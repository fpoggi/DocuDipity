<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title>Secure Publishing using Schema-level Role-based Access Control Policies for Fragments of XML Documents</title><info><confgroup><conftitle>Balisage: The Markup Conference 2008</conftitle><confdates>August 12 - 15, 2008</confdates></confgroup><abstract><para> Popularity of social networks is growing rapidly and secure publishing is an important implementation tool for these networks. At the same time, recent implementations of access control policies (ACPs) for sharing fragments of XML documents have moved from distributing to users numerous sanitized sub-documents to disseminating a single document multi-encrypted with multiple cryptographic keys, in such a way that the stated ACPs are enforced. Any application that uses this implementation of ACPs will incur a high cost of generating keys separately for each document. However, most such applications, such as secure publishing, use similar documents, i.e. documents based on a selected schema. This paper describes RBAC defined at the schema level, (SRBAC), and generation of the minimum number of keys at the schema level. The main advantage of our approach is that for any application that uses a fixed number of schemas, keys can be generated (or even pre-generated) only once, and then reused in all documents valid for the given schema. While in general, key generation at the schema level has to be pessimistic, our approach tries to minimize the number of generated keys. Incoming XML documents are efficiently encrypted using single-pass SAX parsing in such a way that the original structure of these documents is completely hidden. We also describe distributing to each user only keys needed for decrypting accessible nodes, and for applying the minimal number of encryption operations to an XML document required to satisfy the protection requirements of the policy.</para></abstract><author><personname><firstname>Tomasz</firstname><surname>Müldner</surname></personname><personblurb><para>Tomasz Müldner is a professor of computer science at Acadia University in Nova Scotia, one of Canada's top undergraduate universities. He has received numerous teaching awards, including the prestigious Acadia University Alumni Excellence in Teaching Award in 1996. He is the author of several books and numerous research papers. Dr. Müldner received his Ph.D. in mathematics from the Polish Academy of Science in Warsaw, Poland in 1975.  His current research includes XML compression and encryption, and website internationalization.</para></personblurb><affiliation><jobtitle>Professor</jobtitle><orgname>Jodrey School of Computer Science, Acadia University</orgname></affiliation><email>tomasz.muldner@acadiau.ca</email></author><author><personname><firstname>Robin</firstname><surname>McNeill</surname></personname><personblurb><para>Robin McNeill graduated in May of 2008 with a Bachelor of Computer Science degree at Acadia University. He will be returning to Acadia University for the following academic year as a graduate student pursuing his masters degree in computer science.</para></personblurb><affiliation><jobtitle>Graduate Student</jobtitle><orgname>Jodrey School of Computer Science, Acadia University</orgname></affiliation><email>063637m@acadiau.ca</email></author><author><personname><firstname>Jan</firstname><othername>Krzysztof</othername><surname>Miziołek</surname></personname><personblurb><para>Jan Krzysztof Miziołek works for the University of Warsaw, Poland. Dr. Miziołek received his Ph.D. in mathematics from Technical University of Lodz, Poland in 1981. He worked on design and implementation of a high-level programming language, LOGLAN-82. His current research includes XML compression and encryption.</para></personblurb><affiliation><jobtitle>Director</jobtitle><orgname> Computing Services Centre for Studies on the Classical Tradition in Poland and East-Central Europe, University of Warsaw, Warsaw, Poland</orgname></affiliation><email>jkm@ibi.uw.edu.pl</email></author><legalnotice><para>Copyright © 2008 Tomasz Müldner, Robin McNeill, and Jan Krzysztof Miziołek</para></legalnotice><keywordset role="author"><keyword>Secure access</keyword><keyword>Social networks</keyword><keyword>Encryption</keyword><keyword>XML Schema</keyword></keywordset></info><section><title>Introduction</title><para>Recent years have seen the <emphasis role="ital">eXtensible Markup Language (XML)</emphasis> expand beyond its origins as a standard for web document authoring to become widely embraced as a data encoding format.  For example, the most recent releases of commercial database systems include utilities for exporting relational data sets into XML format to facilitate data exchange.  This trend has naturally motivated researchers to investigate fine-grained (i.e., element-level) access control models for XML data sets.  While early approaches employed server-side techniques such as materialized security views and query re-writing, there has been some concern as to whether such approaches can scale up to handle applications involving thousands of users and/or complex access control policies.  More recently, attention has been focused on <emphasis role="ital">secure publishing </emphasis>solutions, in which an XML document is made accessible to all users (e.g., by hosting it on an HTTP server) through possibly insecure channels. The desired <emphasis role="ital">access control policy (ACP)</emphasis> is enforced by encrypting regions of the document using cryptographic keys. Each user is assigned, through a secure channel, a set of keys (a keyring) corresponding to the permissions they have been granted under the access control policy, which allows them to decrypt exactly a document fragment consisting of element nodes they have been granted access to.  There are two crucial issues to note under this scenario: (1) the access control policy is only capable of enforcing read operations, as there is nothing preventing an authorized user from altering a data field once they have decrypted it and republishing a new version, and (2) the document owner (author) relinquishes control over the document once it has been published: consequently, any changes to the access control policy, or to the contents of the document can only be imposed by publishing a new version of the document.</para><para>
While secure publishing approaches can overcome many of the performance limitations of earlier approaches, some care has to be taken in their implementation to ensure scalability.  A naive attempt to enforce an ACP may use <emphasis role="ital">super-encryption</emphasis>, where elements residing in the intersection of two or more document paths in an ACP are encrypted with multiple keys, which greatly increases the number of expensive encryption and decryption operations. We use a more efficient <emphasis role="ital">multi-encryption </emphasis>strategy, in which every node is encrypted with a <emphasis role="ital">single</emphasis> key.  Additionally, a naive implementation may end up assigning many keys, effectively trading the problem of view explosion for key proliferation. Key generation is expensive, and requiring each user to handle multiple keys complicates key management.  Hence, one seeks to minimize the number of keys required to enforce a particular access control policy. Since nowadays many documents conform to one or more schemas, it would be more efficient to generate keys once, at the schema level, and then re-use them for multi-encrypting documents valid in those schemas.</para><para>
<emphasis role="bold">Contributions: </emphasis>In this paper, we address the performance issues alluded to earlier.  Our main contribution is a generalization of key generation to the <emphasis role="ital">schema level</emphasis>, allowing an access control policy to be defined over an entire class of XML documents specified by an XML Schema definition. Specifically, we define SRBAC, Schema-based ACP, based on our specification of grammar paths. This is a departure from previous research on grammar-level ACPs, which have mainly focused on DTDs and require separate key generation for each document valid for the grammar. Our second contribution is a specification of processing the schema S, which generates the keyring K<subscript>S</subscript>, consisting of the minimum number of keys needed. In general, key generation at the schema level has to be pessimistic because it must generate enough keys to correctly encrypt all possible documents valid in the schema. However, because these keys are generated only once, before any document is to be encrypted, the algorithms to determine the minimum number of keys necessary may afford less efficient processing. (This phase roughly resembles program optimization performed by the compiler before the program is executed). Our third contribution is a specification of a <emphasis role="ital">role-available keyring </emphasis> K<subscript>S</subscript>(R) which, for a given role R in the SRBAC policy, consists of keys that will be made available to the user in role R so that this user can access precisely the fragment of any document D, valid in S, allowed by this policy. Our fourth contribution is an <emphasis role="ital">efficient multi-encryption </emphasis> of XML documents in a <emphasis role="ital">single pass </emphasis> (using a SAX parser) in such a way that the decryption of multi-encrypted documents results in a well-formed XML document. The encrypted document hides all of the structure of the original document. While the decrypted documents are no longer valid in the original schema, one may create <emphasis role="ital">sanitized</emphasis> schema (for which such document will be valid), and use them to efficiently apply XML tools, such as XQuery for XML databases. Our current research concentrates on static documents, but using SAX parsing may allow considering streamed XML documents (which will be a focus of future research). Our fifth contribution is a comparison of the efficiency of our approach and super-encryption. Our last contribution is that our key generation technique applies to <emphasis role="ital">any</emphasis> access control model, not only to the role-based model considered in this paper. Note that while encryption is expensive, comparatively speaking, validation is not that expensive and we can't know if a document is valid until it has been completely traversed, so we may perform several costly and wasteful encryptions before discovering that the document is invalid.  In such a case, combining validation and encryption only serves to slow down the validation, while performing two separate passes likely wouldn't take much longer and would avoid wasted encryptions. Therefore, we first validate the document and then encrypt it.
</para><para>
There are various areas where the technique described in this paper can be applied. Besides secure publishing mentioned earlier, it can also be used for areas such as providing secure data to medical organizations or social networks.
</para><para>
This paper is organized as follows. In Section 2, we describe related work. Section 3 describes RBAC at the document level, (DRBAC), and RBAC at the schema level, (SRBAC). In Section 4, we present our main results concerning SRBAC and key generation at the schema level, and briefly describe the implementation. Finally, in Section 5, we provide results of testing, and in Section 6 we describe conclusions and our future work. </para></section><section><title>Related Work </title><para>
The increasing popularity of XML as a data encoding format has forced attention on the problem of controlling access to
XML documents [<xref linkend="mul100"/>]. The majority of approaches to date (e.g. [<xref linkend="mul94"/>],
[<xref linkend="mul108"/>], [<xref linkend="mul107"/>] and [<xref linkend="mul105"/>]) have focused on specification of access control policies at the document level, while a smaller number of proposals have additionally considered expression of policies over an entire class of documents at the schema level. [<xref linkend="mul96"/>] and [<xref linkend="mul98"/>] , [<xref linkend="mul99"/>] specify  systems in which discretionary access control policies can be expressed over an individual XML document, or over a document type definition (DTD) defining a class of XML documents. [<xref linkend="mul106"/>] defines a secure querying method for annotating a DTD with security policies, from which a security view is generated.  This view consists of a sanitized DTD Dv, which contains only the accessible portions of the original DTD D, and a function f, which specifies how to extract accessible data from instance XML documents conforming to D, in such a way that each query result generates a document conforming to Dv.  By hiding f from clients, the schema and data in the original document remain hidden, while clients are able to issue queries on accessible regions using Dv. </para><para>More recent work focuses on the use of XML Schema as the schema specification language, in place of DTDs.
 [<xref linkend="mul103"/>] describes a system which allows role-based access control policies to be defined at either the
 schema or document level.  At the schema level, access permissions are defined on schema objects (definitions of elements). [<xref linkend="mul110"/>] describes RBAC-based policy specifications at the schema level, augmented with policy constraints using Schematron. Note that in all of these works, access control is enforced entirely by a server component, with a customized view of a document, consisting of only the accessible portions of the requested document, being returned to each client in accordance with their access permissions on the original document.  As a customized view must be generated in response to each client access request, in scenarios with complex documents and/or several users, view explosion becomes a problem. </para><para>In contrast, our strategy forgoes reliance on a centralized access control and instead publishes a single (partially-) encrypted copy of each XML document, and relies on public-key cryptography to enforce the desired access control permission.  In this sense, it resembles the work of [<xref linkend="mul107"/>] and [<xref linkend="mul108"/>]. In addition to avoiding the view explosion problem (alluded to earlier) by publishing a single copy of each document, this type of approach is also more suited to deployment within decentralized architectures such as peer-to-peer, as it (1) facilitates the distribution of authentication and access control responsibilities between participating systems, rather than forcing reliance on a centralized component to enforce access control, and (2) is receptive to a variety of document distribution strategies, including broadcast, rather than being restricted to the client pull model. [<xref linkend="mul95"/>]  and [<xref linkend="mul93"/>] describe how to generate keys for documents and for DTDs/Schema; however, since at the schema level some conditions cannot be evaluated, keys must be generated at both the schema and document levels. </para><para>
In this paper, we present key generation at the schema level based on the concept of symbolic grammar paths. In [<xref linkend="mul109"/>], we describe the design of parameterized role access control policies, which has recently been implemented. </para></section><section><title>Access Control Policies</title><para>
This section starts with a definition of ACPs at the document level, and then introduces ACP at the schema level. It also gives several examples that will be used throughout the paper. </para><section><title>Documents and Document Paths</title><para>
In our approach, document fragments, or views, are described using document paths based on XPath [<xref linkend="mul112"/>]. For a document D, by P<subscript>D</subscript> we denote the set of paths in D. We allow disjunctions of document paths, using the | operator. To simplify the process of defining grammar path, we borrow the following two Unix/C conventions: </para><para>

<itemizedlist><listitem><para> parameterless macros may be declared using the #define command, and then called using $macro-name </para></listitem><listitem><para> substitutions of the form
      string<subscript>0</subscript>{string<subscript>1</subscript>, string<subscript>2</subscript>,..., string<subscript>n</subscript>}string</para><para>denote</para><para>
      string<subscript>0</subscript>string<subscript>1</subscript>string | string<subscript>0</subscript>string<subscript>2</subscript>string |...| string<subscript>0</subscript>string<subscript>n</subscript>string
</para><para>
where | denotes the alternative. Nested {} are also supported.</para></listitem></itemizedlist>
</para><para>
For example</para><programlisting xml:space="preserve">
	#define HP	/H/P
	$HP/{a, b, c/{d,e}}
</programlisting><para> stands for </para><programlisting xml:space="preserve">
      /H/P/a | /H/P/b | /H/P/c/d | /H/P/c/e
</programlisting><para xml:id="Ex3.1" xreflabel="Example 3.1">
<emphasis role="bold">Example 3.1. </emphasis></para><para>
Consider a hospital, where there are three types of tests: basic, confidential and very confidential; and each patient has three attributes: name, Id, and perm (the last attribute determines whether or not patients with negative Ids will have access to very confidential tests). The path P: </para><programlisting xml:space="preserve">
	#define hp	/hospital/patient
	P: $hp{/@Id, /basic/text(), /basic, [@Id&lt;"0" AND @perm="true"]/veryConfidential/text()}
</programlisting><para>is a document path for the following document D: </para><programlisting xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-4"?&gt;
&lt;hospital&gt;
	&lt;patient  name="Kay" Id="-1" perm="true" &gt;
		&lt;basic&gt;B1&lt;/basic&gt;
		&lt;confidential&gt;C1&lt;/confidential&gt;
		&lt;veryConfidential&gt;V1&lt;/veryConfidential&gt;
	&lt;/patient&gt;
	&lt;patient  name="Smith" Id="-2" perm="false" &gt;
		&lt;basic&gt;B2&lt;/basic&gt;
		&lt;confidential&gt;C2&lt;/confidential&gt;
		&lt;veryConfidential&gt;V2&lt;/veryConfidential&gt;
	&lt;/patient&gt;
	&lt;patient  name="Zen" Id="200" perm="true" &gt;
		&lt;basic&gt;B3&lt;/basic&gt;
		&lt;confidential&gt;C3&lt;/confidential&gt;
		&lt;veryConfidential&gt;V3&lt;/veryConfidential&gt;
	&lt;/patient&gt;
&lt;/hospital&gt;
</programlisting><para>
The above path P defines a view of D consisting of values of Id for all patients (both attribute and its value), the tagname &lt;basic&gt; and its text values, B1, B2 and B3; and the value of V1.  □ </para><section><title>Document-level Access Control Policies, DRBAC</title><para>
In this section we define document-level RBAC, DRBAC and the related protection requirement. Here, we use a subset of XPath; a path expression p consists of one or more location steps; each location step operates on the child axis.  A path is then of the form p | not p | p1 intersect p2 | p1 union p2 , and its evaluation produces an ordered sequence of nodes. A valid path is any path which does not evaluate to an empty sequence. </para><para>
<emphasis role="bold">Definition 3.1. </emphasis></para><para>
For an XML document D and a finite set Ψ of roles, the document-level RBAC (DRBAC) is a mapping π<subscript>D</subscript>:Ψ→P<subscript>D</subscript> such that π<subscript>D</subscript>(Ψ) covers the set D; i.e., each element of D belongs to at least one document path that occurs in the policy. Often, the mapping π<subscript>D</subscript> is tabulated and shown as a tuple [(R<subscript>1</subscript>, P<subscript>1</subscript>),(R<subscript>2</subscript>, P<subscript>2</subscript>),...,(R<subscript>n</subscript>, P<subscript>n</subscript>)] □ </para><para>
There are various <emphasis role="ital">views </emphasis> of the document D, and each view is defined by π<subscript>D</subscript>(R). The designer of the policy for an XML document D may decide to leave some parts of D unencrypted (accessible to all users) or to make them inaccessible to all users (i.e., to encrypt them, but not to provide the key used for encryption of these nodes to any user). For the former case, the symbol ♥ is used, while for the latter case we use the symbol •. Therefore, the actual definition of the document-level RBAC is that it is pair (π<subscript>D</subscript>, ♦), where ♦ is either ♥ or •.
For simplicity (unless specified otherwise), in the sequel, we omit the second element of this pair, and assume that by default it is always • (i.e. by default, elements of D not covered by D are inaccessible to all users). </para><para>
<emphasis role="bold">Definition 3.2. </emphasis> </para><para>
The document-level protection requirement is said to be satisfied under the following conditions. For an XML document D, a finite set of roles Ψ, and the document-level RBAC π<subscript>D</subscript>:Ψ→P<subscript>D</subscript> a user in role R can access precisely the set π<subscript>D</subscript>(R), and if the policy uses ♥ also those nodes in D which are not covered by any path.  □ </para><para>
<emphasis role="bold">Example 3.2. </emphasis> </para><para xml:id="Ex3.2" xreflabel="Example 3.2">
Consider the document D from [<xref linkend="Ex3.1"/>], and a set of roles Ψ = {Nurse, Physician, Resident, Smith}. We define four document paths: </para><programlisting xml:space="preserve">
	#define hp	/hospital/patient
	#define Sname  	$hp[@name="Smith"]
	ND: $hp{/@Id, [@Id&lt;0]/basic/text()}
	PD: $hp/{@Id, @name, basic/text(), confidential/text(), veryConfidential/text()}
	RD: $hp{/@Id, [@Id&gt;"100" AND @perm= "true"]/veryConfidential/text()}
	SD: $Sname/{@perm, basic/text(), confidential/text(), veryConfidential/text() }
</programlisting><para>
We now define π<subscript>D</subscript> as: [(Nurse, ND), (Physician, PD), (Resident, RD), (Smith, SD)], which gives: </para><itemizedlist><listitem><para>the user in role Nurse access to Ids of all patients, and to the textual content of the basic test for patients whose Id is negative; </para></listitem><listitem><para> the user in role Physician access to Ids and names of all patients, and to the textual content of the basic, confidential and very confidential tests; </para></listitem><listitem><para> the user in role Resident access to Ids of all patients, and to the textual content of the very confidential test for patients whose Id is greater than 100 and perm is set to true;
</para></listitem><listitem><para> the user in role Smith access to permissions, and the textual content of the basic, confidential and very confidential test for these patients whose name is Smith </para></listitem></itemizedlist><para>
Since by default we use the role •, other elements of D are available to nobody. In <xref linkend="fig1"/>, B1, C1, etc. stand for the text contents of the basic tag, confidential tag, etc.; elements accessible to the user in various roles are labeled with dotted boxes containing first letters of the names of these roles; nodes which are not available to any user are not labeled. </para><figure xml:id="fig1" floatstyle="1" xreflabel="Figure 1"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-001.png" width="100%"/></imageobject><caption><para> Labeled document tree for the hospital</para></caption></mediaobject></figure><para>
Let us now use [<xref linkend="Ex3.2"/>] to compare super-encryption and multi-encryption. In the former case, nodes which are on the intersection of document paths would have to be encrypted and then decrypted with several keys. In the latter case, each node will be encrypted and decrypted with a single key. (In Section 6, we provide results of experiments comparing these two techniques.) </para></section></section><section><title> Schemas and Grammar Paths</title><para>
In this paper, we consider schema-oriented XML documents which have to follow the grammar rules specified by an associated schema, rather than schema-less documents which merely have to be well-formed according to the XML language specification [<xref linkend="mul111"/>]. A commonly used grammar description is XML Schema [<xref linkend="mul113"/>], which we also use in this paper. Throughout this paper, by L<subscript>Σ</subscript> we denote the language generated by the schema Σ. Specifically, if Σ is the schema of schemas, i.e. the grammar defining schemas, then L<subscript>Σ</subscript> is the language of all schemas, and for S∈L<subscript>Σ</subscript>, a document D is valid for S iff  D∈L<subscript>S</subscript>. We consider only schemas for which there are no anonymous types (we can do it without a loss of generality because a schema with anonymous types can always have these types replaced by named types.) In the current implementation, we consider only schema with no cycles. By the top-level typename of the schema S, we mean the typename of the root element of any document valid in S. With each schema, we will associate a schema graph. The following examples show two schema and the corresponding graphs. </para><para xml:id="Ex3.3" xreflabel="Example 3.3">
<emphasis role="bold">Example 3.3. </emphasis></para><para>
Consider a reference letter, which provides a specification as to whether or not the letter is confidential, names of a referee and an applicant, and zero, one or more reviews, where each review provides the name of a supervisor, a numeric score, and a comment. The schema T for such a reference letter is given below.
</para><programlisting xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
	&lt;xs:element name="letter" type="LetterType"/&gt;
	&lt;xs:complexType name="LetterType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="referee" type="NameType"/&gt;
			&lt;xs:element name="applicant" type="NameType"/&gt;
			&lt;xs:element name="review" type="ReviewType"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="confidential" type="xs:boolean"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="ReviewType" maxOccurs="unbounded"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="supervisorName" type="NameType"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="score" type="xs:integer"/&gt;
		&lt;xs:attribute name="comments" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="NameType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="first" type="xs:string"/&gt;
			&lt;xs:element name="last" type="xs:string"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</programlisting><para>
Schema graph for the Schema T (see <xref linkend="fig2"/>) replicates nodes that represent elements of the same type. This graph shows <emphasis role="ital">types</emphasis> used in the schema. The alternative representation, used by this paper, (see <xref linkend="fig3"/>) will focus on <emphasis role="ital">element names</emphasis> from the schema, and will <emphasis role="ital">optionally</emphasis> show types of these elements (shown in dotted boxes with gray background). </para><figure xml:id="fig2" floatstyle="1" xreflabel="Figure 2"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-002.png" width="100%"/></imageobject><caption><para> Schema graph for schema T (based on types) </para></caption></mediaobject></figure><figure xml:id="fig3" floatstyle="1" xreflabel="Figure 3"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-003.png" width="100%"/></imageobject><caption><para> Schema graph for schema T (based on element names)</para></caption></mediaobject></figure><para xml:id="Ex3.4" xreflabel="Example 3.4">
<emphasis role="bold">Example 3.4. </emphasis></para><para>
The schema S (see the schema graph in <xref linkend="fig4"/>) is a schema for which the document D from [<xref linkend="Ex3.1"/>] valid. </para><programlisting xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
	&lt;xs:element name="hospital" type="HospitalType"/&gt;
	&lt;xs:complexType name="HospitalType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="patient" type="PatientType" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="PatientType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="basic" type="xs:string"/&gt;
			&lt;xs:element name="confidential" type="xs:string"/&gt;
			&lt;xs:element name="veryConfidential" type="xs:string"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="name" type="xs:string"/&gt;
		&lt;xs:attribute name="Id" type="xs:int"/&gt;
		&lt;xs:attribute name="perm" type="xs:boolean"/&gt;
	&lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</programlisting><figure xml:id="fig4" floatstyle="1" xreflabel="Figure 4"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-004.png" width="100%"/></imageobject><caption><para> Schema graph for schema S</para></caption></mediaobject></figure><para>
In Section 3.1, we defined views of XML documents using document paths. To define views of a schema S, we introduce <emphasis role="ital">grammar paths</emphasis>. For a document D valid in S, a grammar path may be <emphasis role="ital">materialized</emphasis> to produce the document path for D. This way, views of a schema determine views of documents valid in the schema. Here, we consider only absolute paths, but relative paths can be defined in the same way. We denote by Π<subscript>S</subscript> the set of all grammar paths for the schema S.  A triple (schema S, grammar path G, document D valid in S) defines a document path denoted by Π<subscript>S,D</subscript>(G); we refer to this process as a grammar path materialization. </para><para>We start by defining an <emphasis role="ital">atomic grammar path</emphasis>, which is of the form /c<subscript>1</subscript>/c<subscript>2</subscript>/.../c<subscript>n</subscript>. Each c<subscript>i</subscript> is a tag name optionally followed by a predicate in square brackets. (If the predicate is present, then c<subscript>i</subscript> is called the current context node.)  A <emphasis role="ital">predicate</emphasis> is formed using standard Boolean operators: &amp;&amp;, ||, and ! (using standard associativity and precedence rules) and atomic predicates. There are three kinds of atomic predicates:
</para><itemizedlist><listitem><para>equality and inequality comparisons for values of attributes of type string or Boolean </para></listitem><listitem><para>equality and inequality comparisons for the textual content of the current context node, specified using text()
</para></listitem><listitem><para>arbitrary comparisons for values of numerical attributes
</para></listitem></itemizedlist><para>Note that if content of the element is <emphasis role="ital">mixed</emphasis>, i.e. contains both textual content and sub-elements then text() denotes the concatenation of all textual contents of this element. </para><para>
In order to support nested conditions, atomic predicates may also be preceded by one of the following unconditional paths, where the i-th component b<subscript>i</subscript> is a tag name: </para><itemizedlist><listitem><para> /b<subscript>1</subscript>/b<subscript>2</subscript>/.../b<subscript>n</subscript>/; i.e. the absolute path </para></listitem><listitem><para> b<subscript>1</subscript>/b<subscript>2</subscript>/.../b<subscript>n</subscript>/; i.e. the relative path that starts from the current context node
</para></listitem><listitem><para> ../b<subscript>1</subscript>/b<subscript>2</subscript>/.../b<subscript>n</subscript>/; i.e. the relative path that starts from the parent of the current context node
</para></listitem></itemizedlist><para>
Two examples of atomic grammar paths are:
<programlisting xml:space="preserve">
	/H[@x &gt; "1" || @x &lt; "0" &amp;&amp;  @y = "0"]/P[text() = "John"]
	/H/B[../C/@z &gt; "2" || /H/D/text() = "Mary"]/E
</programlisting>
</para><para>
Atomic paths may have conditions involving nested paths, but they specify only a single node. Often it is convenient to specify subtrees, or parts thereof. Therefore, we define a simple grammar path, which is an atomic grammar path followed by a subtree operator of the form: </para><para>
<programlisting xml:space="preserve">
      &lt;text = O3; att = O3; tag = O3&gt;
</programlisting>
</para><para>
where</para><para>
<itemizedlist><listitem><para>all fields (text, att, and tag) may appear in any order (and are separated by ";")
</para></listitem><listitem><para>fields are optional, but at least one must be present </para></listitem><listitem><para>O3 is described below by the following regular expression  </para><para>O1=["*" "+"]; i.e. a character class consisting of * and +</para><para>O2 = (O1 | ".") | ("text" (O1?)); i.e. O1 or "." or "text" optionally followed by O1</para><para>O3 = O2 (","O2)*; ie. one or more O2, separated by";"</para></listitem></itemizedlist>
</para><para>The meaning of subtree operators is explained in [<xref linkend="Ex3.5"/>]. Finally, a <emphasis role="ital">grammar path</emphasis> is an atomic grammar path, or a simple grammar path, or one or more alternatives of such paths. </para><para>For a given schema, a grammar path is valid if it satisfies constraints imposed by the Schema, for example that an element name exists (in the given context), or the attribute value is a correct data type. </para><para xml:id="Ex3.5" xreflabel="Example 3.5">
<emphasis role="bold">Example 3.5. </emphasis></para><para> Below, we use the following terminology: </para><itemizedlist><listitem><para> all descendants of c, meaning all descendants of c, including c; </para></listitem><listitem><para> all proper descendants of c, meaning all descendants of c, excluding c; </para></listitem><listitem><para> children of c, meaning only children of c and not grand-children, etc.
</para></listitem></itemizedlist><para>In all examples given below c is the last component of a simple grammar path: </para><programlisting xml:space="preserve">
  All text descendants of c:					c&lt;text=*&gt;
  All proper text descendants of c:				c&lt;text=+&gt;
  Text child of c (concatenated for mixed content):		c&lt;text=.&gt;
  All text descendants of c that are equal to "the":		c&lt;text="the"*&gt;
  All proper text descendants of c that are equal to "the":	c&lt;text="the"+&gt;
  Concatenated text children of c that is equal to "the":	c&lt;text="the"&gt;
  All attribute descendants of c:				c&lt;att=*&gt;
  All proper attribute descendants of c:			c&lt;att=+&gt;
  All attribute children (attributes) of c:			c&lt;at =.&gt;
  A specific attribute foo of c:				c&lt;att="foo"&gt;
  All "foo" attribute descendants of c:				c&lt;att="foo"*&gt;
  All proper "foo" attribute descendants of c:			c&lt;att="foo"+&gt;
  The tag of c:							c&lt;tag="."&gt; or c
  All element descendants of c:					c&lt;tag=*&gt;
  All proper element descendants of c:				c&lt;tag=+&gt;
  All element children (sub-elements) of c:			c&lt;tag=.&gt;
  A specific tag foo of c:					c&lt;tag = "foo"&gt;
  All element descendants called "foo" of c:			c&lt;tag="foo"*&gt;
  All proper element descendants called "foo" of c:		c&lt;tag="foo"+&gt;
  All descendants of c:						c&lt;*&gt;
  All proper descendants f c					c&lt;+&gt;
  All children of c						c&lt;.&gt;
Finally, some examples of combined fields:
  All proper text descendants of c and all attributes of c:	c&lt;text=*; att =*&gt;
  Attributes foo and goo of c and the tag of c:			c&lt;att = "foo", "goo"; tag =.&gt;
  All element descendants "foo" and "goo" of c, all "hoo" attribute decendants, and the text of c:
   c&lt;tag="foo"*, "goo"*; att="hoo"*; text=.&gt; □
</programlisting><para xml:id="Ex3.6" xreflabel="Example 3.6">
<emphasis role="bold">Example 3.6. </emphasis></para><para>
Below, we provide three grammar paths R, C, and N for the schema T from [<xref linkend="Ex3.3"/>]: </para><para>
<programlisting xml:space="preserve">
	R: /letter[review/score/text() &gt; "7"]/referee/last&lt;text=.&gt;
	C: /letter[!(/referee/last/text() = "Smith" ||
           /referee/last/text() = "Kerry")]&lt;att="comments", "score"&gt;
	N: /letter[@confidential = "false"]/{referee, applicant, review/supervisor}&lt;text=+&gt; |
          /letter[@confidential = "true" &amp;&amp; review/score/text() &gt; "5"
             || applicant/last/text() = "Brown"]/review/supervisor&lt;text=+&gt;
</programlisting>
□
</para><section><title> Schema-level Access Control Policies, SRBAC
</title><para>
In this section we define schema-level RBAC, SRBAC and the related protection requirement. </para><para>
<emphasis role="bold">Definition 3.3. </emphasis> </para><para>
For a schema S, and a set Ψ of roles, an SRBAC policy is a mapping π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript>.□
</para><para xml:id="Ex3.7" xreflabel="Example 3.7">
<emphasis role="bold">Example 3.7. </emphasis></para><para>
For the schema T from [<xref linkend="Ex3.3"/>] we define the SRBAC policy π<subscript>T</subscript>: [(REFEREE, R), (COMMENT, C), (NAME, N)], where R, C and N are grammar paths from [<xref linkend="Ex3.6"/>]. Here: </para><itemizedlist><listitem><para> role REFEREE gives access to last names of referees for reviews with the score greater than 7</para></listitem><listitem><para> role COMMENT gives access to all comments and scores, provided that the referee last name is neither Smith nor Kerry </para></listitem><listitem><para> role NAME gives access to all names for non-confidential letters and for supervisor names provided that the letter is confidential and the score is greater than 5, or last name of the applicant is Brown</para></listitem></itemizedlist><para xml:id="Ex3.8" xreflabel="Example 3.8">
<emphasis role="bold">Example 3.8.  </emphasis></para><para>
For the schema S from [<xref linkend="Ex3.4"/>], we define the SRBAC policy π<subscript>S</subscript>: [(Nurse, N), (Physician, P), (Resident, R), (Smith, S)], where roles N, P, R, and S are defined as follows: </para><programlisting xml:space="preserve">
	#define HP	/hospital/patient
	#define HPN	$HP&lt;att="Id"&gt;
	#define SS  	$HP[@name="Smith"]
	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
	R: $HPN | $HP{/confidential&lt;text=.&gt;, [@Id&gt;"100" &amp;&amp;
		@perm="true"]/veryConfidential&lt;text=.&gt; }
	S: $SS/{@perm, basic&lt;text=.&gt;, confidential&lt;text=.&gt;, veryConfidential&lt;text=.&gt;}
</programlisting><para>
The above SRBAC policy gives the patient Smith access to her data. Existence of multiple patients who should have this kind of access will result in role proliferation. A solution to this problem is to use parameterized roles, and this is the subject of our current research, see [<xref linkend="mul109"/>]. </para><para>
For every document valid in the schema S, a schema-based ACP defines document-based ACP for this document</para><para>
<emphasis role="bold">Definition 3.4. </emphasis></para><para>
For an XML Schema S, instance document D∈L<subscript>S</subscript>, and the schema-based policy π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript>, we define the schema-induced document policy π<subscript>S,D</subscript>:Ψ→P<subscript>D</subscript>,  by materializing grammar paths; i.e. π<subscript>S,D</subscript>(R)= Π<subscript>S,D</subscript>(π<subscript>S</subscript>(R)), for R∈Ψ.□</para><para>
Now, we formulate the schema-level protection requirement in a manner similar to that from Def. 3.2: </para><para>
<emphasis role="bold">Definition 3.5. </emphasis> </para><para>
The <emphasis role="ital">schema-level protection requirement</emphasis> is said to be satisfied under the following conditions. For the schema S, the schema-based ACP π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript> and role R∈Ψ, the user in a role R accessing a document D∈L<subscript>S</subscript>, can read precisely the view π<subscript>S,D</subscript>(R).   □
</para><para>
<emphasis role="bold">Example 3.9. </emphasis></para><para>
For any document D valid in the schema S from [<xref linkend="Ex3.4"/>], grammar paths from [<xref linkend="Ex3.8"/>] will be materialized as follows: </para><para>
<itemizedlist><listitem><para>Π<subscript>S,D</subscript>(N) consists of Ids of all patients, and the textual content of the basic test for patients whose Id is negative </para></listitem><listitem><para> Π<subscript>S,D</subscript>(P)consists of Ids and names of all patients, and the textual content of the basic, confidential and very confidential tests </para></listitem><listitem><para>Π<subscript>S,D</subscript>(R) consists of Ids of all patients, and the textual content of the very confidential test for patients whose Id is greater than 100 and perm is set to true
</para></listitem><listitem><para> Π<subscript>S,D</subscript>(S) gives access to permissions, and the textual content of the basic, confidential and very confidential test for these patients whose name is Smith.
</para></listitem></itemizedlist>
</para><para>
For the specific document D from [<xref linkend="Ex3.1"/>], these materializations will produce respectively paths ND, PD, RD and SD from [<xref linkend="Ex3.2"/>], and so for the policy π<subscript>S</subscript> from [<xref linkend="Ex3.4"/>], the induced policy π<subscript>S,D</subscript> is the policy π<subscript>D</subscript> from [<xref linkend="Ex3.2"/>]. □
</para></section></section></section><section><title>Key Generation and Document Encryption
</title><para>
In this section, we describe key generation at the schema level, and also explain how these keys are used to encrypt documents valid in this schema. As we indicated in the introduction, actions that result in key generation at the schema level may afford less efficient processing because they are performed only once, before any document is to be encrypted. In addition, a typical schema definition (and therefore, its schema graph) is quite small; hence, we assume that that the schema graph is stored as a DOM tree in main memory. However, for multi-encrypting documents (which may be very large), we will only consider single pass, SAX-based parsing. In our approach, we generate keys at the schema level. However, one can also use a <emphasis role="ital">lazy key generation</emphasis>: instead of pre-generating keys at the schema level, key generation will be triggered by the first document to be multi-encrypted. This would generate only the schema-based keys required for multi-encrypting this specific document (and they will be properly recorded). When the subsequent document is to be multi-encrypted, first we would determine if all necessary keys (at the schema level) have already been generated, and only generate any missing keys (at again recorded). </para><para>
We start this section with basic definitions.
Then, we provide our most important result, which is a schema-based key generation algorithm,
and we define schema-based role-accessible keyrings.
Next, we describe an annotated schema and proceed to the second most important algorithm
which uses an annotated schema to efficiently multi-encrypt a document valid in this schema.
Our description will frequently refer to the schema S from [<xref linkend="Ex3.4"/>]
 (which we will call a "running example"), its graph (see <xref linkend="fig4"/>), and grammar paths from [<xref linkend="Ex3.8"/>].</para><section><title>Introduction</title><section><title> Encryption and Keyrings </title><para>
There are two kinds of encryption: symmetric encryption, which uses a shared secret key, and asymmetric encryption, which uses a public-private key pair. For asymmetric encryption, we will call the public key part a <emphasis role="ital">decrypting key</emphasis>, and the private key part an <emphasis role="ital">encrypting key</emphasis>. If it does not lead to confusion, then by a key we mean a decrypting key in an asymmetric encryption and a key in a symmetric encryption. In our approach, we allow either kind of encryption. When asymmetric encryption is used, the user in role R can only decrypt the document fragment. But, with symmetric encryption, they can also encrypt the decrypted m-document. To avoid this problem, the digital signature of the m-document would have to be made available.
</para><para> <emphasis role="bold">Definition 4.1. </emphasis>
</para><para>
A keyring K is a finite set of keys. For an asymmetric encryption, each key is a triple (key name, encrypting key, decrypting key), and for a symmetric encryption it is a pair (key name, key). By K<subscript>S</subscript> we denote a schema-level keyring for the schema S and its policy π<subscript>S</subscript>. □</para></section><section><title> Basic Notations </title><para>
Let us first consider various ways keys may be assigned to documents.
 Since views may be overlapping, we can not assign keys per view.
Indeed, if we did so, then for two overlapping views V<subscript>1</subscript> and V<subscript>2</subscript> we would have two corresponding keys k<subscript>1</subscript> and k<subscript>2</subscript>, and the intersection of the two views would have to be super-encrypted (assigning keys per view would mean that for i=1,2, the user who has access to the view V<subscript>i</subscript> would be given a key k<subscript>i</subscript> and so other options such as encrypting V<subscript>1</subscript> with one key and V<subscript>2</subscript>-V<subscript>1</subscript> with the other key would provide access to the part that is not allowed). What we need to do is to partition the set D (and at the same time each view) into disjoint sets, and then assign one key for each set in this partition. Therefore, for an arbitrary partition {P<subscript>1</subscript>, P<subscript>2</subscript>,...,P<subscript>n</subscript>} of a set D, we need to find a <emphasis role="ital">disjoint partition</emphasis>. One way to achieve this goal is to create all possible differences of intersections of sets in the partition and remaining unions. Note that in our paper by a <emphasis role="ital">partition</emphasis> we mean a family of subsets of a set D that does not necessarily cover D. </para><para>
Here, we work at the schema level, rather than at the document level, but we need to generate keys in such a way that <emphasis role="ital">materialized grammar paths</emphasis> are disjoint. Since set operations for grammar paths (such as a union) are not defined, we now introduce symbolic grammar paths that allow such operations: </para><para><emphasis role="bold">Definition 4.2. </emphasis> </para><para>
Consider a set {P<subscript>i</subscript>: i=1,2,...,k} of grammar paths. By a <emphasis role="ital">symbolic grammar path expression</emphasis> we denote a finite set of string of the form:
<figure xml:id="eq42" floatstyle="1" xreflabel="eq42"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-005.png" width="100%"/></imageobject></mediaobject></figure>

</para><para>
Since document paths support the above mentioned set operations, symbolic grammar paths can be materialized. </para><para>
<emphasis role="bold">Definition 4.3. </emphasis></para><para>
<figure xml:id="eq43" floatstyle="1" xreflabel="eq43"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-006.png" width="100%"/></imageobject></mediaobject></figure>□
</para><para xml:id="Ex4.1" xreflabel="Example 4.1">
<emphasis role="bold">Example 4.1. </emphasis> </para><para>
Consider first two grammar paths from [<xref linkend="Ex3.8"/>], and recalled below: </para><programlisting xml:space="preserve">
	#define HP	/hospital/patient
	#define HPN	$HP&lt;att="Id"&gt;
	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
</programlisting><para>
Here, we have three symbolic grammar paths: N-P, P-N and N*P. To show materializations of the paths, consider the document D valid in S (see <xref linkend="fig1"/>. For this document, we have: </para><figure xml:id="eq44" floatstyle="1" xreflabel="eq44"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-007.png" width="100%"/></imageobject></mediaobject></figure><para>Note that the above materializations cover the same subset of D as materializations of original grammar paths, but unlike the original grammar paths, they are disjoint. □</para></section></section><section><title>Key Generation </title><para>
To generate keys for the schema S one can use the following technique. For every symbolic grammar path, generate a key for that path, and then use these keys to multi-encrypt materializations of document valid in S. However, by following this approach, we would not avoid generating keys for symbolic grammar paths that will always be materialized to <emphasis role="ital">empty document paths</emphasis>. Therefore, we use a different approach, described below. </para><para>
A <emphasis role="ital">target</emphasis> of a grammar path G is a single node in SG, or a node and a subgraph rooted at the node. An <emphasis role="ital">abstract value</emphasis> of G is a list of targets with the associated information about values of conditions that appear in G. Our algorithm finds abstract values of symbolic grammar paths corresponding to grammar paths in the SRBAC policy. We then use these values to avoid generating keys for these symbolic grammar paths whose abstract values are empty. Note that our algorithm additionally avoids creating redundant keys for two or more grammar paths whose abstract values are subsets; for example if the abstract value of G<subscript>1</subscript> is a subset of the abstract value of G<subscript>2</subscript> then the symbolic grammar path G<subscript>1</subscript> - G<subscript>2</subscript> evaluates to empty. Since at the schema level we <emphasis role="ital">do not know values of conditions</emphasis> that appear in grammar paths, we proceed as follows. By a <emphasis role="ital">configuration</emphasis> we refer to a bit-vector that represents true/false values of all conditions that appear in symbolic grammar paths (i.e., if the i-th condition evaluates to true, the i-th bit is set to 1, and 0 otherwise). We annotate every node of the schema graph with the list of pairs of the form (configurations, key).
</para></section><section><title>Configurations</title><para>
A <emphasis role="ital">configuration</emphasis> is a binary value of size k that represents true/false values of conditions. For a given grammar path X and a configuration C, values of all conditions in X are known, and therefore we can find an abstract value of X, which consists of one or more targets for the configuration C. A <emphasis role="ital">configuration index value</emphasis> is the integer decimal value corresponding to the binary value of this configuration. When it does not lead to confusion, we identify a configuration and its index value. Some configurations should be <emphasis role="ital">excluded</emphasis> e.g. if they specify true values for two conditions (involving the same attribute) that cannot be true at the same time (and arbitrary values for other conditions). </para><para>
<emphasis role="bold">Algorithm 4.1</emphasis></para><para>
A <emphasis role="ital">condition</emphasis> (with k variables) is a Boolean Expression B(x<subscript>1</subscript>,x<subscript>2</subscript>,...,x<subscript>k</subscript>) built from comparisons of the form: </para><para>
x<subscript>i</subscript> RelationalOperator c; where x<subscript>i</subscript> and a constant c are of the same data type that supports
linear order (such as real or integer) and three standard Boolean operators: and, or and not,
with the standard associativity and precedence rules, and brackets, and a RelationalOperator is one of: &gt;, &lt;, &lt;=, &gt;=, =, !=.
For example, the expression B(x,y): x&gt;"0" &amp;&amp; y&gt;"100" || x&gt;="4" &amp;&amp; !(x="99") is a condition. </para><para>
For given conditions B<subscript>1</subscript>,...,B<subscript>k</subscript> with k variables x<subscript>1</subscript>,x<subscript>2</subscript>,...,x<subscript>k</subscript>, Algorithm 4.1 <emphasis role="ital">tests</emphasis> if for any subset
(i<subscript>1</subscript>,...,i<subscript>m</subscript>) with 0&lt;=m&lt;=k of the set (1,...,n)
the expression of the form D(x<subscript>1</subscript>,x<subscript>2</subscript>,...,x<subscript>k</subscript>) =
B<subscript>i<subscript>1</subscript></subscript>&amp;&amp;B<subscript>i<subscript>2</subscript></subscript>&amp;&amp;...&amp;&amp;B<subscript>i<subscript>m</subscript></subscript>&amp;&amp;!B<subscript>j<subscript>1</subscript></subscript>&amp;&amp;!B<subscript>j<subscript>2</subscript></subscript>&amp;&amp;...&amp;&amp;!B<subscript>j<subscript>r</subscript></subscript> where {j<subscript>1</subscript>,j<subscript>2</subscript>,...,j<subscript>r</subscript>} = {1,2,...,k} - {i<subscript>1</subscript>,i<subscript>2</subscript>,...,i<subscript>m</subscript>}, is a <emphasis role="ital">falsehood</emphasis>; i.e. is false for all variables x<subscript>1</subscript>,x<subscript>2</subscript>,...,x<subscript>k</subscript>.
</para></section><section><title> Finding abstract values</title><para>
An <emphasis role="ital">abstract value</emphasis> of a grammar path G is defined to be a list consisting of the pairs (target, list of configuration ids). If this list contains all non-excluded configurations, then it is omitted. </para><para>
<emphasis role="bold">Algorithm 4.2. </emphasis></para><para>
Input: A schema S, and an SRBAC policy π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript>, where Π<subscript>S</subscript> ={G <subscript>i</subscript>: i=1,2,...,n} is a set of grammar paths, and role R<subscript>i</subscript> is associated with the path G<subscript>i</subscript>. </para><para>
Output: A table called Results storing abstract values of symbolic grammar paths. </para><para>
Outline of the algorithm. While here we say a "table", the actual implementation may use a different, more efficient data structure. However, in our explanation of the algorithm, we will assume that the table is used.
There are two steps of the algorithm: </para><itemizedlist><listitem><para>Create a list E of all non-excluded conditions C that appear in grammar paths in the policy, using Algorithm 4.1 </para></listitem><listitem><para> Compute abstract values of all grammar paths in the SRBAC. (In the description of an abstract value, we skip the list of configuration ids if this list contains every possible configuration.) Here, we compute symbolic products of pairs G<subscript>i</subscript>*G <subscript>j</subscript> and sums G<subscript>i</subscript>+G <subscript>j</subscript>, products and sums of triples, and so on; finally values of symbolic grammar paths. In this process, maintain three tables storing respectively products, sums and resulting grammar paths.
</para></listitem></itemizedlist><para>
In more details, the table Products[i] stores an abstract value of products G<subscript>i<subscript>1</subscript></subscript>*...*G<subscript>i<subscript>j</subscript></subscript> where 1&lt;=i<subscript>1</subscript>&lt;=...&lt;=i<subscript>j</subscript>&lt;=n and 1&lt;=j&lt;=k.
Here, the index i is a decimal value of the binary word of size k in which bits at positions i<subscript>m</subscript> are set to 1 and remaining bits are set to 0. For example, for k=4, Products[5] stores an abstract value represented by 0101, i.e. of the product G<subscript>2</subscript>*G<subscript>4</subscript> and Result[5] will store the value of G<subscript>2</subscript>*G<subscript>4</subscript> − (G<subscript>1</subscript>+G<subscript>3</subscript>). </para><para>
Execution of step 2 involves: </para><itemizedlist><listitem><para>compute (and store in arrays Products and Sums) abstract values of all G<subscript>i</subscript>, then products (and sums) of two G<subscript>i</subscript>. If any product is empty then store in Products the value 0 (Empty) for any i-tuple that uses this product. Also, store in Results 0 for symbolic grammar paths that use such products. For example, if G<subscript>2</subscript>*G<subscript>4</subscript> is empty, store 0 in Products at positions 5, and 7 and in Results at the same positions. Note that before any products are computed, we check if the value 0 has already been stored for this product</para></listitem><listitem><para> repeat the above step for triples, etc. In computing unions, use previously computed values; for example to compute G<subscript>1</subscript>+G<subscript>2</subscript>+G<subscript>4</subscript>, we use the value of G<subscript>1</subscript>+G<subscript>2</subscript> which has already been computed.
</para></listitem></itemizedlist><para xml:id="Ex4.2" xreflabel="Example 4.2">
<emphasis role="bold">Example 4.2. </emphasis> </para><para>
In our running example, we have four conditions: </para><para>
C1: (@Id&lt;"0"), C2: (@Id&gt;"100"), C3: (@perm="true") and C4: (@name="Smith") </para><para>
and there are 16 configurations; starting with configuration 0, for which all conditions are false, and ending with configuration 15, for which all conditions are true. Now, consider configuration (1100) with the index value equal to 12. However, C1 and C2 cannot be true at the same time, and so any configuration of the form 11xx is excluded. Therefore, the list of non-excluded configurations consists of integers from 0 to 11, and an abstract value of the grammar path N is (Id, basic/text(), (9,10,11)). </para><para>
Abstract values of all symbolic grammar paths are shown below (starting with abstract values of four paths), using the following abbreviations: </para><itemizedlist><listitem><para> I : {1,3,5,9,11}</para></listitem><listitem><para> B : basic/text()</para></listitem><listitem><para> C : confidential/text()</para></listitem><listitem><para> V : veryConfidential/text()</para></listitem></itemizedlist><programlisting xml:space="preserve">
	{N} = &lt;Id, (B,8,9,10,11)&gt;
	{P} = &lt;name,Id,B,C,V&gt;
	{R} = &lt;Id, C, (V,6,7)&gt;
	{S} = &lt;(B,I), (V,I), (C,I), (Perm,I)&gt;

	Results[1] = S-(P+R+N) = (perm,I)
	Results[2] = R-(N+P+S) = 0
	Results[3] = R*S-(P+N) = 0
	Results[4] = P-(N+R+S) = &lt;name,(B,0,2,4,6),(V,0,2,4,8,10)&gt;
	Results[5] = P*S-(N+R) = &lt;(B,1,3,5,7),(V,I)&gt;
	Results[6] = P*R-(N+S) = &lt;(C,0,2,4,6,8,10),(V,6)&gt;
	Results[7] = P*R*S-N = &lt;(C,I), (V,7)&gt;
	Results[8] = N-(P+R+S) = 0
	Results[9] = N*S-(P+R) = 0
	Results[10] = N*R-(P+S) = 0
	Results[11] = N*P*R-S = 0
	Results[12] = N*P-(R+S) = &lt;B,8,10&gt;
	Results[13] = N*P*S-R = &lt;B,9,11&gt;
	Results[14] = N*P*R-S= &lt;Id&gt;
	Results[15] = N*P*R*S = 0
</programlisting></section><section><title> Schema-based Keyrings and Role-accessible Keyrings </title><para>
For a schema S and a schema-level access control policy π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript>, we use Algorithm 4.1, and for each non-empty value from the table Results, we generate one key. The keyring K<subscript>S</subscript> consists of all keys generated this way. Note that in our running example, out of 16 symbolic grammar paths, only 8 are non-empty. Therefore, where a brute-force approach would generate 16 keys for four roles for our running example, our optimized algorithm will instead generate only 8 keys. Now, we show how for each role R∈Ψ the keyring K<subscript>S</subscript> defines the set K<subscript>S</subscript>(R) of R-accessible keys. A user in role R will be provided with the R-accessible keys so that for any document D valid for S, she can decrypt the view π<subscript>S,D</subscript>(R), where π<subscript>S,D</subscript> is the schema-induced document policy. </para><para>
<emphasis role="bold">Algorithm 4.3. </emphasis> </para><para>
Input: A schema S, a schema-level access control policy π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript> and a role R∈Ψ.
</para><para>
Output: Role R-accessible keyring K<subscript>S</subscript>(R). </para><para>
Method: K<subscript>S</subscript>(R) = {k∈K<subscript>S</subscript> for some symbolic grammar path G, the abstract value of {G} is a subset of the abstract value of the grammar path π<subscript>S</subscript>(R)} □ </para><para xml:id="Ex4.3" xreflabel="Example 4.3">
<emphasis role="bold">Example 4.3. </emphasis></para><para>
For our running example, let us denote by ri a key corresponding to the value of Results[i] which is not empty. Therefore, K<subscript>S</subscript>= {r1, r4, r5, r6, r7, r12, r13, r14}. Two examples of role-accessible keyrings are K<subscript>S</subscript>(Nurse) ={r12, r13, r14}, and K<subscript>S</subscript>(Physician) ={r4, r5, r6, r7, r12, r13, r14}.□ </para><para>
One can show that given a schema-level access control policy π<subscript>S</subscript>:Ψ→Π<subscript>S</subscript> and XML document D valid in S, if the user U in role R is provided only with R-accessible keys created by Algorithm 4.3 then the protection requirement is satisfied; in particular U can access precisely the view V = π<subscript>S,D</subscript>(R). □
</para></section><section><title> Schema Graph Annotations </title><para>
Based on the information stored in the table Results, we now annotate the syntax graph with a list of pairs
(key, list of integers representing configuration index values).
We use ♦ to denote a key for the default role; one of • or ♥.
If the list consists of <emphasis role="ital">all</emphasis> permissible index values, then it is omitted.
The annotated schema graph will be used to guide the process of multi-encrypting an XML document D during its
SAX-based parsing. To annotate the schema graph, we traverse the table Results, and collect information about
 all keys. Next, we traverse the schema graph again, and if the annotation is missing at any node we add the
 annotation of the form (♦). For nodes that have already been annotated, we check if these annotations
contain all permissible index values, if any such values are missing they are added with the default key ♦.
</para><para xml:id="Ex4.4" xreflabel="Example 4.4">
<emphasis role="bold">Example 4.4. </emphasis></para><para>
Consider our running example. To annotate the node "veryConfidential" in the schema graph, we look in Results[] for the value V, and so its annotation is &lt;(r4,0,2,4,8,10), (r5,I), (r6,6), (r7,7)&gt;.  For the complete annotated schema graph see <xref linkend="fig5"/>.</para><figure xml:id="fig5" floatstyle="1" xreflabel="Figure 8"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-008.png" width="100%"/></imageobject><caption><para> Annotated syntax graph for schema S </para></caption></mediaobject></figure></section><section><title> Multi-encryption of Documents </title><para>
The encryption of the document D valid in the Schema S results in single well-defined XML m-document MD, which always has a root element &lt;encrypteddocument&gt;. Each part of the document D that is encrypted with a key "k" will be represented as a child of the &lt;encrypteddocument&gt; node using this format: &lt;edata key = "k"&gt; <emphasis role="ital">encrypted_data</emphasis> &lt;/edata&gt;. Note that the structure of the document D is hidden inside of the <emphasis role="ital">encrypted_data</emphasis> part and is therefore not visible to users who are not authorized to decrypt the document (the &lt;edata&gt; tags are not nested inside of other &lt;edata&gt; tags). The encryption is performed by efficient, single-pass SAX parsing of D (performed in parallel with the traversal of the previously annotated schema graph GS). For each node d of D, the corresponding node s in GS is located, and its annotation is examined to determine which key should be used to encrypt this node (note that at that time we can determine values of all conditions and so we know which configuration should be used; unless nested conditions are used, which require additional treatment). Recall that the same key always encrypts the attribute and its value. </para><para xml:id="Ex4.5" xreflabel="Example 4.5">
<emphasis role="bold">Example 4.5. </emphasis></para><para>
Consider the document D from [<xref linkend="Ex3.1"/>], (see <xref linkend="fig6"/>), in which dotted boxes attached to elements and attributes show the key that is used to encrypt this element. To explain the choice of keys, note that there are three patients; when the attributes of the first patient are processed, we know that that the name is not "Smith", Id is negative, and perm is true, and so the configuration 10 is used. Similarly, configuration 9 is used for the second patient, and configuration 6 for the third one. This information is used to retrieve the key to be used for encryption from the annotated schema graph. </para><figure xml:id="fig6" floatstyle="1" xreflabel="Figure 9"><mediaobject><imageobject><imagedata format="png" fileref="../../../vol1/graphics/Muldner01/Muldner01-009.png" width="100%"/></imageobject><caption><para> Document D and keys used to encrypt this document.</para></caption></mediaobject></figure><para>
The m-document M<subscript>D</subscript> looks like this (assuming that by default ♦ indicates that the node is not available to any user, so the corresponding &lt;edata&gt; nodes are omitted; below, we show details of the leftmost "patient" subtree and leave out other subtrees; encrypted data are also omitted): </para><programlisting xml:space="preserve">
&lt;encrypteddocument&gt;
	&lt;edata key="r4"&gt;...&lt;/edata&gt;
	&lt;edata key="r14"&gt;...&lt;/edata&gt;
	&lt;edata key="r6"&gt;...&lt;/edata&gt;
	&lt;edata key="r2"&gt;...&lt;/edata&gt;
	&lt;edata key="r4"&gt;...&lt;/edata&gt;
&lt;/encrypteddocument&gt;
</programlisting></section><section><title> Decryption of Multi-Encrypted Documents </title><para>
When the user U can prove that is entitled to play role R, she will first obtain the R-accessible keyring K<subscript>S</subscript>(R) via a secure channel, and then proceed to decrypt an m-document M<subscript>D</subscript>, to produce a document M<subscript>D,R</subscript>. The software system available for U will first identify a sub-keyring K1 of K<subscript>S</subscript>(R) consisting of keys needed to decrypt M, and then apply keys available in K1 to perform decryption. The output from the decryption is a single XML document. Given this document, U may use the system to create a sanitized schema (showing only accessible parts of schemas), which would allow them to efficiently apply XML tools, such as XQuery for XML databases. One can show that given a schema-level access control policy and XML document D valid in S, if the user U in role R is provided only with R-accessible keys K<subscript>S</subscript>(R), then the protection requirement is satisfied. □
</para><para xml:id="Ex4.6" xreflabel="Example 4.6">
<emphasis role="bold">Example 4.6. </emphasis></para><para>
 Consider the m-document from [<xref linkend="Ex4.5"/>], using the schema-based ACP policy from [<xref linkend="Ex3.8"/>].
Recall from [<xref linkend="Ex4.3"/>] that K<subscript>S</subscript>(Physician) ={r4, r5, r6, r7, r12, r13, r14}.
Assuming that the user plays the role Physician, the decrypted file will look as follows (note that in this example, tags are encrypted and so their respective values have been concatenated): </para><programlisting xml:space="preserve">
	&lt;encryptedtag name="Kay" Id="-1"&gt;B1C1V1&lt;/encryptedtag&gt;
</programlisting><para>□</para></section><section><title> Implementation </title><para>
Our implementation uses the C++ language, with external libraries to support XML usage and cryptographic functions; specifically the Xerces-C++ XML toolkit from Apache [<xref linkend="mul115"/>], and Crypto++ [<xref linkend="mul116"/>]. First, the schema file is parsed and loaded into memory represented as a tree like structure (a schema graph). Once the tree is constructed, the access control policy file will be parsed and can be validated for semantic correctness against the schema in memory (although this is not currently completed). Lastly, all of the information that the encryption process requires will be saved into a file that can be loaded at a later point in time. Currently, this file is a simple xml file that contains the generated keys, schema graph and annotations, as well as the set of conditions specific in the access control policy. </para><para>
The encryption process works by firstly re-loading (if necessary) the data saved to the xml file back into memory, and next the document to be encrypted is parsed with a SAX parser. Each node in the document will be encrypted in the order they appear in the document, with nodes being queued if there is not enough information available to encrypt them at the time they are first encountered (this can happen when the access control policy specified a condition for this node which cannot be calculated until a node later in the document is parsed). The encryption process is implemented in such a way that the algorithm used to perform the encryption can be changed very easily, so either a symmetric or asymmetric algorithm can be used based on user preference. It is also possible to extend the implementation to provide a run time facility for selecting an encryption algorithm.
</para><para>
Nested paths to arbitrary nodes in conditions are supported through a combination of data caching and a queue. During encryption, each node to be encrypted is added to the end of the <emphasis role="ital">encryption queue</emphasis>. Additionally, if the node is an attribute or text node that is referenced by conditions, the value of this node is cached in the <emphasis role="ital">global value table</emphasis>. The encryption queue is then flushed, by trying to encrypt as many nodes from the front of the queue as possible. A node can only be encrypted and removed from the queue if all of its dependencies are met. A node with no condition has no dependencies, and can be always encrypted. A node with a condition has dependencies, and the global value table is searched to ensure that all dependent attribute and text nodes have values within this table. If any dependent node is missing a value, this node cannot be encrypted, and no further nodes flushed from the queue. Otherwise, the condition can be evaluated (determining the key to use for encryption) and then the node is encrypted.
</para></section></section><section><title> Results of Testing </title><para>
We performed testing of our implementation, comparing the time required to multi-encrypt (and decrypt) against the time spent when super-encryption was used. The detailed description of steps performed in testing is provided below: </para><itemizedlist><listitem><para> For the schema S from [<xref linkend="Ex3.4"/>], we considered the SRBAC policy S from [<xref linkend="Ex3.8"/>]
, and determined the number of keys generated by our implementation.</para></listitem><listitem><para> For the same schema S, we considered two documents valid in this schema; document D from [<xref linkend="Ex3.1"/>] and document D2, which is similar to D (except it had much longer text values and different values of attributes). For both of these document, we also considred the induced DRBAC policies for these documents.
.</para></listitem><listitem><para> For each of the two documents D and D2, we multi-encrypted them four times using our approach, measured the time needed to encrypt, and recorded the average multi-encryption time</para></listitem><listitem><para> For each of the two multi-encrypted documents M<subscript>D</subscript> and M<subscript>D2</subscript>, we decrypted themfour times for all four roles, measured the time needed to decrypt, and recorded the average decryption time</para></listitem><listitem><para> For each of the two documents, we generated keys and super-encrypted these documents by performing the SAX traversal of the document, using the following approach: </para><para>
a) for every node x in the intersection of document paths there is a keyring consisting of m keys (one for each path); and the node x is super-encrypted with all these keys. The user in any role R associated with the path P from the intersection will receive the entire keyring. </para><para>
b) to satisfy the protection requirement, keys are reused based on the following principle. Suppose that in performing the SAX traversal of a document, we have encountered the node x as described above (and generated multiple keys), and then we have encountered the node y in the intersection of the same document paths. Then, the same keyring is used (i.e. no new keys are generated), and the node y is super-encrypted with keys from this keyring. </para></listitem><listitem><para> For each of the two documents D1 and D2, we super-encrypted them using the approach described above, and measured the time needed to encrypt </para></listitem><listitem><para> For each of the two super-encrypted documents M<subscript>D</subscript> and M<subscript>D2</subscript>, we decrypted them four times for all four roles, measured the time needed to decrypt, and recorded the average decryption time </para></listitem></itemizedlist><para>
<emphasis role="bold">Results. </emphasis></para><para>
The total number of keys generated at the schema level was 8, while the number of keys generated at the document level (for super-encryption) was 17 for both documents. The time needed to generate keys at the schema level was 0.0279024. The average time needed respectively for multi-encryption and super-encryption of the document D was 0.0007776830 and 0.0019404000. For the document D2, the average time was 0.0022022350 and 0.0042952375.  The average time needed respectively for decryption for the role Physician for the multi-encrypted and super-encrypted document M<subscript>D</subscript> was 0.00125512 and 0.00368630. For the document M<subscript>D2</subscript>, the average time was respectively 0.00633886 and 0.00972875.</para><para>
<emphasis role="bold">Conclusions. </emphasis> Our testing proved the expected superiority of multi-encryption over super-encryption. Approximately half the keys were generated (although at the schema levels we generate keys for all valid documents). While multi-encryption incurs the initial cost of time spending on key generation, our tests show that on average for multi-encryption, the encryption time and the decryption times were between 30 and 50 percent shorter.
 </para></section><section><title> Conclusions and Future Work </title><para>
In this paper, we provided a description of role-based ACPs for defining permissions for fragments of XML documents, both at the document and the schema level. Using our approach, keys can be generated at the schema level and then only required keys may be assigned to specific documents valid for the schema. A complete system was designed and implemented. </para><para>
Our future work includes full optimization of the algorithm which generates keys at the schema level, removing some restrictions on XML documents, such as IDREF attributes, and designing and implementing re-usability of keyrings when a document or ACP is modified. Also, we will start using our approach to develop secure publishing solutions in areas such as social networks. </para></section><section><title>Acknowledgements</title><para> The algorithm to find excluded configurations was suggested by Raimond Seidel,
Saarbruecken University. Greg Leighton, a PhD student from the University of Alberta provided many useful comments. Finally, the first author would like to acknowledge help of Tommie Usdin in resolving various issues when converting the document in thw Word format to XML.
</para></section><bibliography><title>Bibliography</title><bibliomixed xml:id="mul93" xreflabel="Baldano2002">Baldonado, M., Bertino, E. and Ferrari, E. Secure and Selective Dissemination of XML Documents. ACM Transactions on Information and System Security (TISSEC), 5(3):290–331, (2002). doi:<biblioid class="doi">10.1145/545186.545190</biblioid>.</bibliomixed><bibliomixed xml:id="mul94" xreflabel="Bertino2004">Bertino, E., Carminati, B., Ferrari, E., Thuraisingham B. and A. Gupta. Selective and Authentic Third-Party Distribution of XML Documents. IEEE Transactions on Knowledge and Data Engineering (TKDE), 16(10), 2004, pp. 1263–1278. doi:<biblioid class="doi">10.1109/TKDE.2004.63</biblioid>.</bibliomixed><bibliomixed xml:id="mul95" xreflabel="Bertino2001">Bertino, E., Carminati, B. and Ferrari, E. A temporal key management scheme for secure broadcasting of XML documents. Conference on Computer and Comm. Security. Proc. of the 9th ACM conference on Computer and communications security (2002): 31–40. doi:<biblioid class="doi">10.1145/586110.586116</biblioid>.</bibliomixed><bibliomixed xml:id="mul96" xreflabel="Bertino2002">Bertino, E., Carminati, B. and Ferrari, E. Securing XML Documents with Author-X. IEEE Internet Computing Volume 5, Issue 3 (2001): 21 – 31. doi:<biblioid class="doi">10.1109/4236.935172</biblioid>.</bibliomixed><bibliomixed xml:id="mul97" xreflabel="Cramption2004">Crampton, J. Applying hierarchical and role-based access control to XML documents. Proc. of the 2004 workshop on Secure web service (2004): 37 – 46. doi:<biblioid class="doi">10.1145/1111348.1111353</biblioid>.</bibliomixed><bibliomixed xml:id="mul98" xreflabel="Damiani2005">Damiani, E. De Capitani di Vimercati, S.D.C. and Samarati, P. New paradigms for access control in open environments. Signal Processing and Information Technology, Proc. of the Fifth IEEE International Symposium (2005): 540–545. doi:<biblioid class="doi">10.1109/ISSPIT.2005.1577155</biblioid>.</bibliomixed><bibliomixed xml:id="mul99" xreflabel="Damiani2002">Damiani, E., De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  A Fine-grained Access Control System for XML Documents.  ACM Transactions on Information and System Security,5(2): 169–202,(2002). doi:<biblioid class="doi">10.1145/505586.505590</biblioid>.</bibliomixed><bibliomixed xml:id="mul100" xreflabel="De Capitani2003">De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  Access control: principles and solutions. Software Practice and Experience, Vol, 33, Issue 5 (April 2003): 397–421. John Wiley and Sons, Inc. doi:<biblioid class="doi">10.1002/spe.513</biblioid>.</bibliomixed><bibliomixed xml:id="mul101" xreflabel="Devanbu2001">Devanbu, P., Gertz, M., Kwong, A., Martel, C., Nuckolls, G. and S.G. Stubblebine. Flexible Authentication of XML documents. In Proc. of the 8th ACM Conference on Computer and Communications Security, ACM Press, (2001). doi:<biblioid class="doi">10.1145/501983.502003</biblioid>.</bibliomixed><bibliomixed xml:id="mul102" xreflabel="Ferraiolo2001">Ferraiolo, D.F., Sandhu, R., Gavrila, S., Kuhn, D.S. and Chandramouli, R. Proposed NIST Standard for Role-Based Access Control. ACM Trans. on Information and System Security, 4 (3), (2001), 224–274. doi:<biblioid class="doi">10.1145/501978.501980</biblioid>.</bibliomixed><bibliomixed xml:id="mul103" xreflabel="Fundulaki2004">Fundulaki, I. and Marx, M. Specifying access control policies for XML documents. Proceedings of the ninth ACM symposium on Access control models and technologies (2004) 61 – 69. doi:<biblioid class="doi">10.1145/990036.990046</biblioid>.</bibliomixed><bibliomixed xml:id="mul104" xreflabel="Goel2003">Goel, S K., Clinton, C. and Rosenthal, A. Derived access control specification for XML. Proc. of the 2003 ACM workshop on XML security (2003): 1 – 14. doi:<biblioid class="doi">10.1145/968559.968561</biblioid>.</bibliomixed><bibliomixed xml:id="mul105" xreflabel="Kudo2000">Kudo, M. and Hada S. XML document security based on provisional authorization. Proc. of the 7th ACM conference on Computer and communications security (2000): 87 –96. doi:<biblioid class="doi">10.1145/352600.352613</biblioid>.</bibliomixed><bibliomixed xml:id="mul106" xreflabel="Kuper2005">Kuper, G., Massaci, F. and Rassadko, N. Generalized XML security views. Proc. of the tenth ACM symposium on Access control models and technologies. (2005):77–84. doi:<biblioid class="doi">10.1145/1063979.1063994</biblioid>.</bibliomixed><bibliomixed xml:id="mul107" xreflabel="Miklau2003">Miklau, G. and Suciu, D. Controlling Access to Published Data Using Cryptography, In Proc. of the 29th VLDB Conference, Berlin, Germany, (2003).</bibliomixed><bibliomixed xml:id="mul108" xreflabel="Müldner2006"> Müldner, T., Leighton, G. and Miziolek, J.K. Using Multi-Encryption to Provide Secure and Controlled Access to XML Documents. Extreme Markup Languages 2006, (2006), Montreal, Canada.</bibliomixed><bibliomixed xml:id="mul109" xreflabel="Müldner2008"> Müldner, T., Leighton, G. and Miziolek, J.K. Succinct Access Control Policies for Published XML Datasets. 10th International Conference on Enterprise Information Systems. 12 –16, June 2008, Barcelona, Spain.</bibliomixed><bibliomixed xml:id="mul110" xreflabel="Ramaswamy2003">Ramaswamy C. A Policy Validation Framework for Enterprise Authorization Specification. 19th Annual Computer Security Applications Conference ACSAC, (2003): 319–329. doi:<biblioid class="doi">10.1109/CSAC.2003.1254336</biblioid>.</bibliomixed><bibliomixed xml:id="mul111" xreflabel="XML2008">Extensible Markup Language (XML) 1.0 (Fourth Edition) <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</link>.</bibliomixed><bibliomixed xml:id="mul112" xreflabel="XPath2008">XML Path Language. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath</link>.</bibliomixed><bibliomixed xml:id="mul113" xreflabel="XML-Schema2008">XML Schema <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</link>.</bibliomixed><bibliomixed xml:id="mul114" xreflabel="Zhang2003">Zhang, X., Park, J. and Sandhu, R. Schema based XML Security: RBAC Approach, 17th IFIP 11.3. Working Conference on Data and Application Security, 2003. doi:<biblioid class="doi">10.1007/1-4020-8070-0_24</biblioid>.</bibliomixed><bibliomixed xml:id="mul115" xreflabel="Xerces2008"><link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://xerces.apache.org/xerces-c/</link>.</bibliomixed><bibliomixed xml:id="mul116" xreflabel="Crypto++2008"><link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.cryptopp.com/</link>.</bibliomixed></bibliography></article>