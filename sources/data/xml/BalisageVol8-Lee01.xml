<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>CodeUp: Marking up Programming Languages and the winding road to an XML Syntax.</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>Text markup has a rich history and mature tools and techniques. Programming
                languages however are rarely marked up except to provide embedded documentation. In
                this paper I compare the properties of Text and Programming Languages and suggest
                ways of applying the lessons and tool-chains from the Text Markup tradition to
                Programming Languages, evaluating the value verses the cost and suggest alternative
                approaches to achieving some of the value gained using Text Markup in a Programming
                Language context.</para></abstract><author><personname><firstname>David</firstname><surname>Lee</surname></personname><personblurb><para>David Lee has over 30 years experience in the software industry responsible for many major
                    projects in small and large companies including Sun Microsystems, IBM, Centura
                    Software (formerly Gupta.), Premenos, Epiphany (formerly RightPoint), WebGain,
                    Nexstra, Epocrates, MarkLogic. As Lead Engineer at MarkLogic, Inc., Mr Lee is
                    responsible for maintaining and enhancing the core XML Database server.</para><para>Key career contributions include Real-time AIX OS extensions for optimizing transmission
					of real-time streaming video (IBM), secure encrypted EDI over internet email
					(Premenos), porting the Centura Team Desktop system to Solaris (Gupta, Centura),
					optimizations of large Enterprise CRM systems (Epiphany), author of xmlsh (<link xlink:href="http://www.xmlsh.org/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlsh.org</link> ) an open
					source scripting language for XML.</para></personblurb><affiliation><jobtitle>Lead Engineer</jobtitle><orgname>MarkLogic, Inc.</orgname></affiliation><email>dlee@marklogic.com</email></author><legalnotice><para>Copyright Â© 2012 David A. Lee</para></legalnotice></info><section><title>Why is text marked up?</title><para>In any field the experts can get so good at what they do that the original purpose can get
            lost, or they assume everyone has the same understanding. It can be useful to step back
            and ask 'What are we doing?', 'Why are we doing it?', "Who is the audience for our
            work?", "Are our tools and techniques accomplishing our goals?". </para><para>I started this navel pondering last year and asked first myself, then informally the
            professional groups "Why is text marked up?" "Why not just add to the original text?".
            Immediately these simple questions exposed some assumptions that need clarification
            before answers could be given. </para><section><title>What is 'Text'</title><para>For the purposes of this discussion I will define 'Text' as the 'Written representation of
                natural languages'. This is a narrow definition, but it is what we tend to mean when
                talking about 'Marking up Text'. Furthermore I am jumping forward a few centuries
                and narrow the meaning further to mean 'The machine readable digital encoding of
                written representation of natural human languages' aka Bytes, Characters, Codepoints, Words,
                Sentences, Paragraphs in a computer representation.</para><para>So now that we know what 'Text' is ... what does that imply ? Humans don't natively encode
                their thoughts and language directly (aka telepathically) into computers. They speak
                or write or type onto some media which is then encoded or transcribed into a
                computer. That very process changes the original and loses information. In speech,
                intonation and body expressions are lost when transcribed. In writing the media and
                physical representations (style, color, size, and emphasis) is lost when encoded to
                computer media. Typing via a keyboard generally limits the representation to uniform
                characters. Even before computers this was so natural to humans that the expression
                of language can affect it's meaning that different language is used when speaking
                and writing. Written (and printed) language contains information with the intent of
                adding back things missing from the spoken word in the form of style, font, size,
                spacing, as well usually a clearer and more precise use of language. </para><para>Unlike interactive communication, the nature of Text (and recorded speech) extracts itself
                from time and space. Text is read, it is usually at a different moment in time and a
                different place in space from when it was authored. Since language requires a shared
                understanding, much is inherently lost in text. The reader has indirect access at
                best to the environment or context of the original event. Some of this context is
                recreated in the text itself through dialog, prose, notes and contextual references,
                but requires the author to imagine what context may be lost and provide a
                substitute. This is one reason why ancient texts are more difficult to interpret
                than modern texts; the author was unable to predict and accommodate for the greater
                difference in context of the modern reader.</para></section><section><title>What is the purpose of Text ?</title><para>The purpose of Text, as a representation of natural language, is to express and ideally
                communicate thought. Expressing thought implies an Author. Communicating thought
                implies an Audience. We were taught to "Consider the audience" when writing, but
                that is a difficult and often impossible goal. At best we may consider the Intended
                Audience, but who is to say who may want to read our text in the future and where or
                when that might be? Since we can't embed our entire context in every writing there
                is always an assumption as to the shared understanding of the intended
                audience.</para></section><section><title>Why mark up text?</title><para>Why do we mark up text? Especially digital text and when the markup itself is text, why not
                just add to the text? Marking up text is essentially just adding more text. But it's
                a different sort, it is 'out of band'. It represents a different dimension or layer
                from the text itself. Why do we do this ?</para><para>I asked this question to several groups in the hopes of getting opinions I had not
                previously considered, or at least to clarify my preconceptions. As expected the
                answers varied in detail greatly by the person. Obviously (in hindsight) people mark
                up text for different specific purposes and express these in different degrees of
                abstraction.</para><para>Some example responses indicating a range of  reasoning, edited and out of context for
                brevity:</para><blockquote><para>... [so] that you could have a single document (with markup) and derive
						from it a variety of secondary views that were very different. </para><attribution>Dave Patterson on LinkedIn Groups XML and Related Technologies Network <xref linkend="type-ref-1"/>.</attribution></blockquote><blockquote><para>Because it doesn't tell the whole story. There may be important contextual
					information that could completely change the meaning of the narrative. </para><attribution>Paul Monk on LinkedIn Groups XML and Related Technologies Network <xref linkend="type-ref-2"/>.</attribution></blockquote><blockquote><para>... it separates the "meta" information that was human readable in the style
					into a format that is machine readable ...as a visual encoding format that is
					human readable. </para><attribution>Sean Rushing on LinkedIn Groups XML and Related Technologies Network <xref linkend="type-ref-3"/>.</attribution></blockquote><blockquote><para>... Annotate things, ...add meta-data to a document. And presentation
				    ...</para><attribution>Oscar Vives on xml-dev@lists.xml.org <xref linkend="type-ref-4"/>.</attribution></blockquote><blockquote><para>... for the purpose of extending meaning, suggesting presentation or
				    communicating actions </para><attribution>Philip Fennell on xml-dev@lists.xml.org <xref linkend="type-ref-5"/>.</attribution></blockquote><blockquote><para>Mark-up in retail increases the selling price.  Mark-up in texts increases the value. </para><attribution>Liam Quin  on xml-dev@lists.xml.org<xref linkend="type-ref-6"/>.</attribution></blockquote><blockquote><para>To make explicit for mechanical processing what is implicit-but-evident in the original. </para><attribution>Henry S. Thompson on xml-dev@lists.xml.org<xref linkend="type-ref-7"/>.</attribution></blockquote><blockquote><para>... there was an Original Text that was
				Divinely Inspired by the Goddesses, and that could not be improved upon
				by mortals; the task of the humans was to understand these sacred texts,
				so that a commentary had to distinguish clearly the original and the
				expansion.</para><attribution>Liam Quin on xml-dev@lists.xml.org <xref linkend="type-ref-8"/>.</attribution></blockquote><para>Distilling these responses with my own reasoning I propose the following concepts for why
                we mark up text. The reasons vary by author, context, and purpose. Some reasons are
                complementary and some are contradictory. Yet still we find markup useful.</para><para>
				<itemizedlist><listitem><para>Preserve the original text while adding additional information </para></listitem><listitem><para>Annotate for purposes of presentation </para></listitem><listitem><para>Annotate for purposes of action</para></listitem><listitem><para>Annotate to provide 'layers' of information</para></listitem><listitem><para>Provide for machine readable processing</para></listitem><listitem><para>Allow for production of multiple products from the same source (for
							different media, form factor or audience)</para></listitem><listitem><para>To add information (context) implicit in the original form</para></listitem><listitem><para>To encode text so that it may be semantically analyzed</para></listitem></itemizedlist>
			</para><para>It is relevant to note that many of these reasons only require markup because software to
                date is not smart enough to actually parse and understand natural languages well
                enough. With human consumers, the semantics of text representing "Title",
                "Paragraph", "sentence" "emphasis" are usually quite obvious to the human reader. So
                are generally the more linguistic attributes such as verb, noun, and phonetics. Even
                the context is often known implicitly by the reader, say when reading a book by
                Charles Dickens one may have a reasonably accurate internal model of the Victorian
                period by which to frame the experience.</para><para>Thus much of the value of markup is to encode these things which the primary consumer
                (humans) already knows to make it easier for computer processing.</para></section></section><section><title>Why markup Programming Languages?</title><para>As with Text, consider Programming Languages. Why would we want to markup programming
            languages? If there is missing information why not just add more to the program? Isn't a
            Programming language already marked up? Similar to Text, these simple questions pose
            some implications and assumptions.</para><section><title>What is a Programming Language? </title><para>At first glance, Programming Languages seem an altogether different beast than natural
                Languages. The language is artificial and designed for a single purpose - to
                instruct a computer on how to accomplish a task. All the information necessary for
                this task is already encoded in the language - so what need is there for
                markup?</para><para>The hidden assumption in these questions is that Programming Languages (or rather it's
                textual representation - "The Source Code") have a single target audience - the
                compiler. But this is blatantly untrue. The truth is that Programming Languages not
                only have multiple audiences for multiple purposes but also usually multiple
                authors. So what really is a Programming Language?</para><para>An instance of Programming Language is expressed as one or more text documents which
                comprise "The Source Code". These documents are encoded typically in 'plain text'
                with a limited range of characters available. The syntax of the programming language
                is intended to be humanly readable and writable as well as readable by a computer. </para></section><section><title>What is the purpose of a Programming Language?</title><para>A programming language serves multiple purposes. The obvious purpose is to instruct a
                computer to perform a task. But there are other purposes. A programming language is
                intended to be written and understood by humans. Similar to a text document, there
                is an implicit context in which the language resides which may not be necessary for
                the compiler, but is necessary for humans in authoring, editing, reading and
                understanding the program. </para><para>Different languages recognize and support these purposes to different extents by allowing
                types of markup as part of the language itself. Comments are the main form, but also
                common is markup which may be recognized by the compiler or ancillary programs such
                as pragmas, annotations, and micro-markup within comments such as JavaDoc <xref linkend="JavaDoc"/>, HTML <xref linkend="HTML"/> etc. The syntax of comments and
                micro-markup is specific to each language and generally not interoperable. To make
                things more difficult, languages are often embedded within other languages within
                the same document. For example a Java <xref linkend="Java"/> program which includes
                HTML that has JavaScript <xref linkend="JavaScript"/> , or C <xref linkend="C"/>
                Program with embedded SQL <xref linkend="SQL"/> . The syntax rules for what
                constitutes a comment and where it can be placed can get extremely confusing.
                Furthermore, most markup defined in programming languages is a point, not a
                container; e.g. a comment occurs at some point in the text stream but does not
                explicitly identify it's target (if any) that is to what does the comment refer. It
                is up to humans and convention to decipher the target, scope, and intent.</para></section><section><title>Why markup programming languages?</title><para>Programming languages need to be marked up for generally the same reason as Text. Source
                code is a human readable text document that has many of the same characteristics and
                needs as text for human languages. Reasons for marking up Programming Languages
                include: </para><para>
				<itemizedlist><listitem><para>Preserve the original machine readable program while adding additional
							information for human readers.</para></listitem><listitem><para>Annotate for purposes of presentation ("pretty printing")</para></listitem><listitem><para>Annotate for purposes of action ("TODO, FIXME ...")</para></listitem><listitem><para>Annotate to provide 'layers' of information (Change history,
							rationale, alternative implementations)</para></listitem><listitem><para>Provide for machine readable processing besides compilation (document generation,
                            reassembly of sections, flow analysis, code databases and
                            searching)</para></listitem><listitem><para>Allow for production of multiple products from the same source
							(documentation, program listings, graphs, overviews ...)</para></listitem><listitem><para>To add information (context) implicit in the original form (explanation of algorithms,
                            attributions, clarifications)</para></listitem></itemizedlist>
			</para><para>Programming languages have some pre-existing mechanisms for markup which may suffice for
                some of these needs. Are these sufficient? Is there benefit in learning from the
                concepts, tools, and techniques of Text markup?</para><para>A very significant difference between computer languages and Text is that computer
                processes can already (and must) explicitly extract the semantic meaning of most
                language constructs. The main exception being comments which suffer from the same
                problems as Text, they are not currently readily parsable by computers.</para><para>The problem however, is that even though "The Computer" can parse the semantics of
                a programming language, it greedily hides this information in the bowels of it's
                internal data structure giving no heed to the concept that maybe there might be
                additional consumers who could value from this information. Thus much of this
                information for which Text Markup is required is only needed because Programming
                Language consumers (parsers, compilers etc.) are not designed for any other
                purpose.</para><section><title>Practical uses for Programming Language Markup</title><para>In the previous section we discussed some fairly abstract reasons for marking up
                    software. In practical terms what might this buy us? What kinds of tools and
                    value might we expect if the full semantics of programming languages was
                    available to existing markup processing tool-sets?</para><para>Some concrete examples might include:</para><itemizedlist><listitem><para>Automated reorganization of source files by reliable detection of boundary
                            markers in compilation units</para></listitem><listitem><para>Call-flow and dependency analysis</para></listitem><listitem><para>Data Mining and document management of a large code base to determine
                            possibilities for reuse, rework or discovering difficult to find
                            code</para></listitem><listitem><para>Source level code optimization <xref linkend="XsltOpt"/></para></listitem><listitem><para>Algorithmic analysis of software to help find and fix insecure or inefficient code</para></listitem><listitem><para>Publication of parts or all of codebases in different combinations and media.</para></listitem><listitem><para>License management and auditing.</para></listitem><listitem><para>Detecting potential patentable algorithms.</para></listitem><listitem><para>Validation of the accuracy of documentation and comments with respect to the
                            actual code.</para></listitem><listitem><para>Language independent IDE's that can be used across languages and
                            roles.</para></listitem></itemizedlist></section><section><title>The problem with Programming Language AS a Markup Language</title><para>A common sentiment regarding marking up programming languages is that it is
                    unnecessary because programming languages are themselves a markup language, or
                    at least provide a strict syntax which is computer parsable. There are several
                    problems with this reasoning. A big problem is that the syntax and semantics of
                    programming languages is primarily aimed at one consumer - the compiler. This
                    syntax can be extremely tedious to use for other purposes. In general it
                    requires a complete specific language aware parser to extract the program
                    structure from the syntax. Even extracting comments requires a language aware
                    parser.</para><para>For example, consider this Java snippet:</para><figure><programlisting xml:space="preserve">
System.out.println("This is /* A comment */ or // is this " + /* A comment */ " or // is this ") ; // 
"A comment"</programlisting></figure><para>Or this XQuery statement</para><figure><programlisting xml:space="preserve">           

return &lt;element&gt;
    (: Is this a comment :) { () (: or is this a comment :) } &lt;!-- What about this --&gt;
&lt;/element&gt;

            </programlisting></figure><para>Reliably extracting out the comments from the code is a very tedious task.
                    Furthermore, it is language specific. Every programming language has it's own
                    rules and quirks. Of the same can be said of all languages including XML,
                    however programming languages tend to have non regular structures that are
                    particularly difficult to parse.</para><para>But suppose we could easily parse and extract comments, and identify where they were
                in the code text - what do they mean? By their very nature comments have no explicit
                semantics.  They are just plain text.  The traditional way of handling this is to
                add a kind of micro-format or embedded markup within comments used by particular
                tools.  For example JavaDoc uses a set of special tags as well as HTML to mark up
                portions of the text within comments.   This becomes a very complex 'Russian Doll'
                layering of different markup languages embedded within each other.<footnote><para>It can be argued that this markup is actually all part of JavaDoc and not an actual nesting of
                            markup, however the issues involve with parsing the markup
                            remain.</para></footnote>   Even then, the
                target audience of JavaDoc is limited.  It can be parsed by very few tools and the
                output is limited to few uses.  To target other uses we need different markup - and
                special tools to parse that.  </para><figure xml:id="JavaDoc11"><title>JavaDoc Example</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol8/graphics/Lee01/Lee01-001.jpg" width="75%"/></imageobject></mediaobject><caption><para>Nested markup in JavaDoc</para><para>From Saxon 9.4 source.</para></caption></figure><para>Imagine we decided on a good markup for embedding in comments, there is
                a fundamental limitation imposed by the syntax - they are missing a target. Comments
                appear at a single point in the text stream. There is nothing explicit that
                indicates to what they refer. There are conventions that are generally humanly
                understandable, such as placing a comment preceding a function means it applies to
                that function, but the conventions are easily broken.  </para><para> Consider this simple Java snippet</para><figure><programlisting xml:space="preserve">	            
/*
 * This file implements the PixieDust portion of Magic Products.
 */
 class PixieDust {
 
 // The pixie function
 private int magic = 0;     // Magic 
 public int pixie( int dust )
 { 
       /*
       * Be careful that magic is not set somewhere else
       */
      return ((magic &lt; 10) ? 0 : magic)   + dust ;  // Conditionally add dust
 } 
} 
</programlisting></figure><para>To a human it is fairly clear which comment applies to what. One generally follows
                    the convention that block comments precede their target and inline comments
                    follow their target. But from a parsers perspective it's entirely unclear what
                    comment is associated with which language construct, if any. Note, for example,
                    the comment "The pixie function" immediately precedes the variable declaration
                    for "magic" yet is obvious to human readers that it refers to the function
                    declaration instead. The comment "Be careful that magic is not set somewhere
                    else" doesn't target the following expression exactly, it's a more out of bands
                    annotation concerning the algorithm. We could of course start adding markup in
                    the comments to clarify to what they refer.</para><programlisting xml:space="preserve">              
/*
 *  &lt;file name="pixiedust.java"&gt;This file implements the PixieDust portion of Magic Products.&lt;/file&gt;
 */
 class PixieDust {
 
 
  // &lt;function name="pixie"&gt;The pixie function&lt;/function&gt;

  private int magic = 0;     // &lt;description variable="magic"&gt;Magic &lt;/description&gt;
  int pixie( int dust )
  { 
       /* &lt;annotation&gt;
       * Be careful that magic is not set somewhere else
         &lt;/annotation&gt;
       */
      return ((magic &lt; 10) ? 0 : x)   + dust ;  // Add magic to dust if &gt;= 10 ;  // 
      &lt;explanation reference="((magic &lt; 10) ? 0 : magic)"&gt;Conditionally add dust&lt;/explanation&gt;
      
  }
}
	        </programlisting><para>This is starting to look pretty crazy. Unfortunately this is the essence of what
                implementations of embedded markup in programming languages end up doing.
                Furthermore this is still an extremely fragile binding. Without a full language
                parser available, the comment markup processor has no way of identifying and
                validating the targets. For example, if I wanted to query "Give me the code for
                function 'pixie'" the above markup would not be able to answer that. </para><para>We could go further and try to express the more of the structure in comment markup
                    using containment instead of positioning and named references.</para><figure><programlisting xml:space="preserve"> 
	        
/*
 *  &lt;file name="pixiedust.java"&gt;
 *  &lt;description&gt;This file implements the PixieDust portion of Magic Products.&lt;description&gt;
 */
 class PixieDust {
 // &lt;variable name="magic"&gt;
  int magic = 0;     // &lt;description&gt;Magic&lt;/description&gt;
 // &lt;/variable&gt;  
 // &lt;function name="pixie"&gt;
 // &lt;description&gt;The pixie function&lt;/description&gt;

 int pixie( int dust )
 { 
       /* &lt;annotation&gt;
       * Be careful that magic is not set somewhere else
         &lt;/annotation&gt;
       */
        // &lt;explanation&gt;
        
       return ((magic &lt; 10) ? 0 : magic)   + dust ; //  &lt;description&gt;Conditionally add dust&lt;/description&gt;
      // &lt;/explanation&gt;
 }
 //&lt; /function&gt;
 //&lt;/file&gt;

</programlisting></figure><para>Now we approach a markup, embedded in comments, that has more semantics. it's also
                    redundant and extremely difficult to read, edit, maintain and validate. it's
                    likely that for these reasons markup in programming languages is general limited
                    to embedding documentation. When simply using markup for documentation (as
                    opposed to the above structure) the markup is "close to" the code but it really
                    doesn't markup the code. This is very useful as documentation that is close to
                    the code is generally more likely to be updated and kept in sync but it's really
                    just a way of managing documentation and adds little if any value to the code
                    itself</para><section><title>Pragmas and Annotations</title><para>Another form of programming language markup is Pragmas and Annotations. These
                        are designed to be part of the language itself and thus have semantics as
                        opposed to comments. Java is a good example with a quite expressive
                        annotation capability. The problem with annotations and pragmas however lies
                        specifically with their coupling to the language. Not only are they language
                        specific but have predefined or proprietary semantics and are part of the
                        language itself, rather than meta-data about the language. Thus by adding
                        pragmas or annotations you are changing the program itself; this violates
                        many of the goals of markup in that it changes the underlying
                        semantics.</para><para>It is possible that programming languages could be extended to allow for more
                        structured documentation or markup such as annotations that does not affect
                        the semantics of the program in any way. However this would still require a
                        full language parser and would inherently be language  dependent.</para></section></section><section><title>Making Markup a First Class Citizen</title><para>Much of the problem is imposed on us by trying to work within the existing syntax
                    of the language. Either by using comments which have no semantics and complex
                    nested syntax to support markup, or by annotations which have language defined
                    semantics and so affect the underlying code directly. Instead perhaps we can
                    learn from the lessons Text Markup tradition. </para><para>With Text Markup there is fundamentally the same problem. The original text is
                    preserved while adding additional data or meta-data. The solution used by markup
                    such as XML is to discard the concept that serialized format of the document
                    itself must be the original text. Rather the text is contained within markup
                    instead of putting markup within the text. The markup processor can parse the
                    document, and if desired reproduce the original text exactly. Just as with human
                    languages, this technique allows a single syntax to be used to markup any number
                    of languages and a common tool-chain to process them. This inversion of
                    representation is not without precedent in programming languages. Preprocessors
                    such as cpp and m4 are a similar concept, and language tool-chains typically
                    have the ability to integrate transformation of source documents prior to
                    compilation. Many modern IDE's have the ability to install plug-ins for working
                    with additional document formats while utilizing the full features of the
                    IDE.</para></section></section><section><title>A journey through Literate Programming</title><para>A discussion about marking up programming languages is not complete without consideration of Literate Programming <xref linkend="LitP"/>.</para><para>Literate Programming, as introduced by Donald Knuth, is a very interesting concept. The
                idea is that commentary (prose) is 'interwoven' with code and that a post processing
                phase separates the two into either documentation or source code. This has some
                overlap with the concept of marking up programming language but I feel it is a quite
                different path.</para><para>The perspective I propose is that source code be treated more like Historic or Primary
                documents. That is that the source code is the primary information and that markup
                is annotation or meta-data applied to document.</para><para>This philosophical distinction has practical implications. With Literate Programming the
                source code is "tangled". That is snippets of source code are interspersed
                throughout the prose and not necessarily even in the same order as the final
                resulting program. This has the advantages of providing an emphasis on providing the
                prose as the primary source so let's the reader understand the exposition in a more
                customary way, leaving the actual implementation (the code) as almost a side
                thought.</para><para>This is useful for describing the thought processes of design but I argue that it is
                problematic for the actual engineering of software. The fact is that software source
                code (or rather, compilers) is very particular about the exact representation. It
                takes significant effort to produce source code that is parsed and works exactly as
                intended. Much of this difficulty is in fact the sort of things literate programming
                attempts to hide such as ordering and placement of statements, code blocks, and
                compilation units. I suggest that one reason Literate Programming has not achieved
                wide adoption is that it makes the everyday programmers task more difficult.
                Curiously, similar statements have been made about C++ for example. <quote>C++ is an
                    excellent language for hiding the trivial and mundane details of a program...
                    like where the bugs are.</quote><citation>unknown</citation> I belie tangling
                already difficult to understand code within prose makes the job of both authoring
                and debugging the software harder, not easier.</para><para>With these thoughts in mind I suggest diverging from the Literate Programming perspective
                and instead look to the source code as the primary information, not something to be
                hidden within prose, but rather annotated.</para></section></section><section><title>CodeUp - Marking up Programming Languages with XML</title><para>Considering that it is not a huge technical hurdle to integrate marked up programming
            language documents into the life-cycle of development tools, let's consider what
            possible benefits could be gained and effort and costs would be to apply text markup
            concepts to programming languages.</para><para>"CodeUp" is an experimental family of XML schemas designed to experiment with the
            application of Text Markup techniques to programming language source code. The premise
            is that marking up source code can add value and that programming languages can be
            considered similar text in terms of purpose and techniques. To start we take the initial
            huge leap and decide that like XML based text markup, source code should be contained
            within an XML document structure, as opposed to putting XML markup within the
            programming language syntax. This implies that the marked up document is not directly
            usable by a consumer which assumes the document is syntactically represented as it's
            programming language. Rather, like with text markup, a transformation must be applied to
            the marked up document in order to retrieve the 'original' source document. </para><para>By starting with a minimal markup then proceeding to more complexity we can experiment
            with the value vs costs trade-off implicit with adding markup. Markup involves a cost.
            There is the cost of applying the markup, but in addition there are costs associated
            with maintenance, readability and transformation. The more complex the markup the higher
            the cost. Presumably there comes with higher cost, higher value; but like with text
            markup value is more difficult to measure than cost. One way of describing value is like
            potential energy. The value added by markup is potential, but may not be realized
            depending on the actual use of the content. Thus there is a trade-off between how much
            we are willing to invest in markup compared to the value we hope to extract. The first
            foothold in marking up a source code document in XML is to simply wrap the source in a
            root element. This then gives us a scaffolding by which we can incrementally build more
            complex markup. This is very simple to do but it also immediately exposes us to indirect
            costs. Once we wrap a source code document in even the most simple root element it is no
            longer directly usable by the primary consumer - a compiler! Getting over this first
            step adds significant cost with very little if any value.</para><section><title>Transparent Markup</title><para>A critical requirement for source code markup is that the "original" text needs to be
                preserved. Similar to Text Documents, "original" may be a temporal quality (i.e.
                there existed prior in time an "original" document which is later marked up). But a
                similar case is to consider "original" to mean "what would the text be if there was
                no markup", regardless of which was authored first or authored at the same time. In
                both cases the requirements are the same: the "original" must be unchanged by markup
                and be able to be extracted from a marked up document. The simplest case of this is
                the use of "transparent markup". This is a premise in many text oriented schemas,
                that is the concept that if you remove all markup what is left is the
                "original".</para><para>
                Applying that to CodeUp we can start with the first step, a root element.</para><figure><programlisting xml:space="preserve">	            
&lt;program xmlns="http://xml.calldei.com/codeup"&gt;
/*
* This file implements the Pixie portion of PixieDust Products.
*/

// The pixie function
int x = 0;     // Magic 
int pixie( int dust )
{ 
/*
* Be careful that x is not set somewhere else
*/
return ((x &amp;lt; 10) ? 0 : x)   + dust;  // Conditionally Add dust

}
&lt;/program&gt;
 </programlisting></figure><para>This simple step is easy to apply, and in fact could be programmatically applied
                to a set of source code. There is a complication that the text of the code itself
                may overlap with XML markup; it needs to be escaped with entity escapes or CDATA
                sections, but that is fairly easy to accomplish. CDATA markers can easily be added
                by hand to the beginning and end of the file. A simple text parser or an XML enabled
                GUI tool can accomplish entity encoding easily and risk free. The direct cost of
                adding this markup is practically zero. However it exposes the indirect costs: the
                entire development and compilation ecosystem is now broken. In addition if simple
                hand entering or editing of the source code is done care must be taken to escape
                what was source code but in the context of a marked up document would be
                misinterpreted as markup. More complex escaping may need to be done if the code
                contained XML-like markup to begin with such as JavaDoc with embedded HTML,
                especially if the contained markup itself has CDATA sections or entity encoding. </para><section><title>Compilers</title><para>The most obvious problem is that now any consumer of the source code, such as compilers, which previously expected it to be syntactically identical to the original document is broken.</para><para>That is likely why this approach is rarely taken in practice. However the
                    solution for automated processing (compilers, parsers etc.) is actually quite
                    easy. Most development tool-sets accommodate preprocessing quite easily as a
                    normal and expected procedure. For example in a Makefile or ANT script it is
                    quite easy to add a step which would consume the CodeUp document and produce the
                    original source. A Very simple XSLT <xref linkend="XSLT"/>, XQuery <xref linkend="XQuery"/> or other XML processor could be used.</para><para>The following XSLT is sufficient extracting the data from this example. In fact
                    this is sufficient for any markup which follows the constraints of transparent -
                    that is it removes all markup and leaves the underlying text unchanged.
                    Equivalent to this is using any XML parser and outputting only text
                    nodes.</para><figure xml:id="XSLT1"><title>Simple XSLT for transparent markup</title><programlisting xml:space="preserve">	            
&lt;?XML version="1.0" encoding="UTF-8"?&gt;
&lt;XSL:stylesheet xmlns:XSL="http://www.w3.org/1999/XSL/Transform" version="2.0"&gt;
&lt;XSL:output method="text"/&gt;
&lt;XSL:template match="*"&gt;
    &lt;XSL:value-of select="."/&gt;
&lt;/XSL:template&gt;
&lt;/XSL:stylesheet&gt;
</programlisting></figure><para>Applying this transformation as part of the compilation process is quite
                    simple in most programming environments. A somewhat more complex transformation
                    if source line numbers and filenames are to be preserved, but again the
                    techniques are well known and commonly used in other situations.</para></section><section><title>Editors and IDE's</title><para>Authoring and Editing marked up code is another challenge. Once the code no longer
                    parses as the original source language syntax, any editors or IDE's which are
                    designed for the specific language will no longer work as expected. Simple
                    things like syntax highlighting will be broken. More complex features such as
                    refactoring, class browsing, outlining etc. will not work. This can be a major
                    hurdle to embracing code markup.</para><para>Fortunately the IDE's with the more complex features tend to also have more
                    customization abilities. Eclipse <xref linkend="Eclipse"/> is a prime example
                    which is designed to be extended to multiple languages and syntaxes. Another be
                    possibility is that once code is in XML form, then XML editors can be used as
                    intelligent code editors. In fact the more mark-up applied to source code the
                    more XML editors can be leveraged as software editors. However it is difficult
                    to imagine how a pure XML editor could match the features of a language specific
                    IDE even if every token was marked up. Modern IDE's use incremental compilation
                    and language awareness to do things like method name completion which would be
                    impossible to achieve with static schemas alone. An XML editor using a language
                    schema may be able to know that a <emphasis>for loop</emphasis> needs a body but
                    unless they can reflect on the full parse tree of the whole compilation unit
                    they couldn't for example know what methods a particular instance of an object
                    are public or even what variables are in scope.</para><para>For authors that use less specific editors the opposite is the problem. XML markup
                    itself poses no problems in a text editor, but it also provides no benefit. Much
                    like the authors of Text markup, editing marked up code with non-XML aware
                    editors poses challenges to many authors. For those comfortable authoring with
                    markup syntax the experience may be easy, but for those who are not, the use of
                    a specialized editor or macros in customizable editors (like Emacs <xref linkend="Emacs"/>) may be more
                    productive. </para></section></section><section><title>The rocky road from A Text Syntax to an XML Syntax</title><para>Once we've accomplished the initial step of converting a programing language to an XML Document, and all that entails including editors, IDE's, tool-chains and work-flows we can start to explore the benefits and costs of enriching the markup.</para><para>Continuing under the premise of "Transparent Markup" what can be improved while maintaining the original text as source code?  Much of this can be done as language neutral markup because it is entirely optional.  Strip out the markup and you get the source code.  Markup need only be informative or helpful but need not be semantically perfect.</para><para>Imagine the following 'improvements' to the original sample.<figure><programlisting xml:space="preserve">	            
&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
    &lt;comment scope="file"&gt;
    /*
    * This file implements the PixieDust portion of Magic Products.
    */
    &lt;/comment&gt;
    &lt;class&gt;  
    class PixieDust {
    
    &lt;comment inline="true"&gt;// The pixie function&lt;/comment&gt;
    private int magic = 0;     // Magic 
    &lt;method&gt; 
    public int pixie( int dust )
    { 
      &lt;comment&gt;
      /*
      * Be careful that magic is not set somewhere else
      */
      &lt;/comment&gt;
      return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;// Conditionally 
      add dust&lt;/comment&gt;
    
    } 
    &lt;/method&gt;
    &lt;/class&gt;
}
&lt;/program&gt;

</programlisting></figure></para><para>This begins to add the sort of semantics common in text markup while still being transparent.  The simple XSLT still produces the original source code by stripping all markup, and using an XML IDE starts to provide value in terms of authoring </para><para>For example the following is the Author view in Oxygen <xref linkend="Oxygen"/> <footnote><para>For the purpose of this paper, experiments and samples were implemented
                using Oxygen Author.  This tool provides for fairly simple customization
                using CSS Stylesheets <xref linkend="CSS"/> and supports a "WYSIWYG" style of authoring XML marked
                up documents in addition to a text view.  This is not to propose this tool as
                the solution to the problem of editing, but rather as an example of how
                existing tools XML editors can be leveraged for the purposes of authoring
                and editing software.   This focuses on the language neutrality enabled by a
                consistent markup vocabulary regardless of the underlying programming
                language.  Ideally, if these concepts were embraced a more specialized
                software development  IDE (such as Eclipse) should be able to  provide a more
                enhanced experience.  </para></footnote>with a very simple CSS applied to the schema</para><figure xml:id="Sample2"><title>Oxygen Author mode view of the above source.</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol8/graphics/Lee01/Lee01-002.jpg" width="75%"/></imageobject></mediaobject></figure><section><title>The Dead End of Transparent Markup</title><para>The previous attempt has some valuable markup but still lacks significant semantic
                    value. For example the question "what is the method called 'pixie'" or "To which
                    language element is a comment referring" cannot be answered with only this XML
                    markup. Suppose we go further and embed more of the language semantics within
                    the markup, while still staying with the goal of Transparent markup. Something
                    like this is an obvious next step.<figure><programlisting xml:space="preserve">	            
&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
    &lt;comment scope="file"&gt;
    /*
    * This file implements the PixieDust portion of Magic Products.
    */
    &lt;/comment&gt;
    &lt;class name="PixieDust"&gt;    
    class PixieDust {
    
   &lt;comment inline="true"&gt;// The pixie function&lt;/comment&gt;
   
   &lt;variable scope="private" name="magic" type="int" initializer="0"&gt;
    private int magic = 0;     // Magic 
   &lt;/variable&gt;
   
    &lt;method name="pixie" scope="public" return="int"&gt;
    &lt;parameter name="dust" type="int"/&gt;
    public int pixie( int dust )
    { 

    &lt;comment&gt;
    /*
    * Be careful that magic is not set somewhere else
    */
    &lt;/comment&gt;
        &lt;statement type="return" expression="((magic &amp;lt; 10 ) ? 0 : magic)   + dust"&gt;
        return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;// Conditionally 
        add dust&lt;/comment&gt;
    &lt;/statement&gt;
    } 

    &lt;/method&gt;&lt;/class&gt;
    }
&lt;/program&gt;

</programlisting></figure>
                </para><para>With a little CSS magic Oxygen Author mode displays the additional semantics
                including outlining and collapsing. Using the  XSLT in <xref linkend="XSLT1"/>  the result is the original
                    text.<figure xml:id="Sample3"><title>Oxygen Author mode view of the above source.</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol8/graphics/Lee01/Lee01-003.jpg" width="75%"/></imageobject></mediaobject></figure></para><para>At this point we have captured a significant amount of the language semantics
                    entirely in XML Markup and can indeed perform some semantic queries such as
                    "What is the body of the pixie function" or "What are the method names,
                    parameters and return values in the pixiedust.java file". We could use this
                    information to achieve many of the goals of Markup such as production of
                    different representations, limited semantic queries, publication, aggregation
                    even code refactoring - all using XML tools only.</para><para>Unfortunately to achieve this we have suffered some of the main problems of
                    embedded markup: that of duplication of information, fragility and difficulty
                    authoring, editing and viewing. Also the markup does not embed the full
                    semantics of the language. For example call graphs or object dependencies cannot
                    be generated because the semantics of expressions is not modeled. It seems we
                    have reached a dead-end as it's unlikely software authors are willing to put the
                    effort into this level of markup considering that it's really duplicating the
                    code in two different ways serving the author little gain and adding great
                    effort. Furthermore the chances of the markup being valid over the life-cycle of
                    the program are slim. It would take a very dedicated author to make sure that
                    the entire markup is updated as code is updated and there is no automatic way of
                    validating it without comparing the results of a full language parser against
                    the markup. So in reality the value is negative and the cost is high.</para></section><section><title>Semi-transparent Markup</title><para>Considering the dead end attempting pure transparent markup, let's back up and
                    reconsider the original goals. When we wanted to maintain the integrity of the
                    "original text" of the programming language, perhaps the goal can be achieved by
                    relaxing the concept of "original". Instead, considering we have already added a
                    process of transformation to extract the "original", perhaps it's sufficient
                    that the transformation itself can produce some of the text as a side effect of
                    markup instead of requiring that all output be literal text. As long as the
                    results are identical to the <emphasis>intended</emphasis> original we can
                    consider it semantically equivalent. </para><para>For purposes of this discussion I will call this markup style "Semi Transparent".  That is, a combination of markup and plain text, when transformed with a known transformation is able to produce what would be the "original" text if we did not use markup.</para><para>Consider this simple fragment <programlisting xml:space="preserve">
class PixieDust { body } 
 </programlisting> One could represent this using markup but without duplication by something
                    like <programlisting xml:space="preserve">

&lt;class name="PixieDust"&gt;
body
&lt;/class&gt;
</programlisting></para><para>These two are semantically equivalent.  Using a simple transformation the <emphasis>Intended Text</emphasis> could easily be produced but without duplication of data.</para><para>Expanding on this let's see what the full sample might look like using a
                    semi-transparent markup.</para><para><figure><programlisting xml:space="preserve">

&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
   &lt;comment scope="file"&gt;
   * This file implements the PixieDust portion of Magic Products.
   &lt;/comment&gt;
   &lt;class name="PixieDust"&gt;    
   &lt;comment inline="true"&gt;The pixie function&lt;/comment&gt;
        
   &lt;variable scope="private" name="magic" type="int" initializer="0"/&gt;
   &lt;method name="pixie" scope="public" return="int"&gt;
    &lt;parameter name="dust" type="int"/&gt;
    &lt;comment&gt;
    * Be careful that magic is not set somewhere else
    &lt;/comment&gt;
        &lt;statement&gt;
            return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;Conditionally 
            add dust&lt;/comment&gt;
        &lt;/statement&gt;
   &lt;/method&gt;&lt;/class&gt;
&lt;/program&gt;
 
  </programlisting></figure>               
       
             </para><para>With some more CSS magic Oxygen Author mode displays the additional semantics.  
                <figure xml:id="Sample4"><title>Oxygen Author mode view of the above source.</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol8/graphics/Lee01/Lee01-004.jpg" width="75%"/></imageobject></mediaobject></figure></para><para>A slightly more complex XSLT is required to produce the <emphasis>Intended Text</emphasis>
                <figure><programlisting xml:space="preserve">

&lt;?XML version="1.0" encoding="UTF-8"?&gt;
&lt;XSL:stylesheet xmlns:codeup="http://xml.calldei.com/codeup" 
                xmlns:XSL="http://www.w3.org/1999/XSL/Transform" 
                version="2.0"&gt;
    &lt;XSL:output method="text"/&gt;

    &lt;XSL:template match="codeup:comment"&gt;
        &lt;XSL:if test="@inline"&gt;&lt;XSL:text&gt;// &lt;/XSL:text&gt;&lt;/XSL:if&gt;
        &lt;XSL:if test="not(@inline)"&gt;&lt;XSL:text&gt;/*&lt;/XSL:text&gt;&lt;/XSL:if&gt;
        &lt;XSL:value-of select="text()"/&gt; 
        &lt;XSL:if test="not(@inline)"&gt;&lt;XSL:text&gt;*/&lt;/XSL:text&gt;&lt;/XSL:if&gt;
    &lt;/XSL:template&gt;
    
    &lt;XSL:template match="codeup:variable"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt;  &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;  &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@type"/&gt;
        &lt;XSL:text&gt;  = &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@initializer"/&gt;
         &lt;XSL:text&gt; ;&lt;/XSL:text&gt; 
     &lt;/XSL:template&gt;
    
    &lt;XSL:template match="codeup:class"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt; class &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;{&lt;/XSL:text&gt; 
        &lt;XSL:apply-templates select="node() "/&gt;
        &lt;XSL:text&gt;}&lt;/XSL:text&gt; 
    &lt;/XSL:template&gt;
        
    &lt;XSL:template match="codeup:method"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt; &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@return"/&gt; 
        &lt;XSL:text&gt; &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;(&lt;/XSL:text&gt;
        &lt;XSL:apply-templates select="parameters"/&gt;
        &lt;XSL:text&gt;){&lt;/XSL:text&gt;
        &lt;XSL:apply-templates select="node() except element(parameters)"/&gt;
        &lt;XSL:text&gt;}&amp;#10;&lt;/XSL:text&gt;
    &lt;/XSL:template&gt;

&lt;/XSL:stylesheet&gt;
 
  </programlisting></figure> </para></section></section></section><section><title>Towards a fully XML syntax</title><para>As we can see from Semi-Transparent markup there is an obvious path towards a fully
            XML Syntax. If you can mark up classes, function, variable declarations, statements,
            comments, why stop there? One could envision a markup fully detailing the semantics of
            every aspect of the programming language. A next step might be encoding control flow
            (if/while/switch), and expressions. Is there an obvious end to this path? At what point
            do we achieve a fully XML syntax, and is it even desirable?</para><para>A look to what is considered XML Syntax languages can show the possible results. XSLT,
            for example, is considered an XML Syntax language. But XSLT is not fully marked up!
            Consider this snippet in XSLT 3.0. <figure xml:id="XPath"><title>XPath embedded in XSLT <xref linkend="XPathXSLT"/></title><programlisting xml:space="preserve">
 
 
&lt;?XML version='1.0'?&gt;
&lt;XSL:stylesheet 
    version="3.0" 
    xmlns:XSL="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;XSL:template match="/"&gt;
        &lt;XSL:variable name="f1" select="
            function($x as xs:integer) as (function(xs:integer) as xs:integer){
                    function ($y as xs:integer) as xs:integer{
                        $x*$x + $y * $y
                    }
            }
        "/&gt;
        &lt;XSL:value-of select="$f1(2)(3)"/&gt; 
&lt;/XSL:template&gt;
&lt;/XSL:stylesheet&gt;
                      
            
        </programlisting></figure> Here we have a non-XML syntax child language (XPath 3.0 <xref linkend="XPath3"/>) embedded in a XML syntax language (XSLT). </para><para>XQueryX<xref linkend="XQueryX"/> represents a more "pure" XSLT syntax in that even
            XPath expressions within XQueryX are fully decomposed and marked up as XML. However
            XQueryX is generally considered unreadable and unwritable by humans except in very small
            doses. At some point, adding markup or expressing every semantic detail as markup
            becomes untenable - at-least for humans.</para><para>As an example just the select expression in the above XSLT translated to XQueryX is shown
        <figure xml:id="XQueryXXSLT"><programlisting xml:space="preserve">

&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:inlineFunctionItemExpr&gt;
        &lt;xqx:paramList&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;x&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
        &lt;/xqx:paramList&gt;
        &lt;xqx:typeDeclaration&gt;
          &lt;xqx:parenthesizedItemType&gt;
            &lt;xqx:typedFunctionTest&gt;
              &lt;xqx:paramTypeList&gt;
                &lt;xqx:sequenceType&gt;
                  &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
                &lt;/xqx:sequenceType&gt;
              &lt;/xqx:paramTypeList&gt;
              &lt;xqx:sequenceType&gt;
                &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
              &lt;/xqx:sequenceType&gt;
            &lt;/xqx:typedFunctionTest&gt;
          &lt;/xqx:parenthesizedItemType&gt;
        &lt;/xqx:typeDeclaration&gt;
        &lt;xqx:functionBody&gt;
          &lt;xqx:inlineFunctionItemExpr&gt;
            &lt;xqx:paramList&gt;
              &lt;xqx:param&gt;
                &lt;xqx:varName&gt;y&lt;/xqx:varName&gt;
                &lt;xqx:typeDeclaration&gt;
                  &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
                &lt;/xqx:typeDeclaration&gt;
              &lt;/xqx:param&gt;
            &lt;/xqx:paramList&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
            &lt;/xqx:typeDeclaration&gt;
            &lt;xqx:functionBody&gt;
              &lt;xqx:addOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:multiplyOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;x&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;x&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:multiplyOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:multiplyOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;y&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;y&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:multiplyOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:addOp&gt;
            &lt;/xqx:functionBody&gt;
          &lt;/xqx:inlineFunctionItemExpr&gt;
        &lt;/xqx:functionBody&gt;
      &lt;/xqx:inlineFunctionItemExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;

                
                
                
            </programlisting><caption><para>Translation from XQuery 3.0 to XQueryX <xref linkend="XQueryX2"/></para></caption></figure>
            
        </para><section><title>Further down the path of an XML Syntax</title><para>There is much further we can take this exploration. For examples the comments are
                still unreferenced; they appear inline with code but no clear semantic reference to
                which they refer. That could be solved with cross reference tags. Statements and
                expressions are yet to be fully decomposed. The full syntax of statements and
                expressions could be marked up. If we keep on this path we will end up where XSLT
                and ultimately XQueryX have. A fully semantic markup that in this author's  opinion
                is impractical for human authoring and consumption.</para><para>There is a reason that programming languages are largely expressed using more
                unstructured human readable syntax. That is that humans are ultimately the main
                creators and consumers of the language. Even though a computer has to interpret the
                language, so it must be quite explicit and unambiguous, humans have to write, read,
                maintain, and debug it.</para><para>That doesn't mean there isn't room for improvement. As we have seen with markup
                such as JavaDoc there is still a strong desire to add layers of semantics to
                programming languages. A universal markup for programming languages may well be a
                practical and useful tool.  And possibly some compromise between no markup and fully
                semantically marked up might be a 'sweet spot' for some programming
                languages.</para></section><section><title>The Golden Road (to Unlimited Devotion)</title><para> Like the song of the same name <xref linkend="GoldenRoad"/>, applying markup to
                Programming languages to it's full conclusion may require unlimited devotion. Even
                if every single statement, expression and symbol was marked up the resulting
                information would not include all the information that a compiler understands by
                parsing the plain text due to the compiler understanding the semantics of the entire
                corpus. This means even if we follow the Golden Road to it's end we wont end up with
                the information a language specific parser does. So in a way this seems like a dead
                end road. What can markup gain us? </para><para>
               With Text markup, the data added by markup supplies us with generally not available with the original text.  With Programming Languages, the information contained in the program statements themselves
              is ultimately available, even if deeply hidden in the bowls of the compiler.  Perhaps it is best if that in information be pulled from the compiler's grasp instead of duplicated by markup.
              But what of information the compiler discards, is unaware, or is unimportant to the compiler but useful to humans ?  That may be a realm ripe for markup.
           </para><para>So what information in software and it's incarnation in programming language text
                not available or not of interest to the compiler? Clearly comments and documentation
                come to mind. But there is more</para><para>The very tedium of engineering required to construct a good program, and which the
                compiler assumes but generally not part of the compilers undemanding, or discarded
                as part of the compilation may be ripe for markup: information such as the structure
                of a complex system. What pieces need to go together and what is irrelevant (and may
                be changed). What is the rationale behind seemingly arbitrary choices such as naming
                conventions, compilation units and program source structure. For example in version
                of troff <xref linkend="Troff"/> which I was fortunate enough to port in the mid
                80's from Unix to VMS, the C Source was written (originally ported from PDP11
                assembly) assuming that global variables were aligned in memory in the order
                declared. This was implicit but required by the program and broke in exiting ways on
                VMS where the C compiler ordered variables alphabetically not by declaration order.
                Perhaps Markup may have indicated this requirement?</para><para>Sometimes certain functions, variables and comments should belong together.
                Markup could indicate this where a compiler does not. Functions describing a public
                and private interface could be indicated in languages where the compiler does not
                provide such a facility. There are many areas where the compiler is ignorant but the
                programmer has important knowledge. Markup could be effectively used for these
                situations.</para></section></section><section><title>Conclusion: To Mark up or Not to mark up</title><para>The path to marking up programming languages is neither straight nor objective. There
            are branches along the path that depending on the techniques and goals may or may not be
            easy or valuable. There is certainly pain (cost) to be had by adding markup, but there
            is also potential value. Much of the rationale behind Text markup also applies to
            programming languages and we have shown that similar techniques and tools can be used
            for both. But as with Text, it is a continuum not an absolute. Depending on your effort,
            willingness, perspective and desire for additional value, varying types and amounts of
            markup may be appropriate. Traditional embedded markup can be easily simplified by this
            approach. I have shown that one can approach the problem incrementally - even some
            markup can be valuable yet easy to introduce. The hardest part is accepting and
            implementing the inversion of programming language <emphasis>within</emphasis> markup as
            opposed to markup within the programming language syntax. By placing the language within
            the markup we are able to use standard markup processing tools largely programming
            language agnostic as well as keeping the source relatively clean compared to embedding
            markup within language constructs. Another issue is when markup overlaps the information
            inherent in the programming language itself. It is unlikely that programmers will be
            willing to duplicate information the compiler will understand without the markup.
            Furthermore it is generally a bad engineering practice to duplicate information as the
            multiple versions lead to maintenance issues (two watches rarely show the same
            time).</para><para>On the other hand, existing programing language and markup tools are readily available to accomplish many
            tasks with little effort. XML-centric editors could be used for programming IDE's, with some limits.
            Common programming IDE's can be enhanced with understanding of markup. The compilation
            tool-chain has for decades been easily extendible to transformation of source documents.
            By taking the initial step and effort of tooling up for marked up source there is a wide
            spectrum of value that can be achieved with incremental cost.   But and at what value
            and at what cost ?</para><section><title>Markup for high value and low cost</title><para>Examining what types of markup are required to encode what semantic information
                leads one wondering "is it worth it?". There are some goals with moderate value that
                can be achieved at low cost, but much which can be achieved only with very high cost
                if at all, and the value is debatable.</para><para>Presuming you consider the retooling necessary for wrapping programming languages within markup (inversion) a fixed sunk cost, what goals can be achieved with minimal additional work?</para><section><title>Source Structural Decomposition</title><para>With fairly minor markup, mainly wrapping all classes, methods and their
                    corresponding dependent variable declarations and comments in a kind of
                    structural markup, structural decomposition can be achieved.</para><para>By this I mean you can automatically recognize and reorganize your codebase. This
                    might be useful for bulk refactoring or for presenting a database of searchable
                    code snippets. But how useful and reliable will this actually be? Without full
                    knowledge of dependencies (data, call and usage graphs) and subtle details of
                    the language, reorganizing based on simple source file structural boundaries is
                    fragile. It has some value but also high risk.</para><para>Another use for structural markup is providing an IDE with the ability to do
                    outlining, expansion, collapsing, indexing etc. This is definitely a useful
                    feature. However language specific IDE's commonly provide this feature already.
                    The main advantage of achieving this through markup would be to be able to use a
                    language agnostic editor, such as shown through the examples using Oxygen. But
                    since there exists language specific IDE's that do this as good or better than
                    could be done with simple structural markup alone, it's unlikely a developer
                    would move from a more functional IDE to a less functional one especially
                    considering the cost of adding the markup.</para></section><section><title>Associating comments with language elements</title><para>As discussed previously, it is not at all obvious to a computer parser what
                    comments are associated with which language elements. Even the simple case of
                    "block comments precede the element" and "inline comments are after the element"
                    is frequently incorrect. A human usually has no problems detecting the
                    association but without additional hints (markup) a computer often cannot get
                    this right.</para><para>A little markup (low cost) could provide this association easily by containment.
                    However what value is this? To human readers it's little value because they can
                    already usually associate the comment by context. To commuters it might
                    ultimately be of some, but it's not immediately obvious. Since the compiler
                    cannot readily interpret the comment, other uses need to be found where this
                    association is valuable.</para></section><section><title>Adding additional structure</title><para>Not all necessary structure of a program is available as explicit notation in every
                    programming language. A simple example is the separation of variable declaration
                    and use. Variables generally need to be declared before use but it is up to the
                    engineer to arrange the source such that the compiler sees the declaration
                    first. Markup may aid in making explicit the implicit dependencies of pieces of
                    software in order to create structure beyond that which the language allows.
                    Such a markup structure could facilitate refactoring, dependency analysis and
                    reuse.</para></section></section></section><section><title>Markup with high cost</title><section><title>Semantic Analysis</title><para>The really high value possibilities lie in the area of semantic analysis. For
                    example call graphs, dependency checkers, flow control graphs, algorithmic
                    analysis etc. These are areas that could be of extremely high value.
                    Unfortunately they have high cost in terms of both markup and execution. To do something as simple as a call graph,
                    all expressions and identifiers would need to be marked up. In addition full
                    language semantics would need to be understood in order to resolve overloads,
                    virtual functions, namespaces, indirect calls etc. It is not sufficient to
                    simply mark up every bit of the program; a semantic analysis requires full
                    understanding of the language itself.</para><para>Essentially the entire semantics of the program would need to be marked up and
                available to analysis. To achieve this would require markup as verbose complex as
                XQueryX <xref linkend="XQueryXXSLT"/> as well as a knowledge engine that understands
                the meaning of the language constructs.  </para><para>Experience has shown that people do not want to author in this level of markup.
                    The history of mathematics and programming languages has generally been towards
                    concise and humanly readable syntax. In fact many of the 'pure XML' syntax
                    languages like XSLT and XProc<xref linkend="XProc"/> have active groups
                    attempting to reduce the markup in the language providing for an alternate
                    syntax which does not require the verbosity of XML markup. Furthermore
                    describing the information inferred by a compilation of programming languages is
                    extremely difficult in pure XML vocabularies. So even if the syntax was
                    available to XML tools as fully marked up software, the semantics the
                    representation is difficult.</para></section></section><section><title>Extracting semantics</title><para>As discussed there are a few areas which adding markup may be of little effort and
                add value that is not already explicit in the language. In particular are in areas
                of documentation, comments and higher level structures. However the highest value, as well as the highest
                cost is in the semantics of the underlying language structure which is surfaced by
                the actual language syntax.</para><para>Unlike text however this semantics is entirely computable. Unfortunately it is
                largely inaccessible as it lies in the black hole of the interior of the compiler or
                language specific parser and generally unavailable for other purposes.</para><para>Suppose that were not true.  Suppose that the semantics represented by a program were exposed in a unified syntax such as XML and in a open public schema.  Then most of the high value hoped for by making up programming languages could be achieved instead by extracting the semantic model from the compiler.</para><para>This could lead to a very powerful ecosystem of software analysis not bounded by
                the constraint and narrow vision of the compiler. Such a data model should not be
                difficult to generate by enhancements to existing tools as all the knowledge is
                already available to the compiler. It could be supplemented by additional markup
                within the source and then combined to produce a comprehensive data-model that can
                be stored, queried, analyzed and processed using existing markup tool-chains.</para><para>I propose that the difficult work is in designing such a schema and encoding the
                semantics of the language. Can there be a reasonable schema representing a
                programing language model which is language neutral? Or do different languages need
                their own schemas. Perhaps a tree of schemas with some common representation of
                generic programming language constructs with branches for particular languages. In
                addition, to do semantic analysis requires understanding the semantics of the model
                not just the structure.</para><para>Again we can look to the Text Markup work for design patterns on how to do accomplish this.  The road is still open for inquiring minds and brave souls.</para></section><section><title>Conclusion: Proposals</title><para>I suggest that there is value and small cost in marking up programming languages for
            the purposes of comments, documentation, and most importantly, to make explicit the
            higher level structure of the program which the programming language itself does not
            have the capability to describe. However for annotation which duplicates the information
            inferable from the programming language itself the cost is high and the value is likely
            negative due to inherent problems with information duplication. The method with least
            impact on existing tools is embedded markup within comments. However I suggest that
            since there is high value and fairly low cost, if implemented widely, that the concept
            of Transparent Markup be considered and implemented as an option by tools makers
            (particularly in IDE's).</para><para>However the information contained within the programming language itself is of high
                value outside simply compilation. I propose that it is worthwhile to expose this
                information sourced in the text but only currently available in the compiler as
                explicitly generated data. Compilers should be enhanced to optionally generate
                standardized meta information as a byproduct of compilation.</para><para>The combination of high level source markup, and compiler generated information
                could then be utilized by analysis processes. This presents some key areas for
                future research and consideration.</para><section><title>Standardized Transparent Markup</title><para>A standardized schema or family of schemas for transparent markup should be
                considered. If a standard or convention is developed this may encourage tools makers
                to adopt the concept into IDE's and other components of the software lifecycle. It
                should be a fairly easy task to accept a form of transparent markup - even if only
                to completely ignore it. Simply allowing software to be marked up without
                interfering with the toolchain opens it to more diverse purposes. If built into
                IDE's then problems with escaping special markup characters could be minimized. The
                IDE itself may be able to add some markup based on out of band information such as
                project structure. Rich text editing support could be added for sections which allow
                it such as currently supported in JavaDoc. The co-existence of transparent markup
                with the entire toolchain of software development should be a fairly low cost and
                high value proposal.</para></section><section><title>Standardized In-Comment markup</title><para>If transparent markup is too high a cost, then consider standardiazing in-comment markup similar to JavaDoc.  I feel that in todays cross language environments that a language neutral method of marking up languages is valuable.
              While it is difficult to get perfect parsing/extraction of comments from programming languages, it is not that difficult to get "usually works" extraction of comments.
              For example any line that starts with only punction characters then includes say "@@" could indicate a markup tag.
                  <figure xml:id="InlineMarkup"><programlisting xml:space="preserve">
   // @@Tag  A C or C++ or Java inline comment tag
   /*
    * @@Tag A C or C++ or Java block comment tag
    */
   (: @@Tag An XQuery comment Tag :)
   # A Shell or Perl comment tag
   &lt;!-- @@Tag An XML comment tag --&gt;
 
    </programlisting></figure>
              
              </para><para>The choice of @@ is largely arbitrary. Any similar token that is reasonably
                parsable within language comments could be used, including plain XML or perhaps a
                infrequently used PI like &lt;?CODEUP?&gt; . While this is not as technically desirable
                as pure transparent markup - because of the chance of mis-parsing actual code as
                markup, the cost is significantly lower as it would not impact existing software
                lifecycle (compilers, editors etc.) so may be a pragmatic compromise. </para></section><section><title>Standardized compiler data structure outputs</title><para>Compilers should not be black holes for information. A standard or convention
                for representing the information consumed and produced by compilers should be
                considered. If there was a common data structure defined for representing the
                semantic information derived as a side effect of compilation then compilers could
                output this as part of the compilation process and expose this rich source of data
                for other uses. Designing a structure or schema which can be easily produced by a
                variety of compilers as well as usefully consumed by other processes may be a
                challenging task, but I suggest it is an avenue that could lead to great rewards. </para></section><section><title>Put it all together</title><para>In conclusion I propose that a mixture of additional annotation or markup on
                programming languages, in combination with more visibility to the byproducts of
                compilation together could expose great previously untapped value. More work is
                necessary to investigate and implement real world uses for this hidden knowledge but
                the potential is large. Lets get to work !</para></section></section><bibliography><title>References</title><bibliomixed xml:id="XSLT" xreflabel="XSLT">XSL Transformations (XSLT) <link xlink:href="http://www.w3.org/TR/xslt" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</link></bibliomixed><bibliomixed xml:id="XQuery" xreflabel="XQuery">XQuery 1.0: An XML Query Language <link xlink:href="http://www.w3.org/TR/xquery/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</link></bibliomixed><bibliomixed xml:id="JavaScript" xreflabel="JavaScript">JavaScript aka ECMA-262 <link xlink:href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</link></bibliomixed><bibliomixed xml:id="C" xreflabel="C">The C programming language aka ISO/IEC 9899 <link xlink:href="http://www.open-std.org/JTC1/SC22/WG14/www/standards.html#9899" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.open-std.org/JTC1/SC22/WG14/www/standards.html#9899</link></bibliomixed><bibliomixed xml:id="Java" xreflabel="Java">The Java programming <link xlink:href="http://www.java.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.java.com</link></bibliomixed><bibliomixed xml:id="SQL" xreflabel="SQL">Structured Query Language (SQL) <link xlink:href="http://en.wikipedia.org/wiki/SQL" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://en.wikipedia.org/wiki/SQL</link></bibliomixed><bibliomixed xml:id="Oxygen" xreflabel="Oxygen">Oxygen XML Editor <link xlink:href="http://www.oxygenxml.com/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.oxygenxml.com</link></bibliomixed><bibliomixed xml:id="Eclipse" xreflabel="Eclipse">The Eclipse Foundation <link xlink:href="http://www.eclipse.org/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.eclipse.org/</link></bibliomixed><bibliomixed xml:id="Emacs" xreflabel="Emacs">GNU Emacs <link xlink:href="http://www.gnu.org/software/emacs/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.gnu.org/software/emacs/</link></bibliomixed><bibliomixed xml:id="CSS" xreflabel="CSS">Cascading Style Sheets <link xlink:href="http://en.wikipedia.org/wiki/Cascading_Style_Sheets" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://en.wikipedia.org/wiki/Cascading_Style_Sheets</link></bibliomixed><bibliomixed xml:id="XPath3" xreflabel="XPath">XML Path Language (XPath) 3.0 <link xlink:href="http://www.w3.org/TR/xpath-30/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-30/</link></bibliomixed><bibliomixed xml:id="XProc" xreflabel="XProc">XProc: An XML Pipeline Language <link xlink:href="http://www.w3.org/TR/xproc/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xproc/</link></bibliomixed><bibliomixed xml:id="type-ref-1" xreflabel="XMLLinkedIn1">Dave Patterson on LinkedIn Groups XML and Related Technologies Network, Jan 2012		</bibliomixed><bibliomixed xml:id="type-ref-2" xreflabel="XMLLinkedIn2">Paul Monk on LinkedIn Groups XML and Related Technologies Network, Jan 2012	    </bibliomixed><bibliomixed xml:id="type-ref-3" xreflabel="XMLLinkedIn3">Sean Rushing on LinkedIn Groups XML and Related Technologies Network, Jan 2012	    </bibliomixed><bibliomixed xml:id="type-ref-4" xreflabel="XMLDev1">Oscar Vives on xml-dev@lists.xml.org, 2012-01-19</bibliomixed><bibliomixed xml:id="type-ref-5" xreflabel="XMLDev2">Philip Fennell on xml-dev@lists.xml.org, 2012-01-19</bibliomixed><bibliomixed xml:id="type-ref-6" xreflabel="XMLDev3">Liam Quin on xml-dev@lists.xml.org, 2012-01-19</bibliomixed><bibliomixed xml:id="type-ref-7" xreflabel="XMLDev4">Henry S. Thompson on xml-dev@lists.xml.org, 2012-01-19</bibliomixed><bibliomixed xml:id="type-ref-8" xreflabel="XMLDev5">Liam Quin on xml-dev@lists.xml.org, 2012-01-19</bibliomixed><bibliomixed xml:id="JavaDoc" xreflabel="JavaDoc">JavaDoc <link xlink:href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html</link></bibliomixed><bibliomixed xml:id="HTML" xreflabel="HTML">HyperText Markup Language - HTML 4.01 Specification <link xlink:href="http://www.w3.org/TR/html4/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/html4/</link></bibliomixed><bibliomixed xml:id="XPathXSLT" xreflabel="XPathXSLT">XPath in XSLT <link xlink:href="http://www.stylusstudio.com/tutorials/intro-xslt-3.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.stylusstudio.com/tutorials/intro-xslt-3.html</link></bibliomixed><bibliomixed xml:id="XQueryX" xreflabel="XQueryX">XML Syntax for XQuery 1.0 (XQueryX) <link xlink:href="http://www.w3.org/TR/xqueryx/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xqueryx/</link></bibliomixed><bibliomixed xml:id="XQueryX2" xreflabel="XQueryXApplet">From the Grammar Test page for XQuery 3.0 <link xlink:href="http://www.w3.org/2011/08/qt-applets/xquery30/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/2011/08/qt-applets/xquery30/</link></bibliomixed><bibliomixed xml:id="LitP" xreflabel="LiterateProg">Knuth, Donald E. (1992). <emphasis>Literate Programming.</emphasis> ISBN: 978-0-937073-80-3</bibliomixed><bibliomixed xml:id="GoldenRoad" xreflabel="GoldenRoad">The Golden Road (To Unlimited Devotion)
                <link xlink:href="http://artsites.ucsc.edu/GDead/agdl/goldroad.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://artsites.ucsc.edu/GDead/agdl/goldroad.html</link></bibliomixed><bibliomixed xml:id="Troff" xreflabel="Troff">troff - a text formatting language <link xlink:href="http://en.wikipedia.org/wiki/Troff" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://en.wikipedia.org/wiki/Troff</link></bibliomixed><bibliomixed xml:id="XsltOpt" xreflabel="XsltOpt">Writing an XSLT Optimizer in XSLT <link xlink:href="http://www.saxonica.com/papers/Extreme2007/EML2007Kay01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.saxonica.com/papers/Extreme2007/EML2007Kay01.html</link></bibliomixed></bibliography></article>