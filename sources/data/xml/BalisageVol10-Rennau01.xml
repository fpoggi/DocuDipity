<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>The XML info space</title><info><confgroup><conftitle>Balisage: The Markup Conference 2013</conftitle><confdates>August 6 - 9, 2013</confdates></confgroup><abstract><para> XML-related standards imply an architecture of distributed information which
                integrates all accessible XML resources into a coherent whole. Attempting to capture
                the key properties of this architecture, the concept of an info space is defined.
                The concept is used as a tool for deriving desirable extensions of the standards.
                The proposed extensions aim at a fuller realization of the potential offered by the
                architecture. Main aspects are better support for resource discovery and the
                integration of non-XML resources. If not adopted by standards, the extensions may
                also be emulated by application-level design patterns and product-specific features.
                Knowledge of them might therefore be of immediate interest to application developers
                and product designers. </para></abstract><author><personname><firstname>Hans-Jürgen</firstname><othername/><surname>Rennau</surname></personname><personblurb><para/></personblurb><affiliation><jobtitle>Senior Java developer</jobtitle><orgname>Traveltainment GmbH</orgname></affiliation><email>hrennau@yahoo.de</email></author><legalnotice><para>Copyright © 2013 by the author.  Used with permission.</para></legalnotice><keywordset role="author"><keyword>XML info space</keyword><keyword>property-faced collection</keyword><keyword>XML</keyword><keyword>XPath</keyword><keyword>XQuery</keyword><keyword>XSLT</keyword><keyword>JSON&gt;</keyword><keyword>XDM</keyword><keyword>UDL</keyword></keywordset></info><section><title>Introduction</title><para> The first version of a successful program is not the last one. But the more complex
            the program, the more care is required when making changes. When technologies and the
            underlying standards are concerned, any changes must certainly be based on a deep
            understanding of the status quo. But the nature of the required understanding is not
            obvious. </para><para>In 1938, Albert Einstein and Leopold Infeld published a book about the evolution of
            physics [<xref linkend="einstein"/>]. The focus was on the crucial role played by named
                <emphasis role="ital">concepts</emphasis>, guiding and at times limiting our
            thoughts and understanding. A striking example involves the concepts of "force" and
            "field". At a point in time, the scientific understanding of forces was a sort of
            interaction between two bodies. Then the field was discovered as a new reality, existing
            independently of the presence and absence of bodies. Without this image of a field,
            understanding simply could not have passed beyond a certain point.</para><para> In information technology, named concepts can play an important role in the
            development of industry standards. Fielding [<xref linkend="fielding"/>] gave a detailed
            account how the abstractions of a "resource" and "resource representations" enabled a
            unified vision of the emerging internet and led to the definition of an architectural
            style (REST - Representational State Transfer) which provided guidance in the evaluation
            of proposed changes to the standards.</para><para> How about XML – is it final or in need of a new version? Is there a direction to go?
            This paper proposes a novel abstraction to guide a better understanding of the
            technological reality already created, an abstraction intended to help in the evaluation
            of further steps. The reality implemented by XML technology is very versatile, and
            doubtless many conceptualizations are useful and important. Nevertheless, this paper
            suggests a new concept or image - the info space. The concept evokes a potential which
            is at the same time so large and so much limited by the current state of affairs that
            the perspective of a fuller realization may affect our sense of priorities. The
            remaining sections define the concept, explore the current limitations and suggest steps
            towards an increasing realization of its potential. </para></section><section><title>Experiments and observations</title><para>To get started, we examine a few simple programming tasks and possible solutions using
            XPath. The experience will invite some observations, which we then attempt to translate
            into a concept characterizing the new situation which XML technology has created.</para><section xml:id="experiments" xreflabel="Experiments"><title>Experiments</title><para>Assume we have an XML file (<code>foo.xml</code>) and want to retrieve all
                    <code>countryCode</code> elements, no matter where they occur in the document.
                The following XPath expression does just that:
                <programlisting xml:space="preserve">   doc("foo.xml")//countryCode</programlisting> Now we want to
                detect all <code>countryCode</code> instances that do not contain a valid two-letter
                code according to ISO 3166. As a code dictionary in XML format is available in the
                internet<footnote xml:id="uri-iata"><para>
                      http://www.iso.org/iso/home/standards/country_codes/country_names_and_code_elements_xml.htm
                    </para></footnote>
                we can solve the problem by adding a simple filter expression:
                <programlisting xml:space="preserve">   doc("foo.xml")//countryCode[not(. = doc("http://...")//code]</programlisting>
                When the check should be applied to several files, we only have to replace the first
                step by an expression which yields several documents, rather than a single document:
                <programlisting xml:space="preserve">   (doc("foo.xml"), doc("foo2.xml"))
                 //countryCode[not(. = doc("http://...")//code]</programlisting>
                As there may be many documents to be checked, we introduce a helper resource, an XML
                document listing all documents concerned. The list represents each document by a
                    <code>uri</code> element containing the document URI, which may be a file name
                or an HTTP address. In order to apply the check to all documents found in the
                document list, again we adapt the first step of our navigation:
                <programlisting xml:space="preserve">   doc("docs.xml")//uri/doc(.)
                 //countryCode[not(. = doc("http://...")//code]</programlisting>
                The documents may be found in the file system, an intranet or the internet, and
                their number could be large. If a specific document list has to be created for our
                checking task, this might become inconvenient, too. So we introduce a general
                purpose inventory of document URIs which describes a whole domain of documents, only
                some of which have to be checked in this particular case. We create a
                tree-structured document list in which only the leaf elements are <code>uri</code>
                elements containing a document URI, whereas all inner nodes have the purpose of
                adding structure, implicitly creating groups of documents. All elements - inner
                nodes and <code>uri</code> elements - may have attributes supplying metadata
                pertaining to the document(s) referenced by the element itself or its descendants.
                Schematically, such an inventory might look like this: <programlisting xml:space="preserve">   &lt;doctree&gt;
      &lt;department name="d1"&gt;
         &lt;project name="p1"&gt;
            &lt;xsd&gt; 
               &lt;uri app="a1"&gt;…&lt;/uri&gt; 
               &lt;uri app="a2"&gt;…&lt;/uri&gt; 
            &lt;/xsd&gt;
            &lt;msg&gt;…	
               &lt;uri srv="s1"&gt;…&lt;/uri&gt; 
               &lt;uri srv="s2"&gt;…&lt;/uri&gt; 
            &lt;/msg&gt;…
         &lt;/project&gt;
      &lt;/department&gt;
   &lt;/doctree&gt;</programlisting> Now we can combine the selection of documents and their checking
                into a single expression:
                <programlisting xml:space="preserve">   doc("doctree.xml")//project[@name="p1"]/msg/uri/doc(.)/
                 //countryCode[not(. = doc("http://...")//code]</programlisting>
                A navigation across multiple resources - an inventory, all resources referenced by
                    <code>uri</code> elements which match certain conditions, and finally the code
                dictionary – is achieved by a single expression, without taking actions like opening
                a file and without shifting information from data sources into intermediate
                variables.</para><para> The expression does not only yield the faulty codes; it resolves to the <emphasis role="ital">nodes</emphasis> containing them, which means information <emphasis role="ital">and</emphasis> its location. Assigning the nodes to an XQuery
                variable (<code>$faultyCodes</code>), we can later resume navigation, using those
                nodes as starting points. If the documents contain somewhere a
                    <code>changeLog</code> element, we can collect the change logs of all faulty
                documents:
                <programlisting xml:space="preserve">   $faultyCodes/ancestor::document-node()//changeLog</programlisting>
            </para></section><section><title>Observations</title><para>This little programming experience may give a feeling of handling information in a
                different way than when using a general purpose language like Java or Perl. What was
                different? </para><para> First, we did not "load" resources - we just <emphasis role="ital">addressed</emphasis> them using an expression which was equivalent to the
                complete information content. Compare this to Java code extracting data from a CSV
                file. The equivalence enables us to to use the expression as input to navigation:
                <programlisting xml:space="preserve">   doc("…")//countryCode</programlisting>
            </para><para> Second, navigation can be downward (e.g. "…//..") or upward (e.g.
                "ancestor::...") in a <emphasis role="ital">vertically unbounded</emphasis> way,
                moving from any current location in a single bout down to the very leaves under it
                and up to the very root above it. Compare this to the navigation in an object tree:
                a downward move can only be achieved recursively, one level per invocation, and
                upward navigation is impossible. </para><para> Third, <emphasis role="ital">resource boundaries</emphasis> do not impose a
                resistence to navigation: the effort to enter a different document is not greater
                than the effort to move within the same document. The following expression moves
                down to <code>uri</code> elements, crosses over into the referenced documents and
                continues its path down into that document:
                <programlisting xml:space="preserve">   //uri/doc(.)//countryCode</programlisting>
            </para><para> Fourth, navigation is a <emphasis role="ital">parallel operation</emphasis>,
                multiply rooted and cascading: the starting point may be one or many locations, and
                subsequent steps resume the movement at every location reached by the preceding
                step. This is different from navigation of an object tree, which is a movement from
                single item to single item.</para><para> Fifth, navigation is a <emphasis role="ital">generic operation</emphasis>: the
                inventory, the resources to be checked and the code dictionary have different
                semantics, but they are navigated in the same way. Navigation of an object tree, on
                the other hand, must adapt each single step to object types.</para><para> Summarizing the observations, one perceives a continuous space of information: we
                can enter and leave resources at will, and within them we can move up, down, forward
                and backward in a uniform and effortless way. The space is a sum total of
                information which integrates every single accessible XML document. Within this
                space, every item of information is visible and addressable. </para></section></section><section><title>The XML info space</title><para>This section proposes the notion of an <emphasis role="bold">info space</emphasis> as
            an architecture of distributed information which comprises two models, describing
            content and navigation. The definition of the space is guided by the reality introduced
            by XML technology but, being an abstraction, does in no way depend on XML as its
            implementation. Let us summarize some important properties:</para><section><title>The definition</title><itemizedlist><listitem><para>Space content is decomposable into information items<itemizedlist><listitem><para>The space is an unstructured collection of resources</para></listitem><listitem><para>A resource is a structured collection of items</para></listitem></itemizedlist></para></listitem><listitem><para>Inter-item relationships are well defined<itemizedlist><listitem><para>Items within a resource are related by axes</para></listitem><listitem><para>Items in different resources are related by URI+axes</para></listitem></itemizedlist></para></listitem><listitem><para>Navigation is item-oriented<itemizedlist><listitem><para>Input, output, intermediaries are sets of items</para></listitem><listitem><para>Input, output, intermediaries can reside in multiple
                                    resources</para></listitem></itemizedlist></para></listitem><listitem><para>Navigation is generic</para><itemizedlist><listitem><para>The specification of a movement can be separated from the choice
                                of start items</para></listitem><listitem><para>Any specification of a movement can be applied to any choice of
                                start items</para></listitem></itemizedlist></listitem><listitem><para>Information is well defined</para><itemizedlist><listitem><para>Information is a sequence of items</para></listitem><listitem><para>An item is a component with properties</para></listitem><listitem><para>Semantics and value space of item properties are well
                                defined</para></listitem></itemizedlist></listitem><listitem><para>Information is expressible</para><itemizedlist><listitem><para>Information is expressible as navigation leading to it</para></listitem></itemizedlist></listitem></itemizedlist><para>It is easy to see how all properties are implemented by current XML technology.
                The resources in question are XML documents [<xref linkend="w3c-xml"/>], their
                itemized structure is defined by the node model part of the XDM [<xref linkend="w3c-xdm"/>] (which is more suitable as a substrate for navigation than
                the info set model [<xref linkend="w3c-infoset"/>]), intra-resource relationships
                are defined by XPath axes [<xref linkend="w3c-xpath"/>] and inter-resource
                relationships by the URI standard [<xref linkend="uri"/>]. The navigation model is
                provided by XPath [<xref linkend="w3c-xpath"/>] and XQuery [<xref linkend="w3c-xquery"/>] and the information model by the XDM in its entirety
                    [<xref linkend="w3c-xdm"/>].</para></section><section><title> The limitations</title><para>The URIs of all accessible documents are an unstructured collection of strings.
                There is no built-in way how to navigate this collection, iterate over its members
                or in some other way discover URIs. Document access simply requires beforehand
                knowledge of a document URI. If relying on standard XPath functions only, even file
                directories cannot be inspected in order to discover the files it contains. To throw
                light on this limitation, think of a stock of information distributed over thousands
                of XML documents which are accessible either as local files or via HTTP address.
                While on the one hand it is a fascinating thought that anything within that pool of
                documents can be immediately <emphasis role="ital">addressed</emphasis>, it can
                become a serious problem how to <emphasis role="ital">discover</emphasis> the
                resources: to find out which URI to use. If we compared XML documents to relational
                table rows, the info space would resemble a relational database in which
                    <code>select</code> commands are constrained to specify a primary key. </para></section><section><title> The boundaries</title><para>Given a computing site - which part of the resources of the world are in the info
                space, and which are not? Any resource not accessible via network or file system is
                obviously not within the info space: this is the <emphasis role="ital">physical
                    boundary</emphasis>. But also when physical access is possible, the protocol
                requirements may not be supported by XPath functions providing document access
                (namely the <code>fn:doc</code> function), for example due to the need of supplying
                authorization information or an HTTP body: this is the <emphasis role="ital">API
                    boundary</emphasis>. Those resources which are accessible both physically and
                API-wise can be grouped into two categories: XML documents and other resources. The
                former are in the XML info space, the latter are not: the <emphasis role="ital">media type boundary</emphasis> excludes any non-XML resources.</para></section></section><section><title> Addressing the limitations of the info space </title><para> XPath navigation has a strong part and a weak part. Within-resource movement is
            governed by a powerful model – the application of semantic filters (name test and
            predicates) to structural relationships (navigational axes). Between-resource movement,
            on the other hand, is mainly enabled by the <code>fn:doc</code> function, which resolves
            a URI to the corresponding document. This is a lookup requiring beforehand knowledge of
            the key – neither structural nor semantic conditions can be specified. Regarded as a
            means of navigation, the <code>fn:doc</code> function produces “manifold motion making
            little speed” (S. T. Coleridge, “The butterfly”), as it delivers only one result item
            per item of knowledge. The <code>fn:collection</code> function offers multiple items for
            the price of a single URI, but the collection is a pre-defined unit, which often will
            not match the actual requirements. </para><para> These limitations reflect the nature of the info space, which is an unstructured set
            of unrelated, indistinguishable trees. Or more precisely: trees that cannot be
            distinguished or related until an in-memory representation is constructed, as URIs are
            devoid of semantics. The info space does not relate resource URIs to a structure (like
            directories), does not define inter-resource relationships (like XLink links) and does
            not provide any way how to search for resources (as a database does). </para><para> Space structure, resource relationships and searchability may, however, be introduced
            on the grounds of <emphasis role="ital">data</emphasis> which create a second layer of
            information, built upon the first layer consisting of the resources themselves. Think of
            a linkbase defining relationships between documents, or a data set associating URIs with
            meta information. Data-based navigation aids can be introduced on the application level.
            But they might also be supported by standardization. The basic principle would be to
                <emphasis role="ital">extend the dynamic context</emphasis> of XPath evaluation by
            novel components which expose those data to the navigational engine of XPath - enabling
            novel XPath functions, perhaps even novel navigational axes. </para><para> This section explores some possibilities how standards may be extended in order to
            enhance the possibilities of between-resource navigation. </para><section><title>XLink per XPath</title><para> XLink [<xref linkend="w3c-xlink"/>] is a specification that defines XML syntax
                for describing links between resources. Although these resources are not necessarily
                nodes, we can for the sake of our discussion treat XLink as a language for defining
                node relationships. The basic unit of resource linkage is an <emphasis role="ital">arc</emphasis> which maps one set of resources (the starting resources) to
                another set of resources (the ending resources). The arc enables “traversal” from
                any one of the starting resources to any one of the ending resources. This concept
                of XLink traversal is similar, though not identical, to XPath navigation. Both rely
                on a unidirectional mapping from a start or context node to a set of result nodes.
                Consequently, the definition of XLink arcs might be viewed as the definition of
                potential navigation steps available to XPath. Let us investigate possibilities to
                translate XLink-defined arcs into XPath steps. </para><para> XLink defines containers, called extended links, which hold together a set of
                resource locators and associated arcs, which are mappings between subsets of the
                complete set. (For the sake of clarity, we ignore the possibility of using local
                resources instead of or together with resource locators.) The extended link can
                assign to each of its resources an optional label (NCName). The label is like a
                property attached to the resources which allows them to be identified and grouped
                into subsets of the complete set contained by the extended link. The start and the
                end of an arc is defined in terms of an optional label value: if a label value is
                set, the corresponding subset of resources comprises all resources which have this
                label; if no label value is set, the subset is equal to the complete set. Consider
                the following extended link containing four arcs: <programlisting xml:space="preserve">
   &lt;foo xlink:type='extended'&gt;
      &lt;a1 xlink:type='arc' xlink:from='a' xlink:to='b'/&gt;
      &lt;a2 xlink:type='arc' xlink:to='b'/&gt;
      &lt;a3 xlink:type='arc' xlink:from='a'/&gt;
      &lt;a4 xlink:type='arc' /&gt;
    
      &lt;res xlink:type='locator' xlink:href='…1' xlink:label='a'/&gt;
      &lt;res xlink:type='locator' xlink:href='…2' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…3' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…4' xlink:label='b'/&gt;
      &lt;res xlink:type='locator' xlink:href='…5' xlink:label='c'/&gt;
   &lt;/foo&gt;</programlisting>
            </para><para> The arc &lt;a1&gt; leads from the single one resource associated with a label “a” to
                all three resources with a label “b”; &lt;a2&gt; leads from any one of the five
                resources to the three resources with a label “b”; &lt;a3&gt; leads from the resource
                with a label “a” to all five resources, including itself; and &lt;a4&gt; leads from any
                one of the five resources to all five resources, including itself. </para><para> An arc is an option for navigation. Given a node (N), a navigation step may be
                specified by <emphasis role="ital">selecting a particular arc</emphasis> (A). The
                destination is the collection of nodes which <itemizedlist><listitem><para>is empty if N is not among the starting resources of A</para></listitem><listitem><para>comprises the ending resources of A, otherwise</para></listitem></itemizedlist> Such navigation might be integrated into XPath if two changes are
                applied to the current standards: <itemizedlist><listitem><para>extend the static context of XPath by a component <emphasis role="bold">Available extended links</emphasis>, comprising the
                            extended links which are “in scope”. (These extended links may be
                            imported as linkbase documents, analogously to the import of in-scope
                            schemas as schema documents.) </para></listitem><listitem><para> define a new kind of navigation step which is based on the selection
                            of a particular arc </para></listitem></itemizedlist> The new kind of navigation step may be a combination of an
                    <code>xlink</code> axis with an “arc test” selecting arcs. The expression result
                could then be collected from the ending resources of the selected arcs. </para><para> How to specify the selection of arcs? The XLink standard defines extended links
                to have an optional <code>role</code> property and arcs to have an optional
                    <code>arcrole</code> property, where both properties have as value a URI.
                Therefore a selection of arcs might be specified by two URIs, a <code>role</code>
                selecting extended links and an <code>arcrole</code> selecting arcs within those
                links. If we now deviate from the XLink standard and assume that arcs have an
                additional property, an <code>“arclabel”</code> with an NCName as value, then arc
                selection might be specified by a single QName, as a QName consists of a URI plus an
                NCName. The “arc test” selecting an arc might now be specified by a QName, in
                analogy to the name test which is also specified by a QName, but selects elements or
                attributes . Consider the following expression:
                <programlisting xml:space="preserve">   xlink::x:y</programlisting> Its value would be determined as
                follows. <orderedlist><listitem><para> select from the <emphasis role="bold">Available extended
                                links</emphasis> those with a <code>role</code> equal to the URI
                            bound to prefix “x” </para></listitem><listitem><para> within the selected extended links select all arcs with an
                                <code>arclabel</code> equal to “y” </para></listitem><listitem><para> filter the selected arcs, retaining only those whose set of starting
                            resources “matches” the context node (see below for details) </para></listitem><listitem><para> obtain as the expression value the union of the ending resources of
                            all arcs retained by the previous step </para></listitem></orderedlist>
            </para><para> A remaining issue is the definition of when a set of starting resources “matches”
                the context node. The proposal is to define matching as containment: the starting
                resources include a node which is either identical to or contains the context node.
                Consider this expression:
                <programlisting xml:space="preserve">
   doc('foo.xml')//a/xlink::x:y</programlisting>
            </para><para> The selected arcs may include as starting resource either the document “foo.xml”,
                or the “a” element to which the <code>xlink</code> step is applied, or any ancestor
                of that “a” element. </para><para> As an alternative to using a new <code>xlink</code> axis, XLink navigation might
                be supported by a new standard function, <code>fn:xlink</code>. In this case, the
                set of extended links to be considered might alternatively be taken from the static
                context or from linkbase documents supplied as a parameter: <programlisting xml:space="preserve">
   fn:xlink($arcTest as xs:QName) as node()*
   fn:xlink($arcTest as xs:QName, $linkbases as node()*) as node()*</programlisting>
            </para></section><section xml:id="pfc-semantic-navigation"><title>XLink versus data-driven navigation</title><para> XLink defines resource relationships in terms of URI relationships - static
                mappings between single URIs and/or URI collections. The XLink model does not cover
                well a frequent requirement – data-driven navigation, which is guided by data and
                unawares of structural relationships between a current context and the destination.
                For example, assume a document D containing a country code, and further assume a
                collection of documents describing countries, one country per document: how can the
                evaluation of D take advantage of the country description matching the country code? </para><para> Currently, the navigation model of XPath does not offer standardized support for
                such tasks. Working within the bounds of a single document, this is felt less
                acutely as expressions like <code>//country[@code eq 'FR']</code> have a sweeping
                nature which removes any structural assumptions apart from which document the
                information is located in. But when the target might be located in other documents,
                the lack of support may become an issue. Navigation between documents requires
                knowledge of a URI. In the general case this will be the target document URI, as
                support for named collections (the <code>fn:collection</code> function) is
                implementation-defined and hence not portable. Without such support we simply cannot
                “look into” other documents without first providing a document URI. </para><para> If the processor does support the <code>fn:collection</code> function, we can
                access documents without knowledge of individual document URIs. But collections are
                a problematic answer to the challenge of data-driven navigation. The collection is
                not yet the destination of our navigation, but a set of candidates from which to
                select the destination. In order to navigate into one country description, two
                hundred country descriptions have to be parsed (unless they are located in an XML
                database) and queried (unless we can resort to a database index). The greater the
                collection, the greater the overhead incurred by processing the collection in order
                to identify the one or few matching items. When there are a large number of
                candidates – e.g. accumulated log messages – the approach of constructing all
                candidate nodes and then filtering them can quickly become unfeasible. </para><para> The problem is deep-rooted. As navigational axes are bounded by the document
                border, conventional navigation cannot lead to the discovery of information in other
                documents, unless the URIs of those documents are either known beforehand or
                supplied by a document visited at an earlier navigation step. The next section
                develops a concept of data-driven navigation which is based on a filtering of
                collections which does not require the prior in-memory construction of its
                nodes.</para></section><section><title>Property-faced collections</title><section><title>External node properties</title><para> Every XML node has a set of properties defined by the XDM data model. An
                    element node, for example, has twelve properties, which include the name,
                    relationships to other nodes ([parent], [children], [attributes]), a type, a
                    typed value and a string value. Evaluation of these properties is what drives
                    XPath navigation, guiding it from a set of starting points to a set of
                    destination nodes. </para><para> In certain situations, however, the locating of nodes might be greatly
                    simplified if we manage to associate nodes with <emphasis role="ital">additional</emphasis> properties which help us to identify the nodes of
                    interest. Such properties could represent metadata, or they could reflect the
                    contained data, for example echoing a value found at a particular data path
                    within the node, or providing a value derived from contained data, like a
                    minimum or maximum. As these additional properties are not XDM properties, their
                    values are not part of the node data. Hence we call them <emphasis role="bold">external node properties</emphasis>. Their nature implies an interesting
                    possibility: they can provide information about a node which is <emphasis role="ital">accessible without constructing the node</emphasis>. Access to
                    such information might enhance the navigational model of XPath in general, and
                    add support for data-driven navigation in particular. The following sections
                    describe an approach how to achieve this. </para><para> An external property has a name and a value. A set of external node
                    properties can be modelled as a map with which the node is associated. The map
                    entries have a key which represents the property name, and a value which
                    represents the property value. Such a map we call a <emphasis role="ital">property face</emphasis> of the node, or <emphasis role="bold">p-face</emphasis> for short. Striving to keep things simple, we constrain
                    external node properties to have an NCName and a value which is a sequence of
                    atomic items of type <code>xs:untypedAtomic</code>. The value space of p-faces
                    is accordingly constrained. </para></section><section><title>Property-faced collections</title><para> A p-face is not part of the node data – it is merely <emphasis role="ital">associated</emphasis> with them. This relationship can be compared to the
                    general relationship between the keys and values of a map: the keys are not part
                    of the values, but only associated with them in the context of the map. Such an
                    association is not global, but scoped to the map. </para><para> The association between a node and its p-face is provided by a node
                    collection which contains the node. We introduce the concept of a <emphasis role="bold">p-faced collection</emphasis> (short for property-faced
                    collection), which is a conventional node collection plus a mapping associating
                    each node with a p-face. We do not constrain the individual p-faces to use the
                    same property names: the number and names of external properties can vary from
                    node to node. </para><para> The following table shows a simple example of a p-faced collection. In this
                    case, all collection members are associated with the same set of external
                    properties. The collection may therefore be represented by a table in which one
                    column identifies the node and the remaining columns represent external
                    properties. <table><caption><para>
                                <emphasis role="bold"><emphasis role="ital"> Example of a p-faced
                                        collection. </emphasis></emphasis> The collection associates
                                each node with three external properties. Property value items are
                                separated by comma. </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">node URI</th><th align="left" valign="top">countryCode</th><th align="left" valign="top">neighbourCountries</th><th align="left" valign="top">rivers</th></tr></thead><tbody><tr valign="top"><td><code>file://countries/fr.xml</code></td><td>fr</td><td>at, be, ch, de, es, it, lu, mc</td><td>Rhein, Loire, Maas, Rhone, Seine, Garonne, Mosel, Marne, …</td></tr><tr valign="top"><td><code>file://countries/de.xml</code></td><td>de</td><td>at, be, ch, cz, dk, fr, lu, nl, pl</td><td>Donau, Elbe, Rhein, Oder, Weser, Main, Havel, Mosel, …</td></tr><tr valign="top"><td><code>file://countries/it.xml</code></td><td>it</td><td>at, ch, fr, sm, si, va</td><td>Drava, Po, Adige, Tevere, Adda, Oglio, Tanaro, Ticino, ...</td></tr></tbody></table>
                </para><para> A p-faced collection can be filtered by supplying a set of conditions to be
                    tested against the p-faces of its nodes. Such a set of conditions we call a
                        <emphasis role="bold">p-filter</emphasis>. The result of applying a p-filter
                    to a p-faced collection is a sub collection of the original collection, which we
                    call a <emphasis role="bold">p-filtered collection</emphasis>. </para><para> A subsequent section will define the syntax and semantics of property filters
                    in detail. For the moment, assume that such a filter may be represented by a
                    string, and further assume that a p-faced collection is identified by a URI.
                    Concatenating the URI and the query string, we can then identify sub collections
                    by a single string, for example:
                    <programlisting xml:space="preserve">
   http://example.com/pcollections/countries?neighbourCountries=be</programlisting>
                    A new XPath function may provide the functionality of resolving such strings to
                    the node sequences they identify. If the model were adopted by the XPath
                    standard, such a function might be <code>fn:nodes</code>, and one of its
                    signatures might be:
                    <programlisting xml:space="preserve">
   fn:nodes($uriQuery as xs:string) as node()*</programlisting>
                    The following snippet shows a simple XQuery program using this function: <programlisting xml:space="preserve">
   declare variable $country external;
   declare variable $countries := "http://example.com/pcollections/countries";

   &lt;neighbours cy="{$country}"&gt;{
      fn:nodes(concat($countries, '?', $country))
   }&lt;/neighbours&gt;</programlisting> A crucial aspect
                    of p-faced collections is the possibility to separate the evaluation of the
                    p-filter from the construction of the selected nodes. Filter evaluation does not
                    require looking “into” the candidate nodes, in fact it does not require the
                    construction of any nodes. Filter evaluation is an operation on a collection of
                    logical maps, the p-faces. The <emphasis role="bold">p-filter engine</emphasis>
                    may treat the nodes as opaque strings, to be delivered as such. Resolving these
                    strings to the nodes they represent is the task of an independent component, the
                        <emphasis role="bold">node builder</emphasis>. The operations of p-filter
                    evaluation and node construction are distinct and independent. It follows that
                    the p-filter engine need not be based on XML technology. It is possible, for
                    example, to store the p-faced collection in a relational database table and use
                    as p-filter engine the relational database system. In this case, the p-filter
                    supplied to the <code>fn:nodes</code> function would be translated into a SQL
                    query. It is also possible to store the p-faced collection in a NOSQL object
                    collection. The p-filter engine would then be the NOSQL data base system, and
                    the p-filter would be translated into a NOSQL query. Any p-filter engine can be
                    combined with the same node builder, as the mapping of a string to a node is in
                    no way influenced by the way how the string was obtained. </para><para> In summary, p-faced collections promise two distinct benefits. First, they
                    augment the navigational model of XPath with data-based access to information,
                    overcoming the current limitation that document access requires knowledge of the
                    document URI. Second, they offer the possibility to integrate non-XML
                    technologies into the implementation of XML data storage and XPath navigation,
                    which may enhance the scalability of XML based systems significantly. The
                    concept of p-faced collections must now provide <itemizedlist><listitem><para>a model of p-filters in terms of data model, syntax and
                                semantics</para></listitem><listitem><para>a proposal how to integrate p-faced collections into the XPath
                                language</para></listitem><listitem><para>an outline how XPath processors may support the implementation of
                                p-faced collections using non-XML technologies </para></listitem></itemizedlist>
                </para></section><section xml:id="pfc-filter-model" xreflabel="Filter model"><title>Filter model</title><para> A p-filter defines a condition which can be applied to a p-face and yields a
                    Boolean result. As every node in a p-faced collection is associated with a
                    p-face, a p-filter can be used to specify sub collections. This section proposes
                    a generic model of a p-filter, which includes the data model, syntax and
                    semantics. </para><section xml:id="pfc-concept" xreflabel="Concept"><title>Concept</title><para> Attempting to strike a balance between simplicity and expressiveness, we
                        constrain a p-filter to consist only of atomic conditions and Boolean
                        conditions. An atomic condition submits the value of one particular property
                        to a particular test, and a Boolean condition is a Boolean operation
                            (<code>and, or, not</code>) applied to the results of atomic and/or
                        Boolean conditions. A p-filter can therefore be viewed as a logical tree
                        with leaves representing atomic conditions and inner nodes representing
                        Boolean conditions. </para><para> Atomic conditions are modelled as comparisons between a property value
                        and a test value. Like the property value, also the test value is a sequence
                        of atomic items. These items are specified as literal strings or string
                        patterns – they cannot be references to other property values. The
                        comparison is defined in terms of an operator (=, &lt;, &lt;=, …) and a
                        quantifier (<code>some</code> or <code>every</code>) specifying if all
                        property value items or only at least one item must pass the test. </para><para> The information content of a p-filter is defined in terms of the XDM data
                        model, namely as an element information item constrained in particular ways.
                        The data model must be distinguished from the syntax model which defines
                        string representations of this information content. The semantics of a
                        p-filter consist of the rules how to evaluate a p-filter in the context of a
                        p-face to a Boolean result. </para><para> The generic p-filter model allows the use of a p-filter engine (for
                        example a particular relational database system) which does not support all
                        possibilities implied by the model. To this end, the model includes the
                        definition of <emphasis role="ital">features</emphasis> with
                        implementation-defined values. This approach combines the precise
                        specification of a fairly rich functionality with conformance criteria based
                        on a subset of the functionality, and it provides for a standard way how to
                        express implementation-specific limitations. </para></section><section xml:id="pfc-data-model" xreflabel="Data model"><title>Data model</title><para> A p-filter is an element information item with the local name
                            <code>filter</code> and a namespace URI yet to be decided. (For the time
                        being we assume the URI
                        <code>http://www.w3.org/2013/xpath-structures</code>). In the following text
                        we use the prefix p to denote this URI. The filter element is either empty
                        or has element-only content. It can have any number of child elements. Each
                        child element represents either a property condition or a Boolean condition. </para><para> A <emphasis role="bold">property condition</emphasis> specifies a
                        condition referring to a particular property. It is represented by an
                        element information item in no namespace and with a local name equal to the
                        property name. The condition can be structured into four logical components,
                        described by the following table. </para><table><caption><para>
                                <emphasis role="bold"><emphasis role="ital"> The components of a
                                        property condition and their XML representation.
                                    </emphasis></emphasis>
                            </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">Condition component</th><th align="left" valign="top">XML representationn</th><th align="left" valign="top">Explanation</th></tr></thead><tbody><tr valign="top"><td>Property name</td><td>The local name of the element.</td><td>Note that property names are constrained to be NCNames. If this
                                    is changed, the property name will be represented by the value
                                    of a @name attribute.</td></tr><tr valign="top"><td>Test value</td><td>Either the single text child of the element, or the
                                        <code>p:term</code> child elements.</td><td>If there is only one test value item, it is represented by the
                                    text content of the element. If there are several items, use for
                                    each item a <code>p:term</code> child element with a single text
                                    child. Note that test value items are literal – they cannot be
                                    references to other property values. Also note that test value
                                    items cannot be accompanied by type information.</td></tr><tr valign="top"><td>Operator</td><td>Optional @op attribute; default value: =; valid values: =, !=,
                                    &lt;, &lt;=, &gt;, &gt;=, ~, %, #=, #!=, #&lt;, #&lt;=, #&gt;, #&gt;= </td><td>A leading # indicates a numeric comparison; ~ is a regex match
                                    governed by the XPath regex rules; % is a regex or pattern match
                                    with implementation-defined semantics.</td></tr><tr valign="top"><td>Quantifier</td><td>Option @qua attribute; default value: <code>some</code>; valid
                                    values: <code>some, every</code>
                                </td><td>If the value is <code>every</code>, the condition requires every
                                    item of the property value to meet the condition; otherwise,
                                    only at least one item must meet the condition.</td></tr></tbody></table><para> An additional detail concerns the use of regex matching (@op equal ~). In
                        this case test value items containing a # are interpreted as follows: the
                        substring preceding the # is the pattern, the substring following it is a
                        set of match option flags (s, m, x, m, q) as they can be used in the third
                        parameter of standard function <code>fn:matches</code>. </para><para> Some examples of property conditions: </para><programlisting xml:space="preserve">
   &lt;time&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;time op="&amp;lt;" qua="every"&gt;2013-01-01T00:00:00&lt;/time&gt;
   &lt;keywords op="~"&gt;^semantic.*&lt;/keywords&gt;
   &lt;keywords op="~"&gt;^semantic.*#i&lt;/keywords&gt;
   &lt;keywords op="~"&gt;semantic%&lt;/keywords&gt;
   &lt;codes&gt;
      &lt;p:item&gt;DUS&lt;/p:item&gt;
      &lt;p:item&gt;CGN&lt;/p:item&gt;
   &lt;/codes</programlisting><para> A <emphasis role="bold">Boolean condition</emphasis> specifies a Boolean
                        operation applied to the results of other conditions which are property
                        conditions and/or Boolean conditions. A Boolean condition is an element
                        information item with a local name equal to <code>and, or</code> or
                            <code>not</code> and the same namespace URI as the <code>p:filter</code>
                        element. Examples: <programlisting xml:space="preserve">
   &lt;p:and&gt;
      &lt;time op="&amp;gt;"&gt;2012-12-31T22:30:00&lt;/time&gt;
      &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
      &lt;p:or&gt;
         &lt;travelType op="~"&gt;^accommodation.*&lt;/travelType&gt;
         &lt;supplier&gt;TUI&lt;/supplier&gt;
      &lt;/p:or&gt;	
      &lt;p:not&gt;
         &lt;eventDate op="&amp;lt;" qua="every"&gt;2013-08-01&lt;/eventDate&gt;
      &lt;/p:not&gt;
   &lt;/p:and&gt;</programlisting>
                    </para></section><section xml:id="pfc-syntax" xreflabel="Syntax"><title>Syntax</title><para> Being defined as an element information item, a p-filter can be
                        serialized to a string like any other XML data. However, in certain
                        situations a more compact and intuitive syntax is desirable - for example
                        when passing a p-filter to a REST service as part of a URI. Therefore we
                        define a “query syntax” which represents a p-filter by a non-XML string. The
                        syntax represents a <emphasis role="ital">property condition</emphasis> by
                        these patterns: <programlisting xml:space="preserve">
   property-name operator testvalue
   property-name operator (testvalueItem-1, testvalueItem-2, ...)</programlisting>and a <emphasis role="ital">Boolean condition</emphasis> by these patterns: <programlisting xml:space="preserve">
   condition and condition
   condition or condition                        
   not condition
   not (condition1, condition2, ...)</programlisting>Parentheses can be used to change the
                        binding of operands to operator (by default: and &gt; or &gt; not). A non-default
                        quantifier (that is, <code>every</code>) is encoded by a prefix character
                        preceding the operator string (e.g. $=). Example of a p-filter rendered in
                        query syntax:<programlisting xml:space="preserve">
   time &gt;= 2012… 
   and time &lt;=2013…
   and (travelType ~ ^accommodation.* or supplier=TUI) 
   and not(eventData $&gt; 2013-01-01)</programlisting>Note that this is only a sketch of the
                        intended syntax – a detailed specification is left to future investigation.
                        In particular it must be decided if test values are quoted. </para></section><section xml:id="pfc-semantics" xreflabel="Semantics"><title>Semantics</title><para> A p-filter can be applied to a p-face in order to obtain a Boolean
                        result. The atomic operation of this evaluation is the checking of a single
                        property value item against a single test value item. Such a test is called
                        a <emphasis role="bold">comparison constraint</emphasis>. Consequently, the
                        semantics of p-filter evaluation can be divided into general rules and rules
                        governing the evaluation of a comparison constraint. These are the general
                        rules: <itemizedlist><listitem><para> an empty p-filter evaluates to <code>true</code>
                                </para></listitem><listitem><para> a non-empty p-filter evaluates to <code>false</code> if at
                                    least one child element evaluates to <code>false</code>
                                </para></listitem><listitem><para> an <code>and</code> condition evaluations to
                                        <code>false</code> if at least one child element evaluates
                                    to <code>false</code>
                                </para></listitem><listitem><para> an <code>or</code> condition evaluates to <code>true</code>
                                    if at least one child element evaluates to <code>true</code>
                                </para></listitem><listitem><para> a <code>not</code> condition evaluates to <code>false</code>
                                    if at least one child element evaluates to <code>true</code>
                                </para></listitem><listitem><para> a property condition referencing a missing property evaluates
                                    to <code>false</code>
                                </para></listitem><listitem><para> a property condition with quantifier <code>some</code>
                                    evaluates to <code>true</code> if at least one property value
                                    item and at least one test value item meet the comparison
                                    constraint </para></listitem><listitem><para> a property condition with quantifier <code>every</code>
                                    evaluates to <code>false</code> if for at least one property
                                    value item there is no test value item with which it meets the
                                    comparison constraint </para></listitem></itemizedlist> A comparison constraint is specified in terms of an
                        operator. These are the evaluation rules: <itemizedlist><listitem><para> the operators =, !=, &lt;, &lt;= &gt;, &gt;= are evaluated by
                                    applying to the operands the corresponding XPath operator;
                                    operands are typed as <code>xs:untypedAtomic</code>
                                </para></listitem><listitem><para> a comparison operator with a leading # is evaluated by
                                    applying to the operands the corresponding XPath operator;
                                    operands are converted to <code>xs:double</code>
                                </para></listitem><listitem><para> the operand ~ is evaluated by evaluating the
                                        <code>fn:matches</code> function, using the property value
                                    item as first argument and the regex and options parts of the
                                    test value item as second and third arguments. If the test value
                                    item contains a # character, the regex and options parts are the
                                    substrings before and after the character; otherwise, the regex
                                    part is the complete item and the options part is the empty
                                    string. </para></listitem><listitem><para> the operator % has implementation-defined matching semantics
                                </para></listitem></itemizedlist>
                    </para></section></section><section xml:id="new-xpath-functions" xreflabel="New XPath functions"><title>New XPath functions</title><para> Given a p-faced collection, p-filters can be used to select a sub collection,
                    retaining only those nodes whose p-face passes the p-filter. This amounts to a
                    logical operation, mapping a collection URI and a p-filter to a sub collection.
                    New XPath functions can make this operation available. Assuming as a tentative
                    function name <code>fn:nodes</code>, three variants may be useful: <programlisting xml:space="preserve">   fn:nodes($collectionUri as xs:string, p:filter as element(p:filter)) as node()*
   fn:nodes($collectionUri as xs:string, p:filter as xs:string) as node()*
   fn:nodes($filteredCollectionUri as xs:string) as node()*</programlisting>The second signature
                    expects the p-filter in query syntax (see <link linkend="pfc-syntax" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        <emphasis role="under">Syntax</emphasis>)</link>. The third signature
                    expects a string composed of a collection URI and a p-filter in query syntax,
                    separated by a ? character, for example:
                    <programlisting xml:space="preserve">   http://www.traveltainment.de/pfc/shoppingCart?booking-date=2013-08-01</programlisting>Also
                    when concatenated with the collection URI, the p-filter in query syntax is not
                    URI-encoded. </para><para> The introduction of these functions should be accompanied by an extension of
                    the dynamic context of XPath evaluation: an additional component <emphasis role="bold">available property-faced collections</emphasis> provides a
                    mapping of URIs to property-faced collections. A property-faced collection is
                    formally defined as a collection which is associated with a mapping of p-filter
                    instances to sub collections </para></section><section xml:id="pfc-rest" xreflabel="Exposure by REST-ful web services"><title>Exposure by REST-ful web services</title><para> A p-faced collection can be exposed as a REST-full web service, using as URI
                    the concatenation of collection URI and (URI-encoded) p-filter described in the
                    previous section. As a web service is expected to return a single document,
                    rather than a sequence of nodes, the selected sub collection may be wrapped by
                    an element and thus integrated into a single document. The proposed convention
                    is to use a <code>&lt;p:collection&gt;</code> element with two attributes providing
                    the collection URI and the (not URI-encoded) p-filter. Example: <programlisting xml:space="preserve">   &lt;p:collection uri="http://www.traveltainment.de/pfc/offers" p-filter="destination=PMI"
         xmlns="http://www.traveltainment.de/pfc/offers"
         xmlns:p="http://www.w3.org/2013/xpath-structures"&gt; 
      &lt;offer&gt;...&lt;/offer&gt;
      &lt;offer&gt;...&lt;/offer&gt;
      &lt;offer&gt;...&lt;/offer&gt;
   &lt;/p:collection&gt;</programlisting>
                </para></section><section xml:id="pfc-deployed-and-external-collections"><title>Deployed and external collections</title><para> An XPath processor may provide access to two different groups of p-faced
                    collections: <itemizedlist><listitem><para>deployed collections</para></listitem><listitem><para>external collections</para></listitem></itemizedlist>
                </para><para> A deployed collection is accessed according to configuration data. This
                    might, for example, involve the translation of the p-filter into a SQL query,
                    its execution and the construction of nodes from result set data. See <link linkend="pfc-implementation-and-configuration" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        <emphasis role="under">Implementation and configuration</emphasis></link>
                    for details about the deployment of p-faced collection. </para><para> An external collection is accessed by applying the <code>fn:doc</code>
                    function to a URI which is a concatenation of collection URI and (URI-encoded)
                    p-filter in query syntax. The URI is expected to yield a document which
                    represents the selected nodes as child elements of the document element (see
                        <link linkend="pfc-rest" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        <emphasis role="under">Exposure as REST-ful web
                    services</emphasis>)</link>). The <code>fn:nodes</code> function might operate
                    as follows: <itemizedlist><listitem><para> if the collection URI identifies a deployed collection – evaluate
                                the selection in accordance with the configuration data </para></listitem><listitem><para> otherwise – construct a URI concatenating the collection URI and
                                the p-filter, resolve this URI to a document and deliver the child
                                nodes of the document element </para></listitem></itemizedlist>
                </para></section><section xml:id="pfc-implementation-and-configuration"><title>Implementation and configuration</title><para> A crucial aspect of p-faced collections is that they may be implemented using
                    non-XML technologies, namely relational database tables and NOSQL object
                    collections. This follows from the fact that the node itself is represented by a
                    string and that it is not inspected during the filtering operation.
                    Consequently, the implementation of a p-faced collection is not dealing with any
                    tree structure. The implementation must provide for each node the representation
                    of a logical map in which one entry represents the node itself and the remaining
                    entries represent the names and values of properties. Configuration data include
                    the name of the entry representing the node and specify how the node (if
                    selected) is constructed from the string representing it. The string may be a
                    serialization of the node, or it may consist of locator information, either a
                    regular URI or a locator with implementation-defined semantics. </para><para> If the p-faced collection is “homogeneous” in the sense of every node having
                    the same external properties, a relational table is a straightforward choice. If
                    the nodes have different sets of properties, a NOSQL collection may be more
                    appropriate. An example for the latter case are log data, where each log entry
                    has some generic properties including an event type and further properties which
                    are event type-specific. An event of type “file-not-found” may have a property
                    “file-name”, whereas an event “container-delivered” may have properties
                    specifying a container-number and a location. </para><para> Configuration data are required in order to enable an XPath processor to
                    access the implementation of a p-faced collection: <itemizedlist><listitem><para>the collection URI</para></listitem><listitem><para> the implementation technology, implying the backend query
                                language to use </para></listitem><listitem><para> connection data (e.g. database name and credentials and a
                                database table name, or the name of an object collection) </para></listitem><listitem><para> the type of node representation (serialized node, or URI, or an
                                implementation-defined kind of locator) </para></listitem></itemizedlist>
                </para></section><section xml:id="pfc-collection-features"><title>Collection features</title><para> The model of a p-filter includes details which may not be well supported by a
                    particular technology which on the whole seems well-suited to implement p-faced
                    collections. For example, the used technology may not support … <itemizedlist><listitem><para>the regular expression dialect used by XPath</para></listitem><listitem><para>case-sensitive property names</para></listitem><listitem><para>case-sensitive property values</para></listitem><listitem><para>property values with multiple items</para></listitem><listitem><para> searches requiring all property value items to meet a
                                condition</para></listitem></itemizedlist> Two perspectives must be distinguished: <itemizedlist><listitem><para> the collection provider – using a particular implementation
                                technology, his choices of property names and values may be limited
                            </para></listitem><listitem><para> the collection user – certain aspects of selection may not be
                                supported </para></listitem></itemizedlist> Defining the integration of p-faced collections into XPath, only
                    the second perspective is relevant, as it impacts the semantics of XPath
                    expressions. The first perspective may affect the names and values of
                    properties, but not the syntax and semantics of XPath expressions. Such
                    limitations are hidden from the collection user by the actual use of property
                    names and values. For example, if the technology excludes multiple property
                    values, the collection simply does not use multiple-valued properties; or if the
                    technology does not support case-sensitive property names or values, the
                    collection arbitrarily defines all property names to be lower case (or upper
                    case). </para><para> The concept of <emphasis role="bold">collection features</emphasis> is
                    introduced in order to enable a standardized representation of limitations, and
                    to enable a definition of conformance which can be achieved in spite of limited
                    support of the p-filter model. The following table presents a tentative set of
                    collection features.<table><caption><para>
                                <emphasis role="bold"><emphasis role="ital"> Collection features.
                                    </emphasis></emphasis>
                            </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">Collection feature</th><th align="left" valign="top">Description</th><th align="left" valign="top">Remark</th></tr></thead><tbody><tr valign="top"><td>{operators}</td><td>A list of supported operators. The list must contain the “=”
                                    operator, all other operators are optional.</td><td>A p-filter must not use an operator not contained in
                                    {operators}.</td></tr><tr valign="top"><td>{every-supported}</td><td>If <code>false</code>, a p-filter must not contain the
                                        <code>every</code> quantifier.</td><td>Every implementation must support the <code>some</code>
                                    quantifier.</td></tr><tr valign="top"><td>{multiple-test-supported}</td><td>If <code>false</code>, a p-filter must not specify test values
                                    with multiple items.</td><td>The use of multiple test values can be emulated using
                                        <code>p:or</code>.</td></tr></tbody></table>
                </para></section></section></section><section><title> Pushing the boundaries of the info space </title><para>The boundaries of the info space distinguish resources that belong to the space from
            resources that do not belong to the space. A resource is excluded from the info space
            for one of these reasons: <itemizedlist><listitem><para>Physical inaccessibility</para></listitem><listitem><para>API-based inaccessibility</para></listitem><listitem><para>Media type-based inaccessibility</para></listitem></itemizedlist> Physical access is out of scope. API-based inaccessibility is a target
            for extensions of the XPath function library. Media type-based inaccessibility presently
            amounts to the simple rule: XML resources are within, non-XML resources are not within
            the space. This is the basic weakness of the info space seen as an information
            architecture, and it is arguably the greatest challenge for a well-guided evolution of
            XML. Accordingly, this paper concentrates on the media type boundary and limits itself
            to a couple of notes concerning the API-based boundary. </para><para> The API-based boundary can be shifted by the introduction of new standard functions
            for accessing XML documents which are presently not accessible using
            <code>fn:doc</code>. These functions might address: <itemizedlist><listitem><para>Documents requiring HTTP authorization</para></listitem><listitem><para>Documents requiring special HTTP header settings</para></listitem><listitem><para>Documents requiring the HTTP POST method</para></listitem><listitem><para>Documents within archives (e.g. zip)</para></listitem></itemizedlist> Conceivable signatures would be (informally, for the sake of brevity):
            <programlisting xml:space="preserve">   httpDoc($uri, $username, $password, $headerFields, $body) as document-node() 
   zipDocs($uri, $directories, $namePatterns) as document-node()*</programlisting>
        </para><section><title>Model oriented resource representation</title><para> The most critical limitation of the info space is its commitment to the XML media
                type. The most important extension of the space can be achieved by overcoming this
                limitation.</para><para> An integration of non-XML resources into the info space is enabled by a
                consistent distinction between information and representation: between model and
                format. The basic principle of XML technology might be applied to non-XML resources:
                information <emphasis role="ital">is</emphasis> an instance of the data model. The
                info space can be extended by redefining non-XML formats to be <emphasis role="ital">representations</emphasis> of XDM node trees. </para><para> A format defined to represent node trees might be called a <emphasis role="bold">model oriented resource representation</emphasis>: a resource is viewed as a
                unit of information which is captured by a model instance, and this instance is
                represented by the format. The format instance is an expression, the model instance
                its value. </para><section><title>Introductory example</title><para> Scenario: we want to check some country codes, we have access to a dictionary
                    of country codes and names, but this dictionary is represented by a CSV dataset. </para><para> Now let us assume there is a standardized XML vocabulary for table data,
                    comprising "table", "row" and "cell" elements. And we further assume the
                    existence of a new <code>fn:doc</code> variant which delivers CSV data as an XML
                    node tree based on the table vocabulary. It enables us to select all invalid
                    country codes by a simple expression:
                    <programlisting xml:space="preserve">   doc("foo.xml")//countryCode
      [not(. = doc("countries.csv", "csv")//row/cell[1])]</programlisting>
                </para><para> This example demonstrates a seamless integration of data from XML and non-XML
                    resources: both participate in the info space. </para></section><section xml:id="generic-pattern-of-integration"><title>A generic pattern of integration</title><para> Let us assume that for a given data format F three sets of rules have been
                    defined: <variablelist><varlistentry><term>R1</term><listitem><para>Rules how to map an instance of F to a node tree</para></listitem></varlistentry><varlistentry><term>R2</term><listitem><para>Rules how to map a node tree to an instance of F</para></listitem></varlistentry><varlistentry><term>R3</term><listitem><para>Rules how to decide whether a given node tree can or cannot be
                                    mapped to an instance of F </para></listitem></varlistentry></variablelist> And let us further assume that these rules satisfy two
                    conditions: <variablelist><varlistentry><term>C1</term><listitem><para>For any format instance G: R1(G) satisfies R3</para></listitem></varlistentry><varlistentry><term>C2</term><listitem><para>For any R3-conformant node tree N: R1(R2(N)) is deep-equal to
                                    N</para></listitem></varlistentry></variablelist> where <code>R1(G)</code> denotes the result of applying R1 to a
                    format instance G and <code>R2(N)</code> denotes the result of applying R2 to a
                    node tree N. </para><para> C1 and C2 imply a constraint concerning round-tripping which starts with a
                    format instance G: the result is a format instance G' which is not necessarily
                    equal G but which is "FORMAT-deep-equal": R1(G) is deep-equal R1(G'). This
                    amounts to defining the information content of a format instance G: it is the
                    node tree provided by R1. Relying on this definition of information content,
                    instances of F can be safely evaluated or modified by evaluating or modifying
                    the corresponding node tree. This is the foundation of an integration of format
                    F into the info space. </para><para> A normative definition of rule sets R1, R2 and R3 enables the standardized
                    integration of a non-XML format into the info space. This requires two
                    extensions of the XML standards. The first extension is an XPath function which
                    parses an instance of the format into a node tree, reflecting R1. The second
                    change extends the XML serialization model [<xref linkend="w3c-serialization"/>]
                    by the definition of a serialization to format F, reflecting R2 and R3. The
                    interface of serialization is accordingly extended by an additional value of the
                    serialization parameter <code>model</code>. </para><para> A concrete proposal for the required XPath function is the introduction of a
                    second variant of <code>fn:doc</code> which has an additional parameter
                    specifying the source data format:
                    <programlisting xml:space="preserve">   fn:doc($uri as xs:string, $mediaType as xs:string) as document-node()</programlisting>
                    Assuming that rule sets have been standardized for the formats HTML, JSON, CSV,
                    SQL and CSS, access to non-XML resources might look like this:
                    <programlisting xml:space="preserve">   fn:doc("http://example.com/foo.htm", "htm")
   fn:doc("http://example.com/foo.jsn", "jsn")                        
   fn:doc("http://example.com/foo.csv", "csv")
   fn:doc("http://example.com/foo.sql", "sql")
   fn:doc("http://example.com/foo.css", "css")</programlisting>
                    The following sections explore how the rule sets govering parsing and
                    serialization may be defined. </para></section><section><title>Vocabulary based integration</title><para> Domain-specific languages (like SQL) and non-recursive generic formats (like
                    CSV) may be represented by a particular XML vocabulary. The formal definition of
                    such a vocabulary might comprise an XSD and a (possibly empty) set of additional
                    constraints expressible as XPath assertions. As a simple example, the vocabulary
                    for representing CSV data might be defined as a schema containing element
                    declarations with names like "table", "row" and "cell" as well as type
                    definitions constraining a <code>table</code> element to have only
                        <code>row</code> children and <code>row</code> elements to have only
                        <code>cell</code> children. An additional constraint might prescribe that
                    every <code>row</code> element has the same number of cell children:
                    <programlisting xml:space="preserve">   count(distinct-values(//row/count(cell))) eq 1</programlisting>
                    As a second example, an SQL vocabulary might contain a specific element for each
                    SQL statement, with a content model designed to capture all information which
                    the SQL syntax may convey. </para><para> Wiki dialects are non-XML formats representing a node vocabulary (XHTML). The
                    motivation is of course not integration into the info space, but access to a
                    rendering processor. And here a format was added to an existing node vocabulary,
                    whereas integration adds a node vocabulary to an existing format. Nevertheless,
                    it is interesting to notice the popularity which a non-XML/HTML representation
                    of node trees can attain. Standardization work might take this phenomenon into
                    consideration. </para></section><section><title>Vocabulary-assisted integration</title><para>Vocabulary-based integration is natural for formats which do not themselves
                    generate vocabularies as JSON does. Such a generative format might in principle
                    be mapped to a fixed XML vocabulary, by mapping the names supplied by the format
                    instance to XML <emphasis role="ital">data</emphasis>, rather than to XML names.
                    However, if the format has a recursive structure – like JSON – the resulting XML
                    would look unnatural and be inconvenient to evaluate. Such a mapping would have
                    very limited practical value, and it would violate the concept of integration as
                    explained in <link linkend="generic-pattern-of-integration" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        <emphasis role="under">a generic pattern of integration</emphasis></link>.
                    The concept is based on regarding non-XML formats as alternative representations
                    of node trees, as if the node trees were the original information and the format
                    were a means to capture this information. If the node tree looks unnatural, the
                    image presupposes the desire to convey information which is unnaturally
                    structured in the first place, which is absurd. </para><para> If JSON is redefined to be the representation of node trees, these node trees
                    should probably capture JSON names by node names. Several approaches of mapping
                    JSON to XML have done that as far as possible (e.g. [<xref linkend="couthures"/>], [<xref linkend="basex-json"/>], [<xref linkend="hunter"/>], [<xref linkend="lee"/>], [<xref linkend="pemberton"/>]) but they could not achieve
                    two goals: <itemizedlist><listitem><para>Represent any JSON name by an equal node name</para></listitem><listitem><para>Renounce the use of XML nodes containing JSON-related control
                                information</para></listitem></itemizedlist> The first problem arises from the fact that XML names are
                    QNames. The second problem reflects a mismatch of data models: whereas JSON uses
                    two distinct content models, one a map and the other a sequence of anonymous
                    items, XML has a single content model which is sequence-and-name based. The XML
                    model can be used to emulate the JSON models, but it cannot express them
                    natively. Those mapping approaches might be classified as vocabulary-assisted:
                    the bulk of items is named after their JSON counterparts, but a small additional
                    vocabulary is used in order to specify relationships between the nodes and their
                    JSON counterparts. These additional items prevent an evaluation of the node tree
                    from ignoring representations and only seeing the node tree itself. </para></section><section><title>Native integration</title><para> JSON is, like XML, recursively defined and generates vocabularies. The ideal
                    way to integrate it into the info space would be native integration: every JSON
                    instance should be the representation of a node tree which natively expresses
                    the JSON content, so that it can be serialized to JSON based on the node
                    properties only, without requiring the presence of additional nodes guiding the
                    serialization. Native integration of JSON is not possible due to differences of
                    the XML and JSON data models: the XML model is <emphasis role="ital">not</emphasis> a superset of the JSON model. </para></section></section><section><title>The extension of XML</title><para>JSON is a very popular generic markup language. If the XML data model is not a
                superset of the JSON model, it must be questioned if the XML data model is qualified
                to define the info space - an information architecture not tied to a particular
                markup language. The XML data model is very expressive and allows representing
                virtually any tree-structured data as long as each node cannot have more than one
                parent. But in three cases (at least) a given structure must be emulated, rather
                than be expressed natively. Calling the data to be represented a source tree
                composed of nodes, these are: <orderedlist><listitem><para>If a source node has a name which is not a valid QName, the XML node
                            has a different name.</para></listitem><listitem><para> If a source node is anonymous, the XML node must nevertheless have a
                            name. </para></listitem><listitem><para> If a source node has unordered content, the XML node cannot avoid
                            adding the information of a particular order – the data model does not
                            allow “switching off” the meaningfulness of order. </para></listitem></orderedlist> The emulation may deal with arbitrary names either by mapping the
                original name to an NCName or by shifting the source name into data (e.g. an
                attribute). Anonymous nodes can be represented by nodes with an arbitrary name. The
                insignificance of order can be conveyed by out-of-band information. As long as one
                can start and end with XML, these workarounds are not perceived as serious issues.
                Likewise, as long as an initial JSON representation can be permanently replaced by
                XML, there is also no problem as the emulation provides semantic equivalence. But if
                there is a need to <emphasis role="ital">maintain</emphasis> a relationship between
                node tree and JSON representation, one discovers that there is no way to natively
                express arbitrary JSON data by an XML node tree. </para><para> (2) and (3) amount to a mismatch between XML and the dominant content model used
                in programming languages: which is a choice between sequence-based (an "array" of
                anonymous items) and key-based content ("map", "hash", etc.: an unordered collection
                of keyed items). XML has one single content model which is a curious hybrid:
                sequence+name based, which means the content is always ordered (array-like), but
                each sequence item has a name, which is key-like but not a key, as it is not
                required to be unique among the siblings. </para><para> The fact that virtually any tree-structured information can be emulated in XML
                has encouraged the view that the content model is sufficient. The fact that the
                content model is not as generic as it seems on first sight – that it is incapable of
                expressing natively arrays, maps and string-based names – has not yet caught much
                attention. This might change if the concept of an info space gains momentum. The
                concept implies a certain shift of priorities, attaching importance to a native
                representation of non-XML resources by the XML data model. Such a representation is
                required for seamless navigation: navigation which sees the information content (the
                model instance) and is unaware of future or past representations. </para><section><title>Extension of the XML data model</title><para> Rennau [<xref linkend="rennau"/>] proposed an extension of the XML data model
                    which claims to enable a native representation of JSON data. The proposal
                    introduces the same boolean choice of content organization as is used in common
                    programming language like Java: a choice between the sequence based model (which
                    is the only model in current XML) and an alternative model which is truly
                    map-based: the child elements are unordered, and every child element has a
                    string-typed key – which is a new node property, [key]. The choice between the
                    two content models is made by each complex element, and therefore it is modeled
                    as a second new node property, [model]. It has two values, "sequence" and "map",
                    and the relationship between the two new properties is constrained as follows:
                    (a) an element with a non-null [key] must have a parent element with [model]
                    equal "map"; (b) an element with a null [key] must not have a parent element
                    with [model] equal "map". In other words: "map" elements have unordered children
                    which must have keys, and "sequence" elements have ordered children which must
                    not have keys.</para><para> Concerning the handling of anonymous items, Rennau proposed the introduction
                    of "unspecific standard names", but this is unsatisfactory, as it renounces the
                    goal of a genuinely native representation: the only natural representation of an
                    anonymous item is an anonymous item. Therefore we should modify the XML data
                    model by allowing anonymous elements. A JSON array would thus be an elegant
                    representation of an element node with [model] equal "sequence" and anonymous
                    child elements. </para><para> In summary, the following extensions of the XML data model should be
                    considered, as they promise to overcome the limitations which disqualify the
                    model as foundation of the info space: (a) addition of two new node properties,
                    [model] and [key]; (b) modification of the property [node-name], introducing the
                    possibility of a null value. </para></section><section xml:id="extension-xml-syntax"><title>Extension of the XML syntax</title><para> Introducing new node properties implies the necessity to define the
                    representation of these properties in XML syntax. Rennau proposed the use of
                    "pseudo attributes" which look like attributes but do not represent attribute
                    nodes, as they represent node properties: <itemizedlist><listitem><para>udl:model - indicates the value of the [model] property</para></listitem><listitem><para>udl:key - indicates the value of the [key] property</para></listitem></itemizedlist> where the prefix "udl" stands for "unified document language".
                    As a consequence, however, the XML representation of a JSON instance tends to be
                    cluttered with pseudo-attributes, which is perhaps a less important disadvantage
                    as it may seem, as the processing of JSON-supplied data is as elegant as the
                    processing of XML-supplied data (see below, <emphasis role="under"><xref linkend="xml-extension-xpath"/></emphasis>) and the very info space
                    architecture encourages the use of JSON notation whereever it seems more
                    attractive than XML notation (see below, <emphasis role="under"><xref linkend="markup-integration"/></emphasis>) . </para><para> However, a refusal to express the new node properties with the same
                    immediateness as the other properties is unsatisfactory. Pseudo-attributes are
                    an adequate representation of a node property when they can be expected to be
                    rare, as for example <code>xml:type</code> attributes. However, knowing in
                    advance that the XML representation of JSON-supplied data will produce XML
                    documents which are studded with pseudo-attributes - rendering them hardly
                    readable - we are motivated to go a step further and truly extend the XML
                    syntax, introducing new syntax constructs. The goal is to ensure readable XML
                    representations also of such node trees as are constructed from JSON instances.
                    The following syntax extensions should therefore be considered: <itemizedlist><listitem><para> A special character preceding an element name indicates that its
                                [model] is "map", rather than "sequence". Example: &lt;~foo&gt; </para></listitem><listitem><para> The key can be expressed within the element tag by the quoted key
                                value. Example: &lt;foo "2012"&gt; </para></listitem><listitem><para> Anonymous elements which do not have a key use instead of an
                                element name a special character. Example: &lt;*&gt; </para></listitem><listitem><para> Anonymous elements which do have a key are represented by
                                shifting the quoted key value to the beginning of the tag. Example:
                                &lt;"2012"&gt; </para></listitem></itemizedlist> These rules would allow an acceptable representation of JSON
                    data in XML syntax. A special advantage is that a given information content –
                    e.g. a web service response – might then be served <emphasis role="ital">without
                        changes</emphasis> alternatively in JSON or XML. Example: <programlisting xml:space="preserve">   &lt;~getWeatherResponse&gt;
         &lt;"temperature min"&gt;28&lt;/"temperature min"&gt;
         &lt;"temperature max"&gt;32&lt;/"temperature max"&gt; 
   &lt;/~getWeatherResponse&gt;
                        
   {
      "temperature min" : 28,
      "temperature max" : 32
   }</programlisting> To round these considerations off, a further detail of Rennau's proposal
                    which concerns the XML syntax should be retained: for elements which have a
                    parent element with [model] equal "map", the key defaults to the local name.
                    Therefore, a slight modification of the above example would look like this: <programlisting xml:space="preserve">   &lt;~getWeatherResponse&gt;
      &lt;temperatureMin&gt;28&lt;/temperatureMin&gt;
      &lt;temperatureMax&gt;32&lt;/temperatureMax&gt; 
   &lt;/~getWeatherResponse&gt;</programlisting> In this variant the child elements are not any more
                    anonymous but have a local name equal to the key. </para></section><section xml:id="xml-extension-xpath" xreflabel="Extension of the XPath/XQuery language"><title>Extension of the XPath/XQuery language</title><para> Integration of non-XML resources into the info space is driven by the desire
                    to make them accessible to navigation and evaluation. The extension of the data
                    model by a new [key] property must therefore be mirrored by an extension of the
                    XPath semantics. Rennau proposed the introduction of a third node test, the "key
                    test" which functions in analogy to the name test: selecting elements with a
                    given key, rather than elements with a given name. Being a node test, the key
                    test is combined with navigational axes in the same way as a name test. The
                    syntax of a key test is a special character (proposed: "#") followed by the key
                    value within quotes. Examples:
                    <programlisting xml:space="preserve">   $response/#"temperature min"
   $response//#"2012"                        
   $item/ancestor-or-self::#"AC#A-2917"</programlisting>
                    Thanks to the key test, JSON-supplied data can be navigated with the same ease
                    as XML-supplied data, using key tests to select among object members and
                    conventional numerical predicates to select among array items:
                    <programlisting xml:space="preserve">   $response//#"weather"/#"temperatures"/*[3]</programlisting>
                </para><para> Whereas the key test provides for navigation, Rennau also proposed an
                    extension of XQuery which enables the construction of nodes using JSON syntax.
                    The extension is purely syntactical: an additional syntax which is a JSON-style
                    shorthand notation for the construction of nodes which, due to their properties,
                    correspond to JSON objects and arrays. For example, the following XQuery
                    constructor: <programlisting xml:space="preserve">   &lt;*&gt;
      &lt;"temperature min"&gt;{$min}&lt;/"temperature min"&gt;                        
      &lt;"temperature max"&gt;{$max}&lt;/"temperature max"&gt;
      &lt;"temperatures"&gt;{for $v in $values return &lt;*&gt;{$v}&lt;/*&gt;}&lt;/"temperatures"&gt;
   &lt;/*&gt;</programlisting> can equivalently be written using JSON syntax: <programlisting xml:space="preserve">   {
      "temperature min" : $min,
      "temperature max" : $max,
      "temperatures" : [ $values ]
   }</programlisting> The XQuery construction of JSON data using JSON syntax is as convenient as
                    the construction of XML data using XML syntax. Taken together, the proposed
                    extensions of XPath and XQuery ensure a complete integration of JSON into the
                    info space: <itemizedlist><listitem><para> JSON instances can be navigated as easily as any other node
                                trees. </para></listitem><listitem><para> JSON instances can be constructed using JSON syntax. </para></listitem></itemizedlist>
                </para></section></section><section xml:id="markup-integration" xreflabel="Markup integration"><title>Markup integration</title><para> Every syntax which is defined to be the representation of a node tree might be
                integrated into XML markup. Provided that any section using non-XML syntax <itemizedlist><listitem><para>identifies the syntax it uses</para></listitem><listitem><para>is clearly delimited</para></listitem><listitem><para>appears in a place where a sequence of elements might appear</para></listitem></itemizedlist> the document text is guaranteed to be parsable into a node tree in
                an unambiguous way. Rennau proposed a restricted use of this new possibility which
                allows to provide <emphasis role="ital">element contents</emphasis> in non-XML
                syntax. The proposal is to introduce a pseudo-attribute (<code>udl:markup</code>)
                which identifies the syntax used to encode the element content. As a consequence,
                the following text would be a valid XML document: <programlisting xml:space="preserve">   &lt;~getWeatherResponse udl:markup="json"&gt;
      "temperature min" : 28,
      "temperature max" : 32
      "temperatures" : [28, 28, 30, 32, 31]
   &lt;/~getWeatherResponse&gt;</programlisting> Note that the <code>getWeatherResponse</code> element
                has three child elements, as the content of an element with
                    <code>udl:markup='...'</code> is defined to be the nodes resulting from parsing
                the text found between start tag and end tag according to the parsing rules for
                format '...'. </para></section></section><section><title>Wrapping up</title><para> The info space is an information architecture consisting of distributed resources
            whose information content is defined to be a node tree, understood as an instance of the
            (slightly extended) XDM data model. The resources are identified by URIs and accessed by
            XPath functions (<code>fn:doc</code>, <code>fn:httpDoc</code>, ...) which hide the
            actual data formats and expose the node structure. Taken together, the node structure of
            all accessible resources provides a uniform substrate for navigation and discovery. </para><para> It should be noted that the concept of a "resource" as used in the info space model
            is different from the use in Fielding's REST model [<xref linkend="fielding"/>]. The
            latter defines a resource as a conceptual unit whose mapping to concrete representations
            is a function of time. The resources of the info space are units of information which
            are <emphasis role="ital">values</emphasis>, precisely defined in terms of a node tree.
            As such, they are more closely related to Fielding's concept of a resource
            representation than to his concept of a resource. On the other hand, the insistence on a
            well-defined <emphasis role="ital">information content</emphasis> is in sharp contrast
            with Fielding's model, in which there is no place for such a thing. Resources of the
            info space are the accessible resource representations (in Fielding's sense) which can
            be resolved to a node tree. As such, the info space is a <emphasis role="ital">snapshot</emphasis> of all accessible resource representations (in Fielding's
            sense) which have a media type defined to represent a node tree, according to the
            standardizations endorsed by the W3C. </para><para> Fielding's REST model is aimed at an architecture for the internet, understood as a
            distributed hypermedia system. His view of resource navigation assumes a model of
            application behaviour in which the rendering of resource representations powers
            subsequent navigation by supplying embedded links. The info space model, on the other
            hand, is unconcerned with application behaviour and paints a picture in which nothing
            appears but information, aggregated into distinct resources and nevertheless coalesced
            into a single, homogeneous substrate of information. Embedded links are predefined
            point-to-point connections. The connectivity of the info space, however, relies on XPath
            navigation, which is like an ubiquitous field of possibility, potentially leading from
            anywhere to anywhere. Therefore the info space is not a net but more like a space: it
            integrates anything (any resource) appearing within it.</para><para> The info space integrates information on a global scale, relying on a 
            uniform data model. The same can be said about RDF [<xref linkend="w3c-rdf"/>]. 
            What is the relationship
            between the XML info space and RDF? RDF is about 
            <emphasis role="ital">semantic integration</emphasis>,
            establishing the identities of real world resources described
            by the data. The RDF data model is designed to enable the
            assembling of distributed items into synthetic descriptions,
            which are organized by the identities of the described
            resources. </para><para> The XML info space, on the other hand, is about 
            <emphasis role="ital">navigational integration</emphasis>, offering
            it as a possible foundation for semantic integration. The semantic integration
            is left to applications which are supposed to understand
            the trees they are dealing with as a coherent, structured unit - 
            rather than regarding them as a
            "mine" from which to undig self-contained items of information (triples).
            Such a dealing with <emphasis role="ital">well-understood resources</emphasis>
            is the typical task of conventional applications. They know
            what to do with, say, /a/b/c taken from one resource and with
            /x/y/z taken from another resource, and how they are related. 
            For such applications the benefit of simple and efficient 
            navigation is probably
            greater than the benefit of further aids how to find out those
            meanings and relationships. Therefore conventional
            applications 
            may profit from the navigational info space
            immensely and probably far less from the semantic space created by RDF.
            Nevertheless, there may be a wonderful synergy between the
            XML space and the RDF space yet to be explored.</para></section><bibliography><title>Bibliography</title><bibliomixed xml:id="w3c-xpath" xreflabel="1">Berglund, Anders et al, eds. XML Path Language
            (XPath) 2.0 (Second Edition). W3C Recommendation 14 November 2010. <link xlink:href="http://www.w3.org/TR/xpath20/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20/</link></bibliomixed><bibliomixed xml:id="w3c-xdm" xreflabel="2">Berglund, Anders et al, eds. XQuery 1.0 and
            XPath 2.0 Data Model (XDM) (Second Edition). W3C Recommendation 23 January 2007. <link xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</link></bibliomixed><bibliomixed xml:id="uri" xreflabel="3">Berners-Lee, Tim et al. Uniform Resource Identifier
            (URI): Generic Syntax. Network Working Group, Request for Comments: 3986. January 2005.
                <link xlink:href="http://tools.ietf.org/html/rfc3986" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://tools.ietf.org/html/rfc3986</link></bibliomixed><bibliomixed xml:id="w3c-xquery" xreflabel="4">Boag, Scott et al, eds. XQuery 1.0: An XML
            Query Language (Second Edition). W3C Recommendation 14 December 2010. <link xlink:href="http://www.w3.org/TR/xquery/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</link></bibliomixed><bibliomixed xml:id="w3c-serialization" xreflabel="5">Boag, Scott et al, eds. XSLT 2.0 and
            XQuery 1.0 Serialization (Second Edition). W3C Recommendation 14 December 2010. <link xlink:href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xslt-xquery-serialization/</link></bibliomixed><bibliomixed xml:id="w3c-xml" xreflabel="6">Bray, Tim et al, eds. Extensible Markup Language
            (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November 2008. <link xlink:href="http://www.w3.org/TR/REC-xml/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</link></bibliomixed><bibliomixed xml:id="couthures" xreflabel="7">Couthures, Alain. JSON for XForms - adding
            JSON support in XForms data instances. XML Prague 2011, Conference Proceedings, p.
            13-24. <link xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</link>
            .</bibliomixed><bibliomixed xml:id="w3c-infoset" xreflabel="8">Cowan, John &amp; Tobin R., eds. XML
            Information Set (Second Edition). W3C Recommendation 4 February 2004. <link xlink:href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</link></bibliomixed><bibliomixed xml:id="w3c-xlink" xreflabel="9">DeRose, Steve et al, eds. XML Linking Language
            (XLink) Version 1.1. W3C Recommendation 6 May 2010. <link xlink:href="http://www.w3.org/TR/xlink11/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xlink11/</link></bibliomixed><bibliomixed xml:id="einstein" xreflabel="10">Einstein, Albert &amp; Infield, L. The
            evolution of physics. Edited by C.P. Snow. Cambridge University Press, ASIN: B000S52QZ4,
            1938 <link xlink:href="http://archive.org/details/evolutionofphysi033254mbp" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://archive.org/details/evolutionofphysi033254mbp</link>
            .</bibliomixed><bibliomixed xml:id="fielding" xreflabel="11">Fielding, Roy T. Architectural Styles and the
            Design of Network-based Software Architectures. Ph.D. Dissertation, University of
            California, Irvine, 2000. <link xlink:href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</link>
            .</bibliomixed><bibliomixed xml:id="basex-json" xreflabel="12">Gruen, Christian, et al. BaseX Documentation
            Version 7.3, section "JSON Module", p. 161-166. <link xlink:href="http://docs.basex.org/wiki/Main_Page" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://docs.basex.org/wiki/Main_Page</link>.</bibliomixed><bibliomixed xml:id="hunter" xreflabel="13">Hunter, Jason. A JSON facade on MarkLogic
            Server. XML Prague 2011, Conference Proceedings, p. 25-34. <link xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="lee" xreflabel="14">Lee, David A. JXON: an Architecture for Schema and
            Annotation Driven JSON/XML Bidirectional Transformations. Presented at Balisage: The
            Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. In Proceedings of
            Balisage: The Markup Conference 2011. Balisage Series on Markup Technologies, vol. 7
            (2011). doi:<biblioid class="doi">10.4242/BalisageVol7.Lee01</biblioid>. <link xlink:href="http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</link>.</bibliomixed><bibliomixed xml:id="w3c-rdf" xreflabel="15">Manola, Frank &amp; Miller E., eds. RDF Primer. 
            W3C Recommendation 10 February 2004. <link xlink:href="http://www.w3.org/TR/rdf-primer/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/rdf-primer/</link></bibliomixed><bibliomixed xml:id="pemberton" xreflabel="16">Pemberton, Steven. Treating JSON as a subset
            of XML. XML Prague 2012, Conference Proceedings, p. 81-90. <link xlink:href="http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="rennau" xreflabel="17">Rennau, Hans-Jürgen. "From XML to UDL: a unified
            document language, supporting multiple markup languages." Presented at Balisage: The
            Markup Conference 2012, Montréal, Canada, August 7 - 10, 2012. In Proceedings of
            Balisage: The Markup Conference 2012. Balisage Series on Markup Technologies, vol. 8
            (2012). doi:<biblioid class="doi">10.4242/BalisageVol8.Rennau01</biblioid>. <link xlink:href="http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html</link>.</bibliomixed><bibliomixed xml:id="xml-catalog" xreflabel="18">Walsh, Norman, ed. XML Catalogs. OASIS
            Standard V1.1, 7 October 2005. <link xlink:href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html</link>.</bibliomixed><bibliomixed xml:id="json" xreflabel="19">Web resource without source information:
            Introducing JSON. <link xlink:href="http://json.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://json.org</link>.</bibliomixed></bibliography></article>