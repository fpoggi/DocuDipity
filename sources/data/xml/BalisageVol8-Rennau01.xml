<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title>From XML to UDL: a unified document language, supporting multiple markup languages</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>
        A proposal is made how to extend the XML node model in order to be compatible with JSON markup as
        well as XML markup. As XML processing technology (XPath, XQuery, XSLT, XProc) sees instances
        of the node model, but does not see syntax, it is thus enabled to handle JSON as well as XML. 
        The extended node model is dubbed a Unified Document Language, as it defines the 
        construction of documents from building blocks (nodes)
        which can be encoded in various markup languages (XML, JSON, HTML).      
      </para></abstract><author><personname><firstname>Hans-Jürgen</firstname><surname>Rennau</surname></personname><personblurb><para/></personblurb><affiliation><jobtitle>Senior Java developer</jobtitle><orgname>Traveltainment GmbH</orgname></affiliation><email>hrennau@yahoo.de</email></author><legalnotice><para>Copyright © 2012 by the author. Used with permission.</para></legalnotice><keywordset role="author"><keyword>UDL</keyword><keyword>XML</keyword><keyword>JSON&gt;</keyword><keyword>Markup integration</keyword><keyword>XDM</keyword><keyword>XPath</keyword><keyword>XQuery</keyword><keyword>XSLT</keyword></keywordset></info><section xml:id="introduction"><title>Introduction</title><para>
      Is an XML document a string or a tree of nodes? Although in many situations it can be 
      regarded as both, the “node view” is certainly more essential. It ignores syntax and 
      sees the information content. Specialized programs (parser and serializer) provide for 
      the translation between document string and node tree. General processing technologies – 
      e.g. XQuery - ignore syntax. This principle is the very foundation of their power. 
      Technologically speaking, the name “extensible markup language” is questionable, as it 
      emphasizes the surface, rather than the content.
    </para><para>
      The node view of XML is the result of an evolutionary process. The XML specification 
      [<xref linkend="W3C-XML"/>] (1998) itself does not use the word “node”. The tree 
      structure is still implicit, hidden behind the rules of well-formedness. The 
      infoset specification [<xref linkend="W3C-INFOSET"/>] (2004) defined the XML document 
      as a tree of information items, which is similar to a tree of nodes.
      The XDM [<xref linkend="W3C-XDM"/>] (2007) rounded the tree model 
      off, pruning it and extending it by replacing character children by a further node kind, 
      the text node. This completed node model was at the heart of the technological leap which 
      led to XPath 2.0, XSLT 2.0 and XQuery 1.0.
    </para><para>
      Taking the evolution into consideration, one might wonder about the relationship between 
      XML and JSON. It is an obvious fact that they are two markup languages. But if XML is 
      essentially not a syntax, but an information language backed by a syntax – then we should 
      regard JSON as an information language plus syntax, too, and we should explore the 
      relationships between their information models, rather than dwell on the difference of 
      syntax. 
    </para><para>
      Both models are tree models for hierarchical data. Why don’t we have one single, unified 
      model for hierarchical data? If we had one, XML and JSON would not be two languages, but 
      two syntactical styles – a difference that ceases to exist during data processing, between 
      parsing and serializing the data. A uniform data model would enable unified data design 
      approaches, and data processing could be handled by one single set of technologies. XML 
      and JSON parsers would act like adapters. Unfortunately, such a unified model does not 
      exist, due to incompatibilities. Although the XML model is larger and more complex, it 
      is not a superset of the JSON model. XML lacks arrays and maps and XML names cannot 
      be arbitrary strings.
    </para><para>
      These incompatibilities throw a new light on XML. In 2011 Jonathan Robie 
      concluded [<xref linkend="ROBIE"/>]:
         <blockquote><para><emphasis role="ital">
           The dream of one universal markup language is now past. JSON is clearly here to 
           stay, and it is becoming the format of choice for data interchange.
         </emphasis></para></blockquote>
    </para><para>
      A possible response to this perception is a new dream: the dream of one universal 
      information language, backed by several syntax variants aka markup languages. 
      If XML is not as universal as it looked a few years ago – might we extend the 
      language (no pun intended), restoring the universality? This dream is an illusion 
      if we regard XML as a final version. In past years, any considered 
      improvements of XML were too insignificant to warrant the disruptions which a new 
      version might entail. But now we face new proportions, dealing with the issue of 
      universality. We should explore our chances to regain universality by extending 
      the XML model in a moderate, backward compatible way. Eventually, the lessons JSON 
      taught and teaches us might be to a huge benefit of XML – if we attempt to learn 
      them and act accordingly.
    </para></section><section xml:id="distinction-between-markup-and-document-language"><title>Distinction between markup and document language</title><para>
      XML processing technology operates on node trees which capture 
      the information content of XML documents. The nodes may be constructed 
      from XML markup text, or in other ways. An XML document 
      <emphasis role="ital">is</emphasis> a tree of nodes, 
      and it may be <emphasis role="ital">represented</emphasis> by markup. 
      Therefore one might distinguish a <emphasis role="bold">document language</emphasis>
      from a <emphasis role="bold">markup language</emphasis>. The former is a 
      system which defines basic 
      units of information, possible relationships between such units and rules how 
      they can be combined into composite entities, the document. A markup language 
      is a set of rules how to encode a document as a string. To complete the picture, one might 
      add the concept of an <emphasis role="bold">information language</emphasis>, 
      which models information in a more 
      general way – documents and their building blocks, the material 
      that may be inserted into or extracted from a document, and perhaps yet
      other forms of information. The triple XML / Infoset /
      XDM may be viewed as a stack consisting of a markup language, a document language 
      and an information language. 
      This stack of languages is the foundation of technologies – XPath, XQuery, 
      XSLT, XProc – which enable to address and process information with amazing 
      simplicity and efficiency. 
    </para><para>
      <note><title>Use of the term "node model"</title><para>
          The node sub model of the XDM can be regarded as a refactoring of the 
          infoset. The existence of two very similar, yet  distinct tree models – 
          a tree of information items, and a tree of nodes representing the 
          information items – is not really necessary and probably due to a 
          historical process. In this paper, it is the XDM/nodes sub model what 
          is regarded as the document model, rather than the infoset. The term 
          used will be “XML node model”, or simply “node model”.
        </para></note>
    </para><para>
      Nevertheless, JSON has begun to replace XML in many applications. JSON is a 
      simpler and terser markup language, and it is perfectly integrated with 
      JavaScript objects. In many situations, JSON has clear advantages, when 
      neither the loss of expressive power, nor the lack of processing 
      technologies hurt. There is a growing awareness of the need to be 
      flexible, to avoid overhead and use the right tools: the necessity to adapt 
      the choice of markup language to the task at hand [<xref linkend="TENNISON"/>].
    </para><para>
      Doubtless, the technological support for JSON will continuously evolve. 
      Very doubtful, however, it is if it can ever achieve the level attained 
      by XQuery 3.0 and XSLT 3.0. Maybe this will not be possible without a 
      similar evolution, adding to the markup language a document language 
      and an information language on which to base technology. I cannot 
      image that this would be possible without reinventing many wheels, with 
      the end result – in the best case – of a more limited version of XQuery and XSLT.
    </para><para>
      Let us explore the alternative: loosen the tight coupling between the 
      XML markup language and the XML document language, extending the latter 
      to become a unified document language (“UDL”) supporting multiple markup 
      languages – XML, JSON, HTML, …
    </para></section><section xml:id="the-main-idea"><title>
      The main idea
    </title><para>
      This section presents the main idea of UDL – Unified Document Language -
      in a suggestive way and without any precision. It should provide a 
      conceptual backdrop for the remaining sections. What is a document 
      from the “UDL point of view”?
    </para><para>
      A document is a tree of elements. An element has content, which is either 
      text, or other elements, or both. An element has also two properties 
      designed to identify individual elements and to indicate the semantics 
      of the content. One property is the 
      <emphasis role="bold">element name</emphasis>, the other one the 
      <emphasis role="bold">element key</emphasis>. The name is a QName 
      and can be chosen irrespective of the sibling names; the key is an 
      arbitrary string and must not be equal to any sibling key.
      This duality implies three different styles how a document may be 
      designed:
      <itemizedlist><listitem><para>
            name oriented – the elements are identified and described by names
          </para></listitem><listitem><para>
            key oriented – the elements are identified and described by keys
          </para></listitem><listitem><para>
            mixed – making use of both, names and keys
          </para></listitem></itemizedlist>
    </para><para>
      A document can be represented as a string, using a markup language. 
      XML is a markup language well-suited for name oriented documents; 
      JSON, on the other hand, is good at representing key oriented documents. 
      JSON is limited in this respect that it cannot represent arbitrary documents. 
      Only documents meeting certain constraints (using only unspecific standard 
      names, no attributes, no mixed content) can be represented by JSON. 
      XML, on the other hand, can represent any document, though not very 
      elegantly in the case of key oriented documents. 
    </para><para>
      The foundation of document processing is the XPath language, with a core 
      designed for selecting nodes within a document. Its query syntax supports 
      a stepwise navigation across the document, where each step filters a set 
      of candidate nodes by a so-called node test. One node test – the name 
      test - refers to the name property. Example:
      <programlisting xml:space="preserve">
  a/b[.//c]</programlisting>
      This is a selection wholly based on element names. Another node test –
      the key test – refers to the key property. Example:
      <programlisting xml:space="preserve">
  #a/#b[.//#c]</programlisting>
      This selection is based on element keys, rather than names. 
      Apart from that, the logic is exactly the same. Of course, node tests 
      and key tests can be mixed:
      <programlisting xml:space="preserve">
  a/b[.//#c]</programlisting>
    </para><para>
      To generalize, element name and element key are just two properties 
      which XPath expressions and languages built upon XPath (XQuery, XSLT,
      XProc) can reference in a similar way. XML documents and JSON 
      documents are alternative styles of how to represent a UDL document 
      as text string. A parser translates XML documents and JSON documents 
      into UDL documents. A serializer translates a UDL document into an 
      XML document or a JSON document. The translation into XML is always 
      possible without loss of information. The translation into JSON 
      deals with any loss of information as prescribed by 
      serialization parameters. 
    </para><para>
      The remaining sections present a detailed proposal how to implement 
      the UDL by very limited extensions of the XML node model, XML markup, 
      XPath and XQuery.
    </para></section><section xml:id="goals-and-non-goals"><title>Goals and non-goals</title><para>
      The XML node model shall be turned into a
      unified document language, so that XML
      processing technology - which is built on
      the node model, not on markup - 
      becomes a unified processing technology. In particular,
      the document language must support JSON so that
      the processing technology (XPath, XQuery, XSLT, XProc)
      becomes applicable to JSON data as well as to XML data.
    </para><para>From this high-level objective 
      several goals are derived.
    </para><para>
      <itemizedlist><listitem><para>Extend the XML node model, enabling it to represent the information 
            content of JSON documents as a tree of nodes.</para></listitem><listitem><para>Define the serialization to/deserialization from JSON markup.</para></listitem><listitem><para>Extend the XML markup language, enabling it to express the 
            extended node model completely.</para></listitem><listitem><para>Extend the XML markup language, enabling the combination of 
            XML and non-XML markup.</para></listitem><listitem><para>Extend the XPath language, enabling navigation of JSON documents with the 
            same degree of terseness and flexibility.</para></listitem><listitem><para>Extend the XQuery language, adding shorthand notation for the construction
            of JSON data.</para></listitem><listitem><para>Make any changes to the XML node model in a backwards compatible way.</para></listitem><listitem><para>Make any changes to the XML markup language in a backwards compatible way.</para></listitem><listitem><para>Make any changes to the XPath language in a backwards compatible way.</para></listitem><listitem><para>Make any changes to the XQuery language in a backwards compatible way.</para></listitem></itemizedlist>
      These are non-goals.
      <itemizedlist><listitem><para>
            Do not attempt to define a mapping from JSON markup to 
            XML markup (rather, define deserialization from / 
            serialization to JSON).

          </para></listitem><listitem><para>
            Do not attempt to achieve elegance concerning the XML markup 
            representation of a node tree derived from a JSON document.
          </para></listitem><listitem><para>
            Do not attempt to support characters which are valid in JSON but are 
            not valid in XML.
          </para></listitem></itemizedlist>
    </para></section><section xml:id="concepts"><title>Concepts</title><para>
      The proposed approach is an elaboration of a small number of concepts.
    </para><section xml:id="the-node-model-as-a-unified-document-language"><title>
        The node model as a unified document language
      </title><para>
         <orderedlist><listitem><para>
                 The XML node model is extended in such a way that any 
                 JSON document can be translated into a node tree
                 and back again without loss of information.
               </para></listitem><listitem><para>
                 XML markup continues to represent the complete node model – 
                 an extension of the node model must be accompanied by an 
                 extension of the XML markup language.
               </para></listitem><listitem><para>
                 As JSON markup represents a subset of the node model, 
                 the concept of serialization is elaborated, defining distinct 
                 modes characterized by the acceptable loss of information.
               </para></listitem></orderedlist>
      </para></section><section xml:id="the-node-representation-of-json-markup"><title>
        The node representation of JSON markup
      </title><para>
         <orderedlist><listitem><para>
                 JSON structures (objects and arrays) and their members are modelled 
                 as element nodes and their child elements, thus enabling continuous 
                 navigation along the descendant axis.
               </para></listitem><listitem><para>
                 As JSON names can be arbitrary strings and must be unique among
                 sibling name/value pairs, they must not represent node 
                 names, which are QNames and need not be unique among
                 sibling elements. Rather, JSON names correspond to a new 
                 node property, [key]. As a consequence, 
                 element nodes have two properties 
                 related to discovery and content semantics: a required [name] property and an 
                 optional [key] property.
               </para></listitem><listitem><para>
                 The contradiction implied by the facts that node names are required and 
                 JSON is incapable of encoding node names is solved by the concept of 
                 <emphasis role="ital">defaulted node names</emphasis>: the nodes 
                 represented by JSON markup do have a name which is an unspecific 
                 standard name that depends on the content model of the 
                 node (representing an object, an array, a simple value or a null value). 
                 A node which has been constructed from JSON markup can afterwards be 
                 renamed without constraints, like any node constructed in any way.
               </para></listitem></orderedlist>
      </para></section><section xml:id="concepts-extensions-of-the-xml-markup-language"><title>
        Extensions of the XML markup language
      </title><para>
         <orderedlist><listitem><para>
                 The necessary extension of the XML markup language avoids new 
                 syntactical constructs – it completely relies on the semantics 
                 of predefined QNames (e.g. <code>udl:key</code>) used in pseudo-attributes 
                 (constructs which look like an attribute but do not represent a node) 
                 and pseudo-tags (which look like an element but do 
                 not represent a node).
               </para></listitem><listitem><para>
                 XML markup should be “opened”, permitting the local insertion of non-XML markup.
               </para></listitem></orderedlist>
      </para></section><section xml:id="concepts-extensions-of-the-xpath-language"><title>
        Extensions of the XPath language
      </title><para>
        <orderedlist><listitem><para>
              The XPath language is extended by a third node test – the 
              <emphasis role="ital">key test</emphasis>, which checks whether 
              the candidate node has a given key. In a path step, the key test 
              can be used as alternative to a name test or kind test, which 
              means that key tests are freely combinable with navigational axes.
            </para></listitem><listitem><para>
              The syntax of a key test should be as simple as the syntax of a name test.
            </para></listitem></orderedlist>        
      </para></section><section xml:id="concepts-extensions-of-the-xquery-language"><title>
        Extensions of the XQuery language
      </title><para>
        <orderedlist><listitem><para>
              Extensions of the XQuery language are not essential, as JSON
              data are element nodes and thus can be processed without any
              restrictions. 
            </para></listitem><listitem><para>
              Nevertheless, the addition of some abbreviated
              syntax for the construction of  "JSON style nodes" 
              would be quite helpful.
            </para></listitem></orderedlist>
      </para></section></section><section xml:id="proposal-extensions-of-xml-xpath-and_xquery"><title>
      Proposal: extensions of XML, XPath and XQuery
    </title><para>
       This section describes the proposed extensions of XML, XPath and XQuery in detail.
    </para><section xml:id="extensions-of-the-xml-node-model"><title>
        Extensions of the XML node model
      </title><para>
        The XML node model is extended by two new node properties, [model] 
        and [key]. The result of these changes is a unified node model 
        which can represent XML documents, JSON documents as well as nested 
        combinations of JSON and XML fragments as a tree of nodes which 
        is accessible to XPath navigation and, by implication, XQuery 
        and XSLT processing.
      </para><para>
        <emphasis role="bold"><emphasis role="ital">
          Details
        </emphasis></emphasis>
      </para><orderedlist><listitem><para>
            The node model is extended by a further node property: the 
            <emphasis role="bold">[key] property</emphasis>. Only element 
            nodes have a [key], which is possibly empty. The [key] must not
            be empty if the [parent] is an element whose
            [model] property (see below) has a value of "map". In any other
            case (i.e. if [parent] is empty, or is not an element node,
            or is an element whose [model] is "sequence")
            the [key] must be empty. The [key] of an element must not be
            equal to the [key] of any sibling element.
          </para></listitem><listitem><para>
            The node model is extended by a further node property: the 
            <emphasis role="bold">[model] property</emphasis>. Only
            element nodes have a [model], the value of which must be
            either "sequence" or "map". If the
            value is "sequence", the child nodes are an ordered
            collection and child elements must not have a [key]. Conversely, 
            if the value is "map", the child nodes are an unordered
            collection, every child element must have a [key] and there
            must not be text node children containing a non-whitespace
            character. Note that the [model] can be regarded as a
            switch selecting one of two possible content models:
            sequence based (property value "sequence") or
            key based (property value "map"). In the former case
            element content is a sequence of child nodes; in the
            latter case element content is a map of
            child elements, using the child [key]s as map keys.
            The former case corresponds to "conventional XML", 
            where content is always ordered by position.
          </para></listitem><listitem><para>
            <emphasis role="bold">JSON simple values</emphasis>
            are represented by (not nilled) element nodes which have simple 
            content, or (in the case of a zero-length string)
            empty content and a [schema-type] xs:untypedAtomic.
          </para></listitem><listitem><para>
            <emphasis role="bold">JSON null values</emphasis> are represented 
            by nilled elements.
          </para></listitem><listitem><para>
            <emphasis role="bold">JSON objects</emphasis> 
            are represented by (not nilled) element nodes 
            with [model] equal "map". By implication, such
            elements may or may not have child elements, but
            they have no text node children containing
            non-whitespace characters.
            The name/value pairs contained by the object are represented by 
            the element children. Other child nodes (e.g. comments or 
            whitespace-only text nodes) do not correspond to name/value pairs.
            Note that an empty object is represented by an element
            with [model] equal "map" and no child elements.
         </para></listitem><listitem><para>
            <emphasis role="bold">JSON arrays</emphasis> are represented by 
            (not nilled) element nodes satisfying these constraints: (a)
            [model] equal "sequence",
            (b) the content is either empty or contains at least one child element; 
            (c) there are no text node children containing non-whitespace characters. 
            The array members are represented by the element children. 
            Other child nodes (e.g. comments or whitespace-only text nodes) 
            do not correspond to array members.
          </para></listitem><listitem><para>
            <emphasis role="bold">JSON names</emphasis> are represented by 
            the [key] property of element nodes.
          </para></listitem><listitem><para>
            When a node tree is constructed from a JSON document, null values, 
            simple values, arrays and objects are represented by elements which 
            have <emphasis role="bold">default node-names</emphasis> (
            <code>udl:null</code>, 
            <code>udl:value</code>, 
            <code>udl:array</code> and 
            <code>udl:map</code>). 
            As any element names in XML, these names do not have any 
            built-in semantics: they do not signal that the element has
            been constructed from a JSON value, and they do not imply specific 
            values of any node properties. 
            After an update or if the node tree is constructed in any other way, 
            the elements representing null values, simple values, arrays and objects 
            may have any valid node name.
          </para><para>
            Note that JSON names and XML names correspond to two distinct node 
            properties which are utterly independent of each other. And also 
            note the asymmetry: whereas JSON names are represented in XML markup 
            by keys (via the <code>udl:key</code> 
            pseudo-attribute, see next section), XML names cannot 
            be represented in JSON markup at all. Lossless information mapping in 
            both directions is nevertheless enabled by arbitrarily defining 
            JSON markup to represent nodes with default names which are
            implied by other node properties.
          </para></listitem></orderedlist></section><section xml:id="extensions-of-the-xml-markup-language"><title>
        Extensions of the XML markup language
      </title><para>
        The extensions have two purposes: (a) express the 
        new node properties; (b) support the use of non-XML markup within XML 
        documents.
      </para><section xml:id="expressing-the-new-node-properties"><title>
          Expressing the new node properties
        </title><para>
          The XML markup language is extended by rules how to represent the new 
          node properties.
        </para><para>
          <emphasis role="bold"><emphasis role="ital">
            Details
          </emphasis></emphasis>
        </para><orderedlist><listitem><para>
              A pseudo-attribute (<code>udl:model</code>) is introduced which indicates 
              the value of the <emphasis role="bold">[model] property</emphasis>. 
              Possible values are "sequence" and
              "map". The default value is "sequence", unless the element has an
              ancestor element with a pseudo-attribute <code>udl:defaultModel</code>,
              in which case the default is specified by the nearest ancestor 
              with a <code>udl:defaultModel</code> pseudo-attribute.
            </para></listitem><listitem><para>
              A pseudo-attribute (<code>udl:defaultModel</code>) is introduced which 
              sets the default value of [model] for the element itself and its
              descendants. The default value applies to the element itself and
              to its descendant elements unless the element in question has
              simple content (in which case [model] is always "sequence"),
              or has a [model] pseudo-attribute (which overrides the default)
              or has a nearer ancestor with a 
              <code>udl:defaultModel</code> pseudo-attribute (which shadows
              any outer default values).
            </para></listitem><listitem><para>
              A pseudo-attribute (<code>udl:key</code>) is introduced which indicates 
              the value of the <emphasis role="bold">[key] property</emphasis>. 
              If an element without <code>udl:key</code> is child of an 
              element whose [model] is "map", the [key] defaults to the local
              name of the element. Example:
              <programlisting xml:space="preserve">
   &lt;foo udl:model="map"&gt;
      &lt;bar udl:key="bar"&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</programlisting>
              is equivalent to:
              <programlisting xml:space="preserve">
   &lt;foo udl:model="map"&gt;
      &lt;bar&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</programlisting>
              Note that non-empty [key]s are only allowed for elements
              with [parent].[model] equal "map". Accordingly, only such
              elements may have a <code>udl:key</code> pseudo-attribute.
              Example: if in the following markup
              <programlisting xml:space="preserve">
   &lt;foo udl:model="map"&gt;
      &lt;bar udl:key="21"&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</programlisting>
              the value of <code>udl:model</code> were changed to
              "sequence", the markup would cease to be well-formed.
            </para></listitem></orderedlist></section><section xml:id="supporting-non-xml-markup"><title>
          Supporting non-XML markup
        </title><para>
          The extensions enable the use of non-XML markup either embedded 
          in XML markup or completely replacing it.
        </para><para>
          <emphasis role="bold"><emphasis role="ital">
            Details
          </emphasis></emphasis>
        </para><orderedlist><listitem><para>
              The XML syntax model is extended by permitting 
              <emphasis role="bold">alternative markup languages</emphasis>. 
              An alternative language can be used in three 
              different scopes: (a) the content of an element, (b)  
              a document section of arbitrary length, representing any
              number of sibling nodes, 
              (c) the complete document. Three languages are supported: 
              <code>xml</code>,
              <code>json</code>,
              <code>telem</code>,
              a slightly simplified version of XML 
              using JSON-like constructs for simple elements meeting 
              certain constraints. See 
              <xref linkend="mixing-markup-styles"/> for details.
            </para></listitem><listitem><para>
              The XML syntax model is extended by a pseudo-attribute, 
              <code>udl:markup</code>, which specifies the markup 
              language used to represent the content of an element. 
              If the value is not <code>xml</code>, the child nodes
              of the element
              are the nodes constructed from the markup found in the
              text content.
              Only element tags and the pseudo-tag <code>udl:markupSection</code>
              (see below) may have this 
              pseudo-attribute. Possible values are: 
              <code>xml</code>, 
              <code>json</code>, 
              <code>telem</code>; 
              default value is <code>xml</code>. Example:
              <programlisting xml:space="preserve">
   &lt;temperatures y="2012" 
                 udl:markup="json"&gt;&lt;![CDATA[
      "2012-08-01" : 33.2,
      "2012-08-02" : 28.9,
      "2012-08-03" : 30.0,
      "sites" : ["AB", "DK", "PP"],
      "anno" : {"automatic" : true, "reference" : false}
   ]]&gt;&lt;/temperatures&gt;</programlisting>
              Note that the scope of the alternative 
              markup language is the content of an element and 
              that the alternative representation is preceded and 
              followed by the XML start and end tag of the element. 
              Thus the markup of the example corresponds to an 
              element with name “temperatures”, which has one attribute 
              and five child elements. An XML document can use 
              different markup languages in different elements. 
            </para></listitem><listitem><para>
              The XML syntax model is extended by a pseudo-tag 
              <code>udl:markupSection</code>, which delimits a 
              markup section, a section of the document text which 
              uses a particular markup language. 
              When constructing the node tree, the pseudo-tag and 
              its contents represent the nodes constructed from 
              the contained markup. The markup language is identified 
              by the <code>udl:markup</code> pseudo-attribute 
              contained by the pseudo-tag. In the following 
              example, the pseudo-tag represents five nodes 
              which are constructed from the JSON markup:          
              <programlisting xml:space="preserve">
   &lt;udl:markupSection udl:markup="JSON"&gt;&lt;![CDATA[
      "2012-08-01" : 33.2,
      "2012-08-02" : 28.9,
      "2012-08-03" : 30.0,
      "sites" : ["AB", "DK", "PP"],
      "anno" : {"automatic" : true, "reference" : false}
   ]]&gt;&lt;/udl:markupSection&gt;</programlisting>
              Note that the pseudo-tag does itself not represent a node – 
              it has a purely delimiting function.
              Any non-XML markup may be used which is supported by the 
              parser. Besides JSON, a parser may support an 
              implementation-defined set of further markup languages 
              or domain specific languages.
            </para></listitem><listitem><para>
              The <emphasis role="bold">XML declaration</emphasis> is 
              extended by a further field: <code>markup</code>. Possible 
              values are: 
              <code>xml</code>, 
              <code>json</code>, 
              <code>html</code>; 
              default is <code>xml</code>. Depending on the value, 
              the text following the XML declaration will be 
              interpreted as XML markup, JSON markup or HTML markup. 
              Example:
              <programlisting xml:space="preserve">
   &lt;?xml markup="json" encoding="ISO-8859-1"?&gt;
   {
      "title" : "JSON and XML",
      "year" : 2012
   }</programlisting>
            </para></listitem><listitem><para>
              The XML markup language is augmented by a rule how to parse a 
              <emphasis role="bold">non-XML document without
              XML declaration</emphasis>. If the first non-whitespace character 
              of the text is not the “&lt;” character, the document text is 
              interpreted as non-XML markup. More precisely, it is 
              interpreted as the default non-XML markup which is expected 
              to be JSON, although implementation-defined alternatives 
              might be considered. Example: the text
              <programlisting xml:space="preserve">
   {
      "title" : "JSON and XML",
      "year" : 2012
   }</programlisting>
              is a valid UDL document.
            </para></listitem></orderedlist></section></section><section xml:id="extensions-of-the-xml-serialization-model"><title>
        Extensions of the XML serialization model
      </title><para>
        The serialization model must be extended in order to support JSON output.
        <orderedlist><listitem><para>
              When the serialization method is <code>xml</code>, 
              serialization produces conventional XML markup, 
              augmented by the pseudo-attributes 
              <code>udl:key</code>, <code>udl:model</code> 
              and <code>udl:defaultModel</code> where appropriate.
            </para></listitem><listitem><para>
              When the serialization method is <code>xml</code>, the serialization 
              may nevertheless insert non-XML markup into the document text, 
              depending on serialization parameters. The non-XML markup is 
              constrained to represent element contents – that is, every 
              chunk of non-XML markup is scoped to represent the content 
              of an element whose start and end tag delimit the chunk.
            </para></listitem><listitem><para>
              When the serialization method is <code>xml</code>, additional 
              serialization parameters control the use of alternative markup 
              within selected elements. Parameter 
              <code>json-content-elements</code> contains a list of expanded 
              QNames, identifying the elements whose content shall be 
              represented as JSON markup. In a similar way, parameter 
              <code>telem-content-elements</code> identifies the elements 
              to be rendered using the <code>telem</code> style. 
              (For details see 
              <xref linkend="mixing-markup-styles"/>).
            </para></listitem><listitem><para>
              The value range of serialization parameter 
              <code>method</code> is extended by the value 
              <code>json</code>. This value lets the 
              complete document be serialized as JSON markup.
            </para></listitem><listitem><para>
              A new serialization parameter 
              <code>info-loss</code> specifies how to handle 
              information loss implied by the serialization.
              Special values relate to 
              situations where JSON markup should be produced but a 
              node to be serialized contains information which cannot 
              be expressed by a JSON representation. (There are three cases:
              (i) mixed content,
              (ii) the use of attributes,
              (iii) the use of non-standard element names.) 
              Three parameter values are supported: 
              <code>json.strict</code>, 
              <code>json.ignore-names</code>, and 
              <code>json.projection</code>. In case of <code>json.strict</code> the 
              serialization must be aborted; the value 
              <code>json.projection</code> mandates a projection 
              which simply ignores any information which cannot 
              be represented; 
              and the value <code>json.ignore-names</code> means that the 
              QNames of XML elements are ignored, but any other 
              incompatibility with the JSON model 
              (e.g. the use of attributes) 
              produces an unrecoverable error. (For details see
              <xref linkend="serialization-controlling-the-loss-of-information"/>.)
            </para></listitem></orderedlist>
      </para></section><section xml:id="extensions-of-the-xpath-language"><title>
         Extensions of the XPath language
       </title><para>
         The extensions are designed to make the processing of
         JSON data as powerful and convenient as the processing
         of XML data. Namely, the [key] property can be checked
         by a <emphasis role="ital">key test</emphasis>, 
         similarly to the checking of the node name by a
         node test.
       </para><orderedlist><listitem><para>
           The XPath language is extended by a new node test, 
           an alternative to the existing name test and kind test: 
           the <emphasis role="bold">key test</emphasis>. A key test 
           checks for the candidate node if it has a key equal to 
           a given key value. In path expressions, key tests can be 
           combined with XPath axes in the same way as kind tests 
           and name tests. The syntax of a key test is a # character           
           immediately followed by the key value delimited by single
           or double quotes. If the key value contains only name characters,
           the quotes can be omitted. If quotes are used, occurrences
           of the actual quote character within the key value
           must be escaped by an entity or character reference.
           The characters <code>&amp;</code> and <code>&lt;</code>
           must always be escaped.
           Examples of path steps containing a key test:
           <programlisting xml:space="preserve">
  #key1
  #"key1"
  #”key 2”
  self::"#key 2"
  descendant::#key3
  parent::#"#key4"
  ancestor::#'++14085! &amp;amp; O&amp;apos;Neill'</programlisting>
           </para></listitem><listitem><para>
             A new XPath function <code>fn:node-key</code> returns 
             the [key] of a given node, or the empty sequence 
             if the node has no [key]: 
             <programlisting xml:space="preserve">
  fn:node-key($node as node()?) as xs:string?</programlisting>
             Example: the expression
             <programlisting xml:space="preserve">
  string-join($x/ancestor-or-self::*/(concat(‘#’, fn:node-key(.)), ‘/’)</programlisting>
             might return a result like <code>#a/#b/#c</code>.
           </para></listitem><listitem><para>
             A new XPath function <code>fn:node-model</code> returns 
             the [model] of a given node, or the empty sequence
             if the node is not an element node. The [model] is 
             represented as a string
             which is either "sequence" or "map": 
             <programlisting xml:space="preserve">
  fn:node-model($node as node()?) as xs:string?</programlisting>
           </para></listitem><listitem><para>
             The semantics of function <code>fn:deep-equal</code>
             is modified as follows: (a) if the arguments are element
             nodes with different [key]s or with different
             [models]s, the function returns "false"; (b) if both 
             arguments are element nodes with [model] equal "map",
             the comparison ignores non-element children and
             ignores the order of element children.
           </para></listitem><listitem><para>
             The <emphasis role="ital">abbreviated syntax</emphasis> 
             is extended by a more intuitive
             syntax for accessing array members by index, which hides
             the fact that array members are child nodes:
             <programlisting xml:space="preserve">
  foo~[expr] </programlisting>
             is equal to

             <programlisting xml:space="preserve">
  foo/*[expr]</programlisting>
           </para></listitem></orderedlist></section><section xml:id="extensions-of-the-xquery-language"><title>
        Extensions of the XQuery language
      </title><para>
        As JSON items correspond to element nodes, there is no principal
        need to introduce new constructor expressions. In element
        constructors, the pseudo-attributse <code>udl:key</code> 
        and <code>udl:model</code> are used in the same way as they are
        used in XML markup. In order to reduce verbosity,
        however, several abbreviated variants of element constructors
        are introduced.
        <orderedlist><listitem><para>
              <emphasis role="bold">Map constructors</emphasis>
              are a shorthand for constructing element nodes 
              with name <code>udl:map</code> and [model] equal "map". Syntax:
              <programlisting xml:space="preserve">
{ Expr }

   is equivalent to:

&lt;udl:map udl:model="map"&gt;{ Expr }&lt;/udl:map&gt;</programlisting>
            </para><para>
              The children of the newly constructed <code>udl:map</code>
              element are obtained by (a) evaluating the
              content expession to an item sequence, (b) replacing
              in this sequence any document node by its document element,
              (c) replacing in the resulting sequence any element
              without a key by a copy which has a key equal to
              its local name. An error is raised if the result 
              sequence contains atomic or text node items, or if
              it contains two elements with the same key. Otherwise,
              the expression value is guaranteed to be an element
              which can be serialized to JSON without information loss.
            </para></listitem><listitem><para>
              <emphasis role="bold">Array constructors</emphasis>
              are a shorthand for constructing element nodes 
              which correspond to a JSON array. Syntax:
              <programlisting xml:space="preserve">
[ Expr ]

   is equivalent to the following code
   (where p:copy-without-key denotes a pseudo function creating an element copy without [key]):

&lt;udl:array&gt;{
  for $item in Expr return 
    typeswitch($item)
    case document-node()  return $item/*/p:copy-without-key(.)
    case element()        return $item/p:copy-without-key(.)
    case text()           return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
    case xs:anyAtomicType return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
    default               return ()
}&lt;/udl:array&gt;</programlisting>
              </para><para>
              The children of the newly constructed
              <code>udl:array</code> element are obtained by (a) evaluating
              the content expression to an item sequence, 
              (b) replacing in this sequence any document nodes by 
              their element children, 
              (c) replacing in the resulting sequence any element
              with a key by a copy which does not have a key, 
              (d) replacing in the resulting sequence any atomic values
              by a <code>udl:value</code> element containing the value as text. 
              The expression value is guaranteed to be an element which can
              be serialized to a JSON array without information loss.
            </para></listitem><listitem><para>
              <emphasis role="bold">Key-oriented constructors</emphasis>
              are a shorthand for constructing element nodes with a 
              non-empty [key]. 
              They have the following syntax:
              <programlisting xml:space="preserve">
   Expr ':' Expr

   Examples:
   "title" : "XML and JSON"
   $ti     : $tnode
   "title" : //title
   "times" : [ "2012-01-01", "2012-03-31" ],
   "time" : { "begin" : "2012-01-01", "end" : "2012-03-31" }</programlisting>
              The value of this expression is determined as follows.
              <itemizedlist><listitem><para>
                     Evaluate the expression to the left of the
                     colon; the result must be a single item; 
                     determine its string value S. 
                   </para></listitem><listitem><para>
                     Evaluate the expression to the right of the
                     colon; the result R must be either the
                     empty sequence or a single item.
                   </para></listitem><listitem><para>
                     If R is the empty sequence, the value of
                     the constructor expression is an element
                     node with name <code>udl:null</code>,
                     a [key] property equal S and a
                     [nilled] property equal true.
                   </para></listitem><listitem><para>
                     If R is a node, the value of the constructor expression
                     is a node obtained by making a copy of R
                     and setting its [key] property to S.
                   </para></listitem><listitem><para>
                     Otherwise (that is, if R is an atomic value)
                     the value of the constructor expression is an element 
                     node with the name <code>udl:value</code>,
                     a [key] property equal S and a single
                     text node child whose string value is 
                     the string value of R. (Special case:
                     empty content if the string value of R
                     is a zero-length string.)
                     The resulting element has a type annotation
                     which depends on the type of R. If R
                     has a number type, the type annotation is
                     one of these:
                     <code>xs:double</code>,
                     <code>xs:decimal</code>,
                     <code>xs:integer</code>, 
                     whatever is closest to the type of R.
                     If R has a boolean type, the type annotation is
                     <code>xs:boolean</code>. If R is a zero-length
                     string, the type annotation is 
                     <code>xs:untypedAtomic</code>. Otherwise, the
                     default type annotation is used (
                     <code>xs:untyped</code>).
                   </para></listitem></itemizedlist>
            </para></listitem></orderedlist>
      </para></section></section><section xml:id="checking-use-cases"><title>Checking use cases</title><para>
      The proposal made in this paper is motivated by several main use cases. In each of
      these, a significant simplification of the task should be achieved.
    </para><itemizedlist><listitem><para>
          JSON documents must be queried.
        </para></listitem><listitem><para>
          JSON documents must be transformed into other JSON documents.
        </para></listitem><listitem><para>
          JSON documents must be transformed into XML documents.
        </para></listitem><listitem><para>
          JSON documents must be transformed into HTML documents.
        </para></listitem><listitem><para>
          JSON documents must be transformed into other formats (e.g. CSV).
        </para></listitem><listitem><para>
          JSON documents must be created from XML documents.
        </para></listitem><listitem><para>
          JSON documents must be created from other formats (e.g. CSV).
        </para></listitem></itemizedlist><para>
      The fact that XML standard technologies - XPath, XQuery, XSLT, XProc -
      now accept JSON documents as input suggests a great advantage.
      We should however take a closer look at how the processing of JSON
      data looks. Somewhat arbitrarily, these main aspects may be 
      distinguished:
      <itemizedlist><listitem><para>
            Selecting JSON data
          </para></listitem><listitem><para>
            The use of JSON data within XPath/XQuery expressions
            and XSLT instructions
          </para></listitem><listitem><para>
            Creating JSON data
          </para></listitem></itemizedlist>
    </para><para>
      The <emphasis role="bold">selection of data</emphasis> 
      is a crucial operation, underlying
      virtually all forms of data processing. This is the domain
      of XPath, so we shall take a look at how XPath deals with JSON
      data. 
      The proposal avoids the creation of special item types -
      all JSON data reside in element nodes. Therefore it can
      be expected that the <emphasis role="bold">
      use of JSON data in expressions</emphasis>
      and XSLT instructions is indistinguishable from 
      the use of any other element nodes.
      The <emphasis role="bold">creation of JSON data</emphasis> 
      amounts to the creation of
      element nodes, so that again we may expect the same
      ease when creating JSON data as when creating any
      other element nodes.
    </para><para>
    Let us contemplate a few examples. As input we use the following
    JSON document:
    </para><programlisting xml:space="preserve">
[
   {
      "year" : 2011, 
      "title" : "JSON", 
      "author" : [
         {"last" : "Legoux", "first" : "C."}
      ], 
      "price" : 35.95,
      "sigs" : ["LL1002"]
   }, 
   {
      "year" : 2012, 
      "title" : "XML", 
      "author" : [
         {"last" : "Legoux", "first" : "C."}, 
         {"last" : "Berlin", "first" : "D."}
      ], 
      "price" : 29.95,
      "sigs" : []
   },
   {
      "year" : 2012, 
      "title" : "UDL", 
      "author" : [
         {"last" : "Legoux", "first" : "C."},
         {"last" : "Okuda", "first" : "J."}, 
         {"last" : "Berlin", "first" : "D."}
      ], 
      "price" : 49.95,
      "sigs" : ["KL4005", "KL4011"]
   }
]</programlisting><para>
      The following table shows a series of 
      <emphasis role="ital">data selections</emphasis> with
      XPath/XQuery. The expressions typically use key tests (#foo) 
      instead of name tests. Apart from that there is no difference
      compared to conventional uses of XPath. 
      Writing the expressions, one must keep in mind that object members
      (the name/value pairs) and array members are represented by child
      elements of the element representing the object or array,
      respectively.
    </para><para>
      <table><caption><para>
            <emphasis role="bold"><emphasis role="ital">
              Selecting JSON data with XPath/XQuery.
            </emphasis></emphasis>
          </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">task</th><th align="left" valign="top">expression</th><th align="left" valign="top">result</th></tr></thead><tbody><tr valign="top"><td>count books</td><td><code>count(/*/*)</code></td><td>3</td></tr><tr valign="top"><td>maximum price</td><td><code>max(//#price/xs:decimal(.))</code></td><td>
              <para>49.95</para>
            </td></tr><tr valign="top"><td>first book title</td><td><code>/*/*[1]/#title/string()</code></td><td>JSON</td></tr><tr valign="top"><td>all publication years</td><td><code>distinct-values(//#year/string())</code></td><td>2011 2012</td></tr><tr valign="top"><td>books about UDL</td><td><code>//#title[contains(., 'UDL')]/string()</code></td><td>UDL</td></tr><tr valign="top"><td>books above 30$</td><td><code>//#title[../#price/xs:decimal(.) gt 30]/string()</code></td><td>
              <para>JSON UDL</para>
            </td></tr><tr valign="top"><td>books with a single author</td><td><code>//#title[count(../#author/*) eq 1]</code></td><td>
              <para>JSON</para>
            </td></tr><tr valign="top"><td>books without signature</td><td><code>//#title[empty(../#sigs/*)]</code></td><td>
              <para>XML</para>
            </td></tr><tr valign="top"><td>books written by Legoux</td><td><code>/*/*[.//#last = 'Legoux']/#title/string()</code></td><td>
              <para>JSON XML UDL</para>
            </td></tr><tr valign="top"><td>coauthors of Legoux</td><td><code>distinct-values(//#last[. eq 'Legoux']/../../*/#last[. ne 'Legoux'])</code></td><td>
              <para>Berlin Okuda</para>
            </td></tr><tr valign="top"><td>duplicate signatures</td><td>
              <para><code>for $s in distinct-values(//#sigs/*)</code></para>
              <para><code>where count(//#sigs[* = $s]) gt 1</code></para>
              <para><code>return $s</code></para>
            </td><td>
              <para>LL1002</para>
            </td></tr></tbody></table>
    </para><para>
      In order to get a feeling how selected JSON data can be 
      <emphasis role="ital">used in expressions</emphasis>
      and how JSON data can be 
      <emphasis role="ital">constructed</emphasis>, 
      we build a report that transforms the input
      data into a new structure. The report shall list for each author
      all titles he or she has authored, along with the 
      publication year. An XML version of the report might look 
      like this:
      <programlisting xml:space="preserve">
&lt;authors&gt;
   &lt;author name="Legoux, C."&gt;
      &lt;book title="JSON" year="2011"/&gt;
      &lt;book title="UDL" year="2012"/&gt;
      &lt;book title="XML" year="2012"/&gt;
   &lt;/author&gt;
   &lt;author name="Okuda, J."&gt;
      &lt;book title="UDL" year="2012"/&gt;
   &lt;/author&gt;
   &lt;author name="Berlin, D."&gt;
      &lt;book title="UDL" year="2012"/&gt;
      &lt;book title="XML" year="2012"/&gt;
   &lt;/author&gt;
&lt;/authors&gt;
</programlisting>
      and a JSON version like this:
      <programlisting xml:space="preserve">
[
   {
      "author" : "Legoux, C.", 
      "books" : [
         {"title" : "JSON", "year" : "2011"}, 
         {"title" : "UDL",  "year" : "2012"}, 
         {"title" : "XML", "year" : "2012"}
      ]
   }, 
   {
      "author" : "Okuda, J.", 
      "books" : [
         {"title" : "UDL", "year" : "2012"}
      ]
   }, 
   {
      "author" : "Berlin, D.", 
      "books" : [
         {"title" : "UDL", "year" : "2012"}, 
         {"title" : "XML", "year" : "2012"}
      ]
   }
]</programlisting>
      The XML report can be produced with this query:
      <programlisting xml:space="preserve">
&lt;authors&gt;{
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      &lt;author name="{$author}"&gt;{
         for $book in $books
         order by $book/#title
         return 
            &lt;book title="{$book/#title}" year="{$book/#year}" /&gt;
      }&lt;/author&gt;   
}&lt;/authors&gt;
</programlisting>
      and the JSON version can be produced with this query:
      <programlisting xml:space="preserve">
&lt;udl:array&gt;{
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      &lt;udl:map udl:model="map"&gt;{
         &lt;udl:value udl:key="author"&gt;{$author}&lt;/udl:value&gt;,
         &lt;udl:array udl:key="books"&gt;{
            for $book in $books
            order by $book/#title
            return 
            &lt;udl:map udl:model="map"&gt;{
               &lt;udl:value udl:key="title"&gt;{$book/#title/string()}&lt;/udl:value&gt;,
               &lt;udl:value udl:key="year"&gt;{$book/#year/string()}&lt;/udl:value&gt;
            }&lt;/udl:map&gt;
         }&lt;/udl:array&gt;
      }&lt;/udl:map&gt;   
}&lt;/udl:array&gt;</programlisting>
      The element constructors required to create JSON nodes
      are somewhat verbose, and the code is not very readable
      as the distinctive information - the key - is embedded
      in stereotyped markup 
      (e.g. 
      <code>&lt;udl:map udl:key="..."&gt;</code>
      The situation can be amended by resorting to the 
      abbreviated constructors for maps and arrays along with
      the key-oriented constructors 
      (see <xref linkend="extensions-of-the-xquery-language"/>):
      <programlisting xml:space="preserve">
[
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      {
         "author" : $author,
         "books" : [
            for $book in $books
            order by $book/#title
            return 
               {
                  "title" : $book/#title/string(),
                  "year" : $book/#year/string()
               }
         ]
      }
]</programlisting>
      The code examples demonstrated that the processing of JSON data
      with XPath and XQuery is comparable to the processing of XML 
      data. For all use cases
      one may expect from XPath/XQuery/XSLT/XProc 
      the same level of support which one is used to get when 
      dealing with similar problems related to XML without JSON.
      This may be taken as encouragement to explore
      the proposal in greater detail.
    </para></section><section xml:id="various-details"><title>
      Various details
    </title><section xml:id="udl-pseudo-attributes-and-pseudo-tags"><title>
        UDL - pseudo-attributes and pseudo-tags
      </title><para>
        Pseudo-attributes are syntactical constructs which have the lexical 
        form of attributes but can be distinguished from them by the use of 
        a reserved QName. Pseudo-attributes do not represent an attribute node.
        Instead, they represent a node property 
        (<code>udl:key</code>, <code>udl:model</code>) or 
        a default value of a property 
        (<code>udl:defaultModel</code>), or they identify the markup language
        used locally (<code>udl:markup</code>).
      </para><para>
        Pseudo-tags are syntactical constructs which have the lexical form 
        of element tags but can be distinguished from them by the use of a 
        reserved QName. One pseudo-tag is introduced 
        (<code>udl:markupSection</code>) which delimits a section 
        of non-XML markup.
      </para><para>
        Four further names from the UDL namespace are used as 
        default element names, given to the nodes constructed 
        from JSON values. It is important to note that these 
        names have no specific semantics and can be used 
        as node name without restrictions like any other 
        QName. The only specific 
        treatment of these names is when serializing to JSON 
        using the <code>json.strict</code> mode. In this case a node 
        name which is different from the default name expected 
        (according to the node properties)
        is considered information that would be lost during
        serialization (see 
        <xref linkend="serialization-controlling-the-loss-of-information"/>).
      </para><para>
        The following table summarizes the use of QNames from the UDL 
        namespace.
      </para><para>
          <table xml:id="table-reserved-names"><caption><para>
                <emphasis role="bold"><emphasis role="ital">
                  Names in the 
                  <code>udl</code> namespace and their usage.
                </emphasis></emphasis>
              </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">Name</th><th align="left" valign="top">Usage category</th><th align="left" valign="top">Meaning</th></tr></thead><tbody><tr valign="top"><td><code>udl:null</code></td><td>element name</td><td>
                  a standard name available for nilled elements with an unspecific name
                </td></tr><tr valign="top"><td><code>udl:value</code></td><td>element name</td><td>
                  a standard name available for a simple content element with an unspecific name
                </td></tr><tr valign="top"><td><code>udl:array</code></td><td>element name</td><td>
                  a standard name available for a complex element with [model] equal "sequence"
                </td></tr><tr valign="top"><td><code>udl:map</code></td><td>element name</td><td>
                  a standard name available for a complex element with [model] equal "map"
                </td></tr><tr valign="top"><td><code>udl:markupSection</code></td><td>pseudo tag</td><td>
                  delimits a markup section containing markup which may 
                  be non-XML; the section represents the nodes resulting 
                  from parsing the contained markup text
                </td></tr><tr valign="top"><td><code>udl:markup</code></td><td>pseudo attribute</td><td>
                  indicates the markup language used within element content, or 
                  within a markup section
                </td></tr><tr valign="top"><td><code>udl:model</code></td><td>pseudo attribute</td><td>
                  represents the [model] property value
                </td></tr><tr valign="top"><td><code>udl:defaultModel</code></td><td>pseudo attribute</td><td>
                  sets a default value for the [model] property
                </td></tr><tr valign="top"><td><code>udl:key</code></td><td>pseudo attribute</td><td>
                  represents the [key] property value
                </td></tr></tbody></table>
        </para></section><section xml:id="mixing-markup-styles"><title>
        Mixing markup styles
      </title><para>
        The UDL defines a unified document model which can be 
        represented by different markup languages. This unified 
        content of heterogeneous outward shape invites not only 
        a free choice of the markup language actually used. It 
        also implies that markup languages might be mixed within 
        a document, based on simple rules how to delimit the 
        various chunks of markup. These rules are provided 
        by the <code>udl:markup</code> pseudo-attribute and the 
        <code>udl:markupSection </code>
        pseudo-tag (see 
        <xref linkend="supporting-non-xml-markup"/>).
      </para><para>
        Occasionally there may be good reasons to use mixed 
        styles. Consider the case that the document as a 
        whole cannot be represented as JSON (e.g. because 
        of attributes and namespaces), but subtrees 
        represent JSON documents (perhaps imported from 
        pure JSON sources, e.g. logged messages). 
        Without the mixing of markup 
        styles, the resulting serialization would be 
        difficult to read, due to the very verbose
        XML representation of JSON nodes. It should
        of course be remembered that this mixing of
        markup styles has no impact on the
        information content of the UDL document,
        which is exclusively defined in terms of nodes
        and their properties.
      </para><para>  
        The following section describes in detail an 
        additional markup style, which amounts to
        a "small-scale mixing" of XML and JSON, dubbed 
        <code>telem</code> (text notation for 
        simple elements).
      </para></section><section xml:id="xml-syntax-variant-telem"><title>
        XML syntax variant: <code>telem</code>
      </title><para>
        XML markup representing JSON data is 
        ugly. Typically it contains many elements which
        correspond to simple values and are 
        tiresome to read. The 
        <emphasis role="ital">distinctive</emphasis> property 
        of the elements is shifted from the 
        eye-catching node name to a pseudo-attribute, 
        and the markup is often inflated
        by explicit type annotations:
        <programlisting xml:space="preserve">
  &lt;udl:value udl:key=”foo”&gt;someContent&lt;/udl:value&gt;
  &lt;udl:value udl:key=”bar” xsi:type="xs:integer"&gt;99&lt;/udl:value&gt;
  &lt;udl:value udl:key=”foobar” xsi:type="xs:boolean"&gt;true&lt;/udl:value</programlisting>
        whereas the JSON representation could not be more succinct:
        <programlisting xml:space="preserve">
  "foo" : "someContent",
  ”bar”" : 99,
  "foobar” : true</programlisting>
      </para><para>
        Fragments containing <emphasis role="ital">only</emphasis>
        JSON nodes can best be represented by switching to JSON. But
        sometimes such JSON values occur interspersed with conventional
        XML elements which have specific names, have attributes, etc.
        In such cases it is attractive to apply the JSON
        style to the simple values and retain XML style for
        the fragment as a whole. This option is provided by
        the <code>telem</code> markup style. 
      </para><para>
        This style is XML markup augmented by a shorthand representation
        of simple elements meeting several constraints: 
        <itemizedlist><listitem><para>
              element name is the standard name <code>udl:value</code>
            </para></listitem><listitem><para>
              simple content or nilled
            </para></listitem><listitem><para>
              no attributes
            </para></listitem><listitem><para>
              [schema-type] is one of these:
              <code>xs:integer</code>, 
              <code>xs:decimal</code>, 
              <code>xs:double</code>, 
              <code>xs:boolean</code>,
              <code>xs:untypedAtomic</code>, 
              <code>xs:untyped</code>
            </para></listitem></itemizedlist>
      </para><para>
        The syntax corresponds to the JSON representation of a simple 
        or null value, or of a name/value pair with simple or null
        value, depending on whether the element has a [key]. 
        If consecutive element children are represented in 
        <code>telem</code> style, these representations are 
        separated by a comma. If the value is not put in quotes, it 
        must be a number or one of the constants 
        <code>true</code>, 
        <code>false</code> or 
        <code>null</code>, which will be interpreted as implicit type 
        information, following the JSON rules. Example: the following fragment
        <programlisting xml:space="preserve">
   &lt;e udl:model="map"&gt;
      &lt;udl:value udl:key="mode"&gt;repeated&lt;/udl:value&gt;
      &lt;udl:value udl:key="nrep" xsi:type=”xs:integer”&gt;52076&lt;/udl:value&gt;
      &lt;udl:value udl:key="eval" xs:type=”xs:boolean”&gt;true&lt;/udl:value&gt;
      &lt;locInfo udl:key="cities"&gt;
        &lt;udl:value&gt;Paris&lt;/udl:value&gt;
        &lt;udl:value&gt;London&lt;/udl:value&gt;
        &lt;udl:value&gt;Manchester&lt;/udl:value&gt;
      &lt;/locInfo&gt;
   &lt;/e&gt;</programlisting>
        may be alternatively represented this way:
        <programlisting xml:space="preserve">
   &lt;e udl:model="map" udl:markup=”telem”&gt;
      "mode" : “repeated”,
      "nrep" : 52076,
      “eval” : true
      &lt;locInfo udl:key="cities"&gt;
        "Paris",
        "London",
        "Mancester"
      &lt;/locInfo&gt;
   &lt;/e&gt;</programlisting>
        Both representations have the same information content.
      </para></section><section xml:id="deserializing-from-serializing-to-json"><title>
        Deserializing from / serializing to JSON
      </title><para>
        The exact rules for translating JSON into UDL (deserialization) and for 
        translating UDL into JSON (serialization) are listed in the appendix 
        (<xref linkend="appendix-deserialization"/>
        and <xref linkend="appendix-serialization"/>). 
        In this section, the principles are summarized.
      </para><section xml:id="deserialization"><title>
          Deserialization
        </title><para>
          During deserialization every JSON “item” (object, array, 
          simple value, null) is translated into a UDL element node whose 
          name and content are determined by the kind of the JSON 
          item (see 
          <xref linkend="table-deserialization"/>). 
          If the JSON item is associated with 
          a name, the name is copied into the [key] property of the 
          element node; otherwise the element node has no [key].
        </para><para>
          Numbers and Boolean constants are translated into 
          simple elements with a [schema-type] property reflecting 
          the source item (one of: 
          <code>xs:integer</code>,
          <code>xs:decimal</code>,
          <code>xs:double</code>,
          <code>xs:boolean</code>).
          A string which has non-zero length is translated into
          a simple element with [schema-type] <code>xs:untyped</code>.
          A zero-length string is translated into an 
          empty element node with
          [schema-type] <code>xs:untypedAtomic</code>,
          so as to make it distinguishable from a node 
          constructed from an empty array or object.
        </para><para>
          <table xml:id="table-deserialization"><caption><para>
                <emphasis role="bold"><emphasis role="ital">
                  Deserialization - translating JSON items into
                  UDL nodes.
                </emphasis></emphasis>
              </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top" rowspan="2">JSON item</th><th align="center" valign="top" colspan="3">UDL node properties</th><th align="left" valign="top" rowspan="2">remarks</th></tr><tr valign="top"><th align="left" valign="top">node-name</th><th align="left" valign="top">model</th><th align="left" valign="top">children</th></tr></thead><tbody><tr valign="top"><td>name/value pair</td><td>see below</td><td>see below</td><td>see below</td><td>
                  <para>
                    the JSON value can be any item kind (null, 
                    simple value, object, array);
                  </para>
                  <para>
                    all node properties – except 
                    for the [key] – depend on the item kind; 
                  </para>
                  <para>
                    the [key] is set to the JSON name 
                  </para>
                </td></tr><tr valign="top"><td>null</td><td><code>udl:null</code></td><td>sequence</td><td>none</td><td>element is nilled</td></tr><tr valign="top"><td>object</td><td><code>udl:map</code></td><td>map</td><td>elements, one for each name/value</td><td>all child elements have a [key]</td></tr><tr valign="top"><td>array</td><td><code>udl:array</code></td><td>sequence</td><td>elements, one for each member</td><td>all child elements without a [key]</td></tr><tr valign="top"><td>string (non-empty)</td><td><code>udl:value</code></td><td>sequence</td><td>text node</td><td>
                  <para>
                    [schema-type] is xs:untyped
                  </para>
                </td></tr><tr valign="top"><td>zero-length string</td><td><code>udl:value</code></td><td>sequence</td><td>none</td><td>
                  [schema-type] is xs:untypedAtomic
                </td></tr><tr valign="top"><td>number</td><td><code>udl:value</code></td><td>sequence</td><td>text node</td><td>
                  [schema-type] is one of: xs:integer, xs:decimal, xs:double
                </td></tr><tr valign="top"><td>true|false</td><td><code>udl:value</code></td><td>sequence</td><td>text node</td><td>
                  [schema-type] is xs:boolean
                </td></tr></tbody></table>
        </para></section><section xml:id="serialization"><title>
          Serialization
        </title><para>
          The translation of UDL nodes into JSON items does not depend on node 
          names; rather, it is wholly determined by the element content 
          (empty / element children / text child) and several properties 
          ([key], [model], [nilled], [schema-type]). The 
          node name is however checked if the serialization parameter 
          <code>info-loss</code> is <code>json.strict</code>. 
          In this case, the actual node name is compared with the 
          default node name associated with the given element content 
          and properties, and an unrecoverable error is raised if 
          actual node name and expected node name are not the same.
        </para><para>
          See <xref linkend="serialization-controlling-the-loss-of-information"/> 
          for details about how serialization may accept or reject loss of 
          information, dependent on serialization 
          parameter <code>info-loss</code>.
        </para><para>
          <table><caption><para>
                <emphasis role="bold"><emphasis role="ital">
                  Serialization - translating UDL nodes into JSON items. CT =
                  complex type with complex content; ST = simple type.
                </emphasis></emphasis>
              </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="center" valign="top" colspan="4">node properties</th><th align="center" valign="top">JSON item</th></tr><tr valign="top"><th align="left" valign="top">children</th><th align="left" valign="top">model</th><th align="left" valign="top">nilled</th><th align="left" valign="top">schema-type</th><th align="left" valign="top"/></tr></thead><tbody><tr valign="top"><td>empty</td><td>sequence</td><td>false</td><td><code>xs:untyped</code> or CT</td><td>array (empty)</td></tr><tr valign="top"><td>empty</td><td>sequence</td><td>false</td><td><code>xs:untypedAtomic</code> or ST</td><td>string (zero-length)</td></tr><tr valign="top"><td>empty</td><td>map</td><td>false</td><td>any</td><td>object (empty)</td></tr><tr valign="top"><td>empty</td><td>sequence</td><td>true</td><td>any</td><td>null</td></tr><tr valign="top"><td>element children</td><td>sequence</td><td>false</td><td>any</td><td>array</td></tr><tr valign="top"><td>element children</td><td>map</td><td>false</td><td>any</td><td>object</td></tr><tr valign="top"><td>text node</td><td>sequence</td><td>false</td><td><code>xs:double</code></td><td>number</td></tr><tr valign="top"><td>text node</td><td>sequence</td><td>false</td><td><code>xs:decimal</code></td><td>number</td></tr><tr valign="top"><td>text node</td><td>sequence</td><td>false</td><td><code>xs:integer</code></td><td>number</td></tr><tr valign="top"><td>text node</td><td>sequence</td><td>false</td><td><code>xs:boolean</code></td><td><code>true</code>|<code>false</code></td></tr><tr valign="top"><td>text node</td><td>sequence</td><td>false</td><td><code>xs:untyped</code> or ST</td><td>string</td></tr></tbody></table>
        </para></section></section><section xml:id="serialization-controlling-the-loss-of-information"><title>
        Serialization: controlling the loss of information
      </title><para>
        Serialization of a document to a markup language should 
        preserve all information so that the serialization is a 
        complete representation from which the document may be 
        reconstructed. Such a lossless serialization of a UDL 
        document is always possible for XML markup; it is only 
        in special cases possible for JSON markup. For example, 
        any attributes or non-default element names are lost 
        when serializing to JSON.
      </para><para>
        However, it depends on circumstances whether such loss 
        of information renders the serialization result worthless. 
        If, for example, the loss consists of element names only 
        and these names were only introduced in order to facilitate 
        document creation or processing, with an understanding that they will 
        get lost during later processing steps – then a serialization 
        which loses element names might be as valuable as a lossless 
        serialization. Such considerations suggest a refinement of 
        the serialization model: a new serialization parameter might 
        control what losses are acceptable and what losses are not 
        acceptable.
      </para><para>
        The proposal of a unified document language includes such a 
        new serialization parameter: 
        <code>info-loss</code>. Presently the parameter 
        is only relevant when serializing to JSON. Three values are 
        defined:
        <itemizedlist><listitem><para>
              <code>json.strict</code> – any information loss causes 
              an unrecoverable error
            </para></listitem><listitem><para>
              <code>json.ignore-names</code> – element names are ignored, 
              but any other information loss causes an unrecoverable 
              error
            </para></listitem><listitem><para>
              <code>json.projection</code> – any information that JSON 
              cannot represent is simply ignored
            </para></listitem></itemizedlist>
        In particular, <code>info-loss</code> equal 
        <code>json.projection</code> means:
        <itemizedlist><listitem><para>
              element names are ignored
            </para></listitem><listitem><para>
              attributes are ignored
            </para></listitem><listitem><para>
              text node siblings of element nodes are ignored (that is, mixed content
              is projected onto the element children)
            </para></listitem></itemizedlist>
      </para></section><section xml:id="udl-and-xsd"><title>
        UDL and XSD
      </title><para>
        The proposed extensions of the XML node model amount to 
        the introduction of two new node properties. Obviously, 
        they require also an extension of the XSD language. In 
        particular, constraints concerning the [key] property should 
        be supported. However, such changes are 
        out of scope of this paper.
      </para></section></section><section xml:id="limitations-and-future-research"><title>
      Limitations and future research
    </title><para>
      UDL defines the information content of JSON text in terms 
      of a node tree and provides the rules for translating between 
      text and tree, that is, parsing and serialization. This makes 
      JSON data accessible to / producible by XML processing technologies, 
      but there are also important use cases which are not addressed: 
      <orderedlist><listitem><para>
            given a JSON document, a well-readable XML representation 
            is required
          </para></listitem><listitem><para>
            given an arbitrary XML document, a JSON representation is 
            required
          </para></listitem><listitem><para>
            round-tripping XML - JSON - XML
          </para></listitem></orderedlist>
      As will be shown below, these are operations which require 
      some change of information content in the formal sense (in terms of 
      nodes and properties), necessary to create a “semantic” equivalence. 
      Such a change of information content cannot be achieved based on 
      parsing/serialization alone. This section explores the basic limitation 
      and makes a suggestion how an extension of the current UDL proposal 
      might look.
    </para><section xml:id="mapping-arbitrary-xml-to-json"><title>
        Issue: mapping arbitrary XML to JSON
      </title><para>
        A serialization of arbitrary XML documents to JSON is usually 
        not possible without a loss of information, as JSON cannot 
        natively express element names, the distinction between 
        attributes and elements, mixed content and the occurrence 
        of siblings with the same name. This does not mean that JSON 
        could not be used to represent the complete information content 
        of an arbitrary XML document. This representation would however 
        not be a serialization of the XML document tree to JSON, but 
        the (serialized) result of a 
        <emphasis role="ital">transformation</emphasis>, 
        a different node tree, adhering to a specific format which 
        is designed to capture the content of arbitrary XML 
        documents (e.g. [<xref linkend="JSONML"/>] ). 
        The equivalence between the 
        resulting JSON (or the node tree it represents) and 
        the original XML document is not based on the data model, 
        but established on the level of a specific mapping 
        application (as a set of rules). 
      </para></section><section xml:id="mapping-json-to-readable-xml"><title>
        Issue: mapping JSON to readable XML
      </title><para>
        A similar problem concerns the translation of JSON documents 
        into readable XML documents: the documents created by parsing 
        JSON as defined by UDL are well-suited for processing (e.g. 
        per XPath, XQuery, XSLT), but when serialized into XML text 
        look hardly readable. The practical need to obtain a well 
        readable XML representation of a given JSON document, however, 
        cannot be denied. (Think, for example, of a web service which 
        may at user option deliver XML or JSON results). Again, it is 
        a transformation from one tree to a different tree what is 
        required, as opposed to serializations into alternative 
        formats. 
      </para></section><section xml:id="round-tripping-xml-json-xml"><title>
        Issue: Round-tripping XML - JSON - XML
      </title><para>
        The impossibility of serializing arbitrary XML to JSON 
        of course implies that round-tripping XML-JSON-XML is 
        not generally possible solely based on serialization and parsing.
      </para></section><section xml:id="integration-of-standardized-mappings"><title>
        Conceivable extension of UDL: integration of standardized mappings
      </title><para>
        Given the scope of UDL’s main goal – a unified document 
        language supporting multiple markup languages – it may be questioned 
        if the UDL concept is complete if not addressing fundamental 
        mapping tasks, too. A conceivable extension of UDL might 
        include two parts: (a) the definition of 
        <emphasis role="ital">mappings</emphasis>, which 
        are standardized transformations (XML to JSON, lossless; 
        JSON to readable XML; (b) the integration of these mappings 
        with parsing / serialization into new “first-class” operations, 
        “<emphasis role="ital">mparse</emphasis>” (parse &amp; map) and 
        “<emphasis role="ital">mserialize</emphasis>” (map &amp; serialize). 
        The appendix contains a first step in this direction 
        [<xref linkend="appendix-b"/>], 
        which is, however, limited to the use case of JSON documents 
        in which all names are NCNames. Another limitation is that it 
        does not yet support attributes in the mapping result, which 
        probably cannot be the last say.  
      </para><para>
        The mapping between XML and JSON is a question to which 
        already many answers have been given (e.g. 
        [<xref linkend="LEE"/>], 
        [<xref linkend="PEMBERTON"/>], 
        [<xref linkend="COUTHURES"/>], 
        [<xref linkend="JSONML"/>], 
        [<xref linkend="BASEX"/>]). 
        The diversity is mainly due to differences between the 
        exact goals which the solutions pursue (concerning mapping 
        direction, losslessness, readability, configurability, …). 
        It is unclear if the suggested extension of UDL, which 
        involves standardized mappings between XML and JSON, is a 
        realistic task. But it is not hopeless, neither. First, the 
        unified node model provides a conceptual base which other 
        mapping approaches did not have. Second, the goals can be 
        defined precisely, which greatly removes competition between 
        existent solutions and a new standard. And finally, the 
        use of other, non-standard mappings would always remain 
        possible.
      </para></section></section><section xml:id="alternatives-to-udl"><title>
      Alternatives to UDL
    </title><para>
      How to process XML and JSON data in a unified way? The approach taken 
      by UDL should be compared with published alternatives. These fall 
      into two categories.
      <itemizedlist><listitem><para>
            mapping approach – map JSON data to an XML representation and 
            process the latter
          </para></listitem><listitem><para>
            XDM extension – extend the XDM by new item types which can 
            represent JSON data
          </para></listitem></itemizedlist>
      The second category contains two variants:
      <itemizedlist><listitem><para>
            extend the XDM by JSON-specific item types (JSONiq)
          </para></listitem><listitem><para>
            extend the XDM by generic item types (W3C XSL Working Group proposal)
          </para></listitem></itemizedlist>
    </para><para>
      The next three sections attempt to clarify the relationships between 
      these approaches and UDL.
    </para><section xml:id="the-mapping-approach"><title>
      The mapping approach
    </title><para>
      The mapping approach (e.g. <xref linkend="BASEX"/>, <xref linkend="PEMBERTON"/>) 
      is based on an XML 
      representation of JSON data. It uses a simple processing model:
      <itemizedlist><listitem><para>
            preprocessing: JSON =&gt; XML
          </para></listitem><listitem><para>
            processing: applied to XML data
          </para></listitem><listitem><para>
            optional postprocessing: serialization (possibly to JSON)
          </para></listitem></itemizedlist>

      This is a clean solution, provided the XML representation preserves all 
      information contained in the JSON data, and the mapping rule can be 
      applied bidirectionally without loss of information. To define such a 
      mapping is not very difficult, as one can use reserved element names and 
      introduce helper attributes in order to exclude any information loss 
      (see <xref linkend="table-mapping-approach-reserved-names"/> for examples).       

      <table xml:id="table-mapping-approach-reserved-names"><caption><para>
            <emphasis role="bold"><emphasis role="ital">
              The use of reserved element names and 
              helper attributes 
              to assist in the
              mapping of JSON to/from XML (examples).
            </emphasis></emphasis>
          </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top">source</th><th align="left" valign="top">elements</th><th align="left" valign="top">attributes</th></tr></thead><tbody><tr valign="top"><td><xref linkend="BASEX"/></td><td><code>json, value</code></td><td><code>arrays, booleans, nulls, numbers, objects, type </code></td></tr><tr valign="top"><td><xref linkend="COUTHURES"/></td><td><code>exml:anonymous</code></td><td><code>exml:fullname, exml:maxOccurs</code></td></tr><tr valign="top"><td><xref linkend="HUNTER"/></td><td><code>json, item</code></td><td><code>boolean, type</code></td></tr><tr valign="top"><td><xref linkend="PEMBERTON"/></td><td><code>json</code></td><td><code>name, starts, type</code></td></tr></tbody></table>
        Outwardly, UDL looks similar to such a 
        mapping-for-the-sake-of-processing; it is tempting to 
        classify it as yet another mapping variant. But that would 
        be a mistake. Mapping approaches treat the problem as an 
        XML <emphasis role="ital">application</emphasis>: 
        introduce a specific XML dialect designed to achieve a particular
        goal. Like any application, 
        these approaches are free to require the use 
        of application-specific element names and 
        the addition of attributes with application-specific semantics,
        to be evaluated by application code. The 
        <code>type</code> attribute, for example, used in 
        [<xref linkend="BASEX"/>] is a helper attribute which clearly 
        duplicates 
        <code>xsi:type</code> 
        for certain values, yet nevertheless
        had to be introduced as additional attribute, because 
        the value range includes values 
        <code>array</code> and <code>object</code>
        with ad hoc semantics dictated by the mapping 
        task. Such attributes reveal the fact that the
        current XML node model does not support a bidirectional
        mapping into JSON markup. To enable such a mapping,
        the node tree must contain special items with
        serialization semantics.
        This is at odds with the basic principle of serialization
        being a process solely controlled by serialization
        parameters, without a need to interfere with
        the information content of the node tree.
    </para><para>
      UDL does not <emphasis role="ital">map</emphasis>
      XML nodes to JSON structures.
      It redefines JSON to <emphasis role="ital">be</emphasis>
      a representation of nodes. As a consequence, it need not
      "inject" any ad hoc items into the data tree for
      the sake of controlling a serialization to JSON.
      None of the reserved element and attribute names in
      <xref linkend="table-reserved-names"/>
      have anything to do with JSON or serialization.
      Rather, they represent standard names without semantics,
      reflect node properties
      or signal the markup language currently used
      within a well-defined scope.
      The extended node model 
      is expressive enough to represent JSON structures 
      natively. 
    </para><para>
      The main difference between UDL and mapping 
      approaches concerns the handling of JSON names. Mapping 
      approaches represent JSON names as element names if possible, 
      and if not, resort to one of two possible solutions: either 
      place the JSON name in an additional attribute (e.g. 
      <xref linkend="PEMBERTON"/>), or define a bidirectional 
      name mapping 
      (e.g. <xref linkend="BASEX"/>). 
      But there are three differences between 
      the concepts of JSON names and XML names:
      <itemizedlist><listitem><para>
            a JSON name has no namespace component
          </para></listitem><listitem><para>
            a JSON name can use arbitrary characters
          </para></listitem><listitem><para>
            a JSON name must be unique amongst the JSON names of all 
            siblings
          </para></listitem></itemizedlist>
      Note that the last point (the uniqueness 
      constraint) means that a JSON name resembles an 
      <code>xml:id</code> attribute more than an element name.
      It can be compared to a locally scoped 
      <code>xml:id</code> attribute (uniqueness among all element 
      children of an element). 
      For these reasons UDL distinguishes
      the concepts of names and keys. It thus enables
      native relationships between nodes and
      XML markup on the one hand and JSON markup on
      the other hand. As a result it becomes possible
      to regard JSON markup and XML markup as alternative
      representations of an information content
      which is defined in terms of nodes and their
      properties.
      Remembering Plato, 
      one kind of “thing” is inferred from - or may cast -
      two different "shadows".
    </para><para>
      Should we not keep things simple - do we 
      <emphasis role="ital">need</emphasis> to 
      extend the document model and introduce new node properties? Imagine this alternative:
      <itemizedlist><listitem><para>
            the W3C publishes a small specification defining a standardized bi-directional 
            mapping between arbitrary strings and QNames
          </para></listitem><listitem><para>
            the XPath language syntax is slightly extended, introducing a second 
            notation of a name test (e.g. <code>#foo</code>)
            which is interpreted as a string which is 
            <emphasis role="ital">automatically mapped</emphasis> 
            to a QName according to the standard name mapping:
            <programlisting xml:space="preserve">
   a/b/#c       equivalent to:   a/b/c
   a/b/#c_d     equivalent to:   a/b/c__D
   a/b/#1       equivalent to:   a/b/_1
   a/b/#”1 2”   equivalent to:   a/b/_1_00322	   
</programlisting>
          </para></listitem></itemizedlist>
    </para><para>
      This is an attractive scenario: one can formulate the XPath expressions 
      without a mental translation, just using the names one 
      <emphasis role="ital">sees</emphasis> in the source data. The net 
      result is an elegant approach 
      to the processing of JSON data with XML tools. 
    </para><para>
      The approach would be a good – and perhaps 
      a better – alternative to UDL if the processing of JSON documents
      with XML tools were the only goal. However, UDL's design
      aims at a unified document model which expresses the entities
      represented by dominant markup languages in
      a native way. Only this way can information content and
      representation (markup) be decoupled and can the latter
      be switched easily at various scales (whole documents, sections
      or single elements) and in various contexts (data and
      program code).
    </para></section><section xml:id="jsoniq"><title>
      JSONiq
    </title><para>
      JSONiq 
      [<xref linkend="JSONIQ"/>], 
      [<xref linkend="JSONIQSPEC"/>] is an extension of the XQuery 
      language designed to add support for JSON data. Like UDL, 
      JSONiq extends the XDM in order to accommodate JSON structures. 
      However, JSONiq does not change the node sub model of the XDM. 
      Rather, two new item types are introduced, designed to represent 
      JSON data:
      <itemizedlist><listitem><para>object</para></listitem><listitem><para>array</para></listitem></itemizedlist>      
    </para><para>
      It is interesting to note the parallel: both, JSONiq and 
      UDL extend the XDM in order to accommodate JSON data; but 
      the changes UDL proposes are 
      <emphasis role="ital">within</emphasis> the node sub model, 
      whereas JSONiq adds a second sub model for structured data,
      in parallel to the node model. Using the terms proposed in 
      <xref linkend="distinction-between-markup-and-document-language"/>:
      JSONiq keeps the XML 
      document language, but extends the XML information language, 
      whereas UDL shifts the changes into the very document language, 
      refraining from changes outside of the node model.
    </para><para>
      An advantage UDL offers is to represent JSON data as node 
      trees and thus expose them to XPath navigation. JSONiq, 
      on the other hand, might be easier to accept exactly because 
      it does not introduce any change to the document language 
      and therefore restricts itself to the extension of a query 
      language, rather than an extension of XML.
    </para></section><section xml:id="map-items"><title>
      Map items
    </title><para>
      The W3C XSL Working Group has made a proposal for extending
      the XDM by a new item type: map items
      [<xref linkend="W3C-XSLT-3.0"/>]. They represent 
      generic containers, but nevertheless can represent
      JSON data. One should note the
      relationship between JSONiq and the map proposal:
      both approaches mandate new item types which 
      are not nodes and yet can represent structured
      data; but one (JSONiq) resorts to JSON-specific
      items, whereas the other advocates
      generic containers.
    </para><para>
      Not being nodes, map items
      are lightweight containers which can collect
      items without requiring or imposing a structural relationship.
      Therefore node relationships between container and members 
      are not possible. This contrasts sharply with the UDL approach 
      which models JSON containers and their members as nodes and
      their child nodes. Only this way can JSON data be seamlessly 
      integrated into the navigational system based on axes and 
      node tests.
    </para><para>
      This is not to say that such lightweight containers 
      would not be very useful extensions of XDM. Lightweight 
      containers and nodes cannot replace each other. 
      A node model is required for the navigational power of XPath. 
      Lightweight containers are required to model node relationships 
      independently from their structural relationship. And among 
      other benefits they enable a mapping of keys to node references, 
      rather than the nodes themselves, which is a highly desirable
      feature.
    </para><para>
      It is interesting to note a conceptual relationship between
      UDL and the "map proposal": the content of an element with
      [model] equal "map" can be described as a map item
      constrained in the following way: 
      (a) every map value is a child element; (b) every map key
      is the [key] of the associated value.
    </para></section></section><section xml:id="discussion"><title>
      Discussion
    </title><para>
      There is a growing awareness in the XML community that other
      markup languages do, will and should coexist with XML.
      So integration is a crucial task. Being determined
      to integrate, one may look at XML - as well as other
      markup languages - as both: markup, and information
      content represented by markup.
    </para><para>
      We happen to be in the possession of a rigorous, formal
      definition of the information content of XML data. 
      If this model is only approximately, but not quite
      capable of expressing what new markup languages
      have to say (compare 
      <xref linkend="the-mapping-approach"/>),
      this may reflect the circumstances
      when those formal definitions 
      were set down: a point in time when XML 
      structure was the only thing that had to be expressed. 
      But <emphasis role="ital">now</emphasis> 
      it seems a natural course
      to consider extending the model cautiously,
      turning it into a unified document language. When
      infoset and XDM became recommendations, there was nothing to unify,
      now there is.       
    </para><para>
      UDL might change our perception of markup languages:
      they are freely exchangeable 
      in various contexts -
      both in data resources and in program code 
      (within XQuery and XSLT constructors) - 
      and at various scales -
      whole document, document section, single element.
      This becomes possible when different
      markup is seen as alternative representation
      of unified content.
    </para><para>
       An evaluation of the UDL proposal may profit from making
       two distinctions. The first distinction is between UDL's 
       central idea and its translation into technical details.
       The idea is to relate multiple markup languages to a single, 
       unified node model, which turns XML processing 
       technologies into general information processing 
       technologies. For this purpose, the node model was
       extended in a particular way (e.g. adding a new node
       property, [key]). Doubtless,
       other approaches how to extend the node model are conceivable,
       too. An evaluation of the UDL proposal might modify
       or even replace the model extensions by alternatives,
       preserving the central idea as such.
    </para><para>
      The second distinction is between what UDL does achieve and
      what is deliberately left to a future extension (or to
      complementary components). UDL does not yet
      offer support for certain transformations ("mappings")
      which are acknowledged to be important in the context of markup
      integration. In other words: the existence of
      a unified document language does not yet mean
      comprehensive support for all use cases in the context
      of integrating multiple markup languages.
      An evaluation of the UDL proposal 
      should regard the unified document language as 
      a <emphasis role="ital">foundation</emphasis> for
      mapping support - not as a substitute.
    </para></section><section><title>Acknowledgements</title><para>
      Cordial thanks to David A. Lee who read an earlier version of this paper 
      and gave me most valuable feedback. Without David's criticism
      I would not have realized that a further elaboration 
      of the basic concept was necessary. 
    </para></section><appendix xml:id="appendix-a"><title>Deserializing from / serializing to JSON</title><para>
      This appendix contains the precise rules how to deserialize 
      a JSON document to a tree of nodes and how to serialize a 
      tree of nodes to a JSON document.
    </para><section xml:id="appendix-deserialization"><title>
        Deserialization
      </title><para>
        <informaltable><tr valign="top"><td><emphasis role="bold">JSON null</emphasis> =&gt; node</td></tr><tr valign="top"><th align="left">property</th><th align="left">value</th></tr><tr valign="top"><td>name</td><td><code>udl:null</code></td></tr><tr valign="top"><td>key</td><td>                  
                if the null is the value of a name/value pair – 
                the name; empty, otherwise
              </td></tr><tr valign="top"><td>model</td><td>sequence</td></tr><tr valign="top"><td>nilled</td><td>true</td></tr><tr valign="top"><td>schema type</td><td><code>xs:untyped</code></td></tr></informaltable>

        <informaltable><tr valign="top"><td><emphasis role="bold">JSON object</emphasis> =&gt; node</td></tr><tr valign="top"><th align="left">property</th><th align="left">value</th></tr><tr valign="top"><td>name</td><td><code>udl:map</code></td></tr><tr valign="top"><td>key</td><td>                  
                if the object is the value of a name/value pair – 
                the name; empty, otherwise
              </td></tr><tr valign="top"><td>model</td><td>map</td></tr><tr valign="top"><td>content</td><td>
                the collection of element nodes created by deserializing the 
                name/value pairs
              </td></tr><tr valign="top"><td>schema type</td><td><code>xs:untyped</code></td></tr></informaltable>

        <informaltable><tr valign="top"><td><emphasis role="bold">JSON array</emphasis> =&gt; node</td></tr><tr valign="top"><th align="left">property</th><th align="left">value</th></tr><tr valign="top"><td>name</td><td><code>udl:array</code></td></tr><tr valign="top"><td>key</td><td>                  
                if the array is the value of a name/value pair – 
                the name; empty, otherwise
              </td></tr><tr valign="top"><td>model</td><td>sequence</td></tr><tr valign="top"><td>content</td><td>
                the collection of element nodes created by deserializing the 
                array members
              </td></tr><tr valign="top"><td>schema type</td><td><code>xs:untyped</code></td></tr></informaltable>

        <informaltable><tr valign="top"><td><emphasis role="bold">JSON simple value</emphasis> =&gt; node</td></tr><tr valign="top"><th align="left">property</th><th align="left">value</th></tr><tr valign="top"><td>name</td><td><code>udl:value</code></td></tr><tr valign="top"><td>key</td><td>                  
                if the value is part of a name/value pair – 
                the name; empty, otherwise
              </td></tr><tr valign="top"><td>model</td><td>sequence</td></tr><tr valign="top"><td>content</td><td>
                if the value is not a zero-length string: a text node 
                containing the text representation of the value; 
                empty content, otherwise
              </td></tr><tr valign="top"><td>schema type</td><td>
                    <itemizedlist><listitem><para>
                          if the JSON value is a number: 
                          <code>xs:integer/xs:decimal/xs:double</code> –
                          depending on the lexical form 
                        </para></listitem><listitem><para>
                          if the JSON value is one of the constants 
                          <code>true</code> or <code>false</code>: 
                          <code>xs:boolean</code>
                        </para></listitem><listitem><para>
                          if the JSON value is a zero-length string: 
                          <code>xs:untypedAtomic</code>
                        </para></listitem><listitem><para>
                          otherwise: <code>xs:untyped</code>
                        </para></listitem></itemizedlist>
              </td></tr></informaltable>
      </para><para>
          Note: The XML representation of a zero-length JSON string 
          is an empty element with type annotation 
          <code>xs:untypedAtomic</code>. The type annotation
          makes the node distinguishable from empty elements
          corresponding to empty arrays or objects.
      </para></section><section xml:id="appendix-serialization"><title>
        Serialization
      </title><para>
        <emphasis role="bold"><emphasis role="ital">
          Handling attributes
        </emphasis></emphasis>
      </para><para>
        If attributes are encountered, the behaviour depends on the 
        serialization parameter
        <code>info-loss</code>: if the value is 
        <code>json.projection</code>, the attributes are
        ignored; otherwise, a non-recoverable error is raised.
      </para><para>
        <emphasis role="bold"><emphasis role="ital">
          Handling of processing instructions and comments
        </emphasis></emphasis>
      </para><para>
        Processing instructions and comments are ignored.
      </para><para>
        <emphasis role="bold"><emphasis role="ital">
          Handling elements
        </emphasis></emphasis>
      </para><para>
        The handling of elements depends on various properties:
        <itemizedlist><listitem><para>
              the [nilled] property
            </para></listitem><listitem><para>
              the [model] property
            </para></listitem><listitem><para>
              the presence of element children
            </para></listitem><listitem><para>
              the presence of text node children
            </para></listitem><listitem><para>
              the [schema-type] property
            </para></listitem></itemizedlist>
        The following table shows all details.
      </para><para>
        <table><caption><para>
              <emphasis role="bold"><emphasis role="ital">
                Serialization - translating UDL nodes into JSON items.
              </emphasis></emphasis>
            </para></caption><col align="left" valign="top" span="1"/><col align="left" valign="top" span="1"/><thead><tr valign="top"><th align="left" valign="top" rowspan="2">UDL element node</th><th align="left" valign="top" colspan="3">JSON item</th></tr></thead><tbody><tr valign="top"><td>[nilled] is <code>true</code></td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element name is not 
                  <code>udl:null</code>, a non-recoverable error is 
                  raised. Otherwise the element is serialized as a 
                  JSON null value.
                </para>
                 </td></tr><tr valign="top"><td valign="top">
                <para>[model] = "map"</para>
              </td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element 
                  name is not 
                  <code>udl:map</code>, a non-recoverable error is raised. 
                  Otherwise the element is serialized as a JSON object. 
                  The contained name/value pairs are obtained by serializing 
                  the element children. An error is raised if
                  the element has a text node child with 
                  non-whitespace content.
                </para>
              
              </td></tr><tr valign="top"><td>
                <para>
                  [model] = "sequence";
                </para>
                <para>
                  at least one element child
                </para>
              </td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element 
                  name is not 
                  <code>udl:array</code>, a non-recoverable error is raised. 
                  Otherwise the element is serialized as a JSON array. 
                  The array members are obtained by serializing 
                  the element children. An error is raised if 
                  the element has a text node child with 
                  non-whitespace content.
                </para>
               
              </td></tr><tr valign="top"><td>
                <para>
                  [model] = "sequence";
                </para>
                <para>
                  no element children;
                </para>
                <para>
                  at least one text node child
                </para>
              </td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element 
                  name is not 
                  <code>udl:value</code>, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as a JSON simple value.
                  The string values of the text nodes are concatenated and the 
                  result is used to construct a simple JSON value whose type
                  depends on the node's [schema-type]: number (if [schema-type]
                  is equal to or derived from xs:double or xs:decimal),
                  Boolean (if [schema-type] is equal to or derived from xs:boolean)
                  or a string (otherwise).
                </para>
                            </td></tr><tr valign="top"><td>
                <para>
                  [model] = "sequence";
                </para>
                <para>
                  no element children;
                </para>
                <para>
                  no text node child;
                </para>
                <para>
                  [schema-type] is an atomic type
                </para>
              </td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element 
                  name is not 
                  <code>udl:value</code>, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as a JSON string 
                  value of zero length.
                </para>
              
              </td></tr><tr valign="top"><td>
                <para>
                  [model] = "sequence";
                </para>
                <para>
                  no element children;
                </para>
                <para>
                  no text node child;
                </para>
                <para>
                  [schema-type] is not atomic
                </para>
              
              </td><td>
                <para>
                  If serialization parameter 
                  <code>info-loss</code> is 
                  <code>json.strict</code> and the element 
                  name is not 
                  <code>udl:array</code>, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as an empty JSON array.
                </para>
              
              </td></tr></tbody></table>
      </para></section></appendix><appendix xml:id="appendix-b"><title>Additional support for "NCName-only JSON"</title><para>
      This appendix describes an extension of the UDL proposal which 
      provides additional support for processing JSON documents in 
      which every name is an NCName. This extension is presented as 
      an appendix as it has a more tentative character than the core 
      parts of the proposal and is more likely to be modified, removed 
      or replaced by alternatives, should the UDL proposal be evaluated 
      as a whole.
    </para><section xml:id="appendix-b-introduction"><title>
        Introduction
      </title><para>
        UDL does not map JSON documents to XML documents, but defines 
        the information content of a JSON document as an UDL node tree. 
        Such a node tree can be serialized as both, JSON or XML. The 
        XML representation of a JSON document is ugly and not meant 
        for human consumption. The UDL proposal regards the readability 
        of this XML representation as a non-goal and concentrates on 
        the node tree which is designed to enable a JSON processing 
        as powerful and elegant as XML processing. The developer is 
        expected to design his JSON processing code while regarding 
        the JSON serialization, not the XML serialization.
      </para><para>  
        The poor readability of XML-encoded JSON documents is caused by 
        the fact than JSON names are captured as node keys, rather than 
        node names. The [key] property was introduced because the 
        alternative approach of regarding JSON names as node names 
        would introduce a dependence of the node model’s name 
        representation on whether the JSON name happens to be an 
        NCName: NCNames are preserved, and non-NCNames are changed 
        into the result of a name mapping which is either generic 
        and non-semantic (e.g. “2012” to “_2012”) or semantic and 
        application specific (e.g. “2012” to “year-2012”). A 
        semantic mapping is certainly an interesting solution in 
        many situations (compare for example [<xref linkend="LEE"/>]), 
        but it gives up the advantages of a unified document 
        language. The purely technical mapping which 
        replaces inacceptable characters, on 
        the other hand, is unnatural, as it amounts to the perspective 
        that “_2012” is the essential information content, whereas 
        “2012” is some deviating representation.
      </para></section><section xml:id="njson-nnjson"><title>
        Definition of UDL document styles: nJSON, nnJSON
      </title><para>
        Nevertheless it cannot be denied that in some situations 
        one would like to have available both, a readable JSON 
        representation and a readable XML representation. For example,
        an increasing number of web services is expected to deliver both,
        XML and JSON, at user option. In this scenario, UDL’s 
        XML representation of a JSON document is downright inappropriate. 
        What is needed is an XML representation whose element names 
        mirror as good as possible the JSON names. If the JSON document 
        contains non-NCName names, the mapping problem arises - but 
        what if all JSON names <emphasis role="ital">are</emphasis> 
        NCNames? Let us define an 
        <emphasis role="bold">nJSON</emphasis> 
        document as a JSON document in which all names are NCNames.
        An XML representation of an nJSON document may 
        then reuse the JSON names as element names (the local part of it), 
        and yet represent a JSON document without any ambiguity: 
        JSON-serialization using the serialization parameter 
        <code>info-loss</code> with a value 
        <code>json.ignore-names</code> will yield 
        the same document as the strict JSON-serialization of the 
        counterpart which sticks to unspecific names. Let us further 
        introduce the notion of 
        <emphasis role="bold">nnJSON</emphasis> 
        documents defined as follows: 
      </para><orderedlist><listitem><para>
            every name is an NCName (indicated by the first “n”)
          </para></listitem><listitem><para>
            every element with a key has a local name equal to the key (the second “n“)
          </para></listitem><listitem><para>
            the document is JSON-serializable using <code>json.ignore-names</code> (the “JSON”)
          </para></listitem></orderedlist><para>
        Note that (3) implies further constraints: no attributes and no 
        mixed content. At the same time this definition leaves considerable 
        freedom: namespaces and the names of key-less elements can be 
        chosen arbitrarily. nnJSON documents can be regarded as augmented 
        nJSON documents – the additional information consisting of element 
        names which can later be used or discarded, dependent on purpose.
      </para><para>
        nnJSON documents have a remarkable property: they represent 
        an unambiguously determined nJSON document, to whose JSON text 
        they can be serialized, using <code>json.ignore-names</code>; 
        and they can also be serialized to a well-readable XML 
        representation of that JSON document. 
        When dealing with nJSON documents, nnJSON can 
        be used as a normalization of information which enables unified 
        processing code: code that is used no matter if the input is 
        JSON or XML and whether the output is JSON or XML. This 
        unified code consumes an nnJSON tree and it produces an 
        nnJSON tree. The UDL extensions discussed so far ensure that 
        the nnJSON output can be alternatively serialized as readable 
        XML or nJSON. The extensions do however not enable the parsing 
        of both, nJSON text (JSON)  and nnJSON text (XML) into an nnJSON 
        tree. After all, the information content of nJSON and nnJSON 
        is different and parsing by definition does not change the 
        information content: parsing alone will always produce one 
        kind of tree or the other. The processing pattern just 
        sketched – “read and write nnJSON” - therefore has to rely 
        on a translation of an nJSON text or node tree into an nnJSON 
        node tree.
      </para></section><section xml:id="support-for-njson"><title>
        Special support for the processing of nJSON documents – a further extension of XPath
      </title><para>
        After parsing an nJSON document (<code>doc("foo.json")</code>) 
        it can easily be transformed into an nnJSON document, e.g. with 
        a simple stylesheet. nJSON documents are however so important 
        that they warrant a built-in support supplied by the UDL 
        extensions. Therefore the present proposal adds a 
        special-purpose-function which combines the JSON parsing 
        and its transformation to an equivalent nnJSON document:
      </para><programlisting xml:space="preserve">
  nnjson($uri as xs:anyURI) as document-node()</programlisting><para>
        Further signatures allow for control of several aspects 
        of the result document which are not constrained by the 
        definition of nnJSON documents. These  are:
        <orderedlist><listitem><para>
              the element namespaces
            </para></listitem><listitem><para>
              the node name of the root element
            </para></listitem><listitem><para>
              the node names of other elements without a key
            </para></listitem></orderedlist>
        Consider an example. Let the following nJSON document 
        be a response to a “getWeather”  service request:
        <programlisting xml:space="preserve">
  {
     "date" : "2012-08-06",
     "place" : " London",
     "temperatures" : ["12", "21"]
  }</programlisting>
        Here comes a matching nnJSON document:
        <programlisting xml:space="preserve">
  &lt;getWeatherRS xmlns="http://example.com" udl:model="map"&gt;
   &lt;date&gt;2012-08-06&lt;/date&gt;
   &lt;place&gt;London&lt;/place&gt;
   &lt;temperatures&gt;
      &lt;t&gt;12&lt;/t&gt;
      &lt;t&gt;21&lt;/t&gt;
   &lt;/temperatures&gt;  
&lt;/getWeatherRS&gt;</programlisting>
        This document looks as a fairly natural representation of 
        the original JSON document, and it can be serialized 
        to the original JSON document using 
        <code>json.ignore-names</code>. Note 
        the use of an arbitrary namespace and the choice of 
        intuitive element names for key-less elements. A 
        second signature of the <code>nnjson</code> 
        function enables control of these customizations:
        <programlisting xml:space="preserve">
  nnjson($uri as xs:anyURI, 
         $namespace as xs:anyURI?, 
         $rootName as xs:string, 
         $patternsAndNames as item()*)</programlisting>
        The <code>patternsAndNames</code> parameter expects an alternating 
        sequence of XSLT pattern values and an element name; when 
        renaming a key-less element, the first matching pattern is 
        located and the name is taken from the item following the 
        pattern item. Our example could be produced by the 
        following call:
        <programlisting xml:space="preserve">
   nnjson("rsp.json", 
          "http://example.com", 
          "getWeatherRS", 
          ("#temperatures/*", "t")
         )</programlisting>
        Using the simple signature without control paramters, on the other hand:
        <programlisting xml:space="preserve">nnjson("rsp.json")</programlisting>
        produces a document without namespace and with 
        some unspecific element names:
        <programlisting xml:space="preserve">
&lt;udl:map udl:model="map"&gt;
   &lt;date&gt;2012-08-06&lt;/date&gt;
   &lt;place&gt;London&lt;/place&gt;
   &lt;temperatures&gt;
      &lt;udl:value&gt;12&lt;/udl:value&gt;
      &lt;udl:value&gt;21&lt;/udl:value&gt;
   &lt;/udl:temperatures&gt;  
&lt;/udl:map&gt;</programlisting>
        The <code>nnjson</code> function is a convenience function which 
        combines the parsing of an nJSON document with a 
        transformation of particular interest. The transformation 
        is defined in such a way that the changes of information 
        content do not interfere with a subsequent JSON-serialization 
        (using <code>json.ignore-names</code>). This curious mixture 
        of parsing and transformation is regarded as a first-class 
        operation deserving a built-in XPath function because of 
        a well-defined relationship between the resulting 
        XML document and the original JSON document.
      </para></section></appendix><bibliography><title>Bibliography</title><bibliomixed xml:id="BASEX" xreflabel="BaseX">Gruen, Christian, et al. 
      BaseX Documentation Version 7.2, section "JSON Module", p. 125-127. 
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://docs.basex.org/wiki/Main_Page</link>.</bibliomixed><bibliomixed xml:id="COUTHURES" xreflabel="Couthures">Couthures, Alain. 
      JSON for XForms - adding JSON support in XForms data instances. 
      XML Prague 2011, Conference Proceedings, p. 13-24.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="JSON" xreflabel="JSON">Web resource without source information: Introducing JSON.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://json.org</link>.</bibliomixed><bibliomixed xml:id="JSONIQ" xreflabel="JSONiq">Robie, Jonathan, Mathias Brantner,
      Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq - XQuery for JSON,
      JSON for XQuery. XML Prague 2012, Conference Proceedings, p. 63-72.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="JSONIQSPEC" xreflabel="JSONiq Specification">Robie, Jonathan, Mathias Brantner,
      Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq: Language Specification.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://jsoniq.com/docs/spec/en-US/html/index.html</link>.</bibliomixed><bibliomixed xml:id="HUNTER" xreflabel="Hunter">Hunter, Jason. 
      A JSON facade on MarkLogic Server. XML Prague 2011, Conference Proceedings, p. 25-34.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="JSONML" xreflabel="JsonML">Web resource without source 
      information: JSON Markup Language (JsonML). 
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.jsonml.org/</link>.</bibliomixed><bibliomixed xml:id="LEE" xreflabel="Lee">Lee, David A. JXON: an Architecture for 
     Schema and Annotation Driven JSON/XML Bidirectional Transformations. Presented at 
     Balisage: The Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. 
     In Proceedings of Balisage: The Markup Conference 2011. Balisage Series on 
     Markup Technologies, vol. 7 (2011). doi:<biblioid class="doi">10.4242/BalisageVol7.Lee01</biblioid>.
     <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</link>.</bibliomixed><bibliomixed xml:id="PEMBERTON" xreflabel="Pemberton">Pemberton, Steven. 
      Treating JSON as a subset of XML. XML Prague 2012, 
      Conference Proceedings, p. 81-90.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</link>.</bibliomixed><bibliomixed xml:id="ROBIE" xreflabel="Robie">Robie, Jonathan. A universal
      markup language and a universal query language. A contribution to the discussion of 
      Google group JSONiq, 18 October 2011.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://groups.google.com/group/jsoniq</link>.</bibliomixed><bibliomixed xml:id="TENNISON" xreflabel="Tennison">Tennison, Jeni. Opening keynote -
      collisions, chimera and consonance in web content. A presentation at
      xmlprague 2012. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.slideshare.net/JeniT/collisions-chimera-and-consonance-in-web-content</link>.</bibliomixed><bibliomixed xml:id="W3C-INFOSET" xreflabel="W3C Information Set">John Cowan and Richard Tobin, eds. 
      XML Information Set. W3C Recommendation 4 February 2004.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</link>.</bibliomixed><bibliomixed xml:id="W3C-XDM" xreflabel="W3C XDM">Mary Fernandez et al, eds. 
      XQuery 1.0 and XPath 2.0 Data Model (XDM). W3C Recommendation 23 January 2007.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</link>.</bibliomixed><bibliomixed xml:id="W3C-XDM-3.0" xreflabel="W3C XDM 3.0">Norman Walsh et al, eds. 
      XQuery and XPath Data Model 3.0. W3C Working Draft 14 June 2011.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel-30/</link>.</bibliomixed><bibliomixed xml:id="W3C-XML" xreflabel="W3C XML">Tim Bray et al, eds. 
      Extensible Markup Language (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November 2008.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</link>.</bibliomixed><bibliomixed xml:id="W3C-XSLT-3.0" xreflabel="W3C XSLT 3.0">Michael Kay, ed. 
      XSL Transformations (XSLT) Version 3.0. W3C Working Draft 10 July 2012.
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xslt-30/</link>.</bibliomixed></bibliography></article>