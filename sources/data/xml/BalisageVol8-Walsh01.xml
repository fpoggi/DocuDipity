<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>On XML Languages…</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>Some XML languages have an XML syntax, some have a non-XML
syntax, and some have both. This paper explores the intersection of these
languages and syntaxes. What are the advantages of an XML syntax? What are
the advantages of a non-XML syntax? After discussing the general issues, the
paper presents two, alternative non-XML syntaxes for XProc as a case study
to further explore the issues.</para></abstract><author><personname><firstname>Norman</firstname><surname>Walsh</surname></personname><personblurb><para>Norman Walsh is a Lead Engineer at MarkLogic Corporation where he
works with the Application Services team. Norm is also an active
participant in a number of standards efforts worldwide: he is chair of
the XML Processing Model Working Group at the W3C where he is also
co-chair of the XML Core Working Group. At OASIS, he is chair of the
DocBook Technical Committee.</para><para>With more than a decade of industry experience, Norm is well known for
his work on DocBook and a wide range of open source projects. He is the
author of <emphasis>DocBook: The Definitive Guide</emphasis>.</para></personblurb></author><legalnotice><para>Copyright © 2012 Norman Walsh</para></legalnotice></info><para>The Desperate Perl Hacker featured often in the early days of
XML. Designing a markup format that could be processed easily by
ordinary programmers using their chosen languages was an explicit
goal of XML: <quote>4. It
shall be easy to write programs which process XML documents.</quote>
</para><para>This goal was achieved, at least for XML itself, if not all of the
subsequent specifications in the broader ecosystem, and as a consequence
there are no significant, mainstream languages which are incapable of processing
XML. There are probably none for which there aren't a choice of XML
parsers. Any language built on top of the Java VM includes such a choice.
Modern languages like Scala include features for the specific purpose of
writing <quote>domain specific language</quote> parsers. These allow XML,
or subsets of XML, to be incorporated directly into the language itself.
</para><para>It is straightforward to parse XML with more-or-less any programming
language you care to use. The way, and the extent to which, XML coexists with
those languages is largely a question of their design and the full range
of language design is outside the scope of this paper.</para><para><emphasis>Within</emphasis> the XML community, many XML
languages have been designed <emphasis>specifically</emphasis> for the
purpose of processing XML. These include all of the usual suspects:
validation languages, transformation languages, query languages, etc.
These are languages designed by XML users for XML users to process XML.
These are the languages that are the focus of this paper.</para><para>We are concerned mostly with the <emphasis>syntax</emphasis> of these
languages, not their semantics. Of course, syntax and semantics are not
wholly separable. A language whose semantics are nothing more than the
expression of a single boolean value needs at most two tokens and so
can be vastly simpler syntactically than a language with Turing complete
semantics. Nevertheless, we'll focus mostly on the syntax for syntaxes
sake.</para><para>The first, perhaps most obvious, question to ask about the syntax
of an XML language is: to what extent is it XML itself? A brief survey
of XML languages reveals that there is considerable variety on this point.
</para><para>On one end of the spectrum,
<emphasis>RELAX NG Compact Syntax</emphasis> has nothing that resembles XML to the untrained
eye. See <xref linkend="ex.rnc"/>.</para><figure xml:id="ex.rnc"><title>RELAX NG Compact Syntax</title><programlisting xml:space="preserve">namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace db = "http://docbook.org/ns/docbook"

start = purchaseOrder

purchaseOrder = element po { item+ }

item = element item { itemno, quantity, description, unitprice }

itemno =
  element itemno {
    xsd:string { pattern = "[A-Z]+[0-9]+" }
  }

quantity = element quantity { xsd:decimal }

description = element description { (text | emph)* }

emph = element emph { (text | emph)* }

unitprice =
    [
      db:para [
        "The unit price must have an associated currency.\x{a}" ~
        "If no currency is explicitly specified, the default\x{a}" ~
        "value of "
        db:literal [ "USD" ]
        "\x{a}"
        db:emphasis [ "must" ]
        " be assumed."
      ]
    ]
    element unitprice {
       [ a:defaultValue = "USD" ]
       attribute currency {
          ## US Dollars
          "USD"
        | ## Great British Pounds
          "GBP"
        | ## Euro
          "EUR"
       }?,
       xsd:decimal { fractionDigits = "2" }
    }
</programlisting></figure><para>On the other end of the spectrum,
<emphasis>XQueryX</emphasis> is nothing <emphasis>but</emphasis> XML.
See <xref linkend="ex.xqx"/>.</para><figure xml:id="ex.xqx"><title>XQueryX</title><programlisting xml:space="preserve">&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:versionDecl&gt;
    &lt;xqx:version&gt;1.0&lt;/xqx:version&gt;
    &lt;!-- encoding: null --&gt;
  &lt;/xqx:versionDecl&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:defaultNamespaceDecl&gt;
        &lt;xqx:defaultNamespaceCategory&gt;function&lt;/xqx:defaultNamespaceCategory&gt;
        &lt;xqx:uri&gt;http://www.w3.org/2005/xpath-functions&lt;/xqx:uri&gt;
      &lt;/xqx:defaultNamespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;rows&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:flworExpr&gt;
                &lt;xqx:forClause&gt;
                  &lt;xqx:forClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;item&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:forExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:rootExpr/&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;po&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;item&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:forExpr&gt;
                  &lt;/xqx:forClauseItem&gt;
                &lt;/xqx:forClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;itemno&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName&gt;string&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;itemno&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;quant&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName xqx:prefix="xs"&gt;integer&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;quantity&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;desc&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;description&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:anyKindTest/&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;unitp&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqx:functionCallExpr&gt;
                        &lt;xqx:functionName xqx:prefix="xs"&gt;decimal&lt;/xqx:functionName&gt;
                        &lt;xqx:arguments&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;item&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:nameTest&gt;unitprice&lt;/xqx:nameTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                        &lt;/xqx:arguments&gt;
                      &lt;/xqx:functionCallExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:returnClause&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;tr&lt;/xqx:tagName&gt;
                    &lt;xqx:attributeList&gt;
                      &lt;xqx:namespaceDeclaration&gt;
                        &lt;xqx:uri&gt;http://www.w3.org/1999/xhtml&lt;/xqx:uri&gt;
                      &lt;/xqx:namespaceDeclaration&gt;
                    &lt;/xqx:attributeList&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;itemno&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;quant&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;desc&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;unitp&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;td&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:multiplyOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;quant&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;unitp&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:multiplyOp&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:returnClause&gt;
              &lt;/xqx:flworExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqx:elementConstructor&gt;
            &lt;xqx:tagName&gt;html&lt;/xqx:tagName&gt;
            &lt;xqx:attributeList&gt;
              &lt;xqx:namespaceDeclaration&gt;
                &lt;xqx:uri&gt;http://www.w3.org/1999/xhtml&lt;/xqx:uri&gt;
              &lt;/xqx:namespaceDeclaration&gt;
            &lt;/xqx:attributeList&gt;
            &lt;xqx:elementContent&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;head&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;title&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Purchase Order&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;body&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;h1&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Purchase Order&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;table&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;rows&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:elementContent&gt;
          &lt;/xqx:elementConstructor&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</programlisting></figure><para>Other XML languages fit between those two ends. <emphasis>XSLT</emphasis>
has a mostly XML syntax, see <xref linkend="ex.xslt"/>.</para><figure xml:id="ex.xslt"><title>XSLT</title><programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns="http://www.w3.org/1999/xhtml"
		exclude-result-prefixes="xs"
                version="2.0"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:variable name="rows"&gt;
    &lt;xsl:for-each select="/po/item"&gt;
      &lt;xsl:variable name="itemno" select="string(itemno)"/&gt;
      &lt;xsl:variable name="quant" select="xs:integer(quantity)"/&gt;
      &lt;xsl:variable name="desc" select="description/node()"/&gt;
      &lt;xsl:variable name="unitp" select="xs:decimal(unitprice)"/&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="$itemno"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$quant"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:copy-of select="$desc"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$unitp"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="$quant * $unitp"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:variable&gt;

  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;body&gt;
        &lt;table&gt;
          &lt;xsl:sequence select="$rows"/&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</programlisting></figure><para>While
<emphasis>XQuery</emphasis> has a mostly non-XML syntax, see
<xref linkend="ex.xqy"/>.</para><figure xml:id="ex.xqy"><title>XQuery</title><programlisting xml:space="preserve">xquery version "1.0";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

let $rows := for $item in /po/item
             let $itemno := string($item/itemno)
             let $quant  := xs:integer($item/quantity)
             let $desc   := $item/description/node()
             let $unitp  := xs:decimal($item/unitprice)
             return
               &lt;tr xmlns="http://www.w3.org/1999/xhtml"&gt;
                 &lt;td&gt;{ $itemno }&lt;/td&gt;
                 &lt;td&gt;{ $quant }&lt;/td&gt;
                 &lt;td&gt;{ $desc }&lt;/td&gt;
                 &lt;td&gt;{ $unitp } &lt;/td&gt;
                 &lt;td&gt;{ $quant * $unitp }&lt;/td&gt;
               &lt;/tr&gt;
return
  &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;table&gt;
        { $rows }
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</programlisting></figure><para>Let's look a little more closely at the distinction between
<emphasis>XQueryX</emphasis> and <emphasis>XSLT</emphasis>. On the one hand,
<emphasis>XQueryX</emphasis> provides improved machine readability: there are no
semantic elements not manifest in the XML. On the other hand, it gains this benefit
by sacrificing human readability. These are two possible axes on which we can
analyze a language syntax, we'll revisit them later.</para><para>In the meantime, distinguish a “practical” XML
syntax as one that is concise enough for human comprehension
(even if it relies on some non-XML syntax to aid readability).</para><para>How do XML languages stand up? See <xref linkend="xml.lang"/>.</para><table xml:id="xml.lang"><caption><para>XML Languages</para></caption><tbody><tr><th>Language</th><th>XML Syntax</th><th>Practical XML Syntax</th><th>Non-XML Syntax</th></tr><tr><td>Atom</td><td>✓</td><td>✓</td><td/></tr><tr><td>DocBook, HTML, …<footnote><para>…, DITA, TEI, etc. Markup languages
for prose.</para></footnote></td><td>✓</td><td>✓</td><td/></tr><tr><td>MathML</td><td>✓</td><td>✓</td><td/></tr><tr><td>RELAX NG</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>RDF</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Schematron</td><td>✓</td><td>✓</td><td/></tr><tr><td>SVG</td><td>✓</td><td>✓</td><td/></tr><tr><td>XInclude</td><td>✓</td><td>✓</td><td/></tr><tr><td>XLink</td><td/><td/><td>✓</td></tr><tr><td>XML Schema</td><td>✓</td><td>✓</td><td/></tr><tr><td>XPointer</td><td/><td/><td>✓</td></tr><tr><td>XProc</td><td>✓</td><td>✓</td><td/></tr><tr><td>XQuery</td><td>✓</td><td/><td>✓</td></tr><tr><td>XSLT</td><td>✓</td><td>✓</td><td/></tr></tbody></table><para>There may be room for debate about some cells in that table.
Evan Lenz's work on <xref linkend="carrot"/>, for example, is
moving in the direction of a more compact, non-XML syntax for XSLT.
One could argue that TeX is a non-XML syntax for MathML. We might debate
whether or not attribute-based languages like XLink are or are not XML.
And, in addition,
there may be other syntaxes for these languages of which the author is
unaware. However, at a coarse level of granularity, what we can see is
that there are languages all across the spectrum.</para><section xml:id="syntax-choice"><title>Syntactically: XML or not?</title><para>Seeing languages spread across a spectrum like this invites the
question: why? What motivates a language designer to choose an XML
syntax, or not? When both are provided, what motivates a user to
choose an XML syntax, or not?</para><section xml:id="pro-xml"><title>The case for XML syntaxes</title><para>Why choose XML?</para><itemizedlist><listitem><para>“Eat your own dogfood”/”Fly your own airplanes.” One school of thought
says that XML languages should be expressed in XML simply because they are XML
languages. Some XML developers find XML to be a clear and precise format for
the expression of ideas.</para></listitem><listitem><para>Extensibility. The XML syntax has natural extension points,
attributes on start tags, for example, and namespaces. At a
<emphasis>syntactic</emphasis> level, extending an XML language is an
easily solved problem. Conversely, non-XML languages sometimes suffer from
a dearth of extension points. Keeping a grammar for a complex language like
XQuery free from ambiguity while simultaneously adding language features
can be a real challenge.</para><para>Whether the accretion of language features through this form of ad-hoc
extension, in either the XML or non-XML cases, produces a coherent and
regular language over time, is a separate question.</para></listitem><listitem><para>Accessibility to XML tools. The fact that an XSLT stylesheet can be used
to <emphasis>produce</emphasis> an XSLT stylesheet is not a feature that every
XSLT user needs, but there are circumstances when it is a great boon.</para></listitem><listitem><para>Documentation. The ability to inline documentation in an XML language
is considered a great benefit in some environments. Expressing XML documentation
in a non-XML language can have a deleterious effect readability. Compare,
for example, the non-XML representation of the <code>unitprice</code> pattern,
<xref linkend="rnc.doc"/>, with the equivalent XML representation,
<xref linkend="rng.doc"/>.</para><figure xml:id="rnc.doc"><title>XML Documentation in RELAX NG Compact Syntax</title><programlisting xml:space="preserve">unitprice =
    [
      db:para [
        "The unit price must have an associated currency.\x{a}" ~
        "If no currency is explicitly specified, the default\x{a}" ~
        "value of "
        db:literal [ "USD" ]
        "\x{a}"
        db:emphasis [ "must" ]
        " be assumed."
      ]
    ]
    element unitprice {
       [ a:defaultValue = "USD" ]
       attribute currency {
          ## US Dollars
          "USD"
        | ## Great British Pounds
          "GBP"
        | ## Euro
          "EUR"
       }?,
       xsd:decimal { fractionDigits = "2" }
    }
</programlisting></figure><figure xml:id="rng.doc"><title>XML Documentation in RELAX NG XML Syntax</title><programlisting xml:space="preserve">  &lt;define name="unitprice"&gt;
    &lt;element name="unitprice"&gt;
      &lt;db:para&gt;The unit price must have an associated currency.
      If no currency is explicitly specified, the default
      value of &lt;db:literal&gt;USD&lt;/db:literal&gt;
      &lt;db:emphasis&gt;must&lt;/db:emphasis&gt; be assumed.&lt;/db:para&gt;

      &lt;optional&gt;
        &lt;attribute name="currency" a:defaultValue="USD"&gt;
          &lt;choice&gt;
            &lt;value&gt;USD&lt;/value&gt;
            &lt;a:documentation&gt;US Dollars&lt;/a:documentation&gt;
            &lt;value&gt;GBP&lt;/value&gt;
            &lt;a:documentation&gt;Great British Pounds&lt;/a:documentation&gt;
            &lt;value&gt;EUR&lt;/value&gt;
            &lt;a:documentation&gt;Euro&lt;/a:documentation&gt;
          &lt;/choice&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;

      &lt;data type="decimal"&gt;
        &lt;param name="fractionDigits"&gt;2&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
</programlisting></figure></listitem><listitem><para>Syntactic conformance. Operating on XML with a language that has
an XML syntax provides certain minimum assurances about the outputs. An XSLT
stylesheet, which must itself be well formed, guarantees<footnote><para>“Guarantees” in the
absence of features such as disable output escaping and character maps that
are designed to subvert the serialization, in any event.</para></footnote> that
the resulting document will be well formed, by virtue of the nature of XSLT.
</para></listitem><listitem><para>Learnability? There's certainly anecdotal evidence that
non-programmers can be taught to be productive with XSLT in ways that
don't have parallels in non-XML languages. This may be because the
structure of the XSLT stylesheet has a strong surface resemblance to
the documents that are to be transformed. This is true both at the
level of the surface syntax (they're both XML) and at a deeper level
in that templates contain fragments of the documents in a very obvious
and direct way.</para></listitem><listitem><para>Declarativeness? There's a tendency for XML languages to have a more
declarative nature than their non-XML counterparts. This can be seen particularly
in the case of XSLT as compared to XQuery. The XSLT stylesheet in
<xref linkend="ex.xslt"/> was written in a very “pull” fashion in order to
have as much surface similarity to the XQuery example, <xref linkend="ex.xqy"/>,
as possible<footnote><para>Pulling the rows out of line and storing them in a
variable is an awkward consequence of XQuery's completely broken semantics with
respect to the default namespace.</para></footnote>.</para><para>A more idiomatically natural XSLT solution for the problem is shown in
<xref linkend="ex.xslt2"/>.</para><figure xml:id="ex.xslt2"><title>Idiomatic XSLT</title><programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns="http://www.w3.org/1999/xhtml"
		exclude-result-prefixes="xs"
                version="2.0"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Purchase Order&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Purchase Order&lt;/h1&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="po"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="item"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="itemno"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="quantity"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:apply-templates select="description"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="unitprice"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="xs:integer(quantity) * xs:decimal(unitprice)"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="description"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</programlisting></figure><para>In the idiomatic, or “push”, style separate templates are declared
for each component. This greatly increases the flexibility and reusability of
XSLT.</para></listitem><listitem><para>Familiarity. For users whose principle tasks involve editing, validating,
transforming, or otherwise working with XML, a language that is itself expressed
in XML has a certain familiarity. Languages like XSLT or RELAX NG can be edited
in the same comfortable, understood environment used for other XML editing tasks.
</para></listitem></itemizedlist></section><section xml:id="pro-non-xml"><title>The case for non-XML syntaxes</title><para>Why choose a non-XML syntax?</para><itemizedlist><listitem><para>Conciseness. One of the principle attractions of a non-XML syntax is that
it's more compact, more concise. A concise syntax allows more information to
fit on a screen or page and consequently provides the reader with a greater
perspective on the language.</para><para>The compact schema in <xref linkend="ex.rnc"/> fits easily on a
single page or screen and is completely straightforward to understand,
assuming you're familiar with RELAX NG and its compact syntax.</para><para>The same schema expressed in the XML syntax, <xref linkend="ex.rng"/>, is <emphasis>twice</emphasis> as long as it's
compact counterpart. It's not manifestly more difficult to understand,
assuming you're familiar with RELAX NG and its XML syntax, but it
doesn't fit on a single page and contains a lot of syntactic “clutter” that
one must learn to “look through”.
</para><figure xml:id="ex.rng"><title>RELAX NG</title><programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;grammar xmlns:db="http://docbook.org/ns/docbook"
         xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
         xmlns="http://relaxng.org/ns/structure/1.0"
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;start&gt;
    &lt;ref name="purchaseOrder"/&gt;
  &lt;/start&gt;

  &lt;define name="purchaseOrder"&gt;
    &lt;element name="po"&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="item"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="item"&gt;
    &lt;element name="item"&gt;
      &lt;ref name="itemno"/&gt;
      &lt;ref name="quantity"/&gt;
      &lt;ref name="description"/&gt;
      &lt;ref name="unitprice"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="itemno"&gt;
    &lt;element name="itemno"&gt;
      &lt;data type="string"&gt;
        &lt;param name="pattern"&gt;[A-Z]+[0-9]+&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="quantity"&gt;
    &lt;element name="quantity"&gt;
      &lt;data type="decimal"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="description"&gt;
    &lt;element name="description"&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;text/&gt;
          &lt;ref name="emph"/&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="emph"&gt;
    &lt;element name="emph"&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;text/&gt;
          &lt;ref name="emph"/&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="unitprice"&gt;
    &lt;element name="unitprice"&gt;
      &lt;db:para&gt;The unit price must have an associated currency.
      If no currency is explicitly specified, the default
      value of &lt;db:literal&gt;USD&lt;/db:literal&gt;
      &lt;db:emphasis&gt;must&lt;/db:emphasis&gt; be assumed.&lt;/db:para&gt;

      &lt;optional&gt;
        &lt;attribute name="currency" a:defaultValue="USD"&gt;
          &lt;choice&gt;
            &lt;value&gt;USD&lt;/value&gt;
            &lt;a:documentation&gt;US Dollars&lt;/a:documentation&gt;
            &lt;value&gt;GBP&lt;/value&gt;
            &lt;a:documentation&gt;Great British Pounds&lt;/a:documentation&gt;
            &lt;value&gt;EUR&lt;/value&gt;
            &lt;a:documentation&gt;Euro&lt;/a:documentation&gt;
          &lt;/choice&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;

      &lt;data type="decimal"&gt;
        &lt;param name="fractionDigits"&gt;2&lt;/param&gt;
      &lt;/data&gt;
    &lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;
</programlisting></figure></listitem><listitem><para>Familiarity. For tasks, such as programming, that are most
typically performed with non-XML languages, using a non-XML syntax for
an XML language makes it more familiar and approachable for users that come
from other backgrounds.</para><para>XQuery is arguably far more familiar, and consequently less threatening
and more approachable, and easier to learn for a programmer with a background
in SQL or any of a host of common scripting languages.</para></listitem><listitem><para>Accessibility to <emphasis>non-XML</emphasis> tools.
Both familiarity and conciseness play into another strength for non-XML languages:
support in tools and environments that programmers are used to. An XQuery or
RELAX NG Compact Syntax plugin for the programmer's favorite IDE makes editing those
files part of a comfortable, understood environment. Using an XML syntax may require
a new editing tool.</para></listitem><listitem><para>Syntactic expressiveness. An XML syntax imposes constraints on what characters
may appear unescaped. Some of the characters that must escaped are common in
other contexts. For example, it's easy to argue that “<code>$a &lt;= 5</code>”
is easier to read and understand than “<code>$a &amp;lt;= 5</code>”.
</para></listitem></itemizedlist></section></section><section xml:id="syntax-both"><title>Syntactically: Both?</title><para>Why choose if you can have both? RELAX NG is widely praised for having both
an XML syntax and a compact syntax. Why not always take that approach?</para><para>One critical metric by which the success or failure of a
dual-syntax approach will be judged is semantic compatibility.
Arguably, the RELAX NG Compact Syntax has not been successful simply
because it has the advantages of a non-XML syntax, but also because it
describes <emphasis>exactly</emphasis> the same language as the XML
syntax. There are no constructs that can be represented in the compact
syntax that cannot be represented in the XML syntax, and vice-versa.
It is possible to translate <emphasis>every</emphasis> valid schema
losslessly from one format to the other and back again.</para><para>In practice, this is a <emphasis>remarkably</emphasis> high bar.
RELAX NG is a purely declarative language with no semantics for
iteration or transformation. As such, it is burdened with far fewer
semantics to express than a programming language like XSLT or XQuery.
It is difficult to imagine finding a useful alternative syntax for either
of those languages that expressed <emphasis>precisely</emphasis> the same
underlying semantics.</para><para>Yet, the absolute syntactic isomorphism of the two syntaxes is
considered in this paper to be an absolute requirement. Devising alternate
syntaxes for subsets of a language is both much easier and much less
useful. Every instance of the language that uses a construct not available
in the alternate syntax is unavailable to the users who prefer the alternative,
and to tools that are designed to work best with it.</para><para>It's also worth noting that even in the RELAX NG case, there are
unusual artifacts in the non-XML syntax: square bracketed notations
placed in front of the constructs that they modify and a somewhat
torturous representation of XML markup in such annotations. Luckily,
and by design, these annotations are uncommon, the simplest of these
annotations are the most common and the most complicated are quite
rare. Also, because of the syntactic isomorphism, it is possible to
switch back-and-forth between the syntaxes, editing XML annotations in
the XML syntax, and content models in the compact syntax, for
example.</para></section><section xml:id="case-studies"><title>Case studies: compact syntaxes for XProc</title><para>To explore these ideas further, for the balance of this paper,
we will consider two alternative, compact syntaxes for
<emphasis>XProc: An XML Pipeline Language</emphasis>.</para><para>XProc, for those unfamiliar with it, is a language “for
describing operations to be performed on XML documents.”A pipeline
accepts XML documents as input, performs an arbitrary series of
operations on them, and produces XML documents as output. In the
context of an XProc pipeline, an “operation” is one of a set of
discrete steps. These steps perform tasks such as adding an attribute,
counting nodes, deleting nodes, inserting nodes, performing XInclude,
XSLT, or XQuery, various forms of validation. XProc has about 40 such
operations built in and may be extended with additional operations.
</para><para>A simple XProc pipeline is shown in <xref linkend="simple.xpl"/>.</para><figure xml:id="simple.xpl"><title>Simple XProc Pipeline</title><programlisting xml:space="preserve">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
            version='1.0'&gt;
&lt;p:serialization port="result" method="xhtml" indent="true"/&gt;

&lt;p:xinclude/&gt;

&lt;p:xslt&gt;
  &lt;p:input port="stylesheet"&gt;
    &lt;p:document href="dbslides.xsl"/&gt;
  &lt;/p:input&gt;
&lt;/p:xslt&gt;

&lt;/p:pipeline&gt;
</programlisting></figure><para>This pipeline takes a single input document, performs XInclude processing,
styles it using the “<emphasis>dbslides.xsl</emphasis>” stylesheet, and then
produces as its output the result of that transformation. If the XProc processor
serializes the result, it does so as indented XHTML.</para><section xml:id="case-study1"><title>Case study 1: A compact syntax for XProc</title><para>How might the pipeline in <xref linkend="simple.xpl"/> be
represented in a compact, non-XML syntax? Where might we look for
inspiration?</para><itemizedlist><listitem><para>Python? With significant whitespace?</para></listitem><listitem><para>Pascal? With <code>BEGIN</code>/<code>END</code> and <code>:=</code>?</para></listitem><listitem><para>Scheme? Because everything looks better with parentheses?</para></listitem><listitem><para>Something from the C/Java/JavaScript family?</para></listitem></itemizedlist><para>For our first attempt, we'll take the last option. Translating
<xref linkend="simple.xpl"/> into a compact syntax along these lines produces
<xref linkend="simple.xpc1"/>.</para><figure xml:id="simple.xpc1"><title>Simple XProc Pipeline, Compact Syntax #1</title><programlisting xml:space="preserve">xproc 1.0

pipeline {
  serialization "result" with method="xhtml",
       indent="true"
  xinclude
  xslt {
    input "stylesheet" {
      document "dbslides.xsl"
    }
  }
}
</programlisting></figure><para>This is in many ways a very direct translation. Like RELAX NG's
compact syntax and XQuery, we use curly braces to delimit the bodies
of our semantic constructs. Each new construct is introduced by a new
token. There are two syntactic extension points in the XML syntax that
we must accommodate: the presence of arbitrary extension attributes on what are
elements in the XML syntax, and the presence of arbitrary XML
fragments.</para><para>The “<code>with</code>” keyword is used at the end of each
construct in the compact syntax to introduce an unbounded list of
name/value pairs. These map back to extension attributes in the XML
syntax.</para><figure xml:id="lib.xpl"><title>XProc Library</title><programlisting xml:space="preserve">&lt;p:library xmlns:p="http://www.w3.org/ns/xproc"
	   xmlns:cx="http://xmlcalabash.com/ns/extensions"
           version="1.0"&gt;

&lt;p:declare-step type="cx:unzip"&gt;
  &lt;p:output port="result"/&gt;
  &lt;p:option name="href" required="true"
            cx:type="xsd:anyURI"/&gt;
  &lt;p:option name="file"/&gt;
  &lt;p:option name="content-type"/&gt;
&lt;/p:declare-step&gt;

&lt;/p:library&gt;
</programlisting></figure><para>Where additional namespaces are required, as in the pipeline library
in <xref linkend="lib.xpl"/>, they're introduced in the compact syntax and
<code>CName</code>s are allowed as tokens. The equivalent library in
this compact syntax is shown in <xref linkend="lib.xpc1"/>.</para><figure xml:id="lib.xpc1"><title>XProc Library, Compact Syntax #1</title><programlisting xml:space="preserve">xproc 1.0

namespace p = "http://www.w3.org/ns/xproc"
namespace cx = "http://xmlcalabash.com/ns/extensions"

library with version="1.0" {
  declare-step with type="cx:unzip" {
    output "result"
    required option href with cx:type="xsd:anyURI"
    option file
    option content-type
  }
}
</programlisting></figure><para>This example shows the use of an extension attribute, <code>cx:type</code>,
represented in the compact syntax.</para><para>The other challenge is representing arbitrary XML. In RELAX NG,
arbitrary XML fragments are always annotations of one sort or another;
they're both relatively uncommon and, to some extent, unimportant to
the core grammar. Not so in XProc where they appear both in annotations,
like <code>p:documentation</code>, <xref linkend="lib2.xpl"/>,
but also as <emphasis>inline</emphasis> document
content in the pipeline. Using a syntax as awkward as the approach in
RNC seems like a bad choice.</para><figure xml:id="lib2.xpl"><title>XProc Library with Documentation</title><programlisting xml:space="preserve">&lt;p:library xmlns:p="http://www.w3.org/ns/xproc"
           xmlns:cx="http://xmlcalabash.com/ns/extensions"
           version="1.0"&gt;

&lt;p:documentation&gt;
&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;h1&gt;XML Calabash Extension Library&lt;/h1&gt;
&lt;h2&gt;Version 1.0&lt;/h2&gt;
&lt;p&gt;The steps defined in this library are implemented in
&lt;a href="http://xmlcalabash.com/"&gt;XML Calabash&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/p:documentation&gt;
…
</programlisting></figure><para>However, in the context of parsing a non-XML syntax, it must be
possible to recognize both where the XML begins and where it
<emphasis>ends</emphasis>. The presence of, for example, a fragment of
XProc compact syntax in a program listing in some XML must not be
accidentally parsed as XProc. One approach would be to build a
complete XML parser into the grammar of the compact syntax. But even
this is tricky because a <code>p:inline</code> might include
several consecutive sibling elements that each have to be recognized.
</para><para>If only there were some string of tokens that can't appear in
XML…</para><para>In fact, such a sequence exists. Almost. The sequence “<code>]]&gt;</code>”
is forbidden in XML <emphasis>except</emphasis> when it ends a CDATA section.
We can leverage this fact in our compact syntax to form delimiters for
arbitrary XML: “<code>&lt;![xml[</code>” and “<code>]]&gt;</code>”.
See <xref linkend="lib2.xpc1"/>.</para><figure xml:id="lib2.xpc1"><title>XProc Library with Documentation, Compact Syntax #1</title><programlisting xml:space="preserve">xproc 1.0

library with version="1.0" {

documentation {
&lt;![xml[&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;h1&gt;XML Calabash Extension Library&lt;/h1&gt;
&lt;h2&gt;Version 1.0&lt;/h2&gt;
&lt;p&gt;The steps defined in this library are implemented in
&lt;a href="http://xmlcalabash.com/"&gt;XML Calabash&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;]]&gt;
…
</programlisting></figure><para>It's arguably a hack, but it allows us to satisfy the
requirement that each syntax represent exactly the same underlying
constructs.</para><para>This syntax has been implemented. The implementation strategy is
to transform the compact syntax into the XML syntax as a
pre-processing step and then process the resulting XML as usual.</para><para>How does this syntax stand up to the suggested benefits of
non-XML syntaxes?</para><itemizedlist><listitem><para>Conciseness? A wash. It's not clearly shorter in terms of absolute number of lines.
</para></listitem><listitem><para>Familiarity? Not clear. It has the advantage of
less visual clutter, but doesn't draw from the C/Java/JavaScript family in
any significant regard beyond curly braces.
</para></listitem><listitem><para>Accessibility to non-XML tools? Probably an improvement. It's likely that a modern
IDE could be customized with the EBNF (see <xref linkend="xpc1-grammar"/>).
</para></listitem><listitem><para>Syntactic expressiveness? An improvement; outside of XML blocks, there are
no characters that need to be explicitly escaped.
</para></listitem></itemizedlist></section><section xml:id="case-study2"><title>Case study 2: An alternate compact syntax for XProc</title><para>When I presented the first compact syntax in a lightning talk last year,
Jeni Tennison
observed that it could be made more compact, and perhaps more useful
if it was more idiomatically like other programming languages. She
subsequently produced most of the “second compact syntax” language
design.</para><para>Translating
<xref linkend="simple.xpl"/> into this second compact syntax produces
<xref linkend="simple.xpc2"/>.</para><figure xml:id="simple.xpc2"><title>Simple XProc Pipeline, Compact Syntax #2</title><programlisting xml:space="preserve">pipeline {
  xinclude
  xslt ( stylesheet = document 'dbslides.xsl' )
} =&gt; ( result serialized with [ method = 'xhtml', indent = 'true' ] )
</programlisting></figure><para>Adopting a more “method call”-like syntax does make the pipelines
shorter. The outputs of a step are treated in a similar way, but shown at
the end of the body.</para><para>The most obvious example of an attempt to make the language more
idiomatically like other programming languages can be seen in the handling
of <code>p:choose</code>. Consider <xref linkend="choose.xpl"/>.</para><figure xml:id="choose.xpl"><title>XProc “Choose” Pipeline</title><programlisting xml:space="preserve">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
            xmlns:a="http://example.com/a"
            xmlns:b="http://example.com/b"
            version='1.0'&gt;

&lt;p:choose&gt;
  &lt;p:when test="/a:*"&gt;
    &lt;p:xslt&gt;
      &lt;p:input port="stylesheet"&gt;
        &lt;p:document href="a2html.xsl"/&gt;
      &lt;/p:input&gt;
    &lt;/p:xslt&gt;
  &lt;/p:when&gt;
  &lt;p:when test="/b:*"&gt;
    &lt;p:xslt&gt;
      &lt;p:input port="stylesheet"&gt;
        &lt;p:document href="b2html.xsl"/&gt;
      &lt;/p:input&gt;
    &lt;/p:xslt&gt;
  &lt;/p:when&gt;
  &lt;p:otherwise&gt;
    &lt;p:identity/&gt;
  &lt;/p:otherwise&gt;
&lt;/p:choose&gt;

&lt;/p:pipeline&gt;
</programlisting></figure><para>Translating it into our initial compact syntax produces
<xref linkend="choose.xpc1"/>.</para><figure xml:id="choose.xpc1"><title>XProc “Choose” Pipeline, Compact Syntax #1</title><programlisting xml:space="preserve">xproc 1.0

namespace a='http://example.com/a'
namespace b='http://example.com/b'

pipeline {
  choose {
    when "/a:*" {
      xslt {
        input "stylesheet" {
          document "a2html.xsl"
        }
      }
    }
    when "/b:*" {
      xslt {
        input "stylesheet" {
          document "b2html.xsl"
        }
      }
    }
    otherwise {
      identity
    }
  }
}
</programlisting></figure><para>This is clearly a non-XML syntax, but it retains all of the semantic
flavor of the original. In the second XProc compact syntax, a choose statement
is represented using an if/then/else construct that's likely to be more familiar
to programmers, see <xref linkend="choose.xpc2"/>.</para><figure xml:id="choose.xpc2"><title>XProc “Choose” Pipeline, Compact Syntax #2</title><programlisting xml:space="preserve">namespace a: 'http://example.com/a'
namespace b: 'http://example.com/b'

pipeline {
  if (/a:*) {
    xslt ( stylesheet = document 'a2html.xsl' )
  } else if (/b:*) {
    xslt ( stylesheet = document 'b2html.xsl' )
  } else {
    identity
  }
}
</programlisting></figure><para>Again, this manages to be both shorter and possibly more familiar.</para><para>Whether or not either of these syntaxes would be markedly easier to use
or would spur greater adoption of XProc is an open question.</para></section></section><appendix xml:id="xpc1-grammar"><title>Grammar for XProc Compact Syntax #1</title><programlisting xml:space="preserve">document    ::= xpcMarker namespace* ( declareStep | pipeline | library ) EOF

xpcMarker   ::= 'xproc' version

version     ::= '1.0'

namespace   ::= ('namespace' prefix '=' quotedstr)
              | ('default' 'namespace' '=' quotedstr)

prefix      ::= NCName

declareStep ::= 'declare-step' stepName? withExtra? pipelineBody

stepName    ::= 'named' quotedstr

withExtra   ::= 'with' attr (',' attr)*

attr        ::= QName '=' (QName | quotedstr)

pipelineBody ::= '{'
     ( input | output | option | log | serialization )*
     ( declareStep | pipeline | imports )*
     subpipeline?
     '}'

input       ::= 'input' quotedstr withExtra? ( '{' binding* '}' )?

output      ::= 'output' quotedstr withExtra? ( '{' binding* '}' )?

option      ::= 'required' 'option' QName withExtra?
              | 'option' QName withExtra?

log         ::= 'log' quotedstr 'to' quotedstr

serialization ::= 'serialization' quotedstr withExtra?

imports     ::= 'import' quotedstr

variable    ::= 'variable' QName '=' quotedstr variableBody?

variableBody ::= '{' ( binding | namespaces )* '}'

namespaces  ::= 'namespaces' withExtra? nsBody?

nsBody      ::= '{' namespace '}'

binding     ::= ( comment | pi )*
                ( emptyBinding | documentBinding | dataBinding | pipeBinding | inlineBinding )

emptyBinding    ::= 'empty' withExtra?
documentBinding ::= 'document' quotedstr withExtra?
dataBinding     ::= 'data' quotedstr withExtra?
pipeBinding     ::= quotedstr 'on' quotedstr withExtra?
inlineBinding   ::= 'inline' withExtra? inlineXML

inlineXML       ::= '&lt;![XML[' Char* ']]&gt;'

subpipeline     ::= ( variable | documentation | pipeinfo | forEachStep | viewportStep
                     | chooseStep | tryStep | groupStep | atomicStep | comment | pi )+

documentation   ::= 'documentation' withExtra? '{' inlineXML '}'

pipeinfo        ::= 'pipeinfo' withExtra? '{' inlineXML '}'

named           ::= 'named' quotedstr

forEachStep     ::= 'for-each' named? withExtra? forEachBody

forEachBody     ::= '{' ( iterationSource | output | log )* subpipeline '}'

iterationSource ::= 'iteration-source' withExtra? ( '{' binding* '}' )?

viewportStep    ::= 'viewport' named? withExtra? viewportBody

viewportBody    ::= '{' ( viewportSource | output | log )* subpipeline '}'

viewportSource  ::= 'viewport-source' withExtra? ( '{' binding* '}' )?

chooseStep      ::= 'choose' named? withExtra? chooseBody

chooseBody      ::= '{' xpathContext? variable* whenStep* otherwiseStep? '}'

xpathContext    ::= 'xpath-context' withExtra? ( '{' binding* '}' )?

whenStep        ::= 'when' quotedstr withExtra? whenBody

whenBody        ::= ( xpathContext | output | log )* subpipeline

otherwiseStep   ::= 'otherwise' withExtra? otherwiseBody

otherwiseBody   ::= ( output | log )* subpipeline

tryStep         ::= 'try' named? withExtra? tryBody

tryBody         ::= '{' variable* groupStep catchStep '}'

groupStep       ::= 'group' named? withExtra? groupBody

groupBody       ::= '{' ( output | log )* subpipeline '}'

catchStep       ::= 'catch' named? withExtra? catchBody

catchBody       ::= '{' ( output | log )* subpipeline '}'

atomicStep      ::= ( 'add-xml-base' | 'add-attribute' | 'compare' | 'count' | 'delete'
                      | 'directory-list' | 'error' | 'escape-markup' | 'exec' | 'filter'
                      | 'hash' | 'http-request' | 'identity' | 'insert' | 'label-elements'
                      | 'load' | 'make-absolute-uris' | 'namespace-rename' | 'pack'
                      | 'parameters' | 'rename' | 'replace' | 'set-attributes' | 'sink'
                      | 'split-sequence' | 'store' | 'string-replace' | 'unescape-markup'
                      | 'unwrap' | 'uuid' | 'validate-with-relax-ng'
                      | 'validate-with-schematron' | 'validate-with-xml-schema'
                      | 'wrap' | 'wrap-sequence' | 'www-form-urldecode' | 'www-form-urlencode'
                      | 'xinclude' | 'xquery' | 'xslt' | 'xsl-formatter' )
                    named? withExtra? atomicStepBody?
                  | CName named? withExtra? atomicStepBody?

atomicStepBody  ::= '{' ( input | withOption | withParam | log )* '}'

withOption      ::= 'with-option' QName '=' quotedstr withExtra? withOptionBody?

withOptionBody  ::= '{' ( binding | namespaces )* '}'

withParam       ::= 'with-param' QName '=' quotedstr withExtra? withParamBody?

withParamBody   ::= '{' ( binding | namespaces )* '}'

pipeline        ::= 'pipeline' named? withExtra? pipelineBody

library         ::= 'library' withExtra? libraryBody

libraryBody     ::= '{' ( imports | declareStep | pipeline )* '}'

<?TOKENS?>

EOF ::= $

comment  ::= '&lt;!--' ( ( Char - '-' ) | '-' ( Char - '-' ) )* '--&gt;'
pi       ::= '&lt;?' pitarget ( S ( [^?] | '?'+ [^?&gt;] )* '?'* )? '?&gt;' /* ws: explicit */
pitarget ::= NCName
S        ::= ( #x0020 | #x0009 | #x000D | #x000A )+ /* ws: definition */

quotedstr ::= '"' ( [^"] )* '"'
            | "'" ( [^'] )* "'"

NameStartChar
         ::= [A-Z]
           | '_'
           | [a-z]
           | [#x00C0-#x00D6]
           | [#x00D8-#x00F6]
           | [#x00F8-#x02FF]
           | [#x0370-#x037D]
           | [#x037F-#x1FFF]
           | [#x200C-#x200D]
           | [#x2070-#x218F]
           | [#x2C00-#x2FEF]
           | [#x3001-#xD7FF]
           | [#xF900-#xFDCF]
           | [#xFDF0-#xFFFD]
NameChar ::= NameStartChar
           | '-'
           | '.'
           | [0-9]
           | #x00B7
           | [#x0300-#x036F]
           | [#x203F-#x2040]
NCName   ::= NameStartChar NameChar*
CName    ::= (NCName ':' NCName)
QName    ::= NCName | CName

Char     ::= [#x0021-#xD7FF]
           | [#xE000-#xFFFD]
           | [#x10000-#x10FFFF]

</programlisting></appendix><appendix xml:id="implementation"><title>Implementation</title><para><emphasis>XML Calabash</emphasis> implements both compact syntaxes
in the same way.</para><orderedlist><listitem><para>The EBNF for the compact syntax is compiled into an XQuery module
using the <emphasis>REx Parser Generator</emphasis>. The XQuery module
produces an XML parse tree for the input pipeline.
</para></listitem><listitem><para>An XSLT stylesheet is written which transforms the XML parse tree
into standard XProc.</para></listitem><listitem><para>These two steps are combined into a pipeline,
<xref linkend="xpc1toxpl"/>, which is used to transform the input document
into XProc which is then executed normally.</para><para>This mechanism may not be particularly efficient, but it is quite
easy to write as a proof-of-concept.</para></listitem></orderedlist><figure xml:id="xpc1toxpl"><title>XProc Pipeline for Converting XPC to XPL</title><programlisting xml:space="preserve">&lt;p:pipeline xmlns:p="http://www.w3.org/ns/xproc" version="1.0"&gt;

&lt;p:xquery&gt;
  &lt;p:input port="query"&gt;
    &lt;p:data href="xpc1.xqy"/&gt;
  &lt;/p:input&gt;
&lt;/p:xquery&gt;

&lt;p:xslt version="2.0"&gt;
  &lt;p:input port="stylesheet"&gt;
    &lt;p:document href="xpc1.xsl"/&gt;
  &lt;/p:input&gt;
&lt;/p:xslt&gt;

&lt;/p:pipeline&gt;
</programlisting></figure></appendix><bibliography><title>References</title><bibliomixed xml:id="carrot">
Lenz, Evan. “Carrot: An appetizing hybrid of XQuery and XSLT.” Presented at
Balisage: The Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. In
<emphasis>Proceedings of Balisage: The Markup Conference 2011</emphasis>.
Balisage Series on Markup Technologies, vol. 7 (2011).
doi:<biblioid class="doi">10.4242/BalisageVol7.Lenz01</biblioid>.</bibliomixed><bibliomixed xml:id="rex">
Rademacher, Gunther. “REx Parser Generator”,
http://www.bottlecaps.de/rex/</bibliomixed><bibliomixed xml:id="xmlcalabash">
Walsh, Norman. “XML Calabash”,
http://xmlcalabash.com/</bibliomixed></bibliography></article>