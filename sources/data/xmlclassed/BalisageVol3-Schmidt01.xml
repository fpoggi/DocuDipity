<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">Merging Multi-Version Texts: a General Solution to the Overlap Problem</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2009</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 11 - 14, 2009</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Multi-Version Documents or MVDs, as described in Schmidt and Colomb (</textual><xref class="po-milestone e8 e8" linkend="Schm09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), provide a simple format for representing overlapping structures in digital text. They permit the reuse of existing technologies, such as XML, to encode the content of individual versions, while allowing overlapping hierarchies (separate, partial or conditional) and textual variation (insertions, deletions, alternatives and transpositions) to exist within the same document. Most desired operations on MVDs may be performed by simple algorithms in linear time. However, creating and editing MVDs is a much harder and more complex operation that resembles the multiple-sequence alignment problem in biology. The inclusion of the transposition operation into the alignment process makes this a hard problem, with no solutions known to be both optimal and practical. However, a suitable heuristic algorithm can be devised, based in part on the most recent biological alignment programs, whose time complexity is quadratic in the worst case, and is often much faster. The results are satisfactory both in terms of speed and alignment quality. This means that MVDs can be considered as a practical and editable format suitable for representing many cases of overlapping structure in digital text.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Desmond</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Schmidt</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Desmond Schmidt has a BA from the University of Queensland in Classical Greek Language and Ancient History (1980), a PhD from the University of Cambridge, UK, in Classical Greek papyrology (1987). He has worked at the Cambridge Wittgenstein Archive making an edition of Wittgenstein, as a Computer Associate at the Wellcome/CRC (biosciences) Institute. In Australia he has worked as a software developer on a commercial license managment system for Mac OSX, and on the Leximancer data mining application. He currently works at the Information Security Institute, Queensland University of Technology, as a software engineer. Since 2002 he has worked with Domenico Fiormonte and the Digital Variants team developing tools for viewing and editing multi-version texts. He has recently submitted a second PhD at the ITEE School at UQ entitled ‘Multiple Versions and Overlap in Digital Text’.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Software Engineer</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Information Security Institute, Queensland University of Technology</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">schmidda@qut.edu.au</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright © 2009 Desmond Schmidt. Used by permission.</textual></para></legalnotice><keywordset class="po-table e21 e21" role="author"><keyword class="po-field e22 e22"><textual class="po-textual">Overlapping Hierarchies</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">Textual Variation</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">Multiple Sequence Alignment</textual></keyword></keywordset></info><section class="po-hcontainer e25 e25"><title class="po-block e26 e26"><textual class="po-textual">Introduction</textual></title><para class="po-block e27 e27"><textual class="po-textual">Over 20 years ago, shortly after the standardisation of SGML in 1986 (</textual><xref class="po-milestone e28 e28" linkend="Gold90"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), the problem of overlap was first noticed as a serious difficulty in the encoding of digital texts in the humanities and linguistics (</textual><xref class="po-milestone e29 e29" linkend="Barn88"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Overlap may be defined as the inability of markup systems to easily represent overlapping structures by means of paired tags whose primary function is to contain text or other markup in a strictly nested and ‘well-formed’ way (</textual><xref class="po-milestone e30 e30" linkend="Bray08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 2.1). Barnard et al. (</textual><xref class="po-milestone e31 e31" linkend="Barn88"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 275) reassured the reader at the time that ‘SGML can successfully cope with the problem of maintaining multiple structural views’ and that the ‘solutions can be made practical’. After around 50 papers and theses later it would seem that this early assessment may have underestimated the extent of the problem. There have been many surveys of the literature on the subject (</textual><xref class="po-milestone e32 e32" linkend="Witt02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e33 e33" linkend="Maas03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e34 e34" linkend="Dero04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), but the consensus seems to be that no general solution to the overlap problem is known or likely (</textual><xref class="po-milestone e35 e35" linkend="Maas03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 18; </textual><xref class="po-milestone e36 e36" linkend="Sahl05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 3).</textual></para><para class="po-block e37 e37"><textual class="po-textual">The Multi-Version Document or MVD format has been put forward as a possible general solution to the overlap problem (</textual><xref class="po-milestone e38 e38" linkend="Schm09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Although originally conceived as a solution to textual variation, an MVD can also be used to represent ‘overlapping hierarchies’, since multiple conflicting markup perspectives of a single linear text can be construed as variant texts in which only the markup varies. An MVD represents both overlap and variation by replacing the conventional linear form of text with a directed graph. This graph may take two forms:</textual></para><orderedlist class="po-table e39 e39"><listitem class="po-container e40 e40"><para class="po-block e41 e41"><textual class="po-textual">As an explicit directed acyclic graph that starts at one point, then diverges and remerges as required, before ending again at a single point. I call this a ‘variant graph’. Each arc is labelled with the set of versions to which that arc belongs, and a fragment of text, which may be empty. Any version can be read by following the appropriate path through the graph from start to finish. Figure 1 shows a variant graph generated using the algorithm described in this paper from three versions (labelled A,B,C) of part of Valerio Magrelli’s Italian poem </textual><emphasis class="po-inline e42 e42"><textual class="po-textual">Campagna romana</textual></emphasis><textual class="po-textual"> (</textual><xref class="po-milestone e43 e43" linkend="Magr81"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></listitem><listitem class="po-container e44 e44"><para class="po-block e45 e45"><textual class="po-textual">As a list of interleaved pairs, consisting of the labels of each arc, and the sets of versions to which it belongs. The pairs are ordered so that the labels preserve the order of the text for each version they represent (Figure 2).</textual></para></listitem></orderedlist><mediaobject class="po-container e46 e46"><imageobject class="po-container e47 e47"><imagedata class="po-meta e48 e48" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e49 e49"><para class="po-block e50 e50"><textual class="po-textual">Figure 1: A Variant Graph</textual></para></caption></mediaobject><mediaobject class="po-container e51 e51"><imageobject class="po-container e52 e52"><imagedata class="po-meta e53 e53" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e54 e54"><para class="po-block e55 e55"><textual class="po-textual">Figure 2: Part of the Same Graph as a List of Pairs</textual></para></caption></mediaobject><para class="po-block e56 e56"><textual class="po-textual">These two forms are equivalent and interchangeable. The list form is currently better for searching, listing, saving and comparing two versions in an MVD, and the explicit graph for creating and editing an MVD. Conversion between the two forms can be performed losslessly in essentially linear time. It is hoped that in the future it will also be possible to edit and create MVDs using the simpler list format.</textual></para><section class="po-hcontainer e57 e57"><title class="po-block e58 e58"><textual class="po-textual">Advantages of the MVD Format</textual></title><orderedlist class="po-table e59 e59"><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">Because an MVD doesn’t know anything about the format of the text contained in each arc-label or pair, any technology can be used to represent the content of an individual version. In this way the complex overlapping structures of the text are abstracted out into the graph structure, so that the content can be represented using conventional, and simplified, markup. This allows the reuse of existing markup-based tools such as XSLT (Figure 3).</textual></para></listitem><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">Representing a work that contains multiple versions or markup perspectives as a single digital entity facilitates searching, comparing, editing and transmission of the work without the need for complex software to integrate a set of separate files.</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">Because the MVD representation is very simple, and is not dependent on markup, it can provide a general solution to the overlap problem in corpus linguistics and humanities texts of various types and dates. It can work equally well with plain text and some binary formats.</textual></para></listitem></orderedlist><para class="po-block e66 e66"><textual class="po-textual">The only real disadvantage of the format is the difficulty of producing it automatically, which is the problem this paper attempts to solve.</textual></para><mediaobject class="po-container e67 e67"><imageobject class="po-container e68 e68"><imagedata class="po-meta e69 e69" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e70 e70"><para class="po-block e71 e71"><textual class="po-textual">Figure 3: Separation of Variation from Content</textual></para></caption></mediaobject></section><section class="po-hcontainer e72 e72"><title class="po-block e73 e73"><textual class="po-textual">Operations on MVDs</textual></title><para class="po-block e74 e74"><textual class="po-textual">The commonest operations that may be performed on MVDs include:
 </textual><orderedlist class="po-table e75 e75"><listitem class="po-container e76 e76"><para class="po-block e77 e77"><textual class="po-textual">Listing a given version</textual></para></listitem><listitem class="po-container e78 e78"><para class="po-block e79 e79"><textual class="po-textual">Comparing two versions</textual></para></listitem><listitem class="po-container e80 e80"><para class="po-block e81 e81"><textual class="po-textual">Searching a multi-version text</textual></para></listitem><listitem class="po-container e82 e82"><para class="po-block e83 e83"><textual class="po-textual">Finding out what is a variant of what</textual></para></listitem><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">Creating and updating an MVD</textual></para></listitem></orderedlist><textual class="po-textual">
The first four operations can be performed by relatively simple algorithms in linear time. The fifth operation, however, is considerably more complex and costly. Unless a method can be found to efficiently perform this operation, the advantages of the MVD format will be unrealised. In addition, making MVDs editable would represent an advance over current standoff techniques for representing overlap in linguistics texts (</textual><xref class="po-milestone e86 e86" linkend="Stuh08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e87 e87" linkend="Ide06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In these systems editing the overall representation once created is limited or difficult. Although this may be an acceptable limitation for linguists, who are commenting on or marking up an essentially static text, it is a fundamental requirement for humanists to be able to edit texts that contain overlapping structures (</textual><xref class="po-milestone e88 e88" linkend="Buzz02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e89 e89" linkend="Vett03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e90 e90" linkend="Neyt06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e91 e91" linkend="Mcga01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 17; </textual><xref class="po-milestone e92 e92" linkend="Bart06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e93 e93"><textual class="po-textual">An MVD may be created by successively adding versions to an initially empty document. Updating an existing version can be performed in the same way by first deleting the version to be replaced. Creating and updating an MVD thus both reduce to the same operation: that of merging a single version into an existing multi-version document.</textual></para></section></section><section class="po-hcontainer e94 e94"><title class="po-block e95 e95"><textual class="po-textual">Analogies to the Current Problem</textual></title><para class="po-block e96 e96"><textual class="po-textual">The basic problem that underlies this merging operation has already been researched in other fields, in particular in bioinformatics, text processing and humanities computing. Since the solutions in these areas work with different data and with different objectives, none of these algorithms provide a precise match with the current problem. Nevertheless, examining similar areas of research like this is likely to reveal potential pitfalls as well as furnish possible components of the required solution.</textual></para><section class="po-hcontainer e97 e97"><title class="po-block e98 e98"><textual class="po-textual">Bioinformatics</textual></title><para class="po-block e99 e99"><textual class="po-textual">Biologists have studied the computational alignment of multiple sequences of nucleic and amino acids for over 40 years. These computations reduce to the finding of insertions, deletions, substitutions and transpositions in texts with a restricted alphabet of 4 characters for nucleotides or 20 for amino acids. There are in fact three main sub-fields within bioinformatics that are relevant to the current problem.</textual></para><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">Multiple Sequence Alignment</textual></title><para class="po-block e102 e102"><textual class="po-textual">Biologists frequently search databases for similar sequences to newly sequenced genes or proteins (</textual><xref class="po-milestone e103 e103" linkend="Lesk02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 177). The results, however, are usually a set of close matches whose interrelationships may need further exploration. For example, it is often of interest to trace the evolutionary history of a series of mutation events that gave rise to different versions of a protein. This is the multiple sequence alignment problem (</textual><xref class="po-milestone e104 e104" linkend="Edga06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><section class="po-hcontainer e105 e105"><title class="po-block e106 e106"><textual class="po-textual">Two-Way Global Alignment</textual></title><para class="po-block e107 e107"><textual class="po-textual">A multiple sequence alignment is usually built up from a series of two-way alignments, for which an optimal dynamic programming solution has existed since 1970 (</textual><xref class="po-milestone e108 e108" linkend="Need70"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). This calculates a ‘global’ alignment, because it aligns every character in the two sequences.</textual></para><mediaobject class="po-container e109 e109"><imageobject class="po-container e110 e110"><imagedata class="po-meta e111 e111" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-004.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">Figure 4: Needleman-Wunsch Algorithm</textual></para></caption></mediaobject><para class="po-block e114 e114"><textual class="po-textual">In Figure 4 a 2-D matrix representing the alignment of the two strings is filled from the bottom right-hand corner to the top left-hand corner, one cell at a time. Each cell is filled with 1 if the letters at those coordinates match, otherwise 0, </textual><emphasis class="po-inline e115 e115"><textual class="po-textual">plus</textual></emphasis><textual class="po-textual"> the maximum cell-value of the next row and column down and to the right. Once filled, the matrix can be used to recover a common subsequence with the highest score by following matching pairs from 0,0 down and to the right. There may be more than one such optimal path through the matrix.</textual></para><para class="po-block e116 e116"><textual class="po-textual">Although it is theoretically possible to extend their method to n sequences, the time and space requirements increase exponentially for n &gt; 2. For this reason only the 2-way alignments of all possible </textual><emphasis class="po-inline e117 e117"><textual class="po-textual">pairs</textual></emphasis><textual class="po-textual"> of sequences are normally computed, which are then used to construct a close approximation to a global n-way alignment. Even this shortcut turns out to be quite expensive, since the number of possible pairs of n sequences is n(n-1)/2. And the computation of the alignment for each pair of sequences also costs O(MN(M+N)) time, where N and M are the lengths of the two sequences. To give some idea of just how costly that is, the computation of the optimal pairwise alignments of the 36 versions of the Sibylline Gospel (</textual><xref class="po-milestone e118 e118" linkend="Schm08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), i.e. 630 pairwise combinations, each around 2,500 characters long, took 6.6 hours on an ordinary desktop computer.</textual></para></section><section class="po-hcontainer e119 e119"><title class="po-block e120 e120"><textual class="po-textual">Progressive Alignment</textual></title><para class="po-block e121 e121"><textual class="po-textual">One popular way of aligning multiple sequences is progressive alignment (</textual><xref class="po-milestone e122 e122" linkend="Feng87"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In this method the global pairwise alignments of a set of sequences are scored for similarity and the results are used to construct a phylogenetic tree, which records the stemmatic relationships between sequences, to act as a ‘guide’ for the merging process. The multiple-sequence alignment or MSA (Figure 5) is then built up by starting with the most similar pair of sequences, adding gaps where needed (and never removed once inserted), then gradually adding in the other sequences as dictated by the guide-tree. Modern examples of this approach include CLUSTALW (</textual><xref class="po-milestone e123 e123" linkend="Thom94"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and T-COFFEE (</textual><xref class="po-milestone e124 e124" linkend="Notr00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), although the latter augments the usual progressive technique with iterative refinement.</textual></para><mediaobject class="po-container e125 e125"><imageobject class="po-container e126 e126"><imagedata class="po-meta e127 e127" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-005.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e128 e128"><para class="po-block e129 e129"><textual class="po-textual">Figure 5: Multiple Sequence Alignment</textual></para></caption></mediaobject><section class="po-hcontainer e130 e130"><title class="po-block e131 e131"><textual class="po-textual">Disadvantages of Progressive Alignment</textual></title><para class="po-block e132 e132"><textual class="po-textual">Because this method was originally developed to handle short sequences, it doesn’t take account of transpositions, or repeated segments, which appear to be common features of longer protein sequences (</textual><xref class="po-milestone e133 e133" linkend="Pevz04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e134 e134" linkend="Delc02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e135 e135" linkend="Gu99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e136 e136"><textual class="po-textual">Also, it is a greedy algorithm sensitive to the order in which the sequences are added to the 
MSA. Alignment errors that occur early on get locked in and lead to greater divergences 
later (</textual><xref class="po-milestone e137 e137" linkend="Thom94"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e138 e138"><textual class="po-textual">The initial pairwise alignments are particularly expensive to calculate. This limits the number and length of sequences that can be aligned.</textual></para><para class="po-block e139 e139"><textual class="po-textual">Progressive alignment is based on the concept of edit distance (</textual><xref class="po-milestone e140 e140" linkend="Leve66"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). This is a count of the number of insertions, deletions and substitutions of individual characters that need to be performed to turn one string into another. This can only ever approximate the real biological processes that gave rise to the differences (</textual><xref class="po-milestone e141 e141" linkend="Lass02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 13; </textual><xref class="po-milestone e142 e142" linkend="Lesk02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 168).</textual></para></section></section><section class="po-hcontainer e143 e143"><title class="po-block e144 e144"><textual class="po-textual">Partial Order Alignment</textual></title><para class="po-block e145 e145"><textual class="po-textual">A relatively new technique of multiple sequence alignment called POA or Partial Order Alignment has been described by Lee et al. (</textual><xref class="po-milestone e146 e146" linkend="Lee02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and Grasso et al. (</textual><xref class="po-milestone e147 e147" linkend="Gras04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The roots of their method go back to Morgenstern’s Dialign program (</textual><xref class="po-milestone e148 e148" linkend="Morg96"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In that method, as in MAFFT (</textual><xref class="po-milestone e149 e149" linkend="Kato02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), highly similar regions within two sequences are first identified. They are then resolved into a non-overlapping set of diagonals in n Dimensions, then added to the MSA using a greedy strategy. Unaligned regions are then processed recursively. The difference here is that gaps are no longer explicitly introduced: they are simply what is left over once the aligned portions have been determined.</textual></para><para class="po-block e150 e150"><textual class="po-textual">POA takes this strategy one step further: it replaces the MSA matrix with a directed graph.  Instead of pairwise alignment they align each successive sequence – in no particular order – to a partly-built PO-MSA (Partial Order Multiple Sequence Alignment). In their method the initial computation of n(n-1)/2 pairwise alignments is not a preliminary step, but is instead integrated into the alignment process. Because a PO-MSA contains far less data than that contained in all possible pairs of sequences, the computational cost is drastically reduced. </textual></para><para class="po-block e151 e151"><textual class="po-textual">Figure 6 shows their adaptation of the dynamic programming method to the directed graph structure. Instead of aligning two linear sequences within a flat 2-D matrix, in the the PO-MSA method the 2-D matrix becomes a complex planar surface corresponding to the partly merged structure of the directed graph, on the one hand, and the new linear sequence, on the other. At each join between surfaces the program has to decide which surface to align with. Regardless of the order in which the sequences are added to the alignment, each possible pairwise combination of sequences will be considered, since each new sequence is compared to all those already in the graph.</textual></para><mediaobject class="po-container e152 e152"><imageobject class="po-container e153 e153"><imagedata class="po-meta e154 e154" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-006.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e155 e155"><para class="po-block e156 e156"><textual class="po-textual">Figure 6: PO-MSA Alignment</textual></para></caption></mediaobject><para class="po-block e157 e157"><textual class="po-textual">The speed of the program is impressive, but the quality of the alignments is somewhat less than could be achieved by traditional progressive alignment techniques (</textual><xref class="po-milestone e158 e158" linkend="Lass02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Grasso et al. (</textual><xref class="po-milestone e159 e159" linkend="Gras04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) think the cause is partly that the original algorithm still appears to be sensitive to the order in which sequences are added to the PO-MSA. This is probably because, unlike the progressive method, each new version is aligned only with those versions already in the graph, not with those still to be added.</textual></para><section class="po-hcontainer e160 e160"><title class="po-block e161 e161"><textual class="po-textual">Disadvantages of POA</textual></title><para class="po-block e162 e162"><textual class="po-textual">In spite of its innovative data model, the POA graph and associated software can’t handle transpositions or repeated segments. The remaining order sensitivity seems to be an inherent deficiency of this approach.</textual></para></section></section></section><section class="po-hcontainer e163 e163"><title class="po-block e164 e164"><textual class="po-textual">de Bruijn and A-Bruijn Graphs</textual></title><para class="po-block e165 e165"><textual class="po-textual">The second area in bioinformatics that provides a close analogy to the current problem is a more radical solution to the multiple sequence alignment problem. It evolved from the related field of contig-assembly. Starting in the 1980s DNA sequencing machines were developed which output fragments of DNA, typically 650 base pairs in length (</textual><xref class="po-milestone e166 e166" linkend="Delc02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 2480). These short segments have to be assembled correctly into longer ‘contigs,’ which is an NP-hard problem. Pevzner (</textual><xref class="po-milestone e167 e167" linkend="Pevz89"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), Idury and Waterman (</textual><xref class="po-milestone e168 e168" linkend="Idur95"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and Pevzner (</textual><xref class="po-milestone e169 e169" linkend="Pevz01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) developed a heuristic method in which each DNA fragment was broken up into a series of short overlapping substrings of fixed length. For example, if all possible substrings of length 3 are calculated for the string ‘AGTCGTATAC’, then the original string can be reassembled by overlapping these substrings to form the directed graph of Figure 7.</textual></para><mediaobject class="po-container e170 e170"><imageobject class="po-container e171 e171"><imagedata class="po-meta e172 e172" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-007.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e173 e173"><para class="po-block e174 e174"><textual class="po-textual">Figure 7: A Sequence Graph</textual></para></caption></mediaobject><para class="po-block e175 e175"><textual class="po-textual">Each node represents two characters shared by its two adjacent arcs, which are labelled with the 3-character substrings. The cycles record the repeats ‘GT’ and ‘TA’. In practice the length of the substrings would be much greater than 3 – around 20 or so (</textual><xref class="po-milestone e176 e176" linkend="Pevz01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 9751).</textual></para><para class="po-block e177 e177"><textual class="po-textual">This enabled them to reduce the contig-asssembly problem to one of finding an ‘Eulerian’ path through the graph. An Eulerian path is one that visits each arc exactly once, although Idury and Waterman (</textual><xref class="po-milestone e178 e178" linkend="Idur95"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 295) interpret this to mean a path that may cross the same arc multiple times as if it were a set of parallel arcs. The problem can then be solved in linear time by Fleury's algorithm (</textual><xref class="po-milestone e179 e179" linkend="Aldo00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 202).</textual></para><para class="po-block e180 e180"><textual class="po-textual">The original de Bruijn graph represented all possible strings of length </textual><emphasis class="po-inline e181 e181"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> over an alphabet </textual><emphasis class="po-inline e182 e182"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and was entirely cyclical (</textual><xref class="po-milestone e183 e183" linkend="Debr46"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; </textual><xref class="po-milestone e184 e184" linkend="Good46"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). An example is shown in Figure 8, which shows all the 3-character sequences of the alphabet {0,1}.</textual></para><mediaobject class="po-container e185 e185"><imageobject class="po-container e186 e186"><imagedata class="po-meta e187 e187" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-008.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e188 e188"><para class="po-block e189 e189"><textual class="po-textual">Figure 8: A De Bruijn or Good Graph</textual></para></caption></mediaobject><para class="po-block e190 e190"><textual class="po-textual">Raphael et al.'s approach is to add insertions and deletions to the ‘de Bruijn’ graph, calling the result an A-Bruijn graph, and to use it as their data representation (</textual><xref class="po-milestone e191 e191" linkend="Raph04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Although they succeed in representing transpositions (or ‘shuffles’) and repeats, their method only aligns the highly similar regions of protein sequences, while the rest is processed separately using progressive alignment techniques.</textual></para><section class="po-hcontainer e192 e192"><title class="po-block e193 e193"><textual class="po-textual">Disadvantages of de Bruijn and A-Bruijn Graphs</textual></title><para class="po-block e194 e194"><textual class="po-textual">Using directed cycles to represent transpositions leads to complications, as admitted by Pevzner (</textual><xref class="po-milestone e195 e195" linkend="Pevz01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 9571). For example, if there are several arcs exiting a multiple arc, which of them does one take, and in what order? And what if different sequences need to traverse a multiple arc a different number of times? These complications, although they may be overcome by careful labeling of the arcs, are unnecessary. A variant graph represents transpositions without cycles (</textual><xref class="po-milestone e196 e196" linkend="Schm09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and repeats can be treated as transpositions in the same version.</textual></para><para class="po-block e197 e197"><textual class="po-textual">Also, what can be the advantage in breaking up the text and multiplying the amount of data by a factor of twenty, then joining it all back up again? Pevzner et al. admit that this actually throws away information, which has to be restored later (</textual><xref class="po-milestone e198 e198" linkend="Pevz01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 9748).</textual></para><para class="po-block e199 e199"><textual class="po-textual">The A-Bruijn graph also doesn’t appear to be editable.</textual></para></section><section class="po-hcontainer e200 e200"><title class="po-block e201 e201"><textual class="po-textual">Discussion</textual></title><para class="po-block e202 e202"><textual class="po-textual">It is interesting that biologists have now recognised that a useful way to represent multiple sequence alignments might be to use a directed graph instead of a matrix, although they have not yet worked out how best to do this. The mere fact that these approaches are an active area of research, and resemble the variant graph approach, provides a vindication of the overall MVD strategy. Many of the same problems described above will also need to be dealt with when formulating a solution to the current problem.</textual></para></section></section><section class="po-hcontainer e203 e203"><title class="po-block e204 e204"><textual class="po-textual">Anchor-Based Aligners</textual></title><para class="po-block e205 e205"><textual class="po-textual">The third area of bioinformatics that overlaps with the current problem has developed only recently. As a result of the successful sequencing of entire genomes, biologists became interested in much larger scale alignments than had been possible via traditional multiple sequence alignment. The limitation is imposed by the dynamic programming technique and its essentially O(N</textual><superscript class="po-atom e206 e206"><textual class="po-textual">2</textual></superscript><textual class="po-textual">) performance and space requirements per pair of sequences. Also, at the level of millions of base pairs, relocation, reversal and duplication events have become impossible to ignore.</textual></para><para class="po-block e207 e207"><textual class="po-textual">This need has been met by the rapid development of fragment based aligners, using an anchoring strategy, similar to Heckel's (</textual><xref class="po-milestone e208 e208" linkend="Heck78"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) algorithm. Anchoring is the process of first identifying the most similar parts of two or more sequences. Once those have been identified and merged, the program searches for further alignments in the unmerged portions of the sequences. The early fragment based aligners worked only with two versions, e.g. MUMmer (</textual><xref class="po-milestone e209 e209" linkend="Delc02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">); MultiPipMaker, based on BLASTZ (</textual><xref class="po-milestone e210 e210" linkend="Schw00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">); Avid (</textual><xref class="po-milestone e211 e211" linkend="Bray03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and LAGAN (</textual><xref class="po-milestone e212 e212" linkend="Brud03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), and do not handle transpositions, reversals and duplications within the two sequences being compared.</textual></para><section class="po-hcontainer e213 e213"><title class="po-block e214 e214"><textual class="po-textual">Shuffle-LAGAN</textual></title><para class="po-block e215 e215"><textual class="po-textual">Shuffle-Lagan or SLAGAN (</textual><xref class="po-milestone e216 e216" linkend="Brud03b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) was the first algorithm to add these more advanced editorial operations. However, the authors decline to define a mathematical model for these events and their costs (i56). The program is not symmetric: two different results will be obtained if the two sequences are presented in the opposite order. It is also rather slow; the authors quote a running time of 25 CPU-days to align the human and mouse genomes (i56).</textual></para></section><section class="po-hcontainer e217 e217"><title class="po-block e218 e218"><textual class="po-textual">Mauve</textual></title><para class="po-block e219 e219"><textual class="po-textual">Mauve (</textual><xref class="po-milestone e220 e220" linkend="Darl04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) handles transpositions, reversals and duplications, and multiple long sequences. Like the other fragment-based alignment programs, Mauve is based on anchors. The alignment process is shown in Figure 9.</textual></para><mediaobject class="po-container e221 e221"><imageobject class="po-container e222 e222"><imagedata class="po-meta e223 e223" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-009.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e224 e224"><para class="po-block e225 e225"><textual class="po-textual">Figure 9: Anchor-based Alignment in Mauve</textual></para></caption></mediaobject><para class="po-block e226 e226"><textual class="po-textual">In the first stage the program searches for Maximal Unique Matches across all the versions, the so-called ‘multiMUMs’. The multiMUMs are used to generate a phylogenetic guide tree. Successive multiMUMs that don’t overlap are then merged into local co-linear blocks or LCBs (2).  These act as anchors and allow the identification of further multi-MUMs within and between the LCBs. The identification and merging of LCBs then proceeds recursively (3). Finally, progressive alignment is performed on each LCB using the guide tree.</textual></para><para class="po-block e227 e227"><textual class="po-textual">The authors don’t say how fast it is, but it must be slower than Shuffle-LAGAN since it deals with more versions and uses progressive alignment. Its weakest point appears to be that it has no special data representation for the transpositions, and instead uses colour and interconnecting lines to adapt the traditional MSA matrix display.</textual></para></section><section class="po-hcontainer e228 e228"><title class="po-block e229 e229"><textual class="po-textual">Discussion</textual></title><para class="po-block e230 e230"><textual class="po-textual">Unlike the dynamic programming techniques considered earlier, fragment based approaches are able to process much longer sequences. They are also able to identify transpositions. If the progressive alignment stage is removed, they also have the potential to be very fast.</textual></para></section></section></section><section class="po-hcontainer e231 e231"><title class="po-block e232 e232"><textual class="po-textual">Transposition Algorithms</textual></title><para class="po-block e233 e233"><textual class="po-textual">The transposition operation, which is a key part of the current problem, has been little studied in the fields of source code management (version control) and text processing. For these purposes simply calculating the insertions and deletions between two texts at a time, the so-called ‘diffs’ usually suffices. Tichy (</textual><xref class="po-milestone e234 e234" linkend="Tich84"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), for example, reports that adding transposition to the standard diff algorithm for source code management systems only improved performance by 7%. Apart from a couple of practical algorithms for computing transpositions, most of the work is theoretical.</textual></para><para class="po-block e235 e235"><textual class="po-textual">Heckel's 1978 algorithm is the earliest known (</textual><xref class="po-milestone e236 e236" linkend="Heck78"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). It first identifies all the unique lines shared by the two strings, and extends them on either side as long as they match in both versions. If the order of these blocks differs in the two versions they are considered transposed, and otherwise aligned. His method, however, fails if there are no unique lines shared by the two strings. </textual></para><para class="po-block e237 e237"><textual class="po-textual">Tichy (</textual><xref class="po-milestone e238 e238" linkend="Tich84"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) proposed a linear time algorithm using a suffix tree for finding what he called the ‘minimal covering set’ of block moves between two strings. He defines a covering set to mean that every character appearing in both strings is covered by some block move. As shown in Figure 10, a minimal set is just a set of such moves of minimal size. Neither string need be entirely covered by the moves, however, and the moves may overlap.</textual></para><mediaobject class="po-container e239 e239"><imageobject class="po-container e240 e240"><imagedata class="po-meta e241 e241" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-010.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">Figure 10: Tichy's Minimal Covering Set</textual></para></caption></mediaobject><para class="po-block e244 e244"><textual class="po-textual">On the theoretical side, the complexity of the transposition problem was first investigated by Wagner (</textual><xref class="po-milestone e245 e245" linkend="Wagn75"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). He proved that even the addition of simple transpositions of two adjacent characters changes the computational complexity of the edit distance problem from quadratic to NP-complete.</textual></para><para class="po-block e246 e246"><textual class="po-textual">The edit distance problem with block moves was then investigated in depth by Lopresti and Tomkins (</textual><xref class="po-milestone e247 e247" linkend="Lopr97"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). They examined variations of the problem in which:</textual></para><orderedlist class="po-table e248 e248"><listitem class="po-container e249 e249"><para class="po-block e250 e250"><textual class="po-textual">The blocks are disjoint, i.e. they don’t overlap, denoted by D, or if they do by </textual><inlinemediaobject class="po-null e251 e251"><imageobject class="po-container e252 e252"><imagedata class="po-meta e253 e253" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-011.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e254 e254"><para class="po-block e255 e255"><textual class="po-textual">The blocks form a cover, i.e. the transposed blocks occupy all of the text, denoted by C or by </textual><inlinemediaobject class="po-null e256 e256"><imageobject class="po-container e257 e257"><imagedata class="po-meta e258 e258" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-012.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual"> if they don’t.</textual></para></listitem></orderedlist><para class="po-block e259 e259"><textual class="po-textual">For each of the possible combinations of C,</textual><inlinemediaobject class="po-null e260 e260"><imageobject class="po-container e261 e261"><imagedata class="po-meta e262 e262" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-012.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">,D,</textual><inlinemediaobject class="po-null e263 e263"><imageobject class="po-container e264 e264"><imagedata class="po-meta e265 e265" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-011.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual"> they examined the cost of computing the string edit distance between two strings A and B. Using the C,D notation the CD-CD problem is the computation of the string edit distance for a disjoint cover for strings A and B. They reduce each such combination to job scheduling – a known NP-complete problem (</textual><xref class="po-milestone e266 e266" linkend="Gare79"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). They conclude that the only variations that are not NP-complete are those involving </textual><inlinemediaobject class="po-null e267 e267"><imageobject class="po-container e268 e268"><imagedata class="po-meta e269 e269" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-012.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><inlinemediaobject class="po-null e270 e270"><imageobject class="po-container e271 e271"><imagedata class="po-meta e272 e272" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-011.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual"> for one of the sequences.  It is clear that the current problem here is </textual><inlinemediaobject class="po-null e273 e273"><imageobject class="po-container e274 e274"><imagedata class="po-meta e275 e275" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-012.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">D-</textual><inlinemediaobject class="po-null e276 e276"><imageobject class="po-container e277 e277"><imagedata class="po-meta e278 e278" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-012.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">D, which is NP-complete. These results are confirmed by Shapira and Storer (</textual><xref class="po-milestone e279 e279" linkend="Shap02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><section class="po-hcontainer e280 e280"><title class="po-block e281 e281"><textual class="po-textual">Discussion</textual></title><para class="po-block e282 e282"><textual class="po-textual">The practical solutions in this section are not much use for the current problem since they only deal with two versions at a time. Also, since the current problem is NP-complete, it will not be possible to design an algorithm to calculate an optimal solution with respect to edit distance. This is not as bad a result as it seems, since:</textual></para><orderedlist class="po-table e283 e283"><listitem class="po-container e284 e284"><para class="po-block e285 e285"><textual class="po-textual">there is no generally agreed measure of edit distance for transpositions, as there is for insertions, deletions and substitutions</textual></para></listitem><listitem class="po-container e286 e286"><para class="po-block e287 e287"><textual class="po-textual">just as evolutionary events are not precisely modelled by edit distance, so too an ‘optimal’ alignment in a computational sense may not correspond to an optimal alignment in an aesthetic sense.</textual></para></listitem></orderedlist><para class="po-block e288 e288"><textual class="po-textual">A well-designed heuristic algorithm, then, might actually produce better results, as well as take less time.</textual></para></section></section><section class="po-hcontainer e289 e289"><title class="po-block e290 e290"><textual class="po-textual">Collation Algorithms</textual></title><para class="po-block e291 e291"><textual class="po-textual">The third area of analogous research belongs to the more familiar field of humanities computing. A collation program is designed to automate a manual task: the comparison of a number of texts to discover their differences, and output them as an apparatus criticus (</textual><xref class="po-milestone e292 e292" linkend="Shil96"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 134). These differences could then be used to construct a stemma or phylogenetic tree, which would in turn be used in the establishment of the one ‘true’ text (</textual><xref class="po-milestone e293 e293" linkend="Gree94"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 359-360). Clearly, this process belongs to the age of print, but even in the modern digital era there is still a need to compare texts. The current problem can be regarded as a reframing of that process for the digital medium.</textual></para><section class="po-hcontainer e294 e294"><title class="po-block e295 e295"><textual class="po-textual">Sliding Window Collators</textual></title><para class="po-block e296 e296"><textual class="po-textual">Froger (</textual><xref class="po-milestone e297 e297" linkend="Frog68"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 230) describes the execution of what was probably the world's first collation program, running on a Bull GE-55 computer that had only 5K of internal memory. It compared two texts, one word at a time. If there was a mismatch the program gradually increased its lookahead to 2, 5, 25, ... words, comparing all of the words with one another in this window until it found a match, then sliding the window on by one word at a time. This allowed it to recognise insertions, deletions and substitutions over short distances.</textual></para><para class="po-block e298 e298"><textual class="po-textual">This sliding window design, although later much enhanced, appears to have been the basis of all collating programs until recently. Its main disadvantages are that it can’t recognise transpositions, and that it will fail to correctly align inserted or deleted sections larger than its window size. Computational complexity for each pair of versions is O(NW</textual><superscript class="po-atom e299 e299"><textual class="po-textual">2</textual></superscript><textual class="po-textual">), where W is the sliding window size, and N is the average length of the two sequences. Typically a modern collation program will compare each version against a single, and possibly idealistic, base text. Examples include COLLATE (</textual><xref class="po-milestone e300 e300" linkend="Robi89"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 102) and TUSTEP (</textual><xref class="po-milestone e301 e301" linkend="Ott00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></section><section class="po-hcontainer e302 e302"><title class="po-block e303 e303"><textual class="po-textual">Progressive Alignment</textual></title><para class="po-block e304 e304"><textual class="po-textual">Spencer and Howe (</textual><xref class="po-milestone e305 e305" linkend="Spen04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) apply biological progressive alignment to medieval texts of the Canterbury Tales and Parzival. They point out that current automatic collation techniques mimic the original manual process too closely. In particular they object that comparing each version against a base text omits important comparisons between individual witnesses. However, their main objective is to generate a phylogenetic tree or stemma, rather than to produce an apparatus.</textual></para></section><section class="po-hcontainer e306 e306"><title class="po-block e307 e307"><textual class="po-textual">JUXTA</textual></title><para class="po-block e308 e308"><textual class="po-textual">JUXTA (</textual><xref class="po-milestone e309 e309" linkend="Mcga06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) is an open source program, whose collation algorithm is an adaptation of Heckel's (1978). The adaptation consists in reducing the granularity from a line to a word, and in calling it recursively on the unaligned parts. JUXTA collates plain text with embedded empty XML elements as milestone references, like the COCOA references in COLLATE. JUXTA can also be used to produce an apparatus criticus.</textual></para></section><section class="po-hcontainer e310 e310"><title class="po-block e311 e311"><textual class="po-textual">MEDITE</textual></title><para class="po-block e312 e312"><textual class="po-textual">MEDITE (</textual><xref class="po-milestone e313 e313" linkend="Bour07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) is a two-way alignment algorithm based loosely on the fragment based aligners Shuffle-LAGAN and Mauve. The advantage of this approach, in which the transpositions and matches are identified first, then substitutions, insertions and deletions, is that a linear performance can be achieved. The algorithm is basically:
</textual><orderedlist class="po-table e314 e314"><listitem class="po-container e315 e315"><para class="po-block e316 e316"><textual class="po-textual">Normalise the two texts in some predefined way, e.g. removal of punctuation, reduction to lowercase, removal of accents etc.</textual></para></listitem><listitem class="po-container e317 e317"><para class="po-block e318 e318"><textual class="po-textual">Build a generalised suffix tree between strings A and B, as described in (</textual><xref class="po-milestone e319 e319" linkend="Gusf97"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 125). This calculates MUMs between the two strings in linear time.</textual></para></listitem><listitem class="po-container e320 e320"><para class="po-block e321 e321"><textual class="po-textual">Decide which matches are aligned and which are transposed. Since the number of combinations of matches generated by step 2 is exponential, a LIS heuristic (</textual><xref class="po-milestone e322 e322" linkend="Guye97"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) is used to find a good alignment.</textual></para></listitem><listitem class="po-container e323 e323"><para class="po-block e324 e324"><textual class="po-textual">Repeat steps 2 and 3 recursively between each pair of aligned blocks.</textual></para></listitem></orderedlist></para></section><section class="po-hcontainer e325 e325"><title class="po-block e326 e326"><textual class="po-textual">Disadvantages of Collation</textual></title><para class="po-block e327 e327"><textual class="po-textual">Collation algorithms have several potential weaknesses. They are mostly slow, and generally collate </textual><emphasis class="po-inline e328 e328"><textual class="po-textual">plain</textual></emphasis><textual class="po-textual"> text, rather than XML. Nowadays transcriptions of documents in linguistics and the humanities are more likely to be in some form of XML. The problem is that if one collates XML, then the generated apparatus will contain unmatched tags. Markup will then have to be ignored, but that means losing valuable information.</textual></para><para class="po-block e329 e329"><textual class="po-textual">The inclusion of COCOA or empty XML references embedded in the text precludes the use of any other kind of markup, such as structural markup. But references are only needed for attaching the apparatus to the main text, and this could be done away with in a purely digital edition.</textual></para><para class="po-block e330 e330"><textual class="po-textual">Comparison needs to be between all versions at once. Currently only Spencer and Howe's (</textual><xref class="po-milestone e331 e331" linkend="Spen04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) method achieves this.</textual></para><para class="po-block e332 e332"><textual class="po-textual">Transpositions need to be detected, especially when a work is witnessed by many independent copies. Few of the algorithms do this, and none over n versions.</textual></para><para class="po-block e333 e333"><textual class="po-textual">Taken together, the most advanced algorithm appears to be Bourdaillet's (</textual><xref class="po-milestone e334 e334" linkend="Bour07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). However, it can only consider two versions at a time, and so cannot be directly applied to the current problem.</textual></para></section></section></section><section class="po-hcontainer e335 e335"><title class="po-block e336 e336"><textual class="po-textual">A Fast Algorithm to Merge n Versions with Block Moves</textual></title><para class="po-block e337 e337"><textual class="po-textual">The preceding sections have described the various techniques and pitfalls of aligning n versions with or without block transpositions. As explained at the beginning of this paper, if the MVD concept is to become a viable solution, some means must be provided to update an MVD with the text of a new or existing version. This can only be achieved if a number of conditions are met:</textual></para><orderedlist class="po-table e338 e338"><listitem class="po-container e339 e339"><para class="po-block e340 e340"><textual class="po-textual">It has to work in ‘real’ time, so that the user doesn’t lose interest in the process. In other words, the algorithm must terminate correctly in the order of seconds, rather than minutes, hours or days.</textual></para></listitem><listitem class="po-container e341 e341"><para class="po-block e342 e342"><textual class="po-textual">It has to detect transpositions automatically.</textual></para></listitem><listitem class="po-container e343 e343"><para class="po-block e344 e344"><textual class="po-textual">It doesn’t have to produce 100% accurate alignments, but it should be accurate enough for the user not to notice.</textual></para></listitem><listitem class="po-container e345 e345"><para class="po-block e346 e346"><textual class="po-textual">It needs to update by aligning the new version with </textual><emphasis class="po-inline e347 e347"><textual class="po-textual">all</textual></emphasis><textual class="po-textual"> versions currently in the MVD. Otherwise editing will gradually degrade the quality of the alignment.</textual></para></listitem></orderedlist><section class="po-hcontainer e348 e348"><title class="po-block e349 e349"><textual class="po-textual">Alignment Without Transposing</textual></title><para class="po-block e350 e350"><textual class="po-textual">Before considering the complications arising from transpositions, the algorithm’s processing of direct alignments will be described. This will simplify the transposition case and provide a better overall understanding of how the algorithm works. For direct alignments the procedure is basically:</textual></para><section class="po-hcontainer e351 e351"><title class="po-block e352 e352"><textual class="po-textual">Algorithm 1</textual></title><programlisting class="po-block e353 e353" xml:space="preserve"><textual class="po-textual">
1. Find the longest MUM (Maximal Unique Match) between the new version and the versions of the variant 
graph.
2. Merge the new version and the graph at that point, partitioning them both into two halves.
3. Call the algorithm recursively on the two subgraphs, each spanned by one segment of the new 
version.</textual></programlisting></section><section class="po-hcontainer e354 e354"><title class="po-block e355 e355"><textual class="po-textual">Finding The Best MUM</textual></title><para class="po-block e356 e356"><textual class="po-textual">When comparing two strings, a Maximal Exact Match, or MEM, is a sequence of consecutive matching characters in both strings that cannot be extended at either end. A MUM, or Maximal Unique Match, is a MEM that occurs only once in the two strings (</textual><xref class="po-milestone e357 e357" linkend="Delc02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In Figure 11 ‘the quick brown fox’ and ‘ brown fox jumps over the ’ are both MUMs, while ‘the ’ is a MEM that also occurs elsewhere.</textual></para><mediaobject class="po-container e358 e358"><imageobject class="po-container e359 e359"><imagedata class="po-meta e360 e360" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-013.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e361 e361"><para class="po-block e362 e362"><textual class="po-textual">Figure 11: Maximal Exact Match and Maximal Unique Match</textual></para></caption></mediaobject><para class="po-block e363 e363"><textual class="po-textual">In the current problem MUMs will be sought between the new version being added to the graph and the entire graph, the longest of which is the best MUM. They need to be MUMs and not MEMs because otherwise erroneous alignments would be generated. For example, choosing arbitrary instances of multiple spaces at the start of lines, or repeated sequences of markup tokens as points of equivalence would lead to serious misalignments.</textual></para><para class="po-block e364 e364"><textual class="po-textual">Finding the best MUM is related to the problem of finding the Longest Common Substring (LCS) between two strings. A naive approach to finding the LCS might look like this:</textual></para><orderedlist class="po-table e365 e365"><listitem class="po-container e366 e366"><para class="po-block e367 e367"><textual class="po-textual">Examine each character in the first string and compare it with each character in the second string.</textual></para></listitem><listitem class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">If the two characters are the same, continue comparing successive positions in the two strings until you get a mismatch.</textual></para></listitem><listitem class="po-container e370 e370"><para class="po-block e371 e371"><textual class="po-textual">Store the match in a table. If it was already present, increment its count by 1.</textual></para></listitem><listitem class="po-container e372 e372"><para class="po-block e373 e373"><textual class="po-textual">Once all characters in the first string have been used up, the best MUM is the longest string in the table whose frequency is 1.</textual></para></listitem></orderedlist><para class="po-block e374 e374"><textual class="po-textual">Two problems with this naive approach are immediately clear: firstly it is inefficient, since it will take O(MN) time, where M and N are the lengths of the two strings. Secondly, the number of strings in the table will be enormous, as many as M</textual><superscript class="po-atom e375 e375"><textual class="po-textual">2</textual></superscript><textual class="po-textual">N</textual><superscript class="po-atom e376 e376"><textual class="po-textual">2</textual></superscript><textual class="po-textual">. A much faster and more space-efficient way is to use suffix trees.</textual></para><para class="po-block e377 e377"><textual class="po-textual">A suffix tree stores all the suffixes of a given string. In Figure 12 each path from the root to a leaf spells out one possible suffix of ‘Woolloomooloo’. In the leaves are stored the start position of each suffix in the original string. A node labelled λ indicates that at this point in the tree a suffix occurs with no further text, e.g. for the suffixes ‘oo’ and ‘o’. A suffix tree can be used to find any </textual><emphasis class="po-inline e378 e378"><textual class="po-textual">substring</textual></emphasis><textual class="po-textual"> of length M in that string with just M comparisons, however long the string may be.</textual></para><mediaobject class="po-container e379 e379"><imageobject class="po-container e380 e380"><imagedata class="po-meta e381 e381" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-014.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e382 e382"><para class="po-block e383 e383"><textual class="po-textual">Figure 12: A Suffix Tree of ‘Woolloomooloo’</textual></para></caption></mediaobject><para class="po-block e384 e384"><textual class="po-textual">A suffix tree can be constructed in linear time using Ukkonen's algorithm (</textual><xref class="po-milestone e385 e385" linkend="Ukko95"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The LCS between two strings can also be calculated in linear time by building what is called a ‘generalised suffix tree’ (</textual><xref class="po-milestone e386 e386" linkend="Gusf97"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 125). A generalised suffix tree represents n strings instead of 1. For two strings this method constructs a suffix tree from one of the strings in linear time, then carries on building the same tree with the second string. The leaf nodes are labelled by the number of the string and the starting index in either or both strings. Any internal node that has only two leaves as children, one from each string, or any leaf shared by the two strings, must be the suffix of a MUM. The MUM itself can be recovered by counting backwards in both strings until a mismatch. </textual></para><para class="po-block e387 e387"><textual class="po-textual">Unfortunately, it is unclear if one can build a suffix tree from a variant graph. How are the suffixes to be identified, and how can one represent starting offsets within arcs that belong to multiple versions? In any case the gains from using a generalised suffix tree appear to be minimal in practice, since its use greatly increases storage requirements.</textual></para><para class="po-block e388 e388"><textual class="po-textual">The method adopted here resembles the streaming technique used in MUMmer (</textual><xref class="po-milestone e389 e389" linkend="Delc02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In this method only one suffix tree is built. The other sequence is then streamed against it to find matches.</textual></para><mediaobject class="po-container e390 e390"><imageobject class="po-container e391 e391"><imagedata class="po-meta e392 e392" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-015.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e393 e393"><para class="po-block e394 e394"><textual class="po-textual">Figure 13: Finding Matches </textual></para></caption></mediaobject><para class="po-block e395 e395"><textual class="po-textual">The place of the streamed sequence can be taken by the variant graph, whose characters can be exhaustively listed by breadth-first traversal (</textual><xref class="po-milestone e396 e396" linkend="Sedg88"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 430f). Each successive character from the graph is traced in a suffix tree built from the text of the new version, as shown in Figure 13. At the end of an arc, for example, at node 3, MATCH calls itself recursively on each diverging arc until a mismatch occurs. At this point the MATCH procedure has detected a raw match, of which there are likely to be very many. Since all that is wanted is the longest MUM, some filtering of matches is clearly required.</textual></para><orderedlist class="po-table e397 e397"><listitem class="po-container e398 e398"><para class="po-block e399 e399"><textual class="po-textual">Any match shorter than a minimum length (typically 3-5) can be discarded. The user, however, may set this  to 1 for a  finer-grained alignment.</textual></para></listitem><listitem class="po-container e400 e400"><para class="po-block e401 e401"><textual class="po-textual">Many matches are not unique in the suffix tree. Any match that terminates in an internal node shares a path with some other suffix in the tree, and can be discarded. This also cuts out most short matches that pass the first filter.</textual></para></listitem><listitem class="po-container e402 e402"><para class="po-block e403 e403"><textual class="po-textual">Most remaining matches are not maximal. This can be tested for by comparing the two characters immediately preceding the match in the new version and the variant graph. If they are the same, the match is not maximal and can be discarded.</textual></para></listitem></orderedlist><para class="po-block e404 e404"><textual class="po-textual">Candidate MUMs surviving these tests are passed to the UPDATEMUM procedure. Experimental data suggests that, with a minimum match length of five, only about 15% of matches that make it through the three filters are not MUMs.</textual></para></section><section class="po-hcontainer e405 e405"><title class="po-block e406 e406"><textual class="po-textual">Time Complexity of the MATCH Procedure</textual></title><para class="po-block e407 e407"><textual class="po-textual">The cost of scanning for matches between the graph and the new version is O(M(1+</textual><inlinemediaobject class="po-null e408 e408"><imageobject class="po-container e409 e409"><imagedata class="po-meta e410 e410" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-016.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual">)), where M is the number of characters in the graph, and </textual><inlinemediaobject class="po-null e411 e411"><imageobject class="po-container e412 e412"><imagedata class="po-meta e413 e413" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-016.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></inlinemediaobject><textual class="po-textual"> the average length of a match in the suffix tree. In the case that the graph and the new version have no characters in common, exactly M comparisons will be made. On the other hand, in the worst case that the graph and the new version are identical, the program will require NM/2 comparisons. So the time complexity lies between quadratic and linear, depending on the number and distribution of differences between the graph and the new version.</textual></para></section><section class="po-hcontainer e414 e414"><title class="po-block e415 e415"><textual class="po-textual">Updating the MUM</textual></title><para class="po-block e416 e416"><textual class="po-textual">The candidate MUMs, and their frequencies, are stored in a hashtable. When a new candidate MUM arrives from the MATCH procedure, and is already present in the table, its frequency is incremented, otherwise it is added to the table with frequency 1. After the scan of the variant graph is complete, the longest match in the table whose frequency is still 1 will be the best MUM. The cost of each update to the hashtable is constant, and the cost of the final searching through the entries to find the best MUM is an additional linear cost for the whole operation, which has no effect on the time complexity of the algorithm.</textual></para></section><section class="po-hcontainer e417 e417"><title class="po-block e418 e418"><textual class="po-textual">Merging the MUM into the Graph</textual></title><para class="po-block e419 e419"><textual class="po-textual">Having found the longest MUM, the next step is to merge the new version with the variant graph at that point. In fact, before searching for the MUM the new version has already been added to the variant graph as a </textual><emphasis class="po-inline e420 e420"><textual class="po-textual">special arc</textual></emphasis><textual class="po-textual"> connected to the start and end-nodes, as shown in Figure 14.</textual></para><mediaobject class="po-container e421 e421"><imageobject class="po-container e422 e422"><imagedata class="po-meta e423 e423" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-017.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e424 e424"><para class="po-block e425 e425"><textual class="po-textual">Figure 14: Direct Alignment, First Iteration </textual></para></caption></mediaobject><section class="po-hcontainer e426 e426"><title class="po-block e427 e427"><textual class="po-textual">Definition 1</textual></title><para class="po-block e428 e428"><textual class="po-textual">A </textual><emphasis class="po-inline e429 e429"><textual class="po-textual">special arc</textual></emphasis><textual class="po-textual"> represents a new version as yet unassimilated into the variant graph, and is distinguished in some way from other non-special arcs. In all other respects a special arc is still part of the graph, and does not violate its definition because it is part of the unique path of the new version. In Figure 14 the C-arc is a special arc, and is drawn in grey to indicate its status. A special arc is associated with a MUM, which represents its best fit to the variant graph. In Figure 14 the longest MUM, marked in bold, is ‘&lt;/l&gt;&lt;l&gt;d’un antico acquedotto di sguardi,&lt;/l&gt;&lt;l&gt;la sua curva sacra e ’ (‘&lt;/l&gt;&lt;l&gt;of an ancient aqueduct of glances,&lt;/l&gt;&lt;l&gt;its curve sacred and ’), taken from the B-version. It can be merged with the rest of the variant graph by splitting the special arc and the graph at each end of the MUM, then adding new nodes as required, and finally connecting the new arcs to the right nodes. The result is shown in Figure 15.</textual></para><mediaobject class="po-container e430 e430"><imageobject class="po-container e431 e431"><imagedata class="po-meta e432 e432" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-018.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e433 e433"><para class="po-block e434 e434"><textual class="po-textual">Figure 15: Direct Alignment, Second Iteration </textual></para></caption></mediaobject><para class="po-block e435 e435"><textual class="po-textual">Figure 16 shows that there are now two subgraphs on either side of the newly aligned section, and two subarcs left over from the special arc. The terms ‘subarc’ and ‘subgraph’ need to be defined because they will be used in the discussion that follows.</textual></para><mediaobject class="po-container e436 e436"><imageobject class="po-container e437 e437"><imagedata class="po-meta e438 e438" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-019.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e439 e439"><para class="po-block e440 e440"><textual class="po-textual">Figure 16: Subgraphs and Subarcs </textual></para></caption></mediaobject></section><section class="po-hcontainer e441 e441"><title class="po-block e442 e442"><textual class="po-textual">Definition 2</textual></title><para class="po-block e443 e443"><textual class="po-textual">A </textual><emphasis class="po-inline e444 e444"><textual class="po-textual">subgraph</textual></emphasis><textual class="po-textual"> refers to either the entire graph, minus any special arcs, or to any subgraph thereof that conforms to the definition of the variant graph. It has distinguished start and end-nodes and a set of versions over which it ranges.</textual></para></section><section class="po-hcontainer e445 e445"><title class="po-block e446 e446"><textual class="po-textual">Definition 3</textual></title><para class="po-block e447 e447"><textual class="po-textual">A </textual><emphasis class="po-inline e448 e448"><textual class="po-textual">subarc</textual></emphasis><textual class="po-textual"> is a special arc left over after the merging of another special arc. In Figure 16 ‘&lt;l&gt;Questa è la ultima porta’ and ‘solitaria:&lt;/l&gt;’ are both subarcs.</textual></para><para class="po-block e449 e449"><textual class="po-textual">Algorithm 1 can now be called on the subarcs and their corresponding subgraphs. This process of alignment and recursion will continue until the length of a subgraph or subarc falls below the minimum, or no further MUMs can be found. In Figure 16, the right subgraph and its subarc can be merged by the shared MUM ‘a:&lt;/l&gt;’ and on the left by ‘&lt;l&gt;Questa è la ultima ’. Once those merges have been carried out, however, no further merges of more than one character are possible.</textual></para></section><section class="po-hcontainer e450 e450"><title class="po-block e451 e451"><textual class="po-textual">One Small Problem</textual></title><para class="po-block e452 e452"><textual class="po-textual">In the subgraphs of Figure 16, the right subgraph no longer contains a complete A-version. Since the A and B versions on the right are not parallel, it is impossible to tell which portion of A corresponds to the remaining part of the C-version. This is not ideal and does lead to some misalignments. For example, if the text of version C had ended with ‘magic’ instead of ‘solitari’, then, after merging, ‘magic’ would occur twice in the graph, as shown in Figure 17. Order sensitivity has not been entirely banished, as in the POA algorithm.</textual></para><mediaobject class="po-container e453 e453"><imageobject class="po-container e454 e454"><imagedata class="po-meta e455 e455" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-020.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e456 e456"><para class="po-block e457 e457"><textual class="po-textual">Figure 17: A Non-optimal Alignment</textual></para></caption></mediaobject><para class="po-block e458 e458"><textual class="po-textual">One solution is to optimise the graph subsequently. Anomalies like these can be merged away by reconsidering all combinations of arcs between shared endpoints once the first pass of the algorithm has produced a rough version of the graph. In this way the two ‘magic’s could be identified as identical variants of one another and merged. In bioinformatics such iterative refinement techniques have produced high quality alignments, for example TCOFFEE (</textual><xref class="po-milestone e459 e459" linkend="Notr00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) DIALIGN (</textual><xref class="po-milestone e460 e460" linkend="Morg96"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and MAFFT (</textual><xref class="po-milestone e461 e461" linkend="Kato02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). However, this problem does not so often arise in practice, and its solution is left open for future work.</textual></para></section></section></section><section class="po-hcontainer e462 e462"><title class="po-block e463 e463"><textual class="po-textual">Adding Transpositions</textual></title><para class="po-block e464 e464"><textual class="po-textual">The addition of transpositions adds some complications to the simple algorithm just described. This section investigates why it is necessary to compute them at all, rather than simply identify them manually. It also describes how transpositions can be distinguished from random alignments between versions, and how they can be efficiently computed by a slight extension to the direct alignment algorithm.</textual></para><section class="po-hcontainer e465 e465"><title class="po-block e466 e466"><textual class="po-textual">Why Detect Transpositions Automatically?</textual></title><para class="po-block e467 e467"><textual class="po-textual">In texts written by the author evidence of actual transpositions could refute any computational heuristic. Figure 18 shows a clear case of transposition. What need could there be to </textual><emphasis class="po-inline e468 e468"><textual class="po-textual">calculate</textual></emphasis><textual class="po-textual"> the presence of transpositions when their existence can be precisely verified in this way?</textual></para><mediaobject class="po-container e469 e469"><imageobject class="po-container e470 e470"><imagedata class="po-meta e471 e471" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-021.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e472 e472"><para class="po-block e473 e473"><textual class="po-textual">Figure 18: A Clear Case of Transposition</textual></para></caption></mediaobject><para class="po-block e474 e474"><textual class="po-textual">Firstly, even in manuscripts written by the author, the presence of a transposition may not always be immediately obvious. The author may choose to completely rewrite the sentence or to indicate the transposition by some other means, such as insertion and deletion, as in Figure 19.</textual></para><mediaobject class="po-container e475 e475"><imageobject class="po-container e476 e476"><imagedata class="po-meta e477 e477" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-022.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e478 e478"><para class="po-block e479 e479"><textual class="po-textual">Figure 19: Deletion and Reinsertion of ‘la sera’</textual></para></caption></mediaobject><para class="po-block e480 e480"><textual class="po-textual">Secondly, in the case of multiple drafts, or multiple witnesses of the one text, the discovery of transpositions </textual><emphasis class="po-inline e481 e481"><textual class="po-textual">between</textual></emphasis><textual class="po-textual"> physical versions is extremely difficult using any manual method. Even in the case of original manuscripts with corrections by the author, a good automatic method could produce the correct result most of the time. In that case, the editor would only be obliged to manually intervene in a small number of cases. Exactly how such a manual intervention would work is left for the moment as an open question.</textual></para></section><section class="po-hcontainer e482 e482"><title class="po-block e483 e483"><textual class="po-textual">What Constitutes a Transposition?</textual></title><para class="po-block e484 e484"><textual class="po-textual">The edit cost of a transposition in biological sequences is considered to be constant, e.g. Lopresti and Tomkins (1997). If this was also true of documentary texts then even single characters that matched at the start and end of a long document would have to be considered as potential transpositions, but intuitively that isn’t likely.</textual></para><para class="po-block e485 e485"><textual class="po-textual">A metric for assessing the validity of transpositions may instead be modelled as a threshold rather than as an edit cost. Whether a match is a transposition or not seems to be a function of the match's size and the distance between its two halves. Over what ranges those quantities of size and distance may vary can be determined by experiment.</textual></para><para class="po-block e486 e486"><textual class="po-textual">A sample of 49 real cases of transposition were manually identified in a wide variety of texts:</textual></para><orderedlist class="po-table e487 e487"><listitem class="po-container e488 e488"><para class="po-block e489 e489"><textual class="po-textual">The Vienna Edition of Ludwig Wittgenstein (</textual><xref class="po-milestone e490 e490" linkend="Nedo99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e491 e491"><para class="po-block e492 e492"><textual class="po-textual">The Sibylline Gospel (</textual><xref class="po-milestone e493 e493" linkend="Schm08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e494 e494"><para class="po-block e495 e495"><textual class="po-textual">Some texts taken from the plays of Henrik Ibsen by Hilda Böe (</textual><xref class="po-milestone e496 e496" linkend="Boe08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e497 e497"><para class="po-block e498 e498"><textual class="po-textual">The </textual><emphasis class="po-inline e499 e499"><textual class="po-textual">Refrains</textual></emphasis><textual class="po-textual"> of the 16th century Flemish poetess Anna Bijns (</textual><xref class="po-milestone e500 e500" linkend="Vand08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e501 e501"><para class="po-block e502 e502"><textual class="po-textual">The plays of Aeschylus (</textual><xref class="po-milestone e503 e503" linkend="Page72"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e504 e504"><para class="po-block e505 e505"><textual class="po-textual">The </textual><emphasis class="po-inline e506 e506"><textual class="po-textual">Ulysses</textual></emphasis><textual class="po-textual"> of James Joyce (</textual><xref class="po-milestone e507 e507" linkend="Gabl84"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)</textual></para></listitem></orderedlist><para class="po-block e508 e508"><textual class="po-textual">The results are shown in Figure 20. ‘Size’ means the length of the transposed text and ‘distance’ is the distance in characters between the insertion and deletion points before the transposition was carried out.</textual></para><mediaobject class="po-container e509 e509"><imageobject class="po-container e510 e510"><imagedata class="po-meta e511 e511" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-023.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e512 e512"><para class="po-block e513 e513"><textual class="po-textual">Figure 20: Transpositions: Size vs Distance</textual></para></caption></mediaobject><para class="po-block e514 e514"><textual class="po-textual">It is clear from this graph that real transpositions are mostly short-range affairs. (Not considered here are 'transpositions' produced by the reordering of entire works within a single manuscript, as in </textual><xref class="po-milestone e515 e515" linkend="Spen03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.) An approximate heuristic is d &lt; |m|</textual><superscript class="po-atom e516 e516"><textual class="po-textual">φ</textual></superscript><textual class="po-textual">, where d is the distance between the two halves of the match, |m| its length, and φ is the golden ratio, approximately 1.618034. This ratio is relevant for two reasons: it has been used in the arts since classical times, particularly in architecture, and also it expresses a ratio of relative length: (a+b)/a = a/b = φ. All 49 examples meet this simple criterion. Using such a threshold yields the double benefit of decreasing the amount of calculation while increasing accuracy.</textual></para></section><section class="po-hcontainer e517 e517"><title class="po-block e518 e518"><textual class="po-textual">Merging Transpositions into the Variant Graph</textual></title><para class="po-block e519 e519"><textual class="po-textual">Before describing the algorithm it is necessary to explain the difference between merging a direct alignment with the variant graph and merging a transposition. Conceptually a direct alignment and a transposition are very similar: both identify aligned parts in the new version and the variant graph, but in the transposition case the two halves of the alignment are not opposite one another.</textual></para><mediaobject class="po-container e520 e520"><imageobject class="po-container e521 e521"><imagedata class="po-meta e522 e522" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-024.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e523 e523"><para class="po-block e524 e524"><textual class="po-textual">Figure 21: Merging a Transposition</textual></para></caption></mediaobject><para class="po-block e525 e525"><textual class="po-textual">In Figure 21 ‘parrot’ has been identified as a transposition between versions B and C. Merging has been carried out so that the two instances of ‘parrot’ in versions B and C have been separated from their arcs by the addition of new nodes. This creates two new subarcs ‘the raucous’ and ‘swiftly’ on the left, which are both opposite the same subgraph ‘the dog’. The source instance ‘parrot’ in version B may still participate in further transpositions or even in a direct alignment, for example, if the C-version read ‘a surprised parrot’ instead of ‘a surprised lorikeet’. There is no harm in this, and in fact this is one way to detect repetitions. Apart from the addition of a node or two, merging a transposition does not materially change the structure of a variant graph. All that happens is that one half of the match is marked as the parent (in this case the B-version), and the other as the child (version C).</textual></para></section></section><section class="po-hcontainer e526 e526"><title class="po-block e527 e527"><textual class="po-textual">A Simple Algorithm for Detecting Transpositions</textual></title><para class="po-block e528 e528"><textual class="po-textual">The place to look for transpositions of a special arc is thus anywhere </textual><emphasis class="po-inline e529 e529"><textual class="po-textual">except</textual></emphasis><textual class="po-textual"> in its opposite subgraph and any arcs parallel to it. But in order to apply the threshold formula derived above to restrict the range of that search, there needs to be some accurate and reliable way to specify the distance between the two halves of a transposition. In Figure 22 the special arc, shown in grey, spans its subgraph, which is shown in the context of the overall graph. The special arc contains two matches, shown as thicker lines. The distance between the two halves of each match is measured backwards or forwards, following the shortest path, from the end of the match in the special arc to the start of the transposed text in the graph. The objective here is not to solve the shortest path problem optimally – in fact, the very idea of using a shortest path is itself a heuristic – but simply to provide a fast way to estimate distance. A simple breadth-first traversal combined with a greedy calculation of the shortest path to any node from its immediate predecessors provides the appropriate linear performance.</textual></para><mediaobject class="po-container e530 e530"><imageobject class="po-container e531 e531"><imagedata class="po-meta e532 e532" fileref="../../../vol3/graphics/Schmidt01/Schmidt01-025.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e533 e533"><para class="po-block e534 e534"><textual class="po-textual">Figure 22: Measuring Transpose Distance </textual></para></caption></mediaobject><para class="po-block e535 e535"><textual class="po-textual">This measurement process also suggests an algorithm. To find what transpositions are possible for any special arc one only has to look to the left and right of the immediately opposite subgraph of a special arc, as far as the threshold formula allows. For any special arc A there is no point looking further than |A|</textual><superscript class="po-atom e536 e536"><textual class="po-textual">φ</textual></superscript><textual class="po-textual"> bytes to the left or right. Of course, any match m that is found, where |m| &lt; |A| also has to pass the threshold formula. Algorithm 2 uses this technique to modify Algorithm 1 to include transpositions, and also adds a bit more detail from the above discussion.</textual></para><section class="po-hcontainer e537 e537"><title class="po-block e538 e538"><textual class="po-textual">Algorithm 2</textual></title><programlisting class="po-block e539 e539" xml:space="preserve"><textual class="po-textual">
1.  Set currentArc to a special arc made from the new version
2.  Set currentGraph to the variant graph
3.  Attach currentArc to the start and end of currentGraph
4.  Compute the bestMUM between currentArc and currentGraph
5.  Create a priority queue </textual><emphasis class="po-inline e540 e540"><textual class="po-textual">specials</textual></emphasis><textual class="po-textual"> of tuples {Arc,MUM,Graph}
6.  WHILE bestMUM is not NULL DO
7.    Merge bestMUM into currentGraph.
8.    FOR each subarc created by the merge DO
9.      Compute the directMUM, leftTransposeMUM and rightTransposeMUM
10.     Set MUM to the best of the three
11.     IF MUM is not NULL THEN
12.       Insert {subarc,MUM,subgraph} into </textual><emphasis class="po-inline e541 e541"><textual class="po-textual">specials;</textual></emphasis><textual class="po-textual"> keep it sorted
13.     END IF
14.   END FOR
15.   POP {currentArc, bestMUM, currentGraph} from </textual><emphasis class="po-inline e542 e542"><textual class="po-textual">specials;</textual></emphasis><textual class="po-textual">
16. END WHILE
</textual></programlisting><para class="po-block e543 e543"><textual class="po-textual">Algorithm 2 creates a priority queue of triples A</textual><subscript class="po-atom e544 e544"><textual class="po-textual">i</textual></subscript><textual class="po-textual">,M</textual><subscript class="po-atom e545 e545"><textual class="po-textual">i</textual></subscript><textual class="po-textual">,S</textual><subscript class="po-atom e546 e546"><textual class="po-textual">j</textual></subscript><textual class="po-textual">, where A</textual><subscript class="po-atom e547 e547"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is a special arc, M</textual><subscript class="po-atom e548 e548"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is its best MUM with the graph, and S</textual><subscript class="po-atom e549 e549"><textual class="po-textual">j</textual></subscript><textual class="po-textual"> is its opposite subgraph. It has a j subscript, not i because, as explained above, more than one special arc may share the same subgraph. The queue is kept sorted on decreasing length of MUM (line 12). In line 7 the longest MUM is used to create 0-2 new subgraphs and subarcs. Each new subarc, together with its  subgraph and its best MUM, are added to the </textual><emphasis class="po-inline e550 e550"><textual class="po-textual">specials</textual></emphasis><textual class="po-textual"> queue. When the queue no longer contains a valid MUM the program terminates.</textual></para><para class="po-block e551 e551"><textual class="po-textual">The calculation of the two transpose MUMs uses the same process as the direct MUM, except that the variant graph is searched </textual><emphasis class="po-inline e552 e552"><textual class="po-textual"> backwards</textual></emphasis><textual class="po-textual"> on the left hand side from the start node of the subgraph, and forwards from its end node, as shown in Figure 22. The best such MUM found is recorded as the left or right transpose MUM for the special arc. In choosing the best of three in line 10, if a transpose MUM and a direct MUM are of the same length, the direct MUM is preferred.</textual></para><para class="po-block e553 e553"><textual class="po-textual">This algorithm is admittedly naive, but it is easy to implement. In reality transpositions are often composed of imperfectly matched sections, that is, literal matches interspersed with small variants, deletions and insertions. Refinement of the algorithm to allow for such fuzzy matching is left for future work. For the moment, this simple atomic approach to transposition produces satisfactory results.</textual></para></section><section class="po-hcontainer e554 e554"><title class="po-block e555 e555"><textual class="po-textual">Time Complexity of Algorithm 2</textual></title><para class="po-block e556 e556"><textual class="po-textual">There are three operations that have greater than constant cost:</textual></para><orderedlist class="po-table e557 e557"><listitem class="po-container e558 e558"><para class="po-block e559 e559"><textual class="po-textual">Calculation of Direct Align MUMs (lines 4, 9). Since Algorithm 2 subdivides and recurses into smaller and smaller sections of the graph without recalculating MUMs except where a merge has been made, this process is essentially linear. The speed of the merge operation is thus governed by the cost of calculating the best MUM, which is O(MN).</textual></para></listitem><listitem class="po-container e560 e560"><para class="po-block e561 e561"><textual class="po-textual">Calculation of Transpose MUMs (line 9). The same observation applies to transpose MUMs, and its cost is likewise governed by the cost of computing the best MUM.</textual></para></listitem><listitem class="po-container e562 e562"><para class="po-block e563 e563"><textual class="po-textual">Keeping the </textual><emphasis class="po-inline e564 e564"><textual class="po-textual">specials</textual></emphasis><textual class="po-textual"> Queue Sorted (line 12). Using a red-black tree the cost is only O(log Q), where Q is the queue length (</textual><xref class="po-milestone e565 e565" linkend="Sedg88"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 218f). This has no impact on the overall time complexity because it is always much cheaper than the cost of computing MUMs.</textual></para></listitem></orderedlist><para class="po-block e566 e566"><textual class="po-textual">Thus, summing the direct alignment, transposition and sorting costs, the time complexity of merging one version into a variant graph using Algorithm 2, with block transpositions, is O(MN) in the worst case.</textual></para></section><section class="po-hcontainer e567 e567"><title class="po-block e568 e568"><textual class="po-textual">Experimental Performance of Algorithm 2</textual></title><para class="po-block e569 e569"><textual class="po-textual">Algorithm 2 has been written up as a test program called </textual><link class="po-inline e570 e570" xlink:actuate="onRequest" xlink:href="http://www.itee.uq.edu.au/~schmidt/downloads.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">MergeTester</textual></link><textual class="po-textual"> (http://www.itee.uq.edu.au/~schmidt/downloads.html), and has been run on a wide variety of multi-version example texts. The parameters measured are: author, title, average version size in kilobytes, number of versions, approximate date of manuscripts, total time to merge all versions in seconds and average time to merge one version after the first. Times were computed on a 1.66GHz processor. The test program was single-threaded.</textual></para><section class="po-hcontainer e571 e571"><title class="po-block e572 e572"><textual class="po-textual">Performance of Algorithm 2 on Example Texts</textual></title><table class="po-container e573 e573"><col align="left" class="po-meta e574 e574" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e575 e575" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e576 e576" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e577 e577" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e578 e578" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e579 e579" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e580 e580" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e581 e581"><tr class="po-table e582 e582"><th align="left" class="po-field e583 e583"><textual class="po-textual">Author</textual></th><th class="po-field e584 e584"><textual class="po-textual">Title</textual></th><th class="po-field e585 e585"><textual class="po-textual">Size</textual></th><th class="po-field e586 e586"><textual class="po-textual"># Versions</textual></th><th class="po-field e587 e587"><textual class="po-textual">Date</textual></th><th class="po-field e588 e588"><textual class="po-textual">Total Time</textual></th><th class="po-field e589 e589"><textual class="po-textual">Time Per Version</textual></th></tr></thead><tbody class="po-table e590 e590"><tr class="po-table e591 e591"><td class="po-block e592 e592"><textual class="po-textual">Galiano</textual></td><td class="po-block e593 e593"><textual class="po-textual">El mapa de las aguas</textual></td><td align="right" class="po-block e594 e594"><textual class="po-textual">36.0</textual></td><td align="center" class="po-block e595 e595"><textual class="po-textual">3</textual></td><td class="po-block e596 e596"><textual class="po-textual">1993</textual></td><td align="right" class="po-block e597 e597"><textual class="po-textual">8.0</textual></td><td align="right" class="po-block e598 e598"><textual class="po-textual">4.0</textual></td></tr><tr class="po-table e599 e599"><td class="po-block e600 e600"><textual class="po-textual">Chedid</textual></td><td class="po-block e601 e601"><textual class="po-textual">La robe noire</textual></td><td align="right" class="po-block e602 e602"><textual class="po-textual">1.3</textual></td><td align="center" class="po-block e603 e603"><textual class="po-textual">2</textual></td><td class="po-block e604 e604"><textual class="po-textual">1996</textual></td><td align="right" class="po-block e605 e605"><textual class="po-textual">0.2</textual></td><td align="right" class="po-block e606 e606"><textual class="po-textual">0.2</textual></td></tr><tr class="po-table e607 e607"><td class="po-block e608 e608"><textual class="po-textual">Bijns</textual></td><td class="po-block e609 e609"><textual class="po-textual">Refrains</textual></td><td align="right" class="po-block e610 e610"><textual class="po-textual">15.4</textual></td><td align="center" class="po-block e611 e611"><textual class="po-textual">3</textual></td><td class="po-block e612 e612"><textual class="po-textual">16th C.</textual></td><td align="right" class="po-block e613 e613"><textual class="po-textual">5.0</textual></td><td align="right" class="po-block e614 e614"><textual class="po-textual">2.5</textual></td></tr><tr class="po-table e615 e615"><td class="po-block e616 e616"><textual class="po-textual">Huygens</textual></td><td class="po-block e617 e617"><textual class="po-textual">Ooghentroost (fragment)</textual></td><td align="right" class="po-block e618 e618"><textual class="po-textual">3.4</textual></td><td align="center" class="po-block e619 e619"><textual class="po-textual">6</textual></td><td class="po-block e620 e620"><textual class="po-textual">17th C.</textual></td><td align="right" class="po-block e621 e621"><textual class="po-textual">2.0</textual></td><td align="right" class="po-block e622 e622"><textual class="po-textual">0.4</textual></td></tr><tr class="po-table e623 e623"><td class="po-block e624 e624"><textual class="po-textual">Cerami</textual></td><td class="po-block e625 e625"><textual class="po-textual">La donna serpente</textual></td><td align="right" class="po-block e626 e626"><textual class="po-textual">12.0</textual></td><td align="center" class="po-block e627 e627"><textual class="po-textual">9</textual></td><td class="po-block e628 e628"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e629 e629"><textual class="po-textual">7.6</textual></td><td align="right" class="po-block e630 e630"><textual class="po-textual">1.0</textual></td></tr><tr class="po-table e631 e631"><td class="po-block e632 e632"><textual class="po-textual">Cerami</textual></td><td class="po-block e633 e633"><textual class="po-textual">Le visioni del calvo</textual></td><td align="right" class="po-block e634 e634"><textual class="po-textual">12.0</textual></td><td align="center" class="po-block e635 e635"><textual class="po-textual">5</textual></td><td class="po-block e636 e636"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e637 e637"><textual class="po-textual">2.9</textual></td><td align="right" class="po-block e638 e638"><textual class="po-textual">0.7</textual></td></tr><tr class="po-table e639 e639"><td class="po-block e640 e640"><textual class="po-textual">Cerami</textual></td><td class="po-block e641 e641"><textual class="po-textual">L'uovo di colombo</textual></td><td align="right" class="po-block e642 e642"><textual class="po-textual">12.0</textual></td><td align="center" class="po-block e643 e643"><textual class="po-textual">8</textual></td><td class="po-block e644 e644"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e645 e645"><textual class="po-textual">3.0</textual></td><td align="right" class="po-block e646 e646"><textual class="po-textual">0.4</textual></td></tr><tr class="po-table e647 e647"><td class="po-block e648 e648"><textual class="po-textual">Cerami</textual></td><td class="po-block e649 e649"><textual class="po-textual">Nascosti tra la folla</textual></td><td align="right" class="po-block e650 e650"><textual class="po-textual">12.0</textual></td><td align="center" class="po-block e651 e651"><textual class="po-textual">7</textual></td><td class="po-block e652 e652"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e653 e653"><textual class="po-textual">4.9</textual></td><td align="right" class="po-block e654 e654"><textual class="po-textual">0.8</textual></td></tr><tr class="po-table e655 e655"><td class="po-block e656 e656"><textual class="po-textual">Cerami</textual></td><td class="po-block e657 e657"><textual class="po-textual">Paul Newman</textual></td><td align="right" class="po-block e658 e658"><textual class="po-textual">10.0</textual></td><td align="center" class="po-block e659 e659"><textual class="po-textual">8</textual></td><td class="po-block e660 e660"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e661 e661"><textual class="po-textual">5.7</textual></td><td align="right" class="po-block e662 e662"><textual class="po-textual">0.8</textual></td></tr><tr class="po-table e663 e663"><td class="po-block e664 e664"><textual class="po-textual">Cerami</textual></td><td class="po-block e665 e665"><textual class="po-textual">Una donna alta</textual></td><td align="right" class="po-block e666 e666"><textual class="po-textual">12.0</textual></td><td align="center" class="po-block e667 e667"><textual class="po-textual">11</textual></td><td class="po-block e668 e668"><textual class="po-textual">1991</textual></td><td align="right" class="po-block e669 e669"><textual class="po-textual">16.3</textual></td><td align="right" class="po-block e670 e670"><textual class="po-textual">1.5</textual></td></tr><tr class="po-table e671 e671"><td class="po-block e672 e672"><textual class="po-textual">Magrelli</textual></td><td class="po-block e673 e673"><textual class="po-textual">Campagna romana</textual></td><td align="right" class="po-block e674 e674"><textual class="po-textual">0.6</textual></td><td align="center" class="po-block e675 e675"><textual class="po-textual">15</textual></td><td class="po-block e676 e676"><textual class="po-textual">1981</textual></td><td align="right" class="po-block e677 e677"><textual class="po-textual">0.8</textual></td><td align="right" class="po-block e678 e678"><textual class="po-textual">0.05</textual></td></tr><tr class="po-table e679 e679"><td class="po-block e680 e680"><textual class="po-textual">ANC Corpus</textual></td><td class="po-block e681 e681"><textual class="po-textual">Adams Elissa</textual></td><td align="right" class="po-block e682 e682"><textual class="po-textual">3.4</textual></td><td align="center" class="po-block e683 e683"><textual class="po-textual">5</textual></td><td class="po-block e684 e684"><textual class="po-textual">20th C.</textual></td><td align="right" class="po-block e685 e685"><textual class="po-textual">7.0</textual></td><td align="right" class="po-block e686 e686"><textual class="po-textual">1.7</textual></td></tr><tr class="po-table e687 e687"><td class="po-block e688 e688"><textual class="po-textual">Anon</textual></td><td class="po-block e689 e689"><textual class="po-textual">Sibylline Gospel</textual></td><td align="right" class="po-block e690 e690"><textual class="po-textual">3.0</textual></td><td align="center" class="po-block e691 e691"><textual class="po-textual">36</textual></td><td class="po-block e692 e692"><textual class="po-textual">4th-12th C.</textual></td><td align="right" class="po-block e693 e693"><textual class="po-textual">28.4</textual></td><td align="right" class="po-block e694 e694"><textual class="po-textual">0.8</textual></td></tr><tr class="po-table e695 e695"><td class="po-block e696 e696"><textual class="po-textual">Malvezzi</textual></td><td class="po-block e697 e697"><textual class="po-textual">El Rómulo</textual></td><td align="right" class="po-block e698 e698"><textual class="po-textual">98.2</textual></td><td align="center" class="po-block e699 e699"><textual class="po-textual">5</textual></td><td class="po-block e700 e700"><textual class="po-textual">17th C.</textual></td><td align="right" class="po-block e701 e701"><textual class="po-textual">68.0</textual></td><td align="right" class="po-block e702 e702"><textual class="po-textual">17.0</textual></td></tr></tbody></table></section><section class="po-hcontainer e703 e703"><title class="po-block e704 e704"><textual class="po-textual">Alignment Quality</textual></title><para class="po-block e705 e705"><textual class="po-textual">As pointed out in Darling et al. (</textual><xref class="po-milestone e706 e706" linkend="Darl04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 1398), anchor-based alignment techniques that detect transpositions are very difficult to assess objectively. For multiple sequence alignment programs the manually aligned Baslibase archive (</textual><xref class="po-milestone e707 e707" linkend="Thom99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) has been used as a measure of alignment quality. No such benchmark also exists for texts aligned with transpositions and repeats. Visual inspection is subjective, very difficult, and likely to miss many errors. All that can be said at this stage is that, with the exception of the Malvezzi texts (see below), all of the alignments appear to be of good quality, with few missed transpositions or misalignments.</textual></para></section></section></section></section><section class="po-hcontainer e708 e708"><title class="po-block e709 e709"><textual class="po-textual">Conclusion</textual></title><para class="po-block e710 e710"><textual class="po-textual">The problem of how to merge n versions of a text into a variant graph is closely related to applications in biology that seek to compare genetic or amino acid sequences. Their output has traditionally been either a set of aligned sequences or a phylogentic tree showing the interrelationships between versions. Transpositions were not considered.</textual></para><para class="po-block e711 e711"><textual class="po-textual">Like the biologists, humanists have also developed programs to ‘collate’ or compare versions to find differences, originally with a view to constructing the apparatus criticus of the print edition (a kind of alignment), and also a stemma (a kind of phylogenetic tree). Recently they have also tried to apply biological techniques to their texts.</textual></para><para class="po-block e712 e712"><textual class="po-textual">The biologists have recently realised the importance of transpositions, and have tried to create new methods for genome comparison that includes them. Some of these new techniques seek to replace the traditional matrix representation of a multiple sequence alignment by a directed graph. Their graph models, however, are much more complex than the variant graph, although they represent practically the same information. They are also very slow to construct if they attempt to align individual characters. None of the biological programs can be directly applied to the different requirements of humanities and linguistics multi-version texts.</textual></para><para class="po-block e713 e713"><textual class="po-textual">The inclusion of transpositions renders the problem of calculating an optimal alignment between multiple versions intractable. But an optimal alignment is not really necessary. Instead, a heuristic method for aligning n versions with block transpositions has been described, which has O(MN) performance in the worst case, and is often much faster. It uses a novel technique for filtering transpositions via a simple threshold formula, which reduces the amount of computation while increasing accuracy. In texts of typical length of around 50K it can add or replace a version in a variant graph or multi-version document in a few seconds.</textual></para><para class="po-block e714 e714"><textual class="po-textual">Although this represents a ‘first cut’ at solving a difficult problem, results are encouraging enough to demonstrate the viability of using variant graphs or MVDs to overcome the long-standing problems of how to represent ‘overlapping hierarchies’ and multiple versions in humanities texts.</textual></para></section><section class="po-hcontainer e715 e715"><title class="po-block e716 e716"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e717 e717"><textual class="po-textual">This work, although independent research, is supported by the Italian project CoOPERARE (Content Organisation, Propagation, Evaluation and Reuse through Active Repositories), Project of Research in the National Interest (PRIN), 2008-09, whose Rome research unit is directed by Domenico Fiormonte.</textual></para><para class="po-block e718 e718"><textual class="po-textual">The example texts of Angel Garcia Galiano, Vicenzo Cerami and Valerio Magrelli were provided by </textual><link class="po-inline e719 e719" xlink:actuate="onRequest" xlink:href="http://www.digitalvariants.org" xlink:show="new" xlink:type="simple"><textual class="po-textual"> Digital Variants</textual></link><textual class="po-textual">. The texts of Huygens and Anna Bijns were supplied by Ron Van den Branden of the </textual><link class="po-inline e720 e720" xlink:actuate="onRequest" xlink:href="http://www.kantl.be/ctb/project/dalf/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CTB</textual></link><textual class="po-textual"> in Belgium. The Malvezzi texts were supplied by Carmen Isasi of the University of Deusto, Spain, and the Sibylline Gospel texts by Nicoletta Brocca of the University of Venice Ca' Foscari.</textual></para></section><bibliography class="po-hcontainer e721 e721"><title class="po-block e722 e722"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e723 e723" xml:id="Aldo00"><textual class="po-textual">Aldous, J.M. and Wilson, R.J. Graphs and Applications an Introductory Approach. London: Springer, 2000.</textual></bibliomixed><bibliomixed class="po-block e724 e724" xml:id="Barn88"><textual class="po-textual">Barnard, D., Hayter, R., Karababa, M., Logan, G., McFadden, J. ‘SGML-Based Markup for Literary Texts: Two Problems and Some Solutions’, Computers and the Humanities. 22: 265-276, 1988. </textual><biblioid class="po-atom e725 doi e725"><textual class="po-textual">10.1007/BF00118602</textual></biblioid></bibliomixed><bibliomixed class="po-block e726 e726" xml:id="Bart06"><textual class="po-textual">Bart, P.R. ‘Experimental markup in a TEI-conformant setting’, Digital Medievalist, 2: 2006.</textual><link class="po-inline e727 e727" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.digitalmedievalist.org/article.cfm?RecID=10"</textual></link></bibliomixed><bibliomixed class="po-block e728 e728" xml:id="Boe08"><textual class="po-textual">Böe, H. ‘Manuscript Encoding Clarification and Transposition; New Features for the Module for Transcription of Primary Sources?’, unpublished. </textual><link class="po-inline e729 e729" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.emunch.no/tei-mm-2008/index_ms.html</textual></link></bibliomixed><bibliomixed class="po-block e730 e730" xml:id="Bour07"><textual class="po-textual">Bourdaillet, J. Alignment textuel monolingue avec recherche de déplacements: algorithmique pour la critique génétique. PhD Thesis, Université Paris 6 Pierre et Marie Curie, 2007.</textual></bibliomixed><bibliomixed class="po-block e731 e731" xml:id="Bray03"><textual class="po-textual">Bray, N., Dubchak, I. and Pachter, L. AVID: A Global Alignment Program, Genome Research, 2003, 97-102.</textual></bibliomixed><bibliomixed class="po-block e732 e732" xml:id="Bray08"><textual class="po-textual">Bray, T., Paoli, J., Sperberg-McQueen, C.M., Maler, E., Yergeau, F. Extensible Markup Language (XML) 1.0 (Fifth Edition). </textual><link class="po-inline e733 e733" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2008/PER-xml-20080205/</textual></link></bibliomixed><bibliomixed class="po-block e734 e734" xml:id="Brud03a"><textual class="po-textual">Brudno, M., Do, C.B., Cooper, G.M., Kim, M.F., Davydov, E., Green, E.D., Sidow, A., Batzoglou, S. ‘LAGAN and Multi-LAGAN: Efficient Tools for Large-Scale Multiple Alignment of Genomic DNA’, Genome Research, 13: 721-731. </textual><biblioid class="po-atom e735 doi e735"><textual class="po-textual">10.1101/gr.926603</textual></biblioid></bibliomixed><bibliomixed class="po-block e736 e736" xml:id="Brud03b"><textual class="po-textual">Brudno, M., Malde, S., Poliakov, A., Do, C.B., Couronne, O., Dubchak, I. and Batzoglou, S. ‘Glocal alignment: finding rearrangements during alignment’, Bioinformatics, 19: 2003, 154-162. </textual><biblioid class="po-atom e737 doi e737"><textual class="po-textual">10.1093/bioinformatics/btg1005</textual></biblioid></bibliomixed><bibliomixed class="po-block e738 e738" xml:id="Buzz02"><textual class="po-textual">Buzzetti, D. ‘Digital Representation and the Text Model’, New Literary History, 33: 2002, 61-88. </textual><biblioid class="po-atom e739 doi e739"><textual class="po-textual">10.1353/nlh.2002.0003</textual></biblioid></bibliomixed><bibliomixed class="po-block e740 e740" xml:id="Darl04"><textual class="po-textual">Darling, A.C.E., Mau, B. and Blattner, F.R. Mauve: Multiple Alignment of Conserved Sequence With Rearrangements. Genome Research, 14: 2004, 1394-1403. </textual><biblioid class="po-atom e741 doi e741"><textual class="po-textual">10.1101/gr.2289704</textual></biblioid></bibliomixed><bibliomixed class="po-block e742 e742" xml:id="Debr46"><textual class="po-textual">de Bruijn, N.G. ‘A Combinatorial Problem’, Koninklijke Nederlandse Akademie v. Wetenschappen, 49: 1946, 758-764.</textual></bibliomixed><bibliomixed class="po-block e743 e743" xml:id="Delc02"><textual class="po-textual">Delcher, A.L., Phillippy, A., Carlton, J. and Salzberg, S.L. ‘Fast algorithms for large-scale genome alignment and comparison’. Nucleic Acids Research, 30.11: 2002, 2478-2483. </textual><biblioid class="po-atom e744 doi e744"><textual class="po-textual">10.1093/nar/30.11.2478</textual></biblioid></bibliomixed><bibliomixed class="po-block e745 e745" xml:id="Dero04"><textual class="po-textual">DeRose, S. ‘Markup Overlap: A Review and a Horse,’ Extreme Markup Languages Conference, Montreal, 2004. </textual><link class="po-inline e746 e746" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.idealliance.org/papers/extreme/proceedings/html/2004/DeRose01/EML2004DeRose01.html</textual></link></bibliomixed><bibliomixed class="po-block e747 e747" xml:id="Edga06"><textual class="po-textual">Edgar, R.C. and Batzoglou, ‘Multiple sequence alignment’, Current Opinion in Structutural Biology, 16: 2006, 368-373. </textual><biblioid class="po-atom e748 doi e748"><textual class="po-textual">10.1016/j.sbi.2006.04.004</textual></biblioid></bibliomixed><bibliomixed class="po-block e749 e749" xml:id="Feng87"><textual class="po-textual">Feng, D.F. and Doolittle, R.F. ‘Progressive Sequence Alignment as a Prerequisite to Correct Phylogenic Trees’, Journal of Molecular Evolution, 25: 1987, 351-360. </textual><biblioid class="po-atom e750 doi e750"><textual class="po-textual">10.1007/BF02603120</textual></biblioid></bibliomixed><bibliomixed class="po-block e751 e751" xml:id="Frog68"><textual class="po-textual">Froger, D.J. La Critique des textes et son automatisation. Paris: Dunod, 1968.</textual></bibliomixed><bibliomixed class="po-block e752 e752" xml:id="Gabl84"><textual class="po-textual">Gabler, H.W. ‘Towards an Electronic Edition of James Joyce's Ulysses’, Literary and Linguistic Computing, 15: 2000, 115-120. </textual><biblioid class="po-atom e753 doi e753"><textual class="po-textual">10.1093/llc/15.1.115</textual></biblioid></bibliomixed><bibliomixed class="po-block e754 e754" xml:id="Gare79"><textual class="po-textual">Garey, M.R. and Johnson, D. ‘Computers and Intractability; A Guide to the Theory of NP-Completeness’, San Francisco: Freeman, 1979.</textual></bibliomixed><bibliomixed class="po-block e755 e755" xml:id="Gold90"><textual class="po-textual">Goldfarb, C. The SGML Handbook. Oxford: Oxford University Press, 1990.</textual></bibliomixed><bibliomixed class="po-block e756 e756" xml:id="Good46"><textual class="po-textual">Good, I.J. ‘Normal Recurring Decimals’, Journal of the London Mathematical Society, 21: 1946, 167-169. </textual><biblioid class="po-atom e757 doi e757"><textual class="po-textual">10.1112/jlms/s1-21.3.167</textual></biblioid></bibliomixed><bibliomixed class="po-block e758 e758" xml:id="Gras04"><textual class="po-textual">Grasso, C. and Lee, C. ‘Combining partial order alignment and progressive multiple sequence alignment increases alignment speed and scalability to very large alignment problems’, Bioinformatics, 20.10: 2004, 1546-1556. </textual><biblioid class="po-atom e759 doi e759"><textual class="po-textual">10.1093/bioinformatics/bth126</textual></biblioid></bibliomixed><bibliomixed class="po-block e760 e760" xml:id="Gree94"><textual class="po-textual">Greetham, D.C. Textual Scholarship: An Introduction. New York and London: Garland, 1994.</textual></bibliomixed><bibliomixed class="po-block e761 e761" xml:id="Gu99"><textual class="po-textual">Gu, Q-P., Peng, S. and Sudborough, H. ‘A 2-approximation algorithm for genome rearrangement by reversals and transpositions’, Theoretical Computer Science, 210: 1999, 327-339. </textual><biblioid class="po-atom e762 doi e762"><textual class="po-textual">10.1016/S0304-3975(98)00092-9</textual></biblioid></bibliomixed><bibliomixed class="po-block e763 e763" xml:id="Gusf97"><textual class="po-textual">Gusfield, D. Algorithms on Strings, Trees and Sequences: Computer Science and Computer Biology. Cambridge: Cambridge University Press, 1997.</textual></bibliomixed><bibliomixed class="po-block e764 e764" xml:id="Guye97"><textual class="po-textual">Guyer, G.S., Heath, L.S., Vergara, J.P.C. ‘Subsequence and Run Heuristics for Sorting by Transpositions’, Technical Report TR-97-20, Virginia Polytechnic Institute and State University, 1997. </textual><link class="po-inline e765 e765" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://historical.ncstrl.org/tr/fulltext/tr/vatech_cs/TR-97-20.txt</textual></link></bibliomixed><bibliomixed class="po-block e766 e766" xml:id="Heck78"><textual class="po-textual">Heckel, P. ‘A Technique for Isolating Differences Between Files’, Communications of the ACM, 21.4: 1978, 264-268. </textual><biblioid class="po-atom e767 doi e767"><textual class="po-textual">10.1145/359460.359467</textual></biblioid></bibliomixed><bibliomixed class="po-block e768 e768" xml:id="Ide06"><textual class="po-textual">Ide, N. and Suderman, K. ‘Integrating Linguistic Resources: The American National Corpus Model’,
Proceedings of the Fifth Language Resources and Evaluation Conference, 2006.</textual></bibliomixed><bibliomixed class="po-block e769 e769" xml:id="Idur95"><textual class="po-textual">Idury, R.M. and Waterman, M.S. ‘A New Algorithm for DNA Sequence Assembly’, Journal of Computational Biology, 2.2: 1995, 291-306. </textual><biblioid class="po-atom e770 doi e770"><textual class="po-textual">10.1089/cmb.1995.2.291</textual></biblioid></bibliomixed><bibliomixed class="po-block e771 e771" xml:id="Kato02"><textual class="po-textual">Katoh, K., Misawa, K., Kuma, K. and Miyata, T. ‘MAFFT: a novel method for rapid multiple sequence alignment based on Fast Fourier transform’, Nucleic Acids Research, 30.14: 2002, 3059--3066. </textual><biblioid class="po-atom e772 doi e772"><textual class="po-textual">10.1093/nar/gkf436</textual></biblioid></bibliomixed><bibliomixed class="po-block e773 e773" xml:id="Lass02"><textual class="po-textual">Lassmann, T. and Sonnhammer, E.L.L. ‘Quality assessment of multiple alignment programs’, FEBS Letters, 529: 2002, 126-130. </textual><biblioid class="po-atom e774 doi e774"><textual class="po-textual">10.1016/S0014-5793(02)03189-7</textual></biblioid></bibliomixed><bibliomixed class="po-block e775 e775" xml:id="Lee02"><textual class="po-textual">Lee, C. Grasso, C. and Sharlow, M.F. ‘Multiple sequence alignment using partial order graphs’, Bioinformatics, 18.3: 2002, 452-464. </textual><biblioid class="po-atom e776 doi e776"><textual class="po-textual">10.1093/bioinformatics/18.3.452</textual></biblioid></bibliomixed><bibliomixed class="po-block e777 e777" xml:id="Lesk02"><textual class="po-textual">Lesk, A.M. Introduction to Bioinformatics. Oxford: Oxford University Press, 2002.</textual></bibliomixed><bibliomixed class="po-block e778 e778" xml:id="Leve66"><textual class="po-textual">Levenshtein, V.I. ‘Binary Codes Capable of Correcting Insertions and Reversals’, Soviet Physics: ‘Doklady’, 10.8: 1966, 707-710.</textual></bibliomixed><bibliomixed class="po-block e779 e779" xml:id="Lopr97"><textual class="po-textual">Lopresti, D. and Tomkins, A. ‘Block edit models for approximate string matching’, Theoretical Computer Science, 181: 1997, 159-179. </textual><biblioid class="po-atom e780 doi e780"><textual class="po-textual">10.1016/S0304-3975(96)00268-X</textual></biblioid></bibliomixed><bibliomixed class="po-block e781 e781" xml:id="Maas03"><textual class="po-textual">Maas, J.F. Vollautomatische Konvertierung mehrfach XML-annotierter Texte in das NITE-XML Austauschformat, Masters Dissertation, Uni. of Bielefeld, 2003. </textual><link class="po-inline e782 e782" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://coli.lili.uni-bielefeld.de/Texttechnologie/Forschergruppe/sekimo/nite/Text/Magisterarbeit.pdf</textual></link></bibliomixed><bibliomixed class="po-block e783 e783" xml:id="Magr81"><textual class="po-textual">Magrelli, V. Ora serrata retinae. Milan: Feltrinelli, 1981.</textual></bibliomixed><bibliomixed class="po-block e784 e784" xml:id="Mcga01"><textual class="po-textual">McGann, J.J. Radiant Textuality. London: Palgrave McMillan, 2001.</textual></bibliomixed><bibliomixed class="po-block e785 e785" xml:id="Mcga06"><textual class="po-textual">McGann, J.J. Juxta, 2006. </textual><link class="po-inline e786 e786" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.patacriticism.org/juxta/</textual></link></bibliomixed><bibliomixed class="po-block e787 e787" xml:id="Morg96"><textual class="po-textual">Morgenstern, B., Dress, A. and Werner, T. ‘Multiple DNA and Protein Sequence Alignment Based on Segment-To-Segment Comparison’, Proceedings of the Natioanl Academy of Sciences of the United States of America, 93.22: 1996, 12098-12103. </textual><biblioid class="po-atom e788 doi e788"><textual class="po-textual">10.1073/pnas.93.22.12098</textual></biblioid></bibliomixed><bibliomixed class="po-block e789 e789" xml:id="Need70"><textual class="po-textual">Needleman, S.B. and Wunsch, C.D. ‘A General Method Applicable to the Search for Similarities in the Amino Acid Sequence of Two Proteins’, Journal of Molecular Biology, 48: 1970, 443-453. </textual><biblioid class="po-atom e790 doi e790"><textual class="po-textual">10.1016/0022-2836(70)90057-4</textual></biblioid></bibliomixed><bibliomixed class="po-block e791 e791" xml:id="Nedo99"><textual class="po-textual">Nedo, M. Ludwig Wittgenstein Wiener Ausgabe Studien Texte Band 1-5. Vienna and New York: Springer, 1999.</textual></bibliomixed><bibliomixed class="po-block e792 e792" xml:id="Neyt06"><textual class="po-textual">Neyt, V. ‘Fretful Tags Amid the Verbiage: Issues in the Representation of Modern Manuscript Material’, Literary and Linguistic Computing, 21: 2006, 99-111. </textual><biblioid class="po-atom e793 doi e793"><textual class="po-textual">10.1093/llc/fql002</textual></biblioid></bibliomixed><bibliomixed class="po-block e794 e794" xml:id="Notr00"><textual class="po-textual">Notredame, C, Higgins, D.G. and Heringa, J. T-Coffee: ‘A Novel Method for Fast and Accurate Multiple Sequence Alignment’, Journal of Molecular Biology, 302: 2000, 205-217. </textual><biblioid class="po-atom e795 doi e795"><textual class="po-textual">10.1006/jmbi.2000.4042</textual></biblioid></bibliomixed><bibliomixed class="po-block e796 e796" xml:id="Ott00"><textual class="po-textual">Ott, W. Stategies and Tools for Textual Scholarship: the Tübingen System of Text Processing Programs (TUSTEP)’, Literary and Linguistic Computing, 15.1: 2000, 93-108. </textual><biblioid class="po-atom e797 doi e797"><textual class="po-textual">10.1093/llc/15.1.93</textual></biblioid></bibliomixed><bibliomixed class="po-block e798 e798" xml:id="Page72"><textual class="po-textual">Page, D.L. Aeschyli Septem quae Supersunt Tragoedias. Oxford: Clarendon Press, 1972.</textual></bibliomixed><bibliomixed class="po-block e799 e799" xml:id="Pevz89"><textual class="po-textual">Pevzner, P. ‘L-Tuple DNA sequencing. Computer Analysis’, Journal of Biomolecular Structure and Dynamics, 7: 1989, 63-73.</textual></bibliomixed><bibliomixed class="po-block e800 e800" xml:id="Pevz01"><textual class="po-textual">Pevzer P.A., Tang, H. and Waterman, M.S. ‘An Eulerian path approach to DNA fragment assembly’, Proceedings of the National Academy of Sciences USA, 98.17: 2001, 9748-9753. </textual><biblioid class="po-atom e801 doi e801"><textual class="po-textual">10.1073/pnas.171285098</textual></biblioid></bibliomixed><bibliomixed class="po-block e802 e802" xml:id="Pevz04"><textual class="po-textual">Pevzner, P.A., Tang, H. and Tesler, G. ‘De Novo Repeat Classification and Fragment Assembly’. Genome Research, 14: 2004, 1786-1796. </textual><biblioid class="po-atom e803 doi e803"><textual class="po-textual">10.1101/gr.2395204</textual></biblioid></bibliomixed><bibliomixed class="po-block e804 e804" xml:id="Raph04"><textual class="po-textual">Raphael, B., Zhi, D. and Tang, H. ‘A novel method for multiple alignment of sequences with repeated and shuffled elements’, Genome Research, 14: 2004, 2336-2346. </textual><biblioid class="po-atom e805 doi e805"><textual class="po-textual">10.1101/gr.2657504</textual></biblioid></bibliomixed><bibliomixed class="po-block e806 e806" xml:id="Robi89"><textual class="po-textual">Robinson, P.M.W. ‘The Collation and Textual Criticism of Icelandic Manuscripts (1): Collation’, Literary and Linguistic Computing 4.2: 1989, 99-105. </textual><biblioid class="po-atom e807 doi e807"><textual class="po-textual">10.1093/llc/4.2.99</textual></biblioid></bibliomixed><bibliomixed class="po-block e808 e808" xml:id="Sahl05"><textual class="po-textual">Sahle, P. ‘Digitales Archiv – Digitale Edition. Anmerkungen zur Begriffsklärung’. In: Literatur und Literaturwissenschaft auf dem Weg zu den neuen Medien, M. Stoltz, L.M. Gisi and J. Loop (eds), Basel: germanistik.ch, 2005.</textual></bibliomixed><bibliomixed class="po-block e809 e809" xml:id="Schm08"><textual class="po-textual">Schmidt, D., Brocca, N. and Fiormonte, D. ‘A Multi-Version Wiki’. In: Proceedings of Digital Humanities 2008, Oulu, Finland, June, E.S. Ore and L.L. Opas-Hänninen (eds), 187-188.</textual></bibliomixed><bibliomixed class="po-block e810 e810" xml:id="Schm09"><textual class="po-textual">Schmidt, D. and Colomb, R. ‘A data structure for representing multi-version texts online’. International Journal of Human-Computer Studies. 67.6: 2009, 497-514. </textual><biblioid class="po-atom e811 doi e811"><textual class="po-textual">10.1016/j.ijhcs.2009.02.001</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e812 e812" xml:id="Schw00"><textual class="po-textual">Schwartz, S., Zhang, Z. and Frazer, A. ‘PipMaker A Web Server for Aligning Two Genomic DNA Sequences’, Genome Research, 10: 2000, 577-586. </textual><biblioid class="po-atom e813 doi e813"><textual class="po-textual">10.1101/gr.10.4.577</textual></biblioid></bibliomixed><bibliomixed class="po-block e814 e814" xml:id="Sedg88"><textual class="po-textual">Sedgewick, R. Algorithms. Reading Massachusetts: Addison-Wesley, 1988.</textual></bibliomixed><bibliomixed class="po-block e815 e815" xml:id="Shap02"><textual class="po-textual">Shapira, D. and Storer, D.A. ‘Edit Distance with Move Operations’, Lecture Notes in Computer Science, 2373: 2002, 85-98. </textual><biblioid class="po-atom e816 doi e816"><textual class="po-textual">10.1007/3-540-45452-7_9</textual></biblioid></bibliomixed><bibliomixed class="po-block e817 e817" xml:id="Shil96"><textual class="po-textual">Shillingsburg, P.L. Scholarly Editing in the Computer Age. Theory and Practice. AnnArbor: University of Michigan Press, 1996.</textual></bibliomixed><bibliomixed class="po-block e818 e818" xml:id="Spen04"><textual class="po-textual">Spencer, M. and Howe, C.J. ‘Collating Texts Using Progressive Multiple Alignment’, Computers and the Humanities, 38: 2004, 253-270. </textual><biblioid class="po-atom e819 doi e819"><textual class="po-textual">10.1007/s10579-004-8682-1</textual></biblioid></bibliomixed><bibliomixed class="po-block e820 e820" xml:id="Spen03"><textual class="po-textual">Spencer, M. Bordalejo, B., Wang, Li-San, Barbrook, A.C., Mooney, L.R., Robinson, P., Warnow, T and Howe, C.J. ‘Analyzing the Order of Items in Manuscripts of The Canterbury Tales’, Computers and the Humanities, 37.1: 2003, 97-109. </textual><biblioid class="po-atom e821 doi e821"><textual class="po-textual">10.1023/A:1021818600001</textual></biblioid></bibliomixed><bibliomixed class="po-block e822 e822" xml:id="Stuh08"><textual class="po-textual">Stührenberg, M. and Goecke, D. ‘SGF - An integrated model for multiple annotations and its application in a linguistic domain’. In: Balisage: The Markup Conference Proceedings. </textual><link class="po-inline e823 e823" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://balisage.net/Proceedings/html/2008/Stuehrenberg01/Balisage2008-Stuehrenberg01.html</textual></link><textual class="po-textual">. </textual><biblioid class="po-atom e824 doi e824"><textual class="po-textual">10.4242/BalisageVol1.Stuehrenberg01</textual></biblioid></bibliomixed><bibliomixed class="po-block e825 e825" xml:id="Thom94"><textual class="po-textual">Thompson, J.D., Higgins, D.G. and Gibson, T.J. ‘CLUSTALW: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice’. Nucleic Acids Research, 22: 1994, 4673-4680. </textual><biblioid class="po-atom e826 doi e826"><textual class="po-textual">10.1093/nar/22.22.4673</textual></biblioid></bibliomixed><bibliomixed class="po-block e827 e827" xml:id="Thom99"><textual class="po-textual">Thompson, J.D., Plewniak, F. and Poch, O. BAliBASE: a benchmark alignment database for the evaluation of multiple alignment programs, Bioinformatics, 15: 1999, 87-88. </textual><biblioid class="po-atom e828 doi e828"><textual class="po-textual">10.1093/bioinformatics/15.1.87</textual></biblioid></bibliomixed><bibliomixed class="po-block e829 e829" xml:id="Tich84"><textual class="po-textual">Tichy, W.F. ‘The String-to-String Correction Problem with Block Moves’, ACM Transactions on Computer Systems 2.4: 1984, 309-321. </textual><biblioid class="po-atom e830 doi e830"><textual class="po-textual">10.1145/357401.357404</textual></biblioid></bibliomixed><bibliomixed class="po-block e831 e831" xml:id="Ukko95"><textual class="po-textual">Ukkonen, E. ‘On-Line Construction of Suffix Trees’, Algorithmica, 14: 1995, 249-260. </textual><biblioid class="po-atom e832 doi e832"><textual class="po-textual">10.1007/BF01206331</textual></biblioid></bibliomixed><bibliomixed class="po-block e833 e833" xml:id="Vand08"><textual class="po-textual">Van den Branden, R. ‘A Modest Proposal. Analysis of Specific Needs with Reference to Collation in Electronic Editions’, Digital Humanities 2008 University of Oulu, June 24-29 Book of Abstracts, 2008, 206-207.</textual></bibliomixed><bibliomixed class="po-block e834 e834" xml:id="Vett03"><textual class="po-textual">Vetter, L. and McDonald, J. ‘Witnessing Dickinson’s Witnesses’, Literary and Linguistic Computing, 18.2: 2003, 151-165. </textual><biblioid class="po-atom e835 doi e835"><textual class="po-textual">10.1093/llc/18.2.151</textual></biblioid></bibliomixed><bibliomixed class="po-block e836 e836" xml:id="Wagn75"><textual class="po-textual">Wagner, R.A. ‘On the Complexity of the Extended String-to-String Correction Problem’. In: Annual ACM Symposium on Theory of Computing. Proceedings of seventh annual ACM symposium on Theory of computing, A.K. Chandra, A.R. Meyer, W.C. Rounds, R.E. Stearns, R.E. Tarjan, S. Winograd, P.R. Young (eds), 1975, 218-223. </textual><biblioid class="po-atom e837 doi e837"><textual class="po-textual">10.1145/800116.803771</textual></biblioid></bibliomixed><bibliomixed class="po-block e838 e838" xml:id="Witt02"><textual class="po-textual">Witt, A. Multiple Informationsstrukturierung mit Auszeichnungssprachen. XML-basierte Methoden und deren Nutzen für die Sprachtechnologie, PhD Dissertation, Uni. of Bielefeld, 2002. </textual><link class="po-inline e839 e839" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://deposit.ddb.de/cgi-bin/dokserv?idn=963909436</textual></link></bibliomixed></bibliography></article></classedDocument>