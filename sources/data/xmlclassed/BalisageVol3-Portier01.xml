<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Methodology for the construction of multi-structured documents</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2009</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 11 - 14, 2009</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">We present the multi-structured documents problem and offer an overview of existing solutions. We then notice that they do not consider the problem of constructing such documents. In this context, we use our experience with philosophers who are building a digital edition of the work of Jean-Toussaint Desanti, in order to present a methodology for the construction of multi-structured documents. This methodology is based on the MSDM model in order to represent such documents. Moreover each step of the methodology has been implemented in the Haskell functional programming language.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Pierre-Edouard</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Portier</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Pierre-Edouard Portier is a computer science engineer. He has graduated in September 2007 from INSA-Lyon school with a Master degree in computer science. He is continuing his studies at INSA-Lyon as a Ph.D student. He is working in the DRIM team of the LIRIS laboratory under the supervision of Sylvie Calabretto.</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">Université de Lyon, CNRS, INSA-Lyon, LIRIS, UMR5205, F-69621</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">pierre-edouard.portier@insa-lyon.fr</textual></email></author><author class="po-record e17 e17"><personname class="po-record e18 e18"><firstname class="po-field e19 e19"><textual class="po-textual">Sylvie</textual></firstname><surname class="po-field e20 e20"><textual class="po-textual">Calabretto</textual></surname></personname><personblurb class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Sylvie Calabretto : Doctor in Computer Sciences of the « Institut National des Sciences Appliquées de Lyon » in 1993. Presently, Associate professor at the Institut National des Sciences Appliquées de Lyon (INSA-Lyon) and Researcher at the Laboratory of Images and Information Systems Engineering (LIRIS). Co-superviser of nine PhD dissertation. Has published one collective book and about 100 papers on various computing subjects among which Structured Document, Information Retrieval and Digital Libraries.</textual></para></personblurb><affiliation class="po-record e23 e23"><orgname class="po-block e24 e24"><textual class="po-textual">Université de Lyon, CNRS, INSA-Lyon, LIRIS, UMR5205, F-69621</textual></orgname></affiliation><email class="po-field e25 e25"><textual class="po-textual">sylvie.calabretto@insa-lyon.fr</textual></email></author><legalnotice class="po-container e26 e26"><para class="po-block e27 e27"><textual class="po-textual">Copyright © 2009 by the authors.  Used with
      permission.</textual></para></legalnotice><keywordset class="po-table e28 e28" role="author"><keyword class="po-field e29 e29"><textual class="po-textual">Digital libraries</textual></keyword><keyword class="po-field e30 e30"><textual class="po-textual">overlapping hierarchies</textual></keyword><keyword class="po-field e31 e31"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">Haskell</textual></keyword></keywordset></info><section class="po-hcontainer e33 e33"><title class="po-block e34 e34"><textual class="po-textual">Introduction</textual></title><para class="po-block e35 e35"><textual class="po-textual">We introduce a new problem: the construction of multi-structured documents. The multiple uses of a same document have led to a proliferation of documentary structures (physical, logical, semantic, …). The definition of multiple structures for a same document introduced the problem of </textual><emphasis class="po-inline e36 e36" role="ital"><textual class="po-textual">multi-structured documents</textual></emphasis><textual class="po-textual"> [</textual><xref class="po-milestone e37 e37" linkend="Multi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. It has to be analysed in his historical context where the most used formalisms for documents representation (first SGML then XML) implied tree structures. That is why this problem is often known as the </textual><emphasis class="po-inline e38 e38" role="ital"><textual class="po-textual">overlapping hierarchies</textual></emphasis><textual class="po-textual"> problem [</textual><xref class="po-milestone e39 e39" linkend="overlap"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e40 e40"><textual class="po-textual">By studying the construction of multi-structured documents we are close to the daily practices of users who are writing documents.  Our work is based on experience gained working with philosophers who are building a digital edition of the handwritten archives of French philosopher Jean-Toussaint Desanti (1914-2002). Desanti is known for his epistemological work on the development of the mathematical theory of real variables functions. Digital edition covers the whole editorial, scientific and critical process that leads to the publication of an electronic resource.  In the case of manuscripts, it mainly consists in the transcription and critical analysis of digital facsimiles. Exchanging with managers of other similar digital edition projects, we found that the construction of multi-structured documents was at the heart of their work. A multiplicity of structures is needed in order to access a document according to many points of view. As we can see, our work does not only consist in the conception of a model for the representation of multi-structured documents, but must of all in the development of a methodology that promotes the emergence of multiple structures in a multi-users context.</textual></para><para class="po-block e41 e41"><textual class="po-textual">We illustrate our purpose with the </textual><xref class="po-milestone e42 e42" linkend="deuxpages"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that represents a double page from some Desanti's notebook. On this image, the region named ZI represents a meaningful fragment of textual content that spans the two pages. So we face two concurrent hierarchies (that is to say two structures that cannot be represented through a single tree): the pages and the "regions of interest". We can also see equations (E1 and E2) that, even though they do not raise the technical issue of concurrent hierarchies, could belong to a third structure, the one of mathematical expressions. Thus, we not only have to offer a solution to the multiple hierarchies problem but also to conceive a methodology for the creation of multi-structured documents so as to assist the user in his modeling choices.</textual></para><figure class="po-container e43 e43" xml:id="deuxpages" xreflabel="Figure 1"><mediaobject class="po-container e44 e44"><imageobject class="po-container e45 e45"><imagedata class="po-meta e46 e46" fileref="../../../vol3/graphics/Portier01/Portier01-001.jpg" format="jpg" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Two pages from some Desanti's notebook</textual></para></caption></mediaobject></figure><para class="po-block e49 e49"><textual class="po-textual">We propose a description of existing work for the representation of multi-structured documents. Then, we introduce with some details a peculiar model: MultiX². Finally, we use this model to propose a methodology for the construction of multi-structured documents.</textual></para></section><section class="po-hcontainer e50 e50"><title class="po-block e51 e51"><textual class="po-textual">Existing solutions for managing multi-structured documents</textual></title><section class="po-hcontainer e52 e52"><title class="po-block e53 e53"><textual class="po-textual">Approach</textual></title><para class="po-block e54 e54"><textual class="po-textual">We divide into four classes the set of existing solutions for the
representation of multi-structured documents. First, an historical
solution: CONCUR, then ad-hoc solutions as proposed by the TEI (Text
Encoding Initiative) consortium, next models that are not compatible with
the XML language, finally those that are compatible with XML. This XML
criterion, even though strictly technical, is very important since most
communities working on the construction of documents and who could benefit
from the new perspectives we introduce, are already using XML vocabularies
and tools (they will, for example, follow the TEI recommendations).
Finally, each solution is analysed according to six dimensions:
</textual><itemizedlist class="po-table e55 e55"><listitem class="po-container e56 e56"><para class="po-block e57 e57"><emphasis class="po-inline e58 e58" role="ital"><textual class="po-textual">Expressiveness</textual></emphasis><textual class="po-textual"> of the model determines if there is an explicitly
defined model for the static representation of multi-structured documents.</textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><emphasis class="po-inline e61 e61" role="ital"><textual class="po-textual">Genericity</textual></emphasis><textual class="po-textual"> of the model determines, when a model exists, if
it can be modified in order to manage problems outside of the initial scope of
multi-structured documents representation.</textual></para></listitem><listitem class="po-container e62 e62"><para class="po-block e63 e63"><emphasis class="po-inline e64 e64" role="ital"><textual class="po-textual">Quality</textual></emphasis><textual class="po-textual"> of the implementation takes account of the care taken to develop an
effective implementation</textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><emphasis class="po-inline e67 e67" role="ital"><textual class="po-textual">Compatibility</textual></emphasis><textual class="po-textual"> with XML tools determines if it is possible to integrate
the solution with the numerous existing XML tools used to manage XML
documents (especially typing tools such as XML Schemas, ...)</textual></para></listitem><listitem class="po-container e68 e68"><para class="po-block e69 e69"><emphasis class="po-inline e70 e70" role="ital"><textual class="po-textual">Query mechanisms</textual></emphasis><textual class="po-textual"> for multi-structured documents</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><emphasis class="po-inline e73 e73" role="ital"><textual class="po-textual">Change management</textual></emphasis><textual class="po-textual"> in data or structures, determines if the model is
robust to change</textual></para></listitem></itemizedlist></para></section><section class="po-hcontainer e74 e74"><title class="po-block e75 e75"><textual class="po-textual">An historical solution</textual></title><para class="po-block e76 e76"><textual class="po-textual">CONCUR [</textual><xref class="po-milestone e77 e77" linkend="concur"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is an SGML option that allows multiple DTDs for the same
content. In such an SGML document, every structure lives in a same file. In
this file, a first structure is encoded in a standard way. For each
additional structure, a prefix is added to opening tags, in order to
determine which DTD defines this tag.</textual></para><para class="po-block e78 e78"><textual class="po-textual">However, with the CONCUR option, we cannot establish relations
between structures. Moreover, as stated in [</textual><xref class="po-milestone e79 e79" linkend="againstConcur"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], if two
elements from different DTDs describe the same region, tags order is
indeterminable. That is why this solution is rarely implemented, and even
Charles Goldfarb [</textual><xref class="po-milestone e80 e80" linkend="againstConcur"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], the main architect of the SGML
standard, recommends to avoid its use.</textual></para><para class="po-block e81 e81"><textual class="po-textual">The CONCUR option answers most of the problems raised by multi-structured
documents, but cannot establish relations between structures.
However, as an SGML integrated option, it doesn't meet the genericity
criterion. Moreover, there is no query mechanism. It should be noted, that
since there is only one document, changes in structures or data are
possible.</textual></para></section><section class="po-hcontainer e82 e82"><title class="po-block e83 e83"><textual class="po-textual">Ad-hoc solutions</textual></title><para class="po-block e84 e84"><textual class="po-textual">The TEI (Text Encoding Initiative) [</textual><xref class="po-milestone e85 e85" linkend="Tei"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is a consortium developing
and maintaining a standard for the representation of electronic texts.
These recommendations are expressed as an extensible and well documented
XML Schema. Inside the recommendations, for each instance of the
multi-structured document problem, a local solution is proposed. Moreover,
in the last version of the recommendations, an entire chapter is devoted to a synthesis of
the ad-hoc solutions. They are four [</textual><xref class="po-milestone e86 e86" linkend="Rose"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] [</textual><xref class="po-milestone e87 e87" linkend="Multi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]:</textual></para><para class="po-block e88 e88"><textual class="po-textual">It is possible to duplicate the content for each tree structures … Poor
solution that prevents evolutions of the document.</textual></para><para class="po-block e89 e89"><textual class="po-textual">Empty tags can be used (line break, page break, etc.). But
they prohibit us from using standard XML validation tools, or building a
schema that specifies the structure with empty elements.</textual></para><para class="po-block e90 e90"><textual class="po-textual">For two concurrent structures that do not form a tree, we can divide one of
them into elements small enough to avoid overlapping with other
structures. The original structure can be rebuilt through well-chosen
attributes. As for the previous solutions, this one needs specific operations in
order to rebuild the original structures and does not allow us to use XML
typing tools.</textual></para><para class="po-block e91 e91"><textual class="po-textual">Finally, we can isolate the content inside a so called </textual><emphasis class="po-inline e92 e92" role="ital"><textual class="po-textual">base</textual></emphasis><textual class="po-textual"> structure,
and build the documentary structures on top of it. This solution is
probably the most generic.</textual></para></section><section class="po-hcontainer e93 e93"><title class="po-block e94 e94"><textual class="po-textual">XML incompatible models</textual></title><section class="po-hcontainer e95 e95"><title class="po-block e96 e96"><textual class="po-textual">TexMECS</textual></title><para class="po-block e97 e97"><textual class="po-textual">Instead of using existing languages, new syntaxes can be defined. MECS
(Multi-Element Code System) [</textual><xref class="po-milestone e98 e98" linkend="mecs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] was the first language to allow
overlapping of structures. TexMECS [</textual><xref class="po-milestone e99 e99" linkend="texmecs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], based on MECS,
is much more expressive. It allows us to define complex structures where
an element can have multiple parents. The MECS model is expressive enough
to answer the classic problems raised by  multi-structured
documents, but is too complex in order to satisfy the genericity criterion.
Moreover, it does not come with query mechanisms.</textual></para></section><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">LMNL</textual></title><para class="po-block e102 e102"><textual class="po-textual">LMNL (Layered Markup and aNnotation Language) [</textual><xref class="po-milestone e103 e103" linkend="lmnl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] defines a
specific syntax based on a notion of interval that allows the encoding of
multiple structures with overlapping elements. This is only a syntactic
solution that does not propose query mechanisms. As for the previous
solution, since the structures are encoded inside a single document, change in
data or structures is possible. These two solutions are quite complex
and not compatible with the XML tools and remained at an experimental
stage.</textual></para></section><section class="po-hcontainer e104 e104"><title class="po-block e105 e105"><textual class="po-textual">Annotation graphs</textual></title><para class="po-block e106 e106"><textual class="po-textual">Annotation graphs [</textual><xref class="po-milestone e107 e107" linkend="annotationGraphs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] has been developed in order to
model linguistics phenomena (phonetic, prosody, morphology, syntax, ...).
If we consider these domains as distinct structures, then annotation graphs
are a valid solution to the multi-structured documents problem. As shown on
</textual><xref class="po-milestone e108 e108" linkend="graphe_annotations"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the same textual fragment can be annotated
by elements from different structures.</textual></para><figure class="po-container e109 e109" xml:id="graphe_annotations" xreflabel="Figure 2"><mediaobject class="po-container e110 e110"><imageobject class="po-container e111 e111"><imagedata class="po-meta e112 e112" fileref="../../../vol3/graphics/Portier01/Portier01-002.jpg" format="jpg" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e113 e113"><para class="po-block e114 e114"><textual class="po-textual">Annotation Graph</textual></para></caption></mediaobject></figure><para class="po-block e115 e115"><textual class="po-textual">Nodes granularity is the word, or even the character if necessary. Labels on edges
indicate the structure (eg S2:M for the words, S1:L for the lines).
Since structures share the same graph, their update is not a problem.
Moreover, a minimal query language has been developed for this kind of graph
[</textual><xref class="po-milestone e116 e116" linkend="annotationGraphsQuery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The underlying model being a graph, it is
expressive enough to answer the multi-structured documents problem. But, strongly oriented toward linguistic, it lacks genericity.</textual></para></section><section class="po-hcontainer e117 e117"><title class="po-block e118 e118"><textual class="po-textual">RDF graphs</textual></title><para class="po-block e119 e119"><textual class="po-textual">The RDF (Resource Description Framework) graph formalism is able to
represent multi-structured documents [</textual><xref class="po-milestone e120 e120" linkend="Rdf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. This method is similar to
the previous one, but relies on a generic graph model.
Standard query tools for RDF graphs (eg SPARQL) can be used, but complex
queries can be difficult to formulate. Although RDF is serializable in XML,
the use of standard XML tools is problematic because they work on tree
structures. Finally, change management is possible since structures and
data share the same graph.</textual></para></section></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual">XML compatible models</textual></title><section class="po-hcontainer e123 e123"><title class="po-block e124 e124"><textual class="po-textual">MuLaX</textual></title><para class="po-block e125 e125"><textual class="po-textual">MuLaX [</textual><xref class="po-milestone e126 e126" linkend="againstConcur"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is the adaptation of the SGML CONCUR option to
the XML formalism. This is a documentary format that allows to unify XML
documents sharing the same content in a single document. In order to
differentiate annotations levels, the tags are prefixed by a structure
identifier. This solution lacks genericity since a specific editor is
needed in order to interpret the produced documents. As for the CONCUR
option, changes in structures or data are possible since there is one
single document. No query operators has been defined, but the authors
explain that it should be possible to build path expressions similar to
those found in XPath.</textual></para></section><section class="po-hcontainer e127 e127"><title class="po-block e128 e128"><textual class="po-textual">GODDAG</textual></title><para class="po-block e129 e129"><textual class="po-textual">[</textual><xref class="po-milestone e130 e130" linkend="GODDAG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] presents a solution based on the GODDAGs (General Order
Descendant Directed Acyclic Graph) to represent multi-structured
documents. This graph model is a solution to the overlapping hierarchies
problem. In order to query those documents, the author developed an XPath
extension. This extension takes into account new kinds of relations between
elements of distinct structures. This model cannot manage generic relations
between structures. It is possible to import (or export) from (or to) the
XML formalism. With this model it is possible to manage change in
structures.</textual></para></section><section class="po-hcontainer e131 e131"><title class="po-block e132 e132"><textual class="po-textual">MCT</textual></title><para class="po-block e133 e133"><textual class="po-textual">The MCT (Multi-Colored Trees) model [</textual><xref class="po-milestone e134 e134" linkend="mct"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is an extension of the XML
model that allows us to represent multiple trees sharing the same
content. It relies on the tree coloring technique. A color is associated with
each tree. A node may have multiple colors: the color of the main tree to which
it belongs and colors for other trees. </textual><xref class="po-milestone e135 e135" linkend="mctimg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> illustrates this model with an example of manuscript transcription. We see that three of the units nodes share two colors: one for the semantic structure and another one for the physical structure.</textual></para><figure class="po-container e136 e136" xml:id="mctimg" xreflabel="Figure 3"><mediaobject class="po-container e137 e137"><imageobject class="po-container e138 e138"><imagedata class="po-meta e139 e139" fileref="../../../vol3/graphics/Portier01/Portier01-003.png" format="png" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e140 e140"><para class="po-block e141 e141"><textual class="po-textual">Colored Trees</textual></para></caption></mediaobject></figure><para class="po-block e142 e142"><textual class="po-textual">The navigation in the multihierarchy is possible by means of the
multicolored nodes. To navigate between colors, the authors extend the
notion of step in XPath. An extension of
XQuery is also proposed for the creation of nodes.
Concerning updates, the authors explain that the extension of a
language such as XUpdate is possible by using the XPath extension that they propose. The
underlying model is neither expressive nor generic enough since it imposes
an isomorphism of data segments (data segments must be of the same type:
word, character, etc.).</textual></para></section><section class="po-hcontainer e143 e143"><title class="po-block e144 e144"><textual class="po-textual">MSXD</textual></title><para class="po-block e145 e145"><textual class="po-textual">MSXD (Multi-Structured XML Documents) [</textual><xref class="po-milestone e146 e146" linkend="MSXD"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is a representation model
for multi-structured documents that comes along with an XQuery extension. It allows
users to annotate the structures. Moreover a draft of a multi-structured
documents schema is introduced. However the need to define a large number
of relations between structures makes the model difficult to use.
Furthermore, it is not possible to manage changes in data or structures.</textual></para></section><section class="po-hcontainer e147 e147"><title class="po-block e148 e148"><textual class="po-textual">Delay Nodes</textual></title><para class="po-block e149 e149"><textual class="po-textual">Jacques LeMaître [</textual><xref class="po-milestone e150 e150" linkend="delay"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] proposed to add a new type of node to the
XDM model on which are based XPath and XQuery. Those nodes are a virtual
representation as an XQuery query of some of the child nodes of their
parent node (see </textual><xref class="po-milestone e151 e151" linkend="delayimg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The underlying multi-structured documents model is very similar to the one
of Multi Colored Trees (see </textual><xref class="po-milestone e152 e152" linkend="delaymodel"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) where documents
are considered as a set of XML trees. But no
XPath or XQuery extensions are necessary in order to navigate inside these
structures. However, with this approach, it is not possible to reach the
parents of a delay node but only to navigate among the descendants.</textual></para><figure class="po-container e153 e153" xml:id="delayimg" xreflabel="Figure 4"><mediaobject class="po-container e154 e154"><imageobject class="po-container e155 e155"><imagedata class="po-meta e156 e156" fileref="../../../vol3/graphics/Portier01/Portier01-004.png" format="png" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e157 e157"><para class="po-block e158 e158"><textual class="po-textual">Delay nodes</textual></para></caption></mediaobject></figure><figure class="po-container e159 e159" xml:id="delaymodel" xreflabel="Figure 5"><mediaobject class="po-container e160 e160"><imageobject class="po-container e161 e161"><imagedata class="po-meta e162 e162" fileref="../../../vol3/graphics/Portier01/Portier01-005.png" format="png" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e163 e163"><para class="po-block e164 e164"><textual class="po-textual">Delay nodes underlying MSD model</textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e165 e165"><title class="po-block e166 e166"><textual class="po-textual">MonetDB/XQuery</textual></title><para class="po-block e167 e167"><textual class="po-textual">MonetDB/Xquery is a XML SGBD. It has an extension [</textual><xref class="po-milestone e168 e168" linkend="Monet"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] for managing
multi-structured documents thanks to the </textual><emphasis class="po-inline e169 e169" role="ital"><textual class="po-textual">stand-off markup</textual></emphasis><textual class="po-textual"> technique.
Optimized query operators has been developed, but no model is truly
defined, only an informal description is proposed (as for the TEI
solutions).</textual></para></section><section class="po-hcontainer e170 e170"><title class="po-block e171 e171"><textual class="po-textual">MSDM, MultiX</textual></title><para class="po-block e172 e172"><textual class="po-textual">MSDM [</textual><xref class="po-milestone e173 e173" linkend="Multix"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is a model used for the representation of
multi-structured documents written by N.Chatti. An instance of this model,
called MultiX, is expressed in the XML formalism. It belongs to the category of
</textual><emphasis class="po-inline e174 e174" role="ital"><textual class="po-textual">stand-off markup</textual></emphasis><textual class="po-textual"> solutions where content is isolated
in a base structure, and documentary structures are built by references
to the base structure.</textual></para><para class="po-block e175 e175"><textual class="po-textual">In this model, a document is a graph </textual><code class="po-atom e176 e176"><textual class="po-textual">D</textual></code><textual class="po-textual"> composed of:
</textual><itemizedlist class="po-table e177 e177"><listitem class="po-container e178 e178"><para class="po-block e179 e179"><textual class="po-textual">a set of nodes </textual><code class="po-atom e180 e180"><textual class="po-textual">BS</textual></code><textual class="po-textual"> also called the base structure</textual></para></listitem><listitem class="po-container e181 e181"><para class="po-block e182 e182"><textual class="po-textual">a family </textual><code class="po-atom e183 e183"><textual class="po-textual">(DS</textual><subscript class="po-atom e184 e184"><textual class="po-textual">j</textual></subscript><textual class="po-textual">) </textual><subscript class="po-atom e185 e185"><textual class="po-textual">j ∈ J</textual></subscript></code><textual class="po-textual"> of trees also called </textual><emphasis class="po-inline e186 e186" role="ital"><textual class="po-textual">documentary structures</textual></emphasis></para></listitem></itemizedlist></para><para class="po-block e187 e187"><textual class="po-textual">Moreover, </textual><code class="po-atom e188 e188"><textual class="po-textual">∀ j ∈ J</textual></code><textual class="po-textual">, there is a relationship </textual><code class="po-atom e189 e189"><textual class="po-textual">R</textual><subscript class="po-atom e190 e190"><textual class="po-textual">j</textual></subscript></code><textual class="po-textual"> that associates
each node of </textual><code class="po-atom e191 e191"><textual class="po-textual">DS</textual><subscript class="po-atom e192 e192"><textual class="po-textual">j</textual></subscript></code><textual class="po-textual"> with a subset of </textual><code class="po-atom e193 e193"><textual class="po-textual">BS</textual></code><textual class="po-textual"> ; for each leaf of </textual><code class="po-atom e194 e194"><textual class="po-textual">DS</textual><subscript class="po-atom e195 e195"><textual class="po-textual">j</textual></subscript></code><textual class="po-textual">
this subset must be non empty. </textual><xref class="po-milestone e196 e196" linkend="modele"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> illustrates each element
of the model.</textual></para><figure class="po-container e197 e197" xml:id="modele" xreflabel="Figure 6"><mediaobject class="po-container e198 e198"><imageobject class="po-container e199 e199"><imagedata class="po-meta e200 e200" fileref="../../../vol3/graphics/Portier01/Portier01-006.png" format="png" width="70%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">Illustration of the MSDM model</textual></para></caption></mediaobject></figure><para class="po-block e203 e203"><textual class="po-textual">Finally, it should be noted that only nodes from the base structure have an
associated content and depend on the data types (text, movies, etc.). In
the case of textual data, a string of characters, called fragment,
is associated with each node of the base structure.</textual></para></section></section><section class="po-hcontainer e204 e204"><title class="po-block e205 e205"><textual class="po-textual">Summary</textual></title><para class="po-block e206 e206"><xref class="po-milestone e207 e207" linkend="tableau"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> summarises the analysis by affecting, as objectively as
possible, a score from 0 to
3 to each criterion (model expressivity, quality of implementation, use of
standard XML tools, query mechanisms, management of changes in data and
structures) and for each solution. For readability, maximum scores have
been underlined.</textual></para><figure class="po-container e208 e208" xml:id="tableau" xreflabel="Figure 7"><mediaobject class="po-container e209 e209"><imageobject class="po-container e210 e210"><imagedata class="po-meta e211 e211" fileref="../../../vol3/graphics/Portier01/Portier01-007.jpg" format="jpg" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e212 e212"><para class="po-block e213 e213"><textual class="po-textual">Rating of existing solutions to the multi-structured documents problem</textual></para></caption></mediaobject></figure><para class="po-block e214 e214"><textual class="po-textual">We now introduce a new instance of MSDM, called MultiX² that
will allow us to represent multi-structured documents.</textual></para></section></section><section class="po-hcontainer e215 e215"><title class="po-block e216 e216"><textual class="po-textual">MultiX², a model for the representation of multi-structured documents</textual></title><para class="po-block e217 e217"><textual class="po-textual">MultiX² is an instance of MSDM that favors the W3C recommendations (we
make use of the XInclude Standard for linking documentary structures and
the base structure) to the specific mechanisms used by MultiX. We chose MSDM as the representation model on which we built our methodology since, based on the stand-off markup technique, it was simple enough and yet well defined (moreover, it is referenced by the
fifth edition of the TEI guidelines).</textual></para><para class="po-block e218 e218"><textual class="po-textual">We illustrate this instance of the MSDM model on an example taken from the Jean-Toussaint Desanti's
Archive (see </textual><xref class="po-milestone e219 e219" linkend="deuxpages"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). We see two pages from a notebook with
a region of text that overlaps the two pages. Moreover it should be
noted that mathematical equations appear inside this philosophical text. We distinguish two structures. First, the physical structure of pages:
</textual><programlisting class="po-block e220 e220" xml:space="preserve"><textual class="po-textual">
  &lt;s1&gt;
    &lt;page&gt;Autrement dit la distinction signe-signifie ...
      Remarque,
    &lt;/page&gt;
    &lt;page&gt;ce discours, ...
      par ex le discours 3 + 2 = 0 - 1 est-il un texte ? ...
    &lt;/page&gt;
  &lt;/s1&gt;</textual></programlisting><textual class="po-textual">
Then, a logical structure of regions of interest:
</textual><programlisting class="po-block e221 e221" xml:space="preserve"><textual class="po-textual">
  &lt;s2&gt;
    &lt;p&gt;Autrement dit la distinction signe-signifie ...&lt;/p&gt;
    &lt;p&gt;Remarque, ce discours, ...&lt;/p&gt;
    &lt;p&gt;par ex le discours
      &lt;eq&gt;3 + 2 = 0 - 1&lt;/eq&gt; est-il un texte ? ...&lt;/p&gt;
  &lt;/s2&gt;</textual></programlisting><textual class="po-textual">
We build the base structure by identifying the shared fragments from the
two documentary structures:
</textual><programlisting class="po-block e222 e222" xml:space="preserve"><textual class="po-textual">
  &lt;seg xml:id="F1"&gt;Autrement dit la distinction signe-signifie ...
  &lt;/seg&gt;
  &lt;seg xml:id="F2"&gt;Remarque, &lt;/seg&gt;
  &lt;seg xml:id="F3"&gt;ce discours, ...&lt;/seg&gt;
  &lt;seg xml:id="F4"&gt;par ex le discours &lt;/seg&gt;
  &lt;seg xml:id="F5"&gt;3 + 2 = 0 - 1&lt;/seg&gt;
  &lt;seg xml:id="F6"&gt; est-il un texte ? ...&lt;/seg&gt;
</textual></programlisting><textual class="po-textual">
We use the XInclude standard in order to replace the content inside
documentary structures by references to the base structure. First, the
physical structure:
</textual><programlisting class="po-block e223 e223" xml:space="preserve"><textual class="po-textual">
  &lt;s1&gt;
  &lt;page&gt;
    &lt;xi:include href="base.xml" xpointer="element(F1/1)"/&gt;
    &lt;xi:include href="base.xml" xpointer="element(F2/1)"/&gt;
  &lt;/page&gt;
  &lt;page&gt;
    &lt;xi:include href="base.xml" xpointer="element(F3/1)"/&gt;
    &lt;xi:include href="base.xml" xpointer="element(F4/1)"/&gt;
    &lt;xi:include href="base.xml" xpointer="element(F5/1)"/&gt;
    &lt;xi:include href="base.xml" xpointer="element(F6/1)"/&gt;
  &lt;/page&gt;
  &lt;/s1&gt;
</textual></programlisting><textual class="po-textual">
Then the logical structure:
</textual><programlisting class="po-block e224 e224" xml:space="preserve"><textual class="po-textual">
  &lt;s2&gt;
  &lt;p&gt;
    &lt;xi:include href="base.xml" xpointer="element(F1/1)"/&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;xi:include href="base.xml" xpointer="element(F2/1)"/&gt;
    &lt;xi:include href="base.xml" xpointer="element(F3/1)"/&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;xi:include href="base.xml" xpointer="element(F4/1)"/&gt;
    &lt;eq&gt;
      &lt;xi:include href="base.xml" xpointer="element(F5/1)"/&gt;
    &lt;/eq&gt;
    &lt;xi:include href="base.xml" xpointer="element(F6/1)"/&gt;
  &lt;/p&gt;
  &lt;/s2&gt;
</textual></programlisting></para><para class="po-block e225 e225"><textual class="po-textual">We can use standard XML tools in order to validate the documentary
structures. We build queries thanks to specific XQuery functions originally
built for the MultiX formalism. Below, a query that finds regions of
interest overlapping on two pages:
</textual><programlisting class="po-block e226 e226" xml:space="preserve"><textual class="po-textual">
  let $physique := doc("physique.xml")
  let $logique := doc("logique.xml")
  for $page in $physique//page,
      $para in $logique//p
  where multix:share-fragments($page,$para) and
        not(multix:include-content-of($page,$para))
  return $para
</textual></programlisting><textual class="po-textual">
And the result will be:
</textual><programlisting class="po-block e227 e227" xml:space="preserve"><textual class="po-textual">
  &lt;p&gt;Remarque, ce discours, ...&lt;/p&gt;
</textual></programlisting><textual class="po-textual">
The share-fragments(a,b) function checks if elements a and b have at least
one fragment in common. The include-content(a,b) function checks if every
fragment composing element b also compose element a.</textual></para></section><section class="po-hcontainer e228 e228"><title class="po-block e229 e229"><textual class="po-textual">A methodology for the construction of multi-structured documents</textual></title><para class="po-block e230 e230"><textual class="po-textual">We will use the MSDM model in order to introduce the construction of
multi-structured documents. We claim that the study of the construction of documentary structures is a way to approach the user interpretation of a document. For example, numerous critical edition
projects begin with manuscripts images they then transcribe and annotate.
During these operations, the documents will be manipulated by numerous users
and under a multiplicity of perspectives that mostly depend on how the
documents are used. However, within the limits of today systems dedicated to the
creation of documents, most of these diversified perspectives will remain
inaccessible, buried in users minds. We claim that, in the
context of the creation and annotation of documents, most of these hidden
perspectives can be revealed by the differentiation of structures. This
differentiation is an operation that splits an annotation vocabulary into
sub-vocabularies, thus adding a new structure to the document. Thereby, the
methodology we now present promotes the construction of a multiplicity of
structures that should reflect the perspectives adopted by the users while
accessing the documents. This methodology consists of three categories of
methods:
</textual><itemizedlist class="po-table e231 e231"><listitem class="po-container e232 e232"><para class="po-block e233 e233"><textual class="po-textual">detection of needed restructuring and automatic
differentiation of structures. As we will see, the overlapping hierarchies
problem becomes an element of this category of methods.</textual></para></listitem><listitem class="po-container e234 e234"><para class="po-block e235 e235"><textual class="po-textual">execution of the dynamical interpretant of the confrontation of
a user with the results of automatic restructuring. </textual><emphasis class="po-inline e236 e236" role="ital"><textual class="po-textual">Dynamical
interpretant</textual></emphasis><textual class="po-textual"> is a term belonging to C.S. Peirce's terminology that will be
explained in a next section.</textual></para></listitem><listitem class="po-container e237 e237"><para class="po-block e238 e238"><textual class="po-textual">creation of a social network of documents authors
in order to encourage argument about and sharing of annotation vocabularies</textual></para></listitem></itemizedlist></para><section class="po-hcontainer e239 e239"><title class="po-block e240 e240"><textual class="po-textual">Restructuring stage</textual></title><para class="po-block e241 e241"><textual class="po-textual">We analyse the conditions under which it is necessary to build a new
documentary structure and we define the underlying functions performing
this task.</textual></para><section class="po-hcontainer e242 e242"><title class="po-block e243 e243"><textual class="po-textual">Illustration</textual></title><para class="po-block e244 e244"><textual class="po-textual">For clarity, and since we know the field, we use an example taken from
critical electronic edition of manuscripts. We suppose that for the
transcription of a manuscript the researchers have on hand the elements defined by the TEI.  From the previous
example: pages, region of interest and equations have been correctly tagged  until a region overlaps two pages
(see dotted edges of </textual><xref class="po-milestone e245 e245" linkend="restructuration_necessaire"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><figure class="po-container e246 e246" xml:id="restructuration_necessaire" xreflabel="Figure 8"><mediaobject class="po-container e247 e247"><imageobject class="po-container e248 e248"><imagedata class="po-meta e249 e249" fileref="../../../vol3/graphics/Portier01/Portier01-008.png" format="png" width="70%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e250 e250"><para class="po-block e251 e251"><textual class="po-textual">Restructuring is necessary (a paragraph overlaps two pages)</textual></para></caption></mediaobject></figure><para class="po-block e252 e252"><textual class="po-textual">It is then necessary to distinguish two
structures. The creation of a new structure is a purely formal operation
(see </textual><xref class="po-milestone e253 e253" linkend="restructuration_automatique"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) consisting in the
transformation of a graph into two trees.</textual></para><figure class="po-container e254 e254" xml:id="restructuration_automatique" xreflabel="Figure 9"><mediaobject class="po-container e255 e255"><imageobject class="po-container e256 e256"><imagedata class="po-meta e257 e257" fileref="../../../vol3/graphics/Portier01/Portier01-009.png" format="png" width="70%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e258 e258"><para class="po-block e259 e259"><textual class="po-textual">Automatic restructuring (two structures are distinguished)</textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e260 e260"><title class="po-block e261 e261"><textual class="po-textual">Functions for restructuring</textual></title><para class="po-block e262 e262"><textual class="po-textual">We now describe the functions that perform these restructuring operations.
We are using the Haskell pure and statically typed functional programming language [</textual><xref class="po-milestone e263 e263" linkend="Haskell"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. As a pure language, Haskell keeps side effects under the control of a class of type constructor called Monad, in practice this allows us to ensure that a valid document will always be transformed into a valid document. Since our methodology introduces numerous document transformations, this property is very interesting. All the
necessary notions for the understanding of the code will be provided. But not all functions definitions will be given.
Moreover the main purpose of showing these functions is to give a proof of the
feasibility of our methodology.</textual></para><para class="po-block e264 e264"><textual class="po-textual">We need two helper functions, </textual><code class="po-atom e265 e265"><textual class="po-textual">if'</textual></code><textual class="po-textual"> for boolean conditions and </textual><code class="po-atom e266 e266"><textual class="po-textual">add</textual></code><textual class="po-textual"> for
the addition of a new element at the end of a </textual><code class="po-atom e267 e267"><textual class="po-textual">Map</textual></code><textual class="po-textual">. A </textual><code class="po-atom e268 e268"><textual class="po-textual">Map a b</textual></code><textual class="po-textual"> is a
structure of elements of type </textual><code class="po-atom e269 e269"><textual class="po-textual">b</textual></code><textual class="po-textual"> indexed by element of type </textual><code class="po-atom e270 e270"><textual class="po-textual">a</textual></code><textual class="po-textual">.
From the signature of </textual><code class="po-atom e271 e271"><textual class="po-textual">if'</textual></code><textual class="po-textual"> we learn that the function takes
three arguments, the first argument being a Boolean value. </textual><code class="po-atom e272 e272"><textual class="po-textual">if'
True</textual></code><textual class="po-textual"> is a two arguments function that evaluates its first argument (the second argument will never be evaluated), while </textual><code class="po-atom e273 e273"><textual class="po-textual">if' False</textual></code><textual class="po-textual"> is a two arguments function that evaluates its second argument (the first argument will never be evaluated).
</textual><programlisting class="po-block e274 e274" xml:space="preserve"><textual class="po-textual">
-- This is a comment
-- A function is described by its type signature: the list of the types of its
-- arguments and of thereturned value separated by the symbol: '-&gt;'.
-- For example, the addIntegers function would have the signature:
addIntegers :: Int -&gt; Int -&gt; Int
-- and the definition:
addIntegers a b = a + b
-- Moreover, functions are curried, so (addInteger 2) is a function of type:
(addInteger 2) :: Int -&gt; Int
-- Finally, we will:
--   * use some primitive types :
--       - Bool (with the only two constructors True and False)
--       - Int
--   * use the list constructor:
--     [Int] is the type of a list of values of type Int
--   * define data types:
data Interval = Interval {
  start :: Int
  ,end  :: Int
}
-- now Interval is a function (also called a constructor) of type:
Interval :: Int -&gt; Int -&gt; Interval
-- start is a function of type:
start :: Interval -&gt; Int
-- end is a function of type:
end :: Interval -&gt; Int

--   * define shortcuts for existing types:
type Tags = [Tags]
-- Tags is now a synonym for [Tags] (list of Tags)

if' :: Bool -&gt; a -&gt; a -&gt; a
if' True x _ = x
if' False _ y = y

add :: a -&gt; Map Int a -&gt; Map Int a
</textual></programlisting></para><para class="po-block e275 e275"><textual class="po-textual">We first define our main data types. A Tag is composed of an identifier
and a list of attributes. We also have a data structure associating
each tag identifier with a name and a list of default attributes. A
Taggee is the application of a Tag to an interval of characters of the
studied text. A Structure is a named map of taggees. A Document is the
association of a text and a map of structures.
</textual><programlisting class="po-block e276 e276" xml:space="preserve"><textual class="po-textual">
data Interval = Interval {
  start :: Int
  ,end :: Int
}

data Taggee = Taggee {
  tag :: Tag
  ,interval :: Interval
}

data Structure = Structure {
  name :: String
  ,taggees :: Map Int Taggee
}

type TagId = Int

data Tag = Tag {
  tagId :: TagId
  ,atts :: Map Int String
}

type Tags = [Tag]

type Text = String

data Doc = Doc {
  text :: Text
  ,structures :: Map Int Structure
}
</textual></programlisting></para><para class="po-block e277 e277"><textual class="po-textual">We also need functions for simple interval algebra.
</textual><programlisting class="po-block e278 e278" xml:space="preserve"><textual class="po-textual">
overlaps   :: Interval -&gt; Interval -&gt; Bool
isIncluded :: Interval -&gt; Interval -&gt; Bool
includes i1 i2 = isIncluded i2 i1
inside     :: Int -&gt; Interval -&gt; Bool
ilength    :: Interval -&gt; Int
isort :: Interval -&gt; Interval -&gt; (Interval,Interval)

-- The exclusive OR of interval overlapping :
overlapExclusion :: Interval -&gt; Interval -&gt; (Interval,Interval)

-- less than:
ilt i1 i2 = (end i1) &lt; (start i2)
-- greater than :
igt i1 i2 = (start i1) &gt; (end i2)

-- shifting an interval:
ioffset :: Interval -&gt; Int -&gt; Interval
startBefore :: Interval -&gt; Interval -&gt; Bool
equals :: Interval -&gt; Interval -&gt; Bool
isPrefixOf :: Interval -&gt; Interval -&gt; Bool
isSuffixOf :: Interval -&gt; Interval -&gt; Bool
</textual></programlisting><textual class="po-textual">
The </textual><code class="po-atom e279 e279"><textual class="po-textual">addTag</textual></code><textual class="po-textual"> function tries to add a tag to a structure, if the addition
does not imply overlapping then the modified structure is returned, else a
pair of structures is returned: the first structure is the original one
except that every instances of the added tag have been
transfered to the second structure. In a similar way, the $delTag$ function
removes the instance of a given tag from a selected interval and may imply
overlapping thus the type signature.
</textual><programlisting class="po-block e280 e280" xml:space="preserve"><textual class="po-textual">
-- partition the map according to a predicate:
partition :: Ord k =&gt; (a -&gt; Bool ) -&gt; Map k a -&gt; (Map k a, Map k a)
elems     :: Map k a -&gt; [a]

-- function application:
$ :: (a -&gt; b) -&gt; a -&gt; b
-- function composition:
. :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c

-- map f xs is the list obtained by applying f to each element of xs:
-- map f [x1,x2,...,xn] == [f x1, f x2, ..., f xn]
map   :: (a -&gt; b) -&gt; [a] -&gt; [b]
-- foldl, applied to a binary operator, a starting value, and a list, reduces
-- the list using the binary operator, from left to right:
-- foldl f z [x1,x2,...,xn] == f (f (f (f z x1) x2) ...) xn
foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a

-- The Either type represents values with two
-- possibilities: a value of type Either a b is
-- either Left a or Right b

addTag :: Taggee -&gt; Structure -&gt; Either (Structure,Structure) Structure
addTag t (Structure n s) =
let (s1,s2) = partition ( ( (tagId $ tag t)== ) . tagId . tag ) s in
if' ( foldl (||) False $ map (overlaps (interval t) . interval) $ elems s )
    ( Left  ( Structure n $ add t s1, Structure n s2 ) )
    ( Right ( Structure n $ add t s ) )

delTag :: Interval -&gt; TagId -&gt; Structure -&gt; Either (Structure,Structure) Structure
</textual></programlisting></para><para class="po-block e281 e281"><textual class="po-textual">Finally, the user must be able to add or remove textual data. This is the
purpose of the </textual><code class="po-atom e282 e282"><textual class="po-textual">addText</textual></code><textual class="po-textual"> and </textual><code class="po-atom e283 e283"><textual class="po-textual">delText</textual></code><textual class="po-textual"> functions.
</textual><programlisting class="po-block e284 e284" xml:space="preserve"><textual class="po-textual">
-- split a list in two:
splitAt :: Int -&gt; [a] -&gt; ([a], [a])

fst  	  :: (a, b) -&gt; a
snd  	  :: (a, b) -&gt; b

addText :: Int -&gt; String -&gt; Doc -&gt; Doc
addText i s d =
 let t    = text d
    split = splitAt (i-1) t
    t'    = fst split ++ s ++ snd split
    sts   = structures d
    sts'  = map ( addCharInS i (length s) ) sts
    in Doc t' sts'

addCharInS :: Int -&gt; Int -&gt; Structure -&gt; Structure
addCharInS i size (Structure n s) =
 Structure n $ map ( \t -&gt;
  if' ( i `inside` (interval t) )
      t{interval = Interval (start $ interval t) $
                            (end $ interval t) + size}
      t ) s

delText :: Int -&gt; Int -&gt; Doc -&gt; Doc
</textual></programlisting></para></section></section><section class="po-hcontainer e285 e285"><title class="po-block e286 e286"><textual class="po-textual">Integration of the user in the restructuring process</textual></title><section class="po-hcontainer e287 e287"><title class="po-block e288 e288"><textual class="po-textual">Illustration</textual></title><para class="po-block e289 e289"><textual class="po-textual">The automatic restructuring introduced above can be the occasion for a
user to make modeling choices. For example, he can ask for the
creation of a new mathematical structure for the equations and rename the
structures (see </textual><xref class="po-milestone e290 e290" linkend="restructuration_interpretant"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><figure class="po-container e291 e291" xml:id="restructuration_interpretant" xreflabel="Figure 10"><mediaobject class="po-container e292 e292"><imageobject class="po-container e293 e293"><imagedata class="po-meta e294 e294" fileref="../../../vol3/graphics/Portier01/Portier01-010.png" format="png" width="70%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e295 e295"><para class="po-block e296 e296"><textual class="po-textual">Intervention of a user (Three structures are named and distinguished)</textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e297 e297"><title class="po-block e298 e298"><textual class="po-textual">Functions for user integration</textual></title><para class="po-block e299 e299"><code class="po-atom e300 e300"><textual class="po-textual">moveTag</textual></code><textual class="po-textual"> is the main function offered to the user for reacting to the automatic
restructuring, it allows him to move all the instances of a tag from one
structure to another. The function may fail if it introduces
overlapping hierarchies.
</textual><programlisting class="po-block e301 e301" xml:space="preserve"><textual class="po-textual">
-- case analysis for the Either type
either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c

-- the constant function
const :: a -&gt; b -&gt; a

-- foldr, applied to a binary operator, a starting value, and a list, reduces
-- the list using the binary operator, from right to left:
-- foldr f z [x1,x2,...,xn] == f x1 (f x2 (... (f xn z)))
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b

moveTag :: TagId -&gt; Structure -&gt; Structure -&gt; Maybe (Structure, Structure)

moveTag id s1 s2 =
 let (ts',ts'') = partition ( (==id) . tagId . tag ) ( taggees s1 )
     f :: Taggee -&gt; Either (Structure, Structure) Structure -&gt;
          Either (Structure, Structure) Structure
     f t ( Right s )       = addTag t s
     f t ( Left (s1, s2) ) = Left (s1, s2) in

 if' ( null ts' || null ts'' ) Nothing $
 either ( const Nothing )
        ( Just . (,) ( Structure (name s1) ts' ) ) $
        foldr f (Right s2) $ elems ts''
</textual></programlisting><textual class="po-textual">
</textual></para></section></section><section class="po-hcontainer e302 e302"><title class="po-block e303 e303"><textual class="po-textual">Recommendation system for documents authors</textual></title><para class="po-block e304 e304"><textual class="po-textual">We now try to involve even more the author of a document in the process of
maintaining a coherent multiplicity of structures. This is why we promote the
emergence of a social network of documents authors. The recommendation
mechanism that allows us to build this network define two users
as closed, insofar as they are editing specific documents, if the implied
tags trees of their structures are similar. We first give an example of
this process and then define the structures and functions used to implement
it.</textual></para><section class="po-hcontainer e305 e305"><title class="po-block e306 e306"><textual class="po-textual">Illustration</textual></title><para class="po-block e307 e307"><textual class="po-textual">We imagine three users who create documents containing
mathematical notations. For each of them, a mathematical structure emerged
from their operations of annotation (as described in the previous sections).
Users 1 and 2 have already decided to merge their tag hierarchies. The tag
hierarchies are given below:
</textual><informaltable class="po-container e308 e308"><col align="center" class="po-meta e309 e309" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e310 e310" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e311 e311"><tr class="po-table e312 e312"><th class="po-field e313 e313"><textual class="po-textual">Users 1 and 2</textual></th><th class="po-field e314 e314"><textual class="po-textual">User 3</textual></th></tr></thead><tr class="po-table e315 e315"><td class="po-block e316 e316"><textual class="po-textual">
  </textual><itemizedlist class="po-table e317 e317"><listitem class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">theorem</textual></para><itemizedlist class="po-table e320 e320"><listitem class="po-container e321 e321"><para class="po-block e322 e322"><textual class="po-textual">statement</textual></para></listitem><listitem class="po-container e323 e323"><para class="po-block e324 e324"><textual class="po-textual">proof</textual></para></listitem></itemizedlist></listitem><listitem class="po-container e325 e325"><para class="po-block e326 e326"><textual class="po-textual">lemma</textual></para><itemizedlist class="po-table e327 e327"><listitem class="po-container e328 e328"><para class="po-block e329 e329"><textual class="po-textual">statement</textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">proof</textual></para></listitem></itemizedlist></listitem><listitem class="po-container e332 e332"><para class="po-block e333 e333"><textual class="po-textual">cocycle</textual></para></listitem><listitem class="po-container e334 e334"><para class="po-block e335 e335"><textual class="po-textual">cobordism</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></td><td class="po-block e336 e336"><textual class="po-textual">
  </textual><itemizedlist class="po-table e337 e337"><listitem class="po-container e338 e338"><para class="po-block e339 e339"><textual class="po-textual">proposition</textual></para><itemizedlist class="po-table e340 e340"><listitem class="po-container e341 e341"><para class="po-block e342 e342"><textual class="po-textual">proof</textual></para></listitem><listitem class="po-container e343 e343"><para class="po-block e344 e344"><textual class="po-textual">operators</textual></para></listitem></itemizedlist></listitem><listitem class="po-container e345 e345"><para class="po-block e346 e346"><textual class="po-textual">cohomology</textual></para><itemizedlist class="po-table e347 e347"><listitem class="po-container e348 e348"><para class="po-block e349 e349"><textual class="po-textual">cocycle</textual></para></listitem></itemizedlist></listitem></itemizedlist><textual class="po-textual">
</textual></td></tr></informaltable><textual class="po-textual">
If these two hierarchies were detected as similar enough, each user would
be proposed to ask the other users the authorization to merge their
hierarchies. Thus, communities of users appear, centered on their
annotation practices. In this previous example, users seem to
work on the same kind of documents, but the perspective of user 3 may be formal logic
whereas users 1 and 2 refer to a more traditional vocabulary for the
description of proofs. Since the tips the
users receive while annotating a document come from the hierarchy of tags
associated with the current structure, once the merge is accepted, the users may align their
annotation vocabularies or at least question their practices.</textual></para></section><section class="po-hcontainer e350 e350"><title class="po-block e351 e351"><textual class="po-textual">Functions for promoting users interactions</textual></title><para class="po-block e352 e352"><textual class="po-textual">We define a new data type (TagStruct) in order to link each tag used for
the annotation of a document with its possible descendants. Thus, while a user is
annotating a document we can give him hints about the
next tag to choose, based on this new structure and its current position in the text. We also
update the Structure data type to link to the corresponding
implied tag structure. For this linking to be possible, we maintain a map
(of type TagStructs) of the implied tag structures.
</textual><programlisting class="po-block e353 e353" xml:space="preserve"><textual class="po-textual">
type TagStruct = Map TagId [TagId]
type TagStructId = Int
type TagStructs = Map TagStructId TagStruct

data Structure = Structure {
  name :: String
  ,taggees :: Map Int Taggee
  ,tagStructId :: TagStructId
} deriving (Show)
</textual></programlisting><textual class="po-textual">
We have to modify the addTag function in order to update the linked structures of
tags:
</textual><programlisting class="po-block e354 e354" xml:space="preserve"><textual class="po-textual">
addTag :: Taggee -&gt; Structure -&gt; TagStructs -&gt; Either (Structure,Structure, TagStructs) (Structure, TagStructs)
addTag t (Structure n s tagStructId) tagStructs =
  let tId = tagId $ tag t
      (s1,s2) = partition ( (tId==) . tagId . tag ) s
      s' = Structure n (add t s) tagStructId
      (tagStructIdS2, newTagStructs) = addTagStruct tagStructs in
  if' (
        foldl (||) False $
        map (overlaps (interval t) . interval) $
        elems s
      )
      (
        Left ( Structure n (add t s1) tagStructId,
               Structure "" s2 tagStructIdS2,
               delTagFromTagStruct tId tagStructId newTagStructs )
      ) $
      Right ( s', addTagToTagStruct tId (parentId t s') tagStructId tagStructs )

addTagStruct :: TagStructs -&gt; (TagStructId, TagStructs)

delTagFromTagStruct :: TagId -&gt; TagStructId -&gt; TagStructs -&gt; TagStructs

addTagToTagStruct :: TagId -&gt; Maybe TagId -&gt; TagStructId -&gt; TagStructs -&gt; TagStructs

parentId :: Taggee -&gt; Structure -&gt; Maybe TagId
parentId t s = maybe Nothing (Just . tagId . tag) $ parent t s

parent :: Taggee -&gt; Structure -&gt; Maybe Taggee
</textual></programlisting><textual class="po-textual">
Note that Haskell is a </textual><emphasis class="po-inline e355 e355" role="ital"><textual class="po-textual">pure</textual></emphasis><textual class="po-textual"> functional programming language and as such does not allow side effects. That is why, in the previous functions when we had to manage some kind of shared data structure of type TagStructs, we passed it between functions by the way of an extra parameter. Haskell has a data type design pattern called </textual><emphasis class="po-inline e356 e356" role="ital"><textual class="po-textual">monad</textual></emphasis><textual class="po-textual"> that offers a much nicer solution, but we kept with the basics so that the link between the two previous sections remained obvious.
</textual></para><para class="po-block e357 e357"><textual class="po-textual">We finally have to compute the distance between every pair of implied tag
structures. We choose a very straightforward editing distance equals to the
number of "add" and "delete" operations needed to transform one set of tags
into another. It does not take into account the structure of the tags and
has for only purpose to guide the user towards other possibly similar
tagging practices. In our current implementation, the distances computation is a
daily batch process.
</textual><programlisting class="po-block e358 e358" xml:space="preserve"><textual class="po-textual">
type Recommendations = Map TagStructId (Map TagStructId Int)

distance :: TagStruct -&gt; TagStruct -&gt; Int
distance ts1 ts2 =
  let k1 = keys ts1
      k2 = keys ts2
      intersize = length $ intersect k1 k2 in
  (length k1 - intersize) + (length k2 - intersize)

distances :: TagStructs -&gt; Recommendations
distances tss = mapWithKey (\k ts -&gt; map (distance ts) $ delete k tss) tss
</textual></programlisting></para></section></section><section class="po-hcontainer e359 e359"><title class="po-block e360 e360"><textual class="po-textual">Peirce's terminology</textual></title><para class="po-block e361 e361"><textual class="po-textual">We now present the theoretical ideas that gave us the
opportunity to develop our methodology. Indeed, in order to explore the
dynamical aspects of multi-structured documents creation, and not only the
static problem of representing such documents, we needed new tools that
could allow us to think of a maintained multiplicity of structures. We
found them in C.S. Peirce. The
introduction of the </textual><emphasis class="po-inline e362 e362" role="ital"><textual class="po-textual">dynamical interpretant</textual></emphasis><textual class="po-textual"> as part of the notion of sign
received our full attention. In order to define this notion, we quote
Peirce [</textual><xref class="po-milestone e363 e363" linkend="peirce1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]:</textual></para><blockquote class="po-container e364 e364"><para class="po-block e365 e365"><textual class="po-textual">…suppose I awake in the morning before my wife, and that afterwards she
wakes up and inquires, "What sort of a day is it?" This is a sign, whose
Object, as expressed, is the weather at that time, but whose Dynamical
Object is the impression which I have presumably derived from peeping
between the window-curtains. Whose Interpretant, as expressed, is the
quality of the weather, but whose Dynamical Interpretant, is my answering
her question. But beyond that, there is a third Interpretant. The Immediate
Interpretant is what the Question expresses, all that it immediately
expresses, which I have imperfectly restated above. The Dynamical
Interpretant is the actual effect that it has upon me, its interpreter. But
the Significance of it, the Ultimate, or Final, Interpretant is her purpose
in asking it, what effect its answer will have as to her plans for the
ensuing day. I reply, let us suppose: "It is a stormy day." Here is another
sign. Its Immediate Object is the notion of the present weather so far as
this is common to her mind and mine - not the character of it, but the
identity of it. The Dynamical Object is the identity of the actual or Real
meteorological conditions at the moment. The Immediate Interpretant is the
schema in her imagination, i.e. the vague Image or what there is in common
to the different Images of a stormy day. The Dynamical Interpretant is the
disappointment or whatever actual effect it at once has upon her. The Final
Interpretant is the sum of the Lessons of the reply, Moral, Scientific,
etc.</textual></para></blockquote><para class="po-block e366 e366"><textual class="po-textual">Elsewhere [</textual><xref class="po-milestone e367 e367" linkend="peirce2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], we find this definition of the sign: </textual><quote class="po-inline e368 e368"><textual class="po-textual">By a sign I mean any thing
which is in any way, direct or indirect, so influenced by any thing (which
I term its object) and which in turn influence a mind that this mind is
thereby influenced by the Object ; and I term that which is called forth in
the mind the Interpretant of the sign.</textual></quote></para><para class="po-block e369 e369"><textual class="po-textual">That being said, we take as a sign the presentation to the user of a
restructuring, and try to analyze it thanks to Peirce's categories :
</textual><itemizedlist class="po-table e370 e370"><listitem class="po-container e371 e371"><para class="po-block e372 e372"><emphasis class="po-inline e373 e373" role="ital"><textual class="po-textual">immediate object</textual></emphasis><textual class="po-textual">: the actual presentation of an automatic
restructuring</textual></para></listitem><listitem class="po-container e374 e374"><para class="po-block e375 e375"><emphasis class="po-inline e376 e376" role="ital"><textual class="po-textual">dynamical object</textual></emphasis><textual class="po-textual">: the impression the user may have derived from
looking at the automatic restructuring presentation</textual></para></listitem><listitem class="po-container e377 e377"><para class="po-block e378 e378"><emphasis class="po-inline e379 e379" role="ital"><textual class="po-textual">immediate interpretant</textual></emphasis><textual class="po-textual">: validity of the restructuring</textual></para></listitem><listitem class="po-container e380 e380"><para class="po-block e381 e381"><emphasis class="po-inline e382 e382" role="ital"><textual class="po-textual">dynamical interpretant</textual></emphasis><textual class="po-textual">: user answer to the restructuring
presentation in terms of the operations (and the ways to combine them)
offered by the computer</textual></para></listitem><listitem class="po-container e383 e383"><para class="po-block e384 e384"><emphasis class="po-inline e385 e385" role="ital"><textual class="po-textual">final interpretant</textual></emphasis><textual class="po-textual">: effect of the operations engaged by the
user</textual></para></listitem></itemizedlist></para><para class="po-block e386 e386"><textual class="po-textual">We can replay this analysis but this time taking as a sign the previous dynamical
interpretant (we are allowed to take this step by the very nature of the
sign: every sign is linking to another one </textual><emphasis class="po-inline e387 e387" role="ital"><textual class="po-textual">ad libitum</textual></emphasis><textual class="po-textual">:
</textual><itemizedlist class="po-table e388 e388"><listitem class="po-container e389 e389"><para class="po-block e390 e390"><emphasis class="po-inline e391 e391" role="ital"><textual class="po-textual">immediate object</textual></emphasis><textual class="po-textual">: the multiple structures of the document</textual></para></listitem><listitem class="po-container e392 e392"><para class="po-block e393 e393"><emphasis class="po-inline e394 e394" role="ital"><textual class="po-textual">dynamical object</textual></emphasis><textual class="po-textual">: the operations to be applied on the
multi-structured document</textual></para></listitem><listitem class="po-container e395 e395"><para class="po-block e396 e396"><emphasis class="po-inline e397 e397" role="ital"><textual class="po-textual">immediate interpretant</textual></emphasis><textual class="po-textual">: execution of the operations</textual></para></listitem><listitem class="po-container e398 e398"><para class="po-block e399 e399"><emphasis class="po-inline e400 e400" role="ital"><textual class="po-textual">dynamical interpretant</textual></emphasis><textual class="po-textual">: effect of this particular choice of
operations in this particular context</textual></para></listitem><listitem class="po-container e401 e401"><para class="po-block e402 e402"><emphasis class="po-inline e403 e403" role="ital"><textual class="po-textual">final interpretant</textual></emphasis><textual class="po-textual">: effect the presentation of the computer
analysis  of the user interactions will have on the user</textual></para></listitem></itemizedlist></para><para class="po-block e404 e404"><textual class="po-textual">First of all, the linked nature of the sign gave us the idea of introducing the user at
the heart of the restructuring process. Moreover, being able to see the dynamical
interpretant as a producer of new signs gave us the idea of the
construction of a social network of documents authors, the documentary
structures being used as a social glue.</textual></para></section></section><section class="po-hcontainer e405 e405"><title class="po-block e406 e406"><textual class="po-textual">A prototype implementation of the methodology</textual></title><para class="po-block e407 e407"><textual class="po-textual">We provide all the functions introduced above as a Web service that follows
the REST [</textual><xref class="po-milestone e408 e408" linkend="Rest"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] design pattern. In the context of this paper we cannot
fully describe this Web service. We only give as an example the HTTP
operation used for tagging a new "equation" in the mathematical structure
of a notebook. All we have to do is send a POST request to the resource
identified by the URL </textual><emphasis class="po-inline e409 e409" role="ital"><textual class="po-textual">http://desanti.org/cahiers/148/structures/math/taggees</textual></emphasis><textual class="po-textual"> with a body of:
</textual><programlisting class="po-block e410 e410" xml:space="preserve"><textual class="po-textual">
  &lt;taggee&gt;
    &lt;tag name="equation" /&gt;
    &lt;interval start="14" end="26" /&gt;
  &lt;/taggee&gt;
  &lt;/programlisting&gt;
</textual></programlisting></para><para class="po-block e411 e411"><xref class="po-milestone e412 e412" linkend="prototype"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is a screenshot of the client application running inside a Web browser. The region Z3 is a hierarchy
of all the documents of the archive, it gives the researchers the synoptic
view they need. The region Z1 is a draggable navigator obtained by clicking
on an element of the hierarchy Z3, it allows to navigate among the images
of the pages of a collection. The region Z4 is an editor for the
transcription. The region Z5 is the set of recommendations for tag
hierarchies similar to the one implied by the current documentary
structure. Region Z2 is the comparison frame obtained when the user click
on one of the recommendations, it allows him to decide if he wants to merge
his tags structure with the one suggested.</textual></para><figure class="po-container e413 e413" xml:id="prototype" xreflabel="Figure 11"><mediaobject class="po-container e414 e414"><imageobject class="po-container e415 e415"><imagedata class="po-meta e416 e416" fileref="../../../vol3/graphics/Portier01/Portier01-011.jpg" format="jpg" width="95%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e417 e417"><para class="po-block e418 e418"><textual class="po-textual">Prototype</textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e419 e419"><title class="po-block e420 e420"><textual class="po-textual">Conclusions</textual></title><para class="po-block e421 e421"><textual class="po-textual">We have identified a new problem: how to </textual><emphasis class="po-inline e422 e422" role="ital"><textual class="po-textual">build</textual></emphasis><textual class="po-textual"> multi-structured
documents? This allowed us to take over the old issue of multi-structured
documents as we pulled away from its technical formulation and bring
ourselves closer to the daily practices of those building documents. We have shown
that, although the enforcement of tree structures was for a long time
considered as the crux of the problem, we could place it at the heart of a
new solution where the emergence of overlapping hierarchies triggers the
creation of a new structure that has to be validated by the user. In fact, our methodology places the users in a central position and we managed to lighten the cognitive load that results from the interactions with the system by bordering the reflexive activities on small and well defined periods. Thus we
managed to provide a methodology that addresses the needs of humanities
researchers by promoting and maintaining a multiplicity of stuctures.
Moreover, we developed a prototype that implements the algebraic operations
described in the article.  These operations are provided through a Web
interface using the HTTP protocol in accordance with the REST design
pattern.</textual></para></section><bibliography class="po-hcontainer e423 e423"><title class="po-block e424 e424"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e425 e425" xml:id="Rose" xreflabel="Rose2004"><textual class="po-textual">Steven J. DeRose, </textual><emphasis class="po-inline e426 e426" role="ital"><textual class="po-textual">Markup Overlap: A Review and a Horse</textual></emphasis><textual class="po-textual"> in "Extreme Markup Languages" 2004, </textual><link class="po-inline e427 e427" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mulberrytech.com/Extreme/Proceedings/html/2004/DeRose01/EML2004DeRose01.html</textual></link></bibliomixed><bibliomixed class="po-block e428 e428" xml:id="Multi" xreflabel="Bruno2007"><textual class="po-textual">Emmanuel Bruno, Sylvie Calabretto and Elisabeth Murisasco, </textual><emphasis class="po-inline e429 e429" role="ital"><textual class="po-textual">Documents textuels multi structurés : un état de l'art.</textual></emphasis><textual class="po-textual"> in "Revue i3" 2007, </textual><link class="po-inline e430 e430" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://liris.cnrs.fr/publis/?id=2708</textual></link></bibliomixed><bibliomixed class="po-block e431 e431" xml:id="Multix" xreflabel="Chatti2007"><textual class="po-textual">Noureddine Chatti, Souha Kaouk, Sylvie Calabretto and Jean-Marie Pinon, </textual><emphasis class="po-inline e432 e432" role="ital"><textual class="po-textual">MultiX: an XML-based formalism to encode multi-structured documents</textual></emphasis><textual class="po-textual"> in "Proceedings of Extreme Markup Languages'2007"</textual></bibliomixed><bibliomixed class="po-block e433 e433" xml:id="Rest" xreflabel="Fielding2000"><textual class="po-textual">Roy  T. Fielding, </textual><emphasis class="po-inline e434 e434" role="ital"><textual class="po-textual">Architectural styles and the design of network-based software architectures</textual></emphasis><textual class="po-textual">, 2000 </textual><link class="po-inline e435 e435" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://portal.acm.org/citation.cfm?id=932295</textual></link></bibliomixed><bibliomixed class="po-block e436 e436" xml:id="Haskell" xreflabel="PeytonJones2002"><textual class="po-textual">Simon Peyton Jones, </textual><emphasis class="po-inline e437 e437" role="ital"><textual class="po-textual">Haskell 98 Language and Libraries: The Revised Report</textual></emphasis><textual class="po-textual">, 2002 </textual><link class="po-inline e438 e438" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://haskell.org/definition/haskell98-report.pdf</textual></link></bibliomixed><bibliomixed class="po-block e439 e439" xml:id="Tei" xreflabel="Burnard2007"><textual class="po-textual">Lou Burnard and Syd Bauman, </textual><emphasis class="po-inline e440 e440" role="ital"><textual class="po-textual">TEI P5: Guidelines for Electronic Text Encoding and Interchange</textual></emphasis><textual class="po-textual">, 2007 </textual><link class="po-inline e441 e441" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/index.html</textual></link></bibliomixed><bibliomixed class="po-block e442 e442" xml:id="Schema" xreflabel="Simeon2003"><textual class="po-textual">Jerome Simeon and Philip Wadler, </textual><emphasis class="po-inline e443 e443" role="ital"><textual class="po-textual">The essence of XML</textual></emphasis><textual class="po-textual">, 2003 in "POPL '03: Proceedings of the 30th ACM SIGPLAN-SIGACT symposium on Principles of programming languages", doi: </textual><biblioid class="po-atom e444 doi e444"><textual class="po-textual">10.1145/604131.604132</textual></biblioid></bibliomixed><bibliomixed class="po-block e445 e445" xml:id="Annotation" xreflabel="Bird1999"><textual class="po-textual">Steven Bird and Mark Liberman, </textual><emphasis class="po-inline e446 e446" role="ital"><textual class="po-textual">Annotation Graphs as a Framework for Multidimensional Linguistic Data Analysis</textual></emphasis><textual class="po-textual">, 1999 in "Towards Standards and Tools for Discourse Tagging: Proceedings of the Workshop", </textual><link class="po-inline e447 e447" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://citeseer.ist.psu.edu/bird99annotation.html</textual></link></bibliomixed><bibliomixed class="po-block e448 e448" xml:id="Rdf" xreflabel="Tummarello2005"><textual class="po-textual">Giovanni Tummarello, Christian Morbidoni and E. Pierazzo, </textual><emphasis class="po-inline e449 e449" role="ital"><textual class="po-textual">Toward Textual Encoding Based on RDF</textual></emphasis><textual class="po-textual">, in "From Author to Reader: Challenges for the Digital Content Chain: Proceedings of the 9th ICCC International Conference on Electronic Publishing held at Katholieke Universiteit Leuven - ELPUB 2005, Leuven-Heverlee, Belgium, June 8-10, 2005. Proceedings", p. 57-63</textual></bibliomixed><bibliomixed class="po-block e450 e450" xml:id="Monet" xreflabel="Alink2006"><textual class="po-textual">Wouter Alink, R. A. F. Bhoedjang, Arjen P. de Vries and Peter A. Boncz, </textual><emphasis class="po-inline e451 e451" role="ital"><textual class="po-textual">Efficient XQuery Support for Stand-Off Annotation</textual></emphasis><textual class="po-textual">, in "Proceedings of the 3rd International Workshop on XQuery Implementation, Experience and Perspectives, in cooperation with ACM SIGMOD, June 30, 2006, Chicago, USA. 2006", </textual><link class="po-inline e452 e452" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ximep-2006.org/papers/Paper-Alink-Boncz.pdf</textual></link></bibliomixed><bibliomixed class="po-block e453 e453" xml:id="MSXD" xreflabel="Bruno2006"><textual class="po-textual">E. Bruno and E. Murisasco, </textual><emphasis class="po-inline e454 e454" role="ital"><textual class="po-textual">Multistructured XML textual documents</textual></emphasis><textual class="po-textual">, 2006, in "GESTS International Transactions on Computer Science and Engineering", vol. 34 n. 1, p. 200-211</textual></bibliomixed><bibliomixed class="po-block e455 e455" xml:id="GODDAG" xreflabel="Sperberg-McQueen2000"><textual class="po-textual">C. M. Sperberg-McQueen and Claus Huitfeldt, </textual><emphasis class="po-inline e456 e456" role="ital"><textual class="po-textual">GODDAG: A Data Structure for Overlapping Hierarchies</textual></emphasis><textual class="po-textual">, in "Digital Documents: Systems and Principles, 8th International Conference on Digital Documents and Electronic Publishing, DDEP 2000, 5th International Workshop on the Principles of Digital Document Processing, PODDP 2000, Munich, Germany, September 13-15, 2000, Revised Papers", vol. 2023, p. 139-160</textual></bibliomixed><bibliomixed class="po-block e457 e457" xml:id="againstConcur" xreflabel="Hilbert2005"><textual class="po-textual">Mirco Hilbert, Andreas Witt and Oliver Schonefeld, </textual><emphasis class="po-inline e458 e458" role="ital"><textual class="po-textual">Making CONCUR work</textual></emphasis><textual class="po-textual">, 2005, in "Extreme Markup Languages"</textual></bibliomixed><bibliomixed class="po-block e459 e459" xml:id="mecs" xreflabel="Huitfeldt1998"><textual class="po-textual">Claus Huitfeldt, </textual><emphasis class="po-inline e460 e460" role="ital"><textual class="po-textual">MECS - a Multi-Element Code System</textual></emphasis><textual class="po-textual">, 1998, in "Working Papers from the Wittgenstein Archives at the University of Bergen", vol. 3</textual></bibliomixed><bibliomixed class="po-block e461 e461" xml:id="texmecs" xreflabel="Huitfeldt2003"><textual class="po-textual">Claus Huitfeldt and Michael Sperberg-McQueen, </textual><emphasis class="po-inline e462 e462" role="ital"><textual class="po-textual">TexMECS: An experimental markup meta-language for complex documents</textual></emphasis><textual class="po-textual">, 2003, in "Working paper of the project Markup Languages for Complex Documents (MLCD), University of Bergen", </textual><link class="po-inline e463 e463" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://decentius.aksis.uib.no/mlcd/2003/Papers/texmecs.html</textual></link></bibliomixed><bibliomixed class="po-block e464 e464" xml:id="lmnl" xreflabel="Tennison2002"><textual class="po-textual">Jeni Tennison and Wendell Piez, </textual><emphasis class="po-inline e465 e465" role="ital"><textual class="po-textual">The Layered Markup and Annotation Language (LMNL)</textual></emphasis><textual class="po-textual">, 2002, in "Extreme Markup Languages", </textual><link class="po-inline e466 e466" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mulberrytech.com/Extreme/Proceedings/html/2002/Tennison02/EML2002Tennison02.html</textual></link></bibliomixed><bibliomixed class="po-block e467 e467" xml:id="annotationGraphs" xreflabel="Maeda2002"><textual class="po-textual">Kazuaki Maeda, Steven Bird, Xiaoyi Ma and Haejoong Lee, </textual><emphasis class="po-inline e468 e468" role="ital"><textual class="po-textual">Creating Annotation Tools with the Annotation Graph Toolkit</textual></emphasis><textual class="po-textual">, 2002, in "Proceedings of the Third International Conference on Language Resources and Evaluation", </textual><link class="po-inline e469 e469" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://arxiv.org/abs/cs/0204005</textual></link></bibliomixed><bibliomixed class="po-block e470 e470" xml:id="annotationGraphsQuery" xreflabel="Bird2000"><textual class="po-textual">Steven Bird, Peter Buneman and Wang-chiew Tan, </textual><emphasis class="po-inline e471 e471" role="ital"><textual class="po-textual">Towards a Query Language for Annotation Graphs</textual></emphasis><textual class="po-textual">, 2000, in "Proceedings of the Second International Conference on Language Resources and Evaluation", p. 807-814</textual></bibliomixed><bibliomixed class="po-block e472 e472" xml:id="mct" xreflabel="Jagadish2004"><textual class="po-textual">H. V. Jagadish, Laks V. S. Lakshmanan, Monica Scannapieco, Divesh Srivastava, and Nuwee Wiwatwattana, </textual><emphasis class="po-inline e473 e473" role="ital"><textual class="po-textual">Colorful XML: one hierarchy isn't enough</textual></emphasis><textual class="po-textual">, 2004, in "SIGMOD '04: Proceedings of the 2004 ACM SIGMOD international conference on Management of data", p. 251-262, doi: </textual><biblioid class="po-atom e474 doi e474"><textual class="po-textual">10.1145/1007568.1007598</textual></biblioid></bibliomixed><bibliomixed class="po-block e475 e475" xml:id="delay" xreflabel="LeMaitre2006"><textual class="po-textual">Jacques Le Maître, </textual><emphasis class="po-inline e476 e476" role="ital"><textual class="po-textual">Describing multistructured XML documents by means of delay nodes</textual></emphasis><textual class="po-textual">, 2006, in "DocEng '06: Proceedings of the 2006 ACM symposium on Document engineering", New York, NY, USA, p. 155-164, doi: </textual><biblioid class="po-atom e477 doi e477"><textual class="po-textual">10.1145/1166160.1166200</textual></biblioid></bibliomixed><bibliomixed class="po-block e478 e478" xml:id="overlap" xreflabel="Iacob2005"><textual class="po-textual">Ionut E. Iacob and Alex Dekhtyar, </textual><emphasis class="po-inline e479 e479" role="ital"><textual class="po-textual">Processing XML documents with overlapping hierarchies</textual></emphasis><textual class="po-textual">, 2005, in "JCDL '05: Proceedings of the 5th ACM/IEEE-CS joint conference on Digital libraries", New York, NY, USA, p. 409-409, doi: </textual><biblioid class="po-atom e480 doi e480"><textual class="po-textual">10.1145/1065385.1065513</textual></biblioid></bibliomixed><bibliomixed class="po-block e481 e481" xml:id="concur" xreflabel="Goldfarb1990"><textual class="po-textual">Charles F. Goldfarb, </textual><emphasis class="po-inline e482 e482" role="ital"><textual class="po-textual">The SGML handbook</textual></emphasis><textual class="po-textual">, 1990, Oxford University Press, Inc.</textual></bibliomixed><bibliomixed class="po-block e483 e483" xml:id="peirce1" xreflabel="Peirce1909"><textual class="po-textual">Charles Sanders Peirce, </textual><emphasis class="po-inline e484 e484" role="ital"><textual class="po-textual">Letter to William James</textual></emphasis><textual class="po-textual">, in "Collected Papers of Charles Sanders Peirce, Volume 8, Arthur W. Burks. Cambridge, Mass.: Harvard University Press", para. 314, </textual><link class="po-inline e485 e485" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.helsinki.fi/science/commens/terms/dynamicalinterpretant.html</textual></link></bibliomixed><bibliomixed class="po-block e486 e486" xml:id="peirce2" xreflabel="Peirce"><textual class="po-textual">Charles Sanders Peirce, </textual><emphasis class="po-inline e487 e487" role="ital"><textual class="po-textual">Logic: Regarded as a Study of the general nature of Signs</textual></emphasis><textual class="po-textual">, </textual><link class="po-inline e488 e488" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.cspeirce.com/menu/library/rsources/76defs/76defs.htm</textual></link></bibliomixed></bibliography></article></classedDocument>