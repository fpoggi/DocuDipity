<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Decision making in XSL-FO formatting</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">XSL-FO has a very linear processing model that has served it well, but very often it is necessary to make decisions on what will be in the formatted output based on the sizes of the formatted output, and XSL 1.1 as defined does not let you do that.  This paper looks at what's needed to be done to get that sort of decision making into XSL-FO processing today and at some possible future developments.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Tony</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Graham</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Tony Graham is the chair of the Print and Page Layout Community Group at the W3C.</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Consultant</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Mentea</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">tgraham@mentea.net</textual></email></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Copyright © 2013 Mentea</textual></para></legalnotice><keywordset class="po-table e20 e20" role="author"><keyword class="po-field e21 e21"><textual class="po-textual">XSL-FO</textual></keyword></keywordset></info><section class="po-hcontainer e22 e22"><title class="po-block e23 e23"><textual class="po-textual">XSL 1.1 Processing Model</textual></title><para class="po-block e24 e24"><textual class="po-textual">Extensible Stylesheet Language (XSL) 1.1 [XSL11] is defined to cover
both transformation and formatting.  The transformation part was
broken out as XSLT long before XSL 1.1 became a Recommendation, so the XSLT spec, bar a few paragaphs about XSLT, is concerned with formatting the result of a XSLT transformation, where:</textual></para><blockquote class="po-container e25 e25"><para class="po-block e26 e26"><textual class="po-textual">Formatting is enabled by including formatting semantics in the result tree. Formatting semantics are expressed in terms of a catalog of classes of formatting objects. The nodes of the result tree are formatting objects. The classes of formatting objects denote typographic abstractions such as page, paragraph, table, and so forth. Finer control over the presentation of these abstractions is provided by a set of formatting properties, such as those controlling indents, word- and letter spacing, and widow, orphan, and hyphenation control. In XSL, the classes of formatting objects and formatting properties provide the vocabulary for expressing presentation intent.</textual></para></blockquote><para class="po-block e27 e27"><textual class="po-textual">Figure 1 is the detailed conceptual model diagram from XSL 1.1.  It shows a linear process from XML source to the result of the XSLT stage to the formatted output.</textual></para><figure class="po-container e28 e28" xml:id="model1"><title class="po-block e29 e29"><textual class="po-textual">XSL 1.1 processing model</textual></title><mediaobject class="po-container e30 e30"><imageobject class="po-container e31 e31"><imagedata class="po-meta e32 e32" fileref="../../../vol10/graphics/Graham01/Graham01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e33 e33"><textual class="po-textual">The process of turning XML in the FO vocabulary into formatted, and more than likely paginated, output is itself defined in multiple stages.  Figure 2, also from XSL 1.1, shows how the XML representation of the formatting objects is turned into actual objects (as 'actual' as bits and bytes in computer memory can be), expressions in property values are resolved, and the formatter then makes areas.  The formatted areas could be written out to a graphical or document format (such as PDF, PostScript, or RTF) or, in some cases, could be written out as an XML representation of the area tree for later processing.</textual></para><figure class="po-container e34 e34" xml:id="model2"><title class="po-block e35 e35"><textual class="po-textual">Summary of the process</textual></title><mediaobject class="po-container e36 e36"><imageobject class="po-container e37 e37"><imagedata class="po-meta e38 e38" fileref="../../../vol10/graphics/Graham01/Graham01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e39 e39"><textual class="po-textual">The XSL spec itself notes that its design follows that of DSSSL [DSSSL]:</textual></para><blockquote class="po-container e40 e40"><para class="po-block e41 e41"><textual class="po-textual">XSL builds on the prior work on Cascading Style Sheets [CSS2] and the Document Style Semantics and Specification Language [DSSSL].</textual></para></blockquote><para class="po-block e42 e42"><textual class="po-textual">and the linear processing model with transformation and formatting stages follows that of DSSSL:</textual></para><figure class="po-container e43 e43" xml:id="dsssl1"><title class="po-block e44 e44"><textual class="po-textual">DSSSL processing model</textual></title><mediaobject class="po-container e45 e45"><imageobject class="po-container e46 e46"><imagedata class="po-meta e47 e47" fileref="../../../vol10/graphics/Graham01/Graham01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e48 e48" xml:id="dsssl2"><title class="po-block e49 e49"><textual class="po-textual">DSSSL formatting</textual></title><mediaobject class="po-container e50 e50"><imageobject class="po-container e51 e51"><imagedata class="po-meta e52 e52" fileref="../../../vol10/graphics/Graham01/Graham01-004.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e53 e53"><textual class="po-textual">DSSSL goes one step further - or XSL took one step back from DSSSL - since DSSSL states:</textual></para><blockquote class="po-container e54 e54"><para class="po-block e55 e55"><textual class="po-textual">DSSSL is independent of the type of formatter,
formatting system, or other transformation processor.</textual></para></blockquote><para class="po-block e56 e56"><textual class="po-textual">and James Clark's Jade DSSSL procssor [JADE] came with RTF, TeX, and MIF backends for formatted output.</textual></para><para class="po-block e57 e57"><textual class="po-textual">This separation of concerns between a style engine and a backend is not explicit in either the original XSL Requirements Summary [XSLReq] or the XSL spec, but the linear processing model did allow XSL processing to be implemented on top of existing formatters, and of the six formatters for which test results [XSLCRTest] were provided so the XSL 1.0 specification could progress from Candidate Recommendation to Proposed Recommendation, two - Arbortext and PassiveTeX - used existing formatters to make the pages.</textual></para><section class="po-hcontainer e58 e58"><title class="po-block e59 e59"><textual class="po-textual">Effect on decision making</textual></title><para class="po-block e60 e60"><textual class="po-textual">To take a simplistic view of decision making - that it's just that: making decisions - then there's obviously a lot of decision making going on in the XSL processing model:</textual></para><itemizedlist class="po-table e61 e61"><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">The stylesheet writer decides how to style the class of the source documents</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">The XSLT processor, by selecting template rules based on the structure of the source document (and possibly on other factors) and by evaluating conditional expressions, decides what goes in the result tree</textual></para></listitem><listitem class="po-container e66 e66"><para class="po-block e67 e67"><textual class="po-textual">The XSL formatter decides where pages, lines, etc., should break, decides what should change when one area intrudes on another, and decides (based on values of properties such as 'overflow', etc.) what to do when an area or a graphic is too large for the available space</textual></para></listitem></itemizedlist><para class="po-block e68 e68"><textual class="po-textual">yet these are all decisions taken in isolation at different points in the processing.</textual></para></section></section><section class="po-hcontainer e69 e69"><title class="po-block e70 e70"><textual class="po-textual">Case Study - PLOS ONE Journal</textual></title><para class="po-block e71 e71"><textual class="po-textual">
PLOS ONE [PONE] is an international, peer-reviewed, open-access, online publication published by PLOS (Public Library of Science) [PLOS], a nonprofit publisher and advocacy organization headquartered in San Francisco, California, USA.</textual></para><para class="po-block e72 e72"><textual class="po-textual">The author was selected to implement a XSL-FO-based system for producing PDFs of PLOS ONE articles.  The PDFs had to replicate PLOS ONE's existing house style.</textual></para><para class="po-block e73 e73"><textual class="po-textual">PLOS ONE receives manuscripts in Word, LaTeX, or RTF formats, then converts these to XML conforming to the NLM Journal Publishing DTD v3.0 prior to publication.</textual></para><para class="po-block e74 e74"><textual class="po-textual">PLOS ONE articles are formatted in two-column pages.  Figures may be either column-wide or page-wide, and tables may be column-wide, page-wide, or rotated so their width is page-high, but there is no size information for either figures or tables in the source XML.  Figures and graphics may also float to either the top or bottom of the page or column.</textual></para><section class="po-hcontainer e75 e75"><title class="po-block e76 e76"><textual class="po-textual">XSL 1.1 capabilities</textual></title><para class="po-block e77 e77"><textual class="po-textual">XSL 1.1 defines a 'before-float-reference-area' on a page, but does not define an area for content floated to the 'after' end of the page, and the 'before-float-reference-area', when instantiated, takes the full width of the fo:region-body of the page.</textual></para><para class="po-block e78 e78"><textual class="po-textual">PLOS therefore had to choose a XSL formatter based on the availability of vendor extensions to support more ways to float than defined by XSL 1.1.</textual></para></section><section class="po-hcontainer e79 e79"><title class="po-block e80 e80"><textual class="po-textual">Graphics handling</textual></title><para class="po-block e81 e81"><textual class="po-textual">Graphics at least have an intrinsic size and, in formats such as TIFF, have an intrinsic resolution as well.</textual></para><para class="po-block e82 e82"><textual class="po-textual">The process for determining whether graphics are column-wide or page-wide is:</textual></para><itemizedlist class="po-table e83 e83"><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">Download copies of TIFF images from PLOS ONE article web page</textual></para><para class="po-block e86 e86"><textual class="po-textual">In production, PLOS will have the graphics available on their servers, so this is only ncessary while developing the stylesheet.</textual></para></listitem><listitem class="po-container e87 e87"><para class="po-block e88 e88"><textual class="po-textual">Run ImageMagick 'identify' on each graphic to get its width, height, horizontal resolution, and vertical resolution and write the information to a '.identify' file for each graphic</textual></para></listitem><listitem class="po-container e89 e89"><para class="po-block e90 e90"><textual class="po-textual">In the XSLT stylesheet, when processing a graphic, get the contents of the corresponding '.identify' file using 'unparsed-text()', tokenize the returned string to get the four values, then calculate the graphic's width by dividing the width in pixels by the horizontal resolution.  When the calculateed width is less than or equal to the width of a column, it is made column-wide, otherwise it is made page-wide.</textual></para></listitem></itemizedlist><para class="po-block e91 e91"><textual class="po-textual">The PLOS ONE authoring guidelines allow graphics sized up to the height of the page body, but figures may have captions of up to 300 characters, as well as having a label, title, and DOI that also appear in the formatted output.  XSL doesn't allow floated FOs to break across a page, so imilarly to as described below for tables, the processing system 'preformats' the figure captions at both widths and writes out the area tree to be used as input by the main stylesheeet so the stylesheet reduces the allowed maximum height of the graphic so the graphic won't push its following caption into the footer area.</textual></para></section><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">Table handling</textual></title><para class="po-block e94 e94"><textual class="po-textual">Tables, as noted above, are presented one of three ways -- column-wide, page-wide, or page-high -- depending on which best fits the content of the table.  Deciding which to do is entirely up to the processing system since the source XML, converted from other sources as it was, does not include even the few presentation-oriented attributes defined by the DTD.</textual></para><para class="po-block e95 e95"><textual class="po-textual">The NLM/JATS DTDs support [TableWrap] specifying the orientation of a combined table and caption but do not provide a way to indicate the width of a table.  The NISO JATS table model does allow a 'style' attribute on 'table' and 'caption', but not on the 'table-wrap' that contains them both.</textual></para><para class="po-block e96 e96"><textual class="po-textual">The sample files provided at the start of the project included TIFF images of each of the tables in the samples as well as TIFF files for the graphics, and it wasn't until the project was underway that it was made clear that the images of the tables were artifacts of the existing processing system and, not only were they not going to be available for new documents, the new system was expected to produce those as well.</textual></para><para class="po-block e97 e97"><textual class="po-textual">The implemented approach makes a temporary 'sizer' formatted document containing each table at each width, saves the area tree from that document, and provides the area tree as a parameter to the stylesheet that produces the FO for the final formatted output.</textual></para><para class="po-block e98 e98"><textual class="po-textual">The 'sizer' document comprises three pages that each have a different fixed width and a large height (since the formatter doesn't support '&lt;fo:root media-usage="bounded-in-one-dimension"&gt;').  Every table in the source XML has an ID, so the tables on each page are given a unique ID in their FO document by prefixing a page-specific prefix to the tables original ID.  The following figure shows tables from an article formatted at page-wide, column-wide, and page-high widths.  The first two tables fit within a column, but the third overflows a column.</textual></para><figure class="po-container e99 e99" xml:id="sizer"><title class="po-block e100 e100"><textual class="po-textual">'sizer' document</textual></title><mediaobject class="po-container e101 e101"><imageobject class="po-container e102 e102"><imagedata class="po-meta e103 e103" fileref="../../../vol10/graphics/Graham01/Graham01-005.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e104 e104"><textual class="po-textual">The stylesheet that produces the 'sizer' document is very simple.  A template matching the document node does all the work, and the stylesheet imports the 'main' stylesheet so the tables are formatted exactly as they would be in the final output.  Since there are only three pages, the stylesheet does not even define any page-sequence masters, so each fo:page-sequence refers directly to a fo:simple-page-master.</textual></para><programlisting class="po-block e105 e105" xml:space="preserve"><textual class="po-textual">
  &lt;fo:root&gt;
    &lt;fo:layout-master-set&gt;
      &lt;xsl:call-template name="define-sizer-simple-page-masters"/&gt;
    &lt;/fo:layout-master-set&gt;
    &lt;fo:page-sequence master-reference="page-wide"&gt;
      &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
        &lt;xsl:apply-templates select="//table-wrap"&gt;
          &lt;xsl:with-param name="prefix" select="'page-wide-'" as="xs:string" tunnel="yes" /&gt;
        &lt;/xsl:apply-templates&gt;
      &lt;/fo:flow&gt;
    &lt;/fo:page-sequence&gt;
    &lt;fo:page-sequence master-reference="column-wide"&gt;
      &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
        &lt;xsl:apply-templates select="//table-wrap"&gt;
          &lt;xsl:with-param name="prefix" select="'column-wide-'" as="xs:string" tunnel="yes" /&gt;
        &lt;/xsl:apply-templates&gt;
      &lt;/fo:flow&gt;
    &lt;/fo:page-sequence&gt;
    &lt;fo:page-sequence master-reference="page-high"&gt;
      &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
        &lt;xsl:apply-templates select="//table-wrap"&gt;
          &lt;xsl:with-param name="prefix" select="'page-high-'" as="xs:string" tunnel="yes" /&gt;
        &lt;/xsl:apply-templates&gt;
      &lt;/fo:flow&gt;
    &lt;/fo:page-sequence&gt;
  &lt;/fo:root&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e106 e106"><textual class="po-textual">The only template that has so far been needed to override the default processing just stops bibliographic cross-references or references to supplemantary material generating a fo:basic-link so there's no longer warnings from the XSL formatter about unresolved cross-references:</textual></para><programlisting class="po-block e107 e107" xml:space="preserve"><textual class="po-textual">&lt;xsl:template match="xref[@ref-type = ('bibr', 'supplementary-material')]"&gt;
  &lt;xsl:apply-templates /&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e108 e108"><textual class="po-textual">The main stylesheet declares variables for the page width, margins, etc., so the same values are used in the main stylesheet to produce the final output and to work out whether graphics should be page-wide or column-wide and used in the 'sizer' stylesheet to set the pages' dimensions.</textual></para><para class="po-block e109 e109"><textual class="po-textual">As stated previously, the area tree for the 'sizer' document is saved as XML, and the filename of the area tree XML passed to the main stylesheet, when run separately, as a parameter value.  When the stylesheet comes to process a 'table-wrap', it looks up the dimensions of the table variants in the 'sizer' area tree and, based on the dimensions, decides which format of the table to use.  The following figure shows two of the tables from the 'sizer' document in the final formatted output.</textual></para><figure class="po-container e110 e110" xml:id="pages"><title class="po-block e111 e111"><textual class="po-textual">Formatted pages</textual></title><mediaobject class="po-container e112 e112"><imageobject class="po-container e113 e113"><imagedata class="po-meta e114 e114" fileref="../../../vol10/graphics/Graham01/Graham01-006.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e115 e115"><textual class="po-textual">Current capabilities include automatic sizing of tables to be column-wide, page-wide, or page-high (either column-width or page-width), with manual overrides available to force a table to be page-wide or page high, plus automatic breaking of tables that are too high (or, for page-high tables, too wide) for the available space.  When tables are broken into multiple subtables, each subtable gets its column widths from the 'sizer' table both so the subtables use the same widths and to avoid the automatic table algorithm optimising eacch subtable and leaving space at the bottom of a page.</textual></para><para class="po-block e116 e116"><textual class="po-textual">It hasn't yet been necessary to produce TIFF images of each table, but if it were required, the main stylesheet would output a separate FO document with individually-sized page dimensions for each table.  Those FO documents would then be formatted to PDF or PostScript and then converted to TIFF using ImageMagick.</textual></para></section></section><section class="po-hcontainer e117 e117"><title class="po-block e118 e118"><textual class="po-textual">Extensible Stylesheet Language (XSL) Requirements Version 2.0</textual></title><para class="po-block e119 e119"><textual class="po-textual">The "Extensible Stylesheet Language (XSL) Requirements Version 2.0" Working Draft [XSLFO20-Req], published two years after XSL 1.1, includes among its requirements several that require or allow more decision making within the XSL formatter or that break the linear sequence of the XSL 1.1 processing model, including:</textual></para><itemizedlist class="po-table e120 e120"><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">Section 2.3, Feedback from pagination stage</textual></para><para class="po-block e123 e123"><textual class="po-textual">This calls for "the ability to use information from the pagination step of one formatting episode in determining layout of the following formatting episode" and "making changes to the pages, reordering pages, merging multiple flows and do many other post processing tasks."  This is what was done in the PLOS ONE example above, but if it could be realised in a XSL-FO 2.0 specification and in a XSL-FO 2.0 formatter, then it may be easier to use compared to the current bespoke solution that is stitched together using Apache Ant.</textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">Section 3.1, Including information from formatting time</textual></para><para class="po-block e126 e126"><textual class="po-textual">This calls for the XSL-FO expression language "to allow expressions that include information that’s only available at formatting time."  If implemented, it wouldn't necessarily put more decision making in the XSL formatter, but would let the output change the output in a way that isn't possible at present.</textual></para></listitem><listitem class="po-container e127 e127"><para class="po-block e128 e128"><textual class="po-textual">Section 3.2, Pagination information</textual></para><para class="po-block e129 e129"><textual class="po-textual">The ability "to compute expressions that are based on information that is only available after the pagination stage" would be another twist to the linear processing model.</textual></para></listitem><listitem class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual">Section 2.1.4, Copyfitting</textual></para><para class="po-block e132 e132"><textual class="po-textual">Copyfitting, in XSL-FO 2.0 terms, would be the ability to "shrink or grow content (change properties of text, line-spacing, ...) to make it constrain to a certain area."  The requirements also anticipate that "multiple instances of alternative content can be provided to determine best fit" and that copyfitting would act "across a given number of pages, regions, columns etc, for example to constrain the number of pages to 5 pages."</textual></para><para class="po-block e133 e133"><textual class="po-textual">Again, this would put more decision making within the XSL formatter but, once specified in the input FO document, it would be beyond the direct control of the XSLT stylesheet and of the stylesheet writer.</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e134 e134"><title class="po-block e135 e135"><textual class="po-textual">Print and Page Layout Community Group</textual></title><para class="po-block e136 e136"><textual class="po-textual">The charter of the W3C XML Print and Page Layout Working Group, which was developing XSL-FO 2.0 and produced a series of working drafts, expired in early 2013.  However, following the inception of Business and Community Groups at the W3C, the Print and Page Layout Community Group [PPL] has been operating since early 2012.  It has no charter and no support from the W3C other than that provided to all Community Groups, but after a period of relative inactivity, it is now producing new ideas and trying out new solutions for XSL-FO processing.</textual></para><section class="po-hcontainer e137 e137"><title class="po-block e138 e138"><textual class="po-textual">Emphasis on feedback</textual></title><para class="po-block e139 e139"><textual class="po-textual">Following a post by Patrick Gundlach of Speedata on the eve of his XML Prague 2013 talk [Sppedata], the CG turned its attention to feedback, or the lack of it, in XSL-FO processing.  The CG produced a short list of examples where feedback, as the basis for decision making, would be useful [CustReq].  Some of them have direct equivalents in the XSL-FO 2.0 requirements document, but others do not.</textual></para><para class="po-block e140 e140"><textual class="po-textual">It was quite easy for several on the public-ppl@w3.org mailing list to agree on the usefulness of more feedback in XSL-FO processing (while others are happy with XSL 1.1 as it is today [Hahn]), but the difficulty was in doing anything about it given the limited resources of the CG.  In response to comments on the mailing list, Arved Sandstrom of MagicLamp Software produced a proof-of-concept extension function [FOPRunXSLTExt] for both the Saxon and Xerces XSLT processors that, mid-transform, runs the Apache FOP XSL formatter [FOP] on a provided FO document and returns (a reference to) the area tree XML for the formatted result.</textual></para><para class="po-block e141 e141"><textual class="po-textual">Several examples of the extension function in action are provided on the PPL wiki.  The example below demonstrates a solution to requirement #9, "Ability to modify label field width in a single list when labels are large", from [CustReq].</textual></para><para class="po-block e142 e142"><textual class="po-textual">The example's source XML includes two lists that, when transformed with the default stylesheet and formatted, are cleverly contrived to have list item label widths that are either too wide or too narrow for the labels in the lists.</textual></para><figure class="po-container e143 e143" xml:id="wrong"><title class="po-block e144 e144"><textual class="po-textual">Wrong list item label widths</textual></title><mediaobject class="po-container e145 e145"><imageobject class="po-container e146 e146"><imagedata class="po-meta e147 e147" fileref="../../../vol10/graphics/Graham01/Graham01-007.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e148 e148"><textual class="po-textual">When the same XML is transformed with a stylesheet that uses the extension function and then formatted, the list item label widths are set based on the actual maximum formatted width of the labels in each list. The stylesheet constructs a test document containing just the list item label texts, uses the extension function to format that and get the area tree, and decides the maximum widths from the area tree. The document that is formatted mid-transform is, therefore, a different document to the one used to produce the final output.</textual></para><figure class="po-container e149 e149" xml:id="right"><title class="po-block e150 e150"><textual class="po-textual">Right list item label widths</textual></title><mediaobject class="po-container e151 e151"><imageobject class="po-container e152 e152"><imagedata class="po-meta e153 e153" fileref="../../../vol10/graphics/Graham01/Graham01-008.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><programlisting class="po-block e154 e154" xml:space="preserve"><textual class="po-textual">&lt;xsl:template name="main"&gt;
  &lt;!-- Make a test document containing only the list labels.  Re-use
       example markup rather than creating FOs directly just because
       it's convenient. --&gt;
  &lt;xsl:variable name="test-doc"&gt;
    &lt;example&gt;
      &lt;xsl:for-each select="key('lists', true())"&gt;
        &lt;box id="{@id}" width="3in" height="3in"&gt;
          &lt;xsl:for-each select="item/@label"&gt;
            &lt;paragraph&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/paragraph&gt;
          &lt;/xsl:for-each&gt;
        &lt;/box&gt;
      &lt;/xsl:for-each&gt;
    &lt;/example&gt;
  &lt;/xsl:variable&gt;
  &lt;!-- Save the FO tree from $test-doc in a variable. --&gt;
  &lt;xsl:variable name="fo_tree"&gt;
    &lt;xsl:apply-templates select="$test-doc" /&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="area_tree_file"
		select="concat($dest_dir, '/', $area_tree_filename)" /&gt;

  &lt;xsl:message&gt;Area tree filename = &lt;xsl:value-of select="$area_tree_file" /&gt;&lt;/xsl:message&gt;

  &lt;xsl:variable
      name="url"
      select="runfop:area-tree-url($fo_tree, $area_tree_file)"
      as="xs:string" /&gt;

  &lt;xsl:variable
      name="area-tree"
      select="document($url)"
      as="document-node()?" /&gt;

  &lt;xsl:variable name="overrides"&gt;
    &lt;overrides&gt;
      &lt;!-- Find the maximum label width for each list and convert to pt. --&gt;
      &lt;xsl:for-each select="key('lists', true())"&gt;
	&lt;xsl:variable name="id" select="@id" as="xs:string" /&gt;
	&lt;xsl:variable name="block"
		      select="key('blocks', $id, $area-tree)[1]" /&gt;
	&lt;override id="{$id}" label-width="{max($block//text/@ipd) div 1000}pt" /&gt;
      &lt;/xsl:for-each&gt;
    &lt;/overrides&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:apply-templates select="/"&gt;
    &lt;xsl:with-param name="overrides" select="$overrides" as="document-node()" tunnel="yes" /&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e155 e155"><textual class="po-textual">The examples so far haven't demonstrated anything that couldn't be done using two stylesheets in the manner of the PLOS ONE table handling.  The following example impements the oft-stated requirement for adjusting font size until text just fits a certain area.  Since that's an iterative process, it's more convenient to do that within on transformation rather than having to use shell scripts or Ant to run an XSLT processor on a preliminary stylesheet multiple times and examine the result each time.</textual></para><figure class="po-container e156 e156" xml:id="fill"><title class="po-block e157 e157"><textual class="po-textual">'font-size' adjusted so text fills box</textual></title><mediaobject class="po-container e158 e158"><imageobject class="po-container e159 e159"><imagedata class="po-meta e160 e160" fileref="../../../vol10/graphics/Graham01/Graham01-009.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><programlisting class="po-block e161 e161" xml:space="preserve"><textual class="po-textual">&lt;!-- Initial template --&gt;
&lt;xsl:template name="main"&gt;
  &lt;xsl:call-template name="do-box"&gt;
    &lt;xsl:with-param name="font-size" select="$font-size" as="xs:double" /&gt;
    &lt;xsl:with-param
        name="font-size.minimum" select="$font-size" as="xs:double" tunnel="yes" /&gt;
    &lt;xsl:with-param
        name="font-size.maximum" select="$font-size * 10" as="xs:double" tunnel="yes" /&gt;
    &lt;xsl:with-param name="iteration" select="1" as="xs:integer" /&gt;
    &lt;xsl:with-param name="iteration-max" select="30" as="xs:integer" tunnel="yes" /&gt;
    &lt;xsl:with-param name="tolerance" select="$tolerance" as="xs:double" tunnel="yes" /&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="do-box"&gt;
  &lt;xsl:param name="font-size" as="xs:double" /&gt;
  &lt;xsl:param name="font-size.minimum" as="xs:double" tunnel="yes" /&gt;
  &lt;xsl:param name="font-size.maximum" as="xs:double" tunnel="yes" /&gt;
  &lt;xsl:param name="iteration" select="1" as="xs:integer" /&gt;
  &lt;xsl:param name="iteration-max" select="5" as="xs:integer" tunnel="yes" /&gt;
  &lt;xsl:param name="tolerance" select="$tolerance" as="xs:double" tunnel="yes" /&gt;

  &lt;xsl:variable name="area_tree_filename_basename"
                select="replace($area_tree_filename, '\.[^.]+$', '')"
                as="xs:string" /&gt;
  &lt;xsl:variable name="area_tree_filename_suffix"
                select="tokenize($area_tree_filename, '\.')[last()]"
                as="xs:string" /&gt;
  &lt;xsl:variable name="area_tree_file"
		select="concat($dest_dir,
                               '/',
                               $area_tree_filename_basename,
                               '-',
                               $iteration,
                               '.',
                               $area_tree_filename_suffix)"
                as="xs:string" /&gt;

  &lt;xsl:message&gt;iteration = &lt;xsl:value-of select="$iteration" /&gt;&lt;/xsl:message&gt;
  &lt;xsl:message&gt;font-size = &lt;xsl:value-of select="$font-size" /&gt;&lt;/xsl:message&gt;
  &lt;xsl:message&gt;font-size.minimum = &lt;xsl:value-of select="$font-size.minimum" /&gt;&lt;/xsl:message&gt;
  &lt;xsl:message&gt;font-size.maximum = &lt;xsl:value-of select="$font-size.maximum" /&gt;&lt;/xsl:message&gt;
  &lt;xsl:message&gt;Area tree filename = &lt;xsl:value-of select="$area_tree_file" /&gt;&lt;/xsl:message&gt;

  &lt;xsl:variable name="overrides"&gt;
    &lt;overrides&gt;
      &lt;!-- Set the font size. --&gt;
      &lt;xsl:for-each select="key('boxes', true())"&gt;
	&lt;xsl:variable name="id" select="@id" as="xs:string" /&gt;
	&lt;override id="{$id}" font-size="{$font-size}" /&gt;
      &lt;/xsl:for-each&gt;
    &lt;/overrides&gt;
  &lt;/xsl:variable&gt;

  &lt;!-- Save the FO tree in a variable. --&gt;
  &lt;xsl:variable name="fo_tree"&gt;
    &lt;xsl:apply-templates select="/"&gt;
      &lt;xsl:with-param name="overrides" select="$overrides" as="document-node()" tunnel="yes" /&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable
      name="url"
      select="runfop:area-tree-url($fo_tree, $area_tree_file)"
      as="xs:string" /&gt;

  &lt;xsl:variable
      name="area-tree"
      select="document($url)"
      as="document-node()?" /&gt;

  &lt;xsl:variable
      name="bpd"
      select="key('blocks', key('boxes', true())[1]/@id, $area-tree)[1]/block/@bpd"
      as="xs:integer" /&gt;

  &lt;xsl:variable
      name="target-height"
      select="xs:double(substring-before(key('boxes', true())[1]/@height, 'pt'))"
      as="xs:double" /&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test="$iteration eq $iteration-max"&gt;
      &lt;xsl:message&gt;Maximum iterations.&lt;/xsl:message&gt;
      &lt;xsl:apply-templates select="/"&gt;
        &lt;xsl:with-param
            name="overrides"
            select="$overrides"
            as="document-node()"
            tunnel="yes" /&gt;
      &lt;/xsl:apply-templates&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$bpd div 1000 &gt; $target-height"&gt;
      &lt;xsl:call-template name="do-box"&gt;
        &lt;xsl:with-param
            name="font-size"
            select="($font-size + $font-size.minimum) div 2"
            as="xs:double" /&gt;
        &lt;xsl:with-param
            name="font-size.maximum"
            select="$font-size"
            as="xs:double"
            tunnel="yes" /&gt;
        &lt;xsl:with-param name="iteration" select="$iteration + 1" as="xs:integer" /&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="$target-height - ($bpd div 1000) &amp;lt;
                    $target-height * $tolerance div $target-height"&gt;
      &lt;xsl:message&gt;It fits.&lt;/xsl:message&gt;
      &lt;xsl:apply-templates select="/"&gt;
        &lt;xsl:with-param
            name="overrides"
            select="$overrides"
            as="document-node()"
            tunnel="yes" /&gt;
      &lt;/xsl:apply-templates&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:call-template name="do-box"&gt;
        &lt;xsl:with-param
            name="font-size"
            select="($font-size + $font-size.maximum) div 2"
            as="xs:double" /&gt;
        &lt;xsl:with-param
            name="font-size.mimimum"
            select="$font-size"
            as="xs:double"
            tunnel="yes" /&gt;
        &lt;xsl:with-param name="iteration" select="$iteration + 1" as="xs:integer" /&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e162 e162"><textual class="po-textual">The difficulty with the proof-of-concept extension function is that it's only a proof-of-concept -- getting the area tree back from the extension function is more complicated than it needs to be, and getting values from the area tree requires some comprehension of the FOP area tree XML.  If it is to be generally usable and usable with different XSL formatters, there should be a common area tree XML format into which vendor's area trees can be transformed and/or library functions for common area tree access operations.</textual></para></section><section class="po-hcontainer e163 e163"><title class="po-block e164 e164"><textual class="po-textual">Adapt Saxon-CE event model to XSL-FO?</textual></title><para class="po-block e165 e165"><textual class="po-textual">Using the proof-of-concept extension function, an
XSLT stylesheet can now make decisions about what to put in the result
based on the trial formatted size of areas, but as it's only a
proof-of-concept, it doesn't aim as high as getting feedback from or
modifying in-situ the area tree for the final, formatted document.</textual></para><para class="po-block e166 e166"><textual class="po-textual">Once people have tried a few things with getting feedback from the XSL
formatter and start asking their vendors for the same or better, they'll
also be wanting an interoperable way to express what to do with that
feedback.  For simple feedback of static area trees, which is all that is
possible with the current proof-of-concept, the most interoperability that
you could manage would be a common representation of area trees (with
flexibility for vendor extensions) and, possibly, a library of XSLT
functions to make it easier to navigate the area trees, but for "live"
feedback, something more would be required.</textual></para><para class="po-block e167 e167"><textual class="po-textual">The PPL CG has recently been looking at how Saxon-CE [SaxonCE] handles user input, and considering whether the same sort of pattern could be adapted to handling
feedback from the XSL formatter.  Saxon-CE does it through template
rules that match the element that receives the event and are in a mode
that reflects the type of event, and similarly an XSL formatter could
trigger on exceptional events such as overflow occurring or even on
mundane events such as completion of a page sequence, and the templates in
the corresponding modes could match on either FOs in the FO tree or areas
in the area tree.</textual></para><para class="po-block e168 e168"><textual class="po-textual">The following template from the "Knight's Tour" sample Saxon-CE
application is the event handler for when the user clicks the 'Reset'
button.  It simply writes a NO-BREAK SPACE to each square on the Knight's
chess board</textual></para><programlisting class="po-block e169 e169" xml:space="preserve"><textual class="po-textual">&lt;xsl:template match="button[@id='reset']" mode="ixsl:onclick"&gt;
  &lt;xsl:for-each select="//div[starts-with(@id, 'square')]"&gt;
     &lt;xsl:result-document href="#{@id}" method="replace-content"&gt;
       &lt;xsl:text&gt;&amp;amp;#xa0;&lt;/xsl:text&gt;
     &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e170 e170"><textual class="po-textual">The key feature of the event handler for the purposes of this discussion
is that it's written in plain old XSLT.  The advantage of the XSLT event
handler for Saxon-CE users is interactivity "without dropping down into
JavaScript" (as the Saxon-CE documentation so delicately puts it),
but the advantage for XSL-FO users would simply be that they don't need to
learn a new language (declarative, functional, or otherwise) to handle
feedback.  (And the advantage for those trying to define or
implement feedback is that they don't need to invent a whole new language to
handle it.)</textual></para><para class="po-block e171 e171"><textual class="po-textual">Applying the Saxon-CE approach to XSL-FO, the following conceptual FO
event handler would handle a figure overflowing its available space by
reducing its size to 80% of the current.</textual></para><programlisting class="po-block e172 e172" xml:space="preserve"><textual class="po-textual">&lt;xsl:template match="BlockArea[key('fig', @id, $src-doc)]"
              mode="ppl:overflow"&gt;
  &lt;xsl:result-document href="#{@id}/area:external-graphic"
                       method="replace-content"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*"/&gt;
      &lt;xsl:attribute name="width"
                     select="ppl:scale(area:external-graphic/@width,
                                       0.8)"/&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;</textual></programlisting><para class="po-block e173 e173"><textual class="po-textual">
An extra wrinkle for XSL-FO is the question of whether event handlers
should be specified to (a) match on, and (b) modify the FO tree or the
area tree or both.  There are some existing requirements that can only be
satisfied by modifying the area tree, e.g., Section 3.3, Output result of
expression:</textual></para><blockquote class="po-container e174 e174"><para class="po-block e175 e175"><textual class="po-textual">Allow users to output the result of expressions on area tree,
   traits, markers or text content. For example to calculate the
   subtotal of a certain page (as opposed to a running total that
   is already supported in XSL 1.1 with table markers)</textual></para></blockquote><para class="po-block e176 e176"><textual class="po-textual">On the other hand, it will often be simpler (from the user's perspective)
to modify an FO rather than all the areas that it generates, since a
single FO may generate multiple areas across several columns or pages (and
footnote areas), and its content may be reused in markers on multiple
pages.  If, for example, the response to a page sequence taking too many
pages is to reduce the font size in one of the multiple flows appearing on
the page, it would be at once simple to adjust the 'font-size' property on
the appropriate FOs in the FO tree and inaccurate to directly modify font
sizes in the line areas in the area tree.  If the XSL formatter did the
work based on modified FOs, it would reflow the line areas based on their
reduced font size and make the pages again and the resulting modified
block areas would break across pages in different places because of the
smaller font size.  If the XSLT stylesheet did the work by modifying the
area tree, it would have to do the same recalculating of text sizes and
the same merging or splitting of line areas and of block areas, and all
(probably) without the benefit of font metrics.  It might work, just, in a
simple case with only monospace fonts, but would still be a lot of work to
do in XSLT.</textual></para><para class="po-block e177 e177"><textual class="po-textual">Adapting the Saxon-CE event model to XSL-FO is, therefore, an interesting
possible solution to handling feedback from the XSL formatter, but there
are still many FO-specific details that would have to be worked out.</textual></para></section></section><section class="po-hcontainer e178 e178"><title class="po-block e179 e179"><textual class="po-textual">Conclusion</textual></title><para class="po-block e180 e180"><textual class="po-textual">The linear processing model of XSL 1.1 has served it will -- and, in the XSL 1.0 timeframe, helped it towards becoming a Recommendation -- but real world use cases have forced users into doing multi-pass processing and other tricks so they can make decisions on what to put in the formatted output based on sizes in the formatted output.  The XSL-FO 2.0 requirements document recognised some of these requirements, but the XPPL WG's charter expired without XSL-FO 2.0 being completed.  Since then, the Print and Page Layout Community Group at the W3C has been producing innovative ideas and solutions to help satisfy the user requirements for more decision making in XSL-FO processing.</textual></para></section><bibliography class="po-hcontainer e181 e181"><title class="po-block e182 e182"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e183 e183" xml:id="CustReq" xreflabel="CustReq"><textual class="po-textual">Frequently and less frequently stated requirements by print customers, </textual><link class="po-inline e184 e184" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/community/ppl/wiki/CustomerRequirements</textual></link></bibliomixed><bibliomixed class="po-block e185 e185" xml:id="DSSSL" xreflabel="DSSSL"><textual class="po-textual">ISO/IEC 10179:1996 Information technology - Processing languages - Document Style Semantics and Specification Language (DSSSL),
</textual><link class="po-inline e186 e186" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xml.coverpages.org/dsssl96-ps.zip</textual></link><textual class="po-textual"> (from </textual><link class="po-inline e187 e187" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xml.coverpages.org/dsssl.html</textual></link><textual class="po-textual">)</textual></bibliomixed><bibliomixed class="po-block e188 e188" xml:id="FOP" xreflabel="FOP"><textual class="po-textual">Apache™ FOP, </textual><link class="po-inline e189 e189" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xmlgraphics.apache.org/fop/</textual></link></bibliomixed><bibliomixed class="po-block e190 e190" xml:id="FOPRunXSLTExt" xreflabel="FOPRunXSLTExt"><link class="po-inline e191 e191" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/community/ppl/wiki/FOPRunXSLTExt</textual></link></bibliomixed><bibliomixed class="po-block e192 e192" xml:id="Hahn" xreflabel="Hahn"><textual class="po-textual">Re: Customer requirement, a critque, </textual><link class="po-inline e193 e193" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://lists.w3.org/Archives/Public/public-ppl/2013Feb/0078.html</textual></link></bibliomixed><bibliomixed class="po-block e194 e194" xml:id="JADE" xreflabel="JADE"><textual class="po-textual">Jade - James' DSSSL Engine, 
</textual><link class="po-inline e195 e195" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jclark.com/jade/</textual></link></bibliomixed><bibliomixed class="po-block e196 e196" xml:id="PLOS" xreflabel="PLOS"><textual class="po-textual">What is PLOS?,
</textual><link class="po-inline e197 e197" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.plos.org/about/what-is-plos/</textual></link></bibliomixed><bibliomixed class="po-block e198 e198" xml:id="PONE" xreflabel="PONE"><textual class="po-textual">PLOS ONE,
</textual><link class="po-inline e199 e199" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.plosone.org/</textual></link></bibliomixed><bibliomixed class="po-block e200 e200" xml:id="PONEManuscript" xreflabel="PONEManuscript"><textual class="po-textual">PLOS ONE Manuscript Guidelines,
</textual><link class="po-inline e201 e201" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.plosone.org/static/guidelines</textual></link></bibliomixed><bibliomixed class="po-block e202 e202" xml:id="PPL" xreflabel="PPL"><textual class="po-textual">Print and Page Layout Community Group,
</textual><link class="po-inline e203 e203" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/community/ppl/</textual></link></bibliomixed><bibliomixed class="po-block e204 e204" xml:id="SaxonCE" xreflabel="SaxonCE"><link class="po-inline e205 e205" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.saxonica.com/ce/user-doc/1.1/index.html</textual></link></bibliomixed><bibliomixed class="po-block e206 e206" xml:id="Speedata" xreflabel="Speedata"><textual class="po-textual">Fully automatic database publishing with the speedata Publisher,
</textual><link class="po-inline e207 e207" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/sessions/#speedata</textual></link></bibliomixed><bibliomixed class="po-block e208 e208" xml:id="TableWrap" xreflabel="TableWrap"><textual class="po-textual">table-wrap, Journal Archiving and Interchange Tag Library NISO JATS version 1.0, </textual><link class="po-inline e209 e209" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jats.nlm.nih.gov/archiving/tag-library/1.0/index.html?elem=table-wrap</textual></link></bibliomixed><bibliomixed class="po-block e210 e210" xml:id="XSL11" xreflabel="XSL11"><textual class="po-textual">Extensible Stylesheet Language (XSL) Version 1.1,
</textual><link class="po-inline e211 e211" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xsl11/</textual></link></bibliomixed><bibliomixed class="po-block e212 e212" xml:id="XSLCRTest" xreflabel="XSLCRTest"><textual class="po-textual">XSL CR Test Suite -- Test Coverage,
</textual><link class="po-inline e213 e213" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/Style/XSL/TestSuite/coverage/testcoverage.html</textual></link></bibliomixed><bibliomixed class="po-block e214 e214" xml:id="XSLFO20-Req" xreflabel="XSLFO20-Req"><textual class="po-textual">Extensible Stylesheet Language (XSL) Requirements Version 2.0,
</textual><link class="po-inline e215 e215" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslfo20-req/</textual></link></bibliomixed><bibliomixed class="po-block e216 e216" xml:id="XSLReq" xreflabel="XSLReq"><textual class="po-textual">XSL Requirements Summary,
</textual><link class="po-inline e217 e217" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/1998/WD-XSLReq-19980511.html</textual></link></bibliomixed></bibliography></article></classedDocument>