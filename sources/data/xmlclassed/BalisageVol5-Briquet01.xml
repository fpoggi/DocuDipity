<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">A Virtualization-Based Retrieval and Update API for XML-Encoded Corpora</textual><footnote class="po-popup e2 e2" xml:id="CNRSDETCOLGrant"><para class="po-block e3 e3"><textual class="po-textual">The research reported in this paper was supported by grant ANR-06-CORP-007-03.</textual></para></footnote></title><info class="po-record e4 e4"><confgroup class="po-record e5 e5"><conftitle class="po-field e6 e6"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e7 e7"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e8 e8"><para class="po-block e9 e9"><textual class="po-textual">Providing support for flexible automated tagging of text-oriented XML documents (i.e. text with intersparsed markup) is a challenging issue.
This requires support for tag-aware full text search (i.e. the capability to skip some tags or make invisible whole sections of the document), match points, and transparent updates.
An API addressing this issue is described.
Based on the virtualization of selected sections of the XML document, the API produces a tag-aware representation, backed by the document, that is transparently searchable (using keyword search or regular expressions) and updatable, offering support for </textual><emphasis class="po-inline e10 e10"><textual class="po-textual">natural linguistic reasoning</textual></emphasis><textual class="po-textual">.</textual></para></abstract><author class="po-record e11 e11"><personname class="po-record e12 e12"><firstname class="po-field e13 e13"><textual class="po-textual">Cyril</textual></firstname><surname class="po-field e14 e14"><textual class="po-textual">Briquet</textual></surname></personname><personblurb class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Dr. Cyril Briquet received the PhD degree in Computing Science from the University of Liège in 2008.
His research interests include distributed systems and algorithmics, with a particular focus on efficiency and scalability.
In 2007, he introduced the first fully Peer-to-Peer Grid middleware (i.e. both P2P computations as well as BitTorrent-based P2P data transfers).
During his stay at </textual><link class="po-inline e17 e17" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> in Nancy in 2008-2009</textual><footnote class="po-popup e18 e18" xml:id="CyrilBriquetAtCNRS"><para class="po-block e19 e19"><textual class="po-textual">The majority of the research reported here was conducted while Cyril Briquet was at </textual><link class="po-inline e20 e20" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> in 2008-2009.</textual></para></footnote><textual class="po-textual">, he implemented algorithms for the automatic detection of fields of information in XML-encoded corpora.
Now at McMaster University as a Postdoctoral Fellow in Digital Humanities and High Performance Computing, he is working to scale out the analytics back-end of the Voyeur Tools text analytics software.</textual></para></personblurb><affiliation class="po-record e21 e21"><jobtitle class="po-field e22 e22"><textual class="po-textual">Postdoctoral Fellow in Digital Humanities and High Performance Computing</textual></jobtitle><orgname class="po-block e23 e23"><link class="po-inline e24 e24" xlink:actuate="onRequest" xlink:href="http://www.mcmaster.ca/" xlink:show="new" xlink:type="simple"><textual class="po-textual">McMaster University</textual></link></orgname></affiliation><affiliation class="po-record e25 e25"><jobtitle class="po-field e26 e26"><textual class="po-textual">Research Engineer</textual></jobtitle><orgname class="po-block e27 e27"><link class="po-inline e28 e28" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ATILF</textual></link><textual class="po-textual"> (</textual><link class="po-inline e29 e29" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> &amp; </textual><link class="po-inline e30 e30" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Nancy-Université</textual></link><textual class="po-textual">)</textual></orgname></affiliation><email class="po-field e31 e31"><textual class="po-textual">cyril.briquet@acm.org</textual></email></author><author class="po-record e32 e32"><personname class="po-record e33 e33"><firstname class="po-field e34 e34"><textual class="po-textual">Pascale</textual></firstname><surname class="po-field e35 e35"><textual class="po-textual">Renders</textual></surname></personname><personblurb class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual">Pascale Renders holds one diploma in Romance languages as well as one diploma in Classics. She is currently completing her PhD studies at University of Liège, in partnership with the </textual><link class="po-inline e38 e38" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ATILF</textual></link><textual class="po-textual"> lab (Nancy). Her doctoral research topic is the digitization of the Französisches Etymologisches Wörterbuch (FEW), which is the reference etymological and historical dictionary in the Gallo-Roman area. Besides Lexicography and Natural Language Processing, her research interests also encompass Diachronic Linguistics of Romance languages, specifically the key era where Latin evolved into French.</textual></para></personblurb><affiliation class="po-record e39 e39"><jobtitle class="po-field e40 e40"><textual class="po-textual">PhD student</textual></jobtitle><orgname class="po-block e41 e41"><link class="po-inline e42 e42" xlink:actuate="onRequest" xlink:href="http://www.ulg.ac.be/" xlink:show="new" xlink:type="simple"><textual class="po-textual">University of Liège</textual></link></orgname></affiliation><affiliation class="po-record e43 e43"><jobtitle class="po-field e44 e44"><textual class="po-textual">PhD student</textual></jobtitle><orgname class="po-block e45 e45"><link class="po-inline e46 e46" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ATILF</textual></link><textual class="po-textual"> (</textual><link class="po-inline e47 e47" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> &amp; </textual><link class="po-inline e48 e48" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Nancy-Université</textual></link><textual class="po-textual">)</textual></orgname></affiliation><email class="po-field e49 e49"><textual class="po-textual">pascale.renders@ulg.ac.be</textual></email></author><author class="po-record e50 e50"><personname class="po-record e51 e51"><firstname class="po-field e52 e52"><textual class="po-textual">Etienne</textual></firstname><surname class="po-field e53 e53"><textual class="po-textual">Petitjean</textual></surname></personname><personblurb class="po-container e54 e54"><para class="po-block e55 e55"><textual class="po-textual">Etienne Petitjean is a Research Engineer at the </textual><link class="po-inline e56 e56" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ATILF</textual></link><textual class="po-textual"> laboratory (</textual><link class="po-inline e57 e57" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> &amp; </textual><link class="po-inline e58 e58" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Nancy-Université</textual></link><textual class="po-textual">).</textual></para></personblurb><affiliation class="po-record e59 e59"><jobtitle class="po-field e60 e60"><textual class="po-textual">Research Engineer</textual></jobtitle><orgname class="po-block e61 e61"><link class="po-inline e62 e62" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ATILF</textual></link><textual class="po-textual"> (</textual><link class="po-inline e63 e63" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">CNRS</textual></link><textual class="po-textual"> &amp; </textual><link class="po-inline e64 e64" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Nancy-Université</textual></link><textual class="po-textual">)</textual></orgname></affiliation><email class="po-field e65 e65"><textual class="po-textual">etienne.petitjean@atilf.fr</textual></email></author><legalnotice class="po-container e66 e66"><para class="po-block e67 e67"><textual class="po-textual">Copyright © 2010 Cyril Briquet, Pascale Renders, Etienne Petitjean. All rights reserved. Used by permission.</textual></para></legalnotice><keywordset class="po-table e68 e68" role="author"><keyword class="po-field e69 e69"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e70 e70"><textual class="po-textual">corpus</textual></keyword><keyword class="po-field e71 e71"><textual class="po-textual">API</textual></keyword><keyword class="po-field e72 e72"><textual class="po-textual">text</textual></keyword><keyword class="po-field e73 e73"><textual class="po-textual">retrieval</textual></keyword><keyword class="po-field e74 e74"><textual class="po-textual">update</textual></keyword><keyword class="po-field e75 e75"><textual class="po-textual">algorithm</textual></keyword><keyword class="po-field e76 e76"><textual class="po-textual">virtual</textual></keyword><keyword class="po-field e77 e77"><textual class="po-textual">virtualization</textual></keyword><keyword class="po-field e78 e78"><textual class="po-textual">string</textual></keyword><keyword class="po-field e79 e79"><textual class="po-textual">context</textual></keyword></keywordset></info><section class="po-hcontainer e80 e80"><title class="po-block e81 e81"><textual class="po-textual">Introduction</textual></title><section class="po-hcontainer e82 e82"><title class="po-block e83 e83"><textual class="po-textual">Problem domain</textual></title><para class="po-block e84 e84"><textual class="po-textual">XML-encoding a textual corpus is typically achieved through manual tagging,
i.e. by human operators using a text editor or specialized annotation software,
or through the application of algorithms that complete the tagging on the basis of a known schema.
</textual></para><para class="po-block e85 e85"><textual class="po-textual">The problem we address in this paper is to provide an algorithmic substrate,
made accessible through an Application Programming Interface (API),
to achieve automated tagging [</textual><xref class="po-milestone e86 e86" linkend="ren07a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e87 e87" linkend="ren09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e88 e88" linkend="bri09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
of the digitized version of one of the most complex paper dictionaries.
This dictionary is the Französisches Etymologisches Wörterbuch (FEW) [</textual><xref class="po-milestone e89 e89" linkend="projectfew"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e90 e90" linkend="war22a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
The FEW is the historical and etymological dictionary of the languages of the gallo-roman area
(i.e. French, Franco-Provençal, Occitan and Gascon in all of their diatopic variations),
written over the course of more than eighty years.</textual></para><para class="po-block e91 e91"><textual class="po-textual">Each article of the FEW describes all derived words (i.e. lexemes) of a given root word (i.e. etymon) [</textual><xref class="po-milestone e92 e92" linkend="buc96a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],
instead of (as happens in most etymological dictionaries) describing the root word of a given derived word.
Of course, several fields of information are offered for each article, such as the etymon and the language in which this etymon originates, the signature of the article, footnotes.
The structure of the article is emphasized through hierarchical numbering and labeling of groups of paragraphs and cross-references to these.
Several fields of information are offered for each lexeme,
including but not limited to geolinguistic labels, bibliographical references to attestations of the lexeme
and the definition of the lexeme.
All of these types of information are well-delineated, thus good candidates for tagging.
In a nutshell, each article of the FEW is a highly structured text that can be described through a model [</textual><xref class="po-milestone e93 e93" linkend="buc96a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and thus algorithmically processed.</textual></para><para class="po-block e94 e94"><textual class="po-textual">Besides these semantic types of information that are expected to be identified through automated tagging, formatting markup (such as paragraph, bold, italic, exponent, break tags such as end of line or end of column,...) is also available in each article following the digitization process (the formatting markup is added either manually or through OCR). This enables an on-screen visualization of articles that is faithful to the paper version of the dictionary. The availability of paragraph tags is important not only to properly format the articles, but to make accessible a first level of structuring of the article. Likewise, the availability of break tags enables to correctly tag some types of semantic types of information. Many hyphens indeed do not indicate that a long word is being cut at the end of the line where they are found, but instead convey semantic information (e.g. as part of affixes). And there is no straightforward way to automatically disambiguate the syntactic uses from the semantic uses of hyphens at the end of lines in the FEW dictionary.</textual></para><para class="po-block e95 e95"><textual class="po-textual">To put the FEW dictionary [</textual><xref class="po-milestone e96 e96" linkend="projectfew"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e97 e97" linkend="war22a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] in perspective, here is a quick comparison with another complex dictionary, the well-known Oxford English Dictionary (OED) [</textual><xref class="po-milestone e98 e98" linkend="oed"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Whereas the markup used to encode OED articles is proprietary SGML [</textual><xref class="po-milestone e99 e99" linkend="oed"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], the markup used to encode FEW articles is standard XML complying with an XML Schema [</textual><xref class="po-milestone e100 e100" linkend="bri09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The FEW markup is referred to as FFML (FEW Font-style Markup Language) for files input to the automated tagging process. It is referred to as FSML (FEW Semantic Markup Language) for files output by the automated tagging process. FSML is comprised of mostly a superset of FFML, that is augmented with semantic markup. There currently exists no in-depth comparison of the scopes of the OED and FEW markups, and it is clear that there are differences if only because FEW entries are etymons instead of, typically, lexemes. Nonetheless, in very general terms, both markups are intended to encode dictionary articles and it is not surprising to see many common features. The FEW dictionary, though, is considered to be one of the most complex dictionaries in the world [</textual><xref class="po-milestone e101 e101" linkend="buc96a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], notably because of the ever-present implicitness of many types of information. The Table here below provides a shallow quantitative comparison of both dictionaries.

</textual><table class="po-container e102 e102"><caption class="po-container e103 e103"><para class="po-block e104 e104"><textual class="po-textual">Shallow quantitative comparison of OED [</textual><xref class="po-milestone e105 e105" linkend="oedwiki"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and FEW [</textual><xref class="po-milestone e106 e106" linkend="buc96a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]</textual></para></caption><thead class="po-container e107 e107"><tr class="po-table e108 e108"><th class="po-field e109 e109"><textual class="po-textual">Feature</textual></th><th class="po-field e110 e110"><textual class="po-textual">OED</textual></th><th class="po-field e111 e111"><textual class="po-textual">FEW</textual></th><th class="po-field e112 e112"><textual class="po-textual">Comment</textual></th></tr></thead><tbody class="po-table e113 e113"><tr align="right" class="po-table e114 e114"><td align="center" class="po-block e115 e115"><textual class="po-textual">Pages</textual></td><td class="po-block e116 e116"><textual class="po-textual">21730</textual></td><td class="po-block e117 e117"><textual class="po-textual">16865</textual></td></tr><tr align="right" class="po-table e118 e118"><td align="center" class="po-block e119 e119"><textual class="po-textual">Volumes</textual></td><td class="po-block e120 e120"><textual class="po-textual">20</textual></td><td class="po-block e121 e121"><textual class="po-textual">25</textual></td></tr><tr align="right" class="po-table e122 e122"><td align="center" class="po-block e123 e123"><textual class="po-textual">Entries</textual></td><td class="po-block e124 e124"><textual class="po-textual">300000</textual></td><td class="po-block e125 e125"><textual class="po-textual">20000</textual></td><td class="po-block e126 e126"><textual class="po-textual">FEW entries are etymons, not lexemes, thus fewer</textual></td></tr><tr align="right" class="po-table e127 e127"><td align="center" class="po-block e128 e128"><textual class="po-textual">Lexemes</textual></td><td class="po-block e129 e129"><textual class="po-textual">600000</textual></td><td class="po-block e130 e130"><textual class="po-textual">900000 (*)</textual></td><td class="po-block e131 e131"><textual class="po-textual">(*) back-of-the-envelop estimate</textual></td></tr></tbody></table><textual class="po-textual">
</textual></para></section><section class="po-hcontainer e132 e132"><title class="po-block e133 e133"><textual class="po-textual">Importance of the problem</textual></title><para class="po-block e134 e134"><textual class="po-textual">Semantically tagging the articles of the FEW is a multi-year linguistics research project [</textual><xref class="po-milestone e135 e135" linkend="ren07a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] that is tremendously important to the historical linguistics community.
Merely digitizing the FEW, without further processing would only enable full text search.
Tagging the various fields of information would also enable so-called lateral search over the whole dictionary.
Semantic tagging would disambiguate and resolve the implicitness of most of the fields of information contained in the dictionary.</textual></para><para class="po-block e136 e136"><textual class="po-textual">Given the extreme linguistic complexity of the FEW, only highly-trained human experts
could theoretically do the job. But there are not enough of them
to process the twenty thousand articles of the FEW
and this would be a tedious, error-prone job anyway.
It was thus decided to use algorithmic automation to tag the fields of information of the FEW [</textual><xref class="po-milestone e137 e137" linkend="ren09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
Even though the articles of the FEW (implicitly) constitute a highly specialized textual corpus,
we believe that the problem can be sufficiently abstracted
so that our proposed approach is also relevant to other endeavors,
particularly the processing of text-oriented XML documents (i.e. text with intersparsed markup) such as text corpora.</textual></para></section><section class="po-hcontainer e138 e138"><title class="po-block e139 e139"><textual class="po-textual">Scope of the problem</textual></title><para class="po-block e140 e140"><textual class="po-textual">The input of our project is comprised of XML documents,
each of which represents an article of the FEW and includes basic layout tags (article, paragraphs, bold, italic,...)
that were added by human encoders and/or by OCR software.
Obviously, all textual contents are eventually enclosed in paragraph and article tags.
Nonetheless, the element hierarchy is often not the prime model of choice when accessing the FEW.
Identifying fields of information in the FEW indeed focuses on linear regions of text where elements can be nested in many ways.
Thus a very important property is that an FEW article should be considered as a text-oriented XML document,
i.e. a text with intersparsed tags rather than a tree of elements with some textual contents found in the leaves.</textual></para><para class="po-block e141 e141"><textual class="po-textual">The objective of our project is ultimately to add semantic markup around fields of information within a text-oriented XML document
(fields of information of interest are listed in the Problem domain section here above).
This requires to first identify these fields of information, then accordingly update the XML document.</textual></para><para class="po-block e142 e142"><textual class="po-textual">Each article of the FEW dictionary typically features multiple occurrences of 25 or so types of information [</textual><xref class="po-milestone e143 e143" linkend="buc96a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], each of which is detected and tagged by a specific tagging algorithm (see Figure 1 here below).</textual></para><figure class="po-container e144 e144" xml:id="few-tagging-sequence" xreflabel="few-tagging-sequence"><mediaobject class="po-container e145 e145"><imageobject class="po-container e146 e146"><imagedata class="po-meta e147 e147" fileref="../../../vol5/graphics/Briquet01/Briquet01-001.png" format="png" width="360"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">FEW tagging sequence</textual></para></caption></mediaobject></figure><para class="po-block e150 e150"><textual class="po-textual">As the dependency graph of tagging algorithms is acyclic, it is possible - though not straightforward - to determine the sequence in which they should be applied (the so-called retroconversion sequence, e.g. tag definitions, then geolinguistic labels, then bibliographic labels,...) [</textual><xref class="po-milestone e151 e151" linkend="ren09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e152 e152" linkend="bri09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. An important property is that the order in which tags are inserted into the XML document representing an FEW article is known. Therefore, when designing a tagging algorithm, one knows which types of information have previously been tagged - and thus which ones might interfere with information retrieval and updates.</textual></para><para class="po-block e153 e153"><textual class="po-textual">Identification of fields of information in an FEW article by a tagging algorithm is typically based on several retrieval primitives:
keyword search, matching of regular expressions (regexp), 
as well as matching of contextual tag sequences.
Most algorithms rely on a combination of several of these primitives,
often in non-straightforward ways that involve secondary lookups in the contexts surrounding initial matches.
The linguistic challenge resides in handcrafting combinations of retrieval primitives that lead to accurate identification of types of informations.
As the design and implementation of tagging algorithms is beyond the scope of this paper,
we now concentrate on issues that arise from the stated information retrieval requirements.</textual></para><para class="po-block e154 e154"><textual class="po-textual">Among the issues that make information retrieval in the FEW quite challenging, two classes of issues stand out:

</textual><itemizedlist class="po-table e155 e155"><listitem class="po-container e156 e156"><para class="po-block e157 e157"><textual class="po-textual">Firstly, some keyword search may be relevant only in some selected contexts, i.e. would lead to false positives if applied to irrelevant contexts.</textual></para></listitem><listitem class="po-container e158 e158"><para class="po-block e159 e159"><textual class="po-textual">Secondly, the presence of some tags, e.g. such as exponent or end of line tags,
within words or groups of words may prevent the matching of keywords and regular expressions, thus leading to false negatives.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e160 e160"><textual class="po-textual">Update of (the XML document representing) an FEW article by a tagging algorithm typically
includes the insertion, removal, displacement or update of text,
as well as the insertion, displacement or removal of tags.
The possible presence of many types of tags within updated text regions
increases the complexity of update operations,
as these should preserve the well-formedness of the XML document.
Moreover, the tagging of a text region might be decided based on the identification of patterns in a neighboring text region. Support for match points is thus very important, as the locus of where to insert a tag is most often decided based on offsets in the textual representation of the XML document (these offsets being sometimes far away from the XML node whose contents were matched in the identification phase), not relative to tags of the XML document.</textual></para><para class="po-block e161 e161"><textual class="po-textual">In addition to these retrieval and update challenges, one  must keep in mind that the semantic tagging of FEW is a research project [</textual><xref class="po-milestone e162 e162" linkend="ren07a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] whose object of study is a very complex dictionary. Concretely, another layer added to these challenges resides in the lack of knowledge of where tags can appear in the text. Even though it might be known that a given tag type is always included in a specific parent element, this provides no information on where the given tag appears among the textual content of its englobing element. This is the kind of challenge one must face when searching both markup and textual contents at the same time [</textual><xref class="po-milestone e163 e163" linkend="stl01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e164 e164"><textual class="po-textual">This leads to the following additional requirement: A mechanism must be provided to flexibly and easily configure
the contexts where retrieval and update operations will be applied. This is a challenging requirement, as we desire to provide users of the mechanism
a way to think of the dictionary and express themselves in a familiar environment: text without tags.</textual></para><para class="po-block e165 e165"><textual class="po-textual">What is required is thus a mechanism that enables flexible, dynamic, tag-aware retrieval and update in a text-oriented XML document,
in order to support </textual><emphasis class="po-inline e166 e166"><textual class="po-textual">natural linguistic reasoning</textual></emphasis><textual class="po-textual">.
Based on our review of the state of the art presented in the section of this paper discussing related works (see below),
we are not aware of any existing XML technology that addresses all of these requirements, specifically the provision of a familiar environment to users of the mechanism.</textual></para></section><section class="po-hcontainer e167 e167"><title class="po-block e168 e168"><textual class="po-textual">Our Approach</textual></title><para class="po-block e169 e169"><textual class="po-textual">The key principle of our approach to the tag-aware retrieval and update problem
is the virtualization of the text-oriented XML document.
We propose a mechanism to allow one to easily construct,
through an Application Programming Interface (API),
a representation of selected sections of the XML document
from which types of tags leading to ambiguities - as well as their contents, if required -
have been removed.
In practice, sections of the XML document are virtualized
into multiple virtual strings, separated by so-called visible tags,
according to dynamically-defined tag visibility rules.
A definition of the virtual string data structure is provided in a further section;
intuitively, a virtual string is the concatenation of adjacent text chunks,
except those within elements that are configured to not be added to the virtual string.</textual></para><para class="po-block e170 e170"><textual class="po-textual">For example, this section of XML document: </textual><code class="po-atom e171 e171"><textual class="po-textual">&lt;X&gt;&lt;Y&gt;some nice text&lt;/Y&gt; &lt;Z&gt;and text to be made invisible&lt;/Z&gt; and &lt;W&gt;finally&lt;/W&gt; &lt;Y&gt;nice text again&lt;/Y&gt;&lt;/X&gt;</textual></code><textual class="po-textual"> is virtualized into these three virtual strings: (1) </textual><code class="po-atom e172 e172"><textual class="po-textual">some nice text</textual></code><textual class="po-textual">, (2) </textual><code class="po-atom e173 e173"><textual class="po-textual">and finally</textual></code><textual class="po-textual"> and (3) </textual><code class="po-atom e174 e174"><textual class="po-textual">nice text again</textual></code><textual class="po-textual">, if using the following configuration: </textual><code class="po-atom e175 e175"><textual class="po-textual">&lt;X&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e176 e176"><textual class="po-textual">&lt;Y&gt;</textual></code><textual class="po-textual"> tags should stop the virtualization mechanism, </textual><code class="po-atom e177 e177"><textual class="po-textual">&lt;Z&gt;</textual></code><textual class="po-textual"> tags as well as their contents (if considered as elements) should be made invisible, and </textual><code class="po-atom e178 e178"><textual class="po-textual">&lt;W&gt;</textual></code><textual class="po-textual"> tags (not their contents, if considered as elements) should be made invisible.</textual></para><para class="po-block e179 e179"><textual class="po-textual">How do API users benefit from the virtualization? With ambiguity abstracted away through an appropriate configuration of what tags should be made invisible (with or without their contents, if considered as elements), the representation of the XML document as a sequence of virtual strings
is more easily searchable, simplifying retrieval (keyword search, regexp matching, contextual tag sequence matching).</textual></para><para class="po-block e180 e180"><textual class="po-textual">Importantly, each virtual string is backed by the underlying XML document. Updates to a virtual string
are thus transparently propagated to the document.
Therefore, this constructed representation is also easily updatable.</textual></para><para class="po-block e181 e181"><textual class="po-textual">Our approach shares the intent of the Regular Fragmentations
mechanism proposed by Simon St.Laurent [</textual><xref class="po-milestone e182 e182" linkend="stl01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e183 e183" linkend="rfg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
and of the XML Fragments mechanism introduced by Carmel et al. [</textual><xref class="po-milestone e184 e184" linkend="car03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],
to the extent that we wish to devise a transparent mechanism that enables
mixed-information (text/markup) retrieval in a text-oriented XML document.
Our proposed virtualization mechanism
may be viewed as a dynamic, more flexible and - importantly - updatable version
of the Reading Context mechanism introduced by Xavier Tannier [</textual><xref class="po-milestone e185 e185" linkend="tan05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
Mixed-information (text/markup) retrieval is provided by our proposed virtualization mechanism
through the backing of virtual strings by the underlying XML document.
The tag visibility model on which our proposed virtualization mechanism relies
is an extended version (with slightly different semantics) of the tag visibility model initially introduced by Lini et al. [</textual><xref class="po-milestone e186 e186" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
and used by Tannier [</textual><xref class="po-milestone e187 e187" linkend="tan05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
Our proposed API is comprised of exactly the operations that are required to digitize
the FEW dictionary [</textual><xref class="po-milestone e188 e188" linkend="projectfew"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e189 e189" linkend="war22a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], no more, no less.
Nonetheless, we believe it is sufficiently general and extensible
to be useful to other text-oriented XML document processing needs.</textual></para><para class="po-block e190 e190"><textual class="po-textual">The rest of this paper is structured as follows.
Typical use cases are first described in order to ground our work into real, concrete, albeit basic examples.
Hypothetical use cases are also provided, in order to situate our work within a broader context.
The proposed XML document retrieval and update API is then introduced.
Related works are subsequently reviewed and their relationships with our work are explored.
Finally, concluding remarks put the proposed API into perspective.</textual></para></section></section><section class="po-hcontainer e191 e191"><title class="po-block e192 e192"><textual class="po-textual">Typical Use Cases</textual></title><para class="po-block e193 e193"><textual class="po-textual">Four typical use cases gathered here below illustrate how our proposed API can help design tagging algorithms [</textual><xref class="po-milestone e194 e194" linkend="ren09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The use cases highlight two major classes of information retrieval issues encountered in semantically tagging the FEW dictionary (false positives, false negatives).</textual></para><section class="po-hcontainer e195 e195"><title class="po-block e196 e196"><textual class="po-textual">Use case 1: avoidance of false positives for regular expression matching</textual></title><para class="po-block e197 e197"><textual class="po-textual">In this use case, the objective is to tag dates. To search for dates, a regular expression is applied to the full text version of the XML document.</textual></para><para class="po-block e198 e198"><textual class="po-textual">Input (FEW 2, 982b, completus):
</textual><programlisting class="po-block e199 e199" xml:space="preserve"><textual class="po-textual">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;com-&lt;lb merge="no"/&gt;
plètement&lt;/i&gt; &lt;def&gt;„action de mettre au complet“&lt;/def&gt; (seit 1750,&lt;lb merge="no"/&gt;
text in &lt;biblio&gt;Fér 1787&lt;/biblio&gt;).</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e200 e200"><textual class="po-textual">Expected output, one </textual><code class="po-atom e201 e201"><textual class="po-textual">&lt;date&gt;</textual></code><textual class="po-textual"> tag inserted:
</textual><programlisting class="po-block e202 e202" xml:space="preserve"><textual class="po-textual">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;com-&lt;lb merge="no"/&gt;
plètement&lt;/i&gt; &lt;def&gt;„action de mettre au complet“&lt;/def&gt; (seit &lt;date&gt;1750&lt;/date&gt;,&lt;lb merge="no"/&gt;
text in &lt;biblio&gt;Fér 1787&lt;/biblio&gt;).</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e203 e203"><textual class="po-textual">If all tags were removed prior to full text search, the string </textual><quote class="po-inline e204 e204"><textual class="po-textual">1787</textual></quote><textual class="po-textual"> would be matched as a licit date. This would lead to a false positive as it has already been tagged as part of a bibliographical reference.</textual></para><para class="po-block e205 e205"><textual class="po-textual">Instead, </textual><code class="po-atom e206 e206"><textual class="po-textual">&lt;biblio&gt;</textual></code><textual class="po-textual"> tags (as well as others, in practice) should be made totally invisible, their contents included, prior to full text search. The full text to which the search operation is applied thus becomes:
</textual><programlisting class="po-block e207 e207" xml:space="preserve"><textual class="po-textual">Nfr. complètement „action de mettre au complet“ (seit 1750, text in ).</textual></programlisting><textual class="po-textual">
</textual></para></section><section class="po-hcontainer e208 e208"><title class="po-block e209 e209"><textual class="po-textual">Use case 2: avoidance of false positives for keyword search</textual></title><para class="po-block e210 e210"><textual class="po-textual">In this use case, the objective is to tag grammatical categories. To search for grammatical categories, a keyword search is applied to the full text version of the XML document. In practice, the string </textual><quote class="po-inline e211 e211"><textual class="po-textual">f.</textual></quote><textual class="po-textual"> belongs to the keyword list of grammatical categories (it's an abbreviation standing for: feminine substantive).</textual></para><para class="po-block e212 e212"><textual class="po-textual">Input (FEW 2, 983a, completus):
</textual><programlisting class="po-block e213 e213" xml:space="preserve"><textual class="po-textual">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;fleur incomplète&lt;/i&gt; &lt;def&gt;„f. dé-&lt;lb merge="discard-hyphen"/&gt;
pourvue de quelque organe, notamment de corolle“&lt;/def&gt;&lt;lb merge="no"/&gt;
(seit &lt;biblio&gt;Trév 1771&lt;/biblio&gt;).</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e214 e214"><textual class="po-textual">Expected output, no tag inserted:
</textual><programlisting class="po-block e215 e215" xml:space="preserve"><textual class="po-textual">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;fleur incomplète&lt;/i&gt; &lt;def&gt;„f. dé-&lt;lb merge="discard-hyphen"/&gt;
pourvue de quelque organe, notamment de corolle“&lt;/def&gt;&lt;lb merge="no"/&gt;
(seit &lt;biblio&gt;Trév 1771&lt;/biblio&gt;).</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e216 e216"><textual class="po-textual">If all tags were removed prior to full text search, the string </textual><quote class="po-inline e217 e217"><textual class="po-textual">f.</textual></quote><textual class="po-textual"> would be matched as a licit grammatical category. This would lead to a false positive as </textual><quote class="po-inline e218 e218"><textual class="po-textual">f.</textual></quote><textual class="po-textual"> is here an abbreviation of the word </textual><quote class="po-inline e219 e219"><textual class="po-textual">fleur</textual></quote><textual class="po-textual"> (i.e. flower) and has already been tagged as part of the definition of a lexeme.</textual></para><para class="po-block e220 e220"><textual class="po-textual">Instead, </textual><code class="po-atom e221 e221"><textual class="po-textual">&lt;def&gt;</textual></code><textual class="po-textual"> tags (as well as others, in practice and for the relevant algorithm) should be made totally invisible, their contents included, prior to full text search. The full text to which the search operation is applied thus becomes:
</textual><programlisting class="po-block e222 e222" xml:space="preserve"><textual class="po-textual">Nfr. fleur incomplète (seit Trév 1771).</textual></programlisting><textual class="po-textual">
</textual></para></section><section class="po-hcontainer e223 e223"><title class="po-block e224 e224"><textual class="po-textual">Use case 3: avoidance of false negatives for regular expression matching</textual></title><para class="po-block e225 e225"><textual class="po-textual">In this use case, the objective is to tag dates. To search for dates, a regular expression is applied to the full text version of the XML document.
The </textual><quote class="po-inline e226 e226"><textual class="po-textual">–</textual></quote><textual class="po-textual"> character is not a hyphen, but an </textual><textual class="po-textual"> en dash. This character, as well as the spacing around it, is accounted for in the regular expression used to match dates.</textual></para><para class="po-block e227 e227"><textual class="po-textual">Input (FEW 25, 882a, augmentator):
</textual><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">&lt;p&gt;Emprunt de &lt;geoling&gt;lttard.&lt;/geoling&gt; &lt;geoling&gt;mlt.&lt;/geoling&gt; &lt;i&gt;&lt;etymon&gt;augmentator&lt;/etymon&gt;&lt;/i&gt;
(4&lt;e&gt;e&lt;/e&gt;–&lt;lb merge="no"/&gt;
6&lt;e&gt;e&lt;/e&gt; s., &lt;biblio&gt;ThesLL&lt;/biblio&gt; ;</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e229 e229"><textual class="po-textual">Expected output, one </textual><code class="po-atom e230 e230"><textual class="po-textual">&lt;date&gt;</textual></code><textual class="po-textual"> tag inserted:
</textual><programlisting class="po-block e231 e231" xml:space="preserve"><textual class="po-textual">&lt;p&gt;Emprunt de &lt;geoling&gt;lttard.&lt;/geoling&gt; &lt;geoling&gt;mlt.&lt;/geoling&gt; &lt;i&gt;&lt;etymon&gt;augmentator&lt;/etymon&gt;&lt;/i&gt;
(&lt;date&gt;4&lt;e&gt;e&lt;/e&gt;–&lt;lb merge="no"/&gt;
6&lt;e&gt;e&lt;/e&gt; s.&lt;/date&gt;, &lt;biblio&gt;ThesLL&lt;/biblio&gt; ;</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e232 e232"><textual class="po-textual">If &lt;e&gt; and &lt;lb/&gt; tags were not skipped, the date range </textual><quote class="po-inline e233 e233"><textual class="po-textual">4e-6e s.</textual></quote><textual class="po-textual"> (i.e. 4th-6th century) would be split into six fragments. This would lead to a false negative, i.e. the date would not be matched. By virtually removing the &lt;e&gt; and &lt;lb/&gt; tags (as well as others, in practice), the date can be matched by a regular expression.
The full text to which the search operation is applied thus becomes:
</textual><programlisting class="po-block e234 e234" xml:space="preserve"><textual class="po-textual">Emprunt de lttard. mlt. augmentator (4e– 6e s., ThesLL ;</textual></programlisting><textual class="po-textual">
</textual></para></section><section class="po-hcontainer e235 e235"><title class="po-block e236 e236"><textual class="po-textual">Use case 4: avoidance of false negatives for keyword search</textual></title><para class="po-block e237 e237"><textual class="po-textual">In this use case, the objective is to tag affixes (i.e. prefixes and suffixes). To search for affixes, a keyword search is applied to the full text version of the XML document.</textual></para><para class="po-block e238 e238"><textual class="po-textual">Input (FEW 8, 237a, perfectus):
</textual><programlisting class="po-block e239 e239" xml:space="preserve"><textual class="po-textual">&lt;pref id="I 2 a"&gt;a&lt;/pref&gt; mit dem suffix -&lt;i&gt;ivus&lt;/i&gt;</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e240 e240"><textual class="po-textual">Expected output, one </textual><code class="po-atom e241 e241"><textual class="po-textual">&lt;affix&gt;</textual></code><textual class="po-textual"> tag inserted:
</textual><programlisting class="po-block e242 e242" xml:space="preserve"><textual class="po-textual">&lt;pref id="I 2 a"&gt;a&lt;/pref&gt; mit dem suffix &lt;affix&gt;-&lt;i&gt;ivus&lt;/i&gt;&lt;/affix&gt;</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e243 e243"><textual class="po-textual">If &lt;i&gt; tags were not skipped, the hyphen of the suffix </textual><quote class="po-inline e244 e244"><textual class="po-textual">-ivus</textual></quote><textual class="po-textual"> would be separated from the rest of the word. This would lead to a false negative, i.e. the affix would not be matched. By virtually removing the &lt;i&gt; tags (as well as others, in practice), the affix keyword can be matched.
The full text to which the search operation is applied thus becomes:
</textual><programlisting class="po-block e245 e245" xml:space="preserve"><textual class="po-textual">a mit dem suffix -ivus</textual></programlisting><textual class="po-textual">
</textual></para></section></section><section class="po-hcontainer e246 e246"><title class="po-block e247 e247"><textual class="po-textual">Hypothetical Use Cases</textual></title><para class="po-block e248 e248"><textual class="po-textual">In a general sense, our proposed virtualization mechanism enables to construct views of an XML document, dynamically at any time during its processing.
The mechanism masks selected parts of an XML document and transparently applies updates - through the constructed document view - to the XML document. The mechanism operates on a representation of the XML document that does not rely on a DOM tree. The representation of the XML document exhibits very lightweight storage requirements if one desires to process only sections of the document at a time. Therefore, our proposed virtualization mechanism is well-suited to process streamed data.</textual></para><para class="po-block e249 e249"><textual class="po-textual">An hypothetical use case of growing importance would be the semantic analysis of web documents intended to feed the ever-expanding index of a web search engine. Given that web search is predicted to evolve towards a better understanding of what web documents mean [</textual><xref class="po-milestone e250 e250" linkend="sav10a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], semantic analysis of a web document may well evolve to become a key problem in web search. The ability to easily mask selected tagged regions of a web document to try and derive different meanings would thus be an asset when engineering its semantic analysis.</textual></para></section><section class="po-hcontainer e251 e251"><title class="po-block e252 e252"><textual class="po-textual">Document Retrieval and Update API</textual></title><para class="po-block e253 e253"><textual class="po-textual">As most algorithms devised for the semantic tagging of types of information of the FEW dictionary operate based on different contextual assumptions, one should be able to flexibly and easily configure the retrieval and update operations for each algorithm. Why did we choose to expose this mechanism through an Application Programming Interface (API)?
Firstly, tools that can apply only one transformation to an XML document, however powerful they are [</textual><xref class="po-milestone e254 e254" linkend="stl01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e255 e255" linkend="rfg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e256 e256" linkend="tan05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e257 e257" linkend="tan06a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e258 e258" linkend="tan06b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], are not adapted because the semantic tagging of FEW requires each XML document to be processed multiple times.
Secondly, domain-specific languages can serve their purposes well, but often lack in generality.
Thirdly, embeddable domain-specific languages, like XQuery [</textual><xref class="po-milestone e259 e259" linkend="xqe"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is intended to be, deserve attention but the depth of integration may (currently) sometimes be a limiting factor.
Fourthly, an Application Programming Interface (API) offers great flexibility and by design can be easily integrated with user code.
We have thus decided to expose our proposed virtualization mechanism through an Application Programming Interface (API). A Java implementation of this API was completed during the summer of 2009.</textual></para><para class="po-block e260 e260"><textual class="po-textual">Our proposed document retrieval and update API is actually comprised of a set of six distinct APIs (see Figure 2 here below, based on the example illustrating the Our Approach section):
</textual><itemizedlist class="po-table e261 e261"><listitem class="po-container e262 e262"><para class="po-block e263 e263"><textual class="po-textual">addressing API: provides a mechanism to locate target nodes;</textual></para></listitem><listitem class="po-container e264 e264"><para class="po-block e265 e265"><textual class="po-textual">text retrieval API: no specific document-level or node-level text retrieval API is provided, user code is expected to rely on standard Java facilities or user-provided custom packages;</textual></para></listitem><listitem class="po-container e266 e266"><para class="po-block e267 e267"><textual class="po-textual">text update API: provides a mechanism to update a single text node and insert tags into a single text node;</textual></para></listitem><listitem class="po-container e268 e268"><para class="po-block e269 e269"><textual class="po-textual">text virtualization API: provides a mechanism to construct a sequence of virtual strings over a section of the XML document potentially spanning many nodes, from which specified types of tags are virtually removed;</textual></para></listitem><listitem class="po-container e270 e270"><para class="po-block e271 e271"><textual class="po-textual">virtual text retrieval API: provides a mechanism to retrieve data within a virtual string, that also provides access to the underlying nodes of the XML document;</textual></para></listitem><listitem class="po-container e272 e272"><para class="po-block e273 e273"><textual class="po-textual">virtual text update API and virtual tag splicing API: provides a mechanism to update a virtual string and insert tag into a virtual string, and have the updates transparently propagated to the underlying nodes of the XML document.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><figure class="po-container e274 e274" xml:id="retrieval-update-api" xreflabel="retrieval-update-api"><mediaobject class="po-container e275 e275"><imageobject class="po-container e276 e276"><imagedata class="po-meta e277 e277" fileref="../../../vol5/graphics/Briquet01/Briquet01-002.png" format="png" width="620"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e278 e278"><para class="po-block e279 e279"><textual class="po-textual">Document Retrieval and Update API</textual></para></caption></mediaobject></figure><para class="po-block e280 e280"><textual class="po-textual">Before introducing each API, the in-memory representation of XML document on which they operate is first described.</textual></para><section class="po-hcontainer e281 e281"><title class="po-block e282 e282"><textual class="po-textual">In-memory Document Data Structure</textual></title><para class="po-block e283 e283"><textual class="po-textual">An important design decision in XML document processing is the in-memory representation of its markup and content. A typical choice is the DOM tree representation [</textual><xref class="po-milestone e284 e284" linkend="dom"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. However, as we are considering text-oriented XML documents only, there are at least two arguments against a tree representation.
</textual><itemizedlist class="po-table e285 e285"><listitem class="po-container e286 e286"><para class="po-block e287 e287"><textual class="po-textual">Firstly, the structural information contained in the tree branches is practically useless to our purposes as the element hierarchy of the FEW dictionary is not always predictable (see Scope of the problem here above for the rationale). Therefore, the memory footprint of the document representation can be greatly reduced by discarding hierarchical relationships and storing only the list of leaves of the document.</textual></para></listitem><listitem class="po-container e288 e288"><para class="po-block e289 e289"><textual class="po-textual">Secondly, as the generated XML documents may not be well-formed (due to e.g. unexpected textual data that cannot be recognized by the tagging algorithms), a mechanism to deal with the lack of well-formedness, such as e.g. milestones [</textual><xref class="po-milestone e290 e290" linkend="der04a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], is required. A tree representation has thus little benefit.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e291 e291"><textual class="po-textual">We decide instead to represent an XML document as a list of nodes, with each node being either an XML tag or a text chunk. This in-memory representation matches the assumption of text-oriented XML documents. It allows straightforward access to contextual relationships (i.e. is-left-of, is-right-of) between nodes, without precluding to construct additional data structures on top of it in order to access parent/child relationships for specific sections of the document. In the rest of the paper, it will be referred to as a node list.</textual></para><para class="po-block e292 e292"><textual class="po-textual">In practice, the node list can be easily constructed using a validating SAX parser that appends text nodes and tag nodes to the node list as they are loaded to memory. Tag attributes are not appended as nodes themselves, but instead are added as properties of tag nodes. Comments and processing instructions are currently discarded from the XML document (this is an implementation-specific limitation that can be removed through additional engineering hours).</textual></para><para class="po-block e293 e293"><textual class="po-textual">The existing implementation of the API only considers UTF-8-encoded XML documents. Fragments of text of the XML document are normalized as they are inserted into the node list as text nodes. A character map enables the API user to configure all licit character, character entity references and numeric character references. Character sanity is enforced by checking all characters of the XML document against the character map. Character entity references and numeric character references are all resolved into one Unicode character each, possibly in a private use area. All spacing characters are converted to the space character (U+0020), then multiple spaces are compacted into one space only. Leading and trailing spaces within high-level structural tags (dictionary, article, paragraph) are removed. Break tags (e.g. end of line, end of column, end of page,...), despite being tags and not text, are also normalized, i.e. redundant break tags are removed.</textual></para></section><section class="po-hcontainer e294 e294"><title class="po-block e295 e295"><textual class="po-textual">Addressing API</textual></title><para class="po-block e296 e296"><textual class="po-textual">The addressing API takes one node as input, and provides a node as output.</textual></para><para class="po-block e297 e297"><textual class="po-textual">Addressing of XML elements, tags or text chunks, in the node list is always relative to a target node and always returns a single node (never a set of nodes).
No mechanism of absolute addressing of XML elements in the XML document is currently provided because it was not a requirement for the tagging of the FEW dictionary. An absolute addressing mechanism featuring XPath [</textual><xref class="po-milestone e298 e298" linkend="xpat"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] syntax might be supported but at the expense of a severe performance penalty, as the node list does not contain the hierarchical structure of a node tree (see In-memory Document Data Structure here above for the rationale).</textual></para><para class="po-block e299 e299"><textual class="po-textual">Relative addressing of XML elements can be done in three ways: by neighbor access, by tag node search, by text node search.
</textual><itemizedlist class="po-table e300 e300"><listitem class="po-container e301 e301"><para class="po-block e302 e302"><textual class="po-textual">The left and right neighbor of a target node are always immediately accessible, by construction of the node list.</textual></para></listitem><listitem class="po-container e303 e303"><para class="po-block e304 e304"><textual class="po-textual">Several tag node search operations are provided by the addressing API: search forwards/backwards for the next tag node matching a given set of tags and/or tag attributes, before the first occurrence of a stopper tag (if specified). It must be noted that forward search and backward search are not equivalent to descendant search or ancestor search [</textual><xref class="po-milestone e305 e305" linkend="xpat"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] in a tree representation. Consider the following two examples. First example: </textual><code class="po-atom e306 e306"><textual class="po-textual">&lt;X&gt;&lt;Y&gt;some text&lt;/Y&gt;&lt;Z&gt;some text&lt;/Z&gt;&lt;/X&gt;</textual></code><textual class="po-textual">. Second example: </textual><code class="po-atom e307 e307"><textual class="po-textual">&lt;X&gt;&lt;Y&gt;some text&lt;/Y&gt;&lt;/X&gt; &lt;Z&gt;some text&lt;/Z&gt;</textual></code><textual class="po-textual">. A forward search (in our proposed node list representation), relative to the target node </textual><code class="po-atom e308 e308"><textual class="po-textual">&lt;X&gt;</textual></code><textual class="po-textual">, for a </textual><code class="po-atom e309 e309"><textual class="po-textual">&lt;Z&gt;</textual></code><textual class="po-textual"> tag will find a match in both examples, whereas a similar descendant search (in a tree representation) would not find a match in the second example.</textual></para></listitem><listitem class="po-container e310 e310"><para class="po-block e311 e311"><textual class="po-textual">Several text node search operations are provided by the addressing API: search forwards/backwards for the next text node, before the first occurrence of a stopper tag (if specified). Again, forward search and backward search are not equivalent to descendant search or ancestor search [</textual><xref class="po-milestone e312 e312" linkend="xpat"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] in a tree representation.</textual></para></listitem></itemizedlist><textual class="po-textual">
In theory, the cost of relative addressing is bounded by the number of nodes in the node list. In practice, though, most addressing requests for the tagging of the FEW dictionary are fairly local, e.g. within a paragraph of the text encoded into the XML document. If the addressing API is considered for searches not exhibiting high locality, implementation of auxiliary data structures should be considered to guarantee lower bounds in the search cost. To this end, insights (though no direct reuse) could certainly be drawn from the skip list [</textual><xref class="po-milestone e313 e313" linkend="pug90a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] data structure. The availability of such auxiliary data structures would pave the way for XPath addressing.</textual></para></section><section class="po-hcontainer e314 e314"><title class="po-block e315 e315"><textual class="po-textual">Text Retrieval API</textual></title><para class="po-block e316 e316"><textual class="po-textual">Neither a dedicated node-level retrieval API (i.e. within individual nodes only) nor a document-level text retrieval API are provided (i.e. within all individual nodes of the document, considered individually), for two reasons.</textual></para><para class="po-block e317 e317"><textual class="po-textual">Firstly, the text chunk of a text node is a classic Java string.
To achieve node-level text retrieval, it is thus straightforward for user code to rely on standard Java facilities such as the operations on Java strings (java.lang.String methods), the regular expression engine (java.util.regex package), or user-supplied packages.
This also enables one to plug advanced search mechanisms such as collocate search, or search for inflected forms (e.g. mouse/mice).
For instance, in the context of the FEW dictionary, several semantic tagging algorithms depend on a keyword search seeking to match a list of keywords that may each exhibit several nontrivial variations.
The decoupling of node-level text retrieval operations (as well as virtual text retrieval over selected sections of the document, which constitutes the core of this paper, see below) from other core operations thus offers great flexibility to users.</textual></para><para class="po-block e318 e318"><textual class="po-textual">Secondly, document-level retrieval can be achieved by using an additional retrieval mechanism on top of the node list representation, such as one of those discussed in the Related Work section of this article.</textual></para><para class="po-block e319 e319"><textual class="po-textual">Text retrieval over sections of the document (i.e. of its node list representation), though, is made possible using the virtual text retrieval API (see below).</textual></para></section><section class="po-hcontainer e320 e320"><title class="po-block e321 e321"><textual class="po-textual">Text Update API</textual></title><para class="po-block e322 e322"><textual class="po-textual">The text update API takes one text node and an update specification as input, and updates/inserts/deletes text nodes as output.
In the existing implementation, the updates are not </textual><emphasis class="po-inline e323 e323" role="ital"><textual class="po-textual">in-place</textual></emphasis><textual class="po-textual">, i.e. text nodes are actually substituted with an updated copy of themselves.</textual></para><para class="po-block e324 e324"><textual class="po-textual">Three operations applicable to a target text chunk are provided by the node-level text update API:
</textual><itemizedlist class="po-table e325 e325"><listitem class="po-container e326 e326"><para class="po-block e327 e327"><textual class="po-textual">Update (replacement) of a substring of the target text chunk with the specified string.</textual></para></listitem><listitem class="po-container e328 e328"><para class="po-block e329 e329"><textual class="po-textual">Tagging of a substring of target text chunk with a given tag, i.e. insertion of an opening and a closing tag at specified insertion indexes.</textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">Insertion of a list of tags at specified insertion index of target text chunk. Typical use case: inserting an empty element.</textual></para></listitem></itemizedlist><textual class="po-textual">
The node-level text update API is convenient but can update text or insert tags only between a pair of existing tags.</textual></para></section><section class="po-hcontainer e332 e332"><title class="po-block e333 e333"><textual class="po-textual">Text Virtualization API</textual></title><para class="po-block e334 e334"><textual class="po-textual">The text virtualization API takes one node and a virtualization specification as input, and provides a (possibly empty) sequence of virtual strings as output.</textual></para><para class="po-block e335 e335"><textual class="po-textual">Just one operation is provided by the API: the construction of a sequence of virtual strings based on a specification of tag types visibility provided by the API user. The text virtualization API addresses the issue of virtually removing specified types of tag, as well as their contents (if specified), from a sequence of sections of a text-oriented XML document. We define a section as the sequence of nodes starting at a target node and extending immediately prior to (and excluding) the first tag node matching a specified stopper tag type (if any), or the end of the document (in the absence, after the target node, of any stopper tag matching the specified type).
The construction of a sequence of virtual strings thus virtualizes a sequence of sections of the XML document.</textual></para><para class="po-block e336 e336"><textual class="po-textual">We define a virtual string as the data structure:
</textual><itemizedlist class="po-table e337 e337"><listitem class="po-container e338 e338"><para class="po-block e339 e339"><textual class="po-textual">based on a string resulting from the concatenation of adjacent text chunks (two text chunks are considered as adjacent if no visible tag occurs between them),</textual></para></listitem><listitem class="po-container e340 e340"><para class="po-block e341 e341"><textual class="po-textual">that is backed by the underlying text nodes of the XML document,</textual></para></listitem><listitem class="po-container e342 e342"><para class="po-block e343 e343"><textual class="po-textual">that includes all the information necessary for retrieval and dynamic updates (see Virtual Text Retrieval API and Virtual Text Update API in the following).</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e344 e344"><textual class="po-textual">The construction of a sequence of virtual strings is controlled through the specification of a visibility partition of all types of tags that can appear in the XML document. It relies on a tag visibility model that is an extended version (with slightly different semantics) of the tag visibility model initially introduced by Lini et al. [</textual><xref class="po-milestone e345 e345" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and used by Tannier [</textual><xref class="po-milestone e346 e346" linkend="tan05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e347 e347"><textual class="po-textual">Our tag visibility model is comprised of five classes:
</textual><itemizedlist class="po-table e348 e348"><listitem class="po-container e349 e349"><para class="po-block e350 e350"><textual class="po-textual">skipped tags: should be virtually removed from the document section under consideration;</textual></para></listitem><listitem class="po-container e351 e351"><para class="po-block e352 e352"><textual class="po-textual">invisible tags: should be virtually removed, as well as all of their contents (including descendant tags), from the document section under consideration;</textual></para></listitem><listitem class="po-container e353 e353"><para class="po-block e354 e354"><textual class="po-textual">visible tags: signal the end of the document section under consideration;</textual></para></listitem><listitem class="po-container e355 e355"><para class="po-block e356 e356"><textual class="po-textual">terminal tags: signal the end of the document section under consideration, as well as of the sequence of sections under consideration;
the availability of the visible tag class in addition to the terminal tag class enables to construct a sequence of virtual strings using one API call only (e.g. a visible tag could be &lt;/li&gt; and a terminal tag could be &lt;/ul&gt;);</textual></para></listitem><listitem class="po-container e357 e357"><para class="po-block e358 e358"><textual class="po-textual">unexpected tags: should not be found within those areas of the document section under consideration that are outside invisible tags.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e359 e359"><textual class="po-textual">A visibility partition is a partition of the set of all possible tag types that is comprised of five sets, each of which represents a visibility class. 
A partition is intrinsically comprehensive: all tag types must be included into exactly one visibility class each.
At most four visibility classes can thus be empty.
When defining a visibility partition, the API user has the option to specify explicitly only four visibility classes, with the remaining visibility class (whichever it is) implicitly considered as including all tag types not yet assigned to a visibility class.
As will be illustrated through examples, this can be very handy in practice.</textual></para><para class="po-block e360 e360"><textual class="po-textual">When invoked on a target node, the text virtualization API constructs a sequence of virtual strings, virtual string by virtual string. The text virtualization algorithm can be sketched as follows:
</textual><itemizedlist class="po-table e361 e361"><listitem class="po-container e362 e362"><para class="po-block e363 e363"><textual class="po-textual">Each time a visible tag or terminal tag is encountered, a virtual string is produced and returned to the calling code (except when the visible tag is comprised between a pair of matching invisible tags, cf. below). Virtual strings keep getting produced until a terminal tag (or the end of the node list) is encountered, at which point the sequence of virtual strings is complete.</textual></para></listitem><listitem class="po-container e364 e364"><para class="po-block e365 e365"><textual class="po-textual">If an unexpected tag is encountered, an exception is raised.</textual></para></listitem><listitem class="po-container e366 e366"><para class="po-block e367 e367"><textual class="po-textual">If a skipped tag is encountered, it is skipped, as can be expected.</textual></para></listitem><listitem class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">When an opening invisible tag is encountered, all</textual><footnote class="po-popup e370 e370" xml:id="visible-within-invisible"><para class="po-block e371 e371"><textual class="po-textual">After the encounter with an invisible tag, the encounter (immediately or a few nodes further) with a terminal tag, as well as the encounter with the end of the node list, triggers a virtual string to be returned to the calling code. This is not the case when a visible tag is encountered. As invisible tags have precedence over visible tags, the latter ones are also skipped until a matching closing invisible tag is encountered.</textual></para></footnote><textual class="po-textual"> subsequent nodes (both text nodes and tag nodes) are skipped, until a matching closing invisible tag is encountered.</textual></para></listitem><listitem class="po-container e372 e372"><para class="po-block e373 e373"><textual class="po-textual">When a text node is encountered, its text is added to the virtual string under construction.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e374 e374"><textual class="po-textual">As an example, let us consider the following visibility partition over the tag set { </textual><code class="po-atom e375 e375"><textual class="po-textual">&lt;i&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e376 e376"><textual class="po-textual">&lt;lb&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e377 e377"><textual class="po-textual">&lt;s&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e378 e378"><textual class="po-textual">&lt;t&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e379 e379"><textual class="po-textual">&lt;u&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e380 e380"><textual class="po-textual">&lt;v&gt;</textual></code><textual class="po-textual"> }:
</textual><itemizedlist class="po-table e381 e381"><listitem class="po-container e382 e382"><para class="po-block e383 e383"><textual class="po-textual">skipped tags = { </textual><code class="po-atom e384 e384"><textual class="po-textual">&lt;s&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e385 e385"><textual class="po-textual">&lt;lb&gt;</textual></code><textual class="po-textual"> }</textual></para></listitem><listitem class="po-container e386 e386"><para class="po-block e387 e387"><textual class="po-textual">invisible tags = { </textual><code class="po-atom e388 e388"><textual class="po-textual">&lt;i&gt;</textual></code><textual class="po-textual"> }</textual></para></listitem><listitem class="po-container e389 e389"><para class="po-block e390 e390"><textual class="po-textual">visible tags = { </textual><code class="po-atom e391 e391"><textual class="po-textual">&lt;v&gt;</textual></code><textual class="po-textual"> }</textual></para></listitem><listitem class="po-container e392 e392"><para class="po-block e393 e393"><textual class="po-textual">terminal tags = { </textual><code class="po-atom e394 e394"><textual class="po-textual">&lt;t&gt;</textual></code><textual class="po-textual"> }</textual></para></listitem><listitem class="po-container e395 e395"><para class="po-block e396 e396"><textual class="po-textual">unexpected tags = { </textual><code class="po-atom e397 e397"><textual class="po-textual">&lt;u&gt;</textual></code><textual class="po-textual"> }</textual></para></listitem></itemizedlist><textual class="po-textual">
Let the text virtualization API be invoked on the following section of an XML document (the target node is the first node, i.e. the text node </textual><quote class="po-inline e398 e398"><textual class="po-textual">Once upon a time,</textual></quote><textual class="po-textual">), configured with the aforementioned visibility partition:
</textual><programlisting class="po-block e399 e399" xml:space="preserve"><textual class="po-textual">Once upon a time,&lt;i /&gt; there was a &lt;s&gt;sentence with an important&lt;/s&gt; part,&lt;lb merge="no" /&gt;
followed by an &lt;i&gt;irrelevant part&lt;/i&gt;.&lt;v /&gt;It was followed by&lt;lb merge="no" /&gt;
a second sentence separated from the first by a visible tag.&lt;lb merge="no" /&gt;
&lt;v&gt;A word near the end of the third sen-&lt;lb merge="discard-hyphen" /&gt;
tence was split by a break tag.&lt;/v&gt;&lt;/t&gt;
</textual></programlisting><textual class="po-textual">
A sequence of three virtual strings is returned to the calling code:
</textual><itemizedlist class="po-table e400 e400"><listitem class="po-container e401 e401"><para class="po-block e402 e402"><quote class="po-inline e403 e403"><textual class="po-textual">Once upon a time, there was a sentence with an important part, followed by an .</textual></quote></para></listitem><listitem class="po-container e404 e404"><para class="po-block e405 e405"><quote class="po-inline e406 e406"><textual class="po-textual">It was followed by a second sentence separated from the first by a visible tag.</textual></quote></para></listitem><listitem class="po-container e407 e407"><para class="po-block e408 e408"><quote class="po-inline e409 e409"><textual class="po-textual">A word near the end of the third sentence was split by a break tag.</textual></quote></para></listitem></itemizedlist><textual class="po-textual">
Each character of these virtual strings either is backed by a text node of the underlying XML document, or is a virtual space. 
A fourth virtual string would have been added to the sequence if there had been some text between </textual><code class="po-atom e410 e410"><textual class="po-textual">&lt;/v&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e411 e411"><textual class="po-textual">&lt;/t&gt;</textual></code><textual class="po-textual">; indeed, empty virtual strings are never added to the returned sequence.</textual></para><para class="po-block e412 e412"><textual class="po-textual">The construction of a sequence of virtual strings could be formalized as a generalized form of string projection [</textual><xref class="po-milestone e413 e413" linkend="stp"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] applied to a suitable representation of the selected sections of the XML document, based on classes of nodes of the node list. The projection alphabet would be comprised of one symbol only: text nodes that are not inside an invisible tag. The general alphabet would also include as individual symbols the nodes containing standalone tags (either opening, closing or empty) whose types match those included in the skipped, visible, terminal and unexpected tag visibility classes. The general alphabet would further include as individual symbols the sequences of nodes constituting complete elements (i.e. opening tag, matching closing tag and the sequence of nodes in-between) whose types match those included in the invisible tag visibility class.</textual></para></section><section class="po-hcontainer e414 e414"><title class="po-block e415 e415"><textual class="po-textual">Virtual Text Retrieval API</textual></title><para class="po-block e416 e416"><textual class="po-textual">The virtual text retrieval API takes one virtual string and an information request as input, and provides either the text of the virtual string, a node, an offset or a stopper tag as output. Retrieval operations are independently performed by the API user on the text of the virtual string provided by the API.</textual></para><para class="po-block e417 e417"><textual class="po-textual">The virtual text retrieval API implicitly allows tag-aware search by letting the API user perform full text search of a target virtual string. The virtual string exposes the string that was virtually constructed from a section of the XML document. This string is a normal, regular string that can be searched as any other string. In particular, the API user can apply her favorite regexp engine or pattern matching algorithm.</textual></para><para class="po-block e418 e418"><textual class="po-textual">To obtain match points [</textual><xref class="po-milestone e419 e419" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and otherwise access the nodes of the XML document backing the virtual string, all the API user needs to provide is the index of the character of interest (from 0 to N-1, if the length of the virtual string is N).
Five operations are provided by the virtual text retrieval API:
</textual><itemizedlist class="po-table e420 e420"><listitem class="po-container e421 e421"><para class="po-block e422 e422"><textual class="po-textual">Get the text of the virtual string.</textual></para></listitem><listitem class="po-container e423 e423"><para class="po-block e424 e424"><textual class="po-textual">Get the text node backing the character at target index in the virtual string.</textual></para></listitem><listitem class="po-container e425 e425"><para class="po-block e426 e426"><textual class="po-textual">Get the offset, i.e. start index within the virtual string, of the text node backing the character at target index in the virtual string.</textual></para></listitem><listitem class="po-container e427 e427"><para class="po-block e428 e428"><textual class="po-textual">Get the stopper tag (i.e. visible or terminal tag) delimiting (i.e. immediately following) the virtual string, if any. The stopper tag qualifier can also be obtained.</textual></para></listitem><listitem class="po-container e429 e429"><para class="po-block e430 e430"><textual class="po-textual">Check whether the character at target index in the virtual string is a virtual space or a regular character.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e431 e431"><textual class="po-textual">A virtual space is a space character found in a virtual string, that does not belong to any node of the underlying XML document. Virtual spaces are inserted instead of break tags. If a break tag is preceded by a hyphen and if it contains a specific attribute (i.e. </textual><code class="po-atom e432 e432"><textual class="po-textual">merge</textual></code><textual class="po-textual">), the break tag can be processed differently based on the value of the attribute. Three behaviors are defined:
</textual><itemizedlist class="po-table e433 e433"><listitem class="po-container e434 e434"><para class="po-block e435 e435"><textual class="po-textual">insert a virtual space (default behavior in the absence of the specific attribute);</textual></para></listitem><listitem class="po-container e436 e436"><para class="po-block e437 e437"><textual class="po-textual">merge the word preceding the break tag and the word following the break tag, preserving the hyphen;</textual></para></listitem><listitem class="po-container e438 e438"><para class="po-block e439 e439"><textual class="po-textual">merge the word preceding the break tag and the word following the break tag, discarding the hyphen.</textual></para></listitem></itemizedlist><textual class="po-textual">
The text virtualization API thus takes care of automatically adding virtual spaces where specified, and otherwise virtually merges the two parts of hyphenated words, preserving or discarding the hyphen as specified. 
This mechanism lets the API user control how words split by a break tag are processed in the presence of a hyphen. All is required from the API user is to set the value of a specific attribute for each word split by a break tag that should be virtually recomposed into one word when a virtual string is constructed.</textual></para></section><section class="po-hcontainer e440 e440"><title class="po-block e441 e441"><textual class="po-textual">Virtual Text Update API and Virtual Tag Splicing API</textual></title><para class="po-block e442 e442"><textual class="po-textual">The virtual text update API takes one virtual string and an update specification as input, and updates/inserts/deletes text nodes as output.
The virtual tag splicing API takes one virtual string and a splicing specification as input, and inserts tag nodes as output.</textual></para><para class="po-block e443 e443"><textual class="po-textual">The virtual text update API allows to modify the text of a virtual string. The virtual tag splicing API allows to splice (i.e. insert) tags into a virtual string.
Both APIs allow to specify updates in a straightforward manner and have these updates transparently propagated to the underlying XML document. This may involve, in addition to the update of nodes, the insertion of nodes into the node list as well as the deletion of some of its nodes. To specify updates to a virtual string, all the API user needs to specify, besides the update description, is the index of the character (or indexes of the couple of characters) of interest (from 0 to N-1, if the length of the virtual string is N).</textual></para><para class="po-block e444 e444"><textual class="po-textual">One operation is provided by the virtual text update API:
</textual><itemizedlist class="po-table e445 e445"><listitem class="po-container e446 e446"><para class="po-block e447 e447"><textual class="po-textual">Updating a target substring of a virtual string: a couple of target indexes (i.e. start and end indexes) in the virtual string are specified, along with a replacement string. If the replacement string is shorter than the target substring, some of the rightmost backing text nodes might be completely deleted from the XML document.</textual></para></listitem></itemizedlist><textual class="po-textual">
Similarly to XQuery updates [</textual><xref class="po-milestone e448 e448" linkend="xqui"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], virtual text updates are not applied immediately. Virtual text updates are accumulated into a list of pending updates. The listed updates are all applied when the API user explicitly invokes the execution of the updates.
</textual></para><para class="po-block e449 e449"><textual class="po-textual">Two operations are provided by the virtual tag splicing API:
</textual><itemizedlist class="po-table e450 e450"><listitem class="po-container e451 e451"><para class="po-block e452 e452"><textual class="po-textual">Inserting a couple of opening and closing tags around a target substring of a virtual string, that is specified with a couple of target indexes (start and end indexes).</textual></para></listitem><listitem class="po-container e453 e453"><para class="po-block e454 e454"><textual class="po-textual">Inserting a single (opening, closing or empty) tag at a specified index into a virtual string.</textual></para></listitem></itemizedlist><textual class="po-textual">
Also similarly to XQuery updates [</textual><xref class="po-milestone e455 e455" linkend="xqui"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], virtual tag splicing updates are not applied immediately, but accumulated into a list of pending updates that are applied together when explicitly requested by the API user.</textual></para></section></section><section class="po-hcontainer e456 e456"><title class="po-block e457 e457"><textual class="po-textual">Related Work</textual></title><section class="po-hcontainer e458 e458"><title class="po-block e459 e459"><textual class="po-textual">Query and Update Frameworks</textual></title><section class="po-hcontainer e460 e460"><title class="po-block e461 e461"><textual class="po-textual">Information Extraction</textual></title><para class="po-block e462 e462"><textual class="po-textual"> Information Extraction (IE) [</textual><xref class="po-milestone e463 e463" linkend="ie"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] consists of extracting structured information from unstructured documents. Therefore, the semantic tagging of the FEW dictionary could theoretically be modelled as an IE problem (named entity recognition, coreference resolution, terminology extraction, relationship extraction). In practice, however, we hypothesize (but neither claim nor prove) that the quantity and complexity of the involved rules to identify fields of information in the FEW dictionary together make it intractable to use existing general-purpose IE software [</textual><xref class="po-milestone e464 e464" linkend="gate"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e465 e465" linkend="ibmie"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e466 e466"><textual class="po-textual">For instance, the General Architecture for Text Engineering (GATE) [</textual><xref class="po-milestone e467 e467" linkend="gate"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] makes it straightforward to define a large number of pattern matching and text processing rules, however with limited access to context. From our reading of the online documentation of GATE, we hypothesize that most rules for the semantic tagging of the FEW depend so much on context that they cannot be expressed within GATE.</textual></para><para class="po-block e468 e468"><textual class="po-textual">Whether the stated hypothesis is proved or disproved, it will be very interesting to more deeply explore to what extent the semantic tagging of the FEW can be modelled as an IE problem.</textual></para></section><section class="po-hcontainer e469 e469"><title class="po-block e470 e470"><textual class="po-textual">Regular Fragmentations and XML Fragments</textual></title><para class="po-block e471 e471"><textual class="po-textual">The Regular Fragmentations retrieval language and API [</textual><xref class="po-milestone e472 e472" linkend="stl01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e473 e473" linkend="rfg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] allows full text search in XML-encoded corpora (keyword search at least, as well as regexp search). Regular Fragmentations does allow updates as it is a filter tool made available through either an XML configuration file or an API. Its internal representation is tree-based and can be modified based on an implied processing model. Matching on both markup and textual content is (currently?) not supported, which makes it unsuitable to the semantic tagging of the FEW dictionary.</textual></para><para class="po-block e474 e474"><textual class="po-textual">The XML fragments query mechanism [</textual><xref class="po-milestone e475 e475" linkend="car03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] allows full text search (keyword search only, no regexp search) and structural search in XML-encoded corpora. It does not allow updates. It does support tag-aware search. Queries are described as exemplar fragments of the XML document, which allows tag-aware search, albeit with limited flexibility. Lack of support for join operations is noted to be a </textual><emphasis class="po-inline e476 e476" role="ital"><textual class="po-textual">major limitation of [the] XML fragment model, and a major restriction of most IR systems as compared to DB systems</textual></emphasis><textual class="po-textual"> [</textual><xref class="po-milestone e477 e477" linkend="car03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. This remark also highlights that the major strength of our proposed API is its flexibility: Full access to the underlying XML document is provided with the retrieved results, enabling arbitrary supplementary processing of the retrieved results, as well as arbitrary updates of the underlying XML document.</textual></para></section><section class="po-hcontainer e478 e478"><title class="po-block e479 e479"><textual class="po-textual">Reading Contexts</textual></title><para class="po-block e480 e480"><textual class="po-textual">The XTReSy [</textual><xref class="po-milestone e481 e481" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] retrieval language allows full text search in XML-encoded corpora (keyword search, probably not regexp search).
XTReSY does not allow updates. XTReSY supports tag-aware search and has the capability to return match points. Interestingly, text normalization can be flexibly defined and is part of the language. The construction of the in-memory representation of XML documents in our work also features text normalization, but as opposed to XTReSY, punctuation is preserved (as it can constitute useful hints to detect types of information) and case streamlining is left to the API user (see Virtual Text Retrieval API here above). XTReSY actually introduced the concept of tag-aware search (refereed to as tag-dependent search [</textual><xref class="po-milestone e482 e482" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]). XTReSy also introduced a tag visibility model that is extended by our proposed model (see above).
The XTReSy [</textual><xref class="po-milestone e483 e483" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] tag visibility model is comprised of three classes:
</textual><itemizedlist class="po-table e484 e484"><listitem class="po-container e485 e485"><para class="po-block e486 e486"><textual class="po-textual">soft tags: can be mapped to skipped tags in our tag visibility model;</textual></para></listitem><listitem class="po-container e487 e487"><para class="po-block e488 e488"><textual class="po-textual">jump tags: can be mapped to invisible tags in our tag visibility model;</textual></para></listitem><listitem class="po-container e489 e489"><para class="po-block e490 e490"><textual class="po-textual">hard tags: can be mapped to visible and terminal tags in our tag visibility model.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e491 e491"><textual class="po-textual">The XGTagger [</textual><xref class="po-milestone e492 e492" linkend="tan05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] retrieval tool allows full text search in XML-encoded corpora (keyword search, as well as regexp search). XGTagger supports tag-aware search but cannot return match points. XGTagger does not allow updates. Instead, an external tool can update (only once) the virtualized XML document. XGTagger relies on the XTReSy [</textual><xref class="po-milestone e493 e493" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] tag visibility model to virtualize XML documents. Our proposed concept of virtual string is conceptually close to Tannier's concept of reading context. Our virtualization mechanism is more flexible than XGTagger [</textual><xref class="po-milestone e494 e494" linkend="tan06a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e495 e495" linkend="tan06b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Firstly, our API allows to dynamically invoke an arbitrary number of virtualizations and updates to different sections of the XML document. Secondly, XGTagger cannot return match points. Thirdly, though reading contexts are backed by the underlying XML document, XGTagger does not expose the XML document to the external updating tool. Fourthly, our tag visibility model is an extended version of the XTReSy [</textual><xref class="po-milestone e496 e496" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] model on which XGTagger relies to virtualize XML documents; the distinction between visible and terminal tags in our model allows the API user to transparently obtain a scoped iterator over multiple virtual strings.</textual></para></section><section class="po-hcontainer e497 e497"><title class="po-block e498 e498"><textual class="po-textual">XQuery</textual></title><para class="po-block e499 e499"><textual class="po-textual">The XQuery [</textual><xref class="po-milestone e500 e500" linkend="xqe"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] retrieval language allows, among many powerful features, full text search in XML-encoded corpora (keyword search as well as, to a certain extent, regexp search). The Full Text extension [</textual><xref class="po-milestone e501 e501" linkend="xqf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e502 e502" linkend="xqfi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e503 e503" linkend="imh08a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] adds full-text search capabilities to XQuery. The Full Text extension is a very recently (as of January 2010) stabilized W3C Candidate Recommendation. The Full Text extension does support tag-aware search, to a certain extent. Tags can be configured to be made invisible during search through the use of the </textual><code class="po-atom e504 e504"><textual class="po-textual">FTIgnore</textual></code><textual class="po-textual"> option. It must be noted that constructing an intermediate full text representation and searching this full text representations are tightly interwoven, in order to return to user code the XML elements that include contents matching the full text search query.</textual></para><para class="po-block e505 e505"><textual class="po-textual">XQuery, through its Update Facility [</textual><xref class="po-milestone e506 e506" linkend="xqu"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e507 e507" linkend="xqui"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], allows powerful forms of updates to the processed XML document. The Update Facility is a recently (as of June 2009) stabilized W3C Candidate Recommendation. Its internal representation is tree-based and XPath-addressable [</textual><xref class="po-milestone e508 e508" linkend="xpat"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. XQuery Full Text and XQuery Update Facility could thus be combined.</textual></para><para class="po-block e509 e509"><textual class="po-textual">XQuery considered together with XQuery Full Text and the XQuery Update Facility is a very powerful and versatile technology. What then could make it unsuitable for the semantic tagging of the FEW dictionary? FEW algorithms often need to perform additional search operations in the textual context around full text search matches. Results returned to user code by XQuery, though, are XML elements. It is thus not straightforward to perform subsequent search operations on these results, or obtain match points for arbitrary characters in the context of the returned results.</textual></para><para class="po-block e510 e510"><textual class="po-textual">We hypothesize that our proposed virtual text retrieval API might be implemented in XQuery on top of Full Text. However, we also hypothesize that offering the same expressiveness and flexibility would lead to a performance overhead. Indeed, XQuery returns XML elements instead of virtual strings, which means a partial loss of intermediate information (such as match points) that will have to be reconstructed over and over. It is possible, however, that such performance overhead could be addressed through good software engineering and extensions to the XQuery language.</textual></para><para class="po-block e511 e511"><textual class="po-textual">Philosophically, the key feature of our proposed virtualization mechanism over XQuery is to offer linguists a way to think of the dictionary and express themselves in a familiar environment: text without tags.</textual></para></section><section class="po-hcontainer e512 e512"><title class="po-block e513 e513"><textual class="po-textual">Other relevant works</textual></title><para class="po-block e514 e514"><textual class="po-textual">The lq-text [</textual><xref class="po-milestone e515 e515" linkend="qui08a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] retrieval tool allows full text search in XML-encoded corpora (both keyword search as well as regexp search).
It does support a limited form of update, i.e. adding tags around keyword matches. It supports useful Natural Language Processing features such as punctuation-aware and plural-aware search. Its internal representation is not tree-based. It does not support tag-aware search (as considered in this paper), as far as we can tell.</textual></para><para class="po-block e516 e516"><textual class="po-textual">The Nexi [</textual><xref class="po-milestone e517 e517" linkend="kam06a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] query language allows full text search in XML-encoded corpora (keyword search only). It does not allow updates. It does support tag-aware search based on several expressive query forms (it is claimed to be at least as expressive as XML Fragments [</textual><xref class="po-milestone e518 e518" linkend="car03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], see above), but not to the extent required for the semantic tagging of the FEW dictionary (see [</textual><xref class="po-milestone e519 e519" linkend="kam06a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], Section 6, p. 433).</textual></para></section></section><section class="po-hcontainer e520 e520"><title class="po-block e521 e521"><textual class="po-textual">Semantic Tagging of XML-Encoded Corpora</textual></title><para class="po-block e522 e522"><textual class="po-textual">The semantic tagging of the Dictionary of Middle Dutch [</textual><xref class="po-milestone e523 e523" linkend="voo05a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] as well as of the TLFi dictionary [</textual><xref class="po-milestone e524 e524" linkend="den03a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e525 e525" linkend="tlfi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e526 e526" linkend="tlf04a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] were partially automated. However, due to lack of support for virtualization of the XML document, there was little flexibility in the retrieval of the fields of information. Exceedingly complex and brittle regular expressions including hard-coded markup were used. In practice, this certainly limited any changes to the sequence in which fields of information were tagged, and also discouraged the use of attributes in the markup (because tags, attributes and attribute values all had to be hard-coded statically within the regular expressions).</textual></para></section></section><section class="po-hcontainer e527 e527"><title class="po-block e528 e528"><textual class="po-textual">Concluding Remarks</textual></title><para class="po-block e529 e529"><textual class="po-textual">An API providing support for flexible tagging of text-oriented XML documents was introduced in this paper. It is based on the virtualization of selected sections of the XML document. It enables tag-aware full text search, obtaining match points and transparent updates to the underlying XML document.
The API enabled successful, automated tagging [</textual><xref class="po-milestone e530 e530" linkend="ren09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e531 e531" linkend="bri09a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
of a test corpus (146 articles, about 0.75% of the total number of articles) of the digitized version of the FEW, which is one of the most complex paper dictionaries.
Coverage, defined here as the percentage of the length of relevant sections of the XML document that are semantically tagged, consistently converges around 99.3%.
Precision and recall are not yet available. These metrics are very difficult to measure in the context of the FEW: A highly-trained human operator would need several days to manually add semantic tagging to the average FEW article.</textual></para><para class="po-block e532 e532"><textual class="po-textual">A Java implementation of the API was completed during the summer of 2009. The API itself is comprised of ~7500 lines of Java code, with additional dependencies on other parts of the code base (~69000 lines) of the FEW semantic tagging project, notably the node list data structure. It is clear that the current implementation, while 100% operational and used in production for a real-world project, can be optimized for speed (addressing, virtual text update and virtual tag splicing APIs) and for improved memory management (text virtualization API). One of the logical next steps will be to package (and optimize) the API implementation and the node list data structure into a library, so that other projects can benefit from them as well. External feedback on the syntax, semantics and expected performance of the operations provided by the API will be valuable.</textual></para><para class="po-block e533 e533"><textual class="po-textual">To conclude, the take-home message could be stated as follows. Our proposed virtual text retrieval API might be implemented in XQuery on top of Full Text, although probably at the expense of a performance overhead. The key feature of our proposed virtualization mechanism is to offer linguists a way to think of the dictionary and express themselves in a familiar environment: text without tags. Its flexibility and expressiveness are derived from (unconsciously, though, at the time of mechanism design) blending prior ideas, i.e. reading contexts [</textual><xref class="po-milestone e534 e534" linkend="lin01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e535 e535" linkend="tan06a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e536 e536" linkend="tan06b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and regular fragmentations [</textual><xref class="po-milestone e537 e537" linkend="stl01a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], with a good dose of dynamicity. Given the scope and complexity of the FEW dictionary [</textual><xref class="po-milestone e538 e538" linkend="ren07a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e539 e539" linkend="war22a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], an environment or data processing abstraction that is flexible and familiar to the API user might be more important than the power and breadth of features of successful, general-purpose technologies such as XQuery [</textual><xref class="po-milestone e540 e540" linkend="xqe"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Support for </textual><emphasis class="po-inline e541 e541"><textual class="po-textual">natural linguistic reasoning</textual></emphasis><textual class="po-textual">, i.e. tag-aware mixed-information (text/markup) retrieval and update, is the main contribution of our paper.</textual></para></section><section class="po-hcontainer e542 e542"><title class="po-block e543 e543"><textual class="po-textual">Acknowledgments</textual></title><para class="po-block e544 e544"><textual class="po-textual">We would like to thank Xavier Dalem, Stéfan Sinclair and the anonymous reviewers for their helpful suggestions that greatly improved the quality of the paper.
We also would like to thank Eva Buchi for her encouragement to prepare this paper,
as well as for a particularly relevant bibliographical hint that greatly helped us identify related works.</textual></para><para class="po-block e545 e545"><textual class="po-textual">Figure 1 includes icons from the </textual><link class="po-inline e546 e546" xlink:actuate="onRequest" xlink:href="http://tango.freedesktop.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Tango library</textual></link><textual class="po-textual">, under Creative Commons Attribution Share-Alike license.</textual></para><para class="po-block e547 e547"><textual class="po-textual">Finally, we would like to thank Chris Lilley for proofreading the final version of the paper; of course, all remaining typos and grammatical mistakes are ours.</textual></para></section><bibliography class="po-hcontainer e548 e548"><title class="po-block e549 e549"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e550 e550" xml:id="bri09a" xreflabel="Briquet2009a"><link class="po-inline e551 e551" xlink:actuate="onRequest" xlink:href="http://www.montefiore.ulg.ac.be/~briquet/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Cyril Briquet</textual></link><textual class="po-textual"> and Pascale Renders. </textual><emphasis class="po-inline e552 e552" role="ital"><textual class="po-textual">«Une approche reposante (RESTful) des aspects opérationnels de la rétroconversion du Französisches Etymologisches Wörterbuch (FEW)»</textual></emphasis><textual class="po-textual">. Proc. Liège Day in Processing of Gallo-Roman Sources (</textual><link class="po-inline e553 e553" xlink:actuate="onRequest" xlink:href="http://www.trasogal.ulg.ac.be" xlink:show="new" xlink:type="simple"><textual class="po-textual">TraSoGal</textual></link><textual class="po-textual">), May 2009.</textual></bibliomixed><bibliomixed class="po-block e554 e554" xml:id="buc96a" xreflabel="Buchi1996a"><textual class="po-textual">
</textual><link class="po-inline e555 e555" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/perso/buchi/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Éva Büchi</textual></link><textual class="po-textual">. </textual><emphasis class="po-inline e556 e556" role="ital"><textual class="po-textual">«Les Structures du /Französisches Etymologisches Wörterbuch/. Recherches métalexicographiques et métalexicologiques»</textual></emphasis><textual class="po-textual">, Niemeyer, Tübingen, 1996.</textual></bibliomixed><bibliomixed class="po-block e557 e557" xml:id="car03a" xreflabel="Carmel2003a"><textual class="po-textual">David Carmel, Yoelle S. Maarek, Matan Mandelbrod, Yosi Mass and Aya Soffer. </textual><emphasis class="po-inline e558 e558" role="ital"><textual class="po-textual">«Searching XML documents via XML fragments»</textual></emphasis><textual class="po-textual">. Proc. SIGIR, Toronto, ON, 2003.</textual></bibliomixed><bibliomixed class="po-block e559 e559" xml:id="den03a" xreflabel="Dendien2003a"><textual class="po-textual">Jacques Dendien and Jean-Marie Pierrel. </textual><emphasis class="po-inline e560 e560" role="ital"><textual class="po-textual">«Le Trésor de la Langue Française informatisé. Un exemple d’informatisation d’un dictionnaire de langue de référence»</textual></emphasis><textual class="po-textual">. In Traitement Automatique des Langues 43 (2), 2003.</textual></bibliomixed><bibliomixed class="po-block e561 e561" xml:id="der04a" xreflabel="DeRose2004a"><textual class="po-textual">Steven DeRose. </textual><emphasis class="po-inline e562 e562" role="ital"><textual class="po-textual">«</textual><link class="po-inline e563 e563" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">Markup Overlap: A Review and a Horse</textual></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. In Proc. Extreme Markup Languages, Montréal, Québec, August 2004.</textual></bibliomixed><bibliomixed class="po-block e564 e564" xml:id="dom" xreflabel="DOM"><link class="po-inline e565 e565" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Document Object Model (DOM)</textual></link><textual class="po-textual">. [online] [cited April 15, 2010] </textual><link class="po-inline e566 e566" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/DOM/</textual></link></bibliomixed><bibliomixed class="po-block e567 e567" xml:id="gate" xreflabel="GATE"><link class="po-inline e568 e568" xlink:actuate="onRequest" xlink:href="http://gate.ac.uk/" xlink:show="new" xlink:type="simple"><textual class="po-textual">General Architecture for Text Engineering</textual></link><textual class="po-textual">. [online] [cited June 25, 2010] </textual><link class="po-inline e569 e569" xlink:actuate="onRequest" xlink:href="http://gate.ac.uk/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://gate.ac.uk/</textual></link></bibliomixed><bibliomixed class="po-block e570 e570" xml:id="ie" xreflabel="IE"><link class="po-inline e571 e571" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Information_extraction" xlink:show="new" xlink:type="simple"><textual class="po-textual">Information Extraction</textual></link><textual class="po-textual">. [online] [cited June 25, 2010] </textual><link class="po-inline e572 e572" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Information_extraction" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Information_extraction</textual></link></bibliomixed><bibliomixed class="po-block e573 e573" xml:id="ibmie" xreflabel="IBMIE"><link class="po-inline e574 e574" xlink:actuate="onRequest" xlink:href="http://www.research.ibm.com/IE/" xlink:show="new" xlink:type="simple"><textual class="po-textual">IBM Trainable Information Extraction Systems</textual></link><textual class="po-textual">. [online] [cited June 25, 2010] </textual><link class="po-inline e575 e575" xlink:actuate="onRequest" xlink:href="http://www.research.ibm.com/IE/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.research.ibm.com/IE/</textual></link></bibliomixed><bibliomixed class="po-block e576 e576" xml:id="imh08a" xreflabel="Imhof2008a"><textual class="po-textual">Julia Imhof. </textual><emphasis class="po-inline e577 e577" role="ital"><textual class="po-textual">«</textual><link class="po-inline e578 e578" xlink:actuate="onRequest" xlink:href="http://e-collection.ethbib.ethz.ch/eserv/eth:30791/eth-30791-01.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">Evaluation Strategies for XQuery Full-Text</textual></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. M.S. Thesis, ETH Zurich, September 2008.</textual></bibliomixed><bibliomixed class="po-block e579 e579" xml:id="kam06a" xreflabel="Kamps2006a"><textual class="po-textual">Jaap Kamps, Maarten Marx, Maarten de Rijke and Börkur Sigurbjörnsson. </textual><emphasis class="po-inline e580 e580" role="ital"><textual class="po-textual">«Articulating Information Needs in XML Query Languages»</textual></emphasis><textual class="po-textual">. In ACM Transactions on Information Systems 24 (4), October 2006. doi: </textual><biblioid class="po-atom e581 doi e581"><textual class="po-textual">10.1145/1185877.1185879</textual></biblioid></bibliomixed><bibliomixed class="po-block e582 e582" xml:id="lin01a" xreflabel="Lini2001a"><textual class="po-textual">Luca Lini, Daniella Lombardini, Michele Paoli, Dario Colazzo and Carlo Sartiani. </textual><emphasis class="po-inline e583 e583" role="ital"><textual class="po-textual">«XTReSy: A Text Retrieval System for XML documents»</textual></emphasis><textual class="po-textual">. In D. Buzzetti, H. Short, and G. Pancalddella, editors, Augmenting Comprehension: Digital Tools for the History of Ideas. Office for Humanities Communication Publications, King's College, London, 2001.</textual></bibliomixed><bibliomixed class="po-block e584 e584" xml:id="oed" xreflabel="OED"><link class="po-inline e585 e585" xlink:actuate="onRequest" xlink:href="http://www.oed.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Oxford English Dictionary</textual></link><textual class="po-textual">. [online] [cited June 25, 2010] </textual><link class="po-inline e586 e586" xlink:actuate="onRequest" xlink:href="http://www.oed.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oed.com/</textual></link></bibliomixed><bibliomixed class="po-block e587 e587" xml:id="oedwiki" xreflabel="OED"><link class="po-inline e588 e588" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Oxford_English_Dictionary" xlink:show="new" xlink:type="simple"><textual class="po-textual">Oxford English Dictionary</textual></link><textual class="po-textual">. [online] [cited June 25, 2010] </textual><link class="po-inline e589 e589" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Oxford_English_Dictionary" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Oxford_English_Dictionary</textual></link></bibliomixed><bibliomixed class="po-block e590 e590" xml:id="projectfew" xreflabel="ProjectFEW"><link class="po-inline e591 e591" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/few" xlink:show="new" xlink:type="simple"><textual class="po-textual">Französisches Etymologisches Wörterbuch</textual></link><textual class="po-textual">. [online] [cited April 15, 2010] </textual><link class="po-inline e592 e592" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/few" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.atilf.fr/few</textual></link></bibliomixed><bibliomixed class="po-block e593 e593" xml:id="pug90a" xreflabel="Pugh1990a"><textual class="po-textual">William Pugh. </textual><emphasis class="po-inline e594 e594" role="ital"><textual class="po-textual">«Skip lists: a probabilistic alternative to balanced trees»</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e595 e595" xlink:actuate="onRequest" xlink:href="http://cacm.acm.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Communications of the ACM</textual></link><textual class="po-textual"> 33 (6), June 1990. doi: </textual><biblioid class="po-atom e596 doi e596"><textual class="po-textual">10.1145/78973.78977</textual></biblioid></bibliomixed><bibliomixed class="po-block e597 e597" xml:id="qui08a" xreflabel="Quin2008a"><textual class="po-textual">Liam R. E. Quin. </textual><emphasis class="po-inline e598 e598" role="ital"><textual class="po-textual">«</textual><link class="po-inline e599 e599" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol1/html/Quin01/BalisageVol1-Quin01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">Text Retrieval for XML-Encoded Corpora: A Lexical Approach</textual></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. Proc. </textual><link class="po-inline e600 e600" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Balisage</textual></link><textual class="po-textual">, August 2008. doi: </textual><biblioid class="po-atom e601 doi e601"><textual class="po-textual">10.4242/BalisageVol1.Quin01</textual></biblioid></bibliomixed><bibliomixed class="po-block e602 e602" xml:id="ren07a" xreflabel="Renders2007a"><textual class="po-textual">Pascale Renders. </textual><emphasis class="po-inline e603 e603" role="ital"><textual class="po-textual">«L’informatisation du Französisches Etymologisches Wörterbuch : quels objectifs, quelles possibilités ?»</textual></emphasis><textual class="po-textual">. Proc. Congrès International de Linguistique et de Philologie Romanes, Innsbruck, Austria, September 2007.</textual></bibliomixed><bibliomixed class="po-block e604 e604" xml:id="ren09a" xreflabel="Renders2009a"><textual class="po-textual">Pascale Renders and </textual><link class="po-inline e605 e605" xlink:actuate="onRequest" xlink:href="http://www.montefiore.ulg.ac.be/~briquet/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Cyril Briquet</textual></link><textual class="po-textual">. </textual><emphasis class="po-inline e606 e606" role="ital"><textual class="po-textual">«Conception d’algorithmes de rétroconversion»</textual></emphasis><textual class="po-textual">. Proc. Liège Day in Processing of Gallo-Roman Sources (</textual><link class="po-inline e607 e607" xlink:actuate="onRequest" xlink:href="http://www.trasogal.ulg.ac.be" xlink:show="new" xlink:type="simple"><textual class="po-textual">TraSoGal</textual></link><textual class="po-textual">), May 2009.</textual></bibliomixed><bibliomixed class="po-block e608 e608" xml:id="rfg" xreflabel="RegFrag"><link class="po-inline e609 e609" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/projects/fragment/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Regular Fragmentations</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e610 e610" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/projects/fragment/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.simonstl.com/projects/fragment/</textual></link></bibliomixed><bibliomixed class="po-block e611 e611" xml:id="sav10a" xreflabel="Savage2010a"><textual class="po-textual">Neil Savage. </textual><emphasis class="po-inline e612 e612" role="ital"><textual class="po-textual">«New Search Challenges and Opportunities»</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e613 e613" xlink:actuate="onRequest" xlink:href="http://cacm.acm.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Communications of the ACM</textual></link><textual class="po-textual"> 53 (1), January 2010. doi: </textual><biblioid class="po-atom e614 doi e614"><textual class="po-textual">10.1145/1629175.1629183</textual></biblioid></bibliomixed><bibliomixed class="po-block e615 e615" xml:id="stl01a" xreflabel="StLaurent2001a"><textual class="po-textual">Simon St.Laurent. </textual><emphasis class="po-inline e616 e616" role="ital"><textual class="po-textual">«</textual><link class="po-inline e617 e617" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/articles/regfrag/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Treating Complex Textual Content as Markup</textual></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. Proc. Extreme Markup Languages, Montréal, Québec, 2001.</textual></bibliomixed><bibliomixed class="po-block e618 e618" xml:id="stp" xreflabel="StringProjection"><link class="po-inline e619 e619" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/String_projection" xlink:show="new" xlink:type="simple"><textual class="po-textual">String Projection</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e620 e620" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/String_projection" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/String_projection</textual></link></bibliomixed><bibliomixed class="po-block e621 e621" xml:id="tlf04a" xreflabel="TLFi04a"><emphasis class="po-inline e622 e622" role="ital"><textual class="po-textual">«Trésor de la Langue Française informatisé»</textual></emphasis><textual class="po-textual"> (TLFi) CD-ROM, CNRS Editions, Paris, 2004.</textual></bibliomixed><bibliomixed class="po-block e623 e623" xml:id="tlfi" xreflabel="TLFi"><link class="po-inline e624 e624" xlink:actuate="onRequest" xlink:href="http://atilf.atilf.fr/tlf.htm" xlink:show="new" xlink:type="simple"><textual class="po-textual">Trésor de la Langue Française informatisé</textual></link><textual class="po-textual"> [online] [cited April 14, 2010] </textual><link class="po-inline e625 e625" xlink:actuate="onRequest" xlink:href="http://atilf.atilf.fr/tlf.htm" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://atilf.atilf.fr/tlf.htm</textual></link></bibliomixed><bibliomixed class="po-block e626 e626" xml:id="tan05a" xreflabel="Tannier2005a"><textual class="po-textual">Xavier Tannier, Jean-Jacques Girardot and Mihaela Mathieu. </textual><emphasis class="po-inline e627 e627" role="ital"><textual class="po-textual">«Classifying XML Tags through </textual><quote class="po-inline e628 e628"><textual class="po-textual">Reading Contexts</textual></quote><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. Proc. ACM Symposium on Document Engineering, Bristol, UK, 2005. doi: </textual><biblioid class="po-atom e629 doi e629"><textual class="po-textual">10.1145/1096601.1096638</textual></biblioid></bibliomixed><bibliomixed class="po-block e630 e630" xml:id="tan06a" xreflabel="Tannier2006a"><textual class="po-textual">Xavier Tannier. </textual><emphasis class="po-inline e631 e631" role="ital"><textual class="po-textual">«</textual><link class="po-inline e632 e632" xlink:actuate="onRequest" xlink:href="http://www.atala.org/article.php3?id_article=329" xlink:show="new" xlink:type="simple"><textual class="po-textual">Traiter les documents XML avec les </textual><quote class="po-inline e633 e633"><textual class="po-textual">contextes de lecture</textual></quote></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. Traitement Automatique des Langues 47 (1), 2006.</textual></bibliomixed><bibliomixed class="po-block e634 e634" xml:id="tan06b" xreflabel="Tannier2006b"><textual class="po-textual">Xavier Tannier. </textual><emphasis class="po-inline e635 e635" role="ital"><textual class="po-textual">«</textual><link class="po-inline e636 e636" xlink:actuate="onRequest" xlink:href="http://www.limsi.fr/Individu/xtannier/Publications/Tannier_These.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">Extraction et recherche d'information en langage naturel dans les documents semi-structurés</textual></link><textual class="po-textual">»</textual></emphasis><textual class="po-textual">. PhD Dissertation, Ecole Nationale Supérieure des Mines, Saint-Etienne, September 2006.</textual></bibliomixed><bibliomixed class="po-block e637 e637" xml:id="voo05a" xreflabel="Voort2005a"><textual class="po-textual">John van der Voort van der Kleij. </textual><emphasis class="po-inline e638 e638" role="ital"><textual class="po-textual">«Reverse Lemmatizing of the Dictionary of Middle Dutch (1885-1929) Using Pattern Matching»</textual></emphasis><textual class="po-textual">. Proc. Conf. Computational Lexicography and Text Research, Budapest, Hungary, 2005.</textual></bibliomixed><bibliomixed class="po-block e639 e639" xml:id="war22a" xreflabel="Wartburg1922a"><textual class="po-textual">Walther von Wartburg et al. </textual><emphasis class="po-inline e640 e640" role="ital"><textual class="po-textual">«Französisches Etymologisches Wörterbuch. Eine darstellung des galloromanischen sprachschatzes»</textual></emphasis><textual class="po-textual">, 25 volumes, Bonn/Heidelberg/Leipzig-Berlin/Bâle, Klopp/Winter/Teubner/Zbinden, 1922-2002.</textual></bibliomixed><bibliomixed class="po-block e641 e641" xml:id="xpat" xreflabel="XPath"><link class="po-inline e642 e642" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XPath" xlink:show="new" xlink:type="simple"><textual class="po-textual">XPath</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e643 e643" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XPath" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/XPath</textual></link></bibliomixed><bibliomixed class="po-block e644 e644" xml:id="xqe" xreflabel="XQuery"><link class="po-inline e645 e645" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XQuery" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e646 e646" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XQuery" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/XQuery</textual></link></bibliomixed><bibliomixed class="po-block e647 e647" xml:id="xqf" xreflabel="XQueryXPathFullText"><link class="po-inline e648 e648" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-full-text-10/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery and XPath Full Text 1.0</textual></link><textual class="po-textual"> [online] [cited June 25, 2010] </textual><link class="po-inline e649 e649" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-full-text-10/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-full-text-10/</textual></link></bibliomixed><bibliomixed class="po-block e650 e650" xml:id="xqfi" xreflabel="XQueryFullTextIntro"><textual class="po-textual">Xavier Franc. </textual><link class="po-inline e651 e651" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryFullText/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery Full-Text for the impatient</textual></link><textual class="po-textual"> [online] [cited June 25, 2010] </textual><link class="po-inline e652 e652" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryFullText/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlmind.com/_tutorials/XQueryFullText/index.html</textual></link></bibliomixed><bibliomixed class="po-block e653 e653" xml:id="xqui" xreflabel="XQueryUpdateIntro"><textual class="po-textual">Xavier Franc. </textual><link class="po-inline e654 e654" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery Update for the impatient: A quick introduction to the XQuery Update Facility</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e655 e655" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html</textual></link></bibliomixed><bibliomixed class="po-block e656 e656" xml:id="xqu" xreflabel="XQueryUpdate"><link class="po-inline e657 e657" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery Update Facility 1.0</textual></link><textual class="po-textual"> [online] [cited April 15, 2010] </textual><link class="po-inline e658 e658" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery-update-10/</textual></link></bibliomixed></bibliography></article></classedDocument>