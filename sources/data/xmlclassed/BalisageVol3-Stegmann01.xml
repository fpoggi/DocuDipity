<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">TEI Feature Structures as a Representation Format for Multiple Annotation and Generic XML
  Documents</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2009</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 11 - 14, 2009</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual"> Feature structures are mathematical entities (rooted labeled directed acyclic graphs) that
    can be represented as graph displays, attribute value matrices or as XML adhering to the
    constraints of a specialized TEI tag set. We demonstrate that this latter ISO-standardized
    format can be used as an integrative storage and exchange format for sets of multiple annotation
    XML documents. This specific domain of application is rooted in the approach of multiple
    annotations, which marks a possible solution for XML-compliant markup in scenarios with
    conflicting annotation hierarchies. A more extreme proposal consists in the possible use as a
    meta-representation format for generic XML documents. For both scenarios our strategy concerning
    pertinent feature structure representations is grounded on the XDM (XQuery 1.0 and XPath 2.0
    Data Model). The ubiquitous hierarchical and sequential relationships within XML documents are
    represented by specific features that take ordered list values. The mapping to the TEI feature
    structure format has been implemented in the form of an XSLT 2.0 stylesheet. It can be
    characterized as exploiting aspects of both the push and pull processing paradigm as
    appropriate. An indexing mechanism is provided with regard to the multiple annotation documents
    scenario. Hence, implicit links concerning identical primary data are made explicit in the
    result format. In comparison to alternative representations, the TEI-based format does well in
    many respects, since it is both integrative and well-formed XML. However, the result documents
    tend to grow very large depending on the size of the input documents and their respective markup
    structure. This may also be considered as a downside regarding the proposed use for generic XML
    documents. On the positive side, it may be possible to achieve a hookup to methods and
    applications that have been developed for feature structure representations in the fields of
    (computational) linguistics and knowledge representation. </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Jens</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Stegmann</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Jens Stegmann studied linguistics, psychology and computer science at Bielefeld
     University. Parts of this paper deal with aspects of his Master thesis.</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">Bielefeld University</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">jens.stegmann@googlemail.com</textual></email></author><author class="po-record e17 e17"><personname class="po-record e18 e18"><firstname class="po-field e19 e19"><textual class="po-textual">Andreas</textual></firstname><surname class="po-field e20 e20"><textual class="po-textual">Witt</textual></surname></personname><personblurb class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Witt received his Ph.D. in Computational Linguistics and Text Technology from the
     Bielefeld University in 2002 (dissertation title: Multiple Informationsstrukturierung mit
     Auszeichnungssprachen. XML-basierte Methoden und deren Nutzen für die Sprachtechnologie). </textual></para><para class="po-block e23 e23"><textual class="po-textual">After graduating in 1996, he started as a researcher and instructor in Computational
     Linguistics and Text Technology. He was heavily involved in the establishment of the minor
     subject Text Technology in Bielefeld University´s Magister and B.A. program in 1999 and 2002
     respectively. After his Ph.D. in 2002 he became an assistant lecturer, still at the Text
     Technology group in Bielefeld. In 2006 he moved to Tübingen University, where he was involved
     in a project on "Sustainability of Linguistic Resources" and in projects on the
     interoperability of language data. Since 2009 he is senior researcher at "Institut für Deutsche
     Sprache" (Institute for the German Language) in Mannheim. </textual></para><para class="po-block e24 e24"><textual class="po-textual">Witt is and was a member of several research organizations, amongst them the TEI Special
     Interest Group on overlapping markup, for which he was involved in the writing of the latest
     version of the chapter "Multiple Hierarchies", which is included in TEI-Guidelines P5.</textual></para><para class="po-block e25 e25"><textual class="po-textual">Witt's main research interests deal with questions on the use and limitations of markup
     languages for the linguistic description of language data.</textual></para></personblurb><affiliation class="po-record e26 e26"><orgname class="po-block e27 e27"><textual class="po-textual">Institute for the German Language (IDS), Mannheim</textual></orgname></affiliation><email class="po-field e28 e28"><textual class="po-textual">witt@ids-mannheim.de</textual></email></author><legalnotice class="po-container e29 e29"><para class="po-block e30 e30"><textual class="po-textual">Copyright © 2009 by the authors.  Used with
    permission.</textual></para></legalnotice><keywordset class="po-table e31 e31" role="author"><keyword class="po-field e32 e32"><textual class="po-textual">Overlapping Structures</textual></keyword><keyword class="po-field e33 e33"><textual class="po-textual">Multiple Hierarchies</textual></keyword><keyword class="po-field e34 e34"><textual class="po-textual">Multiple Annotation</textual></keyword><keyword class="po-field e35 e35"><textual class="po-textual">TEI</textual></keyword><keyword class="po-field e36 e36"><textual class="po-textual">Text Encoding Initiative</textual></keyword><keyword class="po-field e37 e37"><textual class="po-textual">Feature Structures</textual></keyword></keywordset></info><section class="po-hcontainer e38 e38" xml:id="s1" xreflabel="“Introduction”"><title class="po-block e39 e39"><textual class="po-textual">Introduction</textual></title><para class="po-block e40 e40"><textual class="po-textual"> As the title suggests, this contribution describes aspects of the use of a certain
   representation format ("TEI Feature Structures") with regard to a specific domain of application
   ("Multiple Annotation") and also concerning a second, much more general kind of scenario
   ("Generic XML Documents"). </textual></para><para class="po-block e41 e41"><textual class="po-textual"> TEI P5 </textual><xref class="po-milestone e42 e42" linkend="p5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> compliant encodings of feature structures, which we refer to as
    </textual><emphasis class="po-inline e43 e43"><textual class="po-textual">TEI feature structures</textual></emphasis><textual class="po-textual"> in this article, will receive much of our attention.
    </textual><xref class="po-milestone e44 e44" linkend="f1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a simple example: the encoding of a certain feature structure
     </textual><emphasis class="po-inline e45 e45"><textual class="po-textual">F</textual><subscript class="po-atom e46 e46"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual">. </textual><emphasis class="po-inline e47 e47"><textual class="po-textual">F</textual><subscript class="po-atom e48 e48"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual">
   serves to characterize a specific class of linguistic entities here, namely nominal phrases of
   the third person singular kind.</textual></para><figure class="po-container e49 e49" xml:id="f1" xreflabel="Figure 1"><title class="po-block e50 e50"><textual class="po-textual">TEI Encoding of a Feature Structure </textual><emphasis class="po-inline e51 e51"><textual class="po-textual">F</textual><subscript class="po-atom e52 e52"><textual class="po-textual">1</textual></subscript></emphasis></title><programlisting class="po-block e53 e53" xml:space="preserve"><textual class="po-textual">
&lt;fs&gt;
 &lt;f name="CAT"&gt;
  &lt;symbol value="np" /&gt;
 &lt;/f&gt;
 &lt;f name="AGR"&gt;
  &lt;fs&gt;
   &lt;f name="NUM"&gt;
    &lt;symbol value="sing" /&gt;
   &lt;/f&gt;
   &lt;f name="PER" /&gt;
    &lt;symbol value="third" /&gt;
   &lt;/f&gt;
  &lt;/fs&gt;
 &lt;/f&gt;
&lt;/fs&gt;
            </textual></programlisting></figure><para class="po-block e54 e54"><textual class="po-textual"> There are two features on the top-level of </textual><emphasis class="po-inline e55 e55"><textual class="po-textual">F</textual><subscript class="po-atom e56 e56"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual">:
    </textual><code class="po-atom e57 e57"><textual class="po-textual">CAT</textual></code><textual class="po-textual"> with its value </textual><code class="po-atom e58 e58"><textual class="po-textual">np</textual></code><textual class="po-textual"> and </textual><code class="po-atom e59 e59"><textual class="po-textual">AGR</textual></code><textual class="po-textual"> with an associated complex
   value, which is a feature structure itself. This latter embedded structure consists of the
   feature-value pairs </textual><code class="po-atom e60 e60"><textual class="po-textual">NUM</textual></code><textual class="po-textual"> with value </textual><code class="po-atom e61 e61"><textual class="po-textual">sing</textual></code><textual class="po-textual"> and </textual><code class="po-atom e62 e62"><textual class="po-textual">PER</textual></code><textual class="po-textual"> with value
    </textual><code class="po-atom e63 e63"><textual class="po-textual">third</textual></code><textual class="po-textual">. We will return to the theme of encoding
    </textual><emphasis class="po-inline e64 e64"><textual class="po-textual">F</textual><subscript class="po-atom e65 e65"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual"> below (</textual><xref class="po-milestone e66 e66" linkend="s2.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Since we will use
   the same example there, it will be possible to compare different syntaxes for the display of
   feature structures in a straightforward way. We do not delve into details connected with the XML
   syntax exemplified in </textual><xref class="po-milestone e67 e67" linkend="f1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> here, since this will be the topic of another part of
   this article (</textual><xref class="po-milestone e68 e68" linkend="s2.2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In the rest of this introductory section, we shall try to
   shed some light upon the two application domains that have been mentioned above. </textual></para><para class="po-block e69 e69"><textual class="po-textual"> The more specific scenario consists in the integrative representation of annotation
   documents along the approach of </textual><emphasis class="po-inline e70 e70"><textual class="po-textual">multiple annotations</textual></emphasis><textual class="po-textual">
   </textual><xref class="po-milestone e71 e71" linkend="witt2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. The multiple annotations approach marks a possible solution with
   regard to the markup of overlapping structures. Linguists, e.g., do often encounter XML-related
   problems, when they try to annotate a common core of linguistic data according to different
   levels of linguistic analysis (phonology, morphology, syntax, semantics, and pragmatics). The
   most straightforward way of marking things up might involve the incorporation of crossing edges.
   Such, however, is prohibited on grounds of XML's foundational tree structure. It can be argued
   that such configurations of data with conflicting hierarchies require a different kind of data
   structure, i.e., a </textual><emphasis class="po-inline e72 e72"><textual class="po-textual">multi-rooted tree</textual></emphasis><textual class="po-textual"> (</textual><xref class="po-milestone e73 e73" linkend="carletta2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,</textual><xref class="po-milestone e74 e74" linkend="woerner2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e75 e75" linkend="witt2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). A multi-rooted tree consists of several
   trees that span over the same data leaves. The multiple annotations approach now proposes to mark
   up each description level / tree as a document instance in its own right. This allows for each
   document to consist of well-formed XML, the modeling of alternative annotations is possible, the
   levels can be viewed separately, and new levels can be added at any time </textual><xref class="po-milestone e76 e76" linkend="witt2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. However, such documents may seem to be somewhat unrelated and independent of each other. Witt
   therefore proposes to regard the primary textual data, which have to be identical across all such
   annotation documents, as the defining implicit link between them. Of course, it would be
   desirable to bring such implicit linkages forward as explicit ones. This can be done, e.g.,
   during the course of a transformation to an adequate representation format. We intend to show
   that the ISO-standardized TEI tag set for the representation of feature structures can be such a
   representation format. Pros, cons and alternative strategies with respect to
    </textual><emphasis class="po-inline e77 e77"><textual class="po-textual">overlapping structures</textual></emphasis><textual class="po-textual"> are discussed in the pertinent literature, compare
    </textual><xref class="po-milestone e78 e78" linkend="derose2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e79 e79" linkend="sperberg-mcqueen2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e80 e80" linkend="carletta2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for an overview.</textual></para><para class="po-block e81 e81"><textual class="po-textual"> Besides the different stages of the TEI recommendations (</textual><xref class="po-milestone e82 e82" linkend="p3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e83 e83" linkend="p4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e84 e84" linkend="p5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), at least one alternative proposal concerning the
    </textual><emphasis class="po-inline e85 e85"><textual class="po-textual">encoding of feature structures as SGML/XML markup</textual></emphasis><textual class="po-textual"> has been brought forward
   in the literature </textual><xref class="po-milestone e86 e86" linkend="sailer2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. However, to the best of our knowledge, no one has
   yet discussed the question how a representation in the opposite direction could look like, i.e.,
    </textual><emphasis class="po-inline e87 e87"><textual class="po-textual">encoding SGML/XML markup documents as feature structures</textual></emphasis><textual class="po-textual">. We will come up
   with an original answer to this question, as we succeed concerning the more specific goal of
   finding a way to represent sets of multiple annotation documents as TEI feature structures.
   Feature Structures can be regarded as a general type of data structure and there may be specific
   advantages associated with their use as a meta-representation format. We will speculate about
   related aspects in the last section of this paper. </textual></para><para class="po-block e88 e88"><textual class="po-textual"> The structure for the rest of this article looks as follows. In the next section (</textual><xref class="po-milestone e89 e89" linkend="s2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), we characterize feature structures as mathematical entities and introduce three
   syntaxes for means of visualization and encoding: graph displays, attribute value matrices and
   the pertinent TEI tag set. Ways to represent XML documents as TEI feature structures and aspects
   of the XSLT-implemented transformation from multiple annotation and generic XML documents to the
   integrative TEI feature structure format are discussed in the next section (</textual><xref class="po-milestone e90 e90" linkend="s3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Finally, we summarize our findings, take up some loose ends from the previous sections and
   discuss the relative advantages and disadvantages of representations in terms of TEI feature
   structures in the last section (</textual><xref class="po-milestone e91 e91" linkend="s4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) of this contribution. </textual></para></section><section class="po-hcontainer e92 e92" xml:id="s2" xreflabel="“Feature Structures”"><title class="po-block e93 e93"><textual class="po-textual">Feature Structures</textual></title><section class="po-hcontainer e94 e94" xml:id="s2.1" xreflabel="“Feature Structures in a Nutshell”"><title class="po-block e95 e95"><textual class="po-textual">Feature Structures in a Nutshell</textual></title><para class="po-block e96 e96"><emphasis class="po-inline e97 e97"><textual class="po-textual">Feature structures</textual></emphasis><textual class="po-textual"> are a common means of representation in formal
    linguistic theory.</textual><footnote class="po-popup e98 e98"><para class="po-block e99 e99"><textual class="po-textual">There are equivalent structures in other environments, too, as one of our anonymous
      reviewers remarked. Compare the National Library of Medicine's </textual><emphasis class="po-inline e100 e100"><textual class="po-textual">custom-meta
       structures</textual></emphasis><textual class="po-textual">
      </textual><xref class="po-milestone e101 e101" linkend="nlm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, for example. </textual></para></footnote><textual class="po-textual"> Their use is most prominent in certain variants of generative grammar </textual><xref class="po-milestone e102 e102" linkend="shieber1986"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
    </textual><footnote class="po-popup e103 e103"><para class="po-block e104 e104"><textual class="po-textual">Namely unification-based grammars, whose name derives from the most important operation
      on feature structures, i.e., unification.</textual></para></footnote><textual class="po-textual">, but not constrained to the syntactic level of analysis, e.g., there are linguistic
    applications in phonology, morphology, semantics and pragmatics, too. Furthermore, feature
    structures can be characterized as a general purpose data structure </textual><xref class="po-milestone e105 e105" linkend="iso24610"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
    with possible applications in the vast field of knowledge representation. Hence, their
    usefulness is by no means constrained to linguistic investigations alone.</textual></para><para class="po-block e106 e106"><textual class="po-textual"> From a mathematical stance, there are at least two perspectives on feature structures
     </textual><xref class="po-milestone e107 e107" linkend="shieber1986"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. On the one hand, a feature structure can be construed as a
    partial function from a set of </textual><emphasis class="po-inline e108 e108"><textual class="po-textual">features</textual></emphasis><textual class="po-textual"> to a set of
     </textual><emphasis class="po-inline e109 e109"><textual class="po-textual">values</textual></emphasis><textual class="po-textual">. The value associated with a certain feature can be either
     </textual><emphasis class="po-inline e110 e110"><textual class="po-textual">atomic</textual></emphasis><textual class="po-textual">, e.g., a specific symbolic value as </textual><code class="po-atom e111 e111"><textual class="po-textual">element</textual></code><textual class="po-textual"> or a
    binary value like </textual><code class="po-atom e112 e112"><textual class="po-textual">true</textual></code><textual class="po-textual">, or it may be </textual><emphasis class="po-inline e113 e113"><textual class="po-textual">complex</textual></emphasis><textual class="po-textual">. The latter means
    that it can be a full-blown feature structure itself or it may be of a </textual><emphasis class="po-inline e114 e114"><textual class="po-textual">collection
     value</textual></emphasis><textual class="po-textual"> type like a set or a list of, again, possibly complex values. We will come
    upon numerous examples below. Due to the availability of complex values, feature structures can
    embed other feature structures in value position and, hence, provide a considerable degree of
    representational articulateness. Note that there will be no significance to the order of
    features that are located on the same hierarchical level within a feature structure.</textual></para><para class="po-block e115 e115"><textual class="po-textual">Another mathematical perspective derives from graph theory and leads to the
    characterization of feature structures as rooted labeled directed (acyclic)</textual><footnote class="po-popup e116 e116"><para class="po-block e117 e117"><textual class="po-textual">Some formalizations of feature structures allow cycles and it can also be argued that
      cyclic structures may be needed for the representation of certain phenomena as the liar's
      paradox ("This statement is false.").</textual></para></footnote><textual class="po-textual"> graphs. Graphs </textual><xref class="po-milestone e118 e118" linkend="diestel2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> are mathematical entities that consist
    of sets of nodes and edges. We can think of the edges of a graph as connecting its nodes. Graphs
    can be depicted in an intuitively appealing way as diagram displays. The labeled edges represent
    the features, the leaf nodes represent the atomic values, and the inner nodes, if any, represent
    the complex values of a feature structure. </textual><xref class="po-milestone e119 e119" linkend="f2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is an example </textual><emphasis class="po-inline e120 e120"><textual class="po-textual">graph
     display</textual></emphasis><textual class="po-textual"> of the feature structure </textual><emphasis class="po-inline e121 e121"><textual class="po-textual">F</textual><subscript class="po-atom e122 e122"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual">,
    compare </textual><xref class="po-milestone e123 e123" linkend="f1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> in the preceding section for the TEI counterpart. </textual></para><figure class="po-container e124 e124" xml:id="f2" xreflabel="Figure 2"><title class="po-block e125 e125"><textual class="po-textual">Graph Display of the Feature Structure
     </textual><emphasis class="po-inline e126 e126"><textual class="po-textual">F</textual><subscript class="po-atom e127 e127"><textual class="po-textual">1</textual></subscript></emphasis></title><mediaobject class="po-container e128 e128"><imageobject class="po-container e129 e129"><imagedata class="po-meta e130 e130" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-001.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e131 e131"><textual class="po-textual"> There is an alternative to the visualization of feature structures as graph displays. It
    consists in the use of attribute value matrices.</textual><footnote class="po-popup e132 e132"><para class="po-block e133 e133"><textual class="po-textual">Some linguistic theories use different notations for (total) models vs. (partial)
      descriptions. For example, HPSG </textual><xref class="po-milestone e134 e134" linkend="pollard1994"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> uses graph displays for models
      and AVMs for descriptions.</textual></para></footnote><textual class="po-textual"> In </textual><emphasis class="po-inline e135 e135"><textual class="po-textual">attribute value matrix</textual></emphasis><textual class="po-textual"> notation, the features are written  to the left of their associated values and there are brackets that indicate the
    scope of the (sub-)feature structure(s) involved.</textual><footnote class="po-popup e136 e136"><para class="po-block e137 e137"><textual class="po-textual">Feature names are usually capitalized on grounds of a notational convention. </textual></para></footnote><textual class="po-textual"> </textual><xref class="po-milestone e138 e138" linkend="f3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows
      </textual><emphasis class="po-inline e139 e139"><textual class="po-textual">F</textual><subscript class="po-atom e140 e140"><textual class="po-textual">1</textual></subscript></emphasis><textual class="po-textual"> in attribute value matrix notation, compare
     </textual><xref class="po-milestone e141 e141" linkend="f1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e142 e142" linkend="f2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> above for the TEI- and graph display
    counterparts. Concerning the forthcoming examples in this article, we will only use the TEI
    format and the attribute value matrix notation.</textual></para><figure class="po-container e143 e143" xml:id="f3" xreflabel="Figure 3"><title class="po-block e144 e144"><textual class="po-textual">Attribute Value Matrix Notation of the Feature Structure
       </textual><emphasis class="po-inline e145 e145"><textual class="po-textual">F</textual><subscript class="po-atom e146 e146"><textual class="po-textual">1</textual></subscript></emphasis></title><mediaobject class="po-container e147 e147"><imageobject class="po-container e148 e148"><imagedata class="po-meta e149 e149" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-002.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e150 e150"><textual class="po-textual"> Feature structures list correct information and only correct information, but they do not
    necessarily contain all the correct information with regard to a specific object, i.e., they may
    be of a </textual><emphasis class="po-inline e151 e151"><textual class="po-textual">partial</textual></emphasis><textual class="po-textual"> nature.</textual><footnote class="po-popup e152 e152"><para class="po-block e153 e153"><textual class="po-textual">HPSG theoreticians </textual><xref class="po-milestone e154 e154" linkend="pollard1994"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> draw a distinction between
       </textual><emphasis class="po-inline e155 e155"><textual class="po-textual">feature structures</textual></emphasis><textual class="po-textual">, which can be characterized as total objects in the
      sense of containing all the relevant specifications with respect to the objects they are a
      model of, and </textual><emphasis class="po-inline e156 e156"><textual class="po-textual">feature structure descriptions</textual></emphasis><textual class="po-textual">, which are partial
      descriptions of feature structures. From this perspective, feature structures and feature
      structure descriptions belong to different theoretical realms (model vs. formalism). We will
      not delve deeper into this discussion here and continue with our usage of the term feature
      structure for partial objects also. </textual></para></footnote><textual class="po-textual"> Partiality can be a good thing, since it allows for feature structures to capture
    generalizations via the underspecification of certain properties.</textual></para><para class="po-block e157 e157"><textual class="po-textual">When features have identical values, there are two scenarios to consider: the values can be
    either type- or token-identical. If the values are merely type-identical, we can characterize
    them as being independent of one another. A hypothetical change to one of the values would have
    no effect on the other values involved. However, in case of token-identity the features are
    associated with one and the same value token and, hence, are dependent on it. A change to the
    token would affect all the features that reference it. This latter scenario of token-identity is
    also called coreference, </textual><emphasis class="po-inline e158 e158"><textual class="po-textual">structure sharing</textual></emphasis><textual class="po-textual"> or reentrancy. In attribute
    value matrix notation, it can be indicated by means of co-indexed boxes that either act as a
    referring place-holder in value position or they may be written before a certain value token and
    such all occurrences of the index within the feature structure are bound to that value. We will
    come upon an example in the next subsection of this article, cf. </textual><xref class="po-milestone e159 e159" linkend="f5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> below. At
    the graph display level, we would use edges that lead into one and the same node in order to
    indicate structure sharing. </textual></para><para class="po-block e160 e160"><textual class="po-textual"> An important operation upon feature structures is unification </textual><xref class="po-milestone e161 e161" linkend="shieber1986"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. The foundational idea is fairly simple and can be sketched as follows: the result of the
    unification of compatible feature structures is the most general feature structure that contains
    all the information of the unified feature structures. Technically, unification is defined via
    the auxiliary concept of subsumption. </textual><emphasis class="po-inline e162 e162"><textual class="po-textual">Subsumption</textual></emphasis><textual class="po-textual"> implements an intuitive
    concept of specificity and wealth of information among feature structures. We define that a
    feature structure F' subsumes a feature structure F'' if F' contains a subset of the information
    in F'' </textual><xref class="po-milestone e163 e163" linkend="shieber1986"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Alternatively, we may say that F' carries less information
    than F'' or that F' is more general than F''. Subsumption is a partial order on the set of
    feature structures, since feature structures may be incompatible with each other. Now, we can
    define the </textual><emphasis class="po-inline e164 e164"><textual class="po-textual">unification</textual></emphasis><textual class="po-textual"> of two feature structures F and G, if any, to be the
    most general feature structure H, such that F subsumes H and G subsumes H. If the feature
    structures to be unified are incompatible, we say that the unification fails. A related
    operation that works in the opposite direction is generalization. This operation is the dual of
    unification. We can define the </textual><emphasis class="po-inline e165 e165"><textual class="po-textual">generalization</textual></emphasis><textual class="po-textual"> of two feature structures F
    and G to be the most specific feature structure E, such that E subsumes F and E subsumes G.
    Unlike unification, generalization cannot fail. In the worst case, the result will be the empty
    feature structure [ ] that subsumes every feature structure.</textual></para><para class="po-block e166 e166"><textual class="po-textual"> It should be noted that feature structures can be </textual><emphasis class="po-inline e167 e167"><textual class="po-textual">typed</textual></emphasis><textual class="po-textual">
    </textual><xref class="po-milestone e168 e168" linkend="carpenter1992"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. However, neither the present state of the representations nor
    the implemented transformation that we describe in this paper does make use of typed feature
    structures, so we won't go into details regarding that topic here. </textual></para></section><section class="po-hcontainer e169 e169" xml:id="s2.2" xreflabel="“The TEI Tag Set for Feature Structures”"><title class="po-block e170 e170"><textual class="po-textual">The TEI Tag Set for Feature Structures</textual></title><para class="po-block e171 e171"><textual class="po-textual">The TEI tag set for the representation of feature structures has been a part of the TEI
    Guidelines since version </textual><emphasis class="po-inline e172 e172"><textual class="po-textual">P3</textual></emphasis><textual class="po-textual">
    </textual><xref class="po-milestone e173 e173" linkend="p3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Building on the </textual><emphasis class="po-inline e174 e174"><textual class="po-textual">P4</textual></emphasis><textual class="po-textual"> version </textual><xref class="po-milestone e175 e175" linkend="p4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, an
     </textual><emphasis class="po-inline e176 e176"><textual class="po-textual">ISO</textual></emphasis><textual class="po-textual"> standard </textual><xref class="po-milestone e177 e177" linkend="iso24610"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> was adopted by ISO TC37 SC4 and
    also implemented in the current </textual><emphasis class="po-inline e178 e178"><textual class="po-textual">P5</textual></emphasis><textual class="po-textual"> version </textual><xref class="po-milestone e179 e179" linkend="p5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that we
    use here.</textual></para><para class="po-block e180 e180"><textual class="po-textual"> The foundational XML elements that are needed in order to encode feature structures are
     </textual><code class="po-atom e181 e181"><textual class="po-textual">fs</textual></code><textual class="po-textual"> for feature structures and </textual><code class="po-atom e182 e182"><textual class="po-textual">f</textual></code><textual class="po-textual"> for features. The content of an
     </textual><code class="po-atom e183 e183"><textual class="po-textual">fs</textual></code><textual class="po-textual"> element consists of a sequence of feature-value specifications. A feature-value
    specification is encoded using an element of type </textual><code class="po-atom e184 e184"><textual class="po-textual">f</textual></code><textual class="po-textual"> for the feature and the element
    content of </textual><code class="po-atom e185 e185"><textual class="po-textual">f</textual></code><textual class="po-textual"> for the associated value. The details look as follows. Every
     </textual><code class="po-atom e186 e186"><textual class="po-textual">f</textual></code><textual class="po-textual"> element has an attribute </textual><code class="po-atom e187 e187"><textual class="po-textual">name</textual></code><textual class="po-textual"> for its feature name. The
    representation of the associated value of a feature depends on the exact type of the value
    involved. Atomic values of type </textual><code class="po-atom e188 e188"><textual class="po-textual">binary</textual></code><textual class="po-textual">, </textual><code class="po-atom e189 e189"><textual class="po-textual">symbol</textual></code><textual class="po-textual"> or </textual><code class="po-atom e190 e190"><textual class="po-textual">numeric</textual></code><textual class="po-textual">
    are realized via a </textual><code class="po-atom e191 e191"><textual class="po-textual">value</textual></code><textual class="po-textual"> attribute on a respective child element of </textual><code class="po-atom e192 e192"><textual class="po-textual">f</textual></code><textual class="po-textual">
    that corresponds to the actual value type. For example, </textual><code class="po-atom e193 e193"><textual class="po-textual">f</textual></code><textual class="po-textual"> may have a child element
     </textual><code class="po-atom e194 e194"><textual class="po-textual">binary</textual></code><textual class="po-textual"> which has a </textual><code class="po-atom e195 e195"><textual class="po-textual">value</textual></code><textual class="po-textual"> attribute that provides the desired
    parameter. If the value is of the </textual><code class="po-atom e196 e196"><textual class="po-textual">string</textual></code><textual class="po-textual"> type, however, the value is encoded in a
    slightly different form, i.e., as the literal element content of a respective
     </textual><code class="po-atom e197 e197"><textual class="po-textual">string</textual></code><textual class="po-textual"> child element of </textual><code class="po-atom e198 e198"><textual class="po-textual">f</textual></code><textual class="po-textual">.</textual></para><para class="po-block e199 e199"><textual class="po-textual"> Complex values of the feature structure kind are encoded by means of </textual><code class="po-atom e200 e200"><textual class="po-textual">fs</textual></code><textual class="po-textual">
    elements, of course. However, there is also another class of complex values: these are the
    collection values of the </textual><code class="po-atom e201 e201"><textual class="po-textual">list</textual></code><textual class="po-textual">, </textual><code class="po-atom e202 e202"><textual class="po-textual">set</textual></code><textual class="po-textual"> and </textual><code class="po-atom e203 e203"><textual class="po-textual">bag</textual></code><textual class="po-textual"> type. Such
    collections of values are indicated via </textual><code class="po-atom e204 e204"><textual class="po-textual">vColl</textual></code><textual class="po-textual"> elements that have an
     </textual><code class="po-atom e205 e205"><textual class="po-textual">org</textual></code><textual class="po-textual"> attribute whose value specifies the respective collection type, i.e., whether
    it is a </textual><code class="po-atom e206 e206"><textual class="po-textual">bag</textual></code><textual class="po-textual">, a </textual><code class="po-atom e207 e207"><textual class="po-textual">set</textual></code><textual class="po-textual"> or a </textual><code class="po-atom e208 e208"><textual class="po-textual">list</textual></code><textual class="po-textual">. The content of a
     </textual><code class="po-atom e209 e209"><textual class="po-textual">vColl</textual></code><textual class="po-textual"> element consists of a succession of values of any kind.</textual></para><figure class="po-container e210 e210" xml:id="f4" xreflabel="Figure 4"><title class="po-block e211 e211"><textual class="po-textual">TEI Feature Structure </textual><emphasis class="po-inline e212 e212"><textual class="po-textual">F</textual><subscript class="po-atom e213 e213"><textual class="po-textual">2</textual></subscript></emphasis><textual class="po-textual">: Structure Sharing
     and Collection Values</textual></title><programlisting class="po-block e214 e214" xml:space="preserve"><textual class="po-textual">
&lt;fs&gt;              
 &lt;f name="F"&gt;
  &lt;vColl org="list"&gt;
   &lt;vLabel name="a"&gt;
    &lt;fs&gt;
     &lt;f name="I"&gt;
      &lt;symbol value="a"/&gt;
     &lt;/f&gt;
     &lt;f name="J"&gt;
      &lt;symbol value="b"/&gt;
     &lt;/f&gt;
    &lt;/fs&gt;
   &lt;/vLabel&gt;
   &lt;vLabel name="b"&gt;
    &lt;fs&gt;
     &lt;f name="K"&gt;
      &lt;symbol value="c"/&gt;
     &lt;/f&gt;
     &lt;f name="L"&gt;
      &lt;symbol value="d"/&gt;
     &lt;/f&gt;
    &lt;/fs&gt;
   &lt;/vLabel&gt;
  &lt;/vColl&gt;
 &lt;/f&gt;
 &lt;f name="G"&gt;
  &lt;vLabel name="a"/&gt;
 &lt;/f&gt;
 &lt;f name="H"&gt;
  &lt;vColl org="set"&gt;
   &lt;vLabel name="b"/&gt;
   &lt;fs&gt;
    &lt;f name="M"&gt;
     &lt;symbol value="e"/&gt;
    &lt;/f&gt;
    &lt;f name="N"&gt;
     &lt;symbol value="f"/&gt;
    &lt;/f&gt;
   &lt;/fs&gt;
  &lt;/vColl&gt;
 &lt;/f&gt;
&lt;/fs&gt;                       
                </textual></programlisting></figure><para class="po-block e215 e215"><textual class="po-textual"> There is a special element in order to indicate cases of structure sharing: the
     </textual><code class="po-atom e216 e216"><textual class="po-textual">vLabel</textual></code><textual class="po-textual"> element. It either contains a value token as its element content or it
    occurs as a placeholder which indicates reference to an elsewhere specified value token. Each
     </textual><code class="po-atom e217 e217"><textual class="po-textual">vLabel</textual></code><textual class="po-textual"> element has an associated </textual><code class="po-atom e218 e218"><textual class="po-textual">name</textual></code><textual class="po-textual"> attribute. The value of the
     </textual><code class="po-atom e219 e219"><textual class="po-textual">name</textual></code><textual class="po-textual"> attribute corresponds to the index of a tagged box in attribute value matrix
    notation, see below. This mechanism allows for various structure sharing configurations within a
    single feature structure. </textual><xref class="po-milestone e220 e220" linkend="f4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> (TEI-based representation) and </textual><xref class="po-milestone e221 e221" linkend="f5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> (attribute value matrix notation) display the same abstract example feature structure
      </textual><emphasis class="po-inline e222 e222"><textual class="po-textual">F</textual><subscript class="po-atom e223 e223"><textual class="po-textual">2</textual></subscript></emphasis><textual class="po-textual"> in different notation formats and exemplify the
    themes of structure sharing and collection values. </textual></para><figure class="po-container e224 e224" xml:id="f5" xreflabel="Figure 5"><title class="po-block e225 e225"><textual class="po-textual">Attribute Value Matrix for </textual><emphasis class="po-inline e226 e226"><textual class="po-textual">F</textual><subscript class="po-atom e227 e227"><textual class="po-textual">2</textual></subscript></emphasis><textual class="po-textual">: Structure
     Sharing and Collection Values</textual></title><mediaobject class="po-container e228 e228"><imageobject class="po-container e229 e229"><imagedata class="po-meta e230 e230" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-003.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e231 e231"><textual class="po-textual"> There are three top-level features in </textual><emphasis class="po-inline e232 e232"><textual class="po-textual">F</textual><subscript class="po-atom e233 e233"><textual class="po-textual">2</textual></subscript></emphasis><textual class="po-textual">:
     </textual><code class="po-atom e234 e234"><textual class="po-textual">F</textual></code><textual class="po-textual">, </textual><code class="po-atom e235 e235"><textual class="po-textual">G</textual></code><textual class="po-textual">, and </textual><code class="po-atom e236 e236"><textual class="po-textual">H</textual></code><textual class="po-textual">. All of them are associated with complex
    values. </textual><code class="po-atom e237 e237"><textual class="po-textual">F</textual></code><textual class="po-textual"> has a list collection value, which is encoded using angle brackets at the
    attribute value matrix level, </textual><code class="po-atom e238 e238"><textual class="po-textual">G</textual></code><textual class="po-textual"> has a feature structure as its value, and
     </textual><code class="po-atom e239 e239"><textual class="po-textual">H</textual></code><textual class="po-textual"> has a set collection value that is indicated using curly brackets in Figure 4.
    The first list value of </textual><code class="po-atom e240 e240"><textual class="po-textual">F</textual></code><textual class="po-textual"> and the complex value of </textual><code class="po-atom e241 e241"><textual class="po-textual">G</textual></code><textual class="po-textual"> are co-indicated.
    The same holds for the second list value of </textual><code class="po-atom e242 e242"><textual class="po-textual">F</textual></code><textual class="po-textual"> and the firstly notated set member of
     </textual><code class="po-atom e243 e243"><textual class="po-textual">H</textual></code><textual class="po-textual">.</textual></para></section></section><section class="po-hcontainer e244 e244" xml:id="s3" xreflabel="“Representation and Transformation”"><title class="po-block e245 e245"><textual class="po-textual">Representation and Transformation</textual></title><section class="po-hcontainer e246 e246" xml:id="s3.1" xreflabel="“Representation of XML Documents via TEI Feature Structures”"><title class="po-block e247 e247"><textual class="po-textual">Representation of XML Documents via TEI Feature Structures</textual></title><para class="po-block e248 e248"><textual class="po-textual">Both feature structures and XML documents can be regarded from the perspective of graph
    theory </textual><xref class="po-milestone e249 e249" linkend="diestel2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. XML documents are specimen of ordered trees, while feature
    structures are merely unordered directed acyclic graphs. This holds because of the possibility
    of structure sharing within feature structures and because there is no order imposed among
    features of the same level within feature structures. So, the task of representing XML documents
    as feature structures seems to involve a transformation from a more rigidly structured
    representation format to a less rigidly structured one. Specifically, we have to find a way to
    represent the ordered </textual><emphasis class="po-inline e250 e250"><textual class="po-textual">sequential relations</textual></emphasis><textual class="po-textual"> that hold among parts of XML
    documents both at the text and at the markup level in terms of feature-value pairs. Furthermore,
    also the </textual><emphasis class="po-inline e251 e251"><textual class="po-textual">hierarchical relationships</textual></emphasis><textual class="po-textual"> have to be expressed in terms of
    feature-value specifications. A possible solution consists in the use of specific features for
    hierarchical aspects whose values will be structured themselves and which have to be interpreted
    as reflecting sequential relationships. </textual></para><para class="po-block e252 e252"><textual class="po-textual">In the following, we shall regard a simple annotation data example that will help to
    illustrate our points. It is shown as </textual><xref class="po-milestone e253 e253" linkend="f6"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e254 e254" linkend="f7"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> below, which
    contain morphological and phonological annotation layers of the German verb
    "geben" (engl.: to give).</textual></para><figure class="po-container e255 e255" xml:id="f6" xreflabel="Figure 6"><title class="po-block e256 e256"><textual class="po-textual">Simple Annotation Data: Example 1</textual></title><programlisting class="po-block e257 e257" xml:space="preserve"><textual class="po-textual">
&lt;w&gt;
 &lt;m type="lexical"&gt;geb&lt;/m&gt;
 &lt;m type="flexive"&gt;en&lt;/m&gt;
&lt;/w&gt;
                </textual></programlisting></figure><figure class="po-container e258 e258" xml:id="f7" xreflabel="Figure 7"><title class="po-block e259 e259"><textual class="po-textual">Simple Annotation Data: Example 2</textual></title><programlisting class="po-block e260 e260" xml:space="preserve"><textual class="po-textual">     
&lt;w&gt;
 &lt;syll n="s1"&gt;ge&lt;/syll&gt;
 &lt;syll n="s2"&gt;ben&lt;/syll&gt;
&lt;/w&gt;
                </textual></programlisting></figure><para class="po-block e261 e261"><textual class="po-textual"> In the rest of this section we will follow a historical route and discuss two
     </textual><emphasis class="po-inline e262 e262"><textual class="po-textual">representation alternatives</textual></emphasis><textual class="po-textual"> that we came up with. Both of the sketched
    solutions will be sufficiently general and can hence be applied to generic XML documents and
    sets of multiple annotation documents alike. Our discussion will be framed more towards multiple
    annotation here.</textual></para><para class="po-block e263 e263"><textual class="po-textual"> Our first and historically older </textual><emphasis class="po-inline e264 e264"><textual class="po-textual">representation alternative I</textual></emphasis><textual class="po-textual"> makes
    use of a list notation variant that is defined in a recursive way using </textual><code class="po-atom e265 e265"><textual class="po-textual">FIRST</textual></code><textual class="po-textual"> and
     </textual><code class="po-atom e266 e266"><textual class="po-textual">REST</textual></code><textual class="po-textual"> features </textual><xref class="po-milestone e267 e267" linkend="witt2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. The basic idea is to have the very first
    element of a given sequence, e.g., the first character of a text sequence, as the value of the
     </textual><code class="po-atom e268 e268"><textual class="po-textual">FIRST</textual></code><textual class="po-textual"> feature and the result for the rest of the sequence as the value of the
     </textual><code class="po-atom e269 e269"><textual class="po-textual">REST</textual></code><textual class="po-textual"> feature. So, the latter value will usually be a complex value, again, that is
    structured according to the very same scheme, i.e., with the first item of the (rest-)sequence
    detached and so on.</textual><footnote class="po-popup e270 e270"><para class="po-block e271 e271"><textual class="po-textual">Unless there is no rest sequence and we have reached the end of the sequence
      already.</textual></para></footnote><textual class="po-textual"> We go over the sequence in this way until we reach its end where the recursion
    bottoms out by </textual><code class="po-atom e272 e272"><textual class="po-textual">*null*</textual></code><textual class="po-textual"> as the value of the at most embedded </textual><code class="po-atom e273 e273"><textual class="po-textual">REST</textual></code><textual class="po-textual">
    feature within the list structure. It functions as a placeholder for the empty list.</textual></para><figure class="po-container e274 e274" xml:id="f8" xreflabel="Figure 8"><title class="po-block e275 e275"><textual class="po-textual">Representation Alternative I: TEI-based</textual></title><programlisting class="po-block e276 e276" xml:space="preserve"><textual class="po-textual">       
&lt;fs&gt;
 &lt;f name="DATA"&gt;
  &lt;fs&gt;
   &lt;f name="FIRST"&gt;
    &lt;vLabel name="1"&gt;
     &lt;symbol value="g"/&gt;
    &lt;/vLabel&gt;
   &lt;/f&gt;
   &lt;f name="REST"&gt;
    &lt;fs&gt;
     &lt;f name="FIRST"&gt;
      &lt;vLabel name="2"&gt;
       &lt;symbol value="e"/&gt;
      &lt;/vLabel&gt;
     &lt;/f&gt;
     &lt;f name="REST"&gt;
      &lt;fs&gt;
       &lt;f name="FIRST"&gt;
        &lt;vLabel name="3"&gt;
         &lt;symbol value="b"/&gt;
        &lt;/vLabel&gt;
       &lt;/f&gt;
       &lt;f name="REST"&gt;
        &lt;fs&gt;
         &lt;f name="FIRST"&gt;
          &lt;vLabel name="4"&gt;
           &lt;symbol value="e"/&gt;
          &lt;/vLabel&gt;
         &lt;/f&gt;
         &lt;f name="REST"&gt;
          &lt;fs&gt;
           &lt;f name="FIRST"&gt;
            &lt;vLabel name="5"&gt;
             &lt;symbol value="n"/&gt;
            &lt;/vLabel&gt;
           &lt;/f&gt;
           &lt;f name="REST"&gt;
            &lt;symbol value="*null*"/&gt;
           &lt;/f&gt;
          &lt;/fs&gt;
         &lt;/f&gt;
        &lt;/fs&gt;
       &lt;/f&gt;
      &lt;/fs&gt;
     &lt;/f&gt;
    &lt;/fs&gt;
   &lt;/f&gt;
  &lt;/fs&gt;
 &lt;/f&gt;
 &lt;f name="TIER1"&gt;
   ...
 &lt;/f&gt;
 &lt;f name="TIER2"&gt;
   ...
 &lt;/f&gt;
&lt;/fs&gt;
        </textual></programlisting></figure><para class="po-block e277 e277"><textual class="po-textual">This way of representation is displayed in </textual><xref class="po-milestone e278 e278" linkend="f8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> in an abridged TEI feature
    structure format that shows the top-level feature geometry of the structure :</textual><footnote class="po-popup e279 e279"><para class="po-block e280 e280"><textual class="po-textual">It would be nice to have something like a specialized document grammar regarding the
      finer details of the representations that we propose in this article. One of our anonymous
      reviewers encouraged us to give </textual><emphasis class="po-inline e281 e281"><textual class="po-textual">Feature System Declarations</textual></emphasis><textual class="po-textual">
      </textual><xref class="po-milestone e282 e282" linkend="p5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for the TEI feature structures. However, it seems that TEI FSDs are
      reserved for typed feature structures and the present state of our work here makes use of
      untyped feature structures. Since we may well choose to make the switch to typed
      representations in the future (in a way, the new representation scheme below has been designed
      to make the switch easier), it will be a good idea to take up on that proposal in a respective
      update. For the moment, we can at least validate our documents against TEI feature structure
      schemas generated via the TEI ROMA tool (http://www.tei-c.org/Roma/).</textual></para></footnote><textual class="po-textual">
    </textual><code class="po-atom e283 e283"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> contains a representation of only the textual characters of the document
    adhering to the </textual><code class="po-atom e284 e284"><textual class="po-textual">FIRST/REST</textual></code><textual class="po-textual"> scheme discussed above. Furthermore, each character is
    associated with its own index in order to allow for structure sharing references to it from
    other parts of the feature structure. We provide an index for every character in order to allow
    for arbitrarily specific levels of annotation with respect to the common textual data. The
    numbered </textual><code class="po-atom e285 e285"><textual class="po-textual">TIER</textual></code><textual class="po-textual"> features contain the specific information of the annotation levels.
    Each one represents the information of one of the multiple annotation documents involved. The
    implicit link between the different levels is made explicit by means of structure sharing.
    Therefore, there will be plenty of references to the common data characters from within the
    different </textual><code class="po-atom e286 e286"><textual class="po-textual">TIER</textual></code><textual class="po-textual"> features of the document. However, this is not an explicit part of
    the example display in </textual><xref class="po-milestone e287 e287" linkend="f8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> due to space considerations.</textual><footnote class="po-popup e288 e288"><para class="po-block e289 e289"><textual class="po-textual">Note that a complete representation of the above annotation data examples in TEI format,
      but according to the newer representation standard that will be discussed below in this
      subsection, can be found in </textual><xref class="po-milestone e290 e290" linkend="a1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">The binding of indexes to certain values is shown within the </textual><code class="po-atom e291 e291"><textual class="po-textual">DATA</textual></code><textual class="po-textual">
    feature, but the reference to such values is hidden within the abridged </textual><code class="po-atom e292 e292"><textual class="po-textual">TIER</textual></code><textual class="po-textual"> levels
    of the document. However, those parts and the connections provided by the structure sharing
    mechanism can be inspected in </textual><xref class="po-milestone e293 e293" linkend="f9"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that shows the attribute value matrix
    notation. Unlike its TEI counterpart, this display is complete and probably a bit easier to
    follow. It also displays the mechanics of the representation of the hierarchical relationships.
    They find expression via </textual><code class="po-atom e294 e294"><textual class="po-textual">CONTENT</textual></code><textual class="po-textual"> features, whose values contain the representation
    of the subordinated document parts, e.g., the content of an element. The mechanisms for the
    representation of the hierarchical and the sequential relationships have to be combined as
    appropriate. This means that </textual><code class="po-atom e295 e295"><textual class="po-textual">CONTENT</textual></code><textual class="po-textual"> will have a list value and the respective
    position within that list will reflect the sequential order among the dominated document
    parts.</textual></para><figure class="po-container e296 e296" xml:id="f9" xreflabel="Figure 9"><title class="po-block e297 e297"><textual class="po-textual">Representation Alternative I: Attribute Value Matrix</textual></title><mediaobject class="po-container e298 e298"><imageobject class="po-container e299 e299"><imagedata class="po-meta e300 e300" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-004.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e301 e301"><textual class="po-textual">We move on to the discussion of our historically newer </textual><emphasis class="po-inline e302 e302"><textual class="po-textual">representation alternative
     II</textual></emphasis><textual class="po-textual">, which forms the basis of our current work on the topic. The most important
    changes have been made regarding the representation of sequential relationships and concerning
    the general feature geometry makeup. Consider </textual><xref class="po-milestone e303 e303" linkend="f10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> which shows the changed
    top-level geometry . As its predecessor counterpart in </textual><xref class="po-milestone e304 e304" linkend="f8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, this display is
    incomplete and printed in an abridged format here. However, interested readers can find the
    complete version of this representation of the example data in </textual><xref class="po-milestone e305 e305" linkend="a1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e306 e306" xml:id="f10" xreflabel="Figure 10"><title class="po-block e307 e307"><textual class="po-textual">Representation Alternative II: TEI-based</textual></title><programlisting class="po-block e308 e308" xml:space="preserve"><textual class="po-textual">            
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;fs&gt;
 &lt;f name="DATA"&gt;
  &lt;vColl org="list"&gt;
   &lt;vLabel name="1"&gt;
    &lt;string&gt;g&lt;/string&gt;
   &lt;/vLabel&gt;
   &lt;vLabel name="2"&gt;
    &lt;string&gt;e&lt;/string&gt;
   &lt;/vLabel&gt;
   &lt;vLabel name="3"&gt;
    &lt;string&gt;b&lt;/string&gt;
   &lt;/vLabel&gt;
   &lt;vLabel name="4"&gt;
    &lt;string&gt;e&lt;/string&gt;
   &lt;/vLabel&gt;
   &lt;vLabel name="5"&gt;
    &lt;string&gt;n&lt;/string&gt;
   &lt;/vLabel&gt;
  &lt;/vColl&gt;
 &lt;/f&gt;
 &lt;f name="DOCUMENTS"&gt;
  &lt;vColl org="list"&gt;
   &lt;fs&gt;
     ...
   &lt;/fs&gt;  
   &lt;fs&gt;
     ...  
   &lt;/fs&gt;
  &lt;/vColl&gt;
 &lt;/f&gt;
&lt;/fs&gt;
        </textual></programlisting></figure><para class="po-block e309 e309"><textual class="po-textual"> On the top level, this representation consists of a </textual><code class="po-atom e310 e310"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature and a
     </textual><code class="po-atom e311 e311"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> feature. Both features take complex values of a collection type, i.e.,
    lists of values. Concerning </textual><code class="po-atom e312 e312"><textual class="po-textual">DATA</textual></code><textual class="po-textual">, we now have a flat list representation with
    little internal structure. This format can be built in an easier way as compared to the more
    structured variant. The move to this format is possible, since the TEI Guidelines provide this
    kind of notational sugar for values of the collection kind.</textual><footnote class="po-popup e313 e313"><para class="po-block e314 e314"><textual class="po-textual">In terms of features and values alone, respective structures still have to be realized by
      FIRST/REST-like structured representations as introduced above. The format provided by the TEI
      is a shorthand for that.</textual></para></footnote><textual class="po-textual"> The </textual><code class="po-atom e315 e315"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> feature also makes use of this kind of list notation and
    embeds the representation of the different annotation documents as a flat list of respective
    feature structures. Note also that there is just one such top-level feature now, compare the
    different numbered </textual><code class="po-atom e316 e316"><textual class="po-textual">TIER</textual></code><textual class="po-textual"> features in representation alternative I. If there is only
    one annotation document to process, the list will contain only one corresponding feature
    structure, of course. </textual><xref class="po-milestone e317 e317" linkend="f11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is a complete display of the attribute value matrix
    for our example data.</textual></para><figure class="po-container e318 e318" xml:id="f11" xreflabel="Figure 11"><title class="po-block e319 e319"><textual class="po-textual">Representation Alternative II: Attribute Value Matrix</textual></title><mediaobject class="po-container e320 e320"><imageobject class="po-container e321 e321"><imagedata class="po-meta e322 e322" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-005.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e323 e323"><textual class="po-textual"> This way of representation takes a stance that is based on the </textual><emphasis class="po-inline e324 e324"><textual class="po-textual">XQuery 1.0 and
     XPath 2.0 Data Model</textual></emphasis><textual class="po-textual"> (XDM) and, hence, the representations will be predestined for
    processing in an XSLT 2.0 context. We use the attributes which are provided by the XDM in order
    to represent the different node kinds within an XML document, starting from the very root. The
    node kinds that are distinguished are: document, element, attribute, namespace, commentary,
    processing instruction and text nodes. Every occurrence of a node is represented as a feature
    structure with features as appropriate for the node kind involved. The type of a node is
    indicated via the </textual><code class="po-atom e325 e325"><textual class="po-textual">TYPE</textual></code><textual class="po-textual"> feature for nodes of all kinds. Hierarchical relations are
    represented via the </textual><code class="po-atom e326 e326"><textual class="po-textual">CHILDREN</textual></code><textual class="po-textual"> feature for document- and element nodes. Order among
    the children nodes is encoded by the position within a sequence, since </textual><code class="po-atom e327 e327"><textual class="po-textual">CHILDREN</textual></code><textual class="po-textual">
    takes a collection value of the list kind. Element nodes and attribute nodes have
     </textual><code class="po-atom e328 e328"><textual class="po-textual">NAME</textual></code><textual class="po-textual"> features, attribute and text nodes have </textual><code class="po-atom e329 e329"><textual class="po-textual">VALUE</textual></code><textual class="po-textual"> features.
    Furthermore, each element node has an </textual><code class="po-atom e330 e330"><textual class="po-textual">ATTRIBUTES</textual></code><textual class="po-textual"> feature that takes a set value,
    since attributes are unordered. The semantics associated with the different feature-value pairs
    should be straightforward. All in all, this approach allows for a very systematic representation
    regime across the different parts of an arbitrary XML document instance. Unlike the older
    approach, every feature structure which is embedded below the </textual><code class="po-atom e331 e331"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> top-level
    feature now represents a certain node at the XML tree model level. However, it also has to be
    noted that our feature structure representations of XML documents tend to grow very fast with
    the size of the input document, which, however, seems to be true for all approaches based on TEI
    feature structures due to the modeling as feature structure and also the retranslation to XML involved.</textual><footnote class="po-popup e332 e332"><para class="po-block e333 e333"><textual class="po-textual">As one of our anonymous reviewers remarked, it would be interesting to investigate the
      prospects and the performance of bare feature structures for our purposes and see whether and
      how much better they can perform as compared to the TEI-serialized feature structures that are
      the focus of the present paper.</textual></para></footnote><textual class="po-textual">
   </textual></para><para class="po-block e334 e334"><textual class="po-textual">If the input to the transformation program does not consist of multiple annotation
    documents, but rather of one or several arbitrary XML documents, which do not share identical
    primary data, an integrative representation of such documents will still be build in a similar
    way. However, there will be no indexing mechanism incorporated and so no implicit links will be
    made explicit.</textual></para></section><section class="po-hcontainer e335 e335" xml:id="s3.2" xreflabel="“Aspects of the XSLT Implementation of the Transformation”"><title class="po-block e336 e336"><textual class="po-textual">Aspects of the XSLT Implementation of the Transformation</textual></title><para class="po-block e337 e337"><textual class="po-textual"> The program </textual><code class="po-atom e338 e338"><textual class="po-textual">xmls2avm.xsl</textual></code><textual class="po-textual"> that implements the transformation to the TEI
    feature structure format was written with multiple annotation documents in mind. Nevertheless,
    it is robust enough to provide a result document if the input documents to the transformation
    fail the test of primary data identity or if there is only one document to be transformed. Such
    kind of robustness marks a necessary condition for the program to be useful within the generic
    XML realm. </textual></para><para class="po-block e339 e339"><textual class="po-textual"> The program was written in </textual><emphasis class="po-inline e340 e340"><textual class="po-textual">XSLT 2.0</textual></emphasis><textual class="po-textual"> and uses certain features of the
    new XSLT version. For example, data typing is used for at least some of the parameters and
    variables involved and, most importantly, we exploit the extended functionalities and constructs
    that are grounded on the XDM tree model. XSLT 2.0 comes with support for multiple output
    documents, but the multiple input documents that are needed here still have to be provided via a
    sort of workaround: a call of the </textual><code class="po-atom e341 e341"><textual class="po-textual">document()</textual></code><textual class="po-textual">-function to a post-processed
    representation of a stylesheet parameter. The latter contains a list of secondary input
    documents that has to be assigned by the user when invoking the transformation program from the
    command line. Several further stylesheet parameters are provided in order to parameterize
    certain aspects of the transformation process and to determine peculiarities of the desired
    representation format. Most of this is optional, however, since there are defaults for the
    relevant parameters. An example stylesheet parameter is </textual><code class="po-atom e342 e342"><textual class="po-textual">$firstrestRepr</textual></code><textual class="po-textual">: it
    influences the way how lists are represented. If it is set to </textual><code class="po-atom e343 e343"><textual class="po-textual">true</textual></code><textual class="po-textual">, then lists will
    be represented in the recursively structured way that has been introduced as our historically
    older representation alternative I in the previous section. If it is set to </textual><code class="po-atom e344 e344"><textual class="po-textual">false</textual></code><textual class="po-textual">,
    however, then lists will be represented according to the newer flat representation alternative
    II that exploits the notational sugar provided by the TEI guidelines. The parameter is set to
     </textual><code class="po-atom e345 e345"><textual class="po-textual">false</textual></code><textual class="po-textual"> as a default.</textual></para><para class="po-block e346 e346"><textual class="po-textual">Although we decided that we would not include detailed comments on the whole stylesheet</textual><footnote class="po-popup e347 e347"><para class="po-block e348 e348"><textual class="po-textual">This decision was made on grounds of space considerations, since this is a rather long
      paper already. Some anonymous reviewers would have liked to see the whole stylesheet included.
      Others shared our perspective that examples suffice here.</textual></para></footnote><textual class="po-textual">, we do provide three illustrative template examples below. These will be the
    templates for document nodes (in default mode), attributes and text. Besides these, the full
    stylesheet also contains templates for document nodes (in secondary mode), elements, processing
    instructions, comments. Furthermore, there are named templates for the processing of nested
    sequences and for the processing of nested sequences with regard to namespaces, as well as many
    additional parameters and variables defined.</textual></para><para class="po-block e349 e349"><textual class="po-textual">We begin our discussion with the template for </textual><emphasis class="po-inline e350 e350"><textual class="po-textual">document nodes in default
     mode</textual></emphasis><textual class="po-textual">, i.e., the mode that is used at the start of the transformation without further
    ado. The template shown in </textual><xref class="po-milestone e351 e351" linkend="f12"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> will be applied to the document node of the
    primary input document at the start of the transformation. </textual></para><figure class="po-container e352 e352" xml:id="f12" xreflabel="Figure 12"><title class="po-block e353 e353"><textual class="po-textual">Template for Document Nodes in Default Mode</textual></title><programlisting class="po-block e354 e354" xml:space="preserve"><textual class="po-textual">
&lt;xsl:template match="document-node()" mode="#default"&gt;
 &lt;xsl:variable name="children" select="node()"/&gt;
 &lt;xsl:variable name="textnodes" select="//text()"/&gt;
 &lt;fs&gt;
  &lt;xsl:if test="$dataIdentity and $dataRepr"&gt;
   &lt;f name="DATA"&gt;
    &lt;vColl org="list"&gt;
     &lt;xsl:for-each select="str:characters($primaryString)"&gt;
      &lt;vLabel name="{position()}"&gt;
       &lt;string&gt;
        &lt;xsl:value-of select="."/&gt;
       &lt;/string&gt;
      &lt;/vLabel&gt;
     &lt;/xsl:for-each&gt;
    &lt;/vColl&gt;
   &lt;/f&gt;
  &lt;/xsl:if&gt;
  &lt;f name="DOCUMENTS"&gt;
   &lt;vColl org="list"&gt;
    &lt;fs&gt;
     &lt;f name="TYPE"&gt;
      &lt;symbol value="document"/&gt;
     &lt;/f&gt;
     &lt;f name="CHILDREN"&gt;
      &lt;xsl:choose&gt;
       &lt;xsl:when test="$firstrestRepr"&gt;
        &lt;xsl:choose&gt;
         &lt;xsl:when test="$children"&gt;
          &lt;xsl:call-template name="SequenceProcessing"&gt;
           &lt;xsl:with-param name="seq" select="$children"/&gt;
          &lt;/xsl:call-template&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:otherwise&gt;
          &lt;symbol value="*null*"/&gt;
         &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
        &lt;vColl org="list"&gt;
         &lt;xsl:apply-templates select="$children"/&gt;
        &lt;/vColl&gt;
       &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
     &lt;/f&gt;
    &lt;/fs&gt;
    &lt;xsl:apply-templates select="$docRoots" mode="secondary"/&gt;
   &lt;/vColl&gt;
  &lt;/f&gt;
 &lt;/fs&gt;
&lt;/xsl:template&gt;   
            </textual></programlisting></figure><para class="po-block e355 e355"><textual class="po-textual">The template starts with the definition of variables that can be referenced within the
    scope of the template. Most of the other templates in the stylesheet use such template
    variables, too. Then the first </textual><code class="po-atom e356 e356"><textual class="po-textual">fs</textual></code><textual class="po-textual"> element of the target representation is inserted.
    This will be the outer frame for all the result markup that is created during the
    transformation. The two usual top-level features for a feature structure representation of XML
    documents are </textual><code class="po-atom e357 e357"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> and </textual><code class="po-atom e358 e358"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual">, compare our discussion of
    representation alternative II in the previous section. It is possible to drop even the
     </textual><code class="po-atom e359 e359"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature and go with the </textual><code class="po-atom e360 e360"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> feature on the top-level of
    the feature structure alone. This possibility has been parameterized using
     </textual><code class="po-atom e361 e361"><textual class="po-textual">$dataRepr</textual></code><textual class="po-textual">, i.e., the user may decide whether he wants a </textual><code class="po-atom e362 e362"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature
    at the top-level or not. Furthermore, a variable named </textual><code class="po-atom e363 e363"><textual class="po-textual">$dataidentity</textual></code><textual class="po-textual"> has been
    defined on the global stylesheet level. This variable implements a test for the identity of the
    primary textual data of all the input documents involved. Now, if </textual><code class="po-atom e364 e364"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> shall be
    present and the test result concerning textual data identity is positive, then the feature will
    be inserted into the result and be given a list value. The content of that list will be
    construed as follows: we iterate over all textual characters of our primary input document. For
    each character, we insert index markup (</textual><code class="po-atom e365 e365"><textual class="po-textual">vLabel</textual></code><textual class="po-textual">) with a numerical index attribute
    according to the position value of the respective character. Furthermore, the index will be
    bound to the character value whereas the latter is framed by a </textual><code class="po-atom e366 e366"><textual class="po-textual">string</textual></code><textual class="po-textual"> element to
    indicate its value type. Next is the obligatory </textual><code class="po-atom e367 e367"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> feature. It will take a
    list of feature structures, i.e., a list of </textual><code class="po-atom e368 e368"><textual class="po-textual">fs</textual></code><textual class="po-textual"> elements. Those will represent the
    input documents, respectively. </textual></para><para class="po-block e369 e369"><textual class="po-textual">In what follows in this template, we build the representation for the primary input
    document. The corresponding job for the other input documents, if any, will have to be done by
    the template for document node kinds in secondary mode. The two features appropriate for
    document nodes are </textual><code class="po-atom e370 e370"><textual class="po-textual">TYPE</textual></code><textual class="po-textual"> and </textual><code class="po-atom e371 e371"><textual class="po-textual">CHILDREN</textual></code><textual class="po-textual">. Concerning </textual><code class="po-atom e372 e372"><textual class="po-textual">TYPE</textual></code><textual class="po-textual">,
    its value will be </textual><code class="po-atom e373 e373"><textual class="po-textual">&lt;symbol value="document"/&gt;</textual></code><textual class="po-textual"> obviously. The value of
     </textual><code class="po-atom e374 e374"><textual class="po-textual">CHILDREN</textual></code><textual class="po-textual">, however, is more complicated and has to be determined via a series of
    conditional constructs. Firstly, it depends on whether the list representation has been set to
    the older recursively structured kind (</textual><code class="po-atom e375 e375"><textual class="po-textual">$firstrestRepr</textual></code><textual class="po-textual">) or not. If list
    representations follow that approach, then it depends again on whether the document node has
    descendants or not. If he has none, we insert a value for the empty list (</textual><code class="po-atom e376 e376"><textual class="po-textual">*null*</textual></code><textual class="po-textual">).
    However, if there are descendant nodes to the document node, the further calculation of the list
    representation is taken over by a called template of the recursive kind named
     </textual><code class="po-atom e377 e377"><textual class="po-textual">SequenceProcessing</textual></code><textual class="po-textual">. This template is called with the sequence of the current
    document node's descendant nodes as a parameter. That template will build a recursively
    structured kind of list representation as appropriate. However, if the value of the parameter
     </textual><code class="po-atom e378 e378"><textual class="po-textual">$firstrestRepr</textual></code><textual class="po-textual"> is set such that we will have the flat kind of list representation,
    which is the default, then markup for a collection of the list kind will be inserted. However,
    the content of that list will be determined by the result of applying templates to all the
    descendant nodes of the current document node. Thus, the content of the </textual><code class="po-atom e379 e379"><textual class="po-textual">fs</textual></code><textual class="po-textual"> element
    for the current primary input document is complete and can be closed with the respective end
    tags. What remains to be computed is the markup for the other secondary input documents.
    Therefore, templates are applied to the members of </textual><code class="po-atom e380 e380"><textual class="po-textual">$docRoots</textual></code><textual class="po-textual">, which holds the
    document nodes of the secondary input documents in a sequence format. Note, that a mode
     (</textual><code class="po-atom e381 e381"><textual class="po-textual">secondary</textual></code><textual class="po-textual">) is used in the respective </textual><code class="po-atom e382 e382"><textual class="po-textual">apply-templates</textual></code><textual class="po-textual"> instruction, so
    the present template will not fit and we avoid a repeated insertion of the initial framing
    markup for the outermost level of the feature structure representation, which is only included
    in the processing of the primary input document here. </textual></para><para class="po-block e383 e383"><textual class="po-textual"> The complete stylesheet can be characterized as exploiting aspects of both </textual><emphasis class="po-inline e384 e384"><textual class="po-textual">the
     push and the pull processing paradigm</textual></emphasis><textual class="po-textual">
    </textual><xref class="po-milestone e385 e385" linkend="tennison2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, like most stylesheets of a considerable size and complexity do,
    whereas the focus is shifting in different parts of the stylesheet. In a similar vein, it can be
    classified as implementing different </textual><emphasis class="po-inline e386 e386"><textual class="po-textual">stylesheet design patterns</textual></emphasis><textual class="po-textual">
    </textual><xref class="po-milestone e387 e387" linkend="kay2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. For example, the buildup of the initial target feature structure
    tends to be of the pull type or rather navigational, to use Kay's concept. This, however, shifts
    towards a more push- or rule-oriented approach, which helps to fill up the missing parts of the
    initial structure by applying templates to the descendants of the current node. Appropriate
    templates are provided for each specific node kind against the background of the XDM. Certain
    aspects, e.g., the buildup of the older </textual><code class="po-atom e388 e388"><textual class="po-textual">FIRST</textual></code><textual class="po-textual">/</textual><code class="po-atom e389 e389"><textual class="po-textual">REST</textual></code><textual class="po-textual"> list structures
    have been realized in a computational way recursively via calls to named templates with
    parameters as their arguments. We shall look at a recipient template of the push- or
    rule-oriented style of processing next in </textual><xref class="po-milestone e390 e390" linkend="f13"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. It is the template for the
    processing of </textual><emphasis class="po-inline e391 e391"><textual class="po-textual">attribute nodes</textual></emphasis><textual class="po-textual">, whose application will be initiated from
    within the template for the processing of element nodes.</textual></para><figure class="po-container e392 e392" xml:id="f13" xreflabel="Figure 13"><title class="po-block e393 e393"><textual class="po-textual">Template for Attribute Nodes</textual></title><programlisting class="po-block e394 e394" xml:space="preserve"><textual class="po-textual">
&lt;xsl:template match="attribute()" mode="#all"&gt;
 &lt;fs&gt;
  &lt;f name="TYPE"&gt;
   &lt;symbol value="attribute"/&gt;
  &lt;/f&gt;
  &lt;f name="NAME"&gt;
   &lt;string&gt;
    &lt;xsl:value-of select="node-name(.)"/&gt;
   &lt;/string&gt;
  &lt;/f&gt;
  &lt;f name="VALUE"&gt;
   &lt;string&gt;
    &lt;xsl:value-of select="."/&gt;
   &lt;/string&gt;
  &lt;/f&gt;
 &lt;/fs&gt;
&lt;/xsl:template&gt;
            </textual></programlisting></figure><para class="po-block e395 e395"><textual class="po-textual"> In comparison to the previous template for document nodes, this one is very
    straightforward. There are three features appropriate for feature structures that represent
    attribute nodes: these are </textual><code class="po-atom e396 e396"><textual class="po-textual">TYPE</textual></code><textual class="po-textual">, </textual><code class="po-atom e397 e397"><textual class="po-textual">NAME</textual></code><textual class="po-textual"> and </textual><code class="po-atom e398 e398"><textual class="po-textual">VALUE</textual></code><textual class="po-textual">. The
    respective values are very easily determined. Readers who managed to follow through on our
    description of the previous template should have no problems with this one.</textual></para><para class="po-block e399 e399"><textual class="po-textual"> At the heart of the transformation of multiply annotated documents is the indexing of the
    single characters and the reference mechanism that exploits these indexes. It is dependent on
    the relative position of characters with respect to the other characters of the document. Those
    values can be used as numerical indexes since they are bound to be constant across all the
    documents that pass a test of primary data identity. However, it has to be stressed that the
    computational cost of implementing this functionality can be considerable for large input
    documents. </textual><xref class="po-milestone e400 e400" linkend="f14"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows the code which does the job: it is the template for
     </textual><emphasis class="po-inline e401 e401"><textual class="po-textual">text nodes</textual></emphasis><textual class="po-textual">.</textual></para><figure class="po-container e402 e402" xml:id="f14" xreflabel="Figure 14"><title class="po-block e403 e403"><textual class="po-textual">Template for Text Nodes</textual></title><programlisting class="po-block e404 e404" xml:space="preserve"><textual class="po-textual">
&lt;xsl:template match="text()" mode="#all"&gt;
 &lt;xsl:variable name="currentRoot" select="/"/&gt;
 &lt;fs&gt;
  &lt;f name="TYPE"&gt;
   &lt;symbol value="text"/&gt;
  &lt;/f&gt;
  &lt;f name="VALUE"&gt;
   &lt;xsl:choose&gt;
    &lt;xsl:when test="$dataIdentity"&gt;
     &lt;xsl:variable name="numberOfCharactersSoFar" as="xs:integer"
                   select="sum(for $textnode in preceding::text() return string-length($textnode))"/&gt;
     &lt;vColl org="list"&gt;
      &lt;xsl:for-each select="str:characters(string(.))"&gt;
       &lt;vLabel name="{position() + $numberOfCharactersSoFar}"&gt;
        &lt;xsl:if test="not($dataRepr) and $primary is $currentRoot"&gt;
         &lt;string&gt;
          &lt;xsl:value-of select="."/&gt;
         &lt;/string&gt;
        &lt;/xsl:if&gt;
       &lt;/vLabel&gt;
      &lt;/xsl:for-each&gt;
     &lt;/vColl&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
     &lt;string&gt;
      &lt;xsl:value-of select="."/&gt;
     &lt;/string&gt;
    &lt;/xsl:otherwise&gt;
   &lt;/xsl:choose&gt;
  &lt;/f&gt;
 &lt;/fs&gt;
&lt;/xsl:template&gt;
            </textual></programlisting></figure><para class="po-block e405 e405"><textual class="po-textual"> There are two appropriate features for text nodes: </textual><code class="po-atom e406 e406"><textual class="po-textual">TYPE</textual></code><textual class="po-textual"> and
     </textual><code class="po-atom e407 e407"><textual class="po-textual">VALUE</textual></code><textual class="po-textual">. The </textual><code class="po-atom e408 e408"><textual class="po-textual">TYPE</textual></code><textual class="po-textual"> feature is set to the symbolic value
     </textual><code class="po-atom e409 e409"><textual class="po-textual">text</textual></code><textual class="po-textual">, of course. The procedure for determining the value of the feature
     </textual><code class="po-atom e410 e410"><textual class="po-textual">VALUE</textual></code><textual class="po-textual">, however, is much more complicated. This holds at least for multiple
    annotation documents, where the identity of the primary data is given
     (</textual><code class="po-atom e411 e411"><textual class="po-textual">$dataIdentity</textual></code><textual class="po-textual">). If this is not the case, we can just insert the value of the
    textual node as a whole. With regard to the data-identity scenario, however, we will proceed on
    a character by character basis with the help of an appropriately defined external function
     (</textual><code class="po-atom e412 e412"><textual class="po-textual">str:characters</textual></code><textual class="po-textual">) and calculate the appropriate index for each character. The
    interesting part of the calculation is done in the binding of the variable
     </textual><code class="po-atom e413 e413"><textual class="po-textual">$numberOfCharactersSoFar</textual></code><textual class="po-textual">. That result will be modulated by the relative position
    of each character with respect to the string value of the text node processed. If the user chose
    to go without the </textual><code class="po-atom e414 e414"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature on the top feature geometry level
     (</textual><code class="po-atom e415 e415"><textual class="po-textual">not($dataRepr)</textual></code><textual class="po-textual">) and if we are processing the primary input document
     (</textual><code class="po-atom e416 e416"><textual class="po-textual">$primary is $currentRoot</textual></code><textual class="po-textual">), not only the calculated indexes will be included in
    the list-valued result, but also the character values. Now that there is no specialized
     </textual><code class="po-atom e417 e417"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature, the indexes will be bound to their respective value tokens
    here.</textual></para></section></section><section class="po-hcontainer e418 e418" xml:id="s4" xreflabel="“Summary and Outlook”"><title class="po-block e419 e419"><textual class="po-textual">Summary and Outlook</textual></title><para class="po-block e420 e420"><textual class="po-textual">In the context of this article, we started by providing an informal introduction to feature
   structures and their encoding as proposed in the TEI P5 Guidelines. We continued to discuss
   aspects of the representation of multiple annotation documents as XML-encoded feature structures.
   Most of our pertinent remarks are also correct concerning the representation of generic XML
   documents. It is rather just the indexing mechanism that is lost for that more general domain.
   Furthermore, we characterized the implemented XSLT stylesheet that was written in order to bring
   about the transformation from multiply annotated or generic XML documents to TEI-based feature
   structure representations. In the remainder of this article, we will take up some loose ends and
   speculate about possible advantages and disadvantages that may be connected with the format. </textual></para><para class="po-block e421 e421"><textual class="po-textual">In comparison to alternative proposals like </textual><emphasis class="po-inline e422 e422"><textual class="po-textual">XCONCUR</textual></emphasis><textual class="po-textual"> (</textual><xref class="po-milestone e423 e423" linkend="hilbert2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,</textual><xref class="po-milestone e424 e424" linkend="schonefeld2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and the </textual><emphasis class="po-inline e425 e425"><textual class="po-textual">NITE XML</textual></emphasis><textual class="po-textual">
   format </textual><xref class="po-milestone e426 e426" linkend="carletta2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the following advantages and disadvantages can be stated.
   Like NITE XML, but unlike XCONCUR documents, the TEI-based feature structure format is an XML
   format, which should count as a definitive plus in most contexts. Furthermore, like XCONCUR, but
   unlike the NITE XML representations, the proposed TEI feature structures are integrative in a
   strict sense of the word. What we mean is that all the distributed annotation information is made
   available within the context of a single document instance in which the implicit links have been
   made explicit. So, with regard to these two aspects, TEI feature structures seem to do quite well
   in comparison with the mentioned alternative formats, which lack in the one or the other way.
   However, there is also a big downside connected to them. The TEI feature structure
   representations grow very fast with the size of the input documents and their relative markup
   complexity, much faster than both rival formats.</textual><footnote class="po-popup e427 e427"><para class="po-block e428 e428"><textual class="po-textual">XCONCUR seems to be leanest in this respect.</textual></para></footnote><textual class="po-textual"> So serious doubts remain, whether this format can prevail in practical
   day-to-day-work if it is used for collections of large resource documents.</textual></para><para class="po-block e429 e429"><textual class="po-textual">But are there any striking advantages that may be connected with the representation of XML
   documents in a feature structure format? Feature structures are a common data structure in
   linguistic theory and they play an important role in many implementations in computational
   linguistics. If the preferred representation format of computational linguists can be used, it
   may be possible to find a way to apply the processing tools that have been developed in that
   field and bridge the gap between the information given by annotations and the information
   contained in textual content. One may also speculate whether general operations on feature
   structures like </textual><emphasis class="po-inline e430 e430"><textual class="po-textual">unification</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e431 e431"><textual class="po-textual">generalization</textual></emphasis><textual class="po-textual">, compare
   the section </textual><xref class="po-milestone e432 e432" linkend="s2.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> above, may be applicable to appropriately represented XML
   documents or linguistic corpora.</textual></para><figure class="po-container e433 e433" xml:id="f15" xreflabel="Figure 15"><title class="po-block e434 e434"><textual class="po-textual">Attribute Value Matrix Notation of the Annotation Example 1</textual></title><mediaobject class="po-container e435 e435"><imageobject class="po-container e436 e436"><imagedata class="po-meta e437 e437" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-006.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e438 e438"><textual class="po-textual">Compare </textual><xref class="po-milestone e439 e439" linkend="f15"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e440 e440" linkend="f16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. These are possible TEI feature
   structures for the simple linguistic annotation examples that we have used before. Unlike </textual><xref class="po-milestone e441 e441" linkend="f11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, which is an integrative representation of both example documents, each figure
   here displays the representation of just one annotation document. These examples will help us to
   explore some of the issues involved.</textual></para><figure class="po-container e442 e442" xml:id="f16" xreflabel="Figure 16"><title class="po-block e443 e443"><textual class="po-textual">Attribute Value Matrix Notation of the Annotation Example 2</textual></title><mediaobject class="po-container e444 e444"><imageobject class="po-container e445 e445"><imagedata class="po-meta e446 e446" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-007.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e447 e447"><textual class="po-textual"> As before, we have to consider two broad scenarios: operations among multiply annotated
   documents and operations among generic XML documents. The main difference between both has to do
   with the values of the </textual><code class="po-atom e448 e448"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> feature.</textual><footnote class="po-popup e449 e449"><para class="po-block e450 e450"><textual class="po-textual">For the sake of the argument, we will presume that there will be a </textual><code class="po-atom e451 e451"><textual class="po-textual">DATA</textual></code><textual class="po-textual">
     feature on the top-level of all TEI feature structures. The stylesheet does not force this,
     though.</textual></para></footnote><textual class="po-textual"> For multiple annotation, the values of </textual><code class="po-atom e452 e452"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> will be identical and the
   respective features can, hence, be unified. However, for generic XML documents the
    </textual><code class="po-atom e453 e453"><textual class="po-textual">DATA</textual></code><textual class="po-textual"> values will almost always be different. Hence, they usually won't unify . And
   even multiply annotated documents will run into problems when it comes to the value of the
    </textual><code class="po-atom e454 e454"><textual class="po-textual">DOCUMENTS</textual></code><textual class="po-textual"> feature slot, compare </textual><xref class="po-milestone e455 e455" linkend="f15"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e456 e456" linkend="f16"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. So
   the bare unification of complete representations does not seem to work out for either class of
   documents.</textual></para><figure class="po-container e457 e457" xml:id="f17" xreflabel="Figure 17"><title class="po-block e458 e458"><textual class="po-textual">Rule that uses Unification for Multiple Annotation Data</textual></title><mediaobject class="po-container e459 e459"><imageobject class="po-container e460 e460"><imagedata class="po-meta e461 e461" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-008.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e462 e462"><textual class="po-textual">However, there is a way how unification may be put to use with regard to respective
   representations, but in a somewhat different way. It works analogously to the way in which
   unification is put to use in </textual><emphasis class="po-inline e463 e463"><textual class="po-textual">linguistic rules</textual></emphasis><textual class="po-textual"> in unification-based grammars.
   We do not unify the whole representations, but only parts of it in accordance to a rule, which
   directs how to build a bigger structure from smaller structures (or vice versa, this is a
   question of procedural interpretation). Structures that are coindexed within a rule have to be
   unified when the rule is applied. In line with this, e.g., our annotation examples (on the right
   hand side of the rule) can be projected to a bigger structure (on the left hand side of the
   rule) as displayed in </textual><xref class="po-milestone e464 e464" linkend="f17"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. For generic XML documents, a rule like </textual><xref class="po-milestone e465 e465" linkend="f18"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> might work.</textual></para><figure class="po-container e466 e466" xml:id="f18" xreflabel="Figure 18"><title class="po-block e467 e467"><textual class="po-textual">Rule that uses Unification for Generic XML Documents</textual></title><mediaobject class="po-container e468 e468"><imageobject class="po-container e469 e469"><imagedata class="po-meta e470 e470" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-009.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e471 e471"><textual class="po-textual">For another perspective on the unification of XML documents compare </textual><xref class="po-milestone e472 e472" linkend="witt2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e473 e473"><textual class="po-textual">There is also a second general operation on feature structures: generalization. Unlike
   unification, generalization cannot fail. And indeed, generalization can be put to use concerning
   our examples here. The result indicates what is common to both representations and is shown in
    </textual><xref class="po-milestone e474 e474" linkend="f19"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e475 e475" xml:id="f19" xreflabel="Figure 19"><title class="po-block e476 e476"><textual class="po-textual">Generalization of the Annotation Data Examples 1 and 2</textual></title><mediaobject class="po-container e477 e477"><imageobject class="po-container e478 e478"><imagedata class="po-meta e479 e479" fileref="../../../vol3/graphics/Stegmann01/Stegmann01-010.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e480 e480"><textual class="po-textual"> One of the anonymous reviewers of this paper stated that (s)he thinks that its strength is
   "as a sort of thought experiment that has not provided quite the breakthrough that was hoped for
   it; yet interesting things have been learned and observed." This is not too far off from our own
   perspective. Although we were able to show that this and that can be done, at least in
   principle---as things stand, we do not think that it is likely that TEI feature structures will
   turn out to be the silver bullet for the representation of linguistic annotations or generic XML
   documents. Our respective representations grow too fast and isn't yet clear, whether good and
   sensible use can be made of the general operations on feature structures open to us now, i.e.,
   whether the potential advantages can override the disadvantages connected to it. But it seems
   that there are at least some open questions that remain to be investigated. For example, perhaps
   we could come up with a different way of representing XML documents in terms of TEI feature
   structures as compared to our current representation practice and see if that helps in any way.
   Going with typed feature structures might be a worthwhile thing to try. However, we think that
   the prospects are not too good, since the foundational issue of complex modeling and
   retranslating to XML would basically stay the same and it seems that this is quite an overhead to
   cope with. Therefore, finally, we will at least mention a different direction that has been
   encouraged by the very same reviewer mentioned above. (S)he advised to step away from the
   TEI-ness of the present approach in order to investigate the prospects of bare feature
   structures, e.g., in the sense of an implemented library, with respect to the issues at
   hand.</textual></para></section><appendix class="po-hcontainer e481 e481" xml:id="a1" xreflabel="Appendix A"><title class="po-block e482 e482"><textual class="po-textual">Appendix: Result Document for the Annotation Data Examples</textual></title><programlisting class="po-block e483 e483" xml:space="preserve"><textual class="po-textual">
            &lt;?xml version="1.0" encoding="UTF-8"?&gt;
            &lt;fs&gt;
             &lt;f name="DATA"&gt;
              &lt;vColl org="list"&gt;
               &lt;vLabel name="1"&gt;
                &lt;string&gt;g&lt;/string&gt;
               &lt;/vLabel&gt;
               &lt;vLabel name="2"&gt;
                &lt;string&gt;e&lt;/string&gt;
               &lt;/vLabel&gt;
               &lt;vLabel name="3"&gt;
                &lt;string&gt;b&lt;/string&gt;
               &lt;/vLabel&gt;
               &lt;vLabel name="4"&gt;
                &lt;string&gt;e&lt;/string&gt;
               &lt;/vLabel&gt;
               &lt;vLabel name="5"&gt;
                &lt;string&gt;n&lt;/string&gt;
               &lt;/vLabel&gt;
              &lt;/vColl&gt;
             &lt;/f&gt;
             &lt;f name="DOCUMENTS"&gt;
              &lt;vColl org="list"&gt;
               &lt;fs&gt;
                &lt;f name="TYPE"&gt;
                 &lt;symbol value="document"/&gt;
                &lt;/f&gt;
                &lt;f name="CHILDREN"&gt;
                 &lt;vColl org="list"&gt;
                  &lt;fs&gt;
                   &lt;f name="TYPE"&gt;
                    &lt;symbol value="element"/&gt;
                   &lt;/f&gt;
                   &lt;f name="NAME"&gt;
                    &lt;string&gt;w&lt;/string&gt;
                   &lt;/f&gt;
                   &lt;f name="ATTRIBUTES"&gt;
                    &lt;vColl org="set"/&gt;
                   &lt;/f&gt;
                   &lt;f name="CHILDREN"&gt;
                    &lt;vColl org="list"&gt;
                     &lt;fs&gt;
                      &lt;f name="TYPE"&gt;
                       &lt;symbol value="element"/&gt;
                      &lt;/f&gt;
                      &lt;f name="NAME"&gt;
                       &lt;string&gt;m&lt;/string&gt;
                      &lt;/f&gt;
                      &lt;f name="ATTRIBUTES"&gt;
                       &lt;vColl org="set"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="attribute"/&gt;
                         &lt;/f&gt;
                         &lt;f name="NAME"&gt;
                          &lt;string&gt;type&lt;/string&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;string&gt;lexical&lt;/string&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                      &lt;f name="CHILDREN"&gt;
                       &lt;vColl org="list"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="text"/&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;vColl org="list"&gt;
                           &lt;vLabel name="1"/&gt;
                           &lt;vLabel name="2"/&gt;
                           &lt;vLabel name="3"/&gt;
                          &lt;/vColl&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                     &lt;/fs&gt;
                     &lt;fs&gt;
                      &lt;f name="TYPE"&gt;
                       &lt;symbol value="element"/&gt;
                      &lt;/f&gt;
                      &lt;f name="NAME"&gt;
                       &lt;string&gt;m&lt;/string&gt;
                      &lt;/f&gt;
                      &lt;f name="ATTRIBUTES"&gt;
                       &lt;vColl org="set"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="attribute"/&gt;
                         &lt;/f&gt;
                         &lt;f name="NAME"&gt;
                          &lt;string&gt;type&lt;/string&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;string&gt;flexive&lt;/string&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                      &lt;f name="CHILDREN"&gt;
                       &lt;vColl org="list"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="text"/&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;vColl org="list"&gt;
                           &lt;vLabel name="4"/&gt;
                           &lt;vLabel name="5"/&gt;
                          &lt;/vColl&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                     &lt;/fs&gt;
                    &lt;/vColl&gt;
                   &lt;/f&gt;
                  &lt;/fs&gt;
                 &lt;/vColl&gt;
                &lt;/f&gt;
               &lt;/fs&gt;
               &lt;fs&gt;
                &lt;f name="TYPE"&gt;
                 &lt;symbol value="document"/&gt;
                &lt;/f&gt;
                &lt;f name="CHILDREN"&gt;
                 &lt;vColl org="list"&gt;
                  &lt;fs&gt;
                   &lt;f name="TYPE"&gt;
                    &lt;symbol value="element"/&gt;
                   &lt;/f&gt;
                   &lt;f name="NAME"&gt;
                    &lt;string&gt;w&lt;/string&gt;
                   &lt;/f&gt;
                   &lt;f name="ATTRIBUTES"&gt;
                    &lt;vColl org="set"/&gt;
                   &lt;/f&gt;
                   &lt;f name="CHILDREN"&gt;
                    &lt;vColl org="list"&gt;
                     &lt;fs&gt;
                      &lt;f name="TYPE"&gt;
                       &lt;symbol value="element"/&gt;
                      &lt;/f&gt;
                      &lt;f name="NAME"&gt;
                       &lt;string&gt;syll&lt;/string&gt;
                      &lt;/f&gt;
                      &lt;f name="ATTRIBUTES"&gt;
                       &lt;vColl org="set"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="attribute"/&gt;
                         &lt;/f&gt;
                         &lt;f name="NAME"&gt;
                          &lt;string&gt;n&lt;/string&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;string&gt;s1&lt;/string&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                      &lt;f name="CHILDREN"&gt;
                       &lt;vColl org="list"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="text"/&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;vColl org="list"&gt;
                           &lt;vLabel name="1"/&gt;
                           &lt;vLabel name="2"/&gt;
                          &lt;/vColl&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                     &lt;/fs&gt;
                     &lt;fs&gt;
                      &lt;f name="TYPE"&gt;
                       &lt;symbol value="element"/&gt;
                      &lt;/f&gt;
                      &lt;f name="NAME"&gt;
                       &lt;string&gt;syll&lt;/string&gt;
                      &lt;/f&gt;
                      &lt;f name="ATTRIBUTES"&gt;
                       &lt;vColl org="set"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="attribute"/&gt;
                         &lt;/f&gt;
                         &lt;f name="NAME"&gt;
                          &lt;string&gt;n&lt;/string&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;string&gt;s2&lt;/string&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                      &lt;f name="CHILDREN"&gt;
                       &lt;vColl org="list"&gt;
                        &lt;fs&gt;
                         &lt;f name="TYPE"&gt;
                          &lt;symbol value="text"/&gt;
                         &lt;/f&gt;
                         &lt;f name="VALUE"&gt;
                          &lt;vColl org="list"&gt;
                           &lt;vLabel name="3"/&gt;
                           &lt;vLabel name="4"/&gt;
                           &lt;vLabel name="5"/&gt;
                          &lt;/vColl&gt;
                         &lt;/f&gt;
                        &lt;/fs&gt;
                       &lt;/vColl&gt;
                      &lt;/f&gt;
                     &lt;/fs&gt;
                    &lt;/vColl&gt;
                   &lt;/f&gt;
                  &lt;/fs&gt;
                 &lt;/vColl&gt;
                &lt;/f&gt;
               &lt;/fs&gt;
              &lt;/vColl&gt;
             &lt;/f&gt;
            &lt;/fs&gt;
        </textual></programlisting></appendix><bibliography class="po-hcontainer e484 e484"><title class="po-block e485 e485"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e486 e486" xml:id="p5" xreflabel="(Burnard and Bauman, 2007)"><textual class="po-textual">Burnard, L. and Bauman, S.
    </textual><emphasis class="po-inline e487 e487"><textual class="po-textual">TEI P5: Guidelines for Electronic Text Encoding and Interchange.</textual></emphasis><textual class="po-textual"> Text
   Encoding Initiative, 2007</textual></bibliomixed><bibliomixed class="po-block e488 e488" xml:id="carletta2003" xreflabel="(Carletta et al., 2003)"><textual class="po-textual">Carletta, J.; Kilgour, J.;
   O'Donnell, T.; Evert, S. and Voormann, H. </textual><emphasis class="po-inline e489 e489"><textual class="po-textual">The NITE Object Model Library for Handling
    Structured Linguistic Annotation on Multimodal Data Sets.</textual></emphasis><textual class="po-textual"> In: Proceedings of the EACL
   Workshop on Language Technology and the Semantic Web (3rd Workshop on NLP and XML, NLPXML-2003),
   2003</textual></bibliomixed><bibliomixed class="po-block e490 e490" xml:id="carletta2007" xreflabel="(Carletta et al.,2007)"><textual class="po-textual">Carletta, J.; DeRose, S.;
   Durusau, P.; Piez, W.; Sperberg-McQueen, C. M.; Tennison, J. and Witt, A. </textual><emphasis class="po-inline e491 e491"><textual class="po-textual">International
    Workshop on Markup of Overlapping Structures.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.) Proceedings of
   Extreme Markup Languages 2007, 2007</textual></bibliomixed><bibliomixed class="po-block e492 e492" xml:id="carpenter1992" xreflabel="(Carpenter, 1992)"><textual class="po-textual">Carpenter, B. </textual><emphasis class="po-inline e493 e493"><textual class="po-textual">The
    Logic of Typed Feature Structures: With Applications to Unification Grammars, Logic Programs and
    Constraint Resolution.</textual></emphasis><textual class="po-textual"> Cambridge University Press, 1992</textual></bibliomixed><bibliomixed class="po-block e494 e494" xml:id="derose2004" xreflabel="(DeRose, 2004)"><textual class="po-textual">DeRose, S. </textual><emphasis class="po-inline e495 e495"><textual class="po-textual">Markup Overlap: A
    Review and a Horse.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.) Proceedings of Extreme Markup Languages
   2004, 2004</textual></bibliomixed><bibliomixed class="po-block e496 e496" xml:id="diestel2005" xreflabel="(Diestel, 2005)"><textual class="po-textual">Diestel, R. </textual><emphasis class="po-inline e497 e497"><textual class="po-textual">Graph
    Theory</textual></emphasis><textual class="po-textual">. Springer, 2005</textual></bibliomixed><bibliomixed class="po-block e498 e498" xml:id="hilbert2005" xreflabel="(Hilbert et al.,2005)"><textual class="po-textual">Hilbert, M.; Schonefeld, O.
   and Witt, A. </textual><emphasis class="po-inline e499 e499"><textual class="po-textual">Making CONCUR work.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.) Proceedings of
   Extreme Markup Languages 2005, 2005</textual></bibliomixed><bibliomixed class="po-block e500 e500" xml:id="iso24610" xreflabel="(ISO24610, 2006)"><textual class="po-textual">24610-1:2006, I. </textual><emphasis class="po-inline e501 e501"><textual class="po-textual">Language
    Resource Management -- Feature Structures -- Part 1: Feature Structure
    Representation.</textual></emphasis><textual class="po-textual">International Organization for Standardization, 2006</textual></bibliomixed><bibliomixed class="po-block e502 e502" xml:id="kay2008" xreflabel="(Kay, 2008)"><textual class="po-textual">Kay, M. </textual><emphasis class="po-inline e503 e503"><textual class="po-textual">XSLT 2.0 and XPath 2.0
    Programmer's Reference.</textual></emphasis><textual class="po-textual"> Wrox Press Ltd., 2008</textual></bibliomixed><bibliomixed class="po-block e504 e504" xml:id="nlm" xreflabel="(NLM,2008)"><emphasis class="po-inline e505 e505"><textual class="po-textual">Custom Metadata Group</textual></emphasis><textual class="po-textual">. In:
   Journal Archiving and Interchange Tag Set Tag Library version 3.0, Version of November
   2008.</textual></bibliomixed><bibliomixed class="po-block e506 e506" xml:id="pollard1994" xreflabel="(Pollard and Sag, 1994)"><textual class="po-textual">Pollard, C. and Sag, I.
    </textual><emphasis class="po-inline e507 e507"><textual class="po-textual">Head-Driven Phrase Structure Grammar.</textual></emphasis><textual class="po-textual"> The University of Chicago Press,
   1994</textual></bibliomixed><bibliomixed class="po-block e508 e508" xml:id="sailer2001" xreflabel="(Sailer and Richter, 2001)"><textual class="po-textual">Sailer, M. and Richter, F.
    </textual><emphasis class="po-inline e509 e509"><textual class="po-textual">Eine XML-Kodierung für AVM-Beschreibungen.</textual></emphasis><textual class="po-textual"> In: Lobin, H. (ed.). Sprach- und
   Texttechnologie in digitalen Medien: Proceedings der GLDV-Frühjahrstagung 2001. BOD - Books on
   Demand, 2001, 161-168</textual></bibliomixed><bibliomixed class="po-block e510 e510" xml:id="schonefeld2006" xreflabel="(Schonefeld and Witt, 2006)"><textual class="po-textual">Schonefeld, O. and
   Witt, A. </textual><emphasis class="po-inline e511 e511"><textual class="po-textual">Towards validation of concurrent markup.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.).
   Proceedings of Extreme Markup Languages 2006, 2006</textual></bibliomixed><bibliomixed class="po-block e512 e512" xml:id="shieber1986" xreflabel="(Shieber, 1986)"><textual class="po-textual">Shieber, S. M. </textual><emphasis class="po-inline e513 e513"><textual class="po-textual">An
    Introduction to Unification-based Approaches to Grammar.</textual></emphasis><textual class="po-textual"> CSLI Publications,
   1986</textual></bibliomixed><bibliomixed class="po-block e514 e514" xml:id="p3" xreflabel="(Sperberg-McQueen and Burnard, 1994)"><textual class="po-textual">Sperberg-McQueen, C. M.
   and Burnard, L. </textual><emphasis class="po-inline e515 e515"><textual class="po-textual">TEI Guidelines for Electronic Text Encoding and Interchange (TEI
    P3).</textual></emphasis><textual class="po-textual"> Text Encoding Initiative, 1994</textual></bibliomixed><bibliomixed class="po-block e516 e516" xml:id="p4" xreflabel="(Sperberg-McQueen and Burnard, 2001)"><textual class="po-textual">Sperberg-McQueen, C. M.
   and Burnard, L. </textual><emphasis class="po-inline e517 e517"><textual class="po-textual">Guidelines for Electronic Text Encoding and Interchange (TEI
    P4).</textual></emphasis><textual class="po-textual"> Text Encoding Initiative, 2001</textual></bibliomixed><bibliomixed class="po-block e518 e518" xml:id="sperberg-mcqueen2007" xreflabel="(Sperberg-McQueen, 2007)"><textual class="po-textual">Sperberg-McQueen,
   C. M. </textual><emphasis class="po-inline e519 e519"><textual class="po-textual">Representation of overlapping structures.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.)
   Extreme Markup Languages 2007, 2007</textual></bibliomixed><bibliomixed class="po-block e520 e520" xml:id="tennison2005" xreflabel="(Tennison, 2005)"><textual class="po-textual">Tennison, J. </textual><emphasis class="po-inline e521 e521"><textual class="po-textual">Beginning
    XSLT 2.0: From Novice to Professional.</textual></emphasis><textual class="po-textual"> Apress, 2005</textual></bibliomixed><bibliomixed class="po-block e522 e522" xml:id="witt2004" xreflabel="(Witt, 2004)"><textual class="po-textual">Witt, A. </textual><emphasis class="po-inline e523 e523"><textual class="po-textual">Multiple Hierarchies:
    New Aspects of an Old Solution.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.) Proceedings of Extreme Markup
   Languages 2004, 2004 </textual></bibliomixed><bibliomixed class="po-block e524 e524" xml:id="witt2005" xreflabel="(Witt et al., 2005)"><textual class="po-textual">Witt, A.; Goecke, D.; Sasaki, F.
   and Lüngen, H. </textual><emphasis class="po-inline e525 e525"><textual class="po-textual">Unification of XML Documents with Concurrent Markup.</textual></emphasis><textual class="po-textual"> Literary
   and Linguistic Computing, 2005, 20, 103-116, doi: </textual><biblioid class="po-atom e526 doi e526"><textual class="po-textual">10.1093/llc/fqh046</textual></biblioid></bibliomixed><bibliomixed class="po-block e527 e527" xml:id="witt2007" xreflabel="(Witt et al., 2007)"><textual class="po-textual">Witt, A.; Schonefeld, O.; Rehm, G.;
   Khoo, J. and Evang, K. </textual><emphasis class="po-inline e528 e528"><textual class="po-textual">On the Lossless Transformation of Single-File Multi-Layer
    Annotations into Multi-Rooted Trees.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.). Proceedings of Extreme
   Markup Languages 2007, 2007 </textual></bibliomixed><bibliomixed class="po-block e529 e529" xml:id="witt2009" xreflabel="(Witt et al., 2009)"><textual class="po-textual">Witt, A.; Rehm, G.; Hinrichs, E.;
   Lehmberg, T. and Stegmann, J. </textual><emphasis class="po-inline e530 e530"><textual class="po-textual">SusTEInability of Linguistic Resources through Feature
    Structures.</textual></emphasis><textual class="po-textual"> Literary and Linguistic Computing, 2009,  24, 363-372, doi: </textual><biblioid class="po-atom e531 doi e531"><textual class="po-textual">10.1093/llc/fqp024</textual></biblioid></bibliomixed><bibliomixed class="po-block e532 e532" xml:id="woerner2006" xreflabel="(Wörner et al., 2006)"><textual class="po-textual">Wörner, K.; Witt, A.; Rehm, G.
   and Dipper, S. </textual><emphasis class="po-inline e533 e533"><textual class="po-textual">Modelling Linguistic Data Structures.</textual></emphasis><textual class="po-textual"> In: Usdin, B. T. (ed.).
   Proceedings of Extreme Markup Languages 2006, 2006</textual></bibliomixed></bibliography></article></classedDocument>