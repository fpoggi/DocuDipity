<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Where Are All The Bugs?</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Introspection in XQuery</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">In a large code and complex code base, it becomes unfeasible to
manually develop tests for every feature and combination of
features. The key to quality assurance in this context is automation and focus.
Automatic generation of tests creates its own problems, however, as the
execution of a complete cross-product of all interactions will take too long to
execute, and small defects can give rise to large numbers of regression
failures that must be manually analyzed. Manually identifying the interactions
is itself a challenging undertaking, as is automatically generating
</textual><emphasis class="po-inline e9 e9"><textual class="po-textual">meaningful</textual></emphasis><textual class="po-textual"> test cases. It becomes important to make smart
choices about what to expend effort on so as to minimize the risk of undetected
code defects. 
        </textual></para><para class="po-block e10 e10"><textual class="po-textual">This paper reports on an attempt to find areas to focus testing on in a
large XQuery code base by performing XQuery introspection on that code base,
treating the set of functions and parameter and return types as vocabularies, and
computing TF-IDF scores over the terms in those vocabularies. To the extent
that function names and types follow classic Zipf distributions,
using TF-IDF scoring over those vocabularies makes mathematical sense.
Terms that score high will be those that are common enough to be important
(high term frequency) but not so ubiquitous that they tend not to be covered by
other tests (high inverse document frequency).
        </textual></para></abstract><author class="po-record e11 e11"><personname class="po-record e12 e12"><firstname class="po-field e13 e13"><textual class="po-textual">Mary</textual></firstname><surname class="po-field e14 e14"><textual class="po-textual">Holstege</textual></surname></personname><personblurb class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Mary Holstege is Principal Engineer at MarkLogic
Corporation. She has over 20 years experience as a software engineer in and
around markup technologies and information extraction. She holds a Ph.D. from
Stanford University in Computer Science, for a thesis on document
representation.</textual></para></personblurb><affiliation class="po-record e17 e17"><jobtitle class="po-field e18 e18"><textual class="po-textual">Principal Engineer</textual></jobtitle><orgname class="po-block e19 e19"><textual class="po-textual">MarkLogic Corporation</textual></orgname></affiliation><email class="po-field e20 e20"><textual class="po-textual">mary.holstege@marklogic.com</textual></email></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Copyright Â© 2013 Mary Holstege</textual></para></legalnotice></info><section class="po-hcontainer e23 e23"><title class="po-block e24 e24"><textual class="po-textual">Introduction</textual></title><para class="po-block e25 e25"><textual class="po-textual">Ensuring that software works properly can be a difficult undertaking.
When a code base is small and worked on by a handful of people,
you can manually generate tests with good confidence that they cover the ground.
As the code base grows it develops more complex interactions,
includes more features, and is modified by more and more developers.
The code develops unused byways and tangles of dependencies.
It becomes unfeasible to
manually develop tests for every feature and combination of features.
Complete automated testing of all possibilities also becomes increasing less
feasible:
developing cases, executing them, and analyzing the results becomes more and
more time consuming. The sad truth about QA is that the difficulty of ensuring
that software works correctly does not scale linearly with the size of the code base.
</textual></para><para class="po-block e26 e26"><textual class="po-textual">Analysis of code usage patterns can help focus attention where testing can do
the most good. Code analysis can also provide a different perspective on the
code that can lead to uncovering potential issues as well. For example, a
function that is not called much probably doesn't need a lot of testing. Testing is 
designed to limit risk, and the risk of a bug in a rarely used function is
commensurately low. On the other hand, a function that is widely called may
</textual><emphasis class="po-inline e27 e27"><textual class="po-textual">also</textual></emphasis><textual class="po-textual"> not need a lot of additional testing on the grounds
that it is already tested in the process of testing its callers. So again, from
a risk perspective, the risk of not adding additional tests for that function
is also low. Beyond simple
testing, analysis of usage patterns can perhaps highlight areas where APIs can
be simplified by removing unnecessary options and alternatives.
</textual></para><para class="po-block e28 e28"><textual class="po-textual">
The schema types and elements used in function argument and return types form
an important part of the API. Analysis of the usage patterns of declared types
and elements against the available pool exposed by the in scope schemas can
also provide insights into possible API simplification, or testing focus.
</textual></para><para class="po-block e29 e29"><textual class="po-textual">The idea explored here is that (a) functions and types form
vocabularies of sorts 
and the distribution of usage of those vocabularies follows the well-established
laws for natural language vocabularies (i.e. Zipf's law) and as such
(b) TF-IDF score calculations over those vocabularies make mathematical
sense and (c) high scoring items make interesting and useful targets for
testing. 
</textual></para><para class="po-block e30 e30"><textual class="po-textual">
This paper describes a case study in analyzing a large XQuery code base
using XQuery and XML Schema introspection in an attempt to determine where to
focus testing efforts, based on this idea. For functions at least, there seems
to be some reason to conclude that the idea holds promise. Types, less so.
</textual></para><para class="po-block e31 e31"><textual class="po-textual">Several extensions to XQuery are required to perform this introspection:
a schema component API, functions to provide lists of available functions and
return types and argument types of functions. It is also convenient, in order
to implement the entire processing reasonably efficiently in XQuery, to have
map data types, a structured dump of the parse tree of XQuery modules,
filesystem access functions, and the ability to evaluated constructed XQuery
functions.
</textual></para></section><section class="po-hcontainer e32 e32"><title class="po-block e33 e33"><textual class="po-textual">Background</textual></title><para class="po-block e34 e34"><textual class="po-textual">About ten years ago, a handful of developers worked on a couple thousand
lines of XQuery code, and one person manually constructed the tests to add to
automatic regression suites. All was well. As time went by, the code grew and
became more complex, the number of people manually constructing tests
increased, with additional people to manually analyze regression failures. Some
tests are automatically generated, but such tests tend to raise analysis costs
when something does fail. The time has come to think about new approaches and
find ways to focus effort.
</textual></para><section class="po-hcontainer e35 e35"><title class="po-block e36 e36"><textual class="po-textual">The Code Base</textual></title><para class="po-block e37 e37"><textual class="po-textual">The code base consists of about 630 thousand lines of
XQuery code, divided roughly evenly between an old and much modified
schema-driven GUI
application for database configuration and management, more recent REST endpoint
implementations and web applications, and a collection of library modules
(including some main modules used in triggers). In total there are a little over
1500 XQuery module files, defining over 68 thousand functions. In addition, the
particular XQuery implementation associated with this collection of XQuery
modules also provides a little over 1800 built-in functions. XML schemas are
actively used to strongly type parameters: there are over 150 schema files
exposing over 12 thousand global element declarations, 26 thousand named simple
type definitions, and 7 thousand named complex type definitions. The bulk of
these schemas 
relate to XHTML, however. Setting that aside there are over 50 schema files
exposing over 7 thousand global element declarations, almost 18 thousand named
simple type 
definitions, and 3 thousand complex type definitions.
</textual></para><para class="po-block e38 e38"><textual class="po-textual">This is a live and
active body of code, ranging in age from code first written ten years ago to
functions still just being implemented today. A peculiar problem with this
particular code base is the range of syntax in play: The code ranges from
XQuery 1.0 compliant code to code using some XQuery 3.0 features or
anticipatory XQuery extensions (similar to although not necessarily identical
to proposed XQuery features) and some very old code still using some 2003 draft
syntax. Relying on the XQuery engine itself to analyze such diverse code is
helpful, because the engine already has to reconcile the syntactic differences
internally. This peculiarity does mean that third party code analysis tools
cannot be used.
</textual></para><figure class="po-container e39 e39" xml:id="fig_detailed_stats"><title class="po-block e40 e40"><textual class="po-textual">Detailed statistics</textual></title><informaltable class="po-container e41 e41" rules="groups"><thead class="po-container e42 e42"><tr class="po-table e43 e43"><th class="po-field e44 e44" colspan="3"><textual class="po-textual">XQuery code</textual></th></tr></thead><tfoot class="po-null e45 e45"><tr class="po-table e46 e46"><th class="po-field e47 e47"><textual class="po-textual">Total</textual></th><td class="po-block e48 e48"><textual class="po-textual">1559</textual></td><td class="po-block e49 e49"><textual class="po-textual">363497</textual></td></tr></tfoot><tr class="po-table e50 e50"><th class="po-field e51 e51"><textual class="po-textual">Group</textual></th><th class="po-field e52 e52"><textual class="po-textual">Files</textual></th><th class="po-field e53 e53"><textual class="po-textual">Lines of code</textual></th></tr><tr class="po-table e54 e54"><th class="po-field e55 e55"><textual class="po-textual">Admin GUI</textual></th><td class="po-block e56 e56"><textual class="po-textual">740</textual></td><td class="po-block e57 e57"><textual class="po-textual">116714</textual></td></tr><tr class="po-table e58 e58"><th class="po-field e59 e59"><textual class="po-textual">Libraries</textual></th><td class="po-block e60 e60"><textual class="po-textual">333</textual></td><td class="po-block e61 e61"><textual class="po-textual">137983</textual></td></tr><tr class="po-table e62 e62"><th class="po-field e63 e63"><textual class="po-textual">REST endpoints and applications</textual></th><td class="po-block e64 e64"><textual class="po-textual">387</textual></td><td class="po-block e65 e65"><textual class="po-textual">101322</textual></td></tr><tr class="po-table e66 e66"><th class="po-field e67 e67"><textual class="po-textual">Misc. other</textual></th><td class="po-block e68 e68"><textual class="po-textual">99</textual></td><td class="po-block e69 e69"><textual class="po-textual">7478</textual></td></tr></informaltable><informaltable class="po-container e70 e70" rules="groups"><thead class="po-container e71 e71"><tr class="po-table e72 e72"><th class="po-field e73 e73" colspan="3"><textual class="po-textual">Schema Types</textual></th></tr></thead><tr class="po-table e74 e74"><th class="po-field e75 e75"><textual class="po-textual">Count</textual></th><th class="po-field e76 e76"><textual class="po-textual">Total</textual></th><th class="po-field e77 e77"><textual class="po-textual">Non-XHTML Total</textual></th></tr><tr class="po-table e78 e78"><th class="po-field e79 e79"><textual class="po-textual">Files</textual></th><td class="po-block e80 e80"><textual class="po-textual">158</textual></td><td class="po-block e81 e81"><textual class="po-textual">56</textual></td></tr><tr class="po-table e82 e82"><th class="po-field e83 e83"><textual class="po-textual">Global element declarations</textual></th><td class="po-block e84 e84"><textual class="po-textual">12324</textual></td><td class="po-block e85 e85"><textual class="po-textual">7338</textual></td></tr><tr class="po-table e86 e86"><th class="po-field e87 e87"><textual class="po-textual">Named simple type definitions</textual></th><td class="po-block e88 e88"><textual class="po-textual">26536</textual></td><td class="po-block e89 e89"><textual class="po-textual">17866</textual></td></tr><tr class="po-table e90 e90"><th class="po-field e91 e91"><textual class="po-textual">Named complex type definitions</textual></th><td class="po-block e92 e92"><textual class="po-textual">7038</textual></td><td class="po-block e93 e93"><textual class="po-textual">3009</textual></td></tr></informaltable><informaltable class="po-container e94 e94" rules="groups"><thead class="po-container e95 e95"><tr class="po-table e96 e96"><th class="po-field e97 e97" colspan="2"><textual class="po-textual">Functions</textual></th></tr></thead><tr class="po-table e98 e98"><th class="po-field e99 e99"><textual class="po-textual">Group</textual></th><th class="po-field e100 e100"><textual class="po-textual">Number of Functions</textual></th></tr><tr class="po-table e101 e101"><th class="po-field e102 e102"><textual class="po-textual">Built-in functions (C++)</textual></th><td class="po-block e103 e103"><textual class="po-textual">1849</textual></td></tr><tr class="po-table e104 e104"><th class="po-field e105 e105"><textual class="po-textual">XQuery module functions</textual></th><td class="po-block e106 e106"><textual class="po-textual">68191</textual></td></tr></informaltable></figure></section><section class="po-hcontainer e107 e107"><title class="po-block e108 e108"><textual class="po-textual">Zipf's Law and TF-IDF Scoring</textual></title><para class="po-block e109 e109"><textual class="po-textual">Zipf's law is an empirical observation </textual><citation class="po-atom e110 e110" linkend="zipf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> that
in a natural language corpus, the distribution of word frequencies (number of
occurrences, that is) varies in
inverse proportion to the rank of the word in frequency order. 
Mathematically, </textual><code class="po-atom e111 e111"><textual class="po-textual">Frequency(R) = Frequency(1)/Rk</textual></code><textual class="po-textual"> where
</textual><code class="po-atom e112 e112"><textual class="po-textual">Frequency(R)</textual></code><textual class="po-textual"> is the frequency of the word of rank
</textual><code class="po-atom e113 e113"><textual class="po-textual">R</textual></code><textual class="po-textual"> and </textual><code class="po-atom e114 e114"><textual class="po-textual">k</textual></code><textual class="po-textual"> is some constant.
If you graph the distribution on log-log axes, you get a straight line.
Such distributions are very common across various fields and
applications. This paper will consider sequence types used in function
parameters and return types as forming one vocabulary, and the names of
functions themselves forming another, and look at the frequency distribution of
these terms in the corpus of XQuery modules.
  </textual></para><para class="po-block e115 e115"><textual class="po-textual">TF-IDF scoring has become a standard technique for computing relevance
  of documents to full-text queries since it was introduced in 1972
  </textual><citation class="po-atom e116 e116" linkend="jones"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. TF stands for "term frequency" and is a count of
  how often a particular term occurs in a particular document. In the context
  of full-text search a term is typically a single word, but other terms for
  phrases or wildcards are possible. IDF stands for "inverse document
  frequency" and is the number of documents a term occurs in, as a fraction of
  the total number of documents in the corpus. The "inverse" part of IDF means
  that this number is divided, so that higher document frequencies lead to
  smaller scores.
  </textual></para><para class="po-block e117 e117"><textual class="po-textual">When TF-IDF scores are used to compute relevance to a query, the term
  and document frequencies of each query term are combined together.
  The technique is based on a particular probabilistic model of documents,
  but the intuition behind it is simple enough: more occurrences of a query
  term makes a document more relevant, and occurrences of query terms that only
  occur in a few documents makes a document more relevant.
  </textual></para><para class="po-block e118 e118"><textual class="po-textual">Various modifications and extensions of the
  technique are currently ubiquitous in modern search engines. It has also been put
  to related purposes, such as computing document similarities and
  clustering.  In these applications there may not be a query per se, but the
  set of terms is taken from the documents themselves. 
  </textual></para><para class="po-block e119 e119"><textual class="po-textual">Here, I will attempt to use TF-IDF scores of function calls and types as
  a way of selecting "interesting" functions and types on which to focus QA attention.
  In this model, the XQuery modules play the role of documents, function calls or types
  play the role of terms, and the terms are taken from the documents
  themselves, as one would see in a clustering or similarity application.
  </textual></para><para class="po-block e120 e120"><textual class="po-textual">First, we will look at the actual distributions of types and functions,
to see if computing scores makes sense at all. Where it makes sense to do so, 
we will look at computed scores qualitatively and quantitatively to try to see 
whether the high scoring items are indeed interesting targets for testing focus.
  </textual></para></section></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual">Distribution of Sequence Types</textual></title><para class="po-block e123 e123"><textual class="po-textual">XQuery </textual><citation class="po-atom e124 e124" linkend="xq30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> functions may have declared
sequence types for their parameters and their return values. XQuery sequence
types may be either simple type names </textual><citation class="po-atom e125 e125" linkend="xsd11dt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> or node
tests of some kind. It is 
possible to define sequence types that name a complex type without naming a
specific element. XQuery
3.0 </textual><citation class="po-atom e126 e126" linkend="xqfo30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> also allows for functions tests.
XQuery sequence
types also have cardinality indicators, with '?' meaning a sequence of 0 or 1
instances of the base type, '*' meaning any
number, '+' meaning 1 or more, and no indicator meaning exactly 1. When no
explicit sequence type declaration is given, the sequence type is the most
generic, matching anything: </textual><code class="po-atom e127 e127"><textual class="po-textual">item()*</textual></code><textual class="po-textual">.
    </textual></para><figure class="po-container e128 e128" xml:id="fig_ex_function"><programlisting class="po-block e129 e129" xml:space="preserve"><textual class="po-textual">
declare function my:example($x, $y as xs:string?) as element(my:result)
</textual></programlisting><caption class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual">The declaration of an example function. The parameter </textual><code class="po-atom e132 e132"><textual class="po-textual">$x</textual></code><textual class="po-textual">
has the (default) sequence type </textual><code class="po-atom e133 e133"><textual class="po-textual">item()*</textual></code><textual class="po-textual">, </textual><code class="po-atom e134 e134"><textual class="po-textual">$y</textual></code><textual class="po-textual"> has the
sequence type </textual><code class="po-atom e135 e135"><textual class="po-textual">xs:string?</textual></code><textual class="po-textual">, and the returned value has the sequence
type </textual><code class="po-atom e136 e136"><textual class="po-textual">element(my:result)</textual></code><textual class="po-textual">.</textual></para></caption></figure><para class="po-block e137 e137"><textual class="po-textual">In this code base and the underlying XQuery engine associated with it,
the built-in functions return 196 distinct declared sequence types while the
XQuery modules use 629 distinct declared sequence types. In this particular
XQuery implementation, it is not possible to declare different named element
sequence types for parameters or return types of built-in functions.
That is, a built-in function may be declared as returning
</textual><code class="po-atom e138 e138"><textual class="po-textual">element()</textual></code><textual class="po-textual">
but not </textual><code class="po-atom e139 e139"><textual class="po-textual">element(my:result)</textual></code><textual class="po-textual">. 
If we consolidate all the </textual><code class="po-atom e140 e140"><textual class="po-textual">element</textual></code><textual class="po-textual"> sequence
types for module functions, there are only 103 distinct declared sequence types.
</textual></para><para class="po-block e141 e141"><textual class="po-textual">Obviously, the sequence types used in the API form but a small part of
the total set exposed through the schemas. Only 3 named complex types are
explicitly used, from the complete set of 3 thousand (non-XHTML) named complex
types. Only 474 named elements are explicitly used, from the complete set of 7
thousand. Only 49 named simple types are explicitly used by module
functions. The overabundance of named schema components is partly because named
types and are used implicitly in the schema-driven configuration and
administration UI, and partly a matter of stylistic preference for global
element declarations and for declaring functions using generic element tests
(e.g. </textual><code class="po-atom e142 e142"><textual class="po-textual">element()</textual></code><textual class="po-textual">) rather than specific complex types
(</textual><code class="po-atom e143 e143"><textual class="po-textual">element(*,my:example)</textual></code><textual class="po-textual">). Regardless, it doesn't look like it would
be helpful to pay special attention to types or elements that are not
specifically referenced in function signatures.
</textual></para><figure class="po-container e144 e144" xml:id="fig_rt_dist"><title class="po-block e145 e145"><textual class="po-textual">Sequence type distribution (return values)</textual></title><mediaobject class="po-container e146 e146"><imageobject class="po-container e147 e147"><imagedata class="po-meta e148 e148" fileref="../../../vol10/graphics/Holstege01/Holstege01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><mediaobject class="po-container e149 e149"><imageobject class="po-container e150 e150"><imagedata class="po-meta e151 e151" fileref="../../../vol10/graphics/Holstege01/Holstege01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e152 e152"><para class="po-block e153 e153"><textual class="po-textual">The frequency distribution of return value sequence types
      shown 
on a double log scale. The horizontal axis is the rank and the vertical axis is
frequency. The top graph shows the distribution for built-in
functions; the bottom graph shows the distribution for module functions.</textual></para></caption></figure><para class="po-block e154 e154"><textual class="po-textual">The return type frequency distribution curves in 
    </textual><xref class="po-milestone e155 e155" linkend="fig_rt_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> do show that these return types mostly follow a
    power law distribution, although for built-in functions there is
    very substantial drop-off at ends, possibly as a consequence of the
relatively small vocabulary size.
    </textual></para><para class="po-block e156 e156"><textual class="po-textual">The distribution of function parameter sequence types looks very
    similar to that of function return value sequence types, including the
    drop-offs at the extremes for built-in functions, as shown in </textual><xref class="po-milestone e157 e157" linkend="fig_arg_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></para><figure class="po-container e158 e158" xml:id="fig_arg_dist"><title class="po-block e159 e159"><textual class="po-textual">Sequence type distribution (parameters)</textual></title><mediaobject class="po-container e160 e160"><imageobject class="po-container e161 e161"><imagedata class="po-meta e162 e162" fileref="../../../vol10/graphics/Holstege01/Holstege01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><mediaobject class="po-container e163 e163"><imageobject class="po-container e164 e164"><imagedata class="po-meta e165 e165" fileref="../../../vol10/graphics/Holstege01/Holstege01-004.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e166 e166"><para class="po-block e167 e167"><textual class="po-textual">The frequency distribution of parameter sequence types
      shown 
on a double log scale.  The horizontal axis is the rank and the vertical axis is
frequency.  The top graph shows the distribution for built-in
functions; the bottom graph shows the distribution for module functions.</textual></para></caption></figure><para class="po-block e168 e168"><textual class="po-textual">The top five return value and parameter sequence types share some
    overlap between built-ins and module functions, although there are some
    interesting differences. The atomic types </textual><code class="po-atom e169 e169"><textual class="po-textual">map:map</textual></code><textual class="po-textual"> and
    </textual><code class="po-atom e170 e170"><textual class="po-textual">cts:query</textual></code><textual class="po-textual"> are special built-in types, the former anticipating
    XQuery maps, and the latter in support of full-text queries. Given the
    importance of full-text queries to this implementation, the strong showing
    of </textual><code class="po-atom e171 e171"><textual class="po-textual">cts:query</textual></code><textual class="po-textual"> is unsurprising. The strong showing of
    </textual><code class="po-atom e172 e172"><textual class="po-textual">map:map</textual></code><textual class="po-textual"> demonstrates the utility of this feature. In both
    cases the distribution does suggest that these are important types and
    should be the focus of some QA effort.
    </textual></para><para class="po-block e173 e173"><textual class="po-textual">
    In this
    code base it appears that developers use strong types on parameters more
often than on 
    function return values (as indicated by the higher prevalence of
    </textual><code class="po-atom e174 e174"><textual class="po-textual">item()*</textual></code><textual class="po-textual"> for function return values but not for parameters).
    Simple types dominate the distribution for parameter types but less so for
    return types. The high frequency of </textual><code class="po-atom e175 e175"><textual class="po-textual">empty-sequence()</textual></code><textual class="po-textual"> in return
    types is a consequence of the fact that the implementation supports
    functions that update the data store, so many functions are called for
    effect rather than for the return value.
    </textual></para><table cellpadding="0" class="po-container e176 e176" pgwide="1"><caption class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">Top 5 sequence types in various categories.</textual></para></caption><tr class="po-table e179 e179"><th class="po-field e180 e180" colspan="2"><textual class="po-textual">Return types (modules)</textual></th></tr><tr class="po-table e181 e181"><th align="left" class="po-field e182 e182"><textual class="po-textual">Overall</textual></th><td class="po-block e183 e183"><code class="po-atom e184 e184"><textual class="po-textual">item()*, empty-sequence(), xs:string, node(), element(configuration)</textual></code></td></tr><tr class="po-table e185 e185"><th align="left" class="po-field e186 e186"><textual class="po-textual">Simple types</textual></th><td class="po-block e187 e187"><code class="po-atom e188 e188"><textual class="po-textual">xs:string, xs:boolean, xs:string*, xs:string?, xs:unsignedLong</textual></code></td></tr><tr class="po-table e189 e189"><th align="left" class="po-field e190 e190"><textual class="po-textual">Other</textual></th><td class="po-block e191 e191"><code class="po-atom e192 e192"><textual class="po-textual">item()*, empty-sequence(), node(), element(configuration), node()*</textual></code></td></tr><tr class="po-table e193 e193"><th align="left" class="po-field e194 e194"><textual class="po-textual">Simple types (ignoring cardinality)</textual></th><td class="po-block e195 e195"><code class="po-atom e196 e196"><textual class="po-textual">xs:string, xs:unsignedLong, xs:boolean, cts:query, map:map</textual></code></td></tr><tr class="po-table e197 e197"><th class="po-field e198 e198" colspan="6"><textual class="po-textual">Return types (built-ins)</textual></th></tr><tr class="po-table e199 e199"><th align="left" class="po-field e200 e200"><textual class="po-textual">Overall</textual></th><td class="po-block e201 e201"><code class="po-atom e202 e202"><textual class="po-textual">item()*, empty-sequence(),
xs:string, xs:string*, cts:query</textual></code></td></tr><tr class="po-table e203 e203"><th align="left" class="po-field e204 e204"><textual class="po-textual">Simple types</textual></th><td class="po-block e205 e205"><code class="po-atom e206 e206"><textual class="po-textual">xs:string, xs:string*, cts:query, xs:boolean, xs:unsignedLong</textual></code></td></tr><tr class="po-table e207 e207"><th align="left" class="po-field e208 e208"><textual class="po-textual">Other</textual></th><td class="po-block e209 e209"><code class="po-atom e210 e210"><textual class="po-textual">item()*, empty-sequence(), element()*, element(), node()*</textual></code></td></tr><tr class="po-table e211 e211"><th align="left" class="po-field e212 e212"><textual class="po-textual">Simple types (ignoring cardinality)</textual></th><td class="po-block e213 e213"><code class="po-atom e214 e214"><textual class="po-textual">xs:string, xs:unsignedLong, xs:integer, cts:query, xs:boolean</textual></code></td></tr><tr class="po-table e215 e215"><th class="po-field e216 e216" colspan="6"><textual class="po-textual">Parameters (modules)</textual></th></tr><tr class="po-table e217 e217"><th align="left" class="po-field e218 e218"><textual class="po-textual">Overall</textual></th><td class="po-block e219 e219"><code class="po-atom e220 e220"><textual class="po-textual">xs:string, xs:unsignedLong, map:map, item()*, xs:string?</textual></code></td></tr><tr class="po-table e221 e221"><th align="left" class="po-field e222 e222"><textual class="po-textual">Simple types</textual></th><td class="po-block e223 e223"><code class="po-atom e224 e224"><textual class="po-textual">xs:string, xs:unsignedLong, map:map, xs:string?, xs:boolean</textual></code></td></tr><tr class="po-table e225 e225"><th align="left" class="po-field e226 e226"><textual class="po-textual">Other</textual></th><td class="po-block e227 e227"><code class="po-atom e228 e228"><textual class="po-textual">item()*, node(), element(configuration), node()?, element()</textual></code></td></tr><tr class="po-table e229 e229"><th class="po-field e230 e230" colspan="6"><textual class="po-textual">Parameters (built-ins)</textual></th></tr><tr class="po-table e231 e231"><th align="left" class="po-field e232 e232"><textual class="po-textual">Overall</textual></th><td class="po-block e233 e233"><code class="po-atom e234 e234"><textual class="po-textual">xs:string, xs:string*, xs:QName*, xs:string?, xs:anyAtomicType?</textual></code></td></tr><tr class="po-table e235 e235"><th align="left" class="po-field e236 e236"><textual class="po-textual">Simple types</textual></th><td class="po-block e237 e237"><code class="po-atom e238 e238"><textual class="po-textual">xs:string, xs:string*, xs:QName*, xs:string?, xs:anyAtomicType</textual></code></td></tr><tr class="po-table e239 e239"><th align="left" class="po-field e240 e240"><textual class="po-textual">Other</textual></th><td class="po-block e241 e241"><code class="po-atom e242 e242"><textual class="po-textual">item()*, node(), node()?, node()*, item()</textual></code></td></tr></table><section class="po-hcontainer e243 e243"><title class="po-block e244 e244"><textual class="po-textual">Type Scores</textual></title><para class="po-block e245 e245"><textual class="po-textual"> Given that the distribution of types follows a classic
      Zipf distribution, it is not unreasonable to apply the probabilistic
      document model on which TF-IDF scoring is based.
      </textual></para><para class="po-block e246 e246"><textual class="po-textual">The score of a particular term </textual><code class="po-atom e247 e247"><textual class="po-textual">t</textual></code><textual class="po-textual"> that occurs at least
      once in the corpus of </textual><code class="po-atom e248 e248"><textual class="po-textual">N</textual></code><textual class="po-textual"> documents is given by the following
      equation, where </textual><code class="po-atom e249 e249"><textual class="po-textual">log</textual></code><textual class="po-textual"> is the natural logarithm,
      </textual><code class="po-atom e250 e250"><textual class="po-textual">TF(t)</textual></code><textual class="po-textual"> is the number of occurrences of </textual><code class="po-atom e251 e251"><textual class="po-textual">t</textual></code><textual class="po-textual">, and
      </textual><code class="po-atom e252 e252"><textual class="po-textual">DF(t)</textual></code><textual class="po-textual"> is the number of documents in which </textual><code class="po-atom e253 e253"><textual class="po-textual">t</textual></code><textual class="po-textual">
      occurs.</textual></para><equation class="po-container e254 e254"><mathphrase class="po-block e255 e255"><textual class="po-textual">
        score(t) = log(1+TF(t)) / log(DF(t)/N)
      </textual></mathphrase></equation><para class="po-block e256 e256"><textual class="po-textual">The sequence types with the highest scores are almost all
      distinctly named elements, typically those used as important API
      elements. On the other hand, it must be said that there doesn't seem to
be any qualitative difference between distinctly named elements with high
scores and those with much lower scores. Various kinds of </textual><code class="po-atom e257 e257"><textual class="po-textual">options</textual></code><textual class="po-textual">
elements are scattered throughout the range of scores, for
example. </textual><code class="po-atom e258 e258"><textual class="po-textual">element(xproc:xslt)</textual></code><textual class="po-textual"> has a much higher score than
</textual><code class="po-atom e259 e259"><textual class="po-textual">element(xproc:xquery)</textual></code><textual class="po-textual"> but again, it is hard to see a difference in
the QA needs of these two sequence types. What are we to make of the fact that
</textual><code class="po-atom e260 e260"><textual class="po-textual">xs:long</textual></code><textual class="po-textual"> has a much lower score than </textual><code class="po-atom e261 e261"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">? Not
much, I think. Perhaps the vocabulary of sequence types is too small to be
useful.
      </textual></para><figure class="po-container e262 e262" xml:id="fig_type_scores"><title class="po-block e263 e263"><textual class="po-textual">Sequence Type Scores</textual></title><programlisting class="po-block e264 e264" xml:space="preserve"><textual class="po-textual">
39.10 element(configuration)
33.70 element(opt:options)
31.55 element(forest:forest-status)*
30.14 element(flexrep:configuration)
28.85 element(plugin:plugin-model)?
28.66 element(opt:constraint)
28.18 element(rsrc:resources)
27.74 element(alert:config)
27.26 lnk:uri
27.09 element(sec:external-security)
...
14.10 xs:integer
14.04 xs:float
...
12.45 element(xproc:xslt)
12.30 xs:integer*
12.12 xs:double
...
8.33 xs:date
7.86 xs:long
...
7.35 element(xproc:string-replace)
7.35 element(xproc:xquery)
...
4.79 cts:element-attribute-value-query
4.79 element(project)*
4.64 xs:long*
4.41 cts:word-query
4.36 function(*)+
4.35 text()
4.23 element(test)*
4.07 map:map*
4.03 function()
4.00 cts:element-value-query
</textual></programlisting><caption class="po-container e265 e265"><para class="po-block e266 e266"><textual class="po-textual">The scores for the top 10, bottom 10, and some selected sequence
types in between are shown, rounded to 2 decimal places.</textual></para></caption></figure></section><section class="po-hcontainer e267 e267"><title class="po-block e268 e268"><textual class="po-textual">Techniques</textual></title><para class="po-block e269 e269"><textual class="po-textual">Type frequencies for built-in functions were computed using
      some introspection APIs: a function to enumerate all the defined
      functions, and accessor functions for the return type, the arity of the
      function, and the parameter types. Function accessors defined by Holstege
      </textual><citation class="po-atom e270 e270" linkend="mhsc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> and function introspection functions defined
      in XQuery 3.0 </textual><citation class="po-atom e271 e271" linkend="xqfo30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> do not quite do the job. The
      accessors defined by Holstege only give the atomic type names, not the
      full sequence types, while the XQuery 3.0 functions only give access to
      the function name and its arity. I used three additional
      built-in extension functions, one to enumerate the set of functions, and
      two to give the sequence types as string values.
      Maps kept running totals of the usage of each sequence type.
      </textual></para><para class="po-block e272 e272"><textual class="po-textual">Computing type frequencies for module functions requires a little
      more. There are two approaches: (1) use an evaluation function that
      imports a given module and uses the same approach as for built-ins, but
      only considering functions in the proper namespace, (2) dump out the
      module parse tree in a structured form and analyze it for the necessary
      information. In this case, I used the second approach, using a built-in
      extension function that dumped out the parse tree. The format of this
      dump was not, alas, XML, so fishing information out of the text relied
      heavily on the XQuery 3.0 function </textual><code class="po-atom e273 e273"><textual class="po-textual">analyze-string</textual></code><textual class="po-textual">.
      </textual></para><para class="po-block e274 e274"><textual class="po-textual">Doing everything in XQuery was convenient. Doing so meant using
      non-standard features such as maps and access to filesystem information.
      The filesystem access gave me the equivalent of a recursive
      </textual><code class="po-atom e275 e275"><textual class="po-textual">find</textual></code><textual class="po-textual">. It was handy, but not
      strictly necessary: one could instead use shell scripts to gather up the
      set of module names to process them, and then pass that to the analysis
      module. Strictly speaking, maps are not necessary either, but they made
      it much easier to write the analysis modules.</textual></para></section></section><section class="po-hcontainer e276 e276"><title class="po-block e277 e277"><textual class="po-textual">Distribution of Functions</textual></title><para class="po-block e278 e278"><textual class="po-textual">Function call distributions show the same characteristic Zipf
      distribution as types (see </textual><xref class="po-milestone e279 e279" linkend="fig_fn_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, although with a
      bit of a drop-off at the upper end of the curve. The majority of the top
      10 functions are XQuery standard built-in functions, although map-related
      functions occur at rank 8 and 9. The top 10 most frequently called
      functions are:
</textual><code class="po-atom e280 e280"><textual class="po-textual">string</textual></code><textual class="po-textual">, </textual><code class="po-atom e281 e281"><textual class="po-textual">concat</textual></code><textual class="po-textual">, </textual><code class="po-atom e282 e282"><textual class="po-textual">empty</textual></code><textual class="po-textual">,
</textual><code class="po-atom e283 e283"><textual class="po-textual">exists</textual></code><textual class="po-textual">, </textual><code class="po-atom e284 e284"><textual class="po-textual">xs:QName</textual></code><textual class="po-textual">, </textual><code class="po-atom e285 e285"><textual class="po-textual">error</textual></code><textual class="po-textual">,
</textual><code class="po-atom e286 e286"><textual class="po-textual">data</textual></code><textual class="po-textual">, </textual><code class="po-atom e287 e287"><textual class="po-textual">map:put</textual></code><textual class="po-textual">, </textual><code class="po-atom e288 e288"><textual class="po-textual">map:get</textual></code><textual class="po-textual">,
and </textual><code class="po-atom e289 e289"><textual class="po-textual">not</textual></code><textual class="po-textual">.
      </textual></para><figure class="po-container e290 e290" xml:id="fig_fn_dist"><title class="po-block e291 e291"><textual class="po-textual">Function call distribution</textual></title><mediaobject class="po-container e292 e292"><imageobject class="po-container e293 e293"><imagedata class="po-meta e294 e294" fileref="../../../vol10/graphics/Holstege01/Holstege01-005.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e295 e295"><para class="po-block e296 e296"><textual class="po-textual">The frequency distribution of function calls
      shown on a double log scale.  The horizontal axis is the rank and the vertical axis is
frequency.</textual></para></caption></figure><para class="po-block e297 e297"><textual class="po-textual">Quite a few functions are not used within the code base at
      all. A total of 497 built-in functions are unused, although only 16
      module functions are unused. Given that there is a much larger number of
      declared module functions, the disproportionate nature of this result 
      demands comment. It turns out that the unused built-in functions include a
      number of accessor functions for special types (defined for API
      completeness), some specialized functions that just happen not to be used
      in the applications in this code base (geospatial functions, for
      example), and the 
      constructor functions for some built-in types including some relatively
      uncommon types such as </textual><code class="po-atom e298 e298"><textual class="po-textual">xs:NOTATION</textual></code><textual class="po-textual">. Figure 
      </textual><xref class="po-milestone e299 e299" linkend="fig_unused_builtins"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> gives a rough break down.
      </textual></para><figure class="po-container e300 e300" xml:id="fig_unused_builtins"><table class="po-container e301 e301"><caption class="po-container e302 e302"><para class="po-block e303 e303"><textual class="po-textual">Characterization of the built-in functions unused in any
      module in the code base.</textual></para></caption><tr class="po-table e304 e304"><th class="po-field e305 e305"><textual class="po-textual">Group</textual></th><th class="po-field e306 e306"><textual class="po-textual">Percent</textual></th></tr><tr class="po-table e307 e307"><th align="left" class="po-field e308 e308"><textual class="po-textual">Accessors and constructors for special built-in types</textual></th><td class="po-block e309 e309"><textual class="po-textual">30.6</textual></td></tr><tr class="po-table e310 e310"><th align="left" class="po-field e311 e311"><textual class="po-textual">System management and operations</textual></th><td class="po-block e312 e312"><textual class="po-textual">16.3</textual></td></tr><tr class="po-table e313 e313"><th align="left" class="po-field e314 e314"><textual class="po-textual">Advanced specialized functions</textual></th><td class="po-block e315 e315"><textual class="po-textual">14.7</textual></td></tr><tr class="po-table e316 e316"><th align="left" class="po-field e317 e317"><textual class="po-textual">Assorted standard functions</textual></th><td class="po-block e318 e318"><textual class="po-textual">13.8</textual></td></tr><tr class="po-table e319 e319"><th align="left" class="po-field e320 e320"><textual class="po-textual">Mathematical functions</textual></th><td class="po-block e321 e321"><textual class="po-textual">9.5</textual></td></tr><tr class="po-table e322 e322"><th align="left" class="po-field e323 e323"><textual class="po-textual">Assorted standard XQuery functions</textual></th><td class="po-block e324 e324"><textual class="po-textual">6.4</textual></td></tr><tr class="po-table e325 e325"><th align="left" class="po-field e326 e326"><textual class="po-textual">Debugging/profiling</textual></th><td class="po-block e327 e327"><textual class="po-textual">5.4</textual></td></tr><tr class="po-table e328 e328"><th align="left" class="po-field e329 e329"><textual class="po-textual">In active development</textual></th><td class="po-block e330 e330"><textual class="po-textual">2.4</textual></td></tr></table></figure><para class="po-block e331 e331"><textual class="po-textual">The fact that certain specialized functions are not called 
      anywhere in the code base is not a problem, per se, but the fact that 
      out of an assortment of special built-in types of a particular class 
      (geospatial, for example) only a couple are not represented at all
      may warrant further investigation. It may be a sign of missing 
      functionality in higher level APIs.</textual></para><para class="po-block e332 e332"><textual class="po-textual">The situation with the unused module functions is better: all but
      one of the 
      unused functions have to do with features under active development or
      testing/debugging code. The remaining unused function, however, looks
      like it does represent a genuine oversight.</textual></para><section class="po-hcontainer e333 e333"><title class="po-block e334 e334"><textual class="po-textual">Function Scores</textual></title><para class="po-block e335 e335"><textual class="po-textual"> Again, since the function call distribution follows a classic
      Zipf distribution, it is not unreasonable to apply the probabilistic
document model on which TF-IDF scoring is based.
      </textual></para><figure class="po-container e336 e336" xml:id="fig_function_scores"><title class="po-block e337 e337"><textual class="po-textual">Function Scores</textual></title><programlisting class="po-block e338 e338" xml:space="preserve"><textual class="po-textual">
43.02 agui:navItem
42.49 admin:database-set-value
41.43 agui:navItemClosed
41.35 admin:gr-config
40.60 admin:database-get-value
39.75 agui:reindex-done
39.48 admin:db-config
38.99 admin:appserver-set-value
38.48 admin:appserver-get-value
38.04 aws:add-param
...
7.35 agui:buildHTTPServer2
7.35 converters:set-response-content-type
7.35 utils:distinct-values
7.35 conf-server:create-server
7.35 pipeline:xquery
7.35 agui:get-action
7.35 entity:call-calais
7.35 search-ast:do-parse
7.35 compile:build-zip
7.35 forest:get-default-rep
      </textual></programlisting><caption class="po-container e339 e339"><para class="po-block e340 e340"><textual class="po-textual">The scores for top 10 and bottom 10 functions are
shown, rounded to 2 decimal places. Function namespaces have been abbreviated
to prefixes.</textual></para></caption></figure><para class="po-block e341 e341"><textual class="po-textual">A look at the functions with the highest scores was encouraging:
      the number one 
      function, called </textual><code class="po-atom e342 e342"><textual class="po-textual">navItem</textual></code><textual class="po-textual">, is in a notorious part of the code
      that has been subject to much revision and bug fixes. The function with
      the third highest score was its companion function
      </textual><code class="po-atom e343 e343"><textual class="po-textual">navItemClosed</textual></code><textual class="po-textual">. Other functions in the top ten were
      service functions used within administrative API. These service
      functions are called from many places, but only from within that one
      module. However, that one module is very large. Document size
      normalization is a common modification to TF-IDF scoring. Perhaps a similar
      normalization here would be useful.
      Most of the top 50 functions are other service functions for
      other modules that have similar calling patterns. Are these good
      functions to focus extra testing effort on?  Perhaps. Directed testing of
      such functions is likely to expose important bugs, but
      probably normal API testing would have accomplished the same thing.
      The fact that only one or two modules uses these functions does increase
      the risk that fewer developers are calling them and therefore they are more
      likely to be making (possibly unwarranted) assumptions about how they
      will be used.
      </textual></para><para class="po-block e344 e344"><textual class="po-textual">At the other end of the
      scale, with very low scores, are widely used functions with names like
      </textual><code class="po-atom e345 e345"><textual class="po-textual">buildHTTPServer2</textual></code><textual class="po-textual"> (widely used throughout the Admin UI) and
      </textual><code class="po-atom e346 e346"><textual class="po-textual">do-parse</textual></code><textual class="po-textual"> (a key function for the search APIs) and rarely
      used functions such as </textual><code class="po-atom e347 e347"><textual class="po-textual">call-calais</textual></code><textual class="po-textual"> and
      </textual><code class="po-atom e348 e348"><textual class="po-textual">create-server</textual></code><textual class="po-textual">. Are these good functions to avoid expending
      extra testing effort on? Perhaps. Certainly the very widely used functions
      would have been exercised many times in many different contexts through normal
      API testing. The rare functions have demonstrably few interactions with the
      rest of the code, so presumably the risk of not expending a lot of effort on
      testing them is low.
      </textual></para><para class="po-block e349 e349"><textual class="po-textual">Quantifying the usefulness of this approach is difficult. Getting a
      concrete measure for the bugginess of a particular function is hard
      as bug reports are linked only weakly to particular files, much less
      individual functions within those files. Here we will take the number of
      source control revisions within the scope of a particular function as a
      measure of how likely it is to need fixing. This is obviously an
      imperfect measure, as source changes may reflect new functionality, or
      trivial formatting changes. It is also a manually intensive measure to
      obtain. The following graph shows statistics for functions that were used
      more than once in the corpus that were defined in
      the same module as the top scoring function.
      It is an admittedly very small data set.
      </textual></para><figure class="po-container e350 e350" xml:id="fig_delta_f_score_dist"><title class="po-block e351 e351"><textual class="po-textual">Revisions as a function of score</textual></title><mediaobject class="po-container e352 e352"><imageobject class="po-container e353 e353"><imagedata class="po-meta e354 e354" fileref="../../../vol10/graphics/Holstege01/Holstege01-006.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e355 e355"><para class="po-block e356 e356"><textual class="po-textual">The number of revisions made to functions as a function
      of score.</textual></para></caption></figure><para class="po-block e357 e357"><textual class="po-textual">The correlation of score to the numbers of revisions is positive,
      although not strong (</textual><code class="po-atom e358 e358"><textual class="po-textual">R</textual><superscript class="po-atom e359 e359"><textual class="po-textual">2</textual></superscript><textual class="po-textual">=0.3048</textual></code><textual class="po-textual">).
      There are other associations we might expect to have stronger or more
      meaningful correlations. For example, one might think that the number
      of revisions would correlate with the age of a function, so that older
      functions would tend to have more revisions associated with them. This
      seems to be the case. For this little data set, the number of revisions
      does have a stronger relationship to age, using a power
      function  (</textual><code class="po-atom e360 e360"><textual class="po-textual">R</textual><superscript class="po-atom e361 e361"><textual class="po-textual">2</textual></superscript><textual class="po-textual">=0.6777</textual></code><textual class="po-textual">),
      as shown in </textual><xref class="po-milestone e362 e362" linkend="fig_delta_f_age_power_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      </textual></para><figure class="po-container e363 e363" xml:id="fig_delta_f_age_power_dist"><title class="po-block e364 e364"><textual class="po-textual">Revisions as a function of age</textual></title><mediaobject class="po-container e365 e365"><imageobject class="po-container e366 e366"><imagedata class="po-meta e367 e367" fileref="../../../vol10/graphics/Holstege01/Holstege01-007.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">The number of revisions made to functions as a function of
      the age (minimum revision number) of the function. A power curve gives 
      the best fit.</textual></para></caption></figure><para class="po-block e370 e370"><textual class="po-textual">Similar relationships held for functions in the hand-generated data
      for a couple of other modules as well, with scores showing a weak direct
      relationship with </textual><code class="po-atom e371 e371"><textual class="po-textual">R</textual><superscript class="po-atom e372 e372"><textual class="po-textual">2</textual></superscript></code><textual class="po-textual"> values
      around </textual><code class="po-atom e373 e373"><textual class="po-textual">0.3</textual></code><textual class="po-textual"> and age showing an inverse relationship with 
      </textual><code class="po-atom e374 e374"><textual class="po-textual">R</textual><superscript class="po-atom e375 e375"><textual class="po-textual">2</textual></superscript></code><textual class="po-textual"> values about double that.
      </textual></para><para class="po-block e376 e376"><textual class="po-textual">
      However, neither of these correlations holds up well on a larger data set
      across modules, as you can see in 
      </textual><xref class="po-milestone e377 e377" linkend="fig_large_delta_f_score_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and 
      </textual><xref class="po-milestone e378 e378" linkend="fig_large_delta_f_age_dist"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. The best fit line in
      both cases has </textual><code class="po-atom e379 e379"><textual class="po-textual">R</textual><superscript class="po-atom e380 e380"><textual class="po-textual">2</textual></superscript></code><textual class="po-textual"> of essentially
      zero, virtually indistinguishable from the mean value line. The data 
      behind these numbers is much messier than the hand-generated set, as
      the automated detection of function boundaries is much more error-prone
      and tends to pull in large comment blocks and non-function declarations.
      Nevertheless, it is implausible to suggest that such factors
      overwhelm what would otherwise be an interesting correlation. A manual
      check of the statistics for a particular module from the automated
      data set showed only small deviations from the statistics from the
      manual procedure.
      </textual></para><figure class="po-container e381 e381" xml:id="fig_large_delta_f_score_dist"><title class="po-block e382 e382"><textual class="po-textual">Revisions as a function of score</textual></title><mediaobject class="po-container e383 e383"><imageobject class="po-container e384 e384"><imagedata class="po-meta e385 e385" fileref="../../../vol10/graphics/Holstege01/Holstege01-008.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e386 e386"><para class="po-block e387 e387"><textual class="po-textual">The number of revisions made to functions as a function of
      the score, using a larger but messier data set.</textual></para></caption></mediaobject></figure><figure class="po-container e388 e388" xml:id="fig_large_delta_f_age_dist"><title class="po-block e389 e389"><textual class="po-textual">Revisions as a function of age</textual></title><mediaobject class="po-container e390 e390"><imageobject class="po-container e391 e391"><imagedata class="po-meta e392 e392" fileref="../../../vol10/graphics/Holstege01/Holstege01-009.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e393 e393"><para class="po-block e394 e394"><textual class="po-textual">The number of revisions made to functions as a function of
      the age (minimum revision number), using a larger but messier data set.</textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e395 e395"><title class="po-block e396 e396"><textual class="po-textual">Techniques</textual></title><para class="po-block e397 e397"><textual class="po-textual">Some of the same introspective functions for computing
        the distribution of sequence types in modules were used to compute the
        distribution of function calls in modules. The key technique
        involved analyzing the structured dump of the module parse tree for
        function calls, using maps to store running totals, and using
        filesystem access functions to recursively find and process all modules
        in the code base.
        </textual></para><para class="po-block e398 e398"><textual class="po-textual">Computing the revisions within a particular function involved
        using the source control system's ability to produce the source code
        annotated with revision numbers. The resulting output was
        chopped up into individual functions manually, with a little help from
        Emacs keyboard macros. A shell script counted up the number of distinct
        revision numbers as well as the minimum revision number for the
        function using standard Unix tools such as </textual><code class="po-atom e399 e399"><textual class="po-textual">awk</textual></code><textual class="po-textual">,
        </textual><code class="po-atom e400 e400"><textual class="po-textual">sort</textual></code><textual class="po-textual">, </textual><code class="po-atom e401 e401"><textual class="po-textual">uniq</textual></code><textual class="po-textual">, </textual><code class="po-atom e402 e402"><textual class="po-textual">head</textual></code><textual class="po-textual">, and
        </textual><code class="po-atom e403 e403"><textual class="po-textual">wc</textual></code><textual class="po-textual">.
        </textual></para><para class="po-block e404 e404"><textual class="po-textual">The larger data set began with a file containing the annotated
        source files concatenated together. The XQuery function 
        </textual><code class="po-atom e405 e405"><textual class="po-textual">tokenize</textual></code><textual class="po-textual"> was used to chop up the file first into subfiles
        (by looking for the </textual><code class="po-atom e406 e406"><textual class="po-textual">xquery version</textual></code><textual class="po-textual"> declaration) and then into 
        functions (by looking for </textual><code class="po-atom e407 e407"><textual class="po-textual">declare function</textual></code><textual class="po-textual">, and finally into 
        individual lines of code, from which the revision number was obtained.
        Maps were used to collect minimum, maximum, and
        counts of revision number.</textual></para></section></section><section class="po-hcontainer e408 e408"><title class="po-block e409 e409"><textual class="po-textual">Summary and Conclusions</textual></title><para class="po-block e410 e410"><textual class="po-textual">XQuery introspection can be used to provide a fresh slant on a code
base, even a fairly large one. An analysis of unused schema components
(elements and types) proved largely uninteresting because stylistic
considerations for schema writing dominated actual usage requirements in the
APIs. The fact that certain extension types (in particular maps) were so common
suggests that there is a real need for providing such types as part of standard
XQuery. TF-IDF scores of sequence types did not produce any interesting
information.
    </textual></para><para class="po-block e411 e411"><textual class="po-textual">The analysis of function usage points in a different direction.
A look at unused functions can highlight some interesting problems, but the
most frequently used functions are mainly basic standard XQuery functions.
Looking at a combination of frequency of use and rarity across modules using
TF-IDF scoring can pinpoint some interesting functions that warrant more QA
attention. This is a qualitative judgement. Attempts to quantify the
correlation of score to quality failed, using the number of revisions applied
to the function as a proxy for quality. Relationships within one module at a
time hold up better, but are still weak.
    </textual></para><para class="po-block e412 e412"><textual class="po-textual">One common
modification to TF-IDF scoring is to normalize the TF values by the size of the
document. Since the high scoring functions included many that were only found in
a very large module, perhaps applying a similar normalization here would lead
to better results.
    </textual></para><para class="po-block e413 e413"><textual class="po-textual">To perform introspection of XQuery from within XQuery, a number of
extension functions are useful:
    </textual></para><variablelist class="po-table e414 e414"><varlistentry class="po-record e415 e415"><term class="po-block e416 e416"><textual class="po-textual">Function accessors</textual></term><listitem class="po-container e417 e417"><itemizedlist class="po-table e418 e418"><listitem class="po-container e419 e419"><para class="po-block e420 e420"><textual class="po-textual">list available functions as function items</textual></para></listitem><listitem class="po-container e421 e421"><para class="po-block e422 e422"><textual class="po-textual">return name of function item (XQuery 3.0 function-name)</textual></para></listitem><listitem class="po-container e423 e423"><para class="po-block e424 e424"><textual class="po-textual">return arity of function item (XQuery 3.0 function-arity)</textual></para></listitem><listitem class="po-container e425 e425"><para class="po-block e426 e426"><textual class="po-textual">return sequence type of return value of a function item</textual></para></listitem><listitem class="po-container e427 e427"><para class="po-block e428 e428"><textual class="po-textual">return sequence type of specific parameter of a function item</textual></para></listitem><listitem class="po-container e429 e429"><para class="po-block e430 e430"><textual class="po-textual">get type name from sequence type</textual></para></listitem></itemizedlist></listitem></varlistentry><varlistentry class="po-record e431 e431"><term class="po-block e432 e432"><textual class="po-textual">Type accessors</textual></term><listitem class="po-container e433 e433"><itemizedlist class="po-table e434 e434"><listitem class="po-container e435 e435"><para class="po-block e436 e436"><textual class="po-textual">list global element declarations for a particular schema</textual></para></listitem><listitem class="po-container e437 e437"><para class="po-block e438 e438"><textual class="po-textual">list named simple type definitions for a particular schema</textual></para></listitem><listitem class="po-container e439 e439"><para class="po-block e440 e440"><textual class="po-textual">list named complex type definitions for a particular schema</textual></para></listitem></itemizedlist></listitem></varlistentry><varlistentry class="po-record e441 e441"><term class="po-block e442 e442"><textual class="po-textual">Parse tree accessors</textual></term><listitem class="po-container e443 e443"><itemizedlist class="po-table e444 e444"><listitem class="po-container e445 e445"><para class="po-block e446 e446"><textual class="po-textual">return the parse tree for a particular module in structured form, preferably XQuery</textual></para></listitem></itemizedlist><para class="po-block e447 e447"><textual class="po-textual">OR:</textual></para><itemizedlist class="po-table e448 e448"><listitem class="po-container e449 e449"><para class="po-block e450 e450"><textual class="po-textual">list the functions declared in a particular module as function items</textual></para></listitem><listitem class="po-container e451 e451"><para class="po-block e452 e452"><textual class="po-textual">list the functions called in a particular module</textual></para></listitem></itemizedlist></listitem></varlistentry><varlistentry class="po-record e453 e453"><term class="po-block e454 e454"><textual class="po-textual">File system accessors</textual></term><listitem class="po-container e455 e455"><itemizedlist class="po-table e456 e456"><listitem class="po-container e457 e457"><para class="po-block e458 e458"><textual class="po-textual">list contents of a particular directory</textual></para></listitem><listitem class="po-container e459 e459"><para class="po-block e460 e460"><textual class="po-textual">determine whether a particular file is a directory</textual></para></listitem></itemizedlist></listitem></varlistentry><varlistentry class="po-record e461 e461"><term class="po-block e462 e462"><textual class="po-textual">Maps</textual></term><listitem class="po-container e463 e463"><para class="po-block e464 e464"><textual class="po-textual">Provide a convenient means of keeping running totals
keyed to function names, for example</textual></para></listitem></varlistentry></variablelist></section><bibliography class="po-hcontainer e465 e465"><title class="po-block e466 e466"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e467 e467" xml:id="mhsc" xreflabel="Holstege"><textual class="po-textual">
    Holstege, Mary. 
    </textual><emphasis class="po-inline e468 e468"><textual class="po-textual">Type Introspection in XQuery.</textual></emphasis><textual class="po-textual">
    Presented at Balisage: The Markup Conference 2012, MontrÃ©al, Canada, August
7 - 10, 2012. In Proceedings of Balisage: The Markup Conference 2012. Balisage
Series on Markup Technologies, vol. 8 (2012). </textual><link class="po-inline e469 e469" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Holstege01/BalisageVol8-Holstege01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol8/html/Holstege01/BalisageVol8-Holstege01.html</textual></link><textual class="po-textual">. doi:</textual><biblioid class="po-atom e470 doi e470"><textual class="po-textual">10.4242/BalisageVol8.Holstege01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e471 e471" xml:id="jones" xreflabel="Jones72"><textual class="po-textual">
     Jones, Karen.
     </textual><emphasis class="po-inline e472 e472"><textual class="po-textual">A statistical interpretation of term specificity and its
application in retrieval</textual></emphasis><textual class="po-textual">. Journal of Documentation 28 (1): 11â21. 
     </textual><link class="po-inline e473 e473" xlink:actuate="onRequest" xlink:href="http://www.soi.city.ac.uk/~ser/idfpapers/ksj_orig.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.soi.city.ac.uk/~ser/idfpapers/ksj_orig.pdf</textual></link><textual class="po-textual">. doi:</textual><biblioid class="po-atom e474 doi e474"><textual class="po-textual">10.1108/eb026526</textual></biblioid><textual class="po-textual">.
      1972.
    </textual></bibliomixed><bibliomixed class="po-block e475 e475" xml:id="xqfo30" xreflabel="F&amp;O30"><textual class="po-textual">
    W3C: Michael Kay, editor.
    </textual><emphasis class="po-inline e476 e476"><textual class="po-textual">XPath and XQuery Functions and Operators 3.0</textual></emphasis><textual class="po-textual">
    Candidate Recommendation. W3C, January 2013.
    </textual><link class="po-inline e477 e477" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-functions-30/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e478 e478" xml:id="xsd11dt" xreflabel="XSD11.2"><textual class="po-textual">
    W3C: David Peterson, Shudi (Sandy) Gao é«æ®é, Ashok Malhotra,
C.M. Sperberg-McQueen, and Henry S. Thompson, editors.  
    </textual><emphasis class="po-inline e479 e479"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes.</textual></emphasis><textual class="po-textual">
    W3C. April 2012.
    </textual><link class="po-inline e480 e480" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema11-2/</textual></link><textual class="po-textual">
	</textual></bibliomixed><bibliomixed class="po-block e481 e481" xml:id="xq30" xreflabel="XQuery30"><textual class="po-textual">
    W3C: Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, editors.
    </textual><emphasis class="po-inline e482 e482"><textual class="po-textual">XQuery 3.0: An XML Query Language</textual></emphasis><textual class="po-textual">
    Candidate Recommendation. W3C, January 2013.
    </textual><link class="po-inline e483 e483" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery-30/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e484 e484" xml:id="zipf" xreflabel="Zipf49"><textual class="po-textual">
     Zipf, George Kingsley.
     </textual><emphasis class="po-inline e485 e485"><textual class="po-textual">Human Behaviour and the Principles of Least Effort.</textual></emphasis><textual class="po-textual"> 
     Addison-Wesley, 1949.
    </textual></bibliomixed></bibliography></article></classedDocument>