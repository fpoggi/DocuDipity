<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Programming Application Logic for RESTful Services Using XML Technologies</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2011</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 2 - 5, 2011</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">XRX, XForms on the client, RESTful services and XQuery on the server, introduced a
                development paradigm that could avoid the use to procedural code in the
                implementation of RESTful services.  With the standardization of XProc, the XML
                pipelining language, and the availability of several XProc engines, we have an even
                more powerful mechanism for RESTful services construction. In this paper we briefly
                introduce an XML REST Framework that allows a developer to define resources and
                provide an XML-centric implementation.  Then the main focus of the paper is on how
                XQuery, XSLT and XProc together form a powerful set of tools with which RESTful
                services can be developed, effectively redifining XRX to stand for XForms, RESTful
                services and XProc on the server. We illustrate the benefits each technology brings
                to this service construction by incrementally building up a RESTful service for a
                patient medical records registry.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Cornelia</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Davis</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Cornelia Davis is a Senior Technologist in the Architecture group of the
                    Office of the CTO, focusing RESTful Service Oriented Architectures. Areas of
                    expertise include XML and Atom, and she frequent speaker on RESTful SOA.
                    Cornelia holds a B.S. and an M.S. in Computer Science from California State
                    University, Northridge.</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Senior Technologist</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">EMC Corporation</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">cornelia.davis@emc.com</textual></email></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Copyright © 2011 EMC Corporation.  All rights reserved.</textual></para></legalnotice><keywordset class="po-table e20 e20" role="author"><keyword class="po-field e21 e21"><textual class="po-textual">REST</textual></keyword><keyword class="po-field e22 e22"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">XProc</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">XSLT</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">XML Database</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">XRX</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">HATEOAS</textual></keyword></keywordset></info><section class="po-hcontainer e29 e29"><title class="po-block e30 e30"><textual class="po-textual">Introduction</textual></title><para class="po-block e31 e31"><textual class="po-textual">The term XRX </textual><xref class="po-milestone e32 e32" linkend="XRX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> , stands for XForms </textual><xref class="po-milestone e33 e33" linkend="XForms"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> on the client, RESTful services and XQuery </textual><xref class="po-milestone e34 e34" linkend="XQuery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
            on the server. At its core it is a design approach that uses XML as the model for the
            application entities, and other XML technologies, specifically XForms and XQuery, for
            the application UI and for interface to the persistence layer, respectively. At the
            extreme, XRX can be seen as a no-transformation approach, where resource representations
            accepted and served by RESTful services closely match the form stored in an XML
            database; that is, there is no difference between the logical model for entities and the
            physical one. While our work has been inspired by XRX, and we embrace the notion of
            XML-centric implementations, we have found that RESTful services require transformations
            and other sophisticated operations that are not particularly well suited to an XQuery
            implementation alone. </textual></para><para class="po-block e35 e35"><textual class="po-textual">First, RESTful services must serve resource representations that are hyperlink rich,
            containing links to related resources as well as to URLs that can drive application
            state.  These links are generated only when the resource representation is served and
            they reflect runtime and deployment contexts such as host names.  As such, these links
            must be added to the content that is retrieved from the XML database, and while XQuery
            is clearly the right technology for database access, it is, at best, awkward when used
            to insert these hyperlinks.  </textual></para><para class="po-block e36 e36"><textual class="po-textual">Another key tenet of the REST architectural style is content negotiation, the ability
            for a service to accommodate various formats for the data they serve.  For example, a
            resource representation may be served in some simple XML format (that may indeed closely
            resemble that which is stored in the database), and it may alternatively serve an Atom </textual><xref class="po-milestone e37 e37" linkend="Atom"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
            entry.  Those well versed in the XML-technology stack would likely agree that this is a
            task ideally suited to XSLT </textual><xref class="po-milestone e38 e38" linkend="XSLT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e39 e39"><textual class="po-textual">When we begin to address the implementation details of our RESTful services we see
            common patterns, such as the need to assign identifiers to new resources and the need to
            return from the service values beyond the resource representation.  We have found it
            rather easy to implement these patterns using XProc </textual><xref class="po-milestone e40 e40" linkend="XProc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.  </textual></para><para class="po-block e41 e41"><textual class="po-textual">It is these RESTful services requirements that have driven us to an interpretation of
            XRX that stands for XForms on the client, RESTful services and XProc on the server.  Our
            work has focused on the RESTful services implementation with little attention given to
            the XForms or other consumer-side user interface. </textual></para><para class="po-block e42 e42"><textual class="po-textual">In this paper we will show the value that various XML technologies bring to the
            implementation of RESTful services, with a focus on XProc, XQuery and XSLT.  We will
            demonstrate each of their strengths by incrementally building up a simple service
            implementation that is a part of a larger set of services that implement a patient
            medical records registry.  This implementation was taken to the IHE Connectathon </textual><xref class="po-milestone e43 e43" linkend="IHEConnect"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> event in January 2011 where EMC received certification.  That
            is, the use case presented in this paper is real.  </textual></para><para class="po-block e44 e44"><textual class="po-textual">After briefly introducing the IHE XDS </textual><xref class="po-milestone e45 e45" linkend="IHEXDS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">  registry usecase,
            outlining the key principles of REST and also briefly introducing an XML REST Framework
            we have constructed, we spend the bulk of the remainder of the paper squarely in the XML
            space.  We begin by establishing the base implementation which uses XQuery to write
            resource data to the persistence layer, an XML database.  We then address the hyperlink
            constraint of RESTful services with the construction of an XSLT and build a simple XProc
            pipeline to sequence these operations.  This solution does not yet address the
            generation of identifiers or construction of data elements beyond the resource
            representation, which we then add.  Finally we bind all of the pieces together within
            Spring Framework </textual><xref class="po-milestone e46 e46" linkend="Spring"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> configurations.</textual></para><para class="po-block e47 e47"><textual class="po-textual">While we have found some prior work on XML-centric application development </textual><xref class="po-milestone e48 e48" linkend="Wilde"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, we have found little that addresses how the XML technology stack
            addresses the unique needs of RESTful service construction.  This is the focus of this
            piece. </textual></para></section><section class="po-hcontainer e49 e49"><title class="po-block e50 e50"><textual class="po-textual">Integrated Health Exchange</textual></title><para class="po-block e51 e51"><textual class="po-textual">Integrating the Healthcare Enterprise (IHE) </textual><xref class="po-milestone e52 e52" linkend="IHE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is a consortium that
            develops interoperability standards for health care delivery systems.  They publish
            specifications that address how a wide range of devices and systems should communicate,
            allowing them to be easily connected in a variety of settings. It is in one of these
            specifications that they define interfaces that medical records registries and
            repositories must provide in order to be easily connected to document suppliers and
            consumers. A Cross-Enterprise Document Sharing (XDS) repository stores documents that
            make up a patient medical record including such things as images (e.g. x-rays, CT
            scans), text files (e.g. doctors notes) and documents of any other format. An XDS
            registry augments this content both by associating metadata with the documents stored in
            the repository and by establishing additional organizational structures, such as folder
            hierarchies, around that content. The solution we describe in this paper is a portion of
            the document registry implementation which earned EMC a certification at the IHE
            Connectathon event in January 2011.</textual></para><para class="po-block e53 e53"><textual class="po-textual">The abstractions defined by the IHE for an XDS registry include the
            following:</textual></para><itemizedlist class="po-table e54 e54"><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">A </textual><emphasis class="po-inline e57 e57" role="ital"><textual class="po-textual">document entry</textual></emphasis><textual class="po-textual"> holds metadata for a
                    single document.</textual></para></listitem><listitem class="po-container e58 e58"><para class="po-block e59 e59"><textual class="po-textual">A </textual><emphasis class="po-inline e60 e60" role="ital"><textual class="po-textual">folder</textual></emphasis><textual class="po-textual"> is a container that may hold
                    multiple document entries.</textual></para></listitem><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">An </textual><emphasis class="po-inline e63 e63" role="ital"><textual class="po-textual">association</textual></emphasis><textual class="po-textual"> captures a binary,
                    unidirectional relationship between document entries, folders, submission sets
                    and other associations.</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">A </textual><emphasis class="po-inline e66 e66" role="ital"><textual class="po-textual">submission set</textual></emphasis><textual class="po-textual"> represents a
                    collection of document entries, folders and associations that together form a
                    set that, when written to the registry, must be handled atomically.</textual></para></listitem></itemizedlist><para class="po-block e67 e67"><textual class="po-textual">While submission sets are written as a whole, the individual parts of a submission
            set may be consumed in different combinations.  For example, within a single submission
            set, a folder may have been created and a document entry placed therein, however, the
            document entry may be accessed independently or even in combination with other document
            entries that arrived in different submission sets.  </textual></para><para class="po-block e68 e68"><textual class="po-textual">It is the atomicity requirements on the writing of submission sets, and the
            granular consumption model, that contribute to making the XDS registry RESTful services
            an interesting case-study.  We will examine the implementation of the service for
            creating submission sets in detail in the subsequent sections of this paper.  This is
            relatively complex operation that may involve the assignment of identifiers,
            necessitates validation of some of the input XML against both other portions of the
            submission set as well as to content already existing in the database, and requires that
            the submission set be decomposed for storage in the database.</textual></para></section><section class="po-hcontainer e69 e69"><title class="po-block e70 e70"><textual class="po-textual">The REST Architectural Style</textual></title><para class="po-block e71 e71"><textual class="po-textual">Roy Fielding was one of a group of individuals who developed the architecture of the
            World Wide Web and in 2000 he formalized the key architectural principles in his PhD
            dissertation </textual><xref class="po-milestone e72 e72" linkend="REST"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, coining the term REpresentational State Transfer
            (REST). The REST architectural style is characterized by the following four key
            tenets:</textual></para><itemizedlist class="po-table e73 e73"><listitem class="po-container e74 e74"><para class="po-block e75 e75"><emphasis class="po-inline e76 e76" role="bold"><textual class="po-textual">Identification and addressability of
                        resources</textual></emphasis><textual class="po-textual">: All interesting bits of information are identified
                    with URIs and are usually accessed via URL.</textual></para></listitem><listitem class="po-container e77 e77"><para class="po-block e78 e78"><emphasis class="po-inline e79 e79" role="bold"><textual class="po-textual">The uniform interface</textual></emphasis><textual class="po-textual">: Interaction with
                    resources is through a standardized set of operations, with well understood and
                    agreed upon semantics.</textual></para></listitem><listitem class="po-container e80 e80"><para class="po-block e81 e81"><emphasis class="po-inline e82 e82" role="bold"><textual class="po-textual">Manipulation of resources through
                        representations</textual></emphasis><textual class="po-textual">: Clients are not operating directly on resources,
                    rather resource representations are transfered between the server and the
                    client.</textual></para></listitem><listitem class="po-container e83 e83"><para class="po-block e84 e84"><emphasis class="po-inline e85 e85" role="bold"><textual class="po-textual">Hypermedia constraint</textual></emphasis><textual class="po-textual">: Resource
                    representations include hyperlinks that can be used to drive application state
                    transitions.</textual></para></listitem></itemizedlist><para class="po-block e86 e86"><textual class="po-textual">Each of these principles has played an important role in the success of the World Wide
            Web. Resource centricity and the hierarchical, global address space of URLs provides for
            limitless scale by allowing resources to be continually added to the domain of discourse
            while maintaining linear scale through the use of DNS and a cache-rich infrastructure.
            Having a uniform interface allows the layered web to perform optimizations as a part of
            a resource operation. For example, because the HTTP PUT operation is idempotent (meaning
            it can be executed 1 or more times with the same result), an actor in the web
            infrastructure may perform automatic retries on PUT operations that </textual><emphasis class="po-inline e87 e87" role="under"><textual class="po-textual">may</textual></emphasis><textual class="po-textual"> have failed to complete. The transfer of resource
            representations between the client and server allows those interactions to be entirely
            stateless, further providing scale-out characteristics. And having hyperlink-rich
            resource representations not only provides a means for relationships between resources
            to be presented, it also supports the construction of less-brittle interfaces and looser
            coupling between clients and servers.</textual></para></section><section class="po-hcontainer e88 e88"><title class="po-block e89 e89"><textual class="po-textual">The XML REST Framework</textual></title><para class="po-block e90 e90"><textual class="po-textual">We have produced a framework that allows a developer to create a set of RESTful
            services with most of the implementation achieved using XML-based technologies. We have
            found these technologies to be very effective at addressing many requirements specific
            to RESTful services. XQuery is used to persist resource state into an XML database.
            Content negotiation is straight-forward via the declarative, XSLT programming model, and
            resource hyperlinks are generated using the same declarative approach. Common patterns
            for resource operations are effectively captured in XProc pipelines and processing of
            composite resources is also well accomplished using this XML pipelining approach. </textual></para><para class="po-block e91 e91"><textual class="po-textual">The only portion of the implementation not done with an XML-based technology is the
            interface to the RESTful service. Here we have elected to use Plain Old Java Objects
            (POJOs), annotated with information about resource URLs and the uniform interface. We
            chose to keep this part of a RESTful service implementation in Java primarily for two
            reasons. First, while there is a technology, Servlex </textual><xref class="po-milestone e92 e92" linkend="Servlex"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, that
            does provide a capability for producing web applications with only XML technologies, we
            were concerned that the uptake of the EXPath Webapp </textual><xref class="po-milestone e93 e93" linkend="XPWebapp"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> approach
            has been slow and the community activity is marginal. And more importantly, having
            RESTful services executing within an environment such as the Spring Framework allows
            additional services (such as security) to be wrapped around the core RESTful services we
            implement; it was unclear how the Servlex technology could be leveraged within
            Spring.</textual></para><para class="po-block e94 e94"><textual class="po-textual">Figure 1 depicts the basic construction of RESTful services using our
            framework.</textual></para><figure class="po-container e95 e95" xml:id="fig1"><mediaobject class="po-container e96 e96"><imageobject class="po-container e97 e97"><imagedata class="po-meta e98 e98" fileref="../../../vol7/graphics/Davis01/Davis01-001.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">XML-Centric Services Implementation</textual></para></caption></figure><para class="po-block e101 e101"><textual class="po-textual"> In the next sections I cover each of the blocks shown in this figure.</textual></para></section><section class="po-hcontainer e102 e102"><title class="po-block e103 e103"><textual class="po-textual">The RESTful Service Interface</textual></title><para class="po-block e104 e104"><textual class="po-textual">Because we are specifically addressing RESTful services implementations, we must
            address more than just the construction and delivery of XML data.  In particular, we
            must be able to accept HTTP requests </textual><footnote class="po-popup e105 e105" xml:id="http1"><para class="po-block e106 e106"><textual class="po-textual">Note that while REST is an architectural style that does not require HTTP, in
                    practice most RESTful services are offered over HTTP and we will focus on those
                    here.</textual></para></footnote><textual class="po-textual"> , parse URLs, read and write headers and return errors appropriately. 
            Because several frameworks addressing these HTTP-specific needs, such as Spring MVC
                </textual><xref class="po-milestone e107 e107" linkend="MVC"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Apache CXF </textual><xref class="po-milestone e108 e108" linkend="CXF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and Jersey </textual><xref class="po-milestone e109 e109" linkend="Jersey"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, are already in widespread use, we embrace those and offer an
            extended framework that allows an XML-centric implementation to be wired in.  These
            RESTful services frameworks share common development paradigms where REST resources are
            implemented as Java classes, operations on the resource are implemented with class
            methods, and annotations are used to express RESTful service specifics such as URI
            templates and uniform interface operations.  The following code snippet shows the
            skeleton Java class for the submission sets resource, with a method that will fulfill
            the POST operation; this is the operation we will use to create new submission sets.
            </textual><programlisting class="po-block e110 e110" xml:space="preserve"><textual class="po-textual">package com.emc.cto.healthcare;
            
    // … imports omitted for brevity
            
    @Controller
    @RequestMapping("/submissionsets")
    public class SubmissionSets {
            
    @RequestMapping(method = RequestMethod.POST)
    @ResponseStatus(HttpStatus.CREATED)
    public String addPatient(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Model model) throws XProcException, IOException, URISyntaxException, TransformerException {
            
        …
            
    }
            
    public SubmissionSets() {		
    }
            
}</textual></programlisting><textual class="po-textual">
        </textual></para><para class="po-block e111 e111"><textual class="po-textual">It is within this method that we will invoke the XML-based services implementation. 
            In a later section we will see exactly how the XProc pipeline, which forms the core of
            the implementation, is bound into this service dispatcher class.</textual></para></section><section class="po-hcontainer e112 e112"><title class="po-block e113 e113"><textual class="po-textual">Starting with XQuery</textual></title><para class="po-block e114 e114"><textual class="po-textual"> XQuery serves the role of interfacing with the solution’s persistence layer, the XML
            database.  Each resource operation of the RESTful service will require one or more
            XQueries to map the logical to the physical model.  Figure 2 shows a table representing
            the logical model at left, a pictorial view of the physical database model on the right
            and shading that indicates how the logical resources are mapped to physical ones.</textual></para><figure class="po-container e115 e115" xml:id="fig2"><mediaobject class="po-container e116 e116"><imageobject class="po-container e117 e117"><imagedata class="po-meta e118 e118" fileref="../../../vol7/graphics/Davis01/Davis01-002.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">Logical to Physical Mapping</textual></para></caption></figure><para class="po-block e121 e121"><textual class="po-textual">The darker shaded objects in the tree structure represent folders and the lighter
            shaded objects represent XML documents.  The yellow and blue shadings show a
            correspondence between entities in the logical model and the physical model. Note that
            the submission set resource maps to many entities in the physical model, whereas
            document entry resource mappings are far more constrained.</textual></para><para class="po-block e122 e122"><textual class="po-textual">For this first stage of the implementation we will assume that the submission set
            coming in is entirely valid and has identifiers properly set for each of the elements
            within it.  The following shows an excerpt of the resource representation supplied to a
            POST operation.
        </textual><programlisting class="po-block e123 e123" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CompoundSubmissionSet&gt;
    &lt;SubmissionSet&gt;
        &lt;comments&gt;
            &lt;lang&gt;en-US&lt;/lang&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
            &lt;value&gt;Annual physical&lt;/value&gt;
        &lt;/comments&gt;
        &lt;entryUuid&gt;0324990a-00a4-4b3f-be6d-0a98267d1d28&lt;/entryUuid&gt;
        &lt;patientId&gt;
            &lt;id&gt;RED7020&lt;/id&gt;
            &lt;assigningAuthority&gt;
                &lt;universalId&gt;1.3.6.1.4.1.21367.13.20.1000&lt;/universalId&gt;
                &lt;universalIdType&gt;ISO&lt;/universalIdType&gt;
            &lt;/assigningAuthority&gt;
        &lt;/patientId&gt;
        &lt;title&gt;
            &lt;lang&gt;en-US&lt;/lang&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
            &lt;value&gt;Physical&lt;/value&gt;
        &lt;/title&gt;
        ... additional submission set fields
    &lt;/SubmissionSet&gt;
    &lt;folders /&gt;
    &lt;documentEntries&gt;
        &lt;DocumentEntry&gt;
            &lt;entryUuid&gt;788ccf31-f9fe-409a-91c4-8983e1c8ae14&lt;/entryUuid&gt;
            &lt;patientId&gt;
                &lt;id&gt;RED7020&lt;/id&gt;
                &lt;assigningAuthority&gt;
                    &lt;universalId&gt;1.3.6.1.4.1.21367.13.20.1000&lt;/universalId&gt;
                    &lt;universalIdType&gt;ISO&lt;/universalIdType&gt;
                &lt;/assigningAuthority&gt;
            &lt;/patientId&gt;
            &lt;title&gt;
                &lt;lang&gt;en-US&lt;/lang&gt;
                &lt;charset&gt;UTF-8&lt;/charset&gt;
                &lt;value&gt;Physical&lt;/value&gt;
            &lt;/title&gt;
            ... additional document entry fields
        &lt;/DocumentEntry&gt;
    &lt;/documentEntries&gt;
    &lt;associations&gt;
        &lt;Association&gt;
            &lt;targetUuid&gt;788ccf31-f9fe-409a-91c4-8983e1c8ae14&lt;/targetUuid&gt;
            &lt;sourceUuid&gt;0324990a-00a4-4b3f-be6d-0a98267d1d28&lt;/sourceUuid&gt;
            &lt;associationType&gt;HAS_MEMBER&lt;/associationType&gt;
            &lt;label&gt;ORIGINAL&lt;/label&gt;
            &lt;entryUuid&gt;cb297ac4-22f7-4303-81f5-76bb0befd8cc&lt;/entryUuid&gt;
        &lt;/Association&gt;
    &lt;/associations&gt;
&lt;/CompoundSubmissionSet&gt;
        </textual></programlisting></para><para class="po-block e124 e124"><textual class="po-textual">In the XQuery, then, we fundamentally do two things: we split this larger XML document
            into several smaller ones and write each of those to the database. The following XQuery
            code shows this implementation.
            </textual><programlisting class="po-block e125 e125" xml:space="preserve"><textual class="po-textual">declare variable $input external;

declare updating function local:storeSubmissionset($elem as element()) {
    let $docFileName := concat("/SubmissionSets/", data($elem/entryUuid), ".xml")
    return if (doc-available($docFileName))
           then replace node doc($docFileName)/SubmissionSet with $elem
           else xhive:insert-document($docFileName, document{$elem})
};

declare updating function local:updateTime($folder as element()) {
        let $time := replace(substring-before(xs:string(adjust-dateTime-to-timezone(current-dateTime(),xs:dayTimeDuration("-PT0H"))),"."), "[-:T]", "")
        return &lt;Folder&gt;{$folder/*[name() != "lastUpdateTime"]} &lt;lastUpdateTime&gt;{$time}&lt;/lastUpdateTime&gt;&lt;/Folder&gt;
};
declare updating function local:storeFolders($elem as element()) {
        for $folderRaw in $elem/Folder
                                    let $folder := local:updateTime($folderRaw)
        let $docFileName := concat("/Folders/", data($folder/entryUuid), ".xml")        
        return if (doc-available($docFileName))
                 then replace node doc($docFileName)/Folder with $folder
                else xhive:insert-document($docFileName, document{$folder})
};

declare updating function local:storeDocEntries($elem as element(), $assocs as element()) {
        for $entry in $elem/DocumentEntry
        let $entryUuid := normalize-space(data($entry/entryUuid))
        let $docFileName := concat("/DocumentEntries/", $entryUuid, ".xml")
        let $assoc := $assocs/Association[sourceUuid = $entryUuid and (associationType='TRANSFORM_AND_REPLACE' or associationType='REPLACE') ]
        let $oldDocUuid := normalize-space(data($assoc/targetUuid))
        return  if (doc-available($docFileName))
               then replace node doc($docFileName)/DocumentEntry with $entry
               else (
                      xhive:insert-document($docFileName, document{$entry}),
                      if ($oldDocUuid) 
                      then
                            replace value of node doc("DocumentEntries")/DocumentEntry[entryUuid=$oldDocUuid]/availabilityStatus
                            with "DEPRECATED"
                         else ())
};

declare updating function local:storeAssociations($elem as element()) {
        let $time := replace(substring-before(xs:string(adjust-dateTime-to-timezone(current-dateTime(),xs:dayTimeDuration("-PT0H"))),"."), "[-:T]", "")
        let $res := for $association in $elem/Association
        let $docFileName := concat("/Associations/", data($association/entryUuid), ".xml")
        let $sourceFileName := concat(normalize-space(data($association/sourceUuid)),".xml")
        return (if (doc-available($docFileName))
               then replace node doc($docFileName)/Association with $association
               else xhive:insert-document($docFileName, document{$association}),
               (: if new doc placed into existing folder, update the lastUpdateTime of that folder :)
               if (doc-available(concat("/Folders/", $sourceFileName)))
               then replace value of node doc(concat("/Folders/", $sourceFileName))/Folder/lastUpdateTime with $time
               else (),
               (: if the new doc replaces another we need to create an assoc between the new doc and all of the folders
                  that the orignal doc is in :)
               if ($association/associationType = "REPLACE")
               then local:addAssocsForReplacementDocToFolders($association)
               else ()
               )
return $res
};

declare updating function local:addAssocsForReplacementDocToFolders($association as element()) {
    let $orgDocUuid := normalize-space(data($association/targetUuid))
    let $newDocUuid := normalize-space(data($association/sourceUuid))
    let $newAssocs := for $assoc in doc("Associations")/Association[targetUuid=$orgDocUuid and associationType = "HAS_MEMBER"]
                          let $folder := doc("Folders")/Folder[entryUuid=$assoc/sourceUuid]
                          let $newAssoc := if ($folder)
                               then &lt;Association&gt;&lt;targetUuid&gt;{$newDocUuid}&lt;/targetUuid&gt;
                               &lt;sourceUuid&gt;{normalize-space(data($folder/entryUuid))}&lt;/sourceUuid&gt;
                               &lt;associationType&gt;HAS_MEMBER&lt;/associationType&gt;
                               &lt;entryUuid&gt;{xs:string(uuid:random-uuid())}&lt;/entryUuid&gt;&lt;/Association&gt;
                               else ()
                       return $newAssoc
return local:storeAssociations(&lt;associations&gt;{$newAssocs}&lt;/associations&gt;)
};

let $compoundsubmissionset := if (not(empty(.)))
              then .
              else xhive:parse($input)
return (local:storeSubmissionset($compoundsubmissionset/CompoundSubmissionSet/SubmissionSet),
        local:storeFolders($compoundsubmissionset/CompoundSubmissionSet/folders),
        local:storeDocEntries($compoundsubmissionset/CompoundSubmissionSet/documentEntries,$compoundsubmissionset/CompoundSubmissionSet/associations),
        local:storeAssociations($compoundsubmissionset/CompoundSubmissionSet/associations), 
        $compoundsubmissionset/CompoundSubmissionSet)</textual></programlisting></para><para class="po-block e126 e126"><textual class="po-textual">This implementation is relatively crisp and XQuery serves the needs rather well,
            however there are RESTful service requirements that this implementation has not yet
            met.</textual></para><para class="po-block e127 e127"><textual class="po-textual">Notice that the XQuery responds with XML that represents the resource that has been
            newly created.  This forms the basis of the resource representation that will be
            returned by the RESTful service, however, it is not yet complete.  The hypermedia
            constraint in RESTful services </textual><xref class="po-milestone e128 e128" linkend="Hypermedia"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> requires that resource
            representations contain hyperlinks to other resources, as well as hyperlinks that can
            otherwise drive the state of the application.  In the case of a submission set, for
            example, the representation should contain links to the documents and folders comprising
            it. </textual></para><para class="po-block e129 e129"><textual class="po-textual">While it is possible to achieve this augmentation of the XML using XQuery, we prefer
            XSLT for two primary reasons. First, implementations of RESTful services using the
            approaches described in this piece, follow a Model-View-Controller pattern and we
            intentionally have the XML returned from the XQuery represent the application model
            objects. The hyperlinks presented in a resource representation are the responsibility of
            the controller portion of the implementation, so having hyperlinks inserted as a part of
            the XQuery that interacts with the database would conflate the responsibilities of the
            model and the controller. Of course, a separate XQuery could be used for hyperlink
            insertion, yet this brings us to the second reason for a different choice, and that is
            simply that we prefer the declarative approach that XSLT affords.</textual></para></section><section class="po-hcontainer e130 e130"><title class="po-block e131 e131"><textual class="po-textual">XSLT</textual></title><para class="po-block e132 e132"><textual class="po-textual">Inserting hyperlinks into an XML document involves two things; one must define the
                points of insertion and then express what is to be inserted, and the
            &lt;xsl:template&gt; is ideally suited to the task.  Our XML REST Framework aims to make
            this task easy, even for the non-XSLT expert, by providing a simple XSLT template that
            traverses the document tree seeking those points of insertion, and by providing samples
            of the &lt;xsl:template&gt; definitions that insert links.</textual></para><para class="po-block e133 e133"><textual class="po-textual">The following code snippet shows the simple recursive template that simply copies
                each of the source nodes into the result tree and applies a template with an
                “insert-here” mode at each element node.
            </textual><programlisting class="po-block e134 e134" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xdt="http://www.w3.org/2005/xpath-datatypes"
    xmlns:pat="http://www.emc.com/cto/PMR" xmlns:atom="http://www.w3.org/2005/Atom"&gt;
    &lt;xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes" /&gt;

    &lt;!-- 
        The templates in this xslt simply traverse the input XML and for each element apply any insertion templates 
        that are defined for the particular type of object
     --&gt;

    &lt;xsl:template match="*"&gt;
        &lt;xsl:copy&gt;
            &lt;!-- bring all attributes over --&gt;
            &lt;xsl:apply-templates select="@*" /&gt;
            &lt;!-- insert any hyperlinks --&gt;
            &lt;xsl:apply-templates select="." mode="inserthere" /&gt;
            &lt;xsl:apply-templates select="node()" /&gt;
        &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="@*"&gt;
        &lt;xsl:copy /&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="text()" mode="inserthere" /&gt;

&lt;/xsl:stylesheet&gt;</textual></programlisting></para><para class="po-block e135 e135"><textual class="po-textual">The RESTful services developer then need only define the </textual><code class="po-atom e136 e136"><textual class="po-textual">&lt;xsl:template&gt;</textual></code><textual class="po-textual"> definitions for the elements that 
            should have child link nodes inserted.  The following stylesheet inserts hyperlinks into the submission 
            set resource representation that is returned from the creation (POST) operation.</textual><programlisting class="po-block e137 e137" xml:space="preserve"><textual class="po-textual">&lt;xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xdt="http://www.w3.org/2005/xpath-datatypes"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:functx="http://www.functx.com" exclude-result-prefixes="xs xsl fn xdt functx"&gt;
    &lt;xsl:import href="classpath:insertHyperlinks.xslt" /&gt;
    &lt;xsl:import href="classpath:utils.xslt" /&gt;
    &lt;xsl:output method="xml" version="1.0" encoding="UTF-8"    indent="yes" /&gt;

    &lt;xsl:param name="baseURL" /&gt;
    
    &lt;!--
        This XSLT defines insertion templates that will be driven by the
        imported stylesheet
    --&gt;

    &lt;xsl:template match="SubmissionSet" mode="inserthere"&gt;
        &lt;atom:link rel="self"&gt;
            &lt;xsl:attribute name="href"&gt;&lt;xsl:value-of
                select="concat($baseURL,'/',entryUuid)" /&gt;&lt;/xsl:attribute&gt;
        &lt;/atom:link&gt;
        &lt;xsl:apply-templates select="/CompoundSubmissionSet/documentEntries/DocumentEntry" mode="inserthere" /&gt;
        &lt;xsl:apply-templates select="/CompoundSubmissionSet/folders/Folder" mode="inserthere" /&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="DocumentEntry" mode="inserthere"&gt;
        &lt;atom:link rel="document"&gt;
            &lt;xsl:attribute name="href"&gt;&lt;xsl:value-of
                select="concat(functx:substring-before-last($baseURL,'/'),'/documents/',entryUuid)" /&gt;&lt;/xsl:attribute&gt;
        &lt;/atom:link&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="Folder" mode="inserthere"&gt;
        &lt;atom:link rel="folder"&gt;
            &lt;xsl:attribute name="href"&gt;&lt;xsl:value-of
                select="concat(functx:substring-before-last($baseURL,'/'),'/folders/',entryUuid)" /&gt;&lt;/xsl:attribute&gt;
        &lt;/atom:link&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="CompoundSubmissionSet"&gt;
        &lt;xsl:apply-templates select="SubmissionSet"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="folders"/&gt;
    &lt;xsl:template match="documentEntries"/&gt;
    &lt;xsl:template match="associations"/&gt;
    
&lt;/xsl:stylesheet&gt;</textual></programlisting><textual class="po-textual">
        </textual></para><para class="po-block e138 e138"><textual class="po-textual">Another type of translation that is often needed for RESTful services provides support
            for additional media types.  In general, the media type for the content returned from an
            XQuery will be application/xml or text/xml, and this may be directly returned by the
            RESTful service. Other XML formats, such as application/atom+xml, are also in widespread
            use and therefore a RESTful services framework that makes it easy to perform such a
            transformation is valuable.  Just as with the insertion of hyperlinks, such
            transformations are well executed with an XSLT stylesheet.  Note that JSON is gaining
            popularity as a media type for resource representations.  Our recommendation is to keep
            the application model entities in XML and perform the transformation to JSON, again, via
            XSLT transformation, at the outer edge of that implementation.</textual></para><para class="po-block e139 e139"><textual class="po-textual">At this point we have seen the value in XQuery to interface with the underlying XML
            database, and XSLT for the insertion of hyperlinks and support for alternate media
            types.  The next question to answer, then, is how to tie these two things
            together.</textual></para></section><section class="po-hcontainer e140 e140"><title class="po-block e141 e141"><textual class="po-textual">XProc – the XML Pipelining Language</textual></title><para class="po-block e142 e142"><textual class="po-textual">In May 2010 the XML Processing Model Working Group of the World Wide Web
            Consortium standardized XProc, an XML Pipelining language.  XProc is a high-level
            programming language in which XML processing steps are wired together in such a way that
            the outputs of one step are routed to the inputs of another step; all content flowing
            between steps is XML.  An XProc Engine executes a pipeline, accepting external inputs
            and producing zero or more outputs. The XProc language includes several dozen processing
            steps that when used together allow for sophisticated capabilities to be implemented
            with very few lines of code.</textual></para><para class="po-block e143 e143"><textual class="po-textual">Before looking at some of these more complex examples, let us first look at a very
                simple pipeline that ties together the two solution components we previously
                discussed – the XQuery for database access and the XSLT for hyperlink insertion. 
                Figure 3 shows a pictorial representation of this pipeline.  </textual></para><figure class="po-container e144 e144" xml:id="fig3"><mediaobject class="po-container e145 e145"><imageobject class="po-container e146 e146"><imagedata class="po-meta e147 e147" fileref="../../../vol7/graphics/Davis01/Davis01-003.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">Base Resource-creation Pipeline</textual></para></caption></figure><para class="po-block e150 e150"><textual class="po-textual">In this case where we are creating a submission set, the source document passed into
            the pipeline is the submission set representation.  A second input to the pipeline is
            the base URL, a parameter that reflects the deployment particulars of the service (such
            as hostname), is used in the later XSLT step.  The source document is passed into the
            XQuery, which, as we saw above, splits the input document and writes several XML
            documents to the XML database; the XQuery step produces an XML document as the
            response.  The XSLT step then accepts the result from the XQuery, as well as the base
            URL that was passed into the pipeline, and generates a hyperlink rich XML document on
            the output.</textual></para><section class="po-hcontainer e151 e151"><title class="po-block e152 e152"><textual class="po-textual">Getting More Sophisticated</textual></title><para class="po-block e153 e153"><textual class="po-textual">Recall that earlier we made some simplifying assumptions; one being that the XML
                document supplied to the XQuery would be valid, including having identifiers already
                assigned to the various portions of the submission set. While the IHE specifications
                do require that all recorded document entries, folders, submission sets and
                associations have UUIDs assigned, they allow for a case where the registry receives
                a submission set containing only locally scoped identifiers (within the submission
                set). In this case, the registry implementation responsible for assigning UUIDs. The
                following shows and example of such a resource
                representation.</textual><programlisting class="po-block e154 e154" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CompoundSubmissionSet&gt;
    &lt;SubmissionSet&gt;
        &lt;comments&gt;
            &lt;lang&gt;en-US&lt;/lang&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
            &lt;value&gt;Annual physical&lt;/value&gt;
        &lt;/comments&gt;
        &lt;entryUuid&gt;SubmissionSet01&lt;/entryUuid&gt;
        ... additional submission set fields
    &lt;/SubmissionSet&gt;
    &lt;folders /&gt;
    &lt;documentEntries&gt;
        &lt;DocumentEntry&gt;
            &lt;entryUuid&gt;Document01&lt;/entryUuid&gt;
            ... additional document entry fields
        &lt;/DocumentEntry&gt;
    &lt;/documentEntries&gt;
    &lt;associations&gt;
        &lt;Association&gt;
            &lt;targetUuid&gt;Document01&lt;/targetUuid&gt;
            &lt;sourceUuid&gt;SubmissionSet01&lt;/sourceUuid&gt;
            &lt;associationType&gt;HAS_MEMBER&lt;/associationType&gt;
            &lt;label&gt;ORIGINAL&lt;/label&gt;
            &lt;entryUuid&gt;Association01&lt;/entryUuid&gt;
        &lt;/Association&gt;
    &lt;/associations&gt;
&lt;/CompoundSubmissionSet&gt;
                </textual></programlisting></para><para class="po-block e155 e155"><textual class="po-textual">In our implementation we use XProc to replace the local identifiers with UUIDs and
                to do so we need only loop over each of the non-UUID identifiers and invoke the UUID
                XProc step. Our main XProc pipeline will now include a step which performs this
                insertion, and the output, which fulfills that validity constraint, will be wired to
                the XQuery step. The following XProc step definition shows the recursive application
                of the UUID step.
                </textual><programlisting class="po-block e156 e156" xml:space="preserve"><textual class="po-textual">&lt;p:declare-step name="main"
    xmlns:p="http://www.w3.org/ns/xproc" 
    xmlns:c="http://www.w3.org/ns/xproc-step" 
    xmlns:emc="http://www.emc.com/cto/xds"
    type="emc:replaceNonUuids"
    version="1.0"&gt;
  &lt;p:input port='source'/&gt;
  &lt;p:output port='result' primary='true'/&gt;

  &lt;p:choose name="processUuids"&gt;
      &lt;p:xpath-context&gt;
          &lt;p:pipe step="main" port="source"/&gt;
      &lt;/p:xpath-context&gt;
      &lt;p:variable name="nonUuid" select="//entryUuid[not(contains(.,'-')) and (position() = 1)]/text()"&gt;
          &lt;p:pipe step="main" port="source"/&gt;
      &lt;/p:variable&gt;
      &lt;p:when test="$nonUuid"&gt;
          &lt;p:uuid name="uuid"&gt;
              &lt;p:with-option 
                  name="match" 
                  select='concat("//*[(name(.)='entryUuid' or name(.)='targetUuid' or name(.)='sourceUuid')and .='",
                                 $nonUuid,
                                 "']/text()")'/&gt;
              &lt;p:input port="source"&gt;
                  &lt;p:pipe step="main" port="source"/&gt;
              &lt;/p:input&gt;
          &lt;/p:uuid&gt;
          &lt;emc:replaceNonUuids&gt;
              &lt;p:input port="source"&gt;
                  &lt;p:pipe step="uuid" port="result"/&gt;
              &lt;/p:input&gt;
          &lt;/emc:replaceNonUuids&gt;
      &lt;/p:when&gt;
      &lt;p:otherwise&gt;
          &lt;p:identity&gt;
              &lt;p:input port="source"&gt;
                  &lt;p:pipe step="main" port="source"/&gt;
              &lt;/p:input&gt;
          &lt;/p:identity&gt;
    &lt;/p:otherwise&gt;
  &lt;/p:choose&gt;
&lt;/p:declare-step&gt;</textual></programlisting></para><para class="po-block e157 e157"><textual class="po-textual">Figure 4 shows how this step is wired into the original pipeline.</textual></para><figure class="po-container e158 e158" xml:id="fig4"><mediaobject class="po-container e159 e159"><imageobject class="po-container e160 e160"><imagedata class="po-meta e161 e161" fileref="../../../vol7/graphics/Davis01/Davis01-004.jpg" format="jpg"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e162 e162"><para class="po-block e163 e163"><textual class="po-textual">Pipeline Augmented with Content Enrichment Step</textual></para></caption></figure><para class="po-block e164 e164"><textual class="po-textual">To complete the pipeline for the submission set creation operation we also include
                some additional validation steps (which, for brevity, we will not show here), as
                well as some steps that produce a multi-part response.</textual></para></section><section class="po-hcontainer e165 e165"><title class="po-block e166 e166"><textual class="po-textual">Multi-part Responses</textual></title><para class="po-block e167 e167"><textual class="po-textual">Because we are implementing our RESTful services almost exclusively in XProc pipelines, those
                pipelines must accommodate the need to generate more than just a single result. For
                example, a best practice in RESTful services is that resource creation operations
                return not only the resource representation, but also a URL to the newly created
                resource; this URL is to be returned in the HTTP Location header.  Furthermore,
                RESTful services MUST respond with a status code indicating success or failure, and
                since that outcome is largely determined in the XProc pipeline, that status
                information must similarly be returned.</textual></para><para class="po-block e168 e168"><textual class="po-textual">Fortunately, XProc provides for multi-part responses with multiple output ports,
                where any output port can carry more than one value.  We implement the pipelines for
                our RESTful services in a consistent manner, providing three output ports: the
                primary contains the resource representation, another called “headers” contains
                key/value pairs and one called “error” outputs an XML document that carries
                information on any errors that occurred during the processing of the pipeline.  The
                following is the final implementation of our submission set creation pipeline,
                including error handling and the creation of the location
                header.</textual><programlisting class="po-block e169 e169" xml:space="preserve"><textual class="po-textual">&lt;p:declare-step name="main" 
    xmlns:p="http://www.w3.org/ns/xproc"
    xmlns:c="http://www.w3.org/ns/xproc-step"
    xmlns:emc="http://www.emc.com/cto/xds" 
    version="1.0"&gt;
    &lt;p:input port="source"/&gt;
    &lt;p:input port='xqueryscript' /&gt;
    &lt;p:input port="stylesheet"/&gt;
    &lt;p:input port="stylesheetParameters" kind="parameter"/&gt;
    &lt;p:input port="xqueryParameters" kind="parameter"/&gt;
    &lt;p:output port='result' sequence='true' primary='true'&gt;
        &lt;p:pipe step='checkXquery' port='result'/&gt;
    &lt;/p:output&gt;
    &lt;p:output port='error' sequence="true"&gt;
        &lt;p:pipe step='checkXquery' port='error' /&gt;
    &lt;/p:output&gt;
    &lt;p:output port='headers' sequence="true"&gt;
        &lt;p:pipe step='checkXquery' port='headers' /&gt;
    &lt;/p:output&gt;
    &lt;p:import href="classpath:replaceNonUuids.xpl"/&gt;
    
    &lt;!-- This pipeline will assign identifiers whereever needed and then will
         execute the xquery against the source passed in.  Finally, it will
         take the result and enhance it with hyperlinks to related resources. 
         The xquery and xslt are both passed into the pipeline. --&gt;

    &lt;!-- Replace local identifiers with uuids. --&gt;
    &lt;emc:replaceNonUuids name="replaceNonUuids"&gt;
        &lt;p:input port="source"&gt;
            &lt;p:pipe step="main" port="source"/&gt;
        &lt;/p:input&gt;
    &lt;/emc:replaceNonUuids&gt;

    &lt;!-- execute xQuery against the input source --&gt;
    &lt;p:xquery name="xquery"&gt;
        &lt;p:input port='source'&gt;
            &lt;p:pipe step="replaceNonUuids" port="result" /&gt;
        &lt;/p:input&gt;
        &lt;p:input port="query"&gt;
            &lt;p:pipe step="main" port="xqueryscript" /&gt;
        &lt;/p:input&gt;
        &lt;p:input port="parameters"&gt;
            &lt;p:pipe step='main' port='xqueryParameters'/&gt;
        &lt;/p:input&gt;
    &lt;/p:xquery&gt;

    &lt;!-- check the result of the xQuery to make sure there was no error --&gt;
    &lt;p:choose name="checkXquery"&gt;
        &lt;p:variable name="error" select="/error/code"&gt;
            &lt;p:pipe step="xquery" port="result" /&gt;
        &lt;/p:variable&gt;
        &lt;!-- in case of error, return error xml out of pipeline --&gt;
        &lt;p:when test="$error"&gt;
            &lt;p:output port="error"&gt;
                &lt;p:pipe step="genError" port="result" /&gt;
            &lt;/p:output&gt;
            &lt;p:output port="result" sequence='true' primary="true"&gt;
                &lt;p:empty /&gt;
            &lt;/p:output&gt;
            &lt;p:output port="headers" sequence='true'&gt;
                &lt;p:empty/&gt;
            &lt;/p:output&gt;
            &lt;p:string-replace name="genError" match="/error/code/text()"&gt;
                &lt;p:input port="source"&gt;
                    &lt;p:inline&gt;
                        &lt;error&gt;&lt;code&gt;err&lt;/code&gt;&lt;description&gt;description&lt;/description&gt;&lt;/error&gt;
                    &lt;/p:inline&gt;
                &lt;/p:input&gt;
                &lt;p:with-option name='replace' select="$error" /&gt;
            &lt;/p:string-replace&gt;
        &lt;/p:when&gt;
        &lt;p:otherwise&gt;
            &lt;p:output port="error" sequence="true"&gt;
                &lt;p:empty /&gt;
            &lt;/p:output&gt;
            &lt;p:output port="result" sequence='true' primary="true"&gt;
                &lt;p:pipe step="xslt" port="result"/&gt;
            &lt;/p:output&gt;
            &lt;p:output port="headers" sequence='true'&gt;
                &lt;p:pipe step="locXML" port="result"/&gt;
            &lt;/p:output&gt;
            &lt;!-- insert hyperlinks --&gt;
            &lt;p:xslt name="xslt"&gt;
                &lt;p:input port='source'&gt;
                    &lt;p:pipe step='xquery' port='result'/&gt;
                &lt;/p:input&gt;
                &lt;p:input port='stylesheet'&gt;
                    &lt;p:pipe step='main' port='stylesheet'/&gt;
                &lt;/p:input&gt;
                &lt;p:input port='parameters'&gt;
                    &lt;p:pipe step='main' port='stylesheetParameters'/&gt;
                &lt;/p:input&gt;
            &lt;/p:xslt&gt;

            &lt;!-- generate the URL for the newly created resource --&gt;
            &lt;p:variable name="baseU" select="/c:param-set/c:param[@name='baseURL']/@value"&gt;
                &lt;p:pipe step="main" port="stylesheetParameters"/&gt;
            &lt;/p:variable&gt;
            &lt;p:string-replace name="locXML" match="/Location/text()"&gt;
                &lt;p:input port="source"&gt;
                    &lt;p:inline&gt;
                        &lt;Location&gt;here&lt;/Location&gt;
                    &lt;/p:inline&gt;
                &lt;/p:input&gt;
                &lt;p:with-option name='replace' select="concat('"',$baseU, '/', //entryUuid/text(),'"')"&gt;
                    &lt;p:pipe step='xslt' port='result'/&gt;
                &lt;/p:with-option&gt;        
            &lt;/p:string-replace&gt;

        &lt;/p:otherwise&gt;
    &lt;/p:choose&gt;
&lt;/p:declare-step&gt;</textual></programlisting></para><para class="po-block e170 e170"><textual class="po-textual">XProc’s support for multiple outputs is a good fit for the requirements of RESTful
                services and avoids having the developer design a multi-part model
                themselves.</textual></para></section><section class="po-hcontainer e171 e171"><title class="po-block e172 e172"><textual class="po-textual">XProc and Transactions</textual></title><para class="po-block e173 e173"><textual class="po-textual">One might note that while in our current implementation we have split our
                submission set into more fine-grained parts within the XQuery, that we could also
                have done so in the XProc pipeline. Doing the split as a step in the XProc pipeline
                could result in greater reuse of portions of the implementation and code that is
                easier to produce and maintain.  But then what would come of our requirement for
                atomicity in the construction of the submission set, if pipeline were to execute
                several updating XQuery steps?</textual></para><para class="po-block e174 e174"><textual class="po-textual">Fortunately, the Xproc engine that we are using in house provides transaction
                boundaries at the start and end of a pipeline.   This allows us to construct
                pipelines that execute multiple XQueries, yet have them succeed or fail as one
                single unit.  This powerful capability is quite welcome in the construction of
                RESTful services where compound resources are common.</textual></para></section></section><section class="po-hcontainer e175 e175"><title class="po-block e176 e176"><textual class="po-textual">Binding HTTP Processing to the XML-Centric Implementation </textual></title><para class="po-block e177 e177"><textual class="po-textual">At this point we’ve seen how an XProc pipeline allows us wire up a set of steps to
            provide the core implementation of our RESTful services.  The XProc pipeline accepts
            inputs and returns a multi-part response, including what can be thought of as a body,
            headers and error/status information.  What remains is how an XProc pipeline is bound to
            the Java classes we’ve created for each of our resources, as well as how to bind
            portions of the HTTP request/response to the pipeline inputs/outputs.</textual></para><para class="po-block e178 e178"><textual class="po-textual">To bind an XProc pipeline to a resource (Java) method we inject the XProc pipeline
            into the method via a Spring configuration.  Each method in the Java class will have an
            XMLProcessingContext object associated with it, which encapsulates the pipeline as well
            as any design time bindings to the pipeline.  To understand why design time bindings are
            valuable, consider that the pipeline for most GET operations will be very similar; an
            XQuery will be used to obtain XML from the database and an XSLT will be applied to those
            results.  The only thing that differs from one GET operation to another is the specific
            XQuery and the specific XSLT stylesheet; hence, we will parameterize a single GET
            pipeline with those values and reuse that pipeline over many resource implementations. 
            The following excerpt from a Spring configuration file shows the injection of XQueries
            and XSLTs into the XMLProcessingContext for the createSubmissionSet operation, and the
            injection of that XMLProcessingContext into the resource
            class.</textual><programlisting class="po-block e179 e179" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;!-- other bean definitions omitted for brevity --&gt;

    &lt;!-- Patients and Patient Resource --&gt;
    &lt;bean id="Patients" class="com.emc.cto.healthcare.SubmissionSets"&gt;
        &lt;property name="addSubmissionSet" ref="addSubmissionSetXMLProcessingContext" /&gt;
    &lt;/bean&gt;

    &lt;bean id="addSubmissionSetXMLProcessingContext" class="com.emc.cto.xproc.XProcXMLProcessingContext"&gt;
        &lt;property name="xprocPool" ref="xprocPool" /&gt;
        &lt;property name="pipelineSource"&gt;&lt;value&gt;classpath:xqueryXsltUuid.xpl&lt;/value&gt;&lt;/property&gt;
        &lt;property name="inputs"&gt;
            &lt;map&gt;
                &lt;entry key="xqueryscript" value="classpath:registerObjectsMinimal.xq" /&gt;
                &lt;entry key="stylesheet" value="classpath:hyperlinksSubmissionSet.xslt" /&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="options"&gt;&lt;map/&gt;&lt;/property&gt;
        &lt;property name="parameters"&gt;&lt;map/&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</textual></programlisting></para><para class="po-block e180 e180"><textual class="po-textual">Finally, we must bind additional XProc parameters at run time, using the Java-based
            framework to access parts of the HTTP request and supplying those values to the pipeline
            in the Java method.  Following the execution of the pipeline the results are mapped back
            to the HTTP response.  This is done by our framework in a Spring MVC view that knows how
            to convert the multi-part pipeline output into an HTTP response; this relieves the
            services developer of these concerns.  The following code shows the full implementation
            of the method corresponding to the POST operation on the submission sets
            resource.</textual><programlisting class="po-block e181 e181" xml:space="preserve"><textual class="po-textual">@RequestMapping(method = RequestMethod.POST)
@ResponseStatus(HttpStatus.CREATED)
public String addPatient(HttpServletRequest request, 
                         HttpServletResponse response, 
                         Model model) throws XProcException, IOException, URISyntaxException, TransformerException {
    try {
        PipelineInputCache pi = new PipelineInputCache();

        // supply http body as the source for the resource Create pipeline
        pi.setInputPort("source", request.getInputStream());
            
        // supply current resource URL as the base URL to craft hyperlinks
        String baseUrl = request.getRequestURL().toString();
        if (baseUrl.endsWith("/"))
            baseUrl = baseUrl.substring(0, baseUrl.length()-2);
        pi.addParameter("stylesheetParameters", new QName("baseURL"), baseUrl);

        PipelineOutput output = m_addSubmissionSet.executeOn(pi);

        model.addAttribute("pipelineOutput", output);
        return "pipelineOutput";
    } finally {
        ; 
    }
}</textual></programlisting></para></section><section class="po-hcontainer e182 e182"><title class="po-block e183 e183"><textual class="po-textual">Conclusions</textual></title><para class="po-block e184 e184"><textual class="po-textual">Our experience implementing an XDS Registry using the XML REST Framework shows that
            the XML Technology stack not only provides capabilities adequate for implementation of
            sophisticated RESTful web services, but also results in an elegant solution that is
            arguably easier to construct and maintain than a purely Java-based counterpart. We have
            not done any quantitative analysis comparing developer productivity between the two
            approaches, or comparing the use of our framework to other XRX-based approaches, however
            we do have some anecdotal evidence that supports this claim. In one instance, a
            development team was able to complete the work for two project sprints within the time
            frame of a single sprint; they credited the XML-centric approach to RESTful services
            construction for that acceleration. Some work has been done by Syntactica to quantify
            the productivity gains of an XRX-based approach </textual><xref class="po-milestone e185 e185" linkend="XRXVal"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.  </textual></para><para class="po-block e186 e186"><textual class="po-textual">While there is clearly some overlap between the capabilities in XQuery, XSLT and
            XProc, there is a clean mapping from requirements on RESTful services to the tools that
            best address them.  Limiting an XQuery to interactions with the database results in
            queries that are simple to write and unit test, and effectively encapsulates the logic
            that creates application model objects (XML structures). The controller portion of our
            implementation is implemented with XProc pipelines and XSLT stylesheets.  With its
            mechanism for identifying insertion points, and a powerful language for expressing what
            should be inserted, XSLT is ideally suited to perform hyperlink insertion.  It is also
            the de facto standard for doing XML to XML</textual><footnote class="po-popup e187 e187"><para class="po-block e188 e188"><textual class="po-textual">Note that JSON resource representations are increasingly popular.  The
                    approach we describe in this paper does not preclude such representations and
                    XSLT is also an excellent choice for XML to JSON transformations.</textual></para></footnote><textual class="po-textual"> transformations.  The new XProc standard which defines a high level language
            for wiring together a set of XML-centric steps, provides a means for addressing many of
            the requirements presented by RESTful services: implementations of compound resources, a
            multi-part data model and a large set of out of the box XML processing steps.</textual></para><para class="po-block e189 e189"><textual class="po-textual">One of the most significant, positive results of our work has been that with the
                availability of our XML REST Framework we have enabled developers to more readily
                understand the important elements of RESTful services.  Rather than simply providing
                guidance in the form of a reference architecture, providing a set of tools and
                samples along with that guidance has proven very effective.</textual></para><section class="po-hcontainer e190 e190"><title class="po-block e191 e191"><textual class="po-textual">Limitations</textual></title><para class="po-block e192 e192"><textual class="po-textual">We have employed our XML REST Framework in several projects within EMC with a good
                deal of success.  The biggest barrier, however, continues to be a reluctance by
                developers to embrace XML as the development model.  The XML-based approach that we
                espouse in this paper, while quite powerful, still suffers from a lack of tooling and,
                even more importantly, a learning curve issue.  Most developers are quite familiar with
                Java programming approaches, IDEs, testing frameworks, and so on, and have limited
                experience with the XQuery and XSLT.  Most have never heard of XProc.  While the XProc
                processing model is powerful and conceptually allows pipelines to be easily expressed,
                the syntax is unwieldy and will turn most developers completely off.  It would behoove
                us in the XML community to address these issues to expand the utilization of XML
                technologies in such development scenarios.</textual></para><para class="po-block e193 e193"><textual class="po-textual">One of the things we have found most useful in this XML-centric approach to RESTful
                service construction is the use of XProc to operate on compound resources.  We noted in
                a section above that the XProc implementation we are using in our work creates
                transaction boundaries at the beginning and end of a pipeline.  This feature does not
                exist in all XProc engines, limiting the generality of the approach we describe
                here.</textual></para></section><section class="po-hcontainer e194 e194"><title class="po-block e195 e195"><textual class="po-textual">Future Work</textual></title><para class="po-block e196 e196"><textual class="po-textual">Our work in this area continues.  We are exploring the use of XProc as the core engine in
                the View portion of a Spring MVC implementation.  We are exploring the use of finite
                state machines (FSM) to model application flows and are building an engine that
                interprets these FSMs, inserting hyperlinks in the resource representations. We are also
                investigating how other elements of RESTful service implementations (such as feed paging
                and eTag </textual><xref class="po-milestone e197 e197" linkend="eTags"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> support) can be integrated into the framework so as to
                continue lessening the load on the services developer.</textual></para></section><section class="po-hcontainer e198 e198"><title class="po-block e199 e199"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></title><para class="po-block e200 e200"><textual class="po-textual">The XML REST Framework is available, along with a sample application, from the EMC
        Developer Network </textual><xref class="po-milestone e201 e201" linkend="XMLRESTFW"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.  The distribution includes
        all source code.</textual></para></section></section><bibliography class="po-hcontainer e202 e202"><title class="po-block e203 e203"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e204 e204" xml:id="XRX" xreflabel="XRX"><textual class="po-textual">McCreary, Dan. XRX: Simple, Elegant, Disruptive. May 2008. </textual><link class="po-inline e205 e205" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oreillynet.com/xml/blog/2008/05/xrx_a_simple_elegant_disruptiv_1.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e206 e206" xml:id="XForms" xreflabel="XForms"><textual class="po-textual">Boyer, John M., XForms 1.1. October 2009.  </textual><link class="po-inline e207 e207" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xforms11/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e208 e208" xml:id="XQuery" xreflabel="XQuery"><textual class="po-textual">Boag, Scott, et. al.  XQuery 1.0: An XML Query Language (Second Edition). December 2010. </textual><link class="po-inline e209 e209" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e210 e210" xml:id="XSLT" xreflabel="XSLT"><textual class="po-textual">Kay, Michael. XSL Transforamtions (XSLT) Version 2.0. January 2007. </textual><link class="po-inline e211 e211" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt20/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e212 e212" xml:id="Atom" xreflabel="Atom"><textual class="po-textual">Nottingham, M. and R. Sayre. The Atom Syndication Format. December 2005. </textual><link class="po-inline e213 e213" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc4287</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e214 e214" xml:id="XProc" xreflabel="XProc"><textual class="po-textual">Walsh, Norman, Alex Milowski and Henry S. Tompson. XProc: An XML Pipeline Language. May 2010. </textual><link class="po-inline e215 e215" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xproc/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e216 e216" xml:id="IHEConnect" xreflabel="IHEConnect"><textual class="po-textual">IHE Connectathon. </textual><link class="po-inline e217 e217" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ihe.net/Connectathon/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e218 e218" xml:id="IHEXDS" xreflabel="IHEXDS"><textual class="po-textual">IHE Cross Enterprise Document Sharing (XDS). </textual><link class="po-inline e219 e219" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ihe.net/Profiles/index.cfm#IT</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e220 e220" xml:id="Spring" xreflabel="Spring"><textual class="po-textual">Johnson, R., et. al.  Spring Framework Reference Documentation 3.0. 2004-2010.  </textual><link class="po-inline e221 e221" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e222 e222" xml:id="Wilde" xreflabel="Wilde"><textual class="po-textual">Wilde, Erik.  XML-Centric Application Development. February 2006. </textual><link class="po-inline e223 e223" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dret.net/netdret/docs/wilde-tikrep242.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e224 e224" xml:id="IHE" xreflabel="IHE"><textual class="po-textual">Integrating the Healthcare Enterprise Technical Frameworks. </textual><link class="po-inline e225 e225" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ihe.net/Technical_Framework/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e226 e226" xml:id="REST" xreflabel="IHE"><textual class="po-textual">Fielding, Roy Thomas, Architectural Styles and the Design of Network-based Software Architectures. 2000. </textual><link class="po-inline e227 e227" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e228 e228" xml:id="Servlex" xreflabel="Servlex"><textual class="po-textual">Servlex: an implementation of the EXPath Webapps framework</textual><link class="po-inline e229 e229" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://code.google.com/p/servlex/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e230 e230" xml:id="XPWebapp" xreflabel="EXPath Webapp"><textual class="po-textual">EXPath Webapp. </textual><link class="po-inline e231 e231" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://expath.org/wiki/Webapp</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e232 e232" xml:id="MVC" xreflabel="Spring MVC"><textual class="po-textual">Haines, Steven. Mastering Spring MVC. April 2009. </textual><link class="po-inline e233 e233" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.javaworld.com/javaworld/jw-04-2009/jw-04-springmvc.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e234 e234" xml:id="CXF" xreflabel="Apache CXF"><textual class="po-textual">Apache CXF: An Open Source Services Framework. </textual><link class="po-inline e235 e235" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://cxf.apache.org/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e236 e236" xml:id="Jersey" xreflabel="Jersey"><textual class="po-textual">Glassfish: Jersey.  </textual><link class="po-inline e237 e237" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jersey.java.net/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e238 e238" xml:id="Hypermedia" xreflabel="Hypermedia Constraint"><textual class="po-textual">Fielding, Roy. REST APIs must be hypertext-driven.  Blog post, October 2008. </textual><link class="po-inline e239 e239" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e240 e240" xml:id="eTags" xreflabel="eTags"><textual class="po-textual">Hypertext Transfer Protocol -- HTTP/1.1 - ETag Section.  June 1999. </textual><link class="po-inline e241 e241" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e242 e242" xml:id="XRXVal" xreflabel="XRX Value"><textual class="po-textual">Syntactica Solutions for XRX Developers. </textual><link class="po-inline e243 e243" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.syntactica.com/solutions/xrx.xq</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e244 e244" xml:id="XMLRESTFW" xreflabel="XMLRESTFW"><textual class="po-textual">Davis, Cornelia, XML REST Framework: Spring MVC and XProc. </textual><link class="po-inline e245 e245" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://community.emc.com/docs/DOC-10494</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>