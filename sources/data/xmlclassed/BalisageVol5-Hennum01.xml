<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">XHTML Dialects: Interchange over domain vocabularies through upward expansion</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">With examples of manifesting and validating microformats</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">The XML community exhibits a persistent tension between the value of sharing
(motivating standards) and the value of individuation
(motivating customization of those standards).
Some communities resolve this tension through particular emphasis
on customizations that produce subsets of base vocabularies.
Current practices for defining subset vocabularies, however, have limitations
that reduce the value of this approach.
This paper proposes enhancing the XML ecosystem with a general-purpose
mechanism for defining and managing subset extensions of a vocabulary.
The proposal makes use of Semantic Web strategies —
in particular, asserting new type relations for existing type definitions and 
simplifying content models —
to identify commonality for variant vocabularies.
This approach has particular promise for extending XHTML
as illustrated with a few microformats.
</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Erik</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Hennum</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Erik Hennum has worked in the area of XML and RDF document semantics
and processing since the advent of XML.
As a member of the OASIS DITA Technical Committee,
he originated proposals for several features of the DITA architecture
including domain specialization, design constraints, data extensibility, 
map referencing, subject classification, and metadata schemes.
While at IBM, his work included semantic search projects over structured content
using both DB2 PureXML and Resource Description Framework (RDF) repositories.
</textual></para></personblurb></author><legalnotice class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Copyright © 2010 Erik Hennum under </textual><link class="po-inline e17 e17" xlink:actuate="onRequest" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://creativecommons.org/licenses/by-nc/3.0/</textual></link><textual class="po-textual">.</textual></para></legalnotice></info><section class="po-hcontainer e18 e18"><title class="po-block e19 e19"><textual class="po-textual">Current practices for vocabulary relations</textual></title><para class="po-block e20 e20"><textual class="po-textual">The common practice of customizing standard XML vocabularies
results in variant vocabularies.
Subset vocabularies are particularly useful because they can be converted
to the standard vocabulary for interoperability.
Restrictive substitution guarantees subset vocabularies but
has practical limitations on flexibility and process.
A method for recognizing the common superset of independent derivations has
significant potential benefits.
</textual></para><section class="po-hcontainer e21 e21"><title class="po-block e22 e22"><textual class="po-textual">Community and its discontents</textual></title><para class="po-block e23 e23"><textual class="po-textual">In accepted XML practice, a community typically meets its requirements
for representing the data or discourse for a domain 
by creating a standard vocabulary.
At the present time, the Organization for the Advancement of Structured Information
Standards (OASIS) has approved
over </textual><link class="po-inline e24 e24" xlink:actuate="onRequest" xlink:href="http://www.oasis-open.org/specs/" xlink:show="new" xlink:type="simple"><textual class="po-textual">30 distinct standard
vocabularies</textual></link><textual class="po-textual"> for different domains
(including electronic business, elections, emergency alerting, security assertions,
and so on).
Of course, many domain vocabularies are maintained at other consortia or
independently.
Such standard efforts take on the difficult challenge of arriving at a 
consensual definition of the knowledge of a community.
    </textual></para><para class="po-block e25 e25"><textual class="po-textual">As an equally common practice, the committee writing the schema
that defines the standard provides mechanisms for customizing the vocabulary.
For instance, HTML DTDs have long supported adding or deleting elements or attributes
in any content model.
A former member of the W3C Technical Architecture Group has gone so far
as to mandate extensibility as a prime rule for any vocabulary
(</textual><emphasis class="po-inline e26 e26" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e27 e27" linkend="ORCHARD"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
This emphasis on customization argues that a standard vocabulary is often only an
approximation of the real requirements of adopters.
    </textual></para><para class="po-block e28 e28"><textual class="po-textual">The divergent imperatives for conformance and customization reflect
a fundamental tension between the value of community and individuality:</textual></para><itemizedlist class="po-table e29 e29"><listitem class="po-container e30 e30"><para class="po-block e31 e31"><textual class="po-textual">Conformance minimizes adoption effort,
encourages vendor independence, and
guarantees interoperability with other conformant adopters.
    		</textual></para></listitem><listitem class="po-container e32 e32"><para class="po-block e33 e33"><textual class="po-textual">Customization meets real requirements, allows innovation, and
represents the adopter's knowledge without compromise.
    		</textual></para></listitem></itemizedlist><para class="po-block e34 e34"><textual class="po-textual">Customizations can pose to a lesser degree the same interchange challenges
as unrelated vocabularies.
For instance, interchange between a DocBook customization and standard DocBook
can require a custom transform.
Depending on the extent of customization, such transforms can be 
brittle at the edge, posing interpretation problems where an element
has no equivalent in the target vocabulary and leading to tag abuse.
In short, the DocBook committee has good reason to warn that any customization
is no longer DocBook (</textual><emphasis class="po-inline e35 e35" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual">
</textual><xref class="po-milestone e36 e36" linkend="DOCBOOK"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
    </textual></para><para class="po-block e37 e37"><textual class="po-textual">More formally, customizations can result in a vocabulary that has a subset,
superset, intersect, or disjunct relationship with the standard vocabulary.
The TEI committee recognizes customizations that create a pure subset of TEI
as </textual><emphasis class="po-inline e38 e38" role="ital"><textual class="po-textual">clean</textual></emphasis><textual class="po-textual"> customizations
(</textual><emphasis class="po-inline e39 e39" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e40 e40" linkend="TEI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
Subset customizations merit particular attention because they can convert
a customized instance to a valid base instance, providing interoperability
with other adopters and thus reducing concerns about customization.
Superset customizations, by contrast, convert to a base instance
only if the the additions in the customized instance are possible to ignore
without producing a garbled document. 
</textual></para></section><section class="po-hcontainer e41 e41"><title class="po-block e42 e42"><textual class="po-textual">Vocabulary relations through formal types in XSD</textual></title><para class="po-block e43 e43"><textual class="po-textual">XML Schema (XSD) provides mechanisms for establishing
formal relationships between vocabularies.
In particular, XSD supports definition of formal types with inheritance relations
(</textual><emphasis class="po-inline e44 e44" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e45 e45" linkend="XSD"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
In XSD, a derived type can have either of two relations to an existing base type:</textual></para><variablelist class="po-table e46 e46"><varlistentry class="po-record e47 e47"><term class="po-block e48 e48"><textual class="po-textual">Extension</textual></term><listitem class="po-container e49 e49"><para class="po-block e50 e50"><textual class="po-textual">A superset relation. The extended
type must allow all of the content of the base type as well as the additions.
Instances of the base type have a guaranteed conversion to the extended type.</textual></para></listitem></varlistentry><varlistentry class="po-record e51 e51"><term class="po-block e52 e52"><textual class="po-textual">Restriction</textual></term><listitem class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">A subset relation. The new type can restrict the
range of occurrences of the content of the base type.
For instance, a particle with zero or one occurrences can be reduced
to one and only one occurrence.
The new type can also replace a contained type in the content
with a restricted type for the contained type (or with a
substitution group including any combination of the contained type and
its restrictions).
Instances of the restricted type have a guaranteed conversion to the base type.</textual></para></listitem></varlistentry></variablelist><para class="po-block e55 e55"><textual class="po-textual">Because the new type has exactly one base type in XSD,
the type relations construct a dependency hierarchy with a single root.
The superset-subset relations established through these dependencies
do not constitute a hierarchy.
In particular, through extension, new types can add many different supersets
of an existing type.
As with well-established Object-Oriented programming languages like Java,
the type relations are an immutable design feature of the type. </textual></para><para class="po-block e56 e56"><textual class="po-textual">XSD manages type relations for design and validation but does not
expose type relations for application processing.
Instead, Schema Component Designators
(</textual><emphasis class="po-inline e57 e57" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e58 e58" linkend="SCD"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
a companion standard,
makes type relations available for inspection and processing.
</textual></para></section><section class="po-hcontainer e59 e59"><title class="po-block e60 e60"><textual class="po-textual">Subset vocabularies in DITA</textual></title><para class="po-block e61 e61"><textual class="po-textual">The Darwin Information Typing Architecture
(</textual><emphasis class="po-inline e62 e62" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e63 e63" linkend="DITA"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
provides a method called </textual><emphasis class="po-inline e64 e64" role="ital"><textual class="po-textual">specialization</textual></emphasis><textual class="po-textual"> 
for defining vocabularies by deriving new types from base types.
At present, DITA doesn't implement specialization with XSD type restrictions.
The designer implements vocabularies in either DTD or XSD modules,
following the rule that each new type restricts its base type and
using tools to check conformance.
Specialization emphasizes semantic as well as structural derivation.
That is, the derived type must have a meaning narrower than and subsumed in
the base type.
As in XSD, the type relations construct a single hierarchy, but the type hierarchy
reflects restriction instead of dependency.</textual></para><para class="po-block e65 e65"><textual class="po-textual">DITA implements most of the vocabulary approved as part of the standard
through specialized types.
Adopters have also used specialization to derive vocabularies for automotive,
financial, learning, legal, medical, and other domains.
The base vocabulary provides a number of benefits for the design work 
on these vocabularies:
</textual></para><itemizedlist class="po-table e66 e66"><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">Seeding designs with the vocabulary so the design effort
becomes one of selection and refinement rather than starting from scratch.
</textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">Minimizing the implementation effort through reuse
of portions of the base implementation.</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">Grounding interpretation of each derived type
in a familiar base type.</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">Guaranteeing interoperability at a general level.</textual></para></listitem></itemizedlist><para class="po-block e75 e75"><textual class="po-textual">Applications recognize vocabularies by inspecting
the defaulted values of architectural attributes.
Each element instance declares its type ancestry,
but types that are not instanced in the document are not visible.
Instead, instanced types are associated with modules, and all modules are
declared with an architectural attribute.
That is, applications can inspect and compare vocabularies at module rather than
type granularity.
</textual></para></section><section class="po-hcontainer e76 e76"><title class="po-block e77 e77"><textual class="po-textual">General semantics and loose models in the restriction base</textual></title><para class="po-block e78 e78"><textual class="po-textual">For clarity, this paper will use the term
</textual><emphasis class="po-inline e79 e79" role="ital"><textual class="po-textual">restrictive substitution</textual></emphasis><textual class="po-textual"> for the type relationship
(known as </textual><quote class="po-inline e80 e80"><textual class="po-textual">restriction</textual></quote><textual class="po-textual"> in XSD and as </textual><quote class="po-inline e81 e81"><textual class="po-textual">specialization</textual></quote><textual class="po-textual">
in DITA) that produces subset vocabularies. 
Restrictive substitution provides flexibility for vocabulary design only
when the base vocabulary includes at least a few semantically general types
with loose content models.</textual></para><para class="po-block e82 e82"><textual class="po-textual">In particular, a recursive general type with any occurrence of mixed content
can supply a base for deriving any element structure.
For example, consider a recursive name structure as declared
by the following grammar fragment:
</textual></para><programlisting class="po-block e83 e83" xml:space="preserve"><textual class="po-textual">&lt;NameStructure&gt;
</textual><emphasis class="po-inline e84 e84"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (</textual><emphasis class="po-inline e85 e85"><textual class="po-textual">text</textual></emphasis><textual class="po-textual"> | NameStructure)* 
&lt;/NameStructure&gt;</textual></programlisting><para class="po-block e86 e86"><textual class="po-textual">By substituting a derived type with text content for NameStructure, a designer
can represent a name as simple text content:</textual></para><programlisting class="po-block e87 e87" xml:space="preserve"><textual class="po-textual">&lt;SimpleName&gt;
</textual><emphasis class="po-inline e88 e88"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (</textual><emphasis class="po-inline e89 e89"><textual class="po-textual">text</textual></emphasis><textual class="po-textual">)* 
&lt;/SimpleName&gt;</textual></programlisting><para class="po-block e90 e90"><textual class="po-textual">Another designer can derive types to represent a name with carefully structured
name parts (by substituting derived types as both container and
contained types):</textual></para><programlisting class="po-block e91 e91" xml:space="preserve"><textual class="po-textual">&lt;PersonName&gt;
</textual><emphasis class="po-inline e92 e92"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (FirstName?, OtherName*, Surname, Lineage?) 
&lt;/PersonName&gt;</textual></programlisting><para class="po-block e93 e93"><textual class="po-textual">The two derivations embody very different notions
of the content that represents a name, but
a valid instance of either derivation can convert
to a valid instance of NameStructure.
In the conversion, the semantics of the derivation are lost,
but that accurately reflects the more abstract representation
of the content at the base level.</textual></para></section><section class="po-hcontainer e94 e94"><title class="po-block e95 e95"><textual class="po-textual">Rationale for restrictive substitution</textual></title><para class="po-block e96 e96"><textual class="po-textual">Even in cases without a strong semantic relationship between
the broader and narrower types, restrictive substitution has value:</textual></para><orderedlist class="po-table e97 e97"><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">For many specialized domains, a portion of the authored content
consists of structured text without more specific semantics — 
sections, tables, lists, paragraphs, phrases, terms, and the like
(as in the legislative domain;
</textual><emphasis class="po-inline e100 e100" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e101 e101" linkend="MCGRATH"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
That is, many domain vocabularies require general-purpose types.</textual></para></listitem><listitem class="po-container e102 e102"><para class="po-block e103 e103"><textual class="po-textual">Where the markup annotates readable data or discourse, 
conversion to a base markup with enough structure to format the text 
still has value through support of human readability.</textual></para><para class="po-block e104 e104"><textual class="po-textual">For example, rows of geolocated data still have utility as a readable table
even after dropping the special column semantics for typing the cell values.</textual></para></listitem><listitem class="po-container e105 e105"><para class="po-block e106 e106"><textual class="po-textual">Where the markup captures values that are not meaningful text
but, instead, parameterize an object or interaction, preserving the values
as ignored text in a base representation still has utility. </textual></para><para class="po-block e107 e107"><textual class="po-textual">Developers can inspect the values in context and more easily
implement the necessary interpretation.
(Of course, such cases are often best handled with a textual fallback that's recognized
at the base level but ignored by processing that recognizes the special semantics,
as with multimedia objects.)</textual></para></listitem></orderedlist></section><section class="po-hcontainer e108 e108"><title class="po-block e109 e109"><textual class="po-textual">Limitations of restrictive substitution</textual></title><para class="po-block e110 e110"><textual class="po-textual">Some factors limit the problems solvable
through restrictive substitution alone.</textual></para><para class="po-block e111 e111"><textual class="po-textual">First, when an adopter has an understanding of a content type 
that is broader than or intersects with the standard type,
the only alternatives are requesting expansion of the standard type
or implementing a competing non-standard type with no relation
to the standard type.
For instance, while the DITA 1.0 design for the task type met the requirements
of its initial adopters, subsequent adopters had requirements for 
a broader content model with the same semantic.
The requesters have had to wait for DITA 1.2 for this change. </textual></para><para class="po-block e112 e112"><textual class="po-textual">Orchard (</textual><emphasis class="po-inline e113 e113" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e114 e114" linkend="ORCHARD"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
has recommended providing wildcards in content models to solve this problem.
A derived type tolerated through a wildcard, however, has no interpretation or
processing at the base level.
That is, the instances of the derived type can only be ignored at the base level,
which is not optimal for data or discourse that has special semantics but
can be formatted as structured text. </textual></para><para class="po-block e115 e115"><textual class="po-textual">In short, with restrictive substitution alone, 
the designer has the burden of trying to anticipate the diversity of reasonable
variant perspectives on the information in the domain.
As a consequence, the knowledge representation for the domain cannot grow
through decentralized, independent activity.
</textual></para><para class="po-block e116 e116"><textual class="po-textual">Second, a derived vocabulary that provides a precise representation
for a domain is no longer a good base for subsequent restrictive substitution.
In particular, for many data structures, the content models have particles with
precise an occurrence of at most one.
As a result, substitution cannot increase the number of types in the content model.
For instance, in the PersonName example, the FirstName, Surname, and Lineage
types have at most one occurrence.
In such cases, restrictive substitution cannot insert more particles
a content model. </textual></para></section><section class="po-hcontainer e117 e117"><title class="po-block e118 e118"><textual class="po-textual">Type relations in OWL</textual></title><para class="po-block e119 e119"><textual class="po-textual">OWL (</textual><emphasis class="po-inline e120 e120" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e121 e121" linkend="OWLOVER"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
has a core goal of enabling concurrent creation
of distributed and related vocabularies.
The solutions employed by RDF raise useful considerations
for XML vocabularies:</textual></para><itemizedlist class="po-table e122 e122"><listitem class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">As part of the principle that anyone
can make statements about any resource
(</textual><emphasis class="po-inline e125 e125" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e126 e126" linkend="RDFCONCEPT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
the OWL definitions of classes can be independent of 
the definitions of relationships between those classes.</textual></para><para class="po-block e127 e127"><textual class="po-textual">Applied to markup types, this principle suggests an ability to maintain
type relationships independent of the markup types definitions.</textual></para></listitem><listitem class="po-container e128 e128"><para class="po-block e129 e129"><textual class="po-textual">An OWL subclass can have many base classes, and
the OWL subclass relation is transitive
(</textual><emphasis class="po-inline e130 e130" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e131 e131" linkend="RDFSCHEMA"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e132 e132"><textual class="po-textual">Consider two grocers.
One asserts that Orange is a subclass of Fruit.
Another asserts that Lemon is a subclass of Citrus.
These independent class relations can be integrated for interoperability
without invalidating or modifying existing class relations merely
by adding new assertions that Orange is a subclass of Citrus
and that Citrus is a subclass of Fruit.</textual></para><figure class="po-container e133 e133" xml:id="typeinsert" xreflabel="Type insertion"><title class="po-block e134 e134"><textual class="po-textual">Inserting a base type</textual></title><mediaobject class="po-container e135 e135"><imageobject class="po-container e136 e136"><imagedata class="po-meta e137 e137" fileref="../../../vol5/graphics/Hennum01/Hennum01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e138 e138"><para class="po-block e139 e139"><textual class="po-textual">Distinct types integrated by inserting the Citrus base type
between the Orange derived type and the existing Fruit base type.</textual></para></caption></figure><para class="po-block e140 e140"><textual class="po-textual">Applied to markup type relations, this principle suggests
the ability to add new, less restrictive base types as needed
to recogize commonality between types in different vocabularies.</textual></para></listitem><listitem class="po-container e141 e141"><para class="po-block e142 e142"><textual class="po-textual">Under the Open World Assumption,
the distributed OWL / RDF graph tolerates multiple perspectives
with the expectation that each processor will use common objects and properties
without commitment to all persectives
(</textual><emphasis class="po-inline e143 e143" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e144 e144" linkend="OWLGUIDE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
</textual></para><figure class="po-container e145 e145" xml:id="SubgraphOverlap" xreflabel="Graph subset intersect"><title class="po-block e146 e146"><textual class="po-textual">Intersecting subsets of a graph</textual></title><mediaobject class="po-container e147 e147"><imageobject class="po-container e148 e148"><imagedata class="po-meta e149 e149" fileref="../../../vol5/graphics/Hennum01/Hennum01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">Different, intersecting subsets of the graph
representing the type relations of interest to different adopters.</textual></para></caption></figure><para class="po-block e152 e152"><textual class="po-textual">Applied to markup type relations, this principle suggests
that processors can use the base types related to current interchange or
other processing and ignore uninteresting base types.</textual></para></listitem><listitem class="po-container e153 e153"><para class="po-block e154 e154"><textual class="po-textual">An OWL class has a set of unique properties with cardinality
but not sequence or nested grouping.</textual></para><para class="po-block e155 e155"><textual class="po-textual">Applied to markup type relations, this principle suggests
that formal types could have similar simplified content models.
As Dattolo et al
(</textual><emphasis class="po-inline e156 e156" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e157 e157" linkend="DATTOLO"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
have pointed out, simplified content models can still support
XML processing:
</textual></para><itemizedlist class="po-table e158 e158"><listitem class="po-container e159 e159"><para class="po-block e160 e160"><textual class="po-textual">If the association between contained type and position
is unambiguous for a container type, processes can impose sequence
when desired.</textual></para></listitem><listitem class="po-container e161 e161"><para class="po-block e162 e162"><textual class="po-textual">Nested groups (such as a choice of sequences) can be supported
as the content of explicit grouping container types.</textual></para></listitem></itemizedlist><para class="po-block e163 e163"><textual class="po-textual">Type definitions with simple content models instead of complex grammars
have several benefits for tools and vocabulary designers:</textual></para><itemizedlist class="po-table e164 e164"><listitem class="po-container e165 e165"><para class="po-block e166 e166"><textual class="po-textual">Dynamic inspection of content model designs becomes easier
to implement. </textual></para></listitem><listitem class="po-container e167 e167"><para class="po-block e168 e168"><textual class="po-textual">Correct restriction of content models becomes an
easier design task.</textual></para></listitem><listitem class="po-container e169 e169"><para class="po-block e170 e170"><textual class="po-textual">Diagnostics for design issues become easier 
to understand. </textual></para></listitem></itemizedlist><para class="po-block e171 e171"><textual class="po-textual">Of course, content models without sequence in the type definition
do not remove the ability to preserve sequence in instances
(any more than a choice with multiple occurrences in a schema removes
the need to preserve sequence of instances of the choice in an document).
</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e172 e172"><title class="po-block e173 e173"><textual class="po-textual">Scenarios for upward expansion</textual></title><para class="po-block e174 e174"><textual class="po-textual">Applying the OWL approaches to the XML technique
of restrictive substitution suggests an approach of 
</textual><emphasis class="po-inline e175 e175" role="ital"><textual class="po-textual">upward expansion</textual></emphasis><textual class="po-textual">
for definition of less restrictive base types
without modifying existing type definitions.
The following scenarios illustrate the potential benefits of this approach
for markup types:</textual></para><orderedlist class="po-table e176 e176"><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">In the PersonName example, a new adopter needs to identify
persons by name, but some people have epithets
(as in </textual><quote class="po-inline e179 e179"><textual class="po-textual">Funes, the Memorious</textual></quote><textual class="po-textual">).
The adopter needs a new type that is a pure superset of the
existing PersonName type.
</textual></para><para class="po-block e180 e180"><textual class="po-textual">The adopter can create a new GeneralPersonName type with
the same content model as PersonName augmented by an Epithet type and
declare it as derived from NameStructure and as a base for PersonName.</textual></para><programlisting class="po-block e181 e181" xml:space="preserve"><textual class="po-textual">&lt;GeneralPersonName&gt;
</textual><emphasis class="po-inline e182 e182"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (FirstName?, OtherName*, Surname, Lineage?, Epithet?) 
&lt;/GeneralPersonName&gt;</textual></programlisting><para class="po-block e183 e183"><textual class="po-textual">The adopter can now create instances conforming to the existing PersonName
vocabulary or instances with epithets.
In addition, instances of the PersonName vocabulary can be converted
to instances of the new GeneralPersonName vocabulary by a tool
that reads the type relationships.
A custom transform is not needed. </textual></para></listitem><listitem class="po-container e184 e184"><para class="po-block e185 e185"><textual class="po-textual">In a variation on the first scenario, a new adopter
describes persons who always have epithets and never have lineage.
The adopter needs a new type that intersects with the
existing PersonName type without a pure subset or superset relation.
</textual></para><para class="po-block e186 e186"><textual class="po-textual">The adopter can create the GeneralPersonName type as before
but derive a new  RenownedPersonName type from GeneralPersonName:</textual></para><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual">&lt;RenownedPersonName&gt;
</textual><emphasis class="po-inline e188 e188"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (FirstName?, OtherName*, Surname, Epithet) 
&lt;/RenownedPersonName&gt;</textual></programlisting><para class="po-block e189 e189"><textual class="po-textual">The adopter can now create instances of persons with epithets.
Because both this new type and the existing PersonName type convert
without loss to the GeneralPersonName type, the adopter retains
interoperability with PersonName content at the GeneralPersonName level.
</textual></para></listitem><listitem class="po-container e190 e190"><para class="po-block e191 e191"><textual class="po-textual">In a variant of the second scenario, a practitioner
who is unaware of the PersonName type has independently created
a renowned-person-name type:</textual></para><programlisting class="po-block e192 e192" xml:space="preserve"><textual class="po-textual">&lt;renowned-person-name&gt;
</textual><emphasis class="po-inline e193 e193"><textual class="po-textual">Content:</textual></emphasis><textual class="po-textual"> (first-name?, last-name, epithet) 
&lt;/renowned-person-name&gt;</textual></programlisting><para class="po-block e194 e194"><textual class="po-textual">The practitioner later discovers a need for interoperability 
with the PersonName type.
The practitioner can derive a new GeneralPersonName type as before
and declare it as the base for the PersonName and renowned-person-name
types along with similar derivation declarations for the types in the content
of renowned-person-name.
The new GeneralPersonName type represents the superset
of the two, independently created types. 
</textual></para></listitem></orderedlist><para class="po-block e195 e195"><textual class="po-textual">As these quick scenarios illustrate, upward expansion
could greatly expand the set of problems solvable through restrictive substitution
and, more generally, recognize existing document types as subsets
of a more general domain vocabulary.</textual></para></section><section class="po-hcontainer e196 e196"><title class="po-block e197 e197"><textual class="po-textual">Theoretical alignments</textual></title><para class="po-block e198 e198"><textual class="po-textual">Managing vocabulary relationships aligns with some work on categories
in the Philosophy of Language and Prototype Theory.
Given that markup annotates data or discourse with categorical types,
these alignments are valuable to consider.</textual></para><para class="po-block e199 e199"><textual class="po-textual">Wittegenstein's discussion of family resemblance and the language game
 makes two fundamental points
(</textual><emphasis class="po-inline e200 e200" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e201 e201" linkend="WITTGENSTEIN"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
First, that a category such as </textual><emphasis class="po-inline e202 e202" role="ital"><textual class="po-textual">bird</textual></emphasis><textual class="po-textual"> is defined not
by a single set of core properties but, instead, by variant and overlapping properties
among members as distinct as albatross, flamingo, grouse, parrot, penguin,
ostrich, and woodpecker.
Second, formal rules establishing more consistent but restricted versions of a category
are justified by their utility. </textual></para><para class="po-block e203 e203"><textual class="po-textual">Building on Wittegenstein's work to develop Prototype Theory,
Rosch identifies levels of abstraction among categories
(</textual><emphasis class="po-inline e204 e204" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e205 e205" linkend="ROSCH"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
Minimally concrete categories (as with </textual><emphasis class="po-inline e206 e206" role="ital"><textual class="po-textual">cardinal</textual></emphasis><textual class="po-textual">,
</textual><emphasis class="po-inline e207 e207" role="ital"><textual class="po-textual">eagle</textual></emphasis><textual class="po-textual">, and </textual><emphasis class="po-inline e208 e208" role="ital"><textual class="po-textual">sparrow</textual></emphasis><textual class="po-textual">)
provide as much abstraction as possible without losing easy recognition of members.
By contrast, more abstract categories (superordinates such as
</textual><emphasis class="po-inline e209 e209" role="ital"><textual class="po-textual">bird</textual></emphasis><textual class="po-textual">) lack sufficient concrete information
for the same degree of confidence in recognition. (For instance,
</textual><emphasis class="po-inline e210 e210" role="ital"><textual class="po-textual">bat</textual></emphasis><textual class="po-textual"> is more prone to misidentification as a member of
</textual><emphasis class="po-inline e211 e211" role="ital"><textual class="po-textual">bird</textual></emphasis><textual class="po-textual"> than
as a member of </textual><emphasis class="po-inline e212 e212" role="ital"><textual class="po-textual">sparrow</textual></emphasis><textual class="po-textual">.)
Special concrete categories (subordinates such as
</textual><emphasis class="po-inline e213 e213" role="ital"><textual class="po-textual">bald eagle</textual></emphasis><textual class="po-textual"> and
</textual><emphasis class="po-inline e214 e214" role="ital"><textual class="po-textual">golden eagle</textual></emphasis><textual class="po-textual">) support somewhat better recognition
than minimally concrete categories but at the cognitive cost of a proliferation
of categories.
Finally, Rosch notes that minimally concrete categories typically precede
both abstract categories and special concrete categories,
which are often constructed by contrast with minimally concrete categories on need. 
</textual></para><para class="po-block e215 e215"><textual class="po-textual">These theories suggest the following perspective on relationships
between markup vocabularies:</textual></para><itemizedlist class="po-table e216 e216"><listitem class="po-container e217 e217"><para class="po-block e218 e218"><textual class="po-textual">Intersecting subset vocabularies can fill the role
of minimally concrete categories in Prototype Theory,
overlapping to express family resemblance.
</textual></para><para class="po-block e219 e219"><textual class="po-textual">For example, a ship-tracking vocabulary might share location coordinates
but not the depth dimension with a geophysical-event vocabulary.
From the perspective of the language game, each basic vocabulary applies
its own useful rules for formalizing consistent locations.</textual></para></listitem><listitem class="po-container e220 e220"><para class="po-block e221 e221"><textual class="po-textual">Superset vocabularies can fill the role of abstract 
categories in Prototype Theory, integrating minimally concrete categories.</textual></para><para class="po-block e222 e222"><textual class="po-textual">For example, to integrate tremor data with tsunami observations,
a general location vocabulary could define a union
of the ship-tracking and geophysical-event vocabularies.</textual></para></listitem><listitem class="po-container e223 e223"><para class="po-block e224 e224"><textual class="po-textual">Subset vocabularies can fill the role of special concrete
categories in Prototype Theory,
refining a minimally concrete category with narrower semantics and
more specific properties.</textual></para><para class="po-block e225 e225"><textual class="po-textual">For instance, a vocabulary for tracking maritime research vessels might capture
water temperature and salinity as part of the location.</textual></para></listitem></itemizedlist><para class="po-block e226 e226"><textual class="po-textual">From this perspective, the base vocabulary supplies general-purpose types
for the derivation of minimally concrete vocabularies.
The base vocabulary also provides an upper bound for the abstract vocabularies.</textual></para></section></section><section class="po-hcontainer e227 e227"><title class="po-block e228 e228"><textual class="po-textual">Dialects: Defining and managing vocabulary subsets</textual></title><para class="po-block e229 e229"><textual class="po-textual">From the preceding discussion, a solution for vocabulary relationships
with upward expansion would have the following features:
</textual></para><itemizedlist class="po-table e230 e230"><listitem class="po-container e231 e231"><para class="po-block e232 e232"><textual class="po-textual">Definition of subset vocabularies
(the </textual><emphasis class="po-inline e233 e233" role="ital"><textual class="po-textual">dialects</textual></emphasis><textual class="po-textual">) from a base vocabulary
through restrictive substitution.</textual></para></listitem><listitem class="po-container e234 e234"><para class="po-block e235 e235"><textual class="po-textual">Addition of any number of more general dialect types at any time
above an existing dialect type for the same base vocabulary.</textual></para></listitem><listitem class="po-container e236 e236"><para class="po-block e237 e237"><textual class="po-textual">Management of type inheritance and containment relations
in a graph inspectable by applications.</textual></para></listitem><listitem class="po-container e238 e238"><para class="po-block e239 e239"><textual class="po-textual">Separation of the type relation graph
from the schema used to validate document instances.</textual></para><para class="po-block e240 e240"><textual class="po-textual">The separation of 
</textual><link class="po-inline e241 e241" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Database_design" xlink:show="new" xlink:type="simple"><textual class="po-textual">conceptual
and physical models</textual></link><textual class="po-textual"> has a long tenure in the database community 
with parallels in the UML distinction between the conceptual and
implementation classes diagrams.
Modeling formal types in a graph and XML vocabulary in a schema 
establishes a similar distinction and is recommended by Bauman
(</textual><emphasis class="po-inline e242 e242" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e243 e243" linkend="BAUMAN"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
</textual></para></listitem><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">Simplified content models facilitating comparison,
conversion, and other operations on types.</textual></para></listitem></itemizedlist><note class="po-container e246 e246"><para class="po-block e247 e247"><textual class="po-textual">The Dialects mechanism will be useful only for base vocabularies
that include types with the semantic generality and loose content models
necessary for restrictive substitution.
</textual></para></note><note class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual">Because a processing instruction can represent a name-value pair
in the content for any element,
a processing instruction might provide a base for adding new attributes
to any dialect type.
Effectively, such attributes are ignored at the base level.
Thus, derivation of attributes from processing instructions is particularly useful
for parameters of objects and interactions that should be ignored at the base level
instead of formatted as readable text.
</textual></para></note><section class="po-hcontainer e250 e250"><title class="po-block e251 e251"><textual class="po-textual">Identifying the semantic concepts for markup types</textual></title><para class="po-block e252 e252"><textual class="po-textual">Markup types can reflect different perspectives on the content associated
with a concept.
For instance, the name of a person might be seen as a simple string or
as a structure identifying each part of the name.
In particular, markup types representing the same concept
can derive from different base markup types
(where the markup types represent different perspectives on the information
for the concept).
To indicate semantic commonality across markup types,
the graph must be able to associate a markup type with the concept indicated
by the markup type.
</textual></para><para class="po-block e253 e253"><textual class="po-textual">RDF offers two methods of definition that could be used to manage
information concepts:
</textual></para><variablelist class="po-table e254 e254"><varlistentry class="po-record e255 e255"><term class="po-block e256 e256"><textual class="po-textual">OWL</textual></term><listitem class="po-container e257 e257"><para class="po-block e258 e258"><textual class="po-textual">Defines classes of things and their properties
(</textual><emphasis class="po-inline e259 e259" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e260 e260" linkend="OWLOVER"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></listitem></varlistentry><varlistentry class="po-record e261 e261"><term class="po-block e262 e262"><textual class="po-textual">SKOS</textual></term><listitem class="po-container e263 e263"><para class="po-block e264 e264"><textual class="po-textual">Identifies individual concepts appearing in descriptions
(</textual><emphasis class="po-inline e265 e265" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e266 e266" linkend="SKOS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></listitem></varlistentry></variablelist><para class="po-block e267 e267"><textual class="po-textual">Because XML markup represents a wider range of description than 
the properties of things and because SKOS is lighter-weight than OWL,
SKOS offers a better candidate for managing the semantics of markup types.
Ogbuji has noted the suitability of SKOS for identifying markup
semantics (</textual><emphasis class="po-inline e268 e268" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e269 e269" linkend="OGBUJI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
</textual></para><para class="po-block e270 e270"><textual class="po-textual">SKOS provides the convenient
terms </textual><emphasis class="po-inline e271 e271" role="ital"><textual class="po-textual">broader</textual></emphasis><textual class="po-textual"> and
</textual><emphasis class="po-inline e272 e272" role="ital"><textual class="po-textual">narrower</textual></emphasis><textual class="po-textual">
for relationships between concepts.
The same terms can be applied usefully to relations between markup types,
reserving the terms </textual><emphasis class="po-inline e273 e273" role="ital"><textual class="po-textual">base</textual></emphasis><textual class="po-textual">
and </textual><emphasis class="po-inline e274 e274" role="ital"><textual class="po-textual">dialect</textual></emphasis><textual class="po-textual"> for the special case of a grounding
relationship to the base vocabulary.
</textual></para><note class="po-container e275 e275"><para class="po-block e276 e276"><textual class="po-textual">DuCharme (</textual><emphasis class="po-inline e277 e277" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e278 e278" linkend="DUCHARME"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
has noted that RDFa (</textual><emphasis class="po-inline e279 e279" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e280 e280" linkend="RDFA"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
can provide a method for marking up document instances with markup concepts.
RDFa has a primary focus of tunneling through documents to express structured data.
RDFa does not offer any assistance for managing type relations independent
of document instances.</textual></para></note></section><section class="po-hcontainer e281 e281"><title class="po-block e282 e282"><textual class="po-textual">Metamodel for the type relation graph</textual></title><para class="po-block e283 e283"><textual class="po-textual">A graph with inheritance relations and containment relations
for simple content models would require the following classes:</textual></para><variablelist class="po-table e284 e284"><varlistentry class="po-record e285 e285"><term class="po-block e286 e286"><textual class="po-textual">Type</textual></term><listitem class="po-container e287 e287"><para class="po-block e288 e288"><textual class="po-textual">A base or dialect type supporting restrictive substitution
of the contained types at its positions.</textual></para></listitem></varlistentry><varlistentry class="po-record e289 e289"><term class="po-block e290 e290"><textual class="po-textual">DocumentType</textual></term><listitem class="po-container e291 e291"><para class="po-block e292 e292"><textual class="po-textual">A base or dialect document vocabulary containing 
a single root position and supporting restrictive substitution
of the contained type at the root position.</textual></para></listitem></varlistentry><varlistentry class="po-record e293 e293"><term class="po-block e294 e294"><textual class="po-textual">TypeSet</textual></term><listitem class="po-container e295 e295"><para class="po-block e296 e296"><textual class="po-textual">A set of alternative types.</textual></para></listitem></varlistentry><varlistentry class="po-record e297 e297"><term class="po-block e298 e298"><textual class="po-textual">Position</textual></term><listitem class="po-container e299 e299"><para class="po-block e300 e300"><textual class="po-textual">A position in the content of a container type with cardinality
for a single contained type.</textual></para></listitem></varlistentry><varlistentry class="po-record e301 e301"><term class="po-block e302 e302"><textual class="po-textual">ContainerType</textual></term><listitem class="po-container e303 e303"><para class="po-block e304 e304"><textual class="po-textual">An abstract class for a type or document type.</textual></para></listitem></varlistentry><varlistentry class="po-record e305 e305"><term class="po-block e306 e306"><textual class="po-textual">ContainedType</textual></term><listitem class="po-container e307 e307"><para class="po-block e308 e308"><textual class="po-textual">An abstract class for a type or type set.</textual></para></listitem></varlistentry><varlistentry class="po-record e309 e309"><term class="po-block e310 e310"><textual class="po-textual">Concept</textual></term><listitem class="po-container e311 e311"><para class="po-block e312 e312"><textual class="po-textual">The meaning of a container type as a SKOS concept.</textual></para></listitem></varlistentry></variablelist><figure class="po-container e313 e313" xml:id="metamodel" xreflabel="Metamodel"><title class="po-block e314 e314"><textual class="po-textual">Metamodel for type relation graph</textual></title><mediaobject class="po-container e315 e315"><imageobject class="po-container e316 e316"><imagedata class="po-meta e317 e317" fileref="../../../vol5/graphics/Hennum01/Hennum01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">The principal classes and relationships in the type relation graph
(for clarity, omitting some details such as the base-dialect subproperty
of the broader-narrower property).
</textual></para></caption></figure></section><section class="po-hcontainer e320 e320"><title class="po-block e321 e321"><textual class="po-textual">Binding the graph to schemas</textual></title><para class="po-block e322 e322"><textual class="po-textual">Associating types in the graph with elements and attributes in schemas 
enables interpretation of documents and operations such as conversion
to a related document type.
The binding might take the form of annotations on a manually maintained schema
or of mappings that make it possible to generate schemas in different schema
languages.
In either approach, the binding has the following responsibilities: </textual></para><itemizedlist class="po-table e323 e323"><listitem class="po-container e324 e324"><para class="po-block e325 e325"><textual class="po-textual">Assigning names to markup types.
Different schemas might use the same name for different types.
This practice can improve usability by maximizing the familiarity of elements
when an adopter requires multiple variations on the same markup type.
</textual></para></listitem><listitem class="po-container e326 e326"><para class="po-block e327 e327"><textual class="po-textual">Selecting either the attribute or subelement form
to represent a markup type with a single value as its content
(when positions are not interleaved).</textual></para></listitem><listitem class="po-container e328 e328"><para class="po-block e329 e329"><textual class="po-textual">Selecting a sequence of positions for the content model.</textual></para></listitem></itemizedlist><para class="po-block e330 e330"><textual class="po-textual">These mappings might take defaults from the graph or a preferred schema
for the base vocabulary.</textual></para><para class="po-block e331 e331"><textual class="po-textual">Document instances might reflect the graph binding either indirectly
by means of a catalog entry associating the schema with the document type
or directly by annotating the document instance with a namespaced
attribute (such as dx:doc) on the root element that has a defaulted value
of the document type.
Applications can then use the document type from the graph and the element name or
combination of element and attribute name
to look up the markup type and broader or narrower markup types in the graph.</textual></para></section><section class="po-hcontainer e332 e332"><title class="po-block e333 e333"><textual class="po-textual">Variant serializations of document instances</textual></title><para class="po-block e334 e334"><textual class="po-textual">The type relation graph provides applications with detailed insight
that would be difficult to represent directly in the document instance.
Alternate serializations of the document instance that annotate elements
with markup types can, however, make the instance easier to interpret.
Some potential serializations:</textual></para><itemizedlist class="po-table e335 e335"><listitem class="po-container e336 e336"><para class="po-block e337 e337"><textual class="po-textual">Identify the base dialect type of each element through a namespaced
attribute annotation (such as dx:base) on the element with 
a CURIE (</textual><emphasis class="po-inline e338 e338" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e339 e339" linkend="CURIE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
value.</textual></para><para class="po-block e340 e340"><textual class="po-textual">This serialization makes the base types visible in a dialect document.
The serialization does not, however, remove the need to look up
the markup types for attributes.</textual></para></listitem><listitem class="po-container e341 e341"><para class="po-block e342 e342"><textual class="po-textual">Convert the dialect document instance to a base document instance
(without conversion of added dialect attributes to processing instructions) and
annotate each element with its dialect type through an attribute annotation
(such as dx:type).</textual></para><para class="po-block e343 e343"><textual class="po-textual">This serialization makes the document instance recognizable as a base instance
while retaining visibility of the dialect types on elements and 
availability of dialect attributes.
The serialization may be especially useful for processors that can operate
on well-formed instances of known elements, ignoring unknown attributes.</textual></para></listitem><listitem class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">Convert to a base document instance (with conversion
of added dialect attributes to processing instructions).
Where the base markup provides an attribute for lightweight semantic annotation
(such as a class or role attribute), the attribute can identify the dialect type
(possibly using some alternative to CURIE syntax).</textual></para><para class="po-block e346 e346"><textual class="po-textual">This serialization makes the document instance valid as a base instance
while surfacing the dialect types as much as possible.</textual></para></listitem></itemizedlist><para class="po-block e347 e347"><textual class="po-textual">Finally, multiple document instances can be serialized
together with the type relation graph as an RDF XML document
in which document types have a property with each instance
as an XML literal value.</textual></para></section><section class="po-hcontainer e348 e348"><title class="po-block e349 e349"><textual class="po-textual">Processing the type relations graph</textual></title><para class="po-block e350 e350"><textual class="po-textual">General-purpose tools can use the graph to operate on dialects
without hard-coding specific knowledge of the base or dialect vocabularies.
The following operations can be implemented:</textual></para><itemizedlist class="po-table e351 e351"><listitem class="po-container e352 e352"><para class="po-block e353 e353"><textual class="po-textual">Integrity checks on the compatibility of content models.</textual></para><para class="po-block e354 e354"><textual class="po-textual">Content compatibility is necessary to allow
inclusion of one position at another position.
Content compatibility is also a factor in inheritance relations.</textual></para><para class="po-block e355 e355"><textual class="po-textual">The checker must determine whether each position in the narrower content model
has a corresponding position in the broader content model.
The checker must also confirm that the aggregated cardinality
of the narrower positions are within the cardinality range of 
the corresponding broader position.</textual></para><para class="po-block e356 e356"><textual class="po-textual">The checker can ignore any type in the content model
where its is a member
of a type set that also has one of its broader types as a member.
By definition, if the broader type is compatible, the narrower type is also compatible.
</textual></para></listitem><listitem class="po-container e357 e357"><para class="po-block e358 e358"><textual class="po-textual">Integrity checks on inheritance relations between markup types.</textual></para><para class="po-block e359 e359"><textual class="po-textual">A broader type must have broader content, a broader concept, and
the same base type.</textual></para></listitem><listitem class="po-container e360 e360"><para class="po-block e361 e361"><textual class="po-textual">Automated discovery of broader dialects as potential conversion
targets.</textual></para></listitem><listitem class="po-container e362 e362"><para class="po-block e363 e363"><textual class="po-textual">Browsing for markup types.</textual></para><para class="po-block e364 e364"><textual class="po-textual">The graph can act as a repository for existing types to incorporate
into new vocabularies.
A container type can use a markup type 
if every broader type of the container has a position with a broader type
of the contained type.
</textual></para></listitem><listitem class="po-container e365 e365"><para class="po-block e366 e366"><textual class="po-textual">Conversion of document instances from narrower to broader
dialects.</textual></para><para class="po-block e367 e367"><textual class="po-textual">A document instance is convertible when the root markup type
of the target document type is broader than the root markup type
of the source document type (which guarantees that the entire content tree
is broader).
</textual></para></listitem><listitem class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">Role-oriented processing of a narrower document instances against
broader dialects.</textual></para></listitem><listitem class="po-container e370 e370"><para class="po-block e371 e371"><textual class="po-textual">Generation of schemas for validation of XML instance documents
from mappings.</textual></para></listitem></itemizedlist><para class="po-block e372 e372"><textual class="po-textual">For instance, if the graph asserts that the GeneralPerson type is broader than
the PersonName type, checking that the content of PersonName can be converted
to GeneralPerson confirms the integrity of the graph.
</textual></para></section></section><section class="po-hcontainer e373 e373"><title class="po-block e374 e374"><textual class="po-textual">XHTML Dialects</textual></title><para class="po-block e375 e375"><textual class="po-textual">The Dialects mechanism would make it possible 
to leverage XHTML as a base for representing knowledge in specific domains.
XHTML Dialects would have particular value for accessing content in HTML environments
(such as web browsers, </textual><link class="po-inline e376 e376" xlink:actuate="onRequest" xlink:href="http://www.idpf.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">ePUB</textual></link><textual class="po-textual">,
and </textual><link class="po-inline e377 e377" xlink:actuate="onRequest" xlink:href="http://www.adlnet.gov/Technologies/scorm/default.aspx" xlink:show="new" xlink:type="simple"><textual class="po-textual">SCORM</textual></link><textual class="po-textual">)
with minimal transforms.
</textual></para><para class="po-block e378 e378"><textual class="po-textual">XHTML offers good candidates for restrictive substitution
primarily within the body element.
Because the div and span elements connote useful general structure (block and inline)
and take recursive mixed content, these elements provide a good base
for markup of any readable data or discourse.
More specific base XHTML elements are preferrable where possible 
(an approach that microformats guidelines also suggest
in </textual><xref class="po-milestone e379 e379" linkend="MFGUIDE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
</textual></para><para class="po-block e380 e380"><textual class="po-textual">HTML profiles
(</textual><emphasis class="po-inline e381 e381" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e382 e382" linkend="HTMLPROF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) offer a mechanism 
for incorporating well-known existing vocabularies (such as
</textual><link class="po-inline e383 e383" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/SVG11/" xlink:show="new" xlink:type="simple"><textual class="po-textual">SVG</textual></link><textual class="po-textual">,
</textual><link class="po-inline e384 e384" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xforms/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XForms</textual></link><textual class="po-textual">,
or </textual><link class="po-inline e385 e385" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/MathML2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">MathML</textual></link><textual class="po-textual">)
into XHTML as part of the base vocabulary for dialects.
By definition, dialects of an XHTML profile are effectively dialects
of any superset XHTML profile.
</textual></para><para class="po-block e386 e386"><textual class="po-textual">Because of the importance of the class attribute in HTML,
XHTML Dialects might provide special operations beyond general-purpose dialects
to map markup type identifiers to microformat tokens in the class attribute
when serializing to base XHTML.</textual></para><note class="po-container e387 e387"><para class="po-block e388 e388"><textual class="po-textual">Extensible XHTML Dialects as discussed in this paper
are distinct from the antecedant to HTML profiles discussed 
in </textual><link class="po-inline e389 e389" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/WD-doctypes" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/WD-doctypes</textual></link><textual class="po-textual">.
</textual></para></note><section class="po-hcontainer e390 e390"><title class="po-block e391 e391"><textual class="po-textual">Deriving a document type for a microformat</textual></title><para class="po-block e392 e392"><textual class="po-textual">A microformat
(</textual><emphasis class="po-inline e393 e393" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e394 e394" linkend="MFOVER"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
is a structure expressed in HTML with inline annotations on attributes
identifying narrower semantics.
Thus, by definition, the same structure can be implemented as an XHTML Dialect.
An instance of the equivalent XHTML Dialect can be edited and validated with standard
XML tools but converted to a microformat instance when appropriate.</textual></para><para class="po-block e395 e395"><textual class="po-textual">For example, consider the draft geo microformat
(</textual><emphasis class="po-inline e396 e396" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e397 e397" linkend="MFGEO"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
a simple data structure for geographic coordinates.
Here is an example of the microformat:
</textual></para><programlisting class="po-block e398 e398" xml:space="preserve"><textual class="po-textual">
&lt;div class="geo"&gt;
  &lt;abbr class="latitude" title="37.408183"&gt;N 37° 24.491&lt;/abbr&gt; 
  &lt;abbr class="longitude" title="-122.13855"&gt;W 122° 08.313&lt;/abbr&gt;
&lt;/div&gt;
</textual></programlisting><para class="po-block e399 e399"><textual class="po-textual">The following actions can implement a XHTML dialect for the microformat: 
</textual></para><itemizedlist class="po-table e400 e400"><listitem class="po-container e401 e401"><para class="po-block e402 e402"><textual class="po-textual">Derive a geo dialect type from the div base.</textual></para></listitem><listitem class="po-container e403 e403"><para class="po-block e404 e404"><textual class="po-textual">Derive a latitude dialect type from the abbr base.</textual></para></listitem><listitem class="po-container e405 e405"><para class="po-block e406 e406"><textual class="po-textual">Derive a longitude dialect type from the abbr base.</textual></para></listitem><listitem class="po-container e407 e407"><para class="po-block e408 e408"><textual class="po-textual">Define a document type incorporating the geo dialect type
in a type set with the div base type so geo is available
in all div contexts.</textual></para></listitem><listitem class="po-container e409 e409"><para class="po-block e410 e410"><textual class="po-textual">Map the document type to an schema.</textual></para></listitem></itemizedlist><para class="po-block e411 e411"><textual class="po-textual">The schema could then validate a document instance similar
to following example:</textual></para><programlisting class="po-block e412 e412" xml:space="preserve"><textual class="po-textual">
&lt;geo&gt;
  &lt;latitude title="37.408183"&gt;N 37° 24.491&lt;/latitude&gt; 
  &lt;longitude title="-122.13855"&gt;W 122° 08.313&lt;/latitude&gt;
&lt;/geo&gt;
</textual></programlisting><para class="po-block e413 e413"><textual class="po-textual">The dialect representation is not only possible to validate
using standard XML tools but also, by hiding the base names and class
attribute noise, easier to interpret.
</textual></para><para class="po-block e414 e414"><textual class="po-textual">If an organization would like to adopt the geo type but needs
to associate a name with each location,
the designer can define a NamedGeo type that is broader than the geo type and
that contains a LocationName type as well as the latitude and longitude types.
Instances of the geo type can be converted to the NamedGeo type or extracted
from the NamedGeo type.
</textual></para><para class="po-block e415 e415"><textual class="po-textual">This simple geo structure merely scratches the surface of the
structures specified by the microformat project.
The hAtom microformat
(</textual><emphasis class="po-inline e416 e416" role="ital"><textual class="po-textual">see</textual></emphasis><textual class="po-textual"> </textual><xref class="po-milestone e417 e417" linkend="MFHATOM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
offers a more interesting structure that represents
the </textual><link class="po-inline e418 e418" xlink:actuate="onRequest" xlink:href="http://www.atomenabled.org/developers/syndication/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Atom
syndication format</textual></link><textual class="po-textual"> in XHTML.
As with other microformats, hAtom by definition can be represented as an XHTML dialect.
</textual></para><para class="po-block e419 e419"><textual class="po-textual">In addition, however, hAtom suggests the potential value of bridging
an existing XML vocabulary to an XHTML representation.
The bridge preserves the semantics of the the source vocabulary
and, in effect, gives the content an alternate serialization
as an XHTML document.
That option can be especially valuable for RESTful scenarios given
the emphasis on HTML as the preferred hypermedia representation of state.
</textual></para></section><section class="po-hcontainer e420 e420"><title class="po-block e421 e421"><textual class="po-textual">Benefits of XHTML Dialects</textual></title><para class="po-block e422 e422"><textual class="po-textual">Using XHTML Dialects to create vocabularies has the following
potential benefits:</textual></para><itemizedlist class="po-table e423 e423"><listitem class="po-container e424 e424"><para class="po-block e425 e425"><textual class="po-textual">Leverage XML tools and capabilities for validating vocabularies
and manifesting semantics directly as elements
(instead of annotating XHTML elements as in microformats).</textual></para></listitem><listitem class="po-container e426 e426"><para class="po-block e427 e427"><textual class="po-textual">Represent wikitext and wiki templates directly in XML
for interchange and easy conversion to HTML.</textual></para></listitem><listitem class="po-container e428 e428"><para class="po-block e429 e429"><textual class="po-textual">Simplify design for custom vocabularies by starting
from familar XHTML instead of from scratch.</textual></para></listitem><listitem class="po-container e430 e430"><para class="po-block e431 e431"><textual class="po-textual">Render custom vocabularies in browsers or in printable documents
via ePUB without having to write and maintain vocabulary-specific transforms,
instead using generic conversion to base XHTML.</textual></para></listitem><listitem class="po-container e432 e432"><para class="po-block e433 e433"><textual class="po-textual">Represent state with explicit semantics and validated content
as part of RESTful approaches while retaining the ability to revert to base XHTML
through content negotiation for consumers that understand only the XHTML representation.
</textual></para></listitem></itemizedlist><para class="po-block e434 e434"><textual class="po-textual">In short, XHTML Dialects offer a good solution for either data and discourse
when the content includes readable text or the deployment includes HTML environments.</textual></para></section></section><section class="po-hcontainer e435 e435"><title class="po-block e436 e436"><textual class="po-textual">Future work</textual></title><para class="po-block e437 e437"><textual class="po-textual">The Dialects proposal can benefit from additional prototyping,
experimentation, and discussion.
In particular, the following areas require more attention:</textual></para><itemizedlist class="po-table e438 e438"><listitem class="po-container e439 e439"><para class="po-block e440 e440"><textual class="po-textual">The graph might be capable of deriving a typed structure
from a string through a pattern that maps subfields of the string.</textual></para></listitem><listitem class="po-container e441 e441"><para class="po-block e442 e442"><textual class="po-textual">It may be possible to convert a document instance
when the base type of a source element has narrower content than the 
base type of the target element.
For instance, a span within a div could convert to a div within a div.</textual></para></listitem><listitem class="po-container e443 e443"><para class="po-block e444 e444"><textual class="po-textual">The graph might be capable of supporting conversions
to other base vocabularies that are supersets of the declared base vocabulary.</textual></para></listitem><listitem class="po-container e445 e445"><para class="po-block e446 e446"><textual class="po-textual">The binding between a type relation graph and
an XML vocabulary might not require a one-to-one mapping.
For instance, some vocabulary container elements might be cosmetic, 
and some container type might be inferrable.
</textual></para></listitem><listitem class="po-container e447 e447"><para class="po-block e448 e448"><textual class="po-textual">The graph might benefit from conveniences for defining a dialect type
as subsetting or supersetting changes on another type
(with generation of the fully defined type).
</textual></para></listitem><listitem class="po-container e449 e449"><para class="po-block e450 e450"><textual class="po-textual">An XHTML Dialect for serializing the graph would be
a good demonstration of the capabilities of Dialects and would be useful
for consuming portions of the graph through a RESTful service.
</textual></para><para class="po-block e451 e451"><textual class="po-textual">In passing, defining an XHTML 4 dialect with the new markup
of HTML 5 (especially the new discourse elements) would be another good test and
demonstrate a method for agile and experimental evolution of XHTML.
</textual></para></listitem><listitem class="po-container e452 e452"><para class="po-block e453 e453"><textual class="po-textual">A XHTML Dialect mechanism for defining a narrower document type
by example in an instance of a broader document type would reduce the barriers
for vocabulary designers.
</textual><link class="po-inline e454 e454" xlink:actuate="onRequest" xlink:href="http://examplotron.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Examplotron</textual></link><textual class="po-textual">
provides a precedent for this approach,
but the narrower types would require only names and model differences.
</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e455 e455"><title class="po-block e456 e456"><textual class="po-textual">Summary</textual></title><para class="po-block e457 e457"><textual class="po-textual">The Dialects proposal supplies a mechanism
for deriving new dialects from a base document type to support variant representations
of the knowledge for a domain without compromising the ability to exchange information
within a community.
Through upward expansion, Dialects can add new broader dialects as needed
to recognize commonality across dialects.
By making type relations available to applications, compatibility checks,
conversions, role-based processing, and schema generation become feasible
and interpretation becomes possible to formalize (leveraging RDF technologies).
In particular, XHTML Dialects can enrich the XHTML ecosystem
with extensions that validate existing microformats, bridge other XML
vocabularies, and represent special information with minimal or no transforms.
</textual></para></section><bibliography class="po-hcontainer e458 e458"><title class="po-block e459 e459"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e460 e460" xml:id="BAUMAN" xreflabel="BAUMAN"><textual class="po-textual">Bauman, Bruce Todd.
"Prying Apart Semantics and Implementation:
Generating XML Schemata directly from ontologically sound conceptual models."
Presented at Balisage: The Markup Conference 2009, Montréal, Canada,
August 11 - 14, 2009.
In Proceedings of Balisage: The Markup Conference 2009.
Balisage Series on Markup Technologies, vol. 3 (2009). doi: </textual><biblioid class="po-atom e461 doi e461"><textual class="po-textual">10.4242/BalisageVol3.Bauman01</textual></biblioid><textual class="po-textual">. 
  </textual><link class="po-inline e462 e462" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e463 e463" xml:id="CURIE" xreflabel="CURIE"><textual class="po-textual">Birbeck, Mark and McCarron, Shane, Ed.
"CURIE Syntax 1.0".
W3C, 16 Jan 2009.
  </textual><link class="po-inline e464 e464" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/curie/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/curie/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e465 e465" xml:id="DATTOLO" xreflabel="DATTOLO"><textual class="po-textual">Dattolo, Antonina et al.
"Converting into pattern-based schemas: a formal approach".
The Extreme Markup Conference, Montreal, Canada, 2007.
  </textual><link class="po-inline e466 e466" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2007/Dattolo01/EML2007Dattolo01.xml" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2007/Dattolo01/EML2007Dattolo01.xml</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e467 e467" xml:id="DITA" xreflabel="DITA"><textual class="po-textual">Priestley, Michael and Hackos, JoAnn, Ed.
"DITA Version 1.1 Architectural Specification".
OASIS, 31 May 2007.
  </textual><link class="po-inline e468 e468" xlink:actuate="onRequest" xlink:href="http://docs.oasis-open.org/dita/v1.1/CS01/archspec/ditaspecialization.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oasis-open.org/dita/v1.1/CS01/archspec/ditaspecialization.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e469 e469" xml:id="DOCBOOK" xreflabel="DOCBOOK"><textual class="po-textual">Walsh, Norman.
"DocBook 5: The Definitive Guide".
XML Press, 20 May 2010.
  </textual><link class="po-inline e470 e470" xlink:actuate="onRequest" xlink:href="http://www.docbook.org/tdg5/en/html/ch05.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.docbook.org/tdg5/en/html/ch05.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e471 e471" xml:id="DUCHARME" xreflabel="DUCHARME"><textual class="po-textual">DuCharme, Bob.
"Using RDFa with DITA and DocBook".
devx.com, 20 Aug 2009.
  </textual><link class="po-inline e472 e472" xlink:actuate="onRequest" xlink:href="http://www.devx.com/semantic/Article/42543/1954?pf=true" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.devx.com/semantic/Article/42543/1954?pf=true</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e473 e473" xml:id="MCGRATH" xreflabel="MCGRATH"><textual class="po-textual">McGrath, Sean.
"XML in legislature/parliament environments".
14 June 2010.
</textual><link class="po-inline e474 e474" xlink:actuate="onRequest" xlink:href="http://seanmcgrath.blogspot.com/2010/06/xml-in-legislatureparliament_14.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://seanmcgrath.blogspot.com/2010/06/xml-in-legislatureparliament_14.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e475 e475" xml:id="MFGEO" xreflabel="MFGEO"><textual class="po-textual">Çelik, Tantek, Ed.
"Geo"
microformats.org, 27 Nov 2009.
  </textual><link class="po-inline e476 e476" xlink:actuate="onRequest" xlink:href="http://microformats.org/wiki/geo" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://microformats.org/wiki/geo</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e477 e477" xml:id="MFHATOM" xreflabel="MFHATOM"><textual class="po-textual">Janes, David, Ed.
"hAtom 0.1"
microformats.org, 17 Apr 2010.
  </textual><link class="po-inline e478 e478" xlink:actuate="onRequest" xlink:href="http://microformats.org/wiki/hatom" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://microformats.org/wiki/hatom</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e479 e479" xml:id="MFGUIDE" xreflabel="MFGUIDE"><textual class="po-textual">Çelik, Tantek, Ed.
"hCalendar 1.0"
microformats.org, 6 May 2010.
  </textual><link class="po-inline e480 e480" xlink:actuate="onRequest" xlink:href="http://microformats.org/wiki/hcalendar#Semantic_XHTML_Design_Principles" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://microformats.org/wiki/hcalendar#Semantic_XHTML_Design_Principles</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e481 e481" xml:id="MFOVER" xreflabel="MFOVER"><textual class="po-textual">Messina, Chris et al, Ed.
"What are microformats?".
microformats.org, 10 Mar 2009.
  </textual><link class="po-inline e482 e482" xlink:actuate="onRequest" xlink:href="http://microformats.org/wiki/what-are-microformats" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://microformats.org/wiki/what-are-microformats</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e483 e483" xml:id="OGBUJI" xreflabel="OGBUJI"><textual class="po-textual">Ogbuji, Uche.
"Thinking XML: Enrich Schema definitions with SKOS".
DeveloperWorks, 11 Nov 2008.
  </textual><link class="po-inline e484 e484" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-think42/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibm.com/developerworks/xml/library/x-think42/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e485 e485" xml:id="ORCHARD" xreflabel="ORCHARD"><textual class="po-textual">Orchard, David.
"Extensibility, XML Vocabularies, and XML Schema".
xml.com, 27 Oct 2004.
  </textual><link class="po-inline e486 e486" xlink:actuate="onRequest" xlink:href="http://www.xml.com/lpt/a/1492" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xml.com/lpt/a/1492</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e487 e487" xml:id="OWLGUIDE" xreflabel="OWLGUIDE"><textual class="po-textual">Smith, Michael K. et al, Ed.
"OWL Web Ontology Language Guide".
W3C, 10 Feb 2004.
  </textual><link class="po-inline e488 e488" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/owl-guide/#term_openworld" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/owl-guide/#term_openworld</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e489 e489" xml:id="OWLOVER" xreflabel="OWLOVER"><textual class="po-textual">W3C OWL Working Group, Ed.
"OWL 2 Web Ontology Language Document Overview".
27 October 2009.
  </textual><link class="po-inline e490 e490" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/owl2-overview/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/owl2-overview/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e491 e491" xml:id="RDFA" xreflabel="RDFA"><textual class="po-textual">Adida, Ben et al, Ed.
"RDFa in XHTML: Syntax and Processing".
W3C, 14 Oct 2008.
  </textual><link class="po-inline e492 e492" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/rdfa-syntax/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/rdfa-syntax/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e493 e493" xml:id="RDFCONCEPT" xreflabel="RDFCONCEPT"><textual class="po-textual">Klyne, Graham and
Carroll, Jeremy J., Ed.
"Resource Description Framework (RDF): Concepts and Abstract Syntax".
W3C, 10 Feb 2004.
  </textual><link class="po-inline e494 e494" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/rdf-concepts/#section-anyone" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/rdf-concepts/#section-anyone</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e495 e495" xml:id="RDFSCHEMA" xreflabel="RDFSCHEMA"><textual class="po-textual">Brickley, Dan and Guha, R.V., Ed.
"RDF Vocabulary Description Language 1.0: RDF Schema".
W3C, 10 Feb 2004.
  </textual><link class="po-inline e496 e496" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/rdf-schema/#ch_subclassof" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/rdf-schema/#ch_subclassof</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e497 e497" xml:id="ROSCH" xreflabel="ROSCH"><textual class="po-textual">Rosch, E.
"Classification of Real-World Objects: Origins and Representations in Cognition"
in Johnson-Laird, P. and Wason, P, Ed.
"Thinking: Readings in Cognitive Science",
Cambridge University Press, 1977.
  </textual></bibliomixed><bibliomixed class="po-block e498 e498" xml:id="SCD" xreflabel="SCD"><textual class="po-textual">Holstege, Mary, and Vedamuthu, Asir S., Ed.
"W3C XML Schema Definition Language (XSD): Component Designators".
W3C, 19 Jan 2010.
  </textual><link class="po-inline e499 e499" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-ref/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-ref/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e500 e500" xml:id="SKOS" xreflabel="SKOS"><textual class="po-textual">Miles, Alistair and Bechhofer, Sean, Ed.
"SKOS Simple Knowledge Organization System Reference".
W3C, 18 Aug 2009.
  </textual><link class="po-inline e501 e501" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/skos-reference/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/skos-reference/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e502 e502" xml:id="TEI" xreflabel="TEI"><textual class="po-textual">Burnard, Lou and Bauman, Syd, Ed.
"P5: Guidelines for Electronic Text Encoding and Interchange".
TEI Consortium, Feb 12 2010.
  </textual><link class="po-inline e503 e503" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e504 e504" xml:id="HTMLPROF" xreflabel="HTMLPROF"><textual class="po-textual">W3C HTML Working Group.
"XHTML 1.0 The Extensible HyperText Markup Language (Second Edition)"
W3C, 1 Aug 2002.
  </textual><link class="po-inline e505 e505" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/html/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/html/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e506 e506" xml:id="XSD" xreflabel="XSD"><textual class="po-textual">Thompson, Henry S. et al, Ed.
"XML Schema Part 1: Structures Second Edition".
W3C, 28 Oct 2004.
  </textual><link class="po-inline e507 e507" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-1/#Type_Derivation" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-1/#Type_Derivation</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e508 e508" xml:id="WITTGENSTEIN" xreflabel="WITTGENSTEIN"><textual class="po-textual">Wittgenstein, Ludwig.
"Philosophical Investigations (3rd Edition)".
Prentice Hall, 1973.
</textual><emphasis class="po-inline e509 e509" role="ital"><textual class="po-textual">(especially sections 67 and 69)</textual></emphasis><textual class="po-textual">
  </textual></bibliomixed></bibliography></article></classedDocument>