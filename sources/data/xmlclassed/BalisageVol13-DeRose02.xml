<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">JSOX: A Justly Simple Objectization for XML</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Or: How to do better with Python and XML</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2014</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 5 - 8, 2014</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">XML can be as easy to work with as JSON. However, this has not been obvious until now. JSON is easy because it supports only datatypes that are already native to Javascript and uses the same syntax to access them (such as [1:10], ["x"], and </textual><quote class="po-inline e9 e9"><textual class="po-textual">.</textual></quote><textual class="po-textual"> notation). XML, on the other hand, supports additional datatypes, and is most commonly handled via SAX or DOM, both of which are low-level and meant to be cross-language. Typical developers want high-level access that feels </textual><quote class="po-inline e10 e10"><textual class="po-textual">native</textual></quote><textual class="po-textual"> in the language they are using. These shortcomings have little or nothing to do with XML, and can be remedied by a different API. Software that demonstrates this is presented and described. It uses Python's richer set of abstract datatypes (such as tuples and sets), and provides native Python style syntax with richer semantics than JSON or Javascript.</textual></para></abstract><author class="po-record e11 e11"><personname class="po-record e12 e12"><firstname class="po-field e13 e13"><textual class="po-textual">Steven</textual></firstname><othername class="po-field e14 e14"><textual class="po-textual">J.</textual></othername><surname class="po-field e15 e15"><textual class="po-textual">DeRose</textual></surname></personname><personblurb class="po-container e16 e16"><para class="po-block e17 e17"><textual class="po-textual">Steve DeRose has been working with electronic document and hypertext systems since joining Andries van Dam's FRESS project in 1979. He holds degrees in Computer Science and in Linguistics and a Ph.D. in Computational Linguistics from Brown University.</textual></para><para class="po-block e18 e18"><textual class="po-textual">He co-founded Electronic Book Technologies in 1989 to build the first SGML browser and retrieval system, </textual><quote class="po-inline e19 e19"><textual class="po-textual">DynaText,</textual></quote><textual class="po-textual"> and has been deeply involved in standards development including XML, TEI, HyTime, HTML 4, XPath, XPointer, EAD, Open eBook, OSIS, NLM and others. He has served as Chief Scientist of Brown University's Scholarly Technology Group and Adjunct Associate Professor of Computer Science. He has written many papers, two books, and eleven patents. Most recently he has been working as a consultant in text analytics.</textual></para></personblurb><affiliation class="po-record e20 e20"><jobtitle class="po-field e21 e21"><textual class="po-textual">Consultant</textual></jobtitle><orgname class="po-block e22 e22"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></orgname></affiliation><email class="po-field e23 e23"><textual class="po-textual">sderose@acm.org</textual></email></author><legalnotice class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">Copyright © 2014 by the author. Used with permission.</textual></para></legalnotice><keywordset class="po-table e26 e26" role="author"><keyword class="po-field e27 e27"><textual class="po-textual">Python</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">DOM</textual></keyword><keyword class="po-field e29 e29"><textual class="po-textual">API</textual></keyword><keyword class="po-field e30 e30"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e31 e31"><textual class="po-textual">JSON</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">Abstract collection types</textual></keyword><keyword class="po-field e33 e33"><textual class="po-textual">Markup Systems</textual></keyword><keyword class="po-field e34 e34"><textual class="po-textual">Data modeling</textual></keyword><keyword class="po-field e35 e35"><textual class="po-textual">Container (type theory)</textual></keyword></keywordset></info><section class="po-hcontainer e36 e36"><title class="po-block e37 e37"><textual class="po-textual">Introductory matters</textual></title><para class="po-block e38 e38"><textual class="po-textual">XML and JSON differ in how they punctuate data; this is obvious. Perhaps less obvious is how they differ in the topology and semantics they represent. They share a number of basic structures, and from 50,000 feet up they're both </textual><quote class="po-inline e39 e39"><textual class="po-textual">hierarchical.</textual></quote><textual class="po-textual"> This paper is concerned first with the superficial problem of syntax, where JSON has achieved a reputation in some quarters for being easier to use than XML; and second with the subtler but ultimately more important problem of data modeling.</textual></para><para class="po-block e40 e40"><textual class="po-textual">This papers intends to demonstrate in a practical way, that JSON's seeming advantage over XML in programming convenience actually has little to do with the languages, but much to do with how interfaces </textual><emphasis class="po-inline e41 e41" role="ital"><textual class="po-textual">to</textual></emphasis><textual class="po-textual"> them have been set up in various programming languages. I demonstrate a programming interface to XML data, that is far simpler to use than the APIs usually derived from DOM (). In addition, the API supports the stronger semantics and topology of XML, and so works not only for the simple cases JSON addresses, but also the countless cases where XML's richer selection of abstract data types is needed.</textual></para><para class="po-block e42 e42"><textual class="po-textual">This paper has two basic points to make:</textual></para><orderedlist class="po-table e43 e43"><listitem class="po-container e44 e44"><para class="po-block e45 e45"><textual class="po-textual">Programming languages can make it far easier to deal with XML, by using their native facilities for abstract collection types, instead of mechanically implementing the DOM API, which is not optimized for any particular language.</textual></para></listitem><listitem class="po-container e46 e46"><para class="po-block e47 e47"><textual class="po-textual">XML brings to the fore a particular abstract collection type that is not widely discussed, but follows logically from an analysis of other common types. Although this type may not arise so commonly in traditional </textual><quote class="po-inline e48 e48"><textual class="po-textual">data</textual></quote><textual class="po-textual"> tasks, it does arise all the time in dealing with documents. Trying to manage document-shaped information with arrays and hashes is (of course) possible, but exceedingly awkward. A much better solution is to implement the needed type, and make it as natural to deal with in programming, as arrays and hashes are now.</textual></para></listitem></orderedlist><para class="po-block e49 e49"><textual class="po-textual">Asking a developer in the 1950s about hash tables (or dictionaries or associative arrays), when all they had in their tools were arrays, would likely have provoked responses such as: </textual><quote class="po-inline e50 e50"><textual class="po-textual">Much too complicated.</textual></quote><textual class="po-textual">  </textual><quote class="po-inline e51 e51"><textual class="po-textual">Doesn't fit the way my tools work.</textual></quote><textual class="po-textual">  </textual><quote class="po-inline e52 e52"><textual class="po-textual">Programs just don't have to deal with that kind of thing very much.</textual></quote><textual class="po-textual">  </textual><quote class="po-inline e53 e53"><textual class="po-textual">Too much stuff in there.</textual></quote><textual class="po-textual">  </textual><quote class="po-inline e54 e54"><textual class="po-textual">You can build that all with stuff I've already got.</textual></quote><textual class="po-textual">  </textual><quote class="po-inline e55 e55"><textual class="po-textual">Clever, but not worth the effort.</textual></quote><textual class="po-textual">  Or even, </textual><quote class="po-inline e56 e56"><textual class="po-textual">If the experts who built Fortran didn't see it as necessary, why should I?</textual></quote><textual class="po-textual"> These were also common responses to Unicode, to object-orientation, and to multi-threading. They are much the same arguments made now against XML. And although none of these features has become completely ubiquitous, few developers would oppose built-in support for them.</textual><footnote class="po-popup e57 e57"><para class="po-block e58 e58"><textual class="po-textual">In a discussion at </textual><link class="po-inline e59 e59" xlink:actuate="onRequest" xlink:href="http://programmers.stackexchange.com/questions/173573/history-of-associative-array" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://programmers.stackexchange.com/questions/173573/history-of-associative-array</textual></link><textual class="po-textual">, Yannis Rizos suggests that Snobol was the first language (around 1967) to provide a dictionary-like tool built in, which it called </textual><quote class="po-inline e60 e60"><textual class="po-textual">tables</textual></quote><textual class="po-textual">: </textual><quote class="po-inline e61 e61"><textual class="po-textual">A table is similar to a one-dimensional array. However, instead of referencing an element with an integer, any data object can be used.</textual></quote><textual class="po-textual"> (</textual><citation class="po-atom e62 e62" linkend="Gri68"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, p. 19) For example, </textual><code class="po-atom e63 e63"><textual class="po-textual">T&lt;'A'&gt; = 5</textual></code><textual class="po-textual">.</textual></para></footnote></para><para class="po-block e64 e64"><textual class="po-textual">As with hashes, Unicode, and other advances, I think the key is to build support into the fabric of programming. When developers have to understand Unicode to make their code Unicode-safe, they're unlikely to put in the effort — they have better things to do, or at least, things much more obviously related to the task at hand. Rather, the few character-set specialists need to build Unicode-awareness and Unicode-safety into the system libraries and utilities (just try feeding Unicode to the usual *nix commands!), so they fade into the background and become just the </textual><quote class="po-inline e65 e65"><textual class="po-textual">expected</textual></quote><textual class="po-textual"> behavior. Then developers with better things to do, will use them — and (if the Unicode folks do their implementations right) will notice (perhaps long after) that their systems work better. Meanwhile, their managers may notice that they can sell in new areas with minimal new development costs.</textual></para><para class="po-block e66 e66"><textual class="po-textual">I begin, then, with a look at basic abstract collection types, and at JSON (</textual><citation class="po-atom e67 e67" linkend="Cro06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">), Javascript (</textual><citation class="po-atom e68 e68" linkend="ECM11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">), XML (</textual><citation class="po-atom e69 e69" linkend="Bra08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">), and DOM (</textual><citation class="po-atom e70 e70" linkend="LeH04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">) in light of the types they use and the syntax commonly provided for getting at them. The main portion of the paper then examines the more general notion of abstract collection types, some data's need (and XML's support) for a type that JSON does not provide, and the design and implementation of an interface in Python, to that additional abstract collection type. Given that abstract collection type (which is useful for many things besides XML), a syntactically-native, language-appropriate, easy-to-use interface to XML's more general data becomes easy.</textual></para><section class="po-hcontainer e71 e71"><title class="po-block e72 e72"><textual class="po-textual">On very basic data and collection types</textual></title><para class="po-block e73 e73"><textual class="po-textual">Atomic datatypes such as numbers, strings, and Booleans, are ubiquitous in programming, and the problems they pose are, if annoying, at least familiar: </textual><code class="po-atom e74 e74"><textual class="po-textual">False</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e75 e75"><textual class="po-textual">#F</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e76 e76"><textual class="po-textual">0</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e77 e77"><textual class="po-textual">nil</textual></code><textual class="po-textual">; </textual><code class="po-atom e78 e78"><textual class="po-textual">99</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e79 e79"><textual class="po-textual">99</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e80 e80"><textual class="po-textual">"099"</textual></code><textual class="po-textual">; and a variety of challenges that arise from mathematical and real-world characteristics such as precision, spelling complexity and variability, etc.</textual></para><para class="po-block e81 e81"><textual class="po-textual">Arrays are lists of data items, with the items commonly of atomic types, but in general of any types. Arrays are organized merely by position, generally using non-negative integers. High-level programming languages have included them for a very long time, and the syntax for accessing them is generally similar, although programming languages avoid the literal subscripts we all learned in early math classes. Developers are used to accommodating punctuation differences as they change from one language to another: </textual><code class="po-atom e82 e82"><textual class="po-textual">$myArray[0]</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e83 e83"><textual class="po-textual">myArray(1)</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e84 e84"><textual class="po-textual">item 7 of myArray</textual></code><textual class="po-textual">.</textual></para><para class="po-block e85 e85"><textual class="po-textual">Dictionaries, hashes, or associative arrays instead organize their members via a second piece of data for each: a </textual><quote class="po-inline e86 e86"><textual class="po-textual">name</textual></quote><textual class="po-textual"> or </textual><quote class="po-inline e87 e87"><textual class="po-textual">key</textual></quote><footnote class="po-popup e88 e88"><para class="po-block e89 e89"><textual class="po-textual">Properly speaking, </textual><quote class="po-inline e90 e90"><textual class="po-textual">hash table</textual></quote><textual class="po-textual"> is a data structure very commonly used to implement such keyed collections (binary search trees are another); but the terms are commonly used interchangeably.</textual></para></footnote><textual class="po-textual">. They are not so ubiquitously built in as arrays.
Their punctuation similarly varies: </textual><code class="po-atom e91 e91"><textual class="po-textual">h = [ a=&gt;1, b=&gt;2 ]</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e92 e92"><textual class="po-textual">h = { 'a':1, n:'2' }</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e93 e93"><textual class="po-textual">h["a"]=1, h["b"]=2</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e94 e94"><textual class="po-textual">(hash ('a 1) ('b 2))</textual></code><textual class="po-textual">, and so on).</textual></para><para class="po-block e95 e95"><textual class="po-textual">With minor variations, these types are simple and widespread. Many programming languages provide special syntax for each of them; thus, if you know the programming language, you know the syntax for using these types. That is a nice advantage when you deal with data that is accurately modeled with these types.</textual></para><para class="po-block e96 e96"><textual class="po-textual">It is important to keep in mind that there are several levels of abstraction here. A file containing </textual><code class="po-atom e97 e97"><textual class="po-textual">[ 1, 2, 3 ]</textual></code><textual class="po-textual"> is not an array; it </textual><emphasis class="po-inline e98 e98" role="ital"><textual class="po-textual">represents</textual></emphasis><textual class="po-textual"> one (it may actually </textual><quote class="po-inline e99 e99"><textual class="po-textual">be</textual></quote><textual class="po-textual"> holes in a piece of compressed wood-pulp); or it might represent a vector in a left-handed non-orthogonal 3-space. It might be loaded into 12 bytes of RAM, intended to be interpreted as 3 32-bit (signed?) integers; or Javascript commonly represents arrays as hashes, by converting the indices from integers to strings that it then hashes. Russel and others represent an integer </textual><code class="po-atom e100 e100"><textual class="po-textual">n</textual></code><textual class="po-textual"> as a set nested </textual><code class="po-atom e101 e101"><textual class="po-textual">n</textual></code><textual class="po-textual">-levels deep. And in the end, all of these are merely representations of an abstract notion of quantity that cannot be directly perceived. For present purposes we need not contend with all this ontological complexity; but the differences between these notions are central:</textual></para><orderedlist class="po-table e102 e102"><listitem class="po-container e103 e103"><para class="po-block e104 e104"><textual class="po-textual">The representation of data via a sequence of characters in a text file. For example </textual><code class="po-atom e105 e105"><textual class="po-textual">{ 'a':1, 'b':2, 'c':"\u2172" }</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e106 e106"><para class="po-block e107 e107"><textual class="po-textual">The data structure created from the representation via </textual><quote class="po-inline e108 e108"><textual class="po-textual">loading,</textual></quote><textual class="po-textual"> composed of constructs implemented by those who implement a given programming language. For example, a contiguous sequence of 12 bytes, preceded by 8 extra bytes of overhead such as the width (4) of the entries, the total length of the area, who owns it, etc.</textual></para></listitem><listitem class="po-container e109 e109"><para class="po-block e110 e110"><textual class="po-textual">The interface provided to those data structures for application programmers. For example, </textual><code class="po-atom e111 e111"><textual class="po-textual">myArray</textual></code><textual class="po-textual">, or </textual><code class="po-atom e112 e112"><textual class="po-textual">myArray[1]</textual></code><textual class="po-textual"> or </textual><code class="po-atom e113 e113"><textual class="po-textual">myArray.1</textual></code><textual class="po-textual"> for the second item.</textual></para></listitem></orderedlist></section><section class="po-hcontainer e114 e114"><title class="po-block e115 e115"><textual class="po-textual">On JSON and Javascript's abstract collection types</textual></title><para class="po-block e116 e116"><textual class="po-textual">JSON (JavaScript Object Notation) is a way of representing certain data collections as text files. JSON, for most purposes, simply </textual><quote class="po-inline e117 e117"><textual class="po-textual">is</textual></quote><textual class="po-textual"> a part of Javascript: a valid JSON file can be pasted in as the right-hand-side of a Javascript assignment statement, and should </textual><quote class="po-inline e118 e118"><textual class="po-textual">just work</textual></quote><textual class="po-textual">. The reverse is true for simple cases, though not in general. In my opinion, this is by far the largest factor in JSON's reputed ease of use:</textual></para><orderedlist class="po-table e119 e119"><listitem class="po-container e120 e120"><para class="po-block e121 e121"><textual class="po-textual">JSON supports just the same </textual><emphasis class="po-inline e122 e122" role="ital"><textual class="po-textual">abstract collection types</textual></emphasis><textual class="po-textual"> as Javascript: array (sort of) and dictionary. Thus, the mapping from JSON's idea of how data can be structured, to Javascript's, is trivial; there essentially isn't a </textual><quote class="po-inline e123 e123"><textual class="po-textual">mapping</textual></quote><textual class="po-textual"> at all.</textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">It supports most of the same </textual><emphasis class="po-inline e126 e126" role="ital"><textual class="po-textual">scalar types</textual></emphasis><textual class="po-textual">: integer, floating point number, Boolean, and string.</textual></para></listitem><listitem class="po-container e127 e127"><para class="po-block e128 e128"><textual class="po-textual">Its syntax is almost the same as expressions in Javascript. One exception is that one can't interpolate variables, such as </textual><code class="po-atom e129 e129"><textual class="po-textual">[ 1, myVar, "c",...  ]</textual></code><textual class="po-textual">, so one cannot factor out heavily-reused pieces of data except by introducing conventions outside JSON's awareness. Thus JSON as a representation is slightly </textual><emphasis class="po-inline e130 e130" role="ital"><textual class="po-textual">less</textual></emphasis><textual class="po-textual"> capable than Javascript; but within it's capabilities it </textual><quote class="po-inline e131 e131"><textual class="po-textual">is</textual></quote><textual class="po-textual"> Javascript.</textual></para></listitem><listitem class="po-container e132 e132"><para class="po-block e133 e133"><textual class="po-textual">Once loading some JSON is finished (which, like saving, can be a one-step process, for example via </textual><code class="po-atom e134 e134"><textual class="po-textual">eval(...)</textual></code><textual class="po-textual">), the programmer accesses any part of the (formerly JSON) data structure just as if it were the same data declared as native constants in Javascript.</textual></para></listitem></orderedlist><para class="po-block e135 e135"><textual class="po-textual">These are all legitimate virtues of JSON. They are greatest for the Javascript programmer, but similar advantages apply in many programming languages because similar basic types are common.</textual></para><para class="po-block e136 e136"><textual class="po-textual">Javascript's (hence JSON's) selection of abstract collection types, while simple, is even smaller than programmers are used to dealing with. If anything, it is slightly too small, because there is considerable confusion about Javascript's arrays and dictionaries.</textual></para><para class="po-block e137 e137"><textual class="po-textual">Javascript objects are essentially dictionaries, in that they can have properties which are unordered and are accessed by name, such as </textual><code class="po-atom e138 e138"><textual class="po-textual">obj.myProp</textual></code><textual class="po-textual">. Thus, there is not independent dictionary type.</textual></para><para class="po-block e139 e139"><textual class="po-textual">There is an </textual><code class="po-atom e140 e140"><textual class="po-textual">Array</textual></code><textual class="po-textual"> constructor, which makes objects that support the usual array/list operations (including </textual><code class="po-atom e141 e141"><textual class="po-textual">sort</textual></code><textual class="po-textual">), and whose members can be accessed by </textual><code class="po-atom e142 e142"><textual class="po-textual">a[2]</textual></code><textual class="po-textual"> syntax. They can be initialized with syntax like </textual><code class="po-atom e143 e143"><textual class="po-textual">a = [ 1, 2, 3 ]</textual></code><textual class="po-textual">.</textual></para><para class="po-block e144 e144"><textual class="po-textual">So far, this is mostly as one would expect. However, an object's members can also be accessed with array syntax: </textual><code class="po-atom e145 e145"><textual class="po-textual">obj["myProp"]</textual></code><textual class="po-textual">. This accesses the same property as </textual><code class="po-atom e146 e146"><textual class="po-textual">obj.myProp].</textual></code><textual class="po-textual"> But if you assign </textual><code class="po-atom e147 e147"><textual class="po-textual">obj[99] = "hello"</textual></code><textual class="po-textual">, the integer 99 is converted to the string </textual><quote class="po-inline e148 e148"><textual class="po-textual">99</textual></quote><textual class="po-textual">, and </textual><code class="po-atom e149 e149"><textual class="po-textual">obj</textual></code><textual class="po-textual"> gains a property named </textual><quote class="po-inline e150 e150"><textual class="po-textual">99</textual></quote><textual class="po-textual"> (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array). One could access it as </textual><code class="po-atom e151 e151"><textual class="po-textual">obj.99</textual></code><textual class="po-textual"> except that Javascript syntax does not allow numbers as operands of </textual><quote class="po-inline e152 e152"><textual class="po-textual">.</textual></quote><textual class="po-textual">. Likewise, if assigning </textual><code class="po-atom e153 e153"><textual class="po-textual">a["2"] = "bar"</textual></code><textual class="po-textual"> affects the same member as </textual><code class="po-atom e154 e154"><textual class="po-textual">a[2] = "bar"</textual></code><textual class="po-textual">.</textual></para><para class="po-block e155 e155"><textual class="po-textual">The killer, however, is this: if you explicitly create an array, you can still index into it with non-integers: </textual><code class="po-atom e156 e156"><textual class="po-textual">a["foo"] = "bar"</textual></code><textual class="po-textual">. You can set and get such members. However, the value of </textual><code class="po-atom e157 e157"><textual class="po-textual">a.length</textual></code><textual class="po-textual"> does not change unless those strings; it is defined as the number (property name) of the last non-negative-number-named element, plus 1. Obviously that means that arrays start at 0. You can happily assign to other numeric indices (quoted or not): x[3.0] = 1; x[0.3e3] = 1; x[3.000000000000000001] = 1; x[3.1] = 0; </textual><code class="po-atom e158 e158"><textual class="po-textual">x[-1] = 1; </textual></code><textual class="po-textual">. However, only the first three of those five become part of the </textual><quote class="po-inline e159 e159"><textual class="po-textual">array</textual></quote><textual class="po-textual">; the others quietly become properties instead (therefore still accessible as, for example, </textual><code class="po-atom e160 e160"><textual class="po-textual">x[3.1]</textual></code></para><para class="po-block e161 e161"><textual class="po-textual">As far as I can tell, this amounts to Javascript having only dictionaries, not arrays, as data structures, but both as API (the </textual><code class="po-atom e162 e162"><textual class="po-textual">Array</textual></code><textual class="po-textual"> constructor makes an object with extra properties and methods such as </textual><code class="po-atom e163 e163"><textual class="po-textual">length</textual></code><textual class="po-textual">, </textual><code class="po-atom e164 e164"><textual class="po-textual">sort</textual></code><textual class="po-textual">, etc.). Array methods work so long as you behave just so. For example, if you make an Array and assign to </textual><code class="po-atom e165 e165"><textual class="po-textual">a["foo"]</textual></code><textual class="po-textual"> or </textual><code class="po-atom e166 e166"><textual class="po-textual">a[3.1]</textual></code><textual class="po-textual">, it does create </textual><code class="po-atom e167 e167"><textual class="po-textual">a.foo</textual></code><textual class="po-textual">; but (for example) </textual><code class="po-atom e168 e168"><textual class="po-textual">a.length</textual></code><textual class="po-textual"> does not increase.</textual></para><para class="po-block e169 e169"><textual class="po-textual">Implementing other abstract collection types using only dictionaries is (as with all Turing-computable matters) possible, but awkward compared to using types whose semantics and consequent APIs directly match the problem at hand. In Javascript's case, Arrays are fairly intuitive so long as you carefully follow the implicit rules (rules that are not checked by the language at all). If you bump up against the edges, things get messy.</textual></para></section><section class="po-hcontainer e170 e170"><title class="po-block e171 e171"><textual class="po-textual">On XML's abstract collection types</textual></title><para class="po-block e172 e172"><textual class="po-textual">XML must handle documents; that is its reason for existence. While it has proven useful for many other things, such as configuration files, database interchange, and even sensor data transfer in automative systems, handling all those at the cost of being effective for documents would be failure.</textual></para><para class="po-block e173 e173"><textual class="po-textual">So what is a document, really? Document structuring and representation clearly require at least three things (</textual><citation class="po-atom e174 e174" linkend="Coo87"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, </textual><citation class="po-atom e175 e175" linkend="DeR90"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">):</textual></para><orderedlist class="po-table e176 e176"><listitem class="po-container e177 e177"><para class="po-block e178 e178"><emphasis class="po-inline e179 e179" role="ital"><textual class="po-textual">order</textual></emphasis><textual class="po-textual"> (this paragraph comes before that one)</textual></para></listitem><listitem class="po-container e180 e180"><para class="po-block e181 e181"><emphasis class="po-inline e182 e182" role="ital"><textual class="po-textual">hierarchy</textual></emphasis><textual class="po-textual"> (this chapter contains that section, or this strophe contains that stanza)</textual></para></listitem><listitem class="po-container e183 e183"><para class="po-block e184 e184"><textual class="po-textual">a wide variety of </textual><emphasis class="po-inline e185 e185" role="ital"><textual class="po-textual">names</textual></emphasis></para></listitem></orderedlist><para class="po-block e186 e186"><textual class="po-textual">Disregarding the order of speeches in one scene of a play, or of the steps in a repair procedure, both lead to absurdity. That is not to say that </textual><emphasis class="po-inline e187 e187" role="ital"><textual class="po-textual">everything</textual></emphasis><textual class="po-textual"> in XML is ordered; attributes are not, by definition; some bibliography schemas care not how the components of each entry are ordered; and there are many other cases. But XML does need to support order to support documents.</textual></para><para class="po-block e188 e188"><textual class="po-textual">Hierarchy is also essential — it can makes a great deal of difference whether this footnote (or quotation, or other object) is part of one section (or pericope, or procedure), vs. another. Again, not </textual><emphasis class="po-inline e189 e189" role="ital"><textual class="po-textual">everything</textual></emphasis><textual class="po-textual"> is very hierarchical; front-matter may simply be a long, flat list of metadata items.</textual></para><para class="po-block e190 e190"><textual class="po-textual">Finally, the type-names of various components are extremely important. Aircraft repair manuals contain a variety of warnings, some of which may have mandatory layout requirements so they cannot be lost in fine print. Citations and bibliographies are very important in some genres. Sacred texts are very careful about the distinction between (canonical) content and (merely convenient) annotations. Document representations have reified such linguistic categories, so they can be used for all kinds of processing: </textual><quote class="po-inline e191 e191"><textual class="po-textual">Lay out footnotes this way</textual></quote><textual class="po-textual">; </textual><quote class="po-inline e192 e192"><textual class="po-textual">Retrieve all the distinct conference proceedings from the bibliography</textual></quote><textual class="po-textual">; </textual><quote class="po-inline e193 e193"><textual class="po-textual">Check that all the verses are present in this translation of the Gospel of John</textual></quote><textual class="po-textual">; </textual><quote class="po-inline e194 e194"><textual class="po-textual">Build a table of contents from the first 'title' element in each 'div' not nested more than 3 divs deep</textual></quote><textual class="po-textual">; and so on.</textual></para><para class="po-block e195 e195"><textual class="po-textual">Element type names are handles by which humans organize their thoughts into writing; they are also the usual keys by which processing is triggered, much like class and method names in programming. This function can be moved around syntactically, but remains central (there is a reason that </textual><code class="po-atom e196 e196"><textual class="po-textual">&lt;span class="p"&gt;</textual></code><textual class="po-textual"> looks strange).</textual></para><para class="po-block e197 e197"><textual class="po-textual">At a minimum, any representation that purports to handle documents needs to support
these capabilities. Child-nodes must be accessible by both name and position, and multiple children of the same type must be permissible.</textual></para><section class="po-hcontainer e198 e198"><title class="po-block e199 e199"><textual class="po-textual">An example of a trivial document portion</textual></title><para class="po-block e200 e200"><textual class="po-textual">It is sadly true that those who argue that JSON, SQL, or other </textual><quote class="po-inline e201 e201"><textual class="po-textual">data</textual></quote><textual class="po-textual"> formats are perfectly adequate for documents, rarely show any examples of realistic documents. Rather, the examples virtually always lack hierarchy; even more frequently lack mixed content (an extraordinarily important omission); often have no relevant order; and usually include nothing notionally like attributes (such as properties of elements as wholes; the occasional exception is IDs).</textual></para><para class="po-block e202 e202"><textual class="po-textual">Such examples are unconvincing.</textual></para><para class="po-block e203 e203"><textual class="po-textual">CSV and its kin cannot handle documents well because they lack hierarchy; because (in theory though seldom in practice) they lack order), and because while they may have names (for fields) they lack the ability to put named objects in meaningful orders. About the best you can do is (</textual><citation class="po-atom e204 e204" linkend="Way01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, sec. 10):</textual></para><programlisting class="po-block e205 e205" xml:space="preserve"><textual class="po-textual">"h1", "10: The Argonauts"
...
"p", But the hero essayed to hush their laments and assuage their pain
With words of cheer, and he spake,"
"quo", "Take up my war-array,"
"p-resume", "To the thralls, and with downcast eyes did these in silence obey."
</textual></programlisting><para class="po-block e206 e206"><textual class="po-textual">Even in this tiny and unusually simple snippet there are many problems: After the quotation the containing paragraph ought to continue on, but because there is no hierarchy some hack must be used to re-start it. The same thing would happen if we tried to separate the section-heading's number and title; reality is far more complex.</textual></para><para class="po-block e207 e207"><textual class="po-textual">Documents require an abstract collection type that permits two important kinds of retrieval at every level of a hierarchy: By order (for global processing such as rendering, indexing, and the like); as well as by position (for many analytic and transformation processes). Moreover, these need to work together. Users must be able to refer to things like </textual><quote class="po-inline e208 e208"><textual class="po-textual">the 3rd footnote in chapter 4,</textual></quote><textual class="po-textual"> </textual><quote class="po-inline e209 e209"><textual class="po-textual">the last word of each speech attributed to Medea,</textual></quote><textual class="po-textual"> </textual><quote class="po-inline e210 e210"><textual class="po-textual">all the images,</textual></quote><textual class="po-textual"> and so on.</textual></para><para class="po-block e211 e211"><textual class="po-textual">JSON is vastly more capable than CSV, and so can make a more credible attempt to represent documents; the presence of hierarchy is particularly helpful. But the unavailability of collections whose members are both ordered and named still makes it awkward, and to my knowledge JSON has never been seriously used for substantial documents, such as books, articles, manuals, and so on. It is hard to see a general solution much cleaner than this, because arrays are needed to keep order, while something else is needed to distinguish attributes (which form a dictionary) from sub-elements and text:</textual></para><programlisting class="po-block e212 e212" xml:space="preserve"><textual class="po-textual">
{ "book": [
  { "section": [
    { "title": [
      { "n": 10 },
      "The Argonauts"
    ]},
    { "p": [
      "But the hero essayed to hush their laments and assuage their pain
       With words of cheer, and he spake, ",
      { "quo": [
        "Take up my war-array,"
      ]},
      " To the thralls, and with downcast eyes did these in silence obey."
    ]}
  ]}
]}
</textual></programlisting><para class="po-block e213 e213"><textual class="po-textual">This does represent
the needed relationships of precedence and containment; but it is
far less readable and far more error-prone than XML.</textual></para><programlisting class="po-block e214 e214" xml:space="preserve"><textual class="po-textual">&lt;book&gt;
  &lt;section&gt;
    &lt;title&gt;&lt;n&gt;10&lt;/n&gt; The Argonauts&lt;/title&gt;
    &lt;p&gt;But the hero essayed to hush their laments and assuage their pain
    With words of cheer, and he spake,
    &lt;quo&gt;Take up my war-array,&lt;/quo&gt;
    To the thralls, and with downcast eyes did these in silence obey.&lt;/p&gt;
  &lt;/section&gt;
&lt;/book&gt;
</textual></programlisting><para class="po-block e215 e215"><textual class="po-textual">Having an abstract collection type that actually corresponds to document topology is simply cleaner. A programming language can provide an appropriate interface to that abstract collection type, and thus enable a much clearer and easier interface to XML than hammering XML-shaped pegs into JSON-shaped holes (however nice the latter's fit for JSON-shaped pegs may be).</textual></para><para class="po-block e216 e216"><textual class="po-textual">Python has a rich collection of abstract collection types; rich enough to reveal that the type XML most needs, while not built in, fits into a slot implied by the relationships of abstract collection types that are already available in Python. This type's properties are predicted by symmetry: the same distinctive properties displayed by types already observed can be combined in another way.</textual></para><para class="po-block e217 e217"><textual class="po-textual">Defining the missing type is one small step for Python. But having taken that step, XML can be treated in Python much as JSON is treated in Javascript. An implementation in this form makes use of XML in Python nearly as trivial as use of JSON in Javascript. And although support for abstract collection types in Python is particularly strong, analogous APIs for XML can be made with little more work in other languages, vastly simplifying use of XML for developers in general.</textual></para></section><section class="po-hcontainer e218 e218"><title class="po-block e219 e219"><textual class="po-textual">On DOM</textual></title><para class="po-block e220 e220"><textual class="po-textual">DOM, the </textual><quote class="po-inline e221 e221"><textual class="po-textual">Document Object Model,</textual></quote><textual class="po-textual"> is a standard, widely-used interface to XML structure. The term </textual><quote class="po-inline e222 e222"><textual class="po-textual">Object Model</textual></quote><textual class="po-textual"> can mean either the set of formal properties of some data object, or a collection of classes and APIs for accessing something. DOM involves mainly the second sense: it is essentially an API.</textual></para><para class="po-block e223 e223"><textual class="po-textual">But DOM is not XML, nor the complete object model of XML in the first sense (although it constrains many things about that object model), nor the only way a programmer can access XML data. This paper discusses an alternative way of dealing with XML in programs, yielding the desired simplification for programmers:</textual></para><orderedlist class="po-table e224 e224"><listitem class="po-container e225 e225"><para class="po-block e226 e226"><textual class="po-textual">DOM was designed generically rather than with any particular programming language in mind. It is thus not optimized to feel native in Javascript or Python or C++ or anything else. When mechanically implemented, it speaks with an accent. But this has nothing to do with XML syntax or semantics, and building more native interfaces is not that hard.</textual></para></listitem><listitem class="po-container e227 e227"><para class="po-block e228 e228"><textual class="po-textual">DOM includes two levels in the one notion of Node: A Node in itself, and its context in a tree. While perfectly reasonable, this portmanteau approach makes DOM nodes seem much more complex than need be. In addition, there are general features such as userData, namespaces, isSupported, etc. to complicate matters.</textual></para></listitem><listitem class="po-container e229 e229"><para class="po-block e230 e230"><textual class="po-textual">DOM defines many subclasses of Node, corresponding to SGML syntactic constructs (comments, PIs, documents, etc.), and for HTML the much lower level of individual element types (p, li, i, etc.). This complicates the API to be learned; conceptually, it is as reasonable to think of XML as including only two Node types: elements and leaves; or even 1: Nodes, some of which contain other Nodes and some of which don't.</textual></para></listitem><listitem class="po-container e231 e231"><para class="po-block e232 e232"><textual class="po-textual">DOM is a quite low-level interface. For example, it does not provide any way to get the 3rd </textual><quote class="po-inline e233 e233"><textual class="po-textual">p</textual></quote><textual class="po-textual"> element child of a given node; nor even the 3rd </textual><emphasis class="po-inline e234 e234" role="ital"><textual class="po-textual">element</textual></emphasis><textual class="po-textual"> as opposed to text nodes. The latter is particularly annoying
because text nodes are in many contexts reliably whitespace-only and irrelevant to most or all processing (it is frustrating to write or even just call the same filtering code so many times). Providing higher-level operations helps immensely, as the popularity of libraries such as JQuery (</textual><citation class="po-atom e235 e235" linkend="JQu"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">) attests.</textual></para></listitem></orderedlist></section></section><section class="po-hcontainer e236 e236"><title class="po-block e237 e237"><textual class="po-textual">Common operations on arrays and dictionaries</textual></title><para class="po-block e238 e238"><textual class="po-textual">Arrays and dictionaries are very common; they are reasonably thought of as the
simplest collection types: one accessed by integer </textual><quote class="po-inline e239 e239"><textual class="po-textual">indices,</textual></quote><textual class="po-textual"> and one by string (usually) </textual><quote class="po-inline e240 e240"><textual class="po-textual">keys</textual></quote><textual class="po-textual">. This glosses over many differences in theory, implementation, and use, but will suffice for the moment. Some common operations are shown here, for a plain Javascript/JSON array, and for the children of a DOM node (other aspects of XML and of DOM are discussed later).</textual></para><table class="po-container e241 e241"><tbody class="po-table e242 e242"><tr class="po-table e243 e243"><th class="po-field e244 e244"><textual class="po-textual">Description</textual></th><th class="po-field e245 e245"><textual class="po-textual">Javascript</textual></th><th class="po-field e246 e246"><textual class="po-textual">Javascript DOM</textual></th></tr><tr class="po-table e247 e247"><td class="po-block e248 e248"><textual class="po-textual">Get first item</textual></td><td class="po-block e249 e249"><textual class="po-textual">n[0]</textual></td><td class="po-block e250 e250"><textual class="po-textual">n.firstChild</textual></td></tr><tr class="po-table e251 e251"><td class="po-block e252 e252"><textual class="po-textual">Get second item</textual></td><td class="po-block e253 e253"><textual class="po-textual">n[1]</textual></td><td class="po-block e254 e254"><textual class="po-textual">n.childNodes(1)</textual></td></tr><tr class="po-table e255 e255"><td class="po-block e256 e256"><textual class="po-textual">Items 1-3</textual></td><td class="po-block e257 e257"><textual class="po-textual">n.slice(0, 3)</textual></td><td class="po-block e258 e258"><textual class="po-textual">n.childNodes.slice(0,3)</textual></td></tr><tr class="po-table e259 e259"><td class="po-block e260 e260"><textual class="po-textual">"eggs" attribute"</textual></td><td class="po-block e261 e261"><textual class="po-textual">n.eggs</textual></td><td class="po-block e262 e262"><textual class="po-textual">n.getAttribute("eggs")</textual></td></tr><tr class="po-table e263 e263"><td class="po-block e264 e264"><textual class="po-textual">two items equivalent</textual></td><td class="po-block e265 e265"><textual class="po-textual">n1 == n2</textual></td><td class="po-block e266 e266"><textual class="po-textual">n1.isEqualNode(n2)</textual></td></tr><tr class="po-table e267 e267"><td class="po-block e268 e268"><textual class="po-textual">two items identical</textual></td><td class="po-block e269 e269"><textual class="po-textual">n1 === n2</textual></td><td class="po-block e270 e270"><textual class="po-textual">n1.isSameNode(n2)</textual></td></tr><tr class="po-table e271 e271"><td class="po-block e272 e272"><textual class="po-textual">replace item 3</textual></td><td class="po-block e273 e273"><textual class="po-textual">n1[2] = n3</textual></td><td class="po-block e274 e274"><textual class="po-textual">n1.replaceChild(n2, n3)</textual></td></tr></tbody></table><para class="po-block e275 e275"><textual class="po-textual">The Javascript is obviously shorter, cleaner, and perhaps most important, in keeping with the rest of the language (ignoring the grey area where arrays and dictionaries meet, discussed earlier). Of course there is more to a DOM Node; but these illustrate some of the most common operations.</textual></para><para class="po-block e276 e276"><textual class="po-textual">Already we can see a simple way to make XML structures far easier
to deal with in programming languages with even minimal collection structures: Just use the native array and dictionary syntax instead of functions, for XML constructs that are accessed that way. For example, instead of writing </textual><code class="po-atom e277 e277"><textual class="po-textual">c = n.childNodes[3]</textual></code><textual class="po-textual">,
just say </textual><code class="po-atom e278 e278"><textual class="po-textual">c = n[3]</textual></code><textual class="po-textual">; this could be done in current Javascript by making Node (or </textual><quote class="po-inline e279 e279"><textual class="po-textual">XMLNode</textual></quote><textual class="po-textual"> or whatever) be a subclass of Array, with the child-pointers as the members, and the other data as properties. Although Javascript does not provide operator overloading, in languages that do, other simplifications such as </textual><code class="po-atom e280 e280"><textual class="po-textual">==</textual></code><textual class="po-textual"> instead of </textual><code class="po-atom e281 e281"><textual class="po-textual">isEqualNode</textual></code><textual class="po-textual"> can also be provided.</textual></para><para class="po-block e282 e282"><textual class="po-textual">Such changes are part of the proposal below, but there is much more that can be done by taking the document world's requirements for abstract collection types seriously, and using languages that have a more robust notion and range of types.</textual></para><section class="po-hcontainer e283 e283"><title class="po-block e284 e284"><textual class="po-textual">On the implementation of abstract collection types</textual></title><para class="po-block e285 e285"><textual class="po-textual">Computer scientists use the notion of </textual><emphasis class="po-inline e286 e286" role="ital"><textual class="po-textual">abstract collection types</textual></emphasis><textual class="po-textual"> to
describe various ways in which data items can be aggregated, such as the arrays and dictionaries already discussed. </textual><quote class="po-inline e287 e287"><textual class="po-textual">Abstract</textual></quote><textual class="po-textual"> in this case means that the datatypes are characterized by their storage and access behaviors (or topology, if you will), rather than by how they are implemented. Arrays are distinct from hashes because one indexes items by position, and the other by name (or more properly </textual><quote class="po-inline e288 e288"><textual class="po-textual">key</textual></quote><textual class="po-textual">).</textual></para><para class="po-block e289 e289"><textual class="po-textual">Most any abstract collection type can be concretely implemented using most any concrete data structure; this is to be expected with Turing Machines. For example, arrays are often implemented using the </textual><quote class="po-inline e290 e290"><textual class="po-textual">array</textual></quote><textual class="po-textual"> data structure (a contiguous series of equal-sized memory blocks), but we have already seen that Javascript is an exception. Sparse arrays such as used in high-dimensionality problems in NLP and physics commonly implement arrays using linked lists or even hashes in order not to waste space on large numbers of empty members.</textual></para><para class="po-block e291 e291"><textual class="po-textual">Similarly, an abstract dictionary can be implemented in a concrete array: Just put each key and item together in an array, and then make an array out of those arrays as shown below. Large instances might be slow to access, but provide all needed functionality:</textual></para><programlisting class="po-block e292 e292" xml:space="preserve"><textual class="po-textual">
myDict = [
    [ 1,
        [ "Gouda",     [ "Netherlands" ] ],
        [ "Wisconsin", [ "Wisconsin"   ] ],
    ],
    [ 2,
        [ "Beemster",  [ "Japan"       ] ],
    ],
    [ 3,
        [ "Brie",      [ "France", "USA" ] ],
    ]
]
</textual></programlisting><para class="po-block e293 e293"><textual class="po-textual">As should be clear even from this trivial example, implementing an abstract collection type by using a less-than-natural data structure type frequently involves
inserting extra layers. In some cases it doubles the number of layers, commonly with alternating arrays and dictionaries. This introduces several problems:</textual></para><para class="po-block e294 e294"><textual class="po-textual">First, it's hard to read. Many developers do not carefully align things
as in the example above, although balancing brackets and braces by eye is otherwise difficult.</textual></para><para class="po-block e295 e295"><textual class="po-textual">Second, debugging bracketing errors is difficult because there are so few notations (commonly 1 or 2) being used to express so many distinctions (one per layer).</textual></para><para class="po-block e296 e296"><textual class="po-textual">Third, there are many different ways to introduce the extra layers, so different people
will do so in different ways. Therefore, data with the same abstract structure will
show up in various concrete forms, and receiving software is unlikely to copy without
modification, compromising data portability.</textual></para></section><section class="po-hcontainer e297 e297"><title class="po-block e298 e298"><textual class="po-textual">A feature analysis of abstract collection types</textual></title><para class="po-block e299 e299"><textual class="po-textual">There are several different abstract collection types beyond array and dictionary, that have substantial functional differences. The most obvious example is the </textual><quote class="po-inline e300 e300"><textual class="po-textual">set,</textual></quote><textual class="po-textual"> which has quite different semantics because it has neither position nor identifiers, only data items.</textual></para><para class="po-block e301 e301"><textual class="po-textual">The </textual><quote class="po-inline e302 e302"><textual class="po-textual">Priority queue</textual></quote><textual class="po-textual"> (used to choose tasks in order of importance or urgency) is another abstract collection type, which introduces a new feature:
Its members are accessed by priority, which is very much like a position in an array; however, unlike with an arrays there can be any number of tasks with the same priority.
Dictionaries and sets also fail to encompass priority queues.</textual></para><para class="po-block e303 e303"><textual class="po-textual">As before, introducing more layers is a likely if messy workaround, such as grouping tasks by level and then grouping the levels:</textual></para><programlisting class="po-block e304 e304" xml:space="preserve"><textual class="po-textual">
myDict = [
    [ "Brie",       "France",      3 ],
    [ "Gouda",      "Netherlands", 1 ],
    [ "Beemster",   "Japan",       2 ],
    [ "Wisconsin",  "Wisconsin",   1 ],
]
</textual></programlisting><para class="po-block e305 e305"><textual class="po-textual">The priority queue is effectively an array but with duplicate positions.
The </textual><quote class="po-inline e306 e306"><textual class="po-textual">bag</textual></quote><textual class="po-textual"> or </textual><quote class="po-inline e307 e307"><textual class="po-textual">multiset</textual></quote><textual class="po-textual"> provided in many programming libraries is, similarly, a set but with duplicate entries.</textual></para><para class="po-block e308 e308"><textual class="po-textual">Some programming languages provide versions of some or all these
abstract collection types, which are immutable, or restricted from being modified.
When applicable, this can enable certain kinds of optimization.</textual></para><para class="po-block e309 e309"><textual class="po-textual">In dynamic contexts queues and stacks are
distinct abstract collection types: Their items, after all, are not accessed either by name or by position, but by rule which concern the collection as a whole. However, in immutable contexts (such as data representation) these distinctions are seldom relevant. Either would likely be transmitted as a simple list; the receiving application can do what it likes.</textual></para><para class="po-block e310 e310"><textual class="po-textual">This leads me to suggest the following features for distinguishing abstract collection types:</textual></para><orderedlist class="po-table e311 e311"><listitem class="po-container e312 e312"><para class="po-block e313 e313"><textual class="po-textual">Is the order (position) of entries a way to refer to them?</textual></para></listitem><listitem class="po-container e314 e314"><para class="po-block e315 e315"><textual class="po-textual">Are entries identified (named) by some key in addition to their value?</textual></para></listitem><listitem class="po-container e316 e316"><para class="po-block e317 e317"><textual class="po-textual">Can one position identify only one entry? For example, if you store something in myArray[3] and then do so again, the first item is replaced. But if you store another item in a priority queue under the same priority, the first remains.</textual></para></listitem><listitem class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">Can one key identify only one entry?</textual></para></listitem><listitem class="po-container e320 e320"><para class="po-block e321 e321"><textual class="po-textual">Is the data structure mutable?</textual></para></listitem></orderedlist><para class="po-block e322 e322"><textual class="po-textual">These features define a space of distinct abstract collection types.
The space is not entirely orthogonal; for example, the question of whether there can be multiple entries at the same position is moot if the collection type is not ordered (as dictionaries), and the question of whether there can be multiple entries with the same name is moot if the collection type has no names (as sets).</textual></para><para class="po-block e323 e323"><textual class="po-textual">A few more properties are commonly distinguished, which are less relevant here:</textual></para><orderedlist class="po-table e324 e324"><listitem class="po-container e325 e325"><para class="po-block e326 e326"><textual class="po-textual">Must the data items in each entry all be of the same type? Arrays are sometimes divided into </textual><quote class="po-inline e327 e327"><textual class="po-textual">homogenous</textual></quote><textual class="po-textual"> ones (in which all entries' data items must be of the same datatype, and
</textual><quote class="po-inline e328 e328"><textual class="po-textual">heterogeneous</textual></quote><textual class="po-textual"> ones (in which items can be of mixed types). For example, Python has arrays, which are heterogeneous, and byteArrays which are homogeneous. Collection types rarely place any restriction on entries containing equivalent (or identical) </textual><emphasis class="po-inline e329 e329" role="ital"><textual class="po-textual">data</textual></emphasis><textual class="po-textual"> items.</textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">Is the type recursive? That is, can it have as members, items of its own type? Typically programs allows collection types to have any types they like as members, so recursion is the norm (as in all of JSON, Python, and XML).</textual></para></listitem></orderedlist><para class="po-block e332 e332"><textual class="po-textual">The types and their properties are shown below (parenthesized names are not provided by Python).</textual></para><table border="1" class="po-container e333 e333"><tbody align="center" class="po-table e334 e334"><tr class="po-table e335 e335"><th class="po-field e336 e336"><textual class="po-textual">Name</textual></th><th class="po-field e337 e337"><textual class="po-textual">Position</textual></th><th class="po-field e338 e338"><textual class="po-textual">Named</textual></th><th class="po-field e339 e339"><textual class="po-textual">DupPos</textual></th><th class="po-field e340 e340"><textual class="po-textual">DupName</textual></th><th class="po-field e341 e341"><textual class="po-textual">Immutable form</textual></th></tr><tr class="po-table e342 e342"><td class="po-block e343 e343"><textual class="po-textual">set</textual></td><td class="po-block e344 e344"><textual class="po-textual">0</textual></td><td class="po-block e345 e345"><textual class="po-textual">0</textual></td><td class="po-block e346 e346"><textual class="po-textual">–</textual></td><td class="po-block e347 e347"><textual class="po-textual">0</textual></td><td class="po-block e348 e348"><textual class="po-textual">frozenset</textual></td></tr><tr class="po-table e349 e349"><td class="po-block e350 e350"><textual class="po-textual">(multiset or bag)</textual></td><td class="po-block e351 e351"><textual class="po-textual">0</textual></td><td class="po-block e352 e352"><textual class="po-textual">0</textual></td><td class="po-block e353 e353"><textual class="po-textual">–</textual></td><td class="po-block e354 e354"><textual class="po-textual">1</textual><footnote class="po-popup e355 e355"><para class="po-block e356 e356"><textual class="po-textual">Properly speaking, sets allow duplicate entries, not duplicate names; the definition of the </textual><quote class="po-inline e357 e357"><textual class="po-textual">DupName</textual></quote><textual class="po-textual"> feature can be slightly complicated to account for this if desired.</textual></para></footnote></td><td class="po-block e358 e358"><textual class="po-textual"> </textual></td></tr><tr class="po-table e359 e359"><td class="po-block e360 e360"><textual class="po-textual">dict, defaultdict</textual></td><td class="po-block e361 e361"><textual class="po-textual">0</textual></td><td class="po-block e362 e362"><textual class="po-textual">1</textual></td><td class="po-block e363 e363"><textual class="po-textual">–</textual></td><td class="po-block e364 e364"><textual class="po-textual">0</textual></td><td class="po-block e365 e365"><textual class="po-textual"> </textual></td></tr><tr class="po-table e366 e366"><td class="po-block e367 e367"><textual class="po-textual">Counter</textual></td><td class="po-block e368 e368"><textual class="po-textual">0</textual></td><td class="po-block e369 e369"><textual class="po-textual">1</textual></td><td class="po-block e370 e370"><textual class="po-textual">–</textual></td><td class="po-block e371 e371"><textual class="po-textual">1</textual></td><td class="po-block e372 e372"><textual class="po-textual"> </textual></td></tr><tr class="po-table e373 e373"><td class="po-block e374 e374"><textual class="po-textual">array/list, bytearray</textual></td><td class="po-block e375 e375"><textual class="po-textual">1</textual></td><td class="po-block e376 e376"><textual class="po-textual">0</textual></td><td class="po-block e377 e377"><textual class="po-textual">0</textual></td><td class="po-block e378 e378"><textual class="po-textual">–</textual></td><td class="po-block e379 e379"><textual class="po-textual">tuple, string, u string, buffer</textual></td></tr><tr class="po-table e380 e380"><td class="po-block e381 e381"><textual class="po-textual">priority queue</textual></td><td class="po-block e382 e382"><textual class="po-textual">1</textual></td><td class="po-block e383 e383"><textual class="po-textual">0</textual></td><td class="po-block e384 e384"><textual class="po-textual">1</textual></td><td class="po-block e385 e385"><textual class="po-textual">–</textual></td><td class="po-block e386 e386"><textual class="po-textual"> </textual></td></tr><tr class="po-table e387 e387"><td class="po-block e388 e388"><textual class="po-textual">OrderedDict</textual></td><td class="po-block e389 e389"><textual class="po-textual">1</textual></td><td class="po-block e390 e390"><textual class="po-textual">1</textual></td><td class="po-block e391 e391"><textual class="po-textual">0</textual></td><td class="po-block e392 e392"><textual class="po-textual">0</textual></td><td class="po-block e393 e393"><textual class="po-textual">namedtuple</textual></td></tr><tr class="po-table e394 e394"><td class="po-block e395 e395"><textual class="po-textual">?</textual></td><td class="po-block e396 e396"><textual class="po-textual">1</textual></td><td class="po-block e397 e397"><textual class="po-textual">1</textual></td><td class="po-block e398 e398"><textual class="po-textual">0</textual></td><td class="po-block e399 e399"><textual class="po-textual">1</textual></td><td class="po-block e400 e400"><textual class="po-textual"> </textual></td></tr></tbody></table><para class="po-block e401 e401"><textual class="po-textual">Python's </textual><quote class="po-inline e402 e402"><textual class="po-textual">OrderedDict</textual></quote><textual class="po-textual"> has much in common with XML child sequences.
It is a variation on dictionaries, that also remembers in what order members were added. Members can be added with the usual </textual><code class="po-atom e403 e403"><textual class="po-textual">od["aardvark"] = "Tubulidentata"</textual></code><textual class="po-textual"> syntax, and accessed by the same name. It remembers the order items were added, and can iterate in that order with </textual><code class="po-atom e404 e404"><textual class="po-textual">for k,v in od.items()</textual></code><textual class="po-textual"> items.</textual></para><para class="po-block e405 e405"><textual class="po-textual">However, members cannot be set or retrieved by position, nor can they be moved around (except by deleting each and re-adding it to move it to the end). There is not a method to find out what position an item is in. It also cannot support multiple members with the same name as needed for XML. So OrderedDict functions mainly like a regular dictionary, just with a special iterator.</textual></para><para class="po-block e406 e406"><textual class="po-textual">From this table it is obvious that there are two case missing: First, Python does not have multisets (some other languages do). They can be simulated easily with Counter. The last row has no Python type, and no convenient way to simulate it. Sets have neither
position nor name; arrays have position but no name; dictionaries have name but no position; but where is the final combination? Where is an abstract collection type
that has </textual><emphasis class="po-inline e407 e407" role="ital"><textual class="po-textual">both</textual></emphasis><textual class="po-textual"> name and position, and can have repetitions of at least one of them?</textual></para><para class="po-block e408 e408"><textual class="po-textual">A full-fledged abstract collection type for the final slot turns out to be
exactly the structure that XML needs, but that is hardest to simulate using only arrays and/or dictionaries. I call it </textual><quote class="po-inline e409 e409"><textual class="po-textual">NamedArray,</textual></quote><textual class="po-textual"> and it is described in the next section.</textual><footnote class="po-popup e410 e410"><para class="po-block e411 e411"><textual class="po-textual">There is also room, not shown, for variants of OrderedDict and NamedArray that permit multiple members at the same position, by analogy with priority queues. I have not yet investigated these in any detail, but would tentatively suggest they may be useful for fined-grained version control.</textual></para></footnote></para></section></section><section class="po-hcontainer e412 e412"><title class="po-block e413 e413"><textual class="po-textual">XML collection types</textual></title><para class="po-block e414 e414"><textual class="po-textual">XML includes a few collection types, but the specification itself doesn't
describe or formalize them as such. The attributes of an element form a dictionary. The tokens within an attribute of type IDREFS or NMTOKENS form a homogeneous array. But the children of a given element do not constitute any of the types discussed so far, because </textual><emphasis class="po-inline e415 e415" role="ital"><textual class="po-textual">both</textual></emphasis><textual class="po-textual"> their names (element type names) and their positions are important. What are they, and how can we best access them with typical programming-language syntax?</textual></para><para class="po-block e416 e416"><textual class="po-textual">First, consider XML elements. They are the only Nodes (other than the special case of Root), that are not leaves in the XML structure: that can have children. DOM provides them as an (abstract) array known as </textual><code class="po-atom e417 e417"><textual class="po-textual">childNodes</textual></code><textual class="po-textual">, so they are accessed by position. That's fine as far as it goes, especially if languages would make them accessible via their native array syntax as shown earlier.</textual></para><para class="po-block e418 e418"><textual class="po-textual">The basic goal here is to find a simple mapping of XML structures to the
native collection syntax and semantics of Python, much like the simple mapping of
JSON to the native collection syntax and semantics of Javascript.</textual></para><para class="po-block e419 e419"><textual class="po-textual">In practice, many operations on XML do not access child nodes by numerical position; getting the 20th child is rarely needed, except when iterating over all children. Much more common is to want all the children of a given element type This defines a basic requirement for an OrderedDict-like abstract collection type to suffice for XML.</textual></para><para class="po-block e420 e420"><textual class="po-textual">XML as described by DOM has an orthogonal complexity that gets in the way of this: The distinction of nodeType and nodeName. Every element has a name such as </textual><quote class="po-inline e421 e421"><textual class="po-textual">para</textual></quote><textual class="po-textual"> or </textual><quote class="po-inline e422 e422"><textual class="po-textual">stanza</textual></quote><textual class="po-textual">; but there are also several types of nodes that are not elements. This 2-way or 2-level distinction complicates XML processing, so to keep the syntax and semantics simple it would help to get rid of it. The next section deals with this.</textual></para><section class="po-hcontainer e423 e423"><title class="po-block e424 e424"><textual class="po-textual">Simplifying XML node typing</textual></title><para class="po-block e425 e425"><textual class="po-textual">Every XML node is one of several nodeTypes, as described by DOM. The fundamental ones are element, attribute, text, processing-instruction, root, namespace, and comment (others have to do with physical rather than logical structure, for example CDATA sections and entity references, which need not concern us here).
But elements themselves have types (which DOM calls nodeNames), such as </textual><quote class="po-inline e426 e426"><textual class="po-textual">para</textual></quote><textual class="po-textual"> or </textual><quote class="po-inline e427 e427"><textual class="po-textual">chapter</textual></quote><textual class="po-textual">. The overloading of </textual><quote class="po-inline e428 e428"><textual class="po-textual">type</textual></quote><textual class="po-textual"> is confusing. The simplification proposed here begins by reducing the variety of node-types:</textual></para><orderedlist class="po-table e429 e429"><listitem class="po-container e430 e430"><para class="po-block e431 e431"><textual class="po-textual">Root is merely a special case of element.</textual></para></listitem><listitem class="po-container e432 e432"><para class="po-block e433 e433"><textual class="po-textual">Namespace is merely a special case of attribute.</textual></para></listitem><listitem class="po-container e434 e434"><para class="po-block e435 e435"><textual class="po-textual">Comments and PIs can be thought of as merely special cases of text (or the PI's can be thought of as a special case of an empty element, in order to treat its </textual><quote class="po-inline e436 e436"><textual class="po-textual">target</textual></quote><textual class="po-textual"> as an attribute, or to accomodate the commonplace of using attribute syntax within PIs). </textual></para></listitem></orderedlist><para class="po-block e437 e437"><textual class="po-textual">Let us call the new unified node construct an </textual><quote class="po-inline e438 e438"><textual class="po-textual">Elm,</textual></quote><textual class="po-textual"> since it is largely similar to DOM Element, but subsumes the other nodes types as well. By introducing reserved Elm names such as </textual><quote class="po-inline e439 e439"><textual class="po-textual">_TEXT</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e440 e440"><textual class="po-textual">_PI</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e441 e441"><textual class="po-textual">_COMMENT</textual></quote><textual class="po-textual">, and </textual><quote class="po-inline e442 e442"><textual class="po-textual">_ROOT</textual></quote><textual class="po-textual">, and by treating the text content of such (empty, leaf) Elms as a special attribute, the inventory of node types drops to just Elms and attributes.</textual></para><para class="po-block e443 e443"><textual class="po-textual">Conceptually, Elm leaves could treat individual characters as child nodes, rather than strings. This changes little; in Python strings are a list type, and all the usual list operations can apply to them anyway.</textual></para><para class="po-block e444 e444"><textual class="po-textual">The attributes of any given Elm form a dictionary, so it is convenient to introduce a specific node to encapsulate an element's attribute list as a whole (including both regular and namespace attributes). This corresponds to the XML Attribute-list.</textual></para><para class="po-block e445 e445"><textual class="po-textual">It has often been suggested that the type name of an XML element is merely a special case of an attribute (it applies to the element as a whole, has a simple token as value, comes from a schema-constrained namespace, etc.). So the element type can be treated merely as an attribute, which we may name </textual><quote class="po-inline e446 e446"><textual class="po-textual">_TYPE</textual></quote><textual class="po-textual">.</textual></para><para class="po-block e447 e447"><textual class="po-textual">Conveniently, the attribute-list is a familiar type (dictionary), and the Elm has all the positive properties of an array (plus the presence and use of names).</textual></para></section><section class="po-hcontainer e448 e448"><title class="po-block e449 e449"><textual class="po-textual">Mapping to Javascript types and syntax</textual></title><para class="po-block e450 e450"><textual class="po-textual">Javascript at least seems to have notions of accessing array members, and of accessing object properties. As we have seen, their syntax and semantics overlap somewhat; but to implement an abstract collection type for XML child sequences we can maintain the convention that the children of an Elm are identified by number and accessed via array notation; while the attributes of an Elm are identified by name and accessed via property notation.</textual><footnote class="po-popup e451 e451"><para class="po-block e452 e452"><quote class="po-inline e453 e453"><textual class="po-textual">_</textual></quote><textual class="po-textual"> is used to prefix reserved names such as </textual><quote class="po-inline e454 e454"><textual class="po-textual">_TYPE</textual></quote><textual class="po-textual"> because it is an acceptable identifier-start character in Javascript, Python, and many other languages. XML names can, however, also include colon, period, and hyphen, which would necessitate using Javascript bracket notations instead of dot notation.</textual></para></footnote></para><para class="po-block e455 e455"><textual class="po-textual">This is enough to permit a much more palatable syntax for dealing with XML structures in Javascript. Such an implementation may want to support the existing DOM methods and properties as well, to ease the way for existing users.</textual></para></section><section class="po-hcontainer e456 e456"><title class="po-block e457 e457"><textual class="po-textual">Mapping to Python types and syntax</textual></title><para class="po-block e458 e458"><textual class="po-textual">Given the same unification of subtypes of Node just discussed, the collection of a node's children fits neatly into the taxonomy of abstract collection types discussed earlier, as a more functional analog to OrderedDict. I call it </textual><quote class="po-inline e459 e459"><textual class="po-textual">NamedArray</textual></quote><textual class="po-textual">. The basic properties of this new type are:</textual></para><orderedlist class="po-table e460 e460"><listitem class="po-container e461 e461"><para class="po-block e462 e462"><textual class="po-textual">Order of members is maintained.</textual></para></listitem><listitem class="po-container e463 e463"><para class="po-block e464 e464"><textual class="po-textual">All the usual array operations are supported, such as accessing members by position, splicing, etc. (</textual><code class="po-atom e465 e465"><textual class="po-textual">sort()</textual></code><textual class="po-textual"> probably won't be used much for XML, but may be for other applications of NamedArray). Operations that insert members by position (such as </textual><code class="po-atom e466 e466"><textual class="po-textual">append()</textual></code><textual class="po-textual">) take an extra parameter for the name.</textual></para></listitem><listitem class="po-container e467 e467"><para class="po-block e468 e468"><textual class="po-textual">Like in regular dictionaries, each member of a NamedArray has a name (which is a string for the XML case, but which Python in general would allow to be of any hashable type).</textual></para></listitem><listitem class="po-container e469 e469"><para class="po-block e470 e470"><textual class="po-textual">Unlike in regular dictionaries, NamedArrays may have multiple entries with the same name (at different positions).</textual></para></listitem><listitem class="po-container e471 e471"><para class="po-block e472 e472"><textual class="po-textual">All the usual dictionary operations are supported, such as accessing members by name. However, the semantics are slightly different because duplicate names are permitted. Assigning to a member solely by name replaces the first member with that name; so does deleting by name. Members can also be referred to by name and number simultaneously, which refers to the n-th member with the given name.</textual></para></listitem><listitem class="po-container e473 e473"><para class="po-block e474 e474"><textual class="po-textual">The reserved name </textual><quote class="po-inline e475 e475"><textual class="po-textual">*</textual></quote><textual class="po-textual"> matches any Elm node type name, but not any of the reserved (</textual><quote class="po-inline e476 e476"><textual class="po-textual">_</textual></quote><textual class="po-textual">-initial) names.</textual></para></listitem></orderedlist><para class="po-block e477 e477"><textual class="po-textual">The specific syntax for these operations is described below.</textual></para><para class="po-block e478 e478"><textual class="po-textual">This provides the most commonly-needed operations for XML. Child nodes can be iterated over by number, and the sequence can be edited by the usual splice, append, and other list operations (as in DOM, but with more natural syntax). However, it is equally easy to iterate over all the comments, PIs, text nodes, elements, or elements of a given type, or simply slice out the elements of a given type. These are extremely common requirements in XML processing.</textual></para><para class="po-block e479 e479"><textual class="po-textual">This idea led the author to investigate what it takes to support an additional collection type in Python, with the native syntactic niceties.</textual></para><para class="po-block e480 e480"><textual class="po-textual">Python doesn’t have only the </textual><code class="po-atom e481 e481"><textual class="po-textual">array[n]</textual></code><textual class="po-textual"> notation for arrays. It also provides slicing such as </textual><code class="po-atom e482 e482"><textual class="po-textual">array[start:end]</textual></code><textual class="po-textual"> (note that the 2nd argument specifies the entry </textual><emphasis class="po-inline e483 e483" role="ital"><textual class="po-textual">after</textual></emphasis><textual class="po-textual"> the last one desired — this is commonly convenient). It also provides </textual><code class="po-atom e484 e484"><textual class="po-textual">dict[key]</textual></code><textual class="po-textual"> notation, and a separate notion of object properties, accessed like </textual><code class="po-atom e485 e485"><textual class="po-textual">object.propname</textual></code><footnote class="po-popup e486 e486"><para class="po-block e487 e487"><textual class="po-textual">This is distinctive: Perl uses </textual><code class="po-atom e488 e488"><textual class="po-textual">[]</textual></code><textual class="po-textual"> for arrays, </textual><code class="po-atom e489 e489"><textual class="po-textual">{}</textual></code><textual class="po-textual"> for dicts, and lacks </textual><code class="po-atom e490 e490"><textual class="po-textual">.</textual></code><textual class="po-textual"> notation. Javascript uses </textual><code class="po-atom e491 e491"><textual class="po-textual">array[n]</textual></code><textual class="po-textual">, </textual><code class="po-atom e492 e492"><textual class="po-textual">obj[key]</textual></code><textual class="po-textual">, and </textual><code class="po-atom e493 e493"><textual class="po-textual">obj.key</textual></code><textual class="po-textual">, but they are largely synonymous.</textual></para></footnote><textual class="po-textual">.</textual></para><para class="po-block e494 e494"><textual class="po-textual">Finally, Python has an unusual but very useful </textual><code class="po-atom e495 e495"><textual class="po-textual">array[start:end:interval]</textual></code><textual class="po-textual"> notation. For example, </textual><code class="po-atom e496 e496"><textual class="po-textual">array[0:20:2]</textual></code><textual class="po-textual"> retrieves every other item from among the array's first 20 entries. This is said to be heavily used with the numpy/scipy scientific and math packages.</textual></para><para class="po-block e497 e497"><textual class="po-textual">As with the abstract collection types, there turns out to be a natural combination of these
features which is not built in to Python, but is an excellent fit for XML:</textual></para><table class="po-container e498 e498"><tbody class="po-table e499 e499"><tr class="po-table e500 e500"><th class="po-field e501 e501"><textual class="po-textual">Description</textual></th><th class="po-field e502 e502"><textual class="po-textual">DOM</textual></th><th class="po-field e503 e503"><textual class="po-textual">Pythonish</textual></th></tr><tr class="po-table e504 e504"><td class="po-block e505 e505"><textual class="po-textual">Get first child</textual></td><td class="po-block e506 e506"><textual class="po-textual">n.firstChild</textual></td><td class="po-block e507 e507"><textual class="po-textual">n[1]</textual></td></tr><tr class="po-table e508 e508"><td class="po-block e509 e509"><textual class="po-textual">Get second child</textual></td><td class="po-block e510 e510"><textual class="po-textual">n.childNodes(2)</textual></td><td class="po-block e511 e511"><textual class="po-textual">n[2]</textual></td></tr><tr class="po-table e512 e512"><td class="po-block e513 e513"><textual class="po-textual">Get last child</textual></td><td class="po-block e514 e514"><textual class="po-textual">n.lastChild</textual></td><td class="po-block e515 e515"><textual class="po-textual">n[-1]</textual></td></tr><tr class="po-table e516 e516"><td class="po-block e517 e517"><textual class="po-textual">children 1-3</textual></td><td class="po-block e518 e518"><textual class="po-textual">n.childNodes.slice(0,3)</textual></td><td class="po-block e519 e519"><textual class="po-textual">n[1, 4)</textual></td></tr><tr class="po-table e520 e520"><td class="po-block e521 e521"><textual class="po-textual">two nodes equivalent</textual></td><td class="po-block e522 e522"><textual class="po-textual">n1.isEqualNode(n2)</textual></td><td class="po-block e523 e523"><textual class="po-textual">n1 == n2</textual></td></tr><tr class="po-table e524 e524"><td class="po-block e525 e525"><textual class="po-textual">two nodes identical</textual></td><td class="po-block e526 e526"><textual class="po-textual">n1.isSameNode(n2)</textual></td><td class="po-block e527 e527"><textual class="po-textual">n1 === n2</textual></td></tr><tr class="po-table e528 e528"><td class="po-block e529 e529"><textual class="po-textual">replace third child </textual></td><td class="po-block e530 e530"><textual class="po-textual">n1.replaceChild(n2, n3)</textual></td><td class="po-block e531 e531"><textual class="po-textual">n1[2] = n3</textual></td></tr><tr class="po-table e532 e532"><td class="po-block e533 e533"><textual class="po-textual">get first "p" child</textual></td><td class="po-block e534 e534"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e535 e535"><textual class="po-textual">n["p"]</textual></td></tr><tr class="po-table e536 e536"><td class="po-block e537 e537"><textual class="po-textual">get third "p" child</textual></td><td class="po-block e538 e538"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e539 e539"><textual class="po-textual">n["p":3]</textual></td></tr><tr class="po-table e540 e540"><td class="po-block e541 e541"><textual class="po-textual">get last "p" child</textual></td><td class="po-block e542 e542"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e543 e543"><textual class="po-textual">n["p":-1]</textual></td></tr><tr class="po-table e544 e544"><td class="po-block e545 e545"><textual class="po-textual">get the first 20 "p" children</textual></td><td class="po-block e546 e546"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e547 e547"><textual class="po-textual">n["p":1:21]</textual></td></tr><tr class="po-table e548 e548"><td class="po-block e549 e549"><textual class="po-textual">get all "p" children from among the first 20 children</textual></td><td class="po-block e550 e550"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e551 e551"><textual class="po-textual">n[1:21:"p"]</textual></td></tr><tr class="po-table e552 e552"><td class="po-block e553 e553"><textual class="po-textual">walk down by types</textual></td><td class="po-block e554 e554"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e555 e555"><textual class="po-textual">doc[“chap”:3][“sec”:2]["p"]</textual></td></tr></tbody></table><para class="po-block e556 e556"><textual class="po-textual">It is often helpful to be able to get all child Nodes that are in fact elements; as noted earlier </textual><code class="po-atom e557 e557"><textual class="po-textual">n["*"]</textual></code><textual class="po-textual"> is
defined to do this. The reserved Elm types </textual><quote class="po-inline e558 e558"><textual class="po-textual">_TEXT</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e559 e559"><textual class="po-textual">_PI</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e560 e560"><textual class="po-textual">_COMMENT</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e561 e561"><textual class="po-textual">_ROOT</textual></quote><textual class="po-textual">, and </textual><quote class="po-inline e562 e562"><textual class="po-textual">_ATTLIST</textual></quote><textual class="po-textual"> are simply names when XML uses NamedArray, so NamedArray itself has no awareness of XML convention.</textual></para><para class="po-block e563 e563"><textual class="po-textual">NamedArray is mutable, and does not require homogeneity. The members can be data of whatever type. In an XML document many will be Elms, some of which contain NamedArrays of its own; leaf nodes, however, could be inserted as raw strings, or as separate objects corresponding to DOM's Text, Comment, and PI nodes; NamedArray doesn't care.</textual></para><para class="po-block e564 e564"><textual class="po-textual">This seems, at least to this author, quite intuitive. The various slicing options
make the interface considerably higher-level, and the general applicability of </textual><code class="po-atom e565 e565"><textual class="po-textual">[]</textual></code><textual class="po-textual"> considerably reduces the number of methods and properties required to achieve DOM's functionality.</textual></para><para class="po-block e566 e566"><textual class="po-textual">The subtlest detail is
perhaps the distinction between </textual><code class="po-atom e567 e567"><textual class="po-textual">n["p":1:21]</textual></code><textual class="po-textual"> and </textual><code class="po-atom e568 e568"><textual class="po-textual">n[1:21:"p"]</textual></code><textual class="po-textual">. The former retrieves all children named </textual><quote class="po-inline e569 e569"><textual class="po-textual">p</textual></quote><textual class="po-textual">, and then retrieves the first 20 of those; the second instead retrieves the first 20 children, and then extracts
all of those that are named </textual><quote class="po-inline e570 e570"><textual class="po-textual">p</textual></quote><textual class="po-textual">. That is, the slicing operations go from left to right. This may seem familiar to users of XPath's successive </textual><code class="po-atom e571 e571"><textual class="po-textual">[]</textual></code><textual class="po-textual"> filters.</textual></para></section><section class="po-hcontainer e572 e572"><title class="po-block e573 e573"><textual class="po-textual">The rest of the XML Nodes</textual></title><para class="po-block e574 e574"><textual class="po-textual">So far we have modeled only the child-sequence requirements of XML, using a new abstract collection type that is not XML-specific, and that fits neatly into the pattern of Python's already-existing types. However, there is more to an XML node than a NamedArray of children: it also has attributes, references to neighboring nodes, properties related to namespaces, and a variety of methods.</textual></para><para class="po-block e575 e575"><textual class="po-textual">To begin with attributes, in Javascript they are probably best implemented as properties; however, this can lead to name clashes in relation to properties that are part of the Node implementation (</textual><code class="po-atom e576 e576"><textual class="po-textual">nextSibling</textual></code><textual class="po-textual">, etc.). Another option, which seems better when it is possible, is to keep them all in a dictionary. The dictionary in turn can be a property, or as suggested below, the first member of the NamedArray.</textual></para><para class="po-block e577 e577"><textual class="po-textual">JSOX has a full-fledged dictionary representing the attribute list as a whole.
Because the Elm type (which subsumes DOM nodeType and nodeName) is always present, and considered a reserved attribute, every Elm has at least one member in that dictionary. I favor placing the Attlist dictionary at position 0 in the child sequence, considering it a node in the same way that PIs, comment, and text portions are nodes. Placing it at position 0 fits with where it appears in XML syntax, while also hinting that it is </textual><quote class="po-inline e578 e578"><textual class="po-textual">special.</textual></quote><textual class="po-textual"> With slicing operations, it can be included or excluded at desired. I see this as a rather nice compromise between (a) most programming languages using 0-based arrays, and (b) many people thinking of the first </textual><emphasis class="po-inline e579 e579" role="ital"><textual class="po-textual">element</textual></emphasis><textual class="po-textual"> as #1. Those who disagree can put the attributes elsewhere with no substantial effect on the rest of this proposal.</textual></para><para class="po-block e580 e580"><textual class="po-textual">The other DOM properties (</textual><code class="po-atom e581 e581"><textual class="po-textual">parentNode</textual></code><textual class="po-textual">, etc.) are provided as properties as usual, as are more
Python-native synonyms: cloneNode (copy), textContent (toString),
appendChild (append), hasChildNodes and hasAttribute (in), removeAttribute (del),
removeChild (del), etc.</textual></para></section></section><section class="po-hcontainer e582 e582"><title class="po-block e583 e583"><textual class="po-textual">Implementation</textual></title><para class="po-block e584 e584"><textual class="po-textual">In Python most operators are just shorthand for function calls, and one can override the function definitions. The </textual><code class="po-atom e585 e585"><textual class="po-textual">[]</textual></code><textual class="po-textual"> notation invokes </textual><code class="po-atom e586 e586"><textual class="po-textual">__getitem__()</textual></code><textual class="po-textual">. Python already accepts 3 arguments to the bracket notation, and tests show that any of them can be a string instead of an integer. Thus, the semantics just described are easily implemented:</textual></para><programlisting class="po-block e587 e587" xml:space="preserve"><textual class="po-textual">def __getitem__(self, n1, n2=None, n3=None):
    t1 = t2 = t3 = None
    nargs = 1; t1 = type(n1)
    if (n2 != None): nargs = 2; t2 = type(n2)
    if (n3 != None): nargs = 3; t3 = type(n3)

    if (nargs==1):
        if (t1==StringType):
            if (name == '*'): return(self.getElements());
            return(self.getByName(t1)[1])
        else:
            return(self._subdata[int(t1)])
    elif (nargs==2):
        if (t1==IntType):
            if (t2==IntType):
                return(self._subdata[t1:t2])
            else:
                return(self.getByName(t2)[t1])
        else:
            if (t2==IntType):
                return(self.getByName(t1)[t2])
            else:
                raise(TypeError)
                return(None)
    else: # nargs==3
        if (t1==IntType and t2==IntType):
            if (t3==IntType):
                return(self._subdata[t1:t2:t3])
            else:
                return(self._subdata[t1:t2].getByName(t3))
        elif (t2==IntType and t3==IntType):
                return(self.getByName(t1)._subdata[t2:t3])
        else:
            raise(TypeError)
            return(None)
</textual></programlisting></section><section class="po-hcontainer e588 e588"><title class="po-block e589 e589"><textual class="po-textual">Extensibility</textual></title><para class="po-block e590 e590"><textual class="po-textual">The same kinds of indexing along all the XPath axes (</textual><citation class="po-atom e591 e591" linkend="Cla99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">) would be similarly useful, perhaps exposed
as lazily-evaluated properties of type array-of-Node. Some form of lazy evaluation or indexing is important here, lest enumerating all preceding or following elements be too expensive. It may be that Python's </textual><code class="po-atom e592 e592"><textual class="po-textual">buffer</textual></code><textual class="po-textual"> type, which supports read-only access to successive subsequences of a sequence (reminiscent of Scheme </textual><quote class="po-inline e593 e593"><textual class="po-textual">cdr'ing</textual></quote><textual class="po-textual"> down a list) would provide an effective approach.</textual></para><para class="po-block e594 e594"><textual class="po-textual">Although XML's child sequences are modelled well by NamedArray models, documents sometimes contain particular components that are logically other types. For example, the rows in a table body form an array, while the members of a definition list or glossary may form a dictionary, and a shopping list might form a set. Often the difference is visible only in a schema or documentation:</textual></para><programlisting class="po-block e595 e595" xml:space="preserve"><textual class="po-textual">&lt;!ELEMENT tbody    (tr*)&gt;
&lt;!ELEMENT glossary (term, definition)*&gt;
</textual></programlisting><para class="po-block e596 e596"><textual class="po-textual">All these can be modeled via NamedArray, but it is more perspicuous to provides no syntactic way to indicate that a particular element (type or instance) is conceptually a more constrained type, such as array, set, or dict (schema languages can specify such semantics, of course). This could be a useful addition both to add clarity to XML data, and to aid performance and perspicuity to implementations.</textual></para><para class="po-block e597 e597"><textual class="po-textual">Were XML not so well established and so widely and compatibly implemented, this distinction could be
accomplished by some minor syntactic enhancements, such as these which trade on the familiarity of arrays and dicts:</textual></para><programlisting class="po-block e598 e598" xml:space="preserve"><textual class="po-textual">&lt;x&gt;   &amp;#8212; for the usual XML childSequence
&lt;[x]&gt; &amp;#8212; to indicate the children constitute a logical array
&lt;{x}&gt; &amp;#8212; to indicate the children constitute a logical dictionary
</textual></programlisting><para class="po-block e599 e599"><textual class="po-textual">I find this intuitive, but in addition to not being XML-compatible, one runs out of
punctuation too soon — what would sets use?
</textual><code class="po-atom e600 e600"><textual class="po-textual">&lt;&lt;x&gt;&gt;</textual></code><textual class="po-textual">?
</textual><code class="po-atom e601 e601"><textual class="po-textual">&lt;⊂x⊂&gt;</textual></code><textual class="po-textual">?
</textual><code class="po-atom e602 e602"><textual class="po-textual">&lt;〔x〕&gt;</textual></code><textual class="po-textual">?</textual></para><para class="po-block e603 e603"><textual class="po-textual">A better solution on both counts is to define a namespace in which the abstract types are enumerated (</textual><quote class="po-inline e604 e604"><textual class="po-textual">ac</textual></quote><textual class="po-textual"> for </textual><quote class="po-inline e605 e605"><textual class="po-textual">abstract collection</textual></quote><textual class="po-textual">):</textual></para><programlisting class="po-block e606 e606" xml:space="preserve"><textual class="po-textual">&lt;x ac:type="childSequence"&gt;
&lt;x ac:type="array"&gt;
&lt;x ac:type="dict"&gt;
</textual></programlisting><para class="po-block e607 e607"><textual class="po-textual">This allows complete extensibility, even for specifying finer properties such
as homogeneity, recursion, etc.</textual></para></section></section><section class="po-hcontainer e608 e608"><title class="po-block e609 e609"><textual class="po-textual">Documents</textual></title><para class="po-block e610 e610"><textual class="po-textual">We now come to the most widespread XML use case for which JSON does not suffice: documents. Let us take the </textual><emphasis class="po-inline e611 e611" role="ital"><textual class="po-textual">Ἀργοναυτικά</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e612 e612" role="ital"><textual class="po-textual">Medea</textual></emphasis><textual class="po-textual"> as an example (both, after all, have much to do with Jason). As with most documents,  such works contain long sequences of content objects — many of them verse lines, but intermixed with other types: quotations, stanza and section boundaries, and in some editions notes, links, catchwords, illustrations, stage directions, and so forth.</textual></para><para class="po-block e613 e613"><textual class="po-textual">It should be evident to the reader that re-ordering the parts of a book or chapter (or a Web page) in the manner of a JSON hash table is rather worse than mere inconvenience (such as seen with the  examples above). So when JSON </textual><quote class="po-inline e614 e614"><textual class="po-textual">replaces</textual></quote><textual class="po-textual"> XML, what is to be done? It is a commonplace that perhaps 80-90% even of corporate data, resides in documents rather than databases; but whatever that precise figure may be, Appolonius of Rhodes, Clement of Alexandria, and Harry of Hogwarts are not going away.</textual></para><para class="po-block e615 e615"><textual class="po-textual">In JSON only arrays preserve order, so they must be used. But an array of strings is entirely inadequate; one must reconstruct the entire hierarchy of books, chapters, sections, stanzas, verse lines, footnotes, and whatever else, via arrays. Then, since arrays provide no place to label their entries, each entry must become a collection of its own; perhaps a tuple such as </textual><code class="po-atom e616 e616"><textual class="po-textual">["stanza", "...." ]</textual></code><textual class="po-textual">, or a dictionary such as </textual><code class="po-atom e617 e617"><textual class="po-textual">{"label":"stanza", "content":"...." }</textual></code><textual class="po-textual">.</textual></para><para class="po-block e618 e618"><textual class="po-textual">The latter has the advantage of supporting additional properties, whether for formatting, linking and notes, or meta-textual information such as that the stanza is missing from certain manuscripts. As always, indirection can be used to make an infinite variety of hacks possible; but once we have addressed even the most rudimentary demands of actual documents, JSON's limitation to arrays and hashes forces us into unintuitive, needlessly complex representations.</textual></para><para class="po-block e619 e619"><textual class="po-textual">I carried out such a conversion for the much simpler case of Twitter data. By taking typical advantage of attributes, the data at once becomes:</textual></para><orderedlist class="po-table e620 e620"><listitem class="po-container e621 e621"><para class="po-block e622 e622"><textual class="po-textual">More readable (this, of course, is always subjective).</textual></para></listitem><listitem class="po-container e623 e623"><para class="po-block e624 e624"><textual class="po-textual">Easily processable for multiple purposes (linguistic processing can ignore attributes, style calculation can ignore content, rendering can use everything, ...).</textual></para></listitem><listitem class="po-container e625 e625"><para class="po-block e626 e626"><textual class="po-textual">Usable with generic software (because the notion of labeled </textual><emphasis class="po-inline e627 e627" role="ital"><textual class="po-textual">and yet</textual></emphasis><textual class="po-textual"> ordered items is required for all XML software, but for no JSON software).</textual></para></listitem><listitem class="po-container e628 e628"><para class="po-block e629 e629"><textual class="po-textual">Smaller. </textual><emphasis class="po-inline e630 e630" role="ital"><textual class="po-textual">The XML ends up about 10% smaller than the JSON</textual></emphasis><textual class="po-textual">, with names and whitespace for pretty-printing kept constant. This is partly because attribute names do not need to be quoted, unlike alphanumeric JSON dictionary keys.</textual></para></listitem><listitem class="po-container e631 e631"><para class="po-block e632 e632"><textual class="po-textual">Validatable. This is a particularly important issue. Although it would be possible to design schema languages for JSON, none seem to exist at present. Thus, while it is very easy to save and load JSON from Javascript, it is not at all easy to describe exactly what structure you are sending, or to check that it's right. This rules out JSON for mission-critical applications, unless a special process is created for checking.</textual></para></listitem></orderedlist><para class="po-block e633 e633"><textual class="po-textual">XML has been called "verbose."
But this is often simply wrong. First, skilled rather than mechanical use of XML is often syntactically more compact than JSON.
For example, schemas for XML support default values,
and in many data-intensive applications many entries have the default
value (that's why it's the default). Omitting them can
save a lot; but in JSON, unlike XML, defaults must be implemented at a higher level.
Second, data compression works very effectively on frequently-repeated things like tags. An email exchange on the xml-dev list long ago addressed this in detail (discussed by Edd Dumbill at </textual><link class="po-inline e634 e634" xlink:actuate="onRequest" xlink:href="http://www.xml.com/pub/a/2004/12/15/deviant.html)." xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xml.com/pub/a/2004/12/15/deviant.html).</textual></link><textual class="po-textual">
Third, safe use of JSON often requires processing it twice. Because JSON is essentially a subset of Javascript code, it is tempting to simply "eval" it in order to get it parsed. Doing so opens the door to injection attacks. The easiest way to avoid this is to run a separate regex match first (</textual><citation class="po-atom e635 e635" linkend="Cro06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">).</textual></para></section><section class="po-hcontainer e636 e636"><title class="po-block e637 e637"><textual class="po-textual">Summary</textual></title><para class="po-block e638 e638"><textual class="po-textual">JSON has established itself as an easy way to get data in and out of Javascript programs; that is a good and useful thing. This paper, however, contends that XML's reputation for relative complexity or difficulty in that context arose in large measure because Javascript mechanically translated the language-agnostic Document Object Model to become it's API for XML data, rather than choosing syntax and signatures tailored to the Javascript sprachgefühl.</textual><footnote class="po-popup e639 e639"><para class="po-block e640 e640"><textual class="po-textual">Linguists and translators will recognize this as the classic choice between "literal" and "idiomatic" translations in natural language; the format may (or may not) be more precise, but are far less readable, and often feel "foreign," leading to lower acceptance by readers.</textual></para></footnote><textual class="po-textual">
Javascript programmers accessing XML structures write, for example, </textual><code class="po-atom e641 e641"><textual class="po-textual">n.childNodes[3].childNodes[2].getAttribute('class')</textual></code><textual class="po-textual"> when they would quite sensibly rather write </textual><code class="po-atom e642 e642"><textual class="po-textual">n[3][2].attrs['class']</textual></code><textual class="po-textual"> — countless times.</textual></para><para class="po-block e643 e643"><textual class="po-textual">There is no reason this has to be the case. Even in Javascript, with a very small inventory of abstract collection types and little ability to extend syntax (for example by operator overloading), there is no reason not to provide the latter, or some similar more native and less annoying syntax.</textual></para><para class="po-block e644 e644"><textual class="po-textual">Python provides operator overloading, and so can do even better at providing "native" feel for non-Python-derived formats. Such a Python interface to XML structures is presented. It provides far higher-level functionality than DOM, such as filtering nodes by nodeType and nodeName, slicing and splicing groups of children, and so on. The code to implement it is so small that the main portion is included here.</textual></para><para class="po-block e645 e645"><textual class="po-textual">However, a deeper question arises when one considers just what abstract collection type XML data represents. Most XML constructs constitute ordinary arrays or dictionaries, the most basic and widespread collection types. However, the sequence of children of a given node does not, in part because it is organized and accessed by </textual><emphasis class="po-inline e646 e646" role="ital"><textual class="po-textual">both</textual></emphasis><textual class="po-textual"> position and name. An analysis of Python's abstract collection types into their distinctive features reveals that XML child sequences fit
into a symmetry gap in the pattern. This paper presents a </textual><quote class="po-inline e647 e647"><textual class="po-textual">NamedArray</textual></quote><textual class="po-textual"> type and implementation to fill that gap.</textual></para><para class="po-block e648 e648"><textual class="po-textual">Some have suggested that JSON will "replace" XML, supposedly because it is simpler but still adequate. But any difference in simplicity is minor once you have an appropriate API; and JSON has not yet shown itself adequate for XML's primary application space: documents. Examples that accompany claims of JSON's adequacy uniformly lack the most salient distinctive characteristics of documents. As one example (at the time of writing) Wikipedia's article "Document-oriented databases" gave (only) these two examples of "documents":</textual></para><programlisting class="po-block e649 e649" xml:space="preserve"><textual class="po-textual">{
    FirstName: "Bob",
    Address: "5 Oak St.",
    Hobby: "sailing"
}

{
    FirstName: "Jonathan",
    Address: "15 Wanamassa Point Road",
    Children: [
        {Name: "Michael", Age: 10},
        {Name: "Jennifer", Age: 8},
        {Name: "Samantha", Age: 5},
        {Name: "Elena", Age: 2}
    ]
}
</textual></programlisting><para class="po-block e650 e650"><textual class="po-textual">The second at least contains </textual><emphasis class="po-inline e651 e651" role="ital"><textual class="po-textual">one</textual></emphasis><textual class="po-textual"> example of repetition, and represents it via hierarchy. This is more than many published examples,
but there is not a hint of heterogeneous child sequences; of the same component type appearing at multiple levels; of non-trivial nesting; of anything like the distinction of sub-parts vs. properties of components; nor mention of schemas, constraints, defaults, inheritance, or validation issues.</textual></para><para class="po-block e652 e652"><textual class="po-textual">Such examples do nothing to strengthen JSON's case for adequacy in the document world, however handy it is in the word of simple non-document data. An adequate system for documents must take real account of the fundamental characteristics of documents. If the simpler concepts and structures of regular and associative arrays sufficed for the world of documents and literature, we'd all have saved ourselves a lot of trouble by talking in SQL long ago.</textual></para><para class="po-block e653 e653"><textual class="po-textual">Thus I conclude that JSON, while an excellent idea for the niche of config files, transmission of simple / tabular / homogeneous data structure, is insufficient to
handle documents perspicuously. Until it does, the XML world need have no anxiety on its account; though we should undertake a more serious effort to make XML more accessible to developers new to the field, or in neighboring fields that interacting with XML only peripherally.</textual></para></section><bibliography class="po-hcontainer e654 e654"><title class="po-block e655 e655"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e656 e656" xml:id="Bra08" xreflabel="Bra08"><textual class="po-textual">Bray, Tim, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau.
</textual><quote class="po-inline e657 e657"><textual class="po-textual">Extensible Markup Language (XML) 1.0 (Fifth Edition).</textual></quote><textual class="po-textual">
W3C Recommendation 26 November 2008.
</textual><link class="po-inline e658 e658" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/REC-xml/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link></bibliomixed><bibliomixed class="po-block e659 e659" xml:id="Cla99" xreflabel="Cla99"><textual class="po-textual">Clark, James and Steve DeRose. 1999.
XML Path Language (XPath). Version 1.0. W3C Recommendation 16 November 1999.
</textual><link class="po-inline e660 e660" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath/</textual></link></bibliomixed><bibliomixed class="po-block e661 e661" xml:id="Coo87" xreflabel="Coo87"><textual class="po-textual">Coombs, James H., Allen H. Renear, Steven J. DeRose. 1987.
</textual><quote class="po-inline e662 e662"><textual class="po-textual">Markup systems and the future of scholarly text processing.</textual></quote><textual class="po-textual">
</textual><emphasis class="po-inline e663 e663" role="ital"><textual class="po-textual">Communications of the ACM</textual></emphasis><textual class="po-textual"> 30(11): 933-947.
</textual><link class="po-inline e664 e664" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=32209" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dl.acm.org/citation.cfm?id=32209</textual></link></bibliomixed><bibliomixed class="po-block e665 e665" xml:id="DeR90" xreflabel="DeR90"><textual class="po-textual">DeRose, Steven, David G Durand, Elli Mylonas, and Allen Renear. Winter 1990.
</textual><quote class="po-inline e666 e666"><textual class="po-textual">What is text, really? </textual></quote><textual class="po-textual">
</textual><emphasis class="po-inline e667 e667" role="ital"><textual class="po-textual">Journal of Computing in Higher Education</textual></emphasis><textual class="po-textual">
1(2): 3-26. Springer US.
doi:</textual><biblioid class="po-atom e668 doi e668"><textual class="po-textual">10.1007/BF02941632</textual></biblioid><textual class="po-textual">. ISSN 1042-1726.
</textual><link class="po-inline e669 e669" xlink:actuate="onRequest" xlink:href="http://link.springer.com/article/10.1007%2FBF02941632" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://link.springer.com/article/10.1007%2FBF02941632</textual></link></bibliomixed><bibliomixed class="po-block e670 e670" xml:id="Dur96" xreflabel="Dur96"><textual class="po-textual">Durand, David G., Elli Mylonas, Steven DeRose. 1996.
</textual><quote class="po-inline e671 e671"><textual class="po-textual">What Should Markup Really Be:
Applying theories of text to the design of markup systems.</textual></quote><textual class="po-textual"> </textual><emphasis class="po-inline e672 e672" role="ital"><textual class="po-textual">ALLC/ACH.</textual></emphasis></bibliomixed><bibliomixed class="po-block e673 e673" xml:id="Cro06" xreflabel="Cro06"><textual class="po-textual">Crockford, D. 2006.
</textual><quote class="po-inline e674 e674"><textual class="po-textual">The application/json Media Type for JavaScript Object Notation (JSON)</textual></quote><textual class="po-textual">
IETF RFC 4627.
</textual><link class="po-inline e675 e675" xlink:actuate="onRequest" xlink:href="http://www.ietf.org/rfc/rfc4627.txt" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ietf.org/rfc/rfc4627.txt</textual></link></bibliomixed><bibliomixed class="po-block e676 e676" xml:id="ECM11" xreflabel="ECM11"><textual class="po-textual">ECMA International.
</textual><quote class="po-inline e677 e677"><textual class="po-textual">ECMAScript® Language Specification.</textual></quote><textual class="po-textual">
Standard ECMA-262, 5.1 Edition / June 2011.
Geneva: Ecma International.
</textual><link class="po-inline e678 e678" xlink:actuate="onRequest" xlink:href="http://www.ecma-international.org/ecma-262/5.1/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ecma-international.org/ecma-262/5.1/</textual></link></bibliomixed><bibliomixed class="po-block e679 e679" xml:id="Gri68" xreflabel="Gri68"><textual class="po-textual">
Griswold, R. E.,  J. F. Poage, I. P. Polonsky. 1968, 1971.
  </textual><emphasis class="po-inline e680 e680" role="ital"><textual class="po-textual">THE SNOBOL4 PROGRAMMING LANGUAGE</textual></emphasis><textual class="po-textual">. 2nd ed.
Englewood Cliffs, New Jersey: Prentice-Hall, Inc.
</textual><link class="po-inline e681 e681" xlink:actuate="onRequest" xlink:href="http://www.math.bas.bg/bantchev/place/snobol/gpp-2ed.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.math.bas.bg/bantchev/place/snobol/gpp-2ed.pdf</textual></link></bibliomixed><bibliomixed class="po-block e682 e682" xml:id="JQu" xreflabel="JQu"><textual class="po-textual">
</textual><quote class="po-inline e683 e683"><textual class="po-textual">JQuery API.</textual></quote><textual class="po-textual">
</textual><link class="po-inline e684 e684" xlink:actuate="onRequest" xlink:href="http://api.jquery.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://api.jquery.com</textual></link></bibliomixed><bibliomixed class="po-block e685 e685" xml:id="LeH04" xreflabel="LeH04"><textual class="po-textual">Le Hors, Arnaud, et al. 07 April 2004.
</textual><quote class="po-inline e686 e686"><textual class="po-textual">Document Object Model (DOM) Level 3 Core Specification.</textual></quote><textual class="po-textual">
Version 1.0. W3C Recommendation 07 April 2004.
</textual><link class="po-inline e687 e687" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/</textual></link></bibliomixed><bibliomixed class="po-block e688 e688" xml:id="Way01" xreflabel="Way01"><textual class="po-textual">Way, Arthur Sanders (tr). 1901.
Apollonius Rhodius. </textual><emphasis class="po-inline e689 e689" role="ital"><textual class="po-textual">Argonautica</textual></emphasis><textual class="po-textual">.
London: J. M. Dent and Co.
</textual><link class="po-inline e690 e690" xlink:actuate="onRequest" xlink:href="https://archive.org/details/taleofargonauts00apol" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://archive.org/details/taleofargonauts00apol</textual></link><textual class="po-textual">
</textual></bibliomixed></bibliography></article></classedDocument>