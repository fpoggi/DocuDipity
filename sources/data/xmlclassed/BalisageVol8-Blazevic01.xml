<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">
Extending XML with SHORTREFs specified in RELAX NG</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">
We present a novel method for specifying concrete syntax, based on and compatible with the RELAX NG schema standard. A
parsing method is described for a well-formed XML document conforming to the given concrete syntax specification. The
output of the parser is another XML document conforming to the abstract syntax described by the base RELAX NG schema.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Mario</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Blažević</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">
        The author has a Master's degree in Computer Science from University of Novi Sad, Yugoslavia. Since moving to
        Canada in 2000, he has been working for OmniMark Technologies, later acquired by Stilo International plc.,
        mostly in the area of markup processing and on development of the OmniMark programming language.</textual></para></personblurb><email class="po-field e14 e14"><textual class="po-textual">mblazevic@stilo.com</textual></email><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior software architect</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Stilo International plc.</textual></orgname></affiliation></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Copyright © 2012 Stilo International plc. All rights reserved.</textual></para></legalnotice></info><note class="po-container e20 e20"><para class="po-block e21 e21"><textual class="po-textual">
This paper has been inspired in part by Sam Wilmott's 1993 internal report, </textual><quote class="po-inline e22 e22"><textual class="po-textual">Beyond SGML</textual></quote><textual class="po-textual">[</textual><citation class="po-atom e23 e23" linkend="w93"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. I
also want to thank my colleague Jacques Légaré for his valuable comments and clarifications, and Stilo
International for giving me time to do interesting work.</textual></para></note><section class="po-hcontainer e24 e24"><title class="po-block e25 e25"><textual class="po-textual"> Introduction</textual></title><para class="po-block e26 e26"><textual class="po-textual">SGML had this feature called SHORTREF. It allowed the DTD designer to specify that certain strings called </textual><emphasis class="po-inline e27 e27"><textual class="po-textual">shortrefs</textual></emphasis><textual class="po-textual">
should in some contexts be interpreted as markup tags. For the authors using an SGML DTD with a well-designed set of
shortrefs, the effect was similar to using a kind of Wiki markup.</textual></para><para class="po-block e28 e28"><textual class="po-textual">As with other parts of SGML, the specification syntax for shortrefs was idiosyncratic.[</textual><citation class="po-atom e29 e29" linkend="s86"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] 
Furthermore, the method of their specification typically relied on some other rarely-used features of SGML DTDs, such as
STARTTAG entities. This combination ensured that only an expert in SGML DTDs could hope to design shortrefs correctly,
so they remained obscure and rarely used. When SGML was replaced by its simplified successor XML, nobody regretted their
omission.</textual></para><para class="po-block e30 e30"><textual class="po-textual">Or did they?</textual></para><para class="po-block e31 e31"><textual class="po-textual">Many people stubbornly refuse to abandon their non-XML syntaxes. Programming language designers still use the
old-fashioned EBNF grammars[</textual><citation class="po-atom e32 e32" linkend="b59"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] in their specifications instead of XML Schema. Even some languages
that are at the very core of various XML technologies, such as XPath, are not XML. The RELAX NG schema language, though
specified in XML syntax[</textual><citation class="po-atom e33 e33" linkend="c01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">], defines a non-XML </textual><quote class="po-inline e34 e34"><textual class="po-textual">compact syntax</textual></quote><textual class="po-textual">[</textual><citation class="po-atom e35 e35" linkend="c02c"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] as well.</textual></para><para class="po-block e36 e36"><textual class="po-textual">The strongest evidence of yearning for shortrefs, however, is the myriad of </textual><link class="po-inline e37 e37" xlink:actuate="onRequest" xlink:href="http://www.wikimatrix.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">Wiki languages</textual></link><textual class="po-textual"> in existence. Here we have a large family of actual markup
languages, whose main purpose is to be converted to HTML, another markup language, and still they are not fully tagged
XML. SGML DTDs with shortrefs and appropriate declarations could accomplish the task.[</textual><citation class="po-atom e38 e38" linkend="j04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] Instead,
Wiki engines typically store their pages as plain text, parse them using hand-coded parsers written in various
general-purpose languages, and convert them directly to HTML for presentation.[</textual><citation class="po-atom e39 e39" linkend="b07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]</textual></para><para class="po-block e40 e40"><textual class="po-textual">There are many downsides to this architecture. Most Wiki pages are stored unvalidated and unstructured, which makes them
suboptimal for searching and very difficult to automatically restructure. They are missing all XML tool chain
support. All these problems are judged to be outweighed by the benefit of the special notation. A solution that
preserves this notational convenience while keeping markup in XML documents would be a clear winner.</textual></para><para class="po-block e41 e41"><textual class="po-textual">The present paper aims to deliver one solution that satisfies these criteria: given a relatively simple syntax
specification that follows the established standards, it allows the author to create valid XML without entering XML
tags. In other words, it resurrects SGML shortrefs in a more modern context of well-formed XML and RELAX NG schema
specifications.</textual></para></section><section class="po-hcontainer e42 e42"><title class="po-block e43 e43"><textual class="po-textual"> RELAX NG schema as a grammar</textual></title><para class="po-block e44 e44"><textual class="po-textual">If our job is to specify how some text is to be parsed, one obvious place to start is from grammars, or more
specifically context-free grammars; they have been successfully used for this purpose for more than half a
century[</textual><citation class="po-atom e45 e45" linkend="b59"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. Here is an example of such a grammar for a small fragment of a Wiki markup language,
specified in a variant of the EBNF notation:</textual></para><programlisting class="po-block e46 e46" xml:space="preserve"><textual class="po-textual">paragraph  ::= (plain-text | bold | italic)* "\n\n"?
bold       ::= "**" (plain-text | italic)* "**"
italic     ::= "//" (plain-text | bold)* "//"
plain-text ::= ([^\n*/]+ | "\n" [^\n] | "*" [^*] | "/" [^/])+</textual></programlisting><para class="po-block e47 e47"><textual class="po-textual">The </textual><quote class="po-inline e48 e48"><textual class="po-textual">plain-text</textual></quote><textual class="po-textual"> production is rather tricky. This context-free grammar is working directly on plain-text input with no
help from any lexical layer, so </textual><quote class="po-inline e49 e49"><textual class="po-textual">plain-text</textual></quote><textual class="po-textual"> has to exclude the three markers (</textual><code class="po-atom e50 e50"><textual class="po-textual">**</textual></code><textual class="po-textual">, </textual><code class="po-atom e51 e51"><textual class="po-textual">//</textual></code><textual class="po-textual">, and the newline) in order
to avoid ambiguity. The production would become even more complicated as more markup is added to the grammar.</textual></para><para class="po-block e52 e52"><textual class="po-textual">Once the input text is parsed according to the grammar, we can represent the resulting abstract syntax tree as XML and
use the following compact RELAX NG schema for its validation:</textual></para><programlisting class="po-block e53 e53" xml:space="preserve"><textual class="po-textual">paragraph  = element para { (plain-text | bold | italic)* }
bold       = element bold { (plain-text | italic)* }
italic     = element italic { (plain-text | bold)* }
plain-text = text</textual></programlisting><para class="po-block e54 e54"><textual class="po-textual">The similarities between the two notations above are striking. The main difference is that the former specifies a
</textual><emphasis class="po-inline e55 e55"><textual class="po-textual">concrete</textual></emphasis><textual class="po-textual"> syntax, and the latter the </textual><emphasis class="po-inline e56 e56"><textual class="po-textual">abstract</textual></emphasis><textual class="po-textual"> syntax[</textual><citation class="po-atom e57 e57" linkend="m62"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. To become concrete, and thus
useful for parsing text, the RELAX NG schema needs to specify the string markers, or </textual><emphasis class="po-inline e58 e58"><textual class="po-textual">terminal</textual></emphasis><textual class="po-textual"> symbols. We could try
the following modification, which brings the schema even closer to the EBNF grammar:</textual></para><programlisting class="po-block e59 e59" xml:space="preserve"><textual class="po-textual">paragraph  = element para {
                (plain-text | bold | italic)*,
                "&amp;#x0a;&amp;#x0a;"?
             }
bold       = element bold { "**", (plain-text | italic)*, "**" }
italic     = element italic { "//", (plain-text | bold)*, "//" }
plain-text = text</textual></programlisting><para class="po-block e60 e60"><textual class="po-textual">The RELAX NG specification[</textual><citation class="po-atom e61 e61" linkend="c01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] unfortunately does not allow text-matching and element-matching
patterns to be grouped together, and that makes the above schema invalid. To make our concrete-syntax schema
syntactically correct, we need to enclose each string marker into an element of its own. These elements will belong to
the special </textual><code class="po-atom e62 e62"><textual class="po-textual">terminal</textual></code><textual class="po-textual"> namespace so we can distinguish them from the structural elements:</textual></para><programlisting class="po-block e63 e63" xml:space="preserve"><textual class="po-textual">paragraph  = element para {
                (plain-text | bold | italic)*,
                paragraph_separator?
             }
bold       = element bold {
                bold_marker,
                (plain-text | italic)*,
                bold_marker
             }
italic     = element italic {
                italic_marker,
                (plain-text | bold)*,
                italic_marker
             }
plain-text = text

bold_marker         = element terminal:bold_marker { "**" }
italic_marker       = element terminal:italic_marker { "//" }
paragraph_separator = element terminal:paragraph_separator {
                         "&amp;#x0a;&amp;#x0a;"
                      }</textual></programlisting><para class="po-block e64 e64"><textual class="po-textual">We could also replace the </textual><code class="po-atom e65 e65"><textual class="po-textual">text</textual></code><textual class="po-textual"> pattern by </textual><code class="po-atom e66 e66"><textual class="po-textual">string{pattern="([^\n*/]+|\n[^\n]|\*[^*]|/[^/])+"} </textual></code><textual class="po-textual"> to replicate the
grammar even closer. As noted above, however, this pattern grows more complex as more markers are added to the grammar,
which makes it difficult to maintain. Another downside is that the schema would lose the modularity properties that
RELAX NG normally provides.</textual></para><para class="po-block e67 e67"><textual class="po-textual">The </textual><quote class="po-inline e68 e68"><textual class="po-textual">plain-text</textual></quote><textual class="po-textual"> pattern is meant to match any text up to any marker that is allowed in the context. Rather than require
the user to construct this pattern every time a new marker is introduced, we can change the meaning of the </textual><code class="po-atom e69 e69"><textual class="po-textual">text</textual></code><textual class="po-textual">
pattern to match what we need. In the standard RELAX NG semantics, </textual><code class="po-atom e70 e70"><textual class="po-textual">text</textual></code><textual class="po-textual"> matches all text content up to the next
element tag; in our modified semantics, it will match all text content until the next marker recognizable in the
context, or until the next element tag.</textual></para><para class="po-block e71 e71"><textual class="po-textual">Our parser must construct an abstract syntax tree with element nodes like </textual><code class="po-atom e72 e72"><textual class="po-textual">bold</textual></code><textual class="po-textual"> that are not present in the input. To
achieve this, we need to add another semantic extension and infer the missing element tags[</textual><citation class="po-atom e73 e73" linkend="b10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. This is especially necessary for features like Wiki lists, where a single indented asterisk can denote
the beginning of both a list and a list item. This is similar to the OMITTAG feature of SGML, the main difference being
that our input must be well-formed XML; the element's start-tag and its end-tag must both be present or both omitted.</textual></para><para class="po-block e74 e74"><textual class="po-textual">The only elements with omissible tags will be those in the </textual><code class="po-atom e75 e75"><textual class="po-textual">terminal</textual></code><textual class="po-textual"> namespace and those whose namespace URI begins
with the prefix </textual><code class="po-atom e76 e76"><textual class="po-textual">omissible+</textual></code><textual class="po-textual"> (which is perfectly legal according to RFC 2396). In the schema fragment above, the default
namespace should be made omissible; in other words, the schema should be preceded by</textual></para><programlisting class="po-block e77 e77" xml:space="preserve"><textual class="po-textual">default namespace = "omissible+http://my.namespace.com/"
namespace terminal = "http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"</textual></programlisting><para class="po-block e78 e78"><textual class="po-textual">The elements in the </textual><code class="po-atom e79 e79"><textual class="po-textual">terminal</textual></code><textual class="po-textual"> namespace are perfectly ordinary XML elements; what gives them a special meaning is
that the parser deletes them from the constructed syntax tree together with their content. The elements with the
</textual><code class="po-atom e80 e80"><textual class="po-textual">omissible+</textual></code><textual class="po-textual"> namespace prefix will be kept in the normalized XML output, but their URI prefix will be removed. This
stripping of terminal elements and omissible namespace prefixes is the default mode of operation. The parser can also be
made to emit all the terminal nodes and keep the omissible namespace prefixes. For the above example schema and the
input paragraph</textual></para><programlisting class="po-block e81 e81" xml:space="preserve"><textual class="po-textual">Here's a **fat
and somewhat //slanted
// text**
example.</textual></programlisting><para class="po-block e82 e82"><textual class="po-textual">the default output of the parser is</textual></para><programlisting class="po-block e83 e83" xml:space="preserve"><textual class="po-textual">&lt;paragraph xmlns="http://my.namespace.com"&gt;Here's a &lt;bold&gt;fat
and somewhat &lt;italic&gt;slanted
&lt;/italic&gt; text&lt;/bold&gt;
example.&lt;/paragraph&gt;
</textual></programlisting><para class="po-block e84 e84"><textual class="po-textual">and the raw output, if requested, would be</textual></para><programlisting class="po-block e85 e85" xml:space="preserve"><textual class="po-textual">&lt;paragraph
   xmlns="omissible+http://my.namespace.com"
   xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
&gt;Here's a &lt;bold&gt;&lt;terminal:bold_marker&gt;**&lt;/terminal:bold_marker&gt;fat
and somewhat &lt;italic&gt;&lt;terminal:italic_marker&gt;//&lt;/terminal:italic_marker&gt;slanted
&lt;terminal:italic_marker&gt;//&lt;/terminal:italic_marker&gt;&lt;/italic&gt; text&lt;terminal:bold_marker&gt;**&lt;/terminal:bold_marker&gt;&lt;/bold&gt;
example.&lt;terminal:paragraph_separator&gt;

&lt;/terminal:paragraph_separator&gt;&lt;/paragraph&gt;</textual></programlisting><para class="po-block e86 e86"><textual class="po-textual">Both these outputs are well-formed XML and contain no text markers. The former is valid against the original RELAX NG
schema, and the latter is valid against the enriched schema. If we want to replicate the behaviour of an SGML DTD, where
one can alternate between shortrefs and regular element tags, all we need do is combine the two schemata into one. The
cleanest way to accomplish the same effect is to have the concrete-syntax schema include the original one, combining the
original definitions with its own. If the original schema was defined in file </textual><code class="po-atom e87 e87"><textual class="po-textual">strict.rng</textual></code><textual class="po-textual">, the extended schema could be
defined in a separate file as follows:</textual></para><programlisting class="po-block e88 e88" xml:space="preserve"><textual class="po-textual">default namespace = "omissible+http://my.namespace.com/"
namespace terminal = "http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"

include "strict.rng"

paragraph  |= element para {
                 (plain-text | bold | italic)*,
                 paragraph_separator?
              }
bold       |= element bold {
                 bold_marker,
                 (plain-text | italic)*,
                 bold_marker
              }
italic     |= element italic {
                 italic_marker,
                 (plain-text | bold)*,
                 italic_marker
              }
plain-text  = text

bold_marker         = element terminal:bold_marker { "**" }
italic_marker       = element terminal:italic_marker { "//" }
paragraph_separator = element terminal:paragraph_separator {
                         "&amp;#x0a;&amp;#x0a;"
                      }</textual></programlisting><para class="po-block e89 e89"><textual class="po-textual">Both the default and the raw output (i.e., the abstract and the concrete syntax tree) now conform to the same RELAX NG
schema, and we can use any conforming RELAX NG validator to verify this.</textual></para></section><section class="po-hcontainer e90 e90"><title class="po-block e91 e91"><textual class="po-textual"> Implementation</textual></title><para class="po-block e92 e92"><textual class="po-textual">The parser for the schema specifications described in the previous section has been implemented in Haskell and can be
found at </textual><link class="po-inline e93 e93" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://hackage.haskell.org/package/concrete-relaxng-parser</textual></link><textual class="po-textual">. It compiles to a standalone executable
that requires two file names as arguments: the target RELAX NG schema (with or without any concrete-syntax extensions),
and the input XML document.</textual></para><para class="po-block e94 e94"><textual class="po-textual">The implementation of the concrete-syntax parser is based on the RELAX NG reference implementation[</textual><citation class="po-atom e95 e95" linkend="c02"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] with its novel algorithm based on Brzozowski derivatives[</textual><citation class="po-atom e96 e96" linkend="b64"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] [</textual><citation class="po-atom e97 e97" linkend="s05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">], together with some extensions described in our previous work[</textual><citation class="po-atom e98 e98" linkend="b10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. In particular,
the inference of the missing element tags is the same as in [</textual><citation class="po-atom e99 e99" linkend="b10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">], the only change being its
restriction to the set of elements whose namespace URI begins with the string </textual><code class="po-atom e100 e100"><textual class="po-textual">omissible+</textual></code><textual class="po-textual">. The rest of this section
will concentrate on details that have not been described elsewhere.</textual></para><para class="po-block e101 e101"><textual class="po-textual">The biggest change from [</textual><citation class="po-atom e102 e102" linkend="b10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] is in the </textual><code class="po-atom e103 e103"><textual class="po-textual">textDeriv</textual></code><textual class="po-textual"> function. Both in the reference validator and
in the previous normalizer implementation, this function must match its pattern argument against its entire text node
argument. Now a pattern is allowed to consume only a prefix of the current text node, so the Brzozowski derivatives
cannot be calculated as easily. One possible solution would be to calculate the derivative character by character, but
its performance would be unacceptable. We also considered introducing a lexical layer that separates all possible
syntactic markers from the rest of the text, but in the end we settled for a mixed derivative/continuation-passing
algorithm. The </textual><code class="po-atom e104 e104"><textual class="po-textual">textDeriv</textual></code><textual class="po-textual"> function takes two continuations, one invoked in case the pattern consumes the entire text
node and the other in case there is some leftover text. This way each pattern is free to consume as much text as it can
match in a single try, and pass the rest to the continuation pattern.</textual></para><para class="po-block e105 e105"><textual class="po-textual">This technique unfortunately does not implement the </textual><code class="po-atom e106 e106"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> patterns properly. If their semantics from the RELAX NG
specification was carried over to the text nodes literally, it would imply that an </textual><code class="po-atom e107 e107"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> pattern should match any
interleaving of the character sequences matched by its two branches. This semantics would be very difficult to implement
efficiently, but more importantly, it would probably be useless in practice. Instead, </textual><code class="po-atom e108 e108"><textual class="po-textual">textDeriv</textual></code><textual class="po-textual"> implements the
</textual><code class="po-atom e109 e109"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> pattern as an alternation: one of its branches is matched followed by the other. This semantics is
unfortunately not composable. At this time we must recommend against the use of </textual><code class="po-atom e110 e110"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> in concrete syntax
definitions. The semantics of </textual><code class="po-atom e111 e111"><textual class="po-textual">interleave</textual></code><textual class="po-textual"> across multiple XML elements and text nodes is not affected by this problem.</textual></para><para class="po-block e112 e112"><textual class="po-textual">Another significant hurdle to overcome in the adaptation of RELAX NG to the task of parsing text is its </textual><code class="po-atom e113 e113"><textual class="po-textual">text</textual></code><textual class="po-textual">
pattern. Having been designed for the validation of XML documents, RELAX NG allows the </textual><code class="po-atom e114 e114"><textual class="po-textual">text</textual></code><textual class="po-textual"> pattern to match any
arbitrary contiguous region of text. The boundaries of this region are determined by the surrounding markup tags. Since
we cannot count on these hard boundaries, we must keep track of all syntactic markers that can appear instead of element
tags. These markers are divided into two sets, the </textual><emphasis class="po-inline e115 e115"><textual class="po-textual">alternate set</textual></emphasis><textual class="po-textual"> and the </textual><emphasis class="po-inline e116 e116"><textual class="po-textual">follow set</textual></emphasis><textual class="po-textual">. The former contains all
markers that can begin an alternative to the current pattern, while the latter contains all markers that can appear
after the end of the current pattern.</textual></para><para class="po-block e117 e117"><textual class="po-textual">The same approach is applied to </textual><code class="po-atom e118 e118"><textual class="po-textual">data</textual></code><textual class="po-textual"> and </textual><code class="po-atom e119 e119"><textual class="po-textual">dataExcept</textual></code><textual class="po-textual"> patterns: they are bounded by the next following
marker. They consume the longest possible prefix, recognized by the data type, of the text preceding the marker.</textual></para><para class="po-block e120 e120"><textual class="po-textual">Whitespace is for the most part handled the same as all other text. The only two exceptions are that the whitespace
consumption does not affect the alternate set and follow set of syntactic markers, and that any amount of whitespace can
precede an explicit element tag. The latter feature follows the behaviour of the standard RELAX NG validator, which
ignores whitespace between elements.</textual></para></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual"> Results and future directions</textual></title><para class="po-block e123 e123"><textual class="po-textual">The presented RELAX NG extension could be applied to many RELAX NG schemata and used to shorten their instances. Whether
it </textual><emphasis class="po-inline e124 e124"><textual class="po-textual">should</textual></emphasis><textual class="po-textual"> be applied to any particular schema depends mostly on outside factors like the target audience and
document corpus. There are also, however, several technical factors that must be taken into consideration.</textual></para><itemizedlist class="po-table e125 e125"><listitem class="po-container e126 e126"><para class="po-block e127 e127"><textual class="po-textual"> Syntactic markers can only be used to infer element tags without any specified attributes. This shortcoming is partly
  a consequence of the inability to specify fixed attribute values in RELAX NG, and could potentially be remedied by
  future extensions.</textual></para></listitem><listitem class="po-container e128 e128"><para class="po-block e129 e129"><textual class="po-textual"> While a schema extended with syntactic markers and omissible element tags can replicate most common uses of SGML
  SHORTREF feature, it is a fundamentally different mechanism. A SHORTREF can expand to any general entity, which is
  free to include multiple elements with specified attributes and arbitrary content. A syntactic marker serves only to
  guide the parser in which omissible elements should be inferred, and these inferred elements are the only possible
  addition to the parsed output.</textual></para></listitem><listitem class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual"> SGML derives some benefit from being a large and integrated specification. In particular, we can offer no equivalent
  to SGML </textual><code class="po-atom e132 e132"><textual class="po-textual">usemap</textual></code><textual class="po-textual"> declaration which can activate an arbitrary set of shortrefs in any position in the document, or turn
  them all off. Since our input is well-formed XML, we could instead introduce special processing instructions that
  affect the parser's behaviour. The main obstacle currently is that the RELAX NG infrastructure normalizes the XML
  input, removing all processing instructions prior to validation and parsing. The </textual><code class="po-atom e133 e133"><textual class="po-textual">CDATA</textual></code><textual class="po-textual"> marked sections are also
  normalized away, which presents an even more serious problem because the parser may infer elements within them.</textual></para></listitem><listitem class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual"> The current performance of the parser is sufficient for authoring documents with syntactic markers and occasional
  one-off conversion to a fully tagged instance, but it would impose a significant overhead in a repeatedly invoked
  markup-processing pipeline. The worst-case performance of any parser implementation will depend on the details of the
  schema; since RELAX NG does not impose LL(1) or similar constraints, neither do we.</textual></para></listitem><listitem class="po-container e136 e136"><para class="po-block e137 e137"><textual class="po-textual"> A judicious use of syntactic markers can ease the XML document authoring in a text editor. Their benefits would be
  diminished if used with an XML editor; they could even degrade the experience in this context.</textual></para></listitem><listitem class="po-container e138 e138"><para class="po-block e139 e139"><textual class="po-textual"> There is currently no support for automatic inference of the desired element nesting level, like Wiki for example does
  with the indentation of the list item bullets. To allow an element to be nested within itself, the schema must specify
  a different syntactic marker for each element nesting level. Alternatively, one can always nest explicit element tags.</textual></para></listitem><listitem class="po-container e140 e140"><para class="po-block e141 e141"><textual class="po-textual"> On the positive side, the concrete-syntax schema can be as modular as a regular, abstract-syntax RELAX NG schema. It
  is possible to experiment with multiple different concrete syntaxes for the same abstract syntax, for example, or
  </textual><emphasis class="po-inline e142 e142"><textual class="po-textual">vice versa</textual></emphasis><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e143 e143"><para class="po-block e144 e144"><textual class="po-textual"> The parser translates an XML document from concrete to abstract syntax. There is currently no tool support for
  performing a reverse translation. This would be a problem for any deployment scenario which allows a document to be
  edited in both the explicitly-tagged and its concrete syntax variant.</textual></para></listitem></itemizedlist><para class="po-block e145 e145"><textual class="po-textual">As a proof of concept, the present paper has been written in concrete syntax and translated to the abstract syntax
conforming with the target schema. The concrete-syntax schema extension is given in </textual><xref class="po-milestone e146 e146" linkend="schema"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e147 e147"><textual class="po-textual">The sample schema extension modifies seven elements: </textual><code class="po-atom e148 e148"><textual class="po-textual">code</textual></code><textual class="po-textual">, </textual><code class="po-atom e149 e149"><textual class="po-textual">emphasis</textual></code><textual class="po-textual">, </textual><code class="po-atom e150 e150"><textual class="po-textual">listitem</textual></code><textual class="po-textual">, </textual><code class="po-atom e151 e151"><textual class="po-textual">para</textual></code><textual class="po-textual">, </textual><code class="po-atom e152 e152"><textual class="po-textual">programlisting</textual></code><textual class="po-textual">, </textual><code class="po-atom e153 e153"><textual class="po-textual">quote</textual></code><textual class="po-textual">,
and </textual><code class="po-atom e154 e154"><textual class="po-textual">title</textual></code><textual class="po-textual">. Their tags are made omissible in all contexts where they can occur, with the exception of </textual><code class="po-atom e155 e155"><textual class="po-textual">emphasis</textual></code><textual class="po-textual"> which
must be explicitly tagged inside </textual><code class="po-atom e156 e156"><textual class="po-textual">programlisting</textual></code><textual class="po-textual"> and inside an inferred </textual><code class="po-atom e157 e157"><textual class="po-textual">emphasis</textual></code><textual class="po-textual">. Each of the seven elements is also
given a concrete syntax with different terminal symbols. Authored with the full use of these extensions, the present
paper contains a total of 141 element tags — mostly of elements with required attributes. Once parsed into an
explicitly tagged XML instance, it gains additional 284 element tags.</textual></para><para class="po-block e158 e158"><textual class="po-textual">Another example in </textual><xref class="po-milestone e159 e159" linkend="xhtml"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> presents a small extension of the modularized RELAX NG schema for XHTML 1.0[</textual><citation class="po-atom e160 e160" linkend="c08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">]. We hope to prepare more concrete syntax extensions like these for other XML schemata in the
future.</textual></para></section><section class="po-hcontainer e161 e161"><title class="po-block e162 e162"><textual class="po-textual"> Related work</textual></title><para class="po-block e163 e163"><textual class="po-textual">The tool presented herein treats the RELAX NG schema as an abstract syntax description, and sprinkles it with some
extensions for describing the concrete syntax of the language. There have been other tools[</textual><citation class="po-atom e164 e164" linkend="p09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] [</textual><citation class="po-atom e165 e165" linkend="q11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] using the same approach of starting with the abstract syntax and extending it
with concrete syntax annotations. The abstract syntax notation in these related works is tool-specific, since they don't
use XML as the abstract syntax tree.</textual></para><para class="po-block e166 e166"><textual class="po-textual">On the other hand, there are numerous reports[</textual><citation class="po-atom e167 e167" linkend="b00"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] [</textual><citation class="po-atom e168 e168" linkend="c03"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] [</textual><citation class="po-atom e169 e169" linkend="m04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] [</textual><citation class="po-atom e170 e170" linkend="r05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] that focus on using XML as the target abstract syntax tree (AST) notation of a
parser for some concrete syntax. To perform their parsing, however, they use parser-generators such as ANTLR[</textual><citation class="po-atom e171 e171" linkend="p95"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">] and other traditional parsing tools, so they specify their concrete syntax in the formalism those tools
require. Those that use an XML schema at all, use it only to validate the generated AST.</textual></para></section><appendix class="po-hcontainer e172 e172" xml:id="schema"><title class="po-block e173 e173"><textual class="po-textual"> Concrete syntax schema extension for Balisage submissions</textual></title><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;grammar ns="omissible+http://docbook.org/ns/docbook"
         xmlns:explicit="http://docbook.org/ns/docbook"
         xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
         xmlns:non-syntactic="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Nonterminal_symbols"
         xmlns="http://relaxng.org/ns/structure/1.0"
         datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;

  &lt;!-- The balisage-1-3a.rng schema included below is semantically equivalent to the original Balisage 
       schema, but slightly refactored with the following definitions added for reuse:

    - code.content
    - emphasis.content
    - para.content
    - programlisting.content
    - quote.content
    - title.content
  --&gt;
  &lt;include href="balisage-1-3a.rng"&gt;
    &lt;define name="programlisting.content"&gt;
      &lt;ref name="programlisting.content.explicit"/&gt;
    &lt;/define&gt;
  &lt;/include&gt;

  &lt;define name="title" combine="choice"&gt;
    &lt;element name="title"&gt;
      &lt;ref name="title.attlist"/&gt;
      &lt;ref name="title.content"/&gt;
      &lt;ref name="paragraph_separator"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="para" combine="choice"&gt;
    &lt;element name="para"&gt;
      &lt;ref name="para.attlist"/&gt;
      &lt;ref name="para.content.non-recursive"/&gt;
      &lt;ref name="paragraph_separator"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="programlisting" combine="choice"&gt;
    &lt;element name="programlisting"&gt;
      &lt;ref name="programlisting.attlist"/&gt;
      &lt;ref name="programlisting_open_marker"/&gt;
      &lt;ref name="programlisting.content.explicit"/&gt;
      &lt;ref name="programlisting_close_marker"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="listitem" combine="choice"&gt;
    &lt;element name="listitem"&gt;
      &lt;ref name="listitem.attlist"/&gt;
      &lt;ref name="listitem_marker"/&gt;
      &lt;oneOrMore&gt;
        &lt;ref name="para.level"/&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="code" combine="choice"&gt;
    &lt;element name="code"&gt;
      &lt;ref name="code.attlist"/&gt;
      &lt;ref name="code_marker"/&gt;
      &lt;ref name="code.content"/&gt;
      &lt;ref name="code_marker"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="emphasis" combine="choice"&gt;
    &lt;element name="emphasis"&gt;
      &lt;ref name="emphasis.attlist"/&gt;
      &lt;ref name="emphasis_marker"/&gt;
      &lt;ref name="emphasis.content.non-recursive"/&gt;
      &lt;ref name="emphasis_marker"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="quote" combine="choice"&gt;
    &lt;element name="quote"&gt;
      &lt;ref name="quote.attlist"/&gt;
      &lt;ref name="quote_marker"/&gt;
      &lt;ref name="quote.content"/&gt;
      &lt;ref name="quote_marker"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;!-- inlined emphasis.content, but with only explicit nested emphasis --&gt;
  &lt;define name="emphasis.content.non-recursive"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        &lt;text/&gt;
        &lt;ref name="link"/&gt;
        &lt;ref name="citation"/&gt;
        &lt;ref name="emphasis.explicit"/&gt;
        &lt;ref name="footnote"/&gt;
        &lt;ref name="trademark"/&gt;
        &lt;ref name="email"/&gt;
        &lt;ref name="code"/&gt;
        &lt;ref name="superscript"/&gt;
        &lt;ref name="subscript"/&gt;
        &lt;ref name="quote"/&gt;
        &lt;ref name="xref"/&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;!-- emphasis element with explicit tags --&gt;
  &lt;define name="emphasis.explicit"&gt;
    &lt;element name="explicit:emphasis"&gt;
      &lt;ref name="emphasis.attlist"/&gt;
      &lt;ref name="emphasis.content"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;!-- para.content minus the block-level elements which can recursively nest a paragraph --&gt;
  &lt;define name="para.content.non-recursive"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        &lt;text/&gt;
        &lt;ref name="citation"/&gt;
        &lt;ref name="code"/&gt;
        &lt;ref name="email"/&gt;
        &lt;ref name="emphasis"/&gt;
        &lt;ref name="equation"/&gt;
        &lt;ref name="inlinemediaobject"/&gt;
        &lt;ref name="link"/&gt;
        &lt;ref name="subscript"/&gt;
        &lt;ref name="superscript"/&gt;
        &lt;ref name="trademark"/&gt;
        &lt;ref name="quote"/&gt;
        &lt;ref name="xref"/&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;!-- programlisting.content with only the explicit emphasis --&gt;
  &lt;define name="programlisting.content.explicit"&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        &lt;text/&gt;
        &lt;ref name="emphasis.explicit"/&gt;
        &lt;ref name="superscript"/&gt;
        &lt;ref name="subscript"/&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;define name="emphasis_marker"&gt;
    &lt;element name="terminal:emphasis_marker"&gt;
      &lt;value type="string"&gt;''&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="paragraph_separator"&gt;
    &lt;element name="terminal:paragraph_separator"&gt;
      &lt;value type="string"&gt;&amp;#x0a;&amp;#x0a;&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="programlisting_open_marker"&gt;
    &lt;element name="terminal:programlisting_open_marker"&gt;
      &lt;value type="string"&gt;{{{&amp;#x0a;&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="programlisting_close_marker"&gt;
    &lt;element name="terminal:programlisting_close_marker"&gt;
      &lt;value type="string"&gt;&amp;#x0a;}}}&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="listitem_marker"&gt;
    &lt;element name="terminal:listitem_marker"&gt;
      &lt;value type="token"&gt;*&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="code_marker"&gt;
    &lt;element name="terminal:code_marker"&gt;
      &lt;value type="string"&gt;`&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="quote_marker"&gt;
    &lt;element name="terminal:quote_marker"&gt;
      &lt;value type="string"&gt;"&lt;/value&gt;
    &lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</textual></programlisting></appendix><appendix class="po-hcontainer e175 e175" xml:id="xhtml"><title class="po-block e176 e176"><textual class="po-textual"> Concrete syntax extension of XHTML schema</textual></title><programlisting class="po-block e177 e177" xml:space="preserve"><textual class="po-textual">&lt;grammar ns="omissible+http://www.w3.org/1999/xhtml"
         xmlns:explicit="http://www.w3.org/1999/xhtml"
         xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
         xmlns="http://relaxng.org/ns/structure/1.0"&gt;

&lt;include href="xhtml/xhtml-strict.rng"/&gt;

&lt;define name="head" combine="choice"&gt;
  &lt;element name="head"&gt;
    &lt;ref name="head.content"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="title" combine="choice"&gt;
  &lt;element name="title"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="body" combine="choice"&gt;
  &lt;element name="body"&gt;
    &lt;ref name="Block.model"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="p" combine="choice"&gt;
  &lt;element name="p"&gt;
    &lt;ref name="paragraph_separator"/&gt;
    &lt;ref name="Inline.model"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ol" combine="choice"&gt;
  &lt;element name="ol"&gt;
    &lt;oneOrMore&gt;
      &lt;ref name="ol.li"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ul" combine="choice"&gt;
  &lt;element name="ul"&gt;
    &lt;oneOrMore&gt;
      &lt;ref name="ul.li"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="hr" combine="choice"&gt;
  &lt;element name="hr"&gt;
    &lt;ref name="hr_marker"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="em" combine="choice"&gt;
  &lt;element name="em"&gt;
    &lt;ref name="emphasis_marker"/&gt;
    &lt;ref name="em.content.non-recursive"/&gt;
    &lt;ref name="emphasis_marker"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ol.li"&gt;
  &lt;element name="li"&gt;
    &lt;ref name="ol_item_marker"/&gt;
    &lt;ref name="li.content.non-recursive"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ul.li"&gt;
  &lt;element name="li"&gt;
    &lt;ref name="ul_item_marker"/&gt;
    &lt;ref name="li.content.non-recursive"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="em.content.non-recursive"&gt;
  &lt;zeroOrMore&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;ref name="abbr"/&gt;
      &lt;ref name="acronym"/&gt;
      &lt;ref name="br"/&gt;
      &lt;ref name="cite"/&gt;
      &lt;ref name="code"/&gt;
      &lt;ref name="dfn"/&gt;
      &lt;ref name="kbd"/&gt;
      &lt;ref name="q"/&gt;
      &lt;ref name="samp"/&gt;
      &lt;ref name="span"/&gt;
      &lt;ref name="strong"/&gt;
      &lt;ref name="var"/&gt;
      &lt;ref name="em.explicit"/&gt;
    &lt;/choice&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;

&lt;define name="li.content.non-recursive"&gt;
  &lt;zeroOrMore&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;ref name="Inline.class"/&gt;
      &lt;ref name="address"/&gt;
      &lt;ref name="blockquote"/&gt;
      &lt;ref name="div"/&gt;
      &lt;ref name="pre"/&gt;
      &lt;ref name="Heading.class"/&gt;
      &lt;ref name="dl"/&gt;
      &lt;ref name="p.explicit"/&gt;
      &lt;ref name="ol.explicit"/&gt;
      &lt;ref name="ul.explicit"/&gt;
    &lt;/choice&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;

&lt;define name="em.explicit"&gt;
  &lt;element name="explicit:em"&gt;
    &lt;ref name="em.attlist"/&gt;
    &lt;ref name="Inline.model"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="p.explicit"&gt;
  &lt;element name="explicit:p"&gt;
    &lt;ref name="p.attlist"/&gt;
    &lt;ref name="Inline.model"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ol.explicit"&gt;
  &lt;element name="explicit:ol"&gt;
    &lt;ref name="ol.attlist"/&gt;
    &lt;oneOrMore&gt;
      &lt;ref name="li"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ul.explicit"&gt;
  &lt;element name="explicit:ul"&gt;
    &lt;ref name="ul.attlist"/&gt;
    &lt;oneOrMore&gt;
      &lt;ref name="li"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="emphasis_marker"&gt;
  &lt;element name="terminal:emphasis_marker"&gt;
    &lt;value type="string"&gt;*&lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="paragraph_separator"&gt;
  &lt;element name="terminal:paragraph_separator"&gt;
    &lt;value type="string"&gt;&amp;#x0a;&amp;#x0a;&lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="line_separator"&gt;
  &lt;element name="terminal:line_separator"&gt;
    &lt;value type="string"&gt;&amp;#x0a;&lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ol_item_marker"&gt;
  &lt;element name="terminal:ol_item_marker"&gt;
    &lt;value type="token"&gt;&amp;#x0a;# &lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="ul_item_marker"&gt;
  &lt;element name="terminal:ul_item_marker"&gt;
    &lt;value type="token"&gt;&amp;#x0a;* &lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="hr_marker"&gt;
  &lt;element name="terminal:hr_marker"&gt;
    &lt;value type="token"&gt;&amp;#x0a;----&lt;/value&gt;
  &lt;/element&gt;
&lt;/define&gt;
&lt;/grammar&gt;</textual></programlisting></appendix><bibliography class="po-hcontainer e178 e178"><title class="po-block e179 e179"><textual class="po-textual"> Bibliography</textual></title><bibliomixed class="po-block e180 e180" xml:id="b59"><textual class="po-textual">
    Backus, J.W.,
    The Syntax and Semantics of the Proposed International Algebraic Language of Zürich ACM-GAMM Conference,
    </textual><emphasis class="po-inline e181 e181"><textual class="po-textual">Proceedings of the International Conference on Information Processing, UNESCO</textual></emphasis><textual class="po-textual">,
    1959, pp.125-132.
  </textual></bibliomixed><bibliomixed class="po-block e182 e182" xml:id="b64"><textual class="po-textual">
    Brzozowski, J. A. 1964. Derivatives of Regular Expressions. </textual><emphasis class="po-inline e183 e183"><textual class="po-textual">J. ACM 11</textual></emphasis><textual class="po-textual">,
    4 (Oct. 1964), 481-494.
    doi:</textual><biblioid class="po-atom e184 doi e184"><textual class="po-textual">10.1145/321239.321249</textual></biblioid><textual class="po-textual">.
  </textual></bibliomixed><bibliomixed class="po-block e185 e185" xml:id="b00"><textual class="po-textual">
    Greg J. Badros. 2000.
    JavaML: a markup language for Java source code.
    </textual><emphasis class="po-inline e186 e186"><textual class="po-textual">Computer Networks</textual></emphasis><textual class="po-textual"> 33, 1-6 (June 2000), 159-177.
    doi:</textual><biblioid class="po-atom e187 doi e187"><textual class="po-textual">10.1016/S1389-1286(00)00037-2</textual></biblioid><textual class="po-textual">.
  </textual></bibliomixed><bibliomixed class="po-block e188 e188" xml:id="b07"><textual class="po-textual">
    Mark Bergsma, 2007. Wikimedia architecture
    </textual><link class="po-inline e189 e189" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.nedworks.org/~mark/presentations/kennisnet/Wikimedia%20architecture%20(kennisnet).pdf</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e190 e190" xml:id="b10"><textual class="po-textual">
    Mario Blažević, 2010. Grammar-driven Markup Generation.
    In </textual><emphasis class="po-inline e191 e191"><textual class="po-textual">Proceedings of Balisage: The Markup Conference 2010</textual></emphasis><textual class="po-textual">.
    Balisage Series on Markup Technologies, vol. 5 (2010).
    </textual><link class="po-inline e192 e192" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol5/html/Blazevic01/BalisageVol5-Blazevic01.html</textual></link><textual class="po-textual">.
    doi:</textual><biblioid class="po-atom e193 doi e193"><textual class="po-textual">10.4242/BalisageVol5.Blazevic01</textual></biblioid><textual class="po-textual">.
  </textual></bibliomixed><bibliomixed class="po-block e194 e194" xml:id="c01"><textual class="po-textual">
    James Clark and Makoto Murata. RELAX NG Specification.
    </textual><link class="po-inline e195 e195" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://relaxng.org/spec-20011203.html</textual></link><textual class="po-textual">, 2001. ISO/IEC 19757-2:2003.
  </textual></bibliomixed><bibliomixed class="po-block e196 e196" xml:id="c02"><textual class="po-textual">
    James Clark. An algorithm for RELAX NG validation
    </textual><link class="po-inline e197 e197" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.thaiopensource.com/relaxng/derivative.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e198 e198" xml:id="c02c"><textual class="po-textual">
    James Clark. RELAX NG compact syntax, Committee Specification 21 November 2002, OASIS
    </textual><link class="po-inline e199 e199" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://relaxng.org/compact-20021121.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e200 e200" xml:id="c08"><textual class="po-textual">
    James Clark. Modularization of XHTML in RELAX NG
    </textual><link class="po-inline e201 e201" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.thaiopensource.com/relaxng/xhtml/</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e202 e202" xml:id="c03"><textual class="po-textual">
    James R. Cordy, 2003.
    Generalized Selective XML Markup of Source Code Using Agile Parsing.
    In </textual><emphasis class="po-inline e203 e203"><textual class="po-textual">Proceedings of the 11th IEEE International Workshop on Program Comprehension</textual></emphasis><textual class="po-textual"> (IWPC '03).
    IEEE Computer Society, Washington, DC, USA, 144-
  </textual></bibliomixed><bibliomixed class="po-block e204 e204" xml:id="j04"><textual class="po-textual">
    Rick Jeliffe. From Wiki to XML, through SGML.
    </textual><link class="po-inline e205 e205" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xml.com/pub/a/2004/03/03/sgmlwiki.html</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e206 e206" xml:id="m62"><textual class="po-textual">
    John McCarthy,
    Towards a Mathematical Science of Computation,
    Proceedings of </textual><emphasis class="po-inline e207 e207"><textual class="po-textual">IFIP Congress</textual></emphasis><textual class="po-textual"> 1962,
    pages 21-28,
    </textual><emphasis class="po-inline e208 e208"><textual class="po-textual">North Holland Publishing Company</textual></emphasis><textual class="po-textual">, Amsterdam
  </textual></bibliomixed><bibliomixed class="po-block e209 e209" xml:id="m04"><textual class="po-textual">
    J.I. Maletic, M. Collard, and H. Kagdi,
    Leveraging XML technologies in developing program analysis tools.
    IEEE Digest 2004, 80 (2004), doi:</textual><biblioid class="po-atom e210 doi e210"><textual class="po-textual">10.1049/ic:20040255</textual></biblioid><textual class="po-textual">.
  </textual></bibliomixed><bibliomixed class="po-block e211 e211" xml:id="p95"><textual class="po-textual">
    Parr, T. J. and Quong, R. W.  ANTLR: A predicated-LL(k) parser generator.
    </textual><emphasis class="po-inline e212 e212"><textual class="po-textual">Software: Practice and Experience</textual></emphasis><textual class="po-textual">,
    volume 25, issue 7, 1995. John Wiley &amp; Sons, Ltd.
    doi:</textual><biblioid class="po-atom e213 doi e213"><textual class="po-textual">10.1002/spe.4380250705</textual></biblioid><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e214 e214" xml:id="p09"><textual class="po-textual">
    Jaroslav Porubän, Michal Forgáč, and Miroslav Sabo, Annotation Based Parser Generator.
    </textual><emphasis class="po-inline e215 e215"><textual class="po-textual">Proceedings of the International Multiconference on Computer Science and Information Technology</textual></emphasis><textual class="po-textual">, 2009, pp. 707–714
  </textual></bibliomixed><bibliomixed class="po-block e216 e216" xml:id="q11"><textual class="po-textual">
    Luis Quesada, Fernando Berzal, and Juan-Carlos Cubero,
    A Tool for Model-Based Language Specification.
    Department of Computer Science and Artificial Intelligence, CITIC, University of Granada,
    </textual><link class="po-inline e217 e217" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://arxiv.org/abs/1111.3970v1</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e218 e218" xml:id="r05"><textual class="po-textual">
    Raihan Al-Ekram and Kostas Kontogiannis. 2005.
    An XML-Based Framework for Language Neutral Program Representation Generic Analysis.
    In </textual><emphasis class="po-inline e219 e219"><textual class="po-textual">Proceedings of the Ninth European Conference on Software Maintenance and Reengineering (CSMR '05)</textual></emphasis><textual class="po-textual">.
    IEEE Computer Society, Washington, DC, USA, 42-51.
    doi:</textual><biblioid class="po-atom e220 doi e220"><textual class="po-textual">10.1109/CSMR.2005.10</textual></biblioid><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e221 e221" xml:id="s05"><textual class="po-textual">
    Sperberg-McQueen, C. M. Applications of Brzozowski derivatives to XML schema processing.
    In </textual><emphasis class="po-inline e222 e222"><textual class="po-textual">Extreme Markup Languages</textual></emphasis><textual class="po-textual"> 2005, page 26, Internet, 2005. IDEAlliance.
  </textual></bibliomixed><bibliomixed class="po-block e223 e223" xml:id="s86"><textual class="po-textual">
    Standard Generalized Markup Language (SGML)
    </textual><emphasis class="po-inline e224 e224"><textual class="po-textual">International Organization for Standardization</textual></emphasis><textual class="po-textual"> ISO 8879:1986
  </textual></bibliomixed><bibliomixed class="po-block e225 e225" xml:id="w93"><textual class="po-textual">
    Sam Wilmott, Beyond SGML.
    </textual><emphasis class="po-inline e226 e226"><textual class="po-textual">Exoterica Technical Report</textual></emphasis><textual class="po-textual"> ETR-9, 1993.
    </textual><link class="po-inline e227 e227" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://developers.omnimark.com/etcetera/etr09/</textual></link><textual class="po-textual">
  </textual></bibliomixed></bibliography></article></classedDocument>