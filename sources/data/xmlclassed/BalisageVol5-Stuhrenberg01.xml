<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">Refining the Taxonomy of XML Schema Languages. A new Approach for Categorizing XML Schema
    Languages in Terms of Processing Complexity</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">This paper presents a refined taxonomy of XML schema languages based on the work by
          </textual><xref class="po-milestone e8 e8" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. It can be seen as first building block for a more elaborate
        formal analysis of XML and its accompanied specifications, in this case: XML schema
        languages such as DTD, XSD and RELAX NG.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Maik</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Stührenberg</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Maik Stührenberg studied Computational Linguistics at Bielefeld University. After
          working for four years as research assistant at Giessen University in different
          text-technological projects, he is now a Ph. D. student and research assistant at
          Bielefeld University. His main research interests include XML schema languages and
          specifications for structuring and querying multi-dimensional annotated data.</textual></para></personblurb></author><author class="po-record e15 e15"><personname class="po-record e16 e16"><firstname class="po-field e17 e17"><textual class="po-textual">Christian</textual></firstname><surname class="po-field e18 e18"><textual class="po-textual">Wurm</textual></surname></personname><personblurb class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Christian Wurm is a Ph. D. student in Computational and Mathematical Linguistics at
          Bielefeld University in the Cognitive Interaction Technology – Center of Excellence
          (CITEC) at Bielefeld University.</textual></para></personblurb></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Copyright © 2010 by the authors.  Used with
   permission.</textual></para></legalnotice><keywordset class="po-table e23 e23" role="author"><keyword class="po-field e24 e24"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">Formal Language Theory</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">Schema Languages</textual></keyword></keywordset></info><note class="po-container e27 e27"><para class="po-block e28 e28"><textual class="po-textual">The authors would like to thank both the reviewers for their constructive comments and our
      colleagues Marcus Kracht and Jens Michaelis who provided additional insightful remarks.</textual></para></note><section class="po-hcontainer e29 e29"><title class="po-block e30 e30"><textual class="po-textual">Introduction</textual></title><para class="po-block e31 e31"><textual class="po-textual">In this paper, we continue the fruitful research that has been performed on XML and
      formal language theory (see </textual><xref class="po-milestone e32 e32" linkend="sec.xml_formal"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). As there is a close
      correspondence between schema languages and a hierarchy of tree languages discussed by </textual><xref class="po-milestone e33 e33" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and to which we will refer as the Murata hierarchy, formal language
      theory has been very useful to determine and describe the expressiveness and computability of
      different XML schema languages. From the point of view of formal language theory (ignoring
      things such as user-friendliness or software support, amongst others), the question which
      grammar formalism is most apt for defining a document grammar for a given XML markup language
      is determined by a trade-off between expressiveness on one side and processing complexity on
      the other side. The more expressive a grammar formalism is, the more resources we need for
      processing the corresponding languages, and the more likely are they to fall prey to
      ambiguity.</textual></para><para class="po-block e34 e34"><textual class="po-textual">Expressiveness thus always comes at a cost; it is, however, not always quite clear at
      which cost. To make these things more clear is one goal of this paper. We will look at some
      well-known classes of formal grammars/languages that are relevant for XML, and scrutinize
      their expressivity and processing cost. Pursuing this approach, we will see that there are
      some other interesting and relevant classes, which have not been formally established yet to
      the best of our knowledge, and which we will define in the sequel. These classes partly
      refine, partly complement the hierarchy of </textual><xref class="po-milestone e35 e35" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and, as we will see,
      are partly already tacitly in use. Our main focus will not be on (non-)determinism in content
      models, that is, on properties of regular expressions; rather we will focus on determinism in
      tree structures, and try to formally clarify the relation between determinism and
      expressivity, as well as between locally and globally ambiguous grammars/trees. On the way, we
      provide some new results for the problem of ambiguity not only of grammars, but also of
      languages: as we will see, there are languages for which there is no unambiguous grammar, and
      not yet a class of grammars which generate all and only the languages for which there is an
      unambiguous grammar.</textual></para><para class="po-block e36 e36"><textual class="po-textual">In contrast to other comparative analysis of XML schema languages, such as </textual><xref class="po-milestone e37 e37" linkend="Lee2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or </textual><xref class="po-milestone e38 e38" linkend="Ansari2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the main research goal of our paper is
      thus a more elaborate and fine-grained theoretical approach based on work that has been
      already undertaken (see </textual><xref class="po-milestone e39 e39" linkend="sec.xml_formal"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The application examples shown in
      this paper (especially the ones given in </textual><xref class="po-milestone e40 e40" linkend="sec.murata.locality"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) are clearly
      for demonstration purposes and do not necessarily introduce new findings.</textual></para></section><section class="po-hcontainer e41 e41"><title class="po-block e42 e42"><textual class="po-textual">XML and Formal Language Theory</textual></title><para class="po-block e43 e43"><textual class="po-textual">The history of document grammars begins long before XML's success: in </textual><xref class="po-milestone e44 e44" linkend="Goldfarb1978"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> the first published formal </textual><emphasis class="po-inline e45 e45" role="ital"><textual class="po-textual">document type
        descriptions</textual></emphasis><textual class="po-textual"> can be found, while 1986 SGML Document Type Definition (DTD, </textual><xref class="po-milestone e46 e46" linkend="SGML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) were established, followed by XML's DTD (</textual><xref class="po-milestone e47 e47" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and
      other XML schema languages that were created during XML's ongoing success. This time line
      begins even earlier, in 1955, when Noam Chomsky published his theory on formal grammar (</textual><xref class="po-milestone e48 e48" linkend="Chomsky1955"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e49 e49" linkend="Chomsky1956"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><para class="po-block e50 e50"><textual class="po-textual">One of the several benefits of XML markup languages is the possibility to use a schema (a
      document grammar) to assure not only </textual><emphasis class="po-inline e51 e51" role="ital"><textual class="po-textual">well-formedness</textual></emphasis><textual class="po-textual">, but
      also </textual><emphasis class="po-inline e52 e52" role="ital"><textual class="po-textual">validity</textual></emphasis><textual class="po-textual"> of an instance of a given markup language. The
      XML specification defines well-formedness as follows: </textual><blockquote class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">A textual object is a well-formed XML document if: </textual></para><orderedlist class="po-table e55 e55"><listitem class="po-container e56 e56"><para class="po-block e57 e57"><textual class="po-textual">Taken as a whole, it matches the production labeled document.</textual></para></listitem><listitem class="po-container e58 e58"><para class="po-block e59 e59"><textual class="po-textual">It meets all the well-formedness constraints given in this specification.</textual></para></listitem><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">Each of the parsed entities which is referenced directly or indirectly within the
              document is well-formed.</textual></para></listitem></orderedlist><attribution class="po-block e62 e62"><xref class="po-milestone e63 e63" linkend="XML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Section 2.1 "Well-Formed XML Documents"</textual></attribution></blockquote><textual class="po-textual"> A valid instance in addition declares conformance and actually conforms to the
      rules of a schema of a given markup language. Or, in a more general way: </textual><blockquote class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">The intention or purpose of validation is to subject a document or data set to a test,
          to determine whether it conforms to a given set of external criteria.</textual></para><attribution class="po-block e66 e66"><xref class="po-milestone e67 e67" linkend="Piez2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 144</textual></attribution></blockquote><textual class="po-textual"> A validating parser takes an instance document (and the corresponding schema) as
      input and produces a validation report, </textual><quote class="po-inline e68 e68"><textual class="po-textual">which includes at least a return code reporting
        whether [t]he document is valid and an optional Post Schema Validation Infoset (PSVI),
        updating the original document's infoset (the information obtained from the XML document by
        the parser) with additional information (default values, datatypes, etc.)</textual></quote><textual class="po-textual"> (</textual><xref class="po-milestone e69 e69" linkend="vanderVlist2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). During this process different levels of validation may be
      checked, depending on the XML schema language used: validation of the instance's structure
      (i.e., the markup), datatyping (i.e., the content of individual leaf nodes), integrity (in
      terms of links, either between nodes within a document or between documents). In addition,
      other tests, usually called </textual><emphasis class="po-inline e70 e70" role="ital"><textual class="po-textual">business rules</textual></emphasis><textual class="po-textual"> may apply as well
      (see </textual><xref class="po-milestone e71 e71" linkend="vanderVlist2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). While one may differentiate between the terms
        </textual><emphasis class="po-inline e72 e72" role="ital"><textual class="po-textual">valid</textual></emphasis><textual class="po-textual"> (as defined by the XML specification and therefore
      only referring to validity according to a Document Type Definition) and </textual><emphasis class="po-inline e73 e73" role="ital"><textual class="po-textual">schema-valid</textual></emphasis><textual class="po-textual"> (i.e., valid according to one of the externally defined XML schema
      languages) we will use the former term throughout this paper as equal term for depicting the
      feature of confirmation to a given set of external criteria regardless of the schema language
      used. Furthermore, we will only discuss validation mechanisms through schema languages,
      therefore, technologies such as the </textual><emphasis class="po-inline e74 e74" role="ital"><textual class="po-textual">Content Assembly
        Mechanism</textual></emphasis><textual class="po-textual"> (CAM, see </textual><xref class="po-milestone e75 e75" linkend="Carey2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) or meta-validation techniques
      such as </textual><emphasis class="po-inline e76 e76" role="ital"><textual class="po-textual">Namespace-based Validation Dispatching Language</textual></emphasis><textual class="po-textual">
        (</textual><xref class="po-milestone e77 e77" linkend="NVDL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) are not observed any further. Since we will focus on </textual><emphasis class="po-inline e78 e78" role="ital"><textual class="po-textual">grammar-based schema languages</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e79 e79" role="ital"><textual class="po-textual">rule-based</textual></emphasis><footnote class="po-popup e80 e80"><para class="po-block e81 e81"><textual class="po-textual">For a short discussion if Schematron is a rules language (or rule-based language) see
            </textual><xref class="po-milestone e82 e82" linkend="Jeliffe2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
        </textual></para></footnote><textual class="po-textual"> (or </textual><emphasis class="po-inline e83 e83" role="ital"><textual class="po-textual">constraint-based</textual></emphasis><textual class="po-textual">) </textual><emphasis class="po-inline e84 e84" role="ital"><textual class="po-textual">schema languages</textual></emphasis><textual class="po-textual"> such as </textual><xref class="po-milestone e85 e85" linkend="Schematron"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the </textual><emphasis class="po-inline e86 e86" role="ital"><textual class="po-textual">Constraint Language in XML</textual></emphasis><textual class="po-textual"> (CLiX, </textual><xref class="po-milestone e87 e87" linkend="CLiX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) or </textual><xref class="po-milestone e88 e88" linkend="Moeller2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> will not be observed either.</textual><footnote class="po-popup e89 e89"><para class="po-block e90 e90"><textual class="po-textual">For a different discussion on the topic of expressing constraints see </textual><xref class="po-milestone e91 e91" linkend="Bauman2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote><textual class="po-textual"> For clarification reasons we follow the definitions of </textual><xref class="po-milestone e92 e92" linkend="Costello2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">:</textual><blockquote class="po-container e93 e93"><para class="po-block e94 e94"><textual class="po-textual">A grammar-based schema language specifies the structure and contents of elements and
          attributes in an XML instance document. For example, a grammar-based schema language can
          specify the presence and order of elements in an XML instance document, the number of
          occurrences of each element, and the contents and datatype of each element and attribute.
          A rule-based schema language specifies the relationships that must hold between the
          elements and attributes in an XML instance document. For example, a rule-based schema
          language can specify that the value of certain elements must conform to a rule or
          algorithm.</textual></para><attribution class="po-block e95 e95"><xref class="po-milestone e96 e96" linkend="Costello2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></attribution></blockquote><textual class="po-textual">
    </textual></para><para class="po-block e97 e97"><textual class="po-textual">When someone starts developing a new XML-based markup language sooner or later the
      question about a formalism to define the corresponding document grammar arises, since there is
      a variety of schema (definition) languages available. While a schema can be considered as a
      formal definition of a grammar of the XML-based markup language (e.g. as a set of rules or
      criteria), the schema language is </textual><quote class="po-inline e98 e98"><textual class="po-textual">a formal language for expressing schemas</textual></quote><textual class="po-textual">
        (</textual><xref class="po-milestone e99 e99" linkend="Moeller2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Usually, choosing a schema language depends on several
      factors such as familiarity with a given formalism or support provided by the chosen authoring
      software or processing tools such as </textual><xref class="po-milestone e100 e100" linkend="XSLT2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or </textual><xref class="po-milestone e101 e101" linkend="XQuery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      These factors are very specific for one's own needs and environment and we will not give any
      advice regarding these topics. However, what we want to demonstrate in this paper are the
      differences in terms of expressiveness and computability between the three most used XML
      schema languages, starting with XML's inherent Document Type Definition (DTD, see </textual><xref class="po-milestone e102 e102" linkend="XML10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), based on SGML's DTD (see </textual><xref class="po-milestone e103 e103" linkend="SGML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e104 e104" linkend="Goldfarb1991"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e105 e105" linkend="Maler1995"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) where a non-XML syntax is used</textual><footnote class="po-popup e106 e106"><para class="po-block e107 e107"><textual class="po-textual">We will not discuss any proposals for extended DTDs such as </textual><xref class="po-milestone e108 e108" linkend="Buck2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e109 e109" linkend="Papakonstantinou2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e110 e110" linkend="Vitali2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
          </textual><xref class="po-milestone e111 e111" linkend="Balmin2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or </textual><xref class="po-milestone e112 e112" linkend="Fiorello2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> since these play only minor
          roles in the wild, if any.</textual></para></footnote><textual class="po-textual">, over W3C's XML Schema Description Language (</textual><xref class="po-milestone e113 e113" linkend="XMLSchema2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
        </textual><xref class="po-milestone e114 e114" linkend="XMLSchema2004a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e115 e115" linkend="XMLSchema2004b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and the formal language
      theory based RELAX NG (see </textual><xref class="po-milestone e116 e116" linkend="RELAX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e117 e117" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e118 e118" linkend="RELAX2nd"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> as a successor to both RELAX (</textual><xref class="po-milestone e119 e119" linkend="RELAXCore"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and TREX
        (</textual><xref class="po-milestone e120 e120" linkend="Clark2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></section><section class="po-hcontainer e121 e121" xml:id="sec.xml_formal"><title class="po-block e122 e122"><textual class="po-textual">Formal Language Theory and XML</textual></title><para class="po-block e123 e123"><textual class="po-textual">Although the formal model of an XML instance is always a single rooted tree, the different
      schema languages that can be used to define and constrain instances can be differentiated
      according to their expressiveness and – in a further step – according to their
      computability, which may be interesting when dealing with a task such as programming a
      validating parser. Different authors have dealt with the relationship between XML applications
      and formal languages, for example </textual><xref class="po-milestone e124 e124" linkend="Brueggemann-Klein1992"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e125 e125" linkend="Brueggemann-Klein1993"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e126 e126" linkend="Brueggemann-Klein1997"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e127 e127" linkend="Hopcroft2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e128 e128" linkend="Rizzi2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e129 e129" linkend="Mani2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e130 e130" linkend="Murata2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e131 e131" linkend="Brueggemann-Klein2002"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e132 e132" linkend="Sperberg-McQueen2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e133 e133" linkend="Klarlund2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e134 e134" linkend="Brueggemann-Klein2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e135 e135" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e136 e136" linkend="Martens2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e137 e137" linkend="Kilpeläinen2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e138 e138" linkend="Comon2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e139 e139" linkend="Martens2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and </textual><xref class="po-milestone e140 e140" linkend="Gelade2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Often, a formal specification of
      XML's inherent </textual><code class="po-atom e141 e141"><textual class="po-textual">ID</textual></code><textual class="po-textual">/</textual><code class="po-atom e142 e142"><textual class="po-textual">IDREF</textual></code><textual class="po-textual"> mechanism is omitted; however, </textual><xref class="po-milestone e143 e143" linkend="Abiteboul2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 33 claim that these references can be used to describe graphs
      rather than trees, since they allow for multidominance structures. (see </textual><xref class="po-milestone e144 e144" linkend="Stuehrenberg2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a practical implementation of using
        </textual><code class="po-atom e145 e145"><textual class="po-textual">ID</textual></code><textual class="po-textual">/</textual><code class="po-atom e146 e146"><textual class="po-textual">IDREF</textual></code><textual class="po-textual"> for realizing graph structures within XML's tree model).
        </textual><xref class="po-milestone e147 e147" linkend="Kracht2010"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> uses modal logic to provide a semantics for XML-documents, and
      to characterize XML markup and search and retrieval mechanisms such as XPath. Other work
      leaves the formal model of XML and deals with graph structures that can be described by either
      XML or XML-like markup languages (see </textual><xref class="po-milestone e148 e148" linkend="Marcoux2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a graph
      characterization of TexMECS and other overlapping markup formalisms), but in this paper we
      will concentrate on schema languages that describe well-formed (that is tree-like)
      XML-documents. </textual></para><para class="po-block e149 e149"><textual class="po-textual">Typically, DTDs are characterized as </textual><emphasis class="po-inline e150 e150" role="ital"><textual class="po-textual">extended context-free
        grammars</textual></emphasis><textual class="po-textual"> (see </textual><xref class="po-milestone e151 e151" linkend="Hopcroft2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e152 e152" linkend="Rizzi2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
      that is, on the right-hand-side of a production rule regular expressions are allowed. This
      means for the declaration of an element that its allowed content is described by a regular
      expression using other element names (i.e., referring to other or the very same globally
      declared elements) or reserved keywords such as </textual><code class="po-atom e153 e153"><textual class="po-textual">#PCDATA</textual></code><textual class="po-textual"> or </textual><code class="po-atom e154 e154"><textual class="po-textual">EMPTY</textual></code><textual class="po-textual">. In
      current work, especially </textual><xref class="po-milestone e155 e155" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e156 e156" linkend="Moeller2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, a
      family of </textual><emphasis class="po-inline e157 e157" role="ital"><textual class="po-textual">tree grammars</textual></emphasis><textual class="po-textual"> is used to model XML schema
      languages; for example, DTDs are defined as </textual><emphasis class="po-inline e158 e158" role="ital"><textual class="po-textual">local tree
        grammars</textual></emphasis><textual class="po-textual"> which can be considered strongly equivalent to CFGs, with the only
      difference that they allow non-finitary branching: </textual><blockquote class="po-container e159 e159"><para class="po-block e160 e160"><textual class="po-textual">Ignoring the attributes for a moment, there is a simple but elegant connection between
          DTDs and context-free grammars, namely, each DTD corresponds to an </textual><emphasis class="po-inline e161 e161" role="ital"><textual class="po-textual">extended context-free grammar</textual></emphasis><textual class="po-textual">, where productions may have regular
          expressions on their right-hand side. Then, an XML document is valid with respect to the
          DTD precisely when its associated tree is a correct derivation tree for that
          grammar.</textual></para><attribution class="po-block e162 e162"><xref class="po-milestone e163 e163" linkend="Klarlund2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 13</textual></attribution></blockquote></para><para class="po-block e164 e164"><textual class="po-textual">In addition to using local tree grammars for characterizing DTDs, </textual><xref class="po-milestone e165 e165" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> construe a taxonomy of XML schema languages. The authors introduce
        </textual><emphasis class="po-inline e166 e166" role="ital"><textual class="po-textual">single-type tree grammars</textual></emphasis><textual class="po-textual">, as characterizing XML Schema,
      and use </textual><emphasis class="po-inline e167 e167" role="ital"><textual class="po-textual">regular tree grammars</textual></emphasis><textual class="po-textual"> to characterize RELAX NG.
      Although this work is quite extensive, the formal analysis can be further improved by
      clarifying some propositions. Given the (still growing) importance of XML and the broad range
      of tasks it is used for, stronger theoretical background seems to be the best way to find new
      applications. Before we present our results, we have to introduce the formal concepts we are
      working with.</textual></para></section><section class="po-hcontainer e168 e168"><title class="po-block e169 e169"><textual class="po-textual">Refining the Taxonomy of XML Schema Languages</textual></title><section class="po-hcontainer e170 e170"><title class="po-block e171 e171"><textual class="po-textual">Introduction to the Formal Concepts</textual></title><para class="po-block e172 e172"><textual class="po-textual">In this paper, we will mainly use tree grammars. Since the use of tree grammars is well
        established in the XML community, we will just shortly provide the necessary definitions;
        for a more explicit treatment and motivation, we defer the reader to </textual><xref class="po-milestone e173 e173" linkend="Gecseg1997"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or </textual><xref class="po-milestone e174 e174" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e175 e175"><emphasis class="po-inline e176 e176" role="bold"><textual class="po-textual">Definition 1 </textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e177 e177" role="ital"><textual class="po-textual">A regular tree grammar (RTG) is a 4-tuple (N,T,S,P), where N is a
          finite set of nonterminals, T is a finite set of terminals, S is a set of start symbols,
          which form a subset of N, P is a set of production rules, which have the form: A →
          a(r), where A ∈ N, a ∈ T, and r is a regular expression over elements of N. We
          call A the left hand side of a rule, a the terminal or label which is introduced by the
          rule, and r its content model.</textual></emphasis></para><para class="po-block e178 e178"><textual class="po-textual"> We generally use uppercase letters for nonterminals, and lower-case letters for
        terminals. Note that this grammar generates trees, not strings, and that the nonterminals do
        not remain the labels of the (non-leaf) nodes they introduce, but are substituted by the
        terminal labels. The class of languages generated by RTGs is called the regular tree
        languages (RTLs). This is the most general class of languages we will consider here; and we
        now introduce various restrictions on this class of grammars, as they are defined by </textual><xref class="po-milestone e179 e179" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. </textual></para><para class="po-block e180 e180"><emphasis class="po-inline e181 e181" role="bold"><textual class="po-textual">Definition 2</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e182 e182" role="ital"><textual class="po-textual">We call two rules of a RTG competing, if they introduce the same
          terminal nodes, but have different left hand sides. Thus, A → a(r) and B →
          a(r') are competing. </textual></emphasis></para><para class="po-block e183 e183"><textual class="po-textual">In general, in an RTG we can merge any two rules which have the same left-hand side and
        introduce the same terminal, by merging their content models, because for any two regular
        expressions we can easily form a single expression which denotes is the union of both.
        Therefore, we will generally assume that in our grammars any two rules with same left-hand
        side and same terminal do not exist. As a consequence, the concept of competing rules is the
        crucial point if we deal with determinism and ambiguity. For the same reason, we can speak
        of competing nonterminals almost in the same way as of competing rules: competing
        nonterminals are the left-hand sides of competing rules; a grammar has competing
        nonterminals exactly if it has competing rules, and exactly as many as.</textual></para><para class="po-block e184 e184"><emphasis class="po-inline e185 e185" role="bold"><textual class="po-textual">Definition 3</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e186 e186" role="ital"><textual class="po-textual">A local tree grammar (LTG) is an RTG with no competing
          rules.</textual></emphasis></para><para class="po-block e187 e187"><textual class="po-textual">In an LTG, we have thus a one-to-one correspondence of nonterminals and terminals, which
        makes them very similar to context-free grammars (though not identical, since regular
        content models allow for non-finitary branching).</textual></para><para class="po-block e188 e188"><emphasis class="po-inline e189 e189" role="bold"><textual class="po-textual">Definition 4</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e190 e190" role="ital"><textual class="po-textual">A single type tree grammar (STG) is an RTG, where competing
          nonterminals must not occur in the same content model.</textual></emphasis></para><para class="po-block e191 e191"><textual class="po-textual">As </textual><xref class="po-milestone e192 e192" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> point out, LTGs roughly correspond to DTDs, STGs
        correspond to XML Schema, and RTGs correspond to Relax NG. Note that this correspondence is
        established by only regarding the "core" syntactic features of the schema languages, that is
        XML's inherent reference mechanism is not taken into account. These are thus the most
        important grammar types for XML. </textual><xref class="po-milestone e193 e193" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> still add another type:</textual></para><para class="po-block e194 e194"><emphasis class="po-inline e195 e195" role="bold"><textual class="po-textual">Definition 5</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e196 e196" role="ital"><textual class="po-textual">A restrained competition grammar (RCG) is an RTG, where competing
          nonterminals must not occur in the same content model and with the same prefix of
          nonterminals; we thus disallow rules with identical left-hand side, terminals, and content
          models of the form (Γ A Δ) and (Γ B Δ'), where A and B are competing
          nonterminals, and where uppercase Greek letters refer to possibly empty sequences of
          nonterminals.</textual></emphasis></para><para class="po-block e197 e197"><textual class="po-textual">Notably, the restriction concerns only the left context of the competing nonterminals.
        Of course, there exists a parallel definition for the right context. The problem is that
        both definitions lack some generalization, as they both generate different classes of
        languages, and there is no inclusion in either direction. If we, however, generalize the
        restriction of competition to both the left and the right context (which weakens the overall
        restriction on the grammar), some problems arise. We will discuss possible generalizations
        later on.</textual></para><para class="po-block e198 e198"><textual class="po-textual">It is easily seen that there is a hierarchy of proper inclusion of the grammar types
        presented: LTGs are always STGs, which are always RCGs, which are always RTGs, whereas the
        converse does not hold.</textual></para><para class="po-block e199 e199"><textual class="po-textual">We furthermore define an interpretation of a given tree against a given grammar as
        follows:</textual></para><para class="po-block e200 e200"><emphasis class="po-inline e201 e201" role="bold"><textual class="po-textual">Definition 6 </textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e202 e202" role="ital"><textual class="po-textual">An interpretation I of a
          tree t against a grammar G is a mapping from each node label of t, denoted by e, to a
          nonterminal N of the grammar, such that</textual></emphasis></para><itemizedlist class="po-table e203 e203"><listitem class="po-container e204 e204"><para class="po-block e205 e205"><emphasis class="po-inline e206 e206" role="ital"><textual class="po-textual">I(e) is a start symbol when e is the root of
            t,</textual></emphasis></para></listitem><listitem class="po-container e207 e207"><para class="po-block e208 e208"><emphasis class="po-inline e209 e209" role="ital"><textual class="po-textual">for each e and its daughter nodes e</textual><subscript class="po-atom e210 e210"><textual class="po-textual">0</textual></subscript><textual class="po-textual">,
                e</textual><subscript class="po-atom e211 e211"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,e</textual><subscript class="po-atom e212 e212"><textual class="po-textual">n</textual></subscript><textual class="po-textual">, there is a production rule
              A → a(r) in G, such that</textual></emphasis></para><itemizedlist class="po-table e213 e213"><listitem class="po-container e214 e214"><para class="po-block e215 e215"><emphasis class="po-inline e216 e216" role="ital"><textual class="po-textual">I(e) is A,</textual></emphasis></para></listitem><listitem class="po-container e217 e217"><para class="po-block e218 e218"><emphasis class="po-inline e219 e219" role="ital"><textual class="po-textual">the label of e is a,</textual></emphasis></para></listitem><listitem class="po-container e220 e220"><para class="po-block e221 e221"><emphasis class="po-inline e222 e222" role="ital"><textual class="po-textual">I(e</textual><subscript class="po-atom e223 e223"><textual class="po-textual">0</textual></subscript><textual class="po-textual">),
                  I(e</textual><subscript class="po-atom e224 e224"><textual class="po-textual">1</textual></subscript><textual class="po-textual">),...,I(e</textual><subscript class="po-atom e225 e225"><textual class="po-textual">n</textual></subscript><textual class="po-textual">) matches
                  r.</textual></emphasis></para></listitem></itemizedlist></listitem></itemizedlist><para class="po-block e226 e226"><textual class="po-textual">As is easily seen, with this definition, the ease of interpretation directly interacts
        with the Murata hierarchy. We will continue in this vein. To keep things clear, it is
        crucial to distinguish between the label of a node and its interpretation: the label of a
        node corresponds to its terminal in the production rule (recall that tree grammars directly
        generate trees, not strings via trees as CFGs), and it is immediately visible in the tree.
        By the interpretation of a node in turn we denote the nonterminal by which the node label
        has been produced. This nonterminal is not visible and has to be inferred. In addition, we
        have to distinguish between rule and rule instantiation: since content models are regular
        expressions over nonterminals, they denote sets of sequences of nonterminals, and one member
        of this set is an instantiation. An additional problem arises in interaction with the fact
        that there is no necessary one-to-one correspondence of nonterminals and terminals (i.e.,
        labels); a possible consequence is that the same sequence of labels can be produced by
        different instantiations of a content model (we will exhaustively discuss this source of
        ambiguity later on).</textual></para><para class="po-block e227 e227"><textual class="po-textual">So far, we have introduced the main concepts which are well-known in the literature, and
        which we are going to use and elaborate in this paper.</textual></para></section><section class="po-hcontainer e228 e228"><title class="po-block e229 e229"><textual class="po-textual">An Example Grammar</textual></title><para class="po-block e230 e230"><textual class="po-textual">We will use the following example to demonstrate some of our findings. We want to define
        a document grammar for a text. The text may contain an optional title, followed by either at
        least a single section or a single paragraph. An optional author entity (possibly decoded
        using an attribute) may contain information about the text's author. Inside a section an
        optional title followed by other (sub-)sections or paragraphs are allowed. The title
        consists of raw text while a paragraph may contain raw text or a reference to other
        paragraphs, since these may have an optional identifier (using XML's </textual><code class="po-atom e231 e231"><textual class="po-textual">ID</textual></code><textual class="po-textual">
        type).</textual></para><para class="po-block e232 e232"><textual class="po-textual">If we try to express these constraints more formally we might end up with a grammar
        similar to the one shown in </textual><xref class="po-milestone e233 e233" linkend="fig.grammar"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Again, nonterminals are printed
        in capital letters, while node labels or terminals are printed in small letters. Note, that
        in this formulation elements, attributes and raw text are defined as terminals.</textual></para><figure class="po-container e234 e234" xml:id="fig.grammar"><title class="po-block e235 e235"><textual class="po-textual">An example grammar</textual></title><programlisting class="po-block e236 e236" xml:space="preserve"><emphasis class="po-inline e237 e237" role="ital"><textual class="po-textual">S → text(author,Title? (Section|Para))
Section → section(Title? (Section|Para))
Title → title(#pcdata)
Para → para(id, #pcdata|Xref)
Xref → xref(href,ε) </textual></emphasis></programlisting></figure><section class="po-hcontainer e238 e238"><title class="po-block e239 e239"><textual class="po-textual">The Example Grammar Realized by a DTD (Local Tree Grammar)</textual></title><para class="po-block e240 e240"><textual class="po-textual">Following </textual><xref class="po-milestone e241 e241" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, DTDs can be classified as local tree grammars.
          A possible realization for our example grammar can be seen in </textual><xref class="po-milestone e242 e242" linkend="lst.dtd"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e243 e243" xml:id="lst.dtd"><title class="po-block e244 e244"><textual class="po-textual">DTD realization of the example grammar</textual></title><programlisting class="po-block e245 e245" xml:space="preserve"><textual class="po-textual">&lt;!ELEMENT text (title?, (section | para)+)&gt;
&lt;!ATTLIST text author CDATA #IMPLIED&gt;
&lt;!ELEMENT title (#PCDATA)&gt;
&lt;!ELEMENT section (title?, (section | para)+)&gt;
&lt;!ELEMENT para (#PCDATA | xref)*&gt;
&lt;!ATTLIST para id ID #IMPLIED&gt;
&lt;!ELEMENT xref EMPTY&gt;
&lt;!ATTLIST xref href IDREF #REQUIRED&gt;</textual></programlisting></figure><para class="po-block e246 e246"><textual class="po-textual">Since local tree grammars and DTDs only support globally declared elements (and
          locally declared attributes), the content models of the </textual><code class="po-atom e247 e247"><textual class="po-textual">text</textual></code><textual class="po-textual"> and the
            </textual><code class="po-atom e248 e248"><textual class="po-textual">section</textual></code><textual class="po-textual"> element share references to the same three elements
            (</textual><code class="po-atom e249 e249"><textual class="po-textual">title</textual></code><textual class="po-textual">, </textual><code class="po-atom e250 e250"><textual class="po-textual">section</textual></code><textual class="po-textual"> and </textual><code class="po-atom e251 e251"><textual class="po-textual">para</textual></code><textual class="po-textual">) and contain both a
          sequence and a choice together with the occurrence indicators </textual><code class="po-atom e252 e252"><textual class="po-textual">+</textual></code><textual class="po-textual"> (at least one
          occurrence) and </textual><code class="po-atom e253 e253"><textual class="po-textual">?</textual></code><textual class="po-textual"> (optional). The content model of the </textual><code class="po-atom e254 e254"><textual class="po-textual">para</textual></code><textual class="po-textual">
          element contains mixed content, that is both raw text and the </textual><code class="po-atom e255 e255"><textual class="po-textual">xref</textual></code><textual class="po-textual"> element
          are allowed as children. Since DTDs force the use of the choice group (</textual><code class="po-atom e256 e256"><textual class="po-textual">|</textual></code><textual class="po-textual">) and
          the trailing asterisk (</textual><code class="po-atom e257 e257"><textual class="po-textual">*</textual></code><textual class="po-textual">) as occurrence indicator, there is no other way to
          define this specific content model using this schema language.</textual></para><para class="po-block e258 e258"><textual class="po-textual">Note that DTDs do not support any type mechanism. </textual><xref class="po-milestone e259 e259" linkend="Buck2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e260 e260" linkend="Papakonstantinou2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e261 e261" linkend="Balmin2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e262 e262" linkend="Martens2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> suppose the extension of DTDs by adding types, while DTD++,
          proposed by </textual><xref class="po-milestone e263 e263" linkend="Vitali2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> adds namespace awareness on top, and DTD++ 2.0
          (see </textual><xref class="po-milestone e264 e264" linkend="Fiorello2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) even supports co-constraints.</textual></para></section><section class="po-hcontainer e265 e265"><title class="po-block e266 e266"><textual class="po-textual">The Example Grammar Realized by an XSD (Single Type Tree Grammar)</textual></title><para class="po-block e267 e267"><textual class="po-textual">An XML schema description (i.e., a single type tree grammar) of the same document
          grammar may look like the one in </textual><xref class="po-milestone e268 e268" linkend="lst.xsd"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e269 e269" xml:id="lst.xsd"><title class="po-block e270 e270"><textual class="po-textual">XSD realization of the example grammar</textual></title><programlisting class="po-block e271 e271" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="text"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="textType"&gt;
          &lt;xs:attribute name="author" type="xs:string" use="optional"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="title" type="xs:string"/&gt;
  &lt;xs:element name="section" type="textType"/&gt;
  &lt;xs:element name="para"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="xref" minOccurs="0"&gt;
          &lt;xs:complexType&gt;
            &lt;xs:attribute name="href" type="xs:IDREF" use="required"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute ref="id" use="optional"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:complexType name="textType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="title" minOccurs="0"/&gt;
      &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:group name="sectOrPara"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="section"/&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
&lt;/xs:schema&gt;</textual></programlisting></figure><para class="po-block e272 e272"><textual class="po-textual">Note that this XML schema description is only one possible realization out of a
          variety of different XML schema descriptions that would fit our needs. Although it may be
          not very human-readable, it was designed to show some features that are supported by XSD.
          The </textual><code class="po-atom e273 e273"><textual class="po-textual">text</textual></code><textual class="po-textual"> element is derived by extension of the globally declared complexType
            </textual><code class="po-atom e274 e274"><textual class="po-textual">textType</textual></code><textual class="po-textual"> which itself refers to the globally declared model group
            </textual><code class="po-atom e275 e275"><textual class="po-textual">sectOrPara</textual></code><textual class="po-textual">. The schema contains both locally and globally declared
          attributes (</textual><code class="po-atom e276 e276"><textual class="po-textual">author</textual></code><textual class="po-textual"> vs. </textual><code class="po-atom e277 e277"><textual class="po-textual">id</textual></code><textual class="po-textual">) and elements (</textual><code class="po-atom e278 e278"><textual class="po-textual">xref</textual></code><textual class="po-textual"> as an
          example for a locally declared element). Apart from that, XSD supports </textual><xref class="po-milestone e279 e279" linkend="XMLNS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> which are not shown in the example above. As </textual><xref class="po-milestone e280 e280" linkend="Martens2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> has already pointed out, that the actual extra expressive power
          of XSDs over DTDs can only be used to a very limited extent due to the </textual><emphasis class="po-inline e281 e281" role="ital"><textual class="po-textual">Element Declarations Consistent</textual></emphasis><textual class="po-textual"> (EDC) constraint (see </textual><xref class="po-milestone e282 e282" linkend="XMLSchema2004a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Section 3.8.6).</textual></para></section><section class="po-hcontainer e283 e283"><title class="po-block e284 e284"><textual class="po-textual">The Example Grammar Realized by a RELAX NG Grammar (Regular Tree Grammar)</textual></title><para class="po-block e285 e285"><textual class="po-textual">RELAX NG can be classified as regular tree grammar according to </textual><xref class="po-milestone e286 e286" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. A possible realization with RELAX NG is shown in </textual><xref class="po-milestone e287 e287" linkend="lst.relaxng"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e288 e288" xml:id="lst.relaxng"><title class="po-block e289 e289"><textual class="po-textual">RELAX NG realization of the example grammar</textual></title><programlisting class="po-block e290 e290" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;start&gt;
    &lt;element name="text"&gt;
      &lt;optional&gt;
        &lt;attribute name="author"/&gt;
      &lt;/optional&gt;
      &lt;choice&gt;
        &lt;optional&gt;
          &lt;group&gt;
            &lt;ref name="element.title"/&gt;
            &lt;ref name="element.section"/&gt;
          &lt;/group&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
          &lt;group&gt;
            &lt;ref name="element.title"/&gt;
            &lt;ref name="element.para"/&gt;
          &lt;/group&gt;
        &lt;/optional&gt;
      &lt;/choice&gt;
    &lt;/element&gt;
  &lt;/start&gt;
  &lt;define name="element.title"&gt;
    &lt;element name="title"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="element.section"&gt;
    &lt;element name="section"&gt;
      &lt;optional&gt;
        &lt;ref name="element.title"/&gt;
      &lt;/optional&gt;
      &lt;ref name="sectOrPara"/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="element.para"&gt;
    &lt;element name="para"&gt;
      &lt;optional&gt;
        &lt;attribute name="id"&gt;
          &lt;data type="ID"/&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;
      &lt;zeroOrMore&gt;
        &lt;choice&gt;
          &lt;text/&gt;
          &lt;element name="xref"&gt;
            &lt;attribute name="href"&gt;
              &lt;data type="IDREF"/&gt;
            &lt;/attribute&gt;
            &lt;empty/&gt;
          &lt;/element&gt;
        &lt;/choice&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="sectOrPara"&gt;
    &lt;group&gt;
      &lt;oneOrMore&gt;
        &lt;choice&gt;
          &lt;ref name="element.section"/&gt;
          &lt;ref name="element.para"/&gt;
        &lt;/choice&gt;
      &lt;/oneOrMore&gt;
    &lt;/group&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</textual></programlisting></figure><para class="po-block e291 e291"><textual class="po-textual">Compared to DTD or XSD, RELAX NG is based both on the mathematical theory of regular
          expressions and the concept of hedge grammars (</textual><xref class="po-milestone e292 e292" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e293 e293" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). As an XML schema language, RELAX NG has some advantages over
          other schema languages: while in DTDs and XSD mixed content models may contain child
          elements and text nodes in any arbitrary order, RELAX NG allows for ordering of the
          element child nodes (see </textual><xref class="po-milestone e294 e294" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 57f.). Co-occurrence
          constraints can be used to specify the content model of an item according to the value of
          another item, allowing non-deterministic content models which cannot be realized in DTD or
          XSD (see </textual><xref class="po-milestone e295 e295" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 62f, and </textual><xref class="po-milestone e296 e296" linkend="sec.determinism"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
          for a discussion). In general, a co-occurrence constraint (or co-constraint as they are
          called by </textual><xref class="po-milestone e297 e297" linkend="Pawson2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) may </textual><quote class="po-inline e298 e298"><textual class="po-textual">be a constraint over multiple items,
            not just two items</textual></quote><textual class="po-textual"> and </textual><quote class="po-inline e299 e299"><textual class="po-textual">may exist between XML structure components
            (elements, attributes) as well as between data values</textual></quote><textual class="po-textual">. One may differentiate
          between element-to-element, element-to-attribute, or attribute-attribute co-occurrence
          constraint, based on the items involved.</textual></para><para class="po-block e300 e300"><textual class="po-textual"> In addition, SGML's interleave operator </textual><code class="po-atom e301 e301"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> (see </textual><xref class="po-milestone e302 e302" linkend="Goldfarb1991"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 291) that is missing in XML DTD and XSD can be used in
          RELAX NG as well, although this adds nothing to its expressive power. In contrast to the
          two other schema languages discussed in this paper, RELAX NG does not support default
          values (which are supported for attributes in DTD and for attributes and elements in XSD).
          While both DTD and XSD support XML references via
            </textual><code class="po-atom e303 e303"><textual class="po-textual">ID</textual></code><textual class="po-textual">/</textual><code class="po-atom e304 e304"><textual class="po-textual">IDREF</textual></code><textual class="po-textual">(</textual><code class="po-atom e305 e305"><textual class="po-textual">S</textual></code><textual class="po-textual">) attribute types, RELAX NG has no
          included datatype library; however, as seen in the example grammar, it is possible to
          include the datatype library of </textual><xref class="po-milestone e306 e306" linkend="XMLSchema2004b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e307 e307"><textual class="po-textual">The document instance given in </textual><xref class="po-milestone e308 e308" linkend="lst.instance"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> would be valid according
          to all of the above defined document grammars (the example shows validation against the
          XML schema, adding a Doctype declaration and removing the
            </textual><code class="po-atom e309 e309"><textual class="po-textual">noNamespaceSchemaLocation</textual></code><textual class="po-textual"> attribute of the root element would result in a
          valid instance according to the DTD. Note that RELAX NG does not contain a standard way to
          associate a RELAX NG schema to an XML instance since it was designed as part of the ISO
          DSDL framework (in this framework, the </textual><xref class="po-milestone e310 e310" linkend="NVDL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> should be used as general
          external mechanism for validating instances).</textual></para><figure class="po-container e311 e311" xml:id="lst.instance"><title class="po-block e312 e312"><textual class="po-textual">Valid XML instance</textual></title><programlisting class="po-block e313 e313" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;text xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="text.xsd" author="maik"&gt;
  &lt;title&gt;A simple title&lt;/title&gt;
  &lt;section&gt;
    &lt;title&gt;A section title&lt;/title&gt;
    &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
    &lt;section&gt;
      &lt;title&gt;A subsection title&lt;/title&gt;
      &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/section&gt;
&lt;/text&gt;</textual></programlisting></figure></section></section></section><section class="po-hcontainer e314 e314"><title class="po-block e315 e315"><textual class="po-textual">Determinism and Local Ambiguity</textual></title><para class="po-block e316 e316"><textual class="po-textual">Determinism is a important property for XML Documents, schema languages and
      interpretation. If a grammar is deterministic, parsing will be much more efficient, since in
      general we do not have to keep in mind any information, do not have to backtrack, do not need
      any non-local information in case we search, etc.</textual><footnote class="po-popup e317 e317"><para class="po-block e318 e318"><xref class="po-milestone e319 e319" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> present an algorithm using tree-automata that allows for
          efficient parsing of regular tree grammars.</textual></para></footnote><textual class="po-textual"> The concept of determinism is closely related to the concept of local ambiguity:
      if there is no local ambiguity, then at every point in the parsing process we know the
      structure (in this case: interpretation) of what we have seen so far, because there is
      only one possible local analysis. If there is some local ambiguity, non-determinism arises: we
      cannot assign a unique interpretation locally, for we would need information which is not
      available yet, and we need to apply some heuristics.</textual></para><section class="po-hcontainer e320 e320" xml:id="sec.determinism"><title class="po-block e321 e321"><textual class="po-textual">Determinism, Algorithms and Local Ambiguities</textual></title><para class="po-block e322 e322"><textual class="po-textual">In this section we will review the concept of determinism, as opposed to local ambiguity
        of a grammar. As introductory issue, we show that determinism does not only depend on the
        grammar we use, but also on the algorithm. In regular tree languages, there can be no
        one-dimensional concept of determinism, as there is for regular string languages. Note that
        this is more than a metaphor, since we can perceive of regular string languages as
        one-dimensional structures; in order to talk about trees or the strings formed by their
        leaves, we need at least two dimensions (see </textual><xref class="po-milestone e323 e323" linkend="Rogers2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). In the
        remainder, we will show how different grammar types provide determinism for all, some
        particular class of, or no algorithms.</textual></para></section><section class="po-hcontainer e324 e324"><title class="po-block e325 e325"><textual class="po-textual">Deterministic Content Models</textual></title><para class="po-block e326 e326"><textual class="po-textual">Firstly, we consider the concept of deterministic content models. This draws on the
        notion of deterministic (or 1-unambiguous) regular expressions (DREs), thoroughly surveyed
        by </textual><xref class="po-milestone e327 e327" linkend="Brueggemann-Klein1997"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><footnote class="po-popup e328 e328"><para class="po-block e329 e329"><textual class="po-textual">See </textual><xref class="po-milestone e330 e330" linkend="Mani2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a discussion of the pros and cons of
            1-unambiguous content models in XML schema languages.</textual></para></footnote><textual class="po-textual">. Assume we have a string </textual><emphasis class="po-inline e331 e331" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> which is denoted by
        some regular expression </textual><emphasis class="po-inline e332 e332" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">. Assume furthermore we build our
        expressions with letters from an alphabet </textual><emphasis class="po-inline e333 e333" role="ital"><textual class="po-textual">Π</textual></emphasis><textual class="po-textual">, which is
        identical to the alphabet </textual><emphasis class="po-inline e334 e334" role="ital"><textual class="po-textual">Σ</textual></emphasis><textual class="po-textual">, except for the fact that
        we have additional indices for the letters (taken here from the set of natural numbers). If
        we build an expression from </textual><emphasis class="po-inline e335 e335" role="ital"><textual class="po-textual">Π</textual></emphasis><textual class="po-textual">, we have to make sure
        that every index must occur at most once in it. Constructors for regular expressions are as
        usual, and indices are passed on to the letters of the strings the expression denotes. We
        say that a letter in </textual><emphasis class="po-inline e336 e336" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> instantiates a letter in </textual><emphasis class="po-inline e337 e337" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, if the following holds:</textual></para><para class="po-block e338 e338"><textual class="po-textual">
        </textual><emphasis class="po-inline e339 e339" role="bold"><textual class="po-textual">Definition 7</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e340 e340" role="ital"><textual class="po-textual">A letter a</textual><subscript class="po-atom e341 e341"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> in s instantiates a letter
            a</textual><subscript class="po-atom e342 e342"><textual class="po-textual">j</textual></subscript><textual class="po-textual"> from E, if i = j.</textual></emphasis></para><para class="po-block e343 e343"><textual class="po-textual">The index ensures that for every string an expression denotes, there is a unique
        surjective mapping from letters in </textual><emphasis class="po-inline e344 e344" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> to letters in
          </textual><emphasis class="po-inline e345 e345" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">. We now define a mapping </textual><emphasis class="po-inline e346 e346" role="ital"><textual class="po-textual">♮</textual></emphasis><textual class="po-textual"> on strings over </textual><emphasis class="po-inline e347 e347" role="ital"><textual class="po-textual">Π</textual></emphasis><textual class="po-textual"> to strings
        over </textual><emphasis class="po-inline e348 e348" role="ital"><textual class="po-textual">Σ</textual></emphasis><textual class="po-textual">, such that </textual><emphasis class="po-inline e349 e349" role="ital"><textual class="po-textual">
            ♮(x</textual><subscript class="po-atom e350 e350"><textual class="po-textual">i</textual></subscript><textual class="po-textual">):= x,
        ♮(xs):=♮(x)♮(s)</textual></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e351 e351" role="ital"><textual class="po-textual"> s</textual></emphasis><textual class="po-textual">
        is a string and </textual><emphasis class="po-inline e352 e352" role="ital"><textual class="po-textual">x</textual></emphasis><textual class="po-textual"> a letter (the first of the string). This
        homomorphism simply deletes the indices and leaves anything else untouched. Note that for a
        unique string </textual><emphasis class="po-inline e353 e353" role="ital"><textual class="po-textual">♮s</textual></emphasis><textual class="po-textual">, and a given expression </textual><emphasis class="po-inline e354 e354" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, there might be several </textual><emphasis class="po-inline e355 e355" role="ital"><textual class="po-textual">s ∈
          E</textual></emphasis><textual class="po-textual">, such that their mapping under </textual><emphasis class="po-inline e356 e356" role="ital"><textual class="po-textual">♮</textual></emphasis><textual class="po-textual"> is
        identical. In this case we say that a letter in </textual><emphasis class="po-inline e357 e357" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> might
        instantiate several letters in </textual><emphasis class="po-inline e358 e358" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">. A deterministic regular
        expression over </textual><emphasis class="po-inline e359 e359" role="ital"><textual class="po-textual">Π</textual></emphasis><textual class="po-textual"> is then defined as follows:</textual></para><para class="po-block e360 e360"><textual class="po-textual">
        </textual><emphasis class="po-inline e361 e361" role="bold"><textual class="po-textual">Definition 8</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e362 e362" role="ital"><textual class="po-textual">E is deterministic or one-unambiguous, if for all strings u, v, w over
          Π, and all letters x, y in Π, the following holds: if uxv and uyw ∈ L(E),
          and x ≠ y, then also ♮ x ≠ ♮ y</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e363 e363"><textual class="po-textual"> This means that we can skip the indices, and we still know which letter in </textual><emphasis class="po-inline e364 e364" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is instantiated by any letter in </textual><emphasis class="po-inline e365 e365" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual">, simply from knowing its left context. Formally, this means that the mapping
        ♮ is reversible. A regular language is deterministic if it is denoted by a
        deterministic regular expression. A simple example of a non-deterministic expression is the
        expression </textual><emphasis class="po-inline e366 e366" role="ital"><textual class="po-textual">a*b*a*</textual></emphasis><textual class="po-textual">, as we can easily check for the string
          </textual><emphasis class="po-inline e367 e367" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, which might be the instantiation of either of the two
          </textual><emphasis class="po-inline e368 e368" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">s.</textual></para><para class="po-block e369 e369"><textual class="po-textual">As a consequence for processing, quite informally, we can state that reading </textual><emphasis class="po-inline e370 e370" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual"> ∈ </textual><emphasis class="po-inline e371 e371" role="ital"><textual class="po-textual">L(E)</textual></emphasis><textual class="po-textual"> from the left to
        the right, where </textual><emphasis class="po-inline e372 e372" role="ital"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is a DRE, at any point in </textual><emphasis class="po-inline e373 e373" role="ital"><textual class="po-textual">s</textual></emphasis><textual class="po-textual">, we know at which point in </textual><emphasis class="po-inline e374 e374" role="ital"><textual class="po-textual">E </textual></emphasis><textual class="po-textual"> we
        find ourselves. In automata theory, DREs correspond to deterministic Glushkov
        automata.</textual></para><para class="po-block e375 e375"><textual class="po-textual">There is however a problem if we apply this concept to content models in regular tree
        grammars: in regular expressions, we can see from a letter in the string which type of
        letter in the expression it instantiates (thus, we have a unique letter in </textual><emphasis class="po-inline e376 e376" role="ital"><textual class="po-textual">Σ</textual></emphasis><textual class="po-textual">, though not in </textual><emphasis class="po-inline e377 e377" role="ital"><textual class="po-textual">Π</textual></emphasis><textual class="po-textual">). We
        can thus deduce from a letter in the string a letter in the expression, though not a letter
        instantiation, if the expression is not deterministic. We cannot, however, deduce from a
        given tree node label a unique type of nonterminal: if we have competing rules, different
        nonterminals introduce identical labels; and we still have to keep them apart. Thus, if the
        content model of nonterminals itself is deterministic, this is of little use if we cannot
        infer from a given label the unique nonterminal it belongs to.</textual></para><para class="po-block e378 e378"><textual class="po-textual">By way of example, consider the following grammar rule:</textual></para><para class="po-block e379 e379"><emphasis class="po-inline e380 e380" role="ital"><textual class="po-textual">A → a(ABC|CBA)</textual></emphasis></para><para class="po-block e381 e381"><textual class="po-textual"> Its content model is surely deterministic. However, if </textual><emphasis class="po-inline e382 e382" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e383 e383" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> are competing rules (have identical
        labels), this is of little use. We have to check each subtree until we have its unique
        interpretation. This means, in the worst case, we have to check both subtrees (as we will
        see, this is the case in which the trees generated by </textual><emphasis class="po-inline e384 e384" role="ital"><textual class="po-textual">A (C)</textual></emphasis><textual class="po-textual">
        form a subset of the trees generated by </textual><emphasis class="po-inline e385 e385" role="ital"><textual class="po-textual">C (A)</textual></emphasis><textual class="po-textual">).</textual></para><para class="po-block e386 e386"><textual class="po-textual">The obvious reason for the fact that this concept of determinism comes short is that it
        originates in one-dimensional strings. As our trees are two dimensional, we can define
        determinism only with respect to directions in which our analysis proceeds. The main
        difference is, of course, the one between top-down and bottom-up processing. In this paper
        we will not consider the difference between depth-first and breadth-first parsing, though
        this is surely worthwhile.</textual></para><para class="po-block e387 e387"><textual class="po-textual">In the next subsection, we will reformulate and complete the Murata hierarchy in a way,
        that makes clear which kind of determinism is facilitated by which kind of grammar. In the
        sequel, we will disregard the one-dimensional problem of non-deterministic content models,
        since they have been thoroughly analyzed, and we have nothing to add (see </textual><xref class="po-milestone e388 e388" linkend="Brueggemann-Klein1997"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). At this point, our interest is the second dimension:
        importantly, this means that talking about determinism, we implicitly always add: provided
        that content models are deterministic in the above sense. We thus exclude all problems which
        may arise from regular expressions.</textual></para></section><section class="po-hcontainer e389 e389" xml:id="sec.murata.locality"><title class="po-block e390 e390"><textual class="po-textual">The Murata Hierarchy as Hierarchy of Locality Conditions</textual></title><para class="po-block e391 e391"><textual class="po-textual">As our main concern will be the formal properties of the grammar types, as they affect
        processing, we will firstly reformulate the hierarchy. This reformulation aims at making
        clear which information we need in order to uniquely interpret a local node or
        subtree.</textual></para><orderedlist class="po-table e392 e392" numeration="arabic"><listitem class="po-container e393 e393"><para class="po-block e394 e394"><textual class="po-textual">In a </textual><emphasis class="po-inline e395 e395" role="bold"><textual class="po-textual">local tree grammar</textual></emphasis><textual class="po-textual">, for any node </textual><emphasis class="po-inline e396 e396" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> in any context, we know its unique interpretation. This is
            obvious, since for any node label, there is only one single rule which generates it, by
            the very definition of a local tree grammar. As a consequence, parsing is deterministic
            for any algorithm (provided we have deterministic content models), and the problem of
            giving a certain node of a given tree its interpretation is solvable in a constant
            amount of steps.</textual></para></listitem><listitem class="po-container e397 e397"><para class="po-block e398 e398"><textual class="po-textual">In a </textual><emphasis class="po-inline e399 e399" role="bold"><textual class="po-textual">single type tree grammar</textual></emphasis><textual class="po-textual">, for any node label
              </textual><emphasis class="po-inline e400 e400" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> in any context, we can determine its unique
            interpretation if we know the interpretation of its mother node. This follows directly
            from the definition: if we know the interpretation of a node's mother node (rules
            correspond to interpretations), we know its content model. Within a content model there
            must not occur any competing nonterminals.</textual></para><para class="po-block e401 e401"><textual class="po-textual">Note, however, that it is not sufficient to know the mother nodes label. We can
            easily construct an example to show this: we have two competing rules, </textual><emphasis class="po-inline e402 e402" role="ital"><textual class="po-textual">A → a(C)</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e403 e403" role="ital"><textual class="po-textual">B →
              a(D)</textual></emphasis><textual class="po-textual">, whose nonterminals do not occur in the same content model of any
            rule. </textual></para><para class="po-block e404 e404"><textual class="po-textual">Furthermore, we have the two rules </textual><emphasis class="po-inline e405 e405" role="ital"><textual class="po-textual">C → b(r)</textual></emphasis><textual class="po-textual">
            and </textual><emphasis class="po-inline e406 e406" role="ital"><textual class="po-textual">D → b(r')</textual></emphasis><textual class="po-textual">. Then both nodes, as introduced by
              </textual><emphasis class="po-inline e407 e407" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e408 e408" role="ital"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">, have label
              </textual><emphasis class="po-inline e409 e409" role="ital"><textual class="po-textual">b</textual></emphasis><textual class="po-textual">, their mother nodes both have the label </textual><emphasis class="po-inline e410 e410" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, despite they have different interpretations.</textual></para><para class="po-block e411 e411"><textual class="po-textual">For processing, this has an immediate consequence: a top down parser will at any
            point immediately know the interpretation of any node, whereas if we start
            interpretation from the bottom, in the worst case we will have to go up to the root in
            order to get the correct interpretation. The matter of providing the interpretation of a
            given node is nonetheless a linear search problem, since for a given tree and a given
            node, it is sufficient to go a path from the root to that node.</textual></para></listitem><listitem class="po-container e412 e412"><para class="po-block e413 e413"><textual class="po-textual"> In a </textual><emphasis class="po-inline e414 e414" role="bold"><textual class="po-textual">restrained competition grammar</textual></emphasis><textual class="po-textual"> (RCG), in
            order to give a node its unique interpretation, we must have the interpretation of its
            mother node, and check its left siblings, in case it has any. Note that from how we
            defined RCGs, it follows that we only need the label of the siblings, not their
            interpretation: because any two competing nonterminals within a single content model are
            distinguished by a unique prefix, this prefix itself must not consist of competing
            nonterminals only, and neither must it be empty. This keeps the grammar unambiguous, and
            easy to process. However, it makes some restrictions we do not necessarily want to make:
            maybe the unique interpretation of a label should not depend on a left sibling, but on a
            right sibling. For example, in RCGs we cannot have competing nonterminals as leftmost
            symbols in a content-model, but as rightmost, given some left context. This causes an
            asymmetry which seems quite arbitrary. Of course we can equally define the asymmetric
            counterpart of RCG, checking for unique suffixes instead of prefixes; but care is to be
            taken: since we have to fix the type for the class of languages (i.e., document
            grammars) we define, we have the same problem. If we generalize the concept to both
            unique suffix and prefix, some problems arise, which can however be remedied. </textual></para></listitem><listitem class="po-container e415 e415"><para class="po-block e416 e416"><textual class="po-textual">We now define a </textual><emphasis class="po-inline e417 e417" role="bold"><textual class="po-textual">generalized restrained competition
              grammar</textual></emphasis><textual class="po-textual"> (GRCG), as follows: </textual></para><para class="po-block e418 e418"><textual class="po-textual">In a GRCG, for any two competing nonterminals </textual><emphasis class="po-inline e419 e419" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and
              </textual><emphasis class="po-inline e420 e420" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> within a single content model </textual><emphasis class="po-inline e421 e421" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual">, one of (</textual><emphasis class="po-inline e422 e422" role="ital"><textual class="po-textual">Γ A Δ</textual></emphasis><textual class="po-textual">) and
              (</textual><emphasis class="po-inline e423 e423" role="ital"><textual class="po-textual">Γ B Δ</textual></emphasis><textual class="po-textual">) fails to match </textual><emphasis class="po-inline e424 e424" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual"> (Greek variables range over possible empty sequences of
            nonterminals).</textual></para><para class="po-block e425 e425"><textual class="po-textual">We now have generalized the restriction from the left (right, respectively) to the
            entire context. Note that we have relaxed the overall restriction on the grammar, by
            making the restriction on content models more specific (indeed, this type properly
            includes the RCGs). </textual></para><para class="po-block e426 e426"><textual class="po-textual"> This little relaxation however causes a vast increase in processing complexity:
            because now, in order to give its unique interpretation to any node </textual><emphasis class="po-inline e427 e427" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> in any context, in the worst case one needs to know the
            interpretation of its mother, the interpretation of its siblings, and the interpretation
            of its subtrees as well. And even then, GRCGs might still be ambiguous, allowing more
            than one interpretation for a entire single tree. </textual></para><para class="po-block e428 e428"><textual class="po-textual">This needs some explanation. The first point is easy to see: that we need to know
            the interpretation of the mother node follows a fortiori from the preceding argument
            (single type grammars are properly included in restrained competition grammars). But
            this is insufficient, since competing nonterminals may occur within the same content
            model. We have to match all the sister labels to the nonterminals of the content model
            of the mothers interpretation in order to get a unique interpretation (according to the
            definition). </textual></para><para class="po-block e429 e429"><textual class="po-textual">Note, however, that we need the interpretation of the sister nodes; it is not
            sufficient to have their labels. This we can easily verify with the following grammar
            rule: </textual><emphasis class="po-inline e430 e430" role="ital"><textual class="po-textual">A → a(BC|B'C')</textual></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e431 e431" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e432 e432" role="ital"><textual class="po-textual">B'</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e433 e433" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e434 e434" role="ital"><textual class="po-textual">C'</textual></emphasis><textual class="po-textual"> are competing rules, introduce
            the labels </textual><emphasis class="po-inline e435 e435" role="ital"><textual class="po-textual">b</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e436 e436" role="ital"><textual class="po-textual">c</textual></emphasis><textual class="po-textual">,
            respectively.</textual></para><para class="po-block e437 e437"><textual class="po-textual">This satisfies all conditions on GRCGs. In order to get the correct interpretation
            for the labels </textual><emphasis class="po-inline e438 e438" role="ital"><textual class="po-textual">b</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e439 e439" role="ital"><textual class="po-textual">c</textual></emphasis><textual class="po-textual">, it is not sufficient to know the sister node's label, but its
            interpretation. </textual></para><para class="po-block e440 e440"><textual class="po-textual">Things can thus get even worse, if we consider the case where the interpretation of
            a sister node depends on the interpretation of the node under consideration </textual><emphasis class="po-inline e441 e441" role="ital"><textual class="po-textual">itself</textual></emphasis><textual class="po-textual">. Look at the following example rule: </textual><emphasis class="po-inline e442 e442" role="ital"><textual class="po-textual">A → a(BC|CB)</textual></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e443 e443" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">
            and </textual><emphasis class="po-inline e444 e444" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> are competing rules.</textual></para><para class="po-block e445 e445"><textual class="po-textual">Obviously, they are both uniquely determined by their neighbor within the content
            model of </textual><emphasis class="po-inline e446 e446" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> (</textual><emphasis class="po-inline e447 e447" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> may only
            occur with </textual><emphasis class="po-inline e448 e448" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> to its left or its right, and vice versa).
            However, as they carry the same labels, it is insufficient to determine either of them
            if we just check the label of its sister (since it is identical). Furthermore, we might
            have the case where it is impossible to interpret one of the subtrees, without its
            sisters interpretation (e.g., if one of the competing nonterminals generates a subset of
            the trees generated by the other).</textual></para><para class="po-block e449 e449"><textual class="po-textual">We will consider this case more thoroughly in the next section, showing that there
            are globally ambiguous GRCGs, and that for every language that can be generated by an
            RTG, there is also a GRCG grammar that generates the same language. </textual></para><para class="po-block e450 e450"><textual class="po-textual">From the point of view of processing, we see that in GRCGs, expressive power comes
            at a high cost: neither a bottom-up nor a top-down parser is capable of assigning a
            unique interpretation locally, and maybe not even globally. The problem of giving a
            given node its unique interpretation might thus be an exponential search problem, and in
            the worst case not even decidable. We will therefore introduce a subtype of GRCG, which
            we will call unambiguous RCG. This type is properly included in the class of GRCG
            grammars, and includes properly the class of STGs as well as RCGs, as can be seen
            easily.</textual></para></listitem><listitem class="po-container e451 e451"><para class="po-block e452 e452"><textual class="po-textual">We now introduce </textual><emphasis class="po-inline e453 e453" role="bold"><textual class="po-textual">unambiguous restrained competition
              grammars</textual></emphasis><textual class="po-textual"> (URCGs). What we want to eliminate is ambiguity, which can be
            caused by the fact that in a GRCG, we might have entire competing contexts, or the
            interpretation of the context of a label in a content-model might depend on the
            interpretation of the label itself. In the resulting grammar, it should be possible to
            yield the unique interpretation of a node from the interpretation of its mother and the
            labels (not interpretations) of its sisters.</textual></para><para class="po-block e454 e454"><textual class="po-textual">We characterize the grammar type in the following terms: We introduce an alphabet of
            meta-variables </textual><emphasis class="po-inline e455 e455" role="ital"><textual class="po-textual">O</textual></emphasis><textual class="po-textual">, which we use in the following way: </textual></para><para class="po-block e456 e456"><textual class="po-textual">We form a set of all sets of nonterminals from </textual><emphasis class="po-inline e457 e457" role="ital"><textual class="po-textual">N</textual></emphasis><textual class="po-textual">
            which compete with each other; we call these sets the </textual><emphasis class="po-inline e458 e458" role="ital"><textual class="po-textual">competition
              sets</textual></emphasis><textual class="po-textual"> (which are possibly singletons). We are interested in the sets where
            every nonterminal occurs in exactly one competition set, such that the whole set forms a
            partition of </textual><emphasis class="po-inline e459 e459" role="ital"><textual class="po-textual">N</textual></emphasis><textual class="po-textual">. For every such partition we iterate the
            following procedure: To every competition set, we assign a single symbol from </textual><emphasis class="po-inline e460 e460" role="ital"><textual class="po-textual">O</textual></emphasis><textual class="po-textual">. We call this an </textual><emphasis class="po-inline e461 e461" role="ital"><textual class="po-textual">O-assignment</textual></emphasis><textual class="po-textual">. Then, for all content models, we check for all nonterminals,
            whether the content models still satisfy the GRCG condition, if we replace all other
            nonterminals by the symbols from </textual><emphasis class="po-inline e462 e462" role="ital"><textual class="po-textual">O</textual></emphasis><textual class="po-textual"> they are assigned
            to. In case there is more than one overall assignment, that is, a single nonterminal
            belongs to more than one competition set, we have to iterate this for every possible
            assignment. If for every assignment, nonterminal and content model, the resulting
            grammar is a GRCG, then the original grammar is a URCG.</textual></para><para class="po-block e463 e463"><textual class="po-textual">Note that the assignments are only introduced for this evaluation procedure. We will
            call contexts which are identical under the </textual><emphasis class="po-inline e464 e464" role="ital"><textual class="po-textual">O-assignment</textual></emphasis><textual class="po-textual">
            </textual><emphasis class="po-inline e465 e465" role="bold"><textual class="po-textual">similar</textual></emphasis><textual class="po-textual">. We define accordingly a URCG as a grammar
            where competing nonterminals must not occur in the same content model and in similar
            contexts (this obviously subsumes identical contexts). It is easy to see that now we
            have made sure that competing nonterminals must not occur within the same contexts of
            labels (as opposed to nonterminals).</textual></para><para class="po-block e466 e466"><textual class="po-textual">Thus, a URCG is a GRCG where for every node we find its unique interpretation if we
            have the interpretation of the mother node and the labels of its sister nodes. In
            particular, we can interpret any node without having to recur to its sister node's
            interpretation: the content model </textual><emphasis class="po-inline e467 e467" role="ital"><textual class="po-textual">(BC|CB)</textual></emphasis><textual class="po-textual">, where
              </textual><emphasis class="po-inline e468 e468" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e469 e469" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> are
            competing nonterminals, does not satisfy the condition, because both </textual><emphasis class="po-inline e470 e470" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e471 e471" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> occur in the context
              </textual><emphasis class="po-inline e472 e472" role="ital"><textual class="po-textual">__X</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e473 e473" role="ital"><textual class="po-textual">X__</textual></emphasis><textual class="po-textual">,
            respectively, where </textual><emphasis class="po-inline e474 e474" role="ital"><textual class="po-textual">X</textual></emphasis><textual class="po-textual"> is the </textual><emphasis class="po-inline e475 e475" role="ital"><textual class="po-textual">O-assignment</textual></emphasis><textual class="po-textual"> for both. </textual></para><para class="po-block e476 e476"><textual class="po-textual">This kind of grammar is useful for the following reason: there is no global
            ambiguity in it (as we have deleted the only source of ambiguity, that interpretations
            of labels may depend on each other); and it is the strongest of the non-ambiguous
            grammar types we have considered. However, it is not capable of generating every
            language which is not inherently ambiguous, as we will show later. Note, that in order
            to provide the unique interpretation of a node, we still might have to check all of its
            sister nodes, but it is sufficient to check the labels.</textual></para><para class="po-block e477 e477"><textual class="po-textual">It is easily seen that URCGs properly include RCGs, as both left and right context
            can count as distinctive (we will make this more precise later on). As we will also see
            further down, there are languages which can be generated by GRCGs, but not by URCGs.
            This will follow from the fact that actually every RTL can be generated by a GRCG, but
            there are languages for which there are no unambiguous grammars, and, obviously, URCGs
            are always unambiguous.</textual></para><para class="po-block e478 e478"><textual class="po-textual">Interestingly, the search problem for URCGs is still linear, since we only need to
            go down the path from the root to a given node, and in addition check finitely many
            sister labels (note that while regular expressions allow for arbitrary branching, the
            branching of a given tree is, of course, always finite).</textual></para><para class="po-block e479 e479"><textual class="po-textual">An example of a URCG could be the use of attribute based co-occurrence constraints
            or attribute-element constraints in the following RELAX NG declaration. We extend our
            example grammar by adding a </textual><code class="po-atom e480 e480"><textual class="po-textual">type</textual></code><textual class="po-textual"> information to the </textual><code class="po-atom e481 e481"><textual class="po-textual">section</textual></code><textual class="po-textual">
            element. If the type is set to the value "global" other </textual><code class="po-atom e482 e482"><textual class="po-textual">section</textual></code><textual class="po-textual">
            child elements are allowed as part of the content model, if its value is set to
            "sub" only </textual><code class="po-atom e483 e483"><textual class="po-textual">para</textual></code><textual class="po-textual"> child elements are allowed (see </textual><xref class="po-milestone e484 e484" linkend="lst.grammar.rng.extd"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). </textual><figure class="po-container e485 e485" xml:id="lst.grammar.rng.extd"><title class="po-block e486 e486"><textual class="po-textual">Extended RELAX NG grammar</textual></title><programlisting class="po-block e487 e487" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
  xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;start&gt;
    &lt;element name="text"&gt;
      &lt;optional&gt;
        &lt;attribute name="author"/&gt;
      &lt;/optional&gt;
      &lt;optional&gt;
        &lt;ref name="element.title"/&gt;
      &lt;/optional&gt;
      &lt;oneOrMore&gt;
        &lt;choice&gt;
          &lt;ref name="element.section"/&gt;
          &lt;ref name="element.para"/&gt;
        &lt;/choice&gt;
      &lt;/oneOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;
  &lt;define name="element.section"&gt;
    &lt;choice&gt;
      &lt;oneOrMore&gt;
        &lt;element name="section"&gt;
          &lt;optional&gt;
            &lt;ref name="element.title"/&gt;
          &lt;/optional&gt;
          &lt;optional&gt;
            &lt;attribute name="type"&gt;
              &lt;value&gt;global&lt;/value&gt;
            &lt;/attribute&gt;
          &lt;/optional&gt;
          &lt;oneOrMore&gt;
            &lt;choice&gt;
              &lt;ref name="element.section"/&gt;
              &lt;ref name="element.para"/&gt;
            &lt;/choice&gt;
          &lt;/oneOrMore&gt;
        &lt;/element&gt;
      &lt;/oneOrMore&gt;
      &lt;oneOrMore&gt;
        &lt;element name="section"&gt;
          &lt;optional&gt;
            &lt;ref name="element.title"/&gt;
          &lt;/optional&gt;
          &lt;optional&gt;
            &lt;attribute name="type"&gt;
              &lt;value&gt;sub&lt;/value&gt;
            &lt;/attribute&gt;
          &lt;/optional&gt;
          &lt;ref name="element.para"/&gt;
        &lt;/element&gt;
      &lt;/oneOrMore&gt;
    &lt;/choice&gt;
  &lt;/define&gt;
  &lt;define name="element.title"&gt;
    &lt;element name="title"&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;
  &lt;define name="element.para"&gt;
    &lt;element name="para"&gt;
      &lt;interleave&gt;
        &lt;optional&gt;
          &lt;attribute name="id"
            datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
            &lt;data type="ID"/&gt;
          &lt;/attribute&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
          &lt;element name="xref"&gt;
            &lt;attribute name="href"
              datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
              &lt;data type="IDREF"/&gt;
            &lt;/attribute&gt;
          &lt;/element&gt;
        &lt;/optional&gt;
        &lt;text/&gt;
      &lt;/interleave&gt;
    &lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;
</textual></programlisting></figure><textual class="po-textual">
          </textual></para><para class="po-block e488 e488"><textual class="po-textual">The interesting part is the definition of the </textual><code class="po-atom e489 e489"><textual class="po-textual">element.section</textual></code><textual class="po-textual"> pattern.
            It allows for two different elements named "section" with different content
            models according to the value of the optional </textual><code class="po-atom e490 e490"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute. The result is
            that the instance shown in </textual><xref class="po-milestone e491 e491" linkend="lst.instance.rng.ex1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is valid according to
            this RELAX NG grammar while the one shown in </textual><xref class="po-milestone e492 e492" linkend="lst.instance.rng.ex2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is
            not.</textual></para><figure class="po-container e493 e493" xml:id="lst.instance.rng.ex1"><title class="po-block e494 e494"><textual class="po-textual">Valid XML instance according to the extended RELAX NG grammar</textual></title><programlisting class="po-block e495 e495" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;text author="ms"&gt;
  &lt;title&gt;A simple title&lt;/title&gt;
  &lt;section type="global"&gt;
    &lt;title&gt;A section title&lt;/title&gt;
    &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
    &lt;section type="sub"&gt;
      &lt;title&gt;A subsection title&lt;/title&gt;
      &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/section&gt;
&lt;/text&gt;
</textual></programlisting></figure><note class="po-container e496 e496"><para class="po-block e497 e497"><textual class="po-textual">Without any </textual><code class="po-atom e498 e498"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute the instance shown in </textual><xref class="po-milestone e499 e499" linkend="lst.instance.rng.ex1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> would still be valid.</textual></para></note><figure class="po-container e500 e500" xml:id="lst.instance.rng.ex2"><title class="po-block e501 e501"><textual class="po-textual">Invalid XML instance according to the extended RELAX NG grammar</textual></title><programlisting class="po-block e502 e502" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;text author="ms"&gt;
  &lt;title&gt;A simple title&lt;/title&gt;
  &lt;section type="sub"&gt;
    &lt;title&gt;A section title&lt;/title&gt;
    &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
    &lt;section type="sub"&gt;
      &lt;title&gt;A subsection title&lt;/title&gt;
      &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
    &lt;/section&gt;
  &lt;/section&gt;
&lt;/text&gt;</textual></programlisting></figure><para class="po-block e503 e503"><textual class="po-textual">Other well deployed RELAX NG examples of attribute based co-occurrence constraints
            can be found in </textual><xref class="po-milestone e504 e504" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Chapter 7, in </textual><xref class="po-milestone e505 e505" linkend="Clark2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Section 15, or in the RELAX NG schema for the JLTF (Japanese
            Layout Taskforce) aligned document shown in </textual><xref class="po-milestone e506 e506" linkend="Sasaki2010"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e507 e507"><textual class="po-textual">Importantly, co-occurrence constraints do not add anything to the formal generative
            capacity of the grammar. This is because attributes (or their values, respectively) add
            an additional specification to the </textual><emphasis class="po-inline e508 e508" role="ital"><textual class="po-textual">terminals</textual></emphasis><textual class="po-textual">. Thereby
            we can convert competing terminals (or, equivalently, rules) into non-competing ones,
            but not vice versa. Any co-occurrence constraint thus gives us the possibility to
            distinguish maybe otherwise indistinguishable non-terminals, thereby at most keeping the
            complexity of the grammar constant, or even reducing it. Furthermore, as co-occurrence
            constraints do only affect immediate subtrees (i.e., content models), their expressivity
            is entirely contained within the expressive capacities of standard regular tree
            rewriting rules; the only thing we might need to add to our formal grammar model is some
            additional specification on the terminals.</textual></para><para class="po-block e509 e509"><textual class="po-textual">Neither DTD</textual><footnote class="po-popup e510 e510"><para class="po-block e511 e511"><xref class="po-milestone e512 e512" linkend="Fiorello2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> discuss DTD++ 2.0 which supports a large number
                of co-constraints using a syntax closely resembling DTD.</textual></para></footnote><textual class="po-textual"> nor XSD 1.0 support such attribute-element constraint, although there are
            some workarounds or hacks that can be used in XML schema to mimic co-occurrence
            constraints: either the use of the </textual><code class="po-atom e513 e513"><textual class="po-textual">xsi:type</textual></code><textual class="po-textual"> attribute or
              </textual><code class="po-atom e514 e514"><textual class="po-textual">xs:key</textual></code><footnote class="po-popup e515 e515"><para class="po-block e516 e516"><textual class="po-textual">See </textual><xref class="po-milestone e517 e517" linkend="vanderVlist2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, p. 65 and </textual><link class="po-inline e518 e518" xlink:actuate="onRequest" xlink:href="http://ajwelch.blogspot.com/2008/06/xml-schema-co-occurrence-constraint.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://ajwelch.blogspot.com/2008/06/xml-schema-co-occurrence-constraint.html</textual></link><textual class="po-textual">
                for further information.</textual></para></footnote><textual class="po-textual">. Another option to realize this particular constraint is the use of embedded
              </textual><xref class="po-milestone e519 e519" linkend="Schematron"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> business rules or conditional type assignment using type
            alternatives or assertions that are introduced in </textual><xref class="po-milestone e520 e520" linkend="XMLSchema2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> (for
            complex Types) and </textual><xref class="po-milestone e521 e521" linkend="XMLSchema2009-2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> (for simple Types). </textual><xref class="po-milestone e522 e522" linkend="lst.grammar.xsd11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a possible XSD 1.1 realization.</textual></para><figure class="po-container e523 e523" xml:id="lst.grammar.xsd11"><title class="po-block e524 e524"><textual class="po-textual">XSD grammar with XSD 1.1 </textual><code class="po-atom e525 e525"><textual class="po-textual">assert</textual></code><textual class="po-textual"> element</textual></title><programlisting class="po-block e526 e526" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="text"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="textType"&gt;
          &lt;xs:attribute name="author" type="xs:string" use="optional"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="title" type="xs:string"/&gt;
  &lt;xs:element name="section"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="title" minOccurs="0"/&gt;
        &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="type" use="optional"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="global"/&gt;
            &lt;xs:enumeration value="sub"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:attribute&gt;
      &lt;xs:assert test="@type!='sub' and (child::para | child::section) or 
        @type='sub' and not(child::section)" /&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="para"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="xref" minOccurs="0"&gt;
          &lt;xs:complexType&gt;
            &lt;xs:attribute name="href" type="xs:IDREF" use="required"/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute ref="id" use="optional"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:complexType name="textType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="title" minOccurs="0"/&gt;
      &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:group name="sectOrPara"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="section"/&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
&lt;/xs:schema&gt;</textual></programlisting></figure><para class="po-block e527 e527"><textual class="po-textual">The </textual><code class="po-atom e528 e528"><textual class="po-textual">section</textual></code><textual class="po-textual"> element contains an XSD 1.1 </textual><code class="po-atom e529 e529"><textual class="po-textual">assert</textual></code><textual class="po-textual"> element
            that uses an XPath expression in its </textual><code class="po-atom e530 e530"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute to restrain the
            possible child elements according to the </textual><code class="po-atom e531 e531"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute's value of the
              </textual><code class="po-atom e532 e532"><textual class="po-textual">section</textual></code><textual class="po-textual"> element.</textual></para><para class="po-block e533 e533"><textual class="po-textual">Note that when using XSD 1.1 assertions for expressing co-occurrence constraints we
            are not limited to immediate subtrees: although the evaluation of the XPath expression
            is done in the context of the parent element (i.e., XSD 1.1's </textual><code class="po-atom e534 e534"><textual class="po-textual">xs:assert</textual></code><textual class="po-textual">
            element uses a tree fragment rooted at the element whose type it is tested against) one
            could put the assertion at the level of the common ancestor, that is, the element that
            contains all the data needed to compute the assertion. The support for full XPath (i.e.,
            axes such as ancestor, parent or preceding and preceding-sibling and following and
            following-sibling, respectively) may be implementation-dependent. XSD 1.1 type alternatives
            are restricted to tests against constants or attributes on the element itself but not to
            ancestors, descendants, siblings or children or their attributes while Schematron
            business rules are not restricted to an XPath subset.</textual></para></listitem><listitem class="po-container e535 e535"><para class="po-block e536 e536"><textual class="po-textual">There is one type we should add, which cannot be assigned a place on the hierarchy
            from STGs to RTGs, which is, however, weakly and strongly between LTGs and RTGs.
            Grammars of this type satisfy the following conditions: we want to be able to assign a
            unique interpretation to any node </textual><emphasis class="po-inline e537 e537" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, provided we know
            the complete subtree it governs. This kind of grammar would facilitate deterministic
            parsing for bottom-up algorithms. In terms of grammar, this imposes the following
            restrictions on the formalism:</textual></para><orderedlist class="po-table e538 e538" numeration="loweralpha"><listitem class="po-container e539 e539"><para class="po-block e540 e540"><textual class="po-textual">Every leaf-terminal is introduced by a single nonterminal,</textual></para></listitem><listitem class="po-container e541 e541"><para class="po-block e542 e542"><textual class="po-textual">for every nonterminal </textual><emphasis class="po-inline e543 e543" role="ital"><textual class="po-textual">N</textual></emphasis><textual class="po-textual"> in a given grammar,
                there is at most one rule which has a given terminal </textual><emphasis class="po-inline e544 e544" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, and </textual><emphasis class="po-inline e545 e545" role="ital"><textual class="po-textual">N</textual></emphasis><textual class="po-textual"> appears in its content
                model. </textual></para></listitem></orderedlist><para class="po-block e546 e546"><textual class="po-textual">We call this grammar type </textual><emphasis class="po-inline e547 e547" role="bold"><textual class="po-textual">unique subtree grammar</textual></emphasis><textual class="po-textual">
            (USG). Note that this grammar type does not include STGs and URCGs, nor is it included
            by them. The restrictions do not restrain the occurrence of competing nonterminals in
            content models, but rather the labels which belong to nonterminals in the content model.
            More precisely, whereas the former types restrain the occurrence of competing
            nonterminals within content models, USGs restrain the content models of competing rules
            itself. </textual></para><para class="po-block e548 e548"><textual class="po-textual">However, as all other types, they properly include the class of LTGs, as every LTG
            is a USG, but not vice versa, and it easy to find a language which is generated by a
            USG, but not by LTG. Furthermore, they are properly included in the class of RTGs, in
            the strong and the weak sense (and weakly within the class of GRCGs, as we will see). </textual></para><para class="po-block e549 e549"><textual class="po-textual">As is also easy to see, the distinctive USG property provides deterministic bottom
            up parsing. In order to get the interpretation of a given node, it is therefore
            sufficient to find a path from the leaves, which is a linear search problem.</textual></para></listitem></orderedlist></section></section><section class="po-hcontainer e550 e550"><title class="po-block e551 e551"><textual class="po-textual">Structure and Global Ambiguity</textual></title><para class="po-block e552 e552"><textual class="po-textual">First, we will present some well-known results, which are important for our further
      discussion.</textual></para><para class="po-block e553 e553"><textual class="po-textual">
      </textual><emphasis class="po-inline e554 e554" role="bold"><textual class="po-textual">Theorem 1 </textual></emphasis><emphasis class="po-inline e555 e555" role="ital"><textual class="po-textual">RTGs are weakly equivalent to
        CFGs (that is, the set of strings of leaves generated by CFGs is equivalent to the set of
        strings of leaves generated by RTGs).</textual></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e556 e556"><emphasis class="po-inline e557 e557" role="bold"><textual class="po-textual">Theorem 2 </textual></emphasis><textual class="po-textual">
      </textual><emphasis class="po-inline e558 e558" role="ital"><textual class="po-textual">RTGs are strongly equivalent
        to graphs generated by a CFGs, modulo a homomorphism of node labels (i.e., a homomorphism
        which maps various node labels in a given tree onto a single one), provided the RTG has
        finitary branching.</textual></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e559 e559"><emphasis class="po-inline e560 e560" role="bold"><textual class="po-textual">Theorem 3 </textual></emphasis><textual class="po-textual">
      </textual><emphasis class="po-inline e561 e561" role="ital"><textual class="po-textual">LTGs are strongly equivalent
        to graphs generated by CFGs, provided finitary branching.</textual></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e562 e562"><textual class="po-textual">Proof is trivial: as in LTGs every node label is generated by exactly one nonterminal; and
      in CFGs, nodes which are not leaves are labeled by nonterminals, there is a one-to-one
      correspondence. This has some importance for the relation of LTGs and RTGs. It follows, that
      LTGs and RTGs are equivalent up to homomorphism, as well as all grammar types in between.
      Every discussion we have about generative capacity concerns only non-equivalence in
      isomorphism. Since also the strings of leaves for all grammar types are identical, we can only
      be interested in the sets of trees. In the sequel, if we speak of the weak generative capacity
      of a tree grammar, we refer to the sets of trees it generates, not the strings of
      leaves.</textual></para><para class="po-block e563 e563"><textual class="po-textual">Since to our knowledge, only the strong generative capacity of the grammar types of </textual><xref class="po-milestone e564 e564" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> has been in the focus of research, we will now scrutinize their weak
      generative capacity.</textual></para><para class="po-block e565 e565"><emphasis class="po-inline e566 e566" role="bold"><textual class="po-textual">Theorem 4 </textual></emphasis><emphasis class="po-inline e567 e567" role="ital"><textual class="po-textual">The
        sets of trees generated by STGs form a proper subset of the sets of trees generated by
        RCGs.</textual></emphasis></para><para class="po-block e568 e568"><textual class="po-textual">For proof, consider the trees generated by the following grammar: </textual><programlisting class="po-block e569 e569" xml:space="preserve"><textual class="po-textual">S → a(AB)
A → b(C)
B → b(D)
C → c(D)
D → c(ε)</textual></programlisting></para><para class="po-block e570 e570"><textual class="po-textual">This is an RCG, since A and B do not occur in similar contexts. In order to see that there
      is no way to generate this tree with an STG, consider the following fact: </textual><emphasis class="po-inline e571 e571" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> governs two identical labels, which however govern different
      subtrees. It is therefore impossible to introduce them with identical rules, and (by
      definition of STGs) forbidden to have two competing rules in the content model of the first
      rule. This is sufficient for the proof of weak inclusion, since all STG rules are also RCG
      rules, and therefore the languages generated form a proper subset.</textual></para><para class="po-block e572 e572"><emphasis class="po-inline e573 e573" role="bold"><textual class="po-textual">Theorem 5 </textual></emphasis><emphasis class="po-inline e574 e574" role="ital"><textual class="po-textual">The
        sets of trees generated by LTGs form a proper subset of the sets of trees generated by
        STGs.</textual></emphasis></para><para class="po-block e575 e575"><textual class="po-textual">Consider the trees generated by the following grammar: </textual><programlisting class="po-block e576 e576" xml:space="preserve"><emphasis class="po-inline e577 e577" role="ital"><textual class="po-textual">A → a(B)
B → b(C)
C → a(D)
D → c(ε)</textual></emphasis></programlisting></para><para class="po-block e578 e578"><textual class="po-textual">This is a single type tree grammar, and no LTG is able to generate such a tree (remember
      that LTGs are strongly equivalent to graphs generated by CFG, provided finitary
      branching).</textual></para><section class="po-hcontainer e579 e579"><title class="po-block e580 e580"><textual class="po-textual">Restrained Competition Grammars and Variants</textual></title><para class="po-block e581 e581"><textual class="po-textual">In this section we will scrutinize formal properties of the different types of
        restrained competition grammars. We will show which kind of languages cannot be generated by
        RCGs; we will prove that there are GRCGs which are ambiguous, and that for every language
        which can be generated by an RTG, there is a GRCG which generates the same language.
        Finally, we will show that URCGs do not have these properties, are properly included within
        GRCGs and properly include RCGs. </textual></para><para class="po-block e582 e582"><textual class="po-textual">The type of languages we cannot generate with RCGs is quickly described as follows: all
        grammars, where a single content model contains competing nonterminals, which can be
        uniquely distinguished only from their left (right, respectively) context, are not RCGs.
        Consequently, we cannot generate sets of trees, where a certain node has different subtrees
        depending on its right siblings. If we want to get rid if this asymmetry, and allow for
        GRCGs, where competing nonterminals in a single content model are uniquely determined by
        their left or right context, we run into problems: </textual></para><para class="po-block e583 e583"><emphasis class="po-inline e584 e584" role="bold"><textual class="po-textual">Theorem 6 </textual></emphasis><emphasis class="po-inline e585 e585" role="ital"><textual class="po-textual">There
          are GRCGs which are ambiguous.</textual></emphasis></para><para class="po-block e586 e586"><textual class="po-textual"> For proof, consider the following rule: </textual><emphasis class="po-inline e587 e587" role="ital"><textual class="po-textual">S →
          a(AB|BA)</textual></emphasis><textual class="po-textual">. Suppose, </textual><emphasis class="po-inline e588 e588" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e589 e589" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> are competing nonterminals; suppose furthermore, that there is some
        overlapping between </textual><emphasis class="po-inline e590 e590" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e591 e591" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">; i.e., the nonterminals generate overlapping sets of trees. In particular,
        we may assume that the trees generated by </textual><emphasis class="po-inline e592 e592" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> form a subset
        of the trees generated by </textual><emphasis class="po-inline e593 e593" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">. For example, </textual><emphasis class="po-inline e594 e594" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e595 e595" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> generate identical trees
        up to depth </textual><emphasis class="po-inline e596 e596" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">; </textual><emphasis class="po-inline e597 e597" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> in
        addition generates a tree of depth </textual><emphasis class="po-inline e598 e598" role="ital"><textual class="po-textual">n+1</textual></emphasis><textual class="po-textual">. In this case, the
        trees of the language have the root </textual><emphasis class="po-inline e599 e599" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, with two symmetrical
        sets of subtrees up to depth </textual><emphasis class="po-inline e600 e600" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">, and possibly one subtree
        with depth </textual><emphasis class="po-inline e601 e601" role="ital"><textual class="po-textual">n+1</textual></emphasis><textual class="po-textual">. It is easily seen that now it is impossible
        to merge </textual><emphasis class="po-inline e602 e602" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e603 e603" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, for then
        we would be incapable of expressing the condition that at most one subtree has depth
          </textual><emphasis class="po-inline e604 e604" role="ital"><textual class="po-textual">n+1</textual></emphasis><textual class="po-textual">. However, for the trees, where the subtrees
        introduced by </textual><emphasis class="po-inline e605 e605" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e606 e606" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> have
        depth at most </textual><emphasis class="po-inline e607 e607" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">, there is necessarily more than one
        analysis. The grammar we have described so far is, however, a GRCG, because neither
          </textual><emphasis class="po-inline e608 e608" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> nor </textual><emphasis class="po-inline e609 e609" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> occur in
        identical contexts (though in similar contexts, remember the preceding section).</textual></para><para class="po-block e610 e610"><emphasis class="po-inline e611 e611" role="bold"><textual class="po-textual">Theorem 7 </textual></emphasis><emphasis class="po-inline e612 e612" role="ital"><textual class="po-textual">For
          every language which can be generated by an RTG, there is a GRCG which generates the same
          language.</textual></emphasis></para><para class="po-block e613 e613"><textual class="po-textual"> To proof this theorem, we describe a simple procedure to convert any RTG into a GRCG,
        which generates the same language. We define competing sequences of length </textual><emphasis class="po-inline e614 e614" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> of nonterminals as follows: two sequences of nonterminals
        compete, if for all </textual><emphasis class="po-inline e615 e615" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">, the </textual><emphasis class="po-inline e616 e616" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">th nonterminal of one sequence competes with the </textual><emphasis class="po-inline e617 e617" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">th nonterminal of the other sequence. We have to assume a content model
          </textual><emphasis class="po-inline e618 e618" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual"> which is not GRCG conform. Therefore, there have to be
        two competing nonterminals or competing sequences of nonterminals </textual><emphasis class="po-inline e619 e619" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e620 e620" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e621 e621" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual">, such that for possibly empty sequences of nonterminals </textual><emphasis class="po-inline e622 e622" role="ital"><textual class="po-textual">Γ</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e623 e623" role="ital"><textual class="po-textual">Δ</textual></emphasis><textual class="po-textual">, (</textual><emphasis class="po-inline e624 e624" role="ital"><textual class="po-textual">Γ A Δ</textual></emphasis><textual class="po-textual">) and (</textual><emphasis class="po-inline e625 e625" role="ital"><textual class="po-textual">Γ B Δ</textual></emphasis><textual class="po-textual">) match
        with </textual><emphasis class="po-inline e626 e626" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e627 e627"><textual class="po-textual"> Given this, we can be sure, that in the instantiations of </textual><emphasis class="po-inline e628 e628" role="ital"><textual class="po-textual">r</textual></emphasis><textual class="po-textual">, which violate the GRCG condition, </textual><emphasis class="po-inline e629 e629" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and
          </textual><emphasis class="po-inline e630 e630" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> occur in exactly the same global tree contexts. By
        global tree context we here mean that a tree with a governing the subtrees generated by
          </textual><emphasis class="po-inline e631 e631" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> is part of the language iff a also governs the set of
        subtrees generated by </textual><emphasis class="po-inline e632 e632" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">. Since this is the case, we can
        simply merge the two nonterminals to a new one, </textual><emphasis class="po-inline e633 e633" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual">, which is
        the union of the former two. This new nonterminal substitutes all instantiations of
          </textual><emphasis class="po-inline e634 e634" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e635 e635" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, which occur in
        the same global tree context. This, by definition, are the instantiations which violate the
        GRCG condition. This we can apply to all nonterminals which violate the GRCG condition. The
        only thing we have to take care of is that we apply this only to those instantiations of the
        content models where two competing nonterminals match equally (this might force us to change
        some regular expressions). We do not show an exact algorithm at this point, since it is
        clear that an equivalent GRCG exist, and the details of the construction are of no practical
        interest at this point. </textual></para><para class="po-block e636 e636"><textual class="po-textual">We now show that there is a hierarchy of proper inclusion RCG ⊂ URCG ⊂ GRCG.
        To show that RCG ⊂ URCG, consider the following: every rule which is admitted by an
        RCG is also admitted by a URCG, because if competing nonterminals in the same content model
        have a unique prefix, a fortiori they also have a unique context (we have already shown that
        a unique prefix of nonterminals is paramount to a unique prefix of labels/siblings, by
        induction). Above, we have already shown that for an RCG it is impossible to generate
        languages as the following, which is a URCG. </textual><programlisting class="po-block e637 e637" xml:space="preserve"><emphasis class="po-inline e638 e638" role="ital"><textual class="po-textual">S → a(AC|BD)
A → b(C)
B → b(D)
C → c(ε)
D → d(ε)</textual></emphasis></programlisting><textual class="po-textual">
        </textual><emphasis class="po-inline e639 e639" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e640 e640" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> compete, but are
        determined uniquely by their context.</textual></para><para class="po-block e641 e641"><textual class="po-textual">This concludes the first part; the second part will be a corollary of the next section:
        We will show that some languages are inherently ambiguous, that is, there is no unambiguous
        grammar for them. By Theorem 7 we know that we can generate these languages with GRCGs, but
        URCGs cannot:</textual></para><para class="po-block e642 e642"><emphasis class="po-inline e643 e643" role="bold"><textual class="po-textual">Proposition 1 </textual></emphasis><emphasis class="po-inline e644 e644" role="ital"><textual class="po-textual">A URCG cannot be ambiguous.</textual></emphasis></para><para class="po-block e645 e645"><textual class="po-textual">This is easy to see: an ambiguous grammar assigns two different sequences of
        nonterminals to the daughters of one node (since root nodes are unambiguous): Then however,
        there must be at least two competing nonterminals which occur in the same content model in
        similar contexts, which, by definition, is impossible.</textual></para></section><section class="po-hcontainer e646 e646"><title class="po-block e647 e647"><textual class="po-textual">Inherently Ambiguous Languages</textual></title><para class="po-block e648 e648"><textual class="po-textual">As a corollary, we can show that there are regular tree languages, for which there is no
        unambiguous grammar. There are sets of trees, which are generated by an ambiguous GRCG, but
        by no URCG. We will call these languages </textual><emphasis class="po-inline e649 e649" role="ital"><textual class="po-textual">inherently
          ambiguous</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e650 e650"><emphasis class="po-inline e651 e651" role="bold"><textual class="po-textual">Theorem 8 </textual></emphasis><emphasis class="po-inline e652 e652" role="ital"><textual class="po-textual">Some
          regular tree languages are inherently ambiguous.</textual></emphasis></para><para class="po-block e653 e653"><textual class="po-textual">This can be seen easily, if we spell out a grammar which we described in the above
        subsection. We will then show that there is now way to write an unambiguous grammar which
        generates the same language.</textual><programlisting class="po-block e654 e654" xml:space="preserve"><emphasis class="po-inline e655 e655" role="ital"><textual class="po-textual">S → r(AB|BA)
A → a(C)
B → a(D)
C → b(ε)
D → b(ε|E)
E → c(ε)</textual></emphasis></programlisting></para><para class="po-block e656 e656"><textual class="po-textual">There is no way to merge </textual><emphasis class="po-inline e657 e657" role="ital"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e658 e658" role="ital"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, since they generate different sets of subtrees (we can write </textual><emphasis class="po-inline e659 e659" role="ital"><textual class="po-textual">L(A)≠L(B)</textual></emphasis><textual class="po-textual">); but since they overlap (</textual><emphasis class="po-inline e660 e660" role="ital"><textual class="po-textual">L(A)∩ L(B)≠ ∅</textual></emphasis><textual class="po-textual">), there is no way to have a unique
        interpretation in the cases where the subtrees generated by the nonterminals are identical.
        There will always be two ways to generate trees in this case.</textual></para><para class="po-block e661 e661"><textual class="po-textual">We can, furthermore, precisely state the conditions, under which a regular tree language
        is ambiguous. To this end, however, we need to introduce some notation. We now for
        simplicity write trees as terms: a tree with root </textual><emphasis class="po-inline e662 e662" role="ital"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> and
        daughters </textual><emphasis class="po-inline e663 e663" role="ital"><textual class="po-textual">b</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e664 e664" role="ital"><textual class="po-textual">c</textual></emphasis><textual class="po-textual"> is
        denoted as </textual><emphasis class="po-inline e665 e665" role="ital"><textual class="po-textual">a(b,c)</textual></emphasis><textual class="po-textual">, etc. As a next step, we define a context
        as the position, where certain subtrees occur within trees of a language. </textual></para><para class="po-block e666 e666"><textual class="po-textual">
        </textual><emphasis class="po-inline e667 e667" role="bold"><textual class="po-textual">Definition 9</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e668 e668" role="ital"><textual class="po-textual">A context C is a tree-term with exactly one variable. We say that a
          set of subtrees α occurs in a context C in a language L, if the following holds: We
          can instantiate the variable of C with any tree from α, and the resulting tree is in
          L</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e669 e669"><textual class="po-textual">Note that sets of subtrees correspond to nonterminals, when we speak of languages rather
        than grammars. In the sequel, for simplicity we will use lower case Greek variables equally
        for sets of subtrees as for ordered sequences of sets of subtrees. The definition of a
        context is easily accommodated to sequences. A set of sequences of trees of length </textual><emphasis class="po-inline e670 e670" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> consists of ordered tuples of trees of length </textual><emphasis class="po-inline e671 e671" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">, of the form (</textual><emphasis class="po-inline e672 e672" role="ital"><textual class="po-textual">t</textual><subscript class="po-atom e673 e673"><textual class="po-textual">0</textual></subscript><textual class="po-textual">,...,t</textual><subscript class="po-atom e674 e674"><textual class="po-textual">n-1</textual></subscript></emphasis><textual class="po-textual">). Sets of subtrees
        are then simply sets of one-tuples. Importantly, we will not provide a proof for the
        following proposition, and leave it open as a conjecture. However, we will sketch the
        argument. We now make the following conjecture: </textual></para><para class="po-block e675 e675"><emphasis class="po-inline e676 e676" role="bold"><textual class="po-textual">Conjecture 1</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e677 e677" role="ital"><textual class="po-textual">A tree-language is inherently ambiguous iff at least one node fulfills
          all of the following conditions: </textual></emphasis></para><para class="po-block e678 e678"><emphasis class="po-inline e679 e679" role="ital"><textual class="po-textual">We need to have one node with an arbitrary label a, with at least
          two (sequences of) sets of subtrees α and β, such that </textual></emphasis></para><orderedlist class="po-table e680 e680" numeration="arabic"><listitem class="po-container e681 e681"><para class="po-block e682 e682"><emphasis class="po-inline e683 e683" role="ital"><textual class="po-textual">α ∩ β ≠ ∅</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e684 e684"><para class="po-block e685 e685"><emphasis class="po-inline e686 e686" role="ital"><textual class="po-textual">α ≠ β</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e687 e687"><para class="po-block e688 e688"><textual class="po-textual">There is at least one context </textual><emphasis class="po-inline e689 e689" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e690 e690" role="ital"><textual class="po-textual">L</textual></emphasis><textual class="po-textual">, such that both </textual><emphasis class="po-inline e691 e691" role="ital"><textual class="po-textual">a(Γ,
                (t</textual><subscript class="po-atom e692 e692"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,t</textual><subscript class="po-atom e693 e693"><textual class="po-textual">n</textual></subscript><textual class="po-textual">), Δ,
                (u</textual><subscript class="po-atom e694 e694"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,u</textual><subscript class="po-atom e695 e695"><textual class="po-textual">n</textual></subscript><textual class="po-textual">), Θ)</textual></emphasis><textual class="po-textual"> and
              </textual><emphasis class="po-inline e696 e696" role="ital"><textual class="po-textual">a(Γ,
                (u</textual><subscript class="po-atom e697 e697"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,u</textual><subscript class="po-atom e698 e698"><textual class="po-textual">n</textual></subscript><textual class="po-textual">), Δ,
                (t</textual><subscript class="po-atom e699 e699"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,t</textual><subscript class="po-atom e700 e700"><textual class="po-textual">n</textual></subscript><textual class="po-textual">), Θ)</textual></emphasis><textual class="po-textual"> occur
            in </textual><emphasis class="po-inline e701 e701" role="ital"><textual class="po-textual">C</textual></emphasis><textual class="po-textual">, for all </textual><emphasis class="po-inline e702 e702" role="ital"><textual class="po-textual">(t</textual><subscript class="po-atom e703 e703"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,t</textual><subscript class="po-atom e704 e704"><textual class="po-textual">n</textual></subscript><textual class="po-textual">) ∈ α</textual></emphasis><textual class="po-textual">
            and all </textual><emphasis class="po-inline e705 e705" role="ital"><textual class="po-textual">(u</textual><subscript class="po-atom e706 e706"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,u</textual><subscript class="po-atom e707 e707"><textual class="po-textual">n</textual></subscript><textual class="po-textual">)
              ∈ β</textual></emphasis><textual class="po-textual">, where uppercase Greek letters designate possibly empty
            sequences of daughter sub-trees; note that the sequences need to have equal length in
            order to meet condition 1.</textual></para></listitem></orderedlist><para class="po-block e708 e708"><textual class="po-textual">Due to space restrictions, we leave the prove for this conjecture open here; this
        reminds however of a theorem in </textual><xref class="po-milestone e709 e709" linkend="Odgen1968"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for string languages. But we
        will give some rather informal discussion of the points in the next section. It is not hard
        to see that this is merely a generalization of the cases we have been described above. As we
        will see, we can derive some useful facts from these properties of ambiguous languages, even
        without a general proof: we can show that we can construe grammars for languages which do
        not fulfill one of the conditions, and, moreover, which type of grammars we can
        construe.</textual></para></section><section class="po-hcontainer e710 e710"><title class="po-block e711 e711"><textual class="po-textual">Unambiguous Languages</textual></title><para class="po-block e712 e712"><emphasis class="po-inline e713 e713" role="bold"><textual class="po-textual">Theorem 9</textual></emphasis><textual class="po-textual">
        </textual><emphasis class="po-inline e714 e714" role="ital"><textual class="po-textual">From the grammar types sketched so far, there is no type which
          generates all and only the RTLs that are not inherently ambiguous.</textual></emphasis></para><para class="po-block e715 e715"><textual class="po-textual">We will demonstrate this going through the three conditions mentioned in the preceding
        section, and look which unambiguous grammar we can construe if one condition is not met.
        This is to be read as follows: if one condition is not met, then it means, that from all
        nodes of the tree language, there might be any one which meets the ones not in question, but
        none which meets the one currently under consideration.</textual></para><orderedlist class="po-table e716 e716"><listitem class="po-container e717 e717"><para class="po-block e718 e718"><textual class="po-textual">If there is no intersection between the subtrees of a given node, the grammar is of
            course not ambiguous. We can, however not necessarily construe a URCG for this grammar,
            since in the content model of the mother node there are competing nonterminals in
            similar contexts (recall the example given above).</textual></para><para class="po-block e719 e719"><textual class="po-textual">We can, however, construe a USG for such a language, since subtrees are uniquely
            identifiable.</textual></para></listitem><listitem class="po-container e720 e720"><para class="po-block e721 e721"><textual class="po-textual">This means that there are no two sets of subtrees governed by the same node which
            are not identical. We can thus introduce them by the same nonterminals, and have a local
            tree grammar (having no different sets of subtrees governed by the same node amounts to
            say we need no competing rules in the grammar, as nonterminals correspond to sets of
            subtrees).</textual></para></listitem><listitem class="po-container e722 e722"><para class="po-block e723 e723"><textual class="po-textual">If the third condition is not met, then we can construe nonterminals (corresponding
            to the sets of subtrees) such that for all of them the following holds: assuming they
            compete (introduce identical labels), they either occur in different contexts, in which
            case they are distinguishable thereby and no ambiguity arises; or they occur in
            identical contexts, in which case we can use a unique nonterminal which is the merge of
            both (this also holds for root nodes). The critical case, where the content of one
            (sequence of) set(s) of subtrees depends on the other one, which makes them occur in
            similar contexts, while making it impossible to merge them, however, we have excluded by
            assumption.</textual></para><para class="po-block e724 e724"><textual class="po-textual">Since this argument holds inductively from the root to all subtrees, we can construe
            a URCG for the language were condition 3 is not met, but we cannot use any strictly
            weaker type. The only thing we have provided is that if two sets of subtrees occur in
            similar contexts (for the grammar we construe), then they actually occur in identical
            contexts. It follows that we do not need competing nonterminals in similar
            contexts.</textual></para></listitem></orderedlist><para class="po-block e725 e725"><textual class="po-textual">This shows that we still have not solved the problem to define a canonical grammar type
        which generates all and only the unambiguous languages, since there are languages which are
        generated by USGs, but no other canonical class which does not allow any ambiguity type, and
        languages which are generated by URCGs and no other such type. So far, we are still lacking
        a characterization of the unambiguous languages in terms of grammar rules. </textual></para></section></section><section class="po-hcontainer e726 e726"><title class="po-block e727 e727"><textual class="po-textual">Application and Future Research</textual></title><para class="po-block e728 e728"><textual class="po-textual">When we speak of XML schema languages and applications, the first thing that comes into
      mind is parsing an instance and validate it according to a respective schema. </textual><xref class="po-milestone e729 e729" linkend="Murata2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> have shown algorithms for parsing the three types of tree grammars we
      discussed already. However, a task which is still open is to provide algorithms for the new
      grammars types we have defined.</textual></para><para class="po-block e730 e730"><xref class="po-milestone e731 e731" linkend="Mani2002"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> demonstrated the use of the theory of regular tree grammars for
      the XML to relational conversion as an additional application of formal language in the XML
      context. Again, this work could be extended using the newly established grammar types.</textual></para><para class="po-block e732 e732"><textual class="po-textual">Regarding future research this paper may serve as just a foundation in the fields of XML
      applications and formal languages. New features that are introduced in XSD 1.1 such as
      conditional type assignment, assertions and the </textual><code class="po-atom e733 e733"><textual class="po-textual">openContent</textual></code><textual class="po-textual"> element as well as
      the relaxed </textual><emphasis class="po-inline e734 e734" role="ital"><textual class="po-textual">Unique Particle Attribution</textual></emphasis><textual class="po-textual"> rule (UPA, aka the
      determinism rule, see </textual><xref class="po-milestone e735 e735" linkend="XMLSchema2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Section 3.8.6.4), or changed behavior
      regarding wildcards have effects on the expressiveness. Apart from these natural enhancements,
      another focus may lie in examining the relationships between XPath and XQuery and formal
      languages on the basis of the work undertaken in this paper; we expect to shed some light on
      this topic during future research. In addition, a more formal approach in the analysis of
      overlapping markup structures such as GODDAGs (</textual><xref class="po-milestone e736 e736" linkend="Sperberg-McQueen2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) could
      be an interesting field for future work.</textual></para><para class="po-block e737 e737"><textual class="po-textual">Seen from a practical perspective and under consideration of the findings in </textual><xref class="po-milestone e738 e738" linkend="Martens2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, a large portion of the XML document grammars that can be found in
      the wild are structurally equivalent to DTDs or </textual><emphasis class="po-inline e739 e739" role="ital"><textual class="po-textual">specialized
        DTDs</textual></emphasis><textual class="po-textual"> (that is, adding a mechanism to decouple element names from their types to
      regular DTDs, see </textual><xref class="po-milestone e740 e740" linkend="Papakonstantinou2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e741 e741" linkend="Balmin2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
      – also called EDTDs by </textual><xref class="po-milestone e742 e742" linkend="Martens2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), hence use roughly the
      expressiveness of local tree grammars. This is often due to nontransparent restrictions in the
      XML Schema spec such as the already discussed </textual><emphasis class="po-inline e743 e743" role="ital"><textual class="po-textual">Element Declarations
        Consistent</textual></emphasis><textual class="po-textual"> (EDC) constraint. </textual><xref class="po-milestone e744 e744" linkend="Bex2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e745 e745" linkend="Martens2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> provide simplifications for XSDs and XSD authoring tools that should
      relive authors from the burden of these constraints by </textual><quote class="po-inline e746 e746"><textual class="po-textual">automatically transforming
        nondeterministic expressions into concise deterministic ones</textual></quote><textual class="po-textual">. Regarding RELAX NG
      document grammars we think that restraining its expressive power to the class of URCGs would
      provide a feasible compromise. Up to this point we hope that this more fine-grained hierarchy
      may serve others as guide for choosing a specific XML schema language depending on the
      expressivity of the markup language that has to be developed.</textual></para></section><bibliography class="po-hcontainer e747 e747"><title class="po-block e748 e748"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e749 e749" xml:id="Abiteboul2000" xreflabel="Abiteboul et al., 2000"><textual class="po-textual">Abiteboul, S., P.
      Buneman, and D. Suciu (2000). Data on the Web: From Relations to Semistructured Data and XML.
      Morgan Kaufmann Publishers, San Francisco, California.</textual></bibliomixed><bibliomixed class="po-block e750 e750" xml:id="Ansari2009" xreflabel="Ansari et al., 2009"><textual class="po-textual">Ansari, M. S., Zahid, N., and
      K.-G. Doh. A Comparative Analysis of XML Schema Languages. In Slezak, D., Kim, T., Zhang, Y.,
      Ma, J., and K. Chung, eds., Database Theory and Application. International Conference, DTA
      2009, Held as Part of the Future Generation Information Technology Conference, FGIT 2009, Jeju
      Island, Korea, December 10-12, 2009. Proceedings, volume 64, pages 41– 48. Springer, Berlin,
      Heidelberg, 2009. doi: </textual><biblioid class="po-atom e751 doi e751"><textual class="po-textual">10.1007/978-3-642-10583-8_6</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e752 e752" xml:id="Balmin2004" xreflabel="Balmin et al., 2004"><textual class="po-textual">Balmin, A., Papakonstantinou,
      Y., and V. Vianu (2004). Incremental validation of XML documents. ACM Transactions on Database
      Systems (TODS), 29(4):710–751. doi: </textual><biblioid class="po-atom e753 doi e753"><textual class="po-textual">10.1145/1042046.1042050</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e754 e754" xml:id="Bauman2008" xreflabel="Bauman, 2008"><textual class="po-textual">Bauman, S., (2008). Freedom to
      Constrain: where does attribute constraint come from, mommy? In Proceedings of Balisage: The
      Markup Conference 2008. Balisage Series on Markup Technologies, vol. 1 (2008). doi: </textual><biblioid class="po-atom e755 doi e755"><textual class="po-textual">10.4242/BalisageVol1.Bauman01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e756 e756" xml:id="Bex2009" xreflabel="Bex et al., 2009"><textual class="po-textual">Bex, G. J., Gelade, W., Martens, W.
      and F. Neven (2009). Simplifying XML Schema: Effortless Handling of Nondeterministic Regular
      Expressions. In SIGMOD ’09: Proceedings of the 35th SIGMOD international conference on
      Management of data, pages 731–744, New York, NY, USA, ACM. doi: </textual><biblioid class="po-atom e757 doi e757"><textual class="po-textual">10.1145/1559845.1559922</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e758 e758" xml:id="Brueggemann-Klein1992" xreflabel="Brüggemann-Klein and Wood, 1992"><textual class="po-textual">Brüggemann-Klein, A., and D. Wood (1992). Deterministic Regular Languages. In Finkel, A. and
      M. Jantzen, eds., STACS 92. 9th Annual Symposium on Theoretical Aspects of Computer Science
      Cachan, France, February 13–15, 1992 Proceedings, volume 577 of Lecture Notes in Computer
      Science, pages 173–184. Springer, Berlin, Heidelberg. doi: </textual><biblioid class="po-atom e759 doi e759"><textual class="po-textual">10.1007/3-540-55210-3_182</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e760 e760" xml:id="Brueggemann-Klein1993" xreflabel="Brüggemann-Klein, 1993"><textual class="po-textual">Brüggemann-Klein,
      A. (1993). Formal Models in Document Processing. Habilitation, Albert-Ludwig-Universität zu
      Freiburg i. Br.</textual></bibliomixed><bibliomixed class="po-block e761 e761" xml:id="Brueggemann-Klein1997" xreflabel="Brüggemann-Klein and Wood, 1997"><textual class="po-textual">Brüggemann-Klein, A., and D. Wood (1997). One-unambiguous regular languages. Information and
      computation, 142:182–206. doi: </textual><biblioid class="po-atom e762 doi e762"><textual class="po-textual">10.1006/inco.1997.2695</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e763 e763" xml:id="Brueggemann-Klein2002" xreflabel="Brüggemann-Klein and Wood, 2002"><textual class="po-textual">Brüggemann-Klein, A., and D. Wood (2002). The parsing of extended context-free grammars.
      HKUST Theoretical Computer Science Center Research Report HKUST-TCSC-2002-08, The Hong Kong
      University of Science and Technology Library.</textual></bibliomixed><bibliomixed class="po-block e764 e764" xml:id="Brueggemann-Klein2004" xreflabel="Brüggemann-Klein and Wood, 2004"><textual class="po-textual">Brüggemann-Klein, A., and D. Wood (2004). Balanced context-free grammars, hedge grammars and
      pushdown caterpillar automata. In Proceedings of Extreme Markup Languages, Montréal,
      Québec.</textual></bibliomixed><bibliomixed class="po-block e765 e765" xml:id="Buck2000" xreflabel="Buck et al., 2000"><textual class="po-textual">Buck, L., Goldfarb, C. F., and P.
      Prescod (2000). Datatypes for DTDs (DT4DTD) 1.0. W3C Note 13 January 2000, World Wide Web
      Consortium.</textual></bibliomixed><bibliomixed class="po-block e766 e766" xml:id="Carey2009" xreflabel="Carey, 2009"><textual class="po-textual">Carey, B. M. (2009). Meet CAM: A new XML
      validation technology. Take semantic and structural validation to the next level. IBM
      developerworks, IBM Corporation. </textual><link class="po-inline e767 e767" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-cam/?S_TACT=105AGX54&amp;S_CMP=C0924&amp;ca=dnw-1036&amp;ca=dth-x&amp;open&amp;cm_mmc=6015-_-n-_-vrm_newsletter-_-10731_131528&amp;cmibm_em=dm:0:13962324" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ibm.com/developerworks/xml/library/x-cam/?S_TACT=105AGX54&amp;S_CMP=C0924&amp;ca=dnw-1036&amp;ca=dth-x&amp;open&amp;cm_mmc=6015-_-n-_-vrm_newsletter-_-10731_131528&amp;cmibm_em=dm:0:13962324</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e768 e768" xml:id="Chomsky1955" xreflabel="Chomsky, 1955"><textual class="po-textual">Chomsky, N. (1955). Logical Syntax
      and Semantics: Their Linguistic Relevance. Language, 31(1):36–45, 1955. doi: </textual><biblioid class="po-atom e769 doi e769"><textual class="po-textual">10.2307/410891</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e770 e770" xml:id="Chomsky1956" xreflabel="Chomsky, 1956"><textual class="po-textual">Chomsky, N. (1956). Three Models for
      the Description of Language. IRE Transactions on Information Theory, 2:113–124,
      1956. doi: </textual><biblioid class="po-atom e771 doi e771"><textual class="po-textual">10.1109/TIT.1956.1056813</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e772 e772" xml:id="Clark2001" xreflabel="Clark, 2001"><textual class="po-textual">Clark, J. (2001). TREX – Tree Regular
      Expressions for XML Language Specification. Technical report, Thai Open Source Software Center
      Ltd.</textual></bibliomixed><bibliomixed class="po-block e773 e773" xml:id="Clark2003" xreflabel="Clark et al., 2003"><textual class="po-textual">Clark, J., J. Cowan, and M.
      Murata, (2003). Relax NG Compact Syntax Tutorial. Working Draft 26 March 2003, OASIS –-
      Organization for the Advancement of Structured Information Standards. </textual><link class="po-inline e774 e774" xlink:actuate="onRequest" xlink:href="http://relaxng.org/compact-tutorial-20030326.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://relaxng.org/compact-tutorial-20030326.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e775 e775" xml:id="Comon2008" xreflabel="Comon et al., 2008"><textual class="po-textual">Comon, H., M. Dauchet, R.
      Gilleron, C. Löding, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi (2007). Tree Automata
      Techniques and Applications. Release November, 18th 2008. </textual><link class="po-inline e776 e776" xlink:actuate="onRequest" xlink:href="http://www.grappa.univ-lille3.fr/tata" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.grappa.univ-lille3.fr/tata</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e777 e777" xml:id="Costello2008" xreflabel="Costello and Simmons, 2008"><textual class="po-textual"> Costello, R. L., and
      R. A. Simmons (2008). Tutorials on Schematron: Two Types of XML Schema Language. </textual><link class="po-inline e778 e778" xlink:actuate="onRequest" xlink:href="http://www.xfront.com/schematron/Two-types-of-XML-Schema-Language.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xfront.com/schematron/Two-types-of-XML-Schema-Language.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e779 e779" xml:id="Moeller2005" xreflabel="DSD2"><textual class="po-textual">Møller, A. (2005). Document Structure
      Description 2.0. Technical report, BRICS (Basic Research in Computer Science, Aarhus
      University), 2005. </textual><link class="po-inline e780 e780" xlink:actuate="onRequest" xlink:href="http://www.brics.dk/DSD/dsd2.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.brics.dk/DSD/dsd2.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e781 e781" xml:id="Fiorello2004" xreflabel="Fiorello et al., 2004"><textual class="po-textual">Fiorello, D., Gessa, N.,
      Marinelli, P., and F. Vitali. DTD++ 2.0: Adding support for co-constraints. In Proceedings of
      Extreme Markup Languages, Montréal, Québec.</textual></bibliomixed><bibliomixed class="po-block e782 e782" xml:id="Gelade2009" xreflabel="Gelade et al., 2009"><textual class="po-textual">Gelade, W, Martens, W., and F.
      Neven (2009). Optimizing Schema Languages for XML: Numerical Constraints and Interleaving.
      SIAM Journal on Computing, 38(5):2021–2043. doi: </textual><biblioid class="po-atom e783 doi e783"><textual class="po-textual">10.1137/070697367</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e784 e784" xml:id="Goldfarb1978" xreflabel="Goldfarb, 1978"><textual class="po-textual">Goldfarb, C. F. (1978). DCF GML
      User’s Guide (IBM SH20-9160). IBM, 1978.</textual></bibliomixed><bibliomixed class="po-block e785 e785" xml:id="Goldfarb1991" xreflabel="Goldfarb, 1991"><textual class="po-textual">Goldfarb, C. F. (1991). The SGML
      Handbook. Oxford University Press, Oxford.</textual></bibliomixed><bibliomixed class="po-block e786 e786" xml:id="Gecseg1997" xreflabel="Gécseg and Steinby, 1997"><textual class="po-textual">Gécseg, F., and M. Steinby
      (1997). Tree languages. In Handbook of Formal Languages, volume 3, pages 1-68. Springer, New
      York.</textual></bibliomixed><bibliomixed class="po-block e787 e787" xml:id="Hopcroft2000" xreflabel="Hopcroft et al., 2000"><textual class="po-textual">Hopcroft, J., R. Motwani,
      and J. Ullman (2000). Introduction to Automata Theory, Languages, and Computation. 2nd
      edition. Addison Wesley Longman, Amsterdam.</textual></bibliomixed><bibliomixed class="po-block e788 e788" xml:id="Jeliffe2009" xreflabel="Jeliffe, 2009"><textual class="po-textual">Jeliffe, R. (2009). Is Schematron a
      rules language? Online: </textual><link class="po-inline e789 e789" xlink:actuate="onRequest" xlink:href="http://broadcast.oreilly.com/2009/01/is-schematron-a-rules-language.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://broadcast.oreilly.com/2009/01/is-schematron-a-rules-language.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e790 e790" xml:id="Kilpeläinen2007" xreflabel="Kilpeläinen and Tuhkanen, 2007"><textual class="po-textual">Kilpeläinen,
      P., and R. Tuhkanen (2007). One-unambiguity of regular expressions with numeric occurrence
      indicators. Information and Computation, 205(6):890–916. doi: </textual><biblioid class="po-atom e791 doi e791"><textual class="po-textual">10.1016/j.ic.2006.12.003</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e792 e792" xml:id="Klarlund2003" xreflabel="Klarlund et al., 2003"><textual class="po-textual">Klarlund, N., T.
      Schwentick, and D. Suciu (2003). XML: Model, Schemas, Types, Logics and Queries. In Chomicki,
      J., R. van der Meyden, and G. Saake, eds., Logics for Emerging Applications of Databases,
      pages 1-41. Springer, Berlin, Heidelberg.</textual></bibliomixed><bibliomixed class="po-block e793 e793" xml:id="Kracht2010" xreflabel="Kracht, 2010"><textual class="po-textual">Kracht, M. (to appear). Modal Logic
      Foundations of Markup Structures in Annotation Systems. In Mehler, A., Kühnberger, K.-U.,
      Lobin, H., Lüngen, H., Storrer, A., and A. Witt, eds., Modeling, Learning and Processing of
      Text Technological Data Structures, Studies in Computational Intelligence. Springer,
      Dordrecht.</textual></bibliomixed><bibliomixed class="po-block e794 e794" xml:id="Lee2000" xreflabel="Lee and Chu, 2000"><textual class="po-textual">Lee, D. and W. Chu. Comparative
      Analysis of Six XML Schema Languages. ACM SIGMOD Record, 29(3):76–87, September
      2000. doi: </textual><biblioid class="po-atom e795 doi e795"><textual class="po-textual">10.1145/362084.362140</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e796 e796" xml:id="Maler1995" xreflabel="Maler and Andaloussi, 1995"><textual class="po-textual">Maler, E., and J. E.
      Andaloussi (1995). Developing SGML DTDs: From Text to Model to Markup. Prentice Hall, Upper
      Saddle River, New Jersey</textual></bibliomixed><bibliomixed class="po-block e797 e797" xml:id="Mani2001" xreflabel="Mani, 2001"><textual class="po-textual">M. Mani (2001). Keeping chess alive: Do we
      need 1-unambiguous content models? In Proceedings of Extreme Markup Languages, Montréal,
      Québec.</textual></bibliomixed><bibliomixed class="po-block e798 e798" xml:id="Mani2002" xreflabel="Mani and Lee, 2002"><textual class="po-textual">Mani, M., and D. Lee (2002). XML
      to Relational Conversion using Theory of Regular Tree Grammars. In Proceedings of the 28th
      VLDB Conference, Hong Kong, China.</textual></bibliomixed><bibliomixed class="po-block e799 e799" xml:id="Marcoux2008" xreflabel="Marcoux, 2008"><textual class="po-textual">Marcoux, Y. (2008). Graph
      characterization of overlap-only TexMECS and other overlapping markup formalisms. In
      Proceedings of Balisage: The Markup Conference 2008. Balisage Series on Markup Technologies,
      vol. 1. Montréal, Québec. doi: </textual><biblioid class="po-atom e800 doi e800"><textual class="po-textual">10.4242/BalisageVol1.Marcoux01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e801 e801" xml:id="Martens2005" xreflabel="Martens et al., 2005"><textual class="po-textual">Martens, W., Neven, F., and
      T. Schwentick (2005). Which XML Schemas Admit 1-Pass Preorder Typing? In Eiter, T., and L.
      Libkin, eds., Database Theory – ICDT 2005, volume 3363 of Lecture Notes in Computer Science,
      pages 68–82. Springer, Berlin, Heidelberg, 2005. doi: </textual><biblioid class="po-atom e802 doi e802"><textual class="po-textual">10.1007/978-3-540-30570-5_5</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e803 e803" xml:id="Martens2006" xreflabel="Martens et al., 2006"><textual class="po-textual">Martens, W., Neven, F.,
      Schwentick, T., and G. Bex (2006). Expressiveness and Complexity of XML Schema. ACM
      Transactions on Database Systems (TODS), 31(3):770–813. doi: </textual><biblioid class="po-atom e804 doi e804"><textual class="po-textual">10.1145/1166074.1166076</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e805 e805" xml:id="Martens2007" xreflabel="Martens et al., 2007"><textual class="po-textual">Martens, W., Neven, F. and T.
      Schwentick (2007). Simple off the shelf abstractions for XML schema. SIGMOD Rec.,
      36(3):15–22. doi: </textual><biblioid class="po-atom e806 doi e806"><textual class="po-textual">10.1145/1324185.1324188</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e807 e807" xml:id="Martens2009" xreflabel="Martens et al., 2009"><textual class="po-textual">Martens, W., Neven, F. and T.
      Schwentick (2009). Complexity of Decision Problems for XML Schemas and Chain Regular
      Expressions. SIAM Journal on Computing, 39(4):1486–1530. doi: </textual><biblioid class="po-atom e808 doi e808"><textual class="po-textual">10.1137/080743457</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e809 e809" xml:id="Moeller2006" xreflabel="Møller and Schwartzbach, 2006"><textual class="po-textual">Møller, A., and M.
      Schwartzbach (2006). An Introduction to XML and Web Technologies, chapter Schema Languages,
      pages 92–187. Addison-Wesley, Harlow, England.</textual></bibliomixed><bibliomixed class="po-block e810 e810" xml:id="Murata2001" xreflabel="Murata et al., 2001"><textual class="po-textual">﻿Murata, M., D. Lee, and M.
      Mani (2001). Taxonomy of XML Schema Languages using Formal Language Theory. In Proceedings of
      Extreme Markup Languages, Montréal, Québec.</textual></bibliomixed><bibliomixed class="po-block e811 e811" xml:id="Murata2005" xreflabel="Murata et al., 2005"><textual class="po-textual">﻿Murata, M., D. Lee, M. Mani,
      and K. Kawaguchi (2005). Taxonomy of XML Schema Languages Using Formal Language Theory. ACM
      Transactions on Internet Technology, 5(4):660–704. doi: </textual><biblioid class="po-atom e812 doi e812"><textual class="po-textual">10.1145/1111627.1111631</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e813 e813" xml:id="CLiX" xreflabel="Nentwich, 2005"><textual class="po-textual">Nentwich, C. (2005). CLiX – A
      Validation Rule Language for XML. Presented by Anthony Finkelstein at W3C Workshop on Rule
      Languages for Interoperability, 27-28 April 2005, Washington D.C. </textual><link class="po-inline e814 e814" xlink:actuate="onRequest" xlink:href="http://www.w3.org/2004/12/rules-ws/paper/24/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/2004/12/rules-ws/paper/24/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e815 e815" xml:id="NVDL" xreflabel="NVDL"><textual class="po-textual">ISO/IEC 19757-4:2006. Information technology —
      Document Schema Definition Languages (DSDL) — Part 4: Namespace-based Validation Dispatching
      Language (NVDL), International Standard, International Organization for Standardization,
      Geneva.</textual></bibliomixed><bibliomixed class="po-block e816 e816" xml:id="Odgen1968" xreflabel="Odgen, 1968"><textual class="po-textual">Odgen, W. (1968). A Helpful Result for
      Proving Inherent Ambiguity. In Mathematical Systems Theory, 2(3):191–194. doi: </textual><biblioid class="po-atom e817 doi e817"><textual class="po-textual">10.1007/BF01694004</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e818 e818" xml:id="Pawson2007" xreflabel="Pawson, 2007"><textual class="po-textual">Pawson, D. (2007). ISO Schematron
      tutorial. </textual><link class="po-inline e819 e819" xlink:actuate="onRequest" xlink:href="http://www.dpawson.co.uk/schematron/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.dpawson.co.uk/schematron/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e820 e820" xml:id="Papakonstantinou2000" xreflabel="Papakonstantinou and Vianu, 2000"><textual class="po-textual">Papakonstantinou, Y., and V. Vianu (2000). DTD inference for views of XML data. In PODS ’00:
      Proceedings of the nineteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database
      systems, pages 35–46, New York, NY, USA, ACM. doi: </textual><biblioid class="po-atom e821 doi e821"><textual class="po-textual">10.1145/335168.335173</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e822 e822" xml:id="Piez2001" xreflabel="Piez, 2001"><textual class="po-textual">Piez, W. (2001). Beyond the “descriptive
      vs. procedural” distinction. In Markup Languages – Theory &amp; Practice,
      3(2):141–172. doi: </textual><biblioid class="po-atom e823 doi e823"><textual class="po-textual">10.1162/109966201317356380</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e824 e824" xml:id="RELAXCore" xreflabel="RELAX Core"><textual class="po-textual">ISO/IEC TR 22250-1:2002. Information
      technology – Document description and processing languages – Regular Language Description for
      XML – part 1: RELAX Core. International Standard, International Organization for
      Standardization, Geneva.</textual></bibliomixed><bibliomixed class="po-block e825 e825" xml:id="RELAX" xreflabel="RELAX NG"><textual class="po-textual">ISO/IEC 19757-2:2008. Information technology –
      Document Schema Definition Language (DSDL) – Part 2: Regular-grammar-based validation – RELAX
      NG (ISO/IEC 19757-2). International Standard, International Organization for Standardization,
      Geneva.</textual></bibliomixed><bibliomixed class="po-block e826 e826" xml:id="RELAX2nd" xreflabel="RELAX NG (2nd Ed.)"><textual class="po-textual">ISO/IEC 19757-2:2008. Information
      technology – Document Schema Definition Language (DSDL) – Part 2: Regular-grammar-based
      validation – RELAX NG (ISO/IEC 19757-2). Second Edition. International Standard, International
      Organization for Standardization, Geneva.</textual></bibliomixed><bibliomixed class="po-block e827 e827" xml:id="Rizzi2001" xreflabel="Rizzi, 2001"><textual class="po-textual">Rizzi, R. (2001). Complexity of
      context-free grammars with exceptions and the inadequacy of grammars as models for XML and
      SGML. Markup Languages – Theory &amp; Practice, 3(1):107–116. doi: </textual><biblioid class="po-atom e828 doi e828"><textual class="po-textual">10.1162/109966201753537222</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e829 e829" xml:id="Rogers2003" xreflabel="Rogers, 2003"><textual class="po-textual">Rogers, J. (2003). Syntactic
      Structures as Multi-dimensional Trees. In Research on Language and Computation,
      1(3-4):265–305. doi: </textual><biblioid class="po-atom e830 doi e830"><textual class="po-textual">10.1023/A:1024695608419</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e831 e831" xml:id="Sasaki2010" xreflabel="Sasaki, 2010"><textual class="po-textual">Sasaki, F. (2010). How to avoid
      suffering from markup: A project report about the virtue of hiding xml. In XML Prague 2010
      Conference Proceedings, pages 105–123, Prague, Czech Republic, March 13–14 2010. Institute for
      Theoretical Computer Science.</textual></bibliomixed><bibliomixed class="po-block e832 e832" xml:id="Schematron" xreflabel="Schematron"><textual class="po-textual">ISO/IEC 19757-3:2006 Information
      technology — Document Schema Definition Languages (DSDL) — Part 3: Rule-based validation —
      Schematron. International Standard, International Organization for Standardization,
      Geneva.</textual></bibliomixed><bibliomixed class="po-block e833 e833" xml:id="SGML" xreflabel="SGML"><textual class="po-textual">ISO 8879:1986. Information Processing — Text and
      Office Information Systems — Standard Generalized Markup Language. International Standard,
      International Organization for Standardization, Geneva.</textual></bibliomixed><bibliomixed class="po-block e834 e834" xml:id="Sperberg-McQueen2003" xreflabel="Sperberg-McQueen, 2003"><textual class="po-textual">Sperberg-McQueen,
      C. M. (2003). Logic grammars and XML Schema. In Proceedings of Extreme Markup Languages,
      Montréal, Québec.</textual></bibliomixed><bibliomixed class="po-block e835 e835" xml:id="Sperberg-McQueen2004" xreflabel="Sperberg-McQueen and        Huitfeldt, 2004"><textual class="po-textual">Sperberg-McQueen, C. M. and C.
      Huitfeldt (2004). GODDAG: A Data Structure for Overlapping Hierarchies. In King, P. and E. V.
      Munson, eds. Proceedings of the 5th International Workshop on the Principles of Digital
      Document Processing (PODDP 2000), volume 2023 of Lecture Notes in Computer Science, pages
      139–160. Springer, 2004</textual></bibliomixed><bibliomixed class="po-block e836 e836" xml:id="Stuehrenberg2009" xreflabel="Stührenberg and Jettka, 2009"><textual class="po-textual">Stührenberg, M.
      and D. Jettka (2009). A toolkit for multi-dimensional markup: The development of SGF to
      XStandoff. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup
      Technologies, vol. 3 (2009). Montréal, Québec. doi: </textual><biblioid class="po-atom e837 doi e837"><textual class="po-textual">10.4242/BalisageVol3.Stuhrenberg01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e838 e838" xml:id="Vitali2003" xreflabel="Vitali et al., 2003"><textual class="po-textual">Vitali, F., Amorosi, N., and N.
      Gessa. Datatype- and namespace-aware DTDs: A minimal extension. In Proceedings of Extreme
      Markup Languages, Montré́al, Québec.</textual></bibliomixed><bibliomixed class="po-block e839 e839" xml:id="vanderVlist2001" xreflabel="van der Vlist, 2001"><textual class="po-textual">van der Vlist, E. (2001).
      Comparing XML Schema Languages, 12 December 2001. </textual><link class="po-inline e840 e840" xlink:actuate="onRequest" xlink:href="http://www.xml.com/pub/a/2001/12/12/schemacompare.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xml.com/pub/a/2001/12/12/schemacompare.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e841 e841" xml:id="vanderVlist2003" xreflabel="van der Vlist, 2003"><textual class="po-textual">van der Vlist, E. (2003).
      RELAX NG. O’Reilly, Sebastopol.</textual></bibliomixed><bibliomixed class="po-block e842 e842" xml:id="XML10" xreflabel="XML 1.0"><textual class="po-textual">Extensible Markup Language (XML) 1.0. W3C
      Recommendation, World Wide Web Consortium, 10 February 1998. </textual><link class="po-inline e843 e843" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/1998/REC-xml-19980210" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/1998/REC-xml-19980210</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e844 e844" xml:id="XML" xreflabel="XML 1.0 (Fifth Edition)"><textual class="po-textual">Extensible Markup Language (XML)
      1.0 (Fifth Edition). W3C Recommendation, World Wide Web Consortium, 26 November 2008. </textual><link class="po-inline e845 e845" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/REC-xml-20081126/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2008/REC-xml-20081126/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e846 e846" xml:id="XMLNS" xreflabel="XML Namespaces (Third Edition)"><textual class="po-textual">Namespaces in XML 1.0
      (Third Edition). W3C Recommendation, World Wide Web Consortium, 8 December 2009. </textual><link class="po-inline e847 e847" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2009/REC-xml-names-20091208/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e848 e848" xml:id="XMLSchema2004" xreflabel="XML Schema 1.0 Part 0"><textual class="po-textual">XML Schema Part 0: Primer
      Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October 2004. </textual><link class="po-inline e849 e849" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e850 e850" xml:id="XMLSchema2004a" xreflabel="XML Schema 1.0 Part 1"><textual class="po-textual">XML Schema Part 1:
      Structures Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October 2004.
        </textual><link class="po-inline e851 e851" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e852 e852" xml:id="XMLSchema2004b" xreflabel="XML Schema 1.0 Part 2"><textual class="po-textual">XML Schema Part 2:
      Datatypes Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October 2004.
        </textual><link class="po-inline e853 e853" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e854 e854" xml:id="XMLSchema2009" xreflabel="XML Schema 1.1 Part 1"><textual class="po-textual">W3C XML Schema Definition
      Language (XSD) 1.1 Part 1: Structures. W3C Working Draft, World Wide Web Consortium, 3
      December 2009. </textual><link class="po-inline e855 e855" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e856 e856" xml:id="XMLSchema2009-2" xreflabel="XML Schema 1.1 Part 2"><textual class="po-textual">W3C XML Schema
      Definition Language (XSD) 1.1 Part 2: Datatypes. W3C Working Draft, World Wide Web Consortium,
      3 December 2009. </textual><link class="po-inline e857 e857" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/WD-xmlschema11-2-20091203/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2009/WD-xmlschema11-2-20091203/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e858 e858" xml:id="XSLT2" xreflabel="XSLT 2.0"><textual class="po-textual">XSL Transformations (XSLT) Version 2.0. W3C
      Recommendation, World Wide Web Consortium, 23 January 2007. </textual><link class="po-inline e859 e859" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2007/REC-xslt20-20070123/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2007/REC-xslt20-20070123/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e860 e860" xml:id="XQuery" xreflabel="XQuery 1.0"><textual class="po-textual">XQuery 1.0: An XML Query Language. W3C
      Recommendation, World Wide Web Consortium, 23 January 2007. </textual><link class="po-inline e861 e861" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2007/REC-xquery-20070123/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2007/REC-xquery-20070123/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>