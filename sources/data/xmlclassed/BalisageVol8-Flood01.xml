<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Encoding Transparency: Literate Programming and Test Generation for Scientific Function Libraries</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">We present a variation on literate programming (see Knuth: 1984, 1992) targeting
                multiple simultaneous readerships, both human (e.g., coders, testers, analysts,
                etc.) and compilers/interpreters (e.g., C++, Python, Fortran, etc.). The technique
                exploits existing commenting syntax available in all common programming languages to
                provide inline documentation and other semantic markup, which can then be used in
                test generation and code translation. To keep the problem manageable, we restrict
                attention to scientific function libraries (i.e., libraries of numerical routines
                adhering to the functional programming rule of </textual><quote class="po-inline e8 e8"><textual class="po-textual">no side effects</textual></quote><textual class="po-textual">). We offer a
                prototype implementation in XSLT and DocBook.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Mark</textual></firstname><othername class="po-field e12 e12"><textual class="po-textual">D.</textual></othername><surname class="po-field e13 e13"><textual class="po-textual">Flood</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Mark D. Flood (Mark.Flood@treasury.gov) did his undergraduate work at Indiana
                    University in Bloomington, where he majored in finance (B.S., 1982), and German
                    and economics (B.A., 1983). In 1990, he earned his Ph.D. in finance from the
                    Graduate School of Business at the University of North Carolina at Chapel Hill.
                    He has taught finance and business at universities in the U.S. and Canada, and
                    worked as an Economist and Financial Economist on issues of regulatory policy
                    and risk management at the Federal Reserve Bank of St. Louis, the Office of
                    Thrift Supervision, the Federal Housing Finance Board, and the Federal Housing
                    Finance Agency. He was a founding member of the Committee to Establish a
                    National Institute of Finance. He is currently a Senior Policy Advisor in the
                    U.S. Treasury, working for the Office of Financial Research. His research has
                    appeared in a number of journals, including the Review of Financial Studies,
                    Quantitative Finance, the Journal of International Money and Finance, and the
                    St. Louis Fed's Review.</textual></para></personblurb><affiliation class="po-record e16 e16"><jobtitle class="po-field e17 e17"><textual class="po-textual">Senior Policy Advior</textual></jobtitle><orgname class="po-block e18 e18"><textual class="po-textual">Office of Financial Research</textual></orgname></affiliation><email class="po-field e19 e19"><textual class="po-textual">mark.flood@treasury.gov</textual></email></author><author class="po-record e20 e20"><personname class="po-record e21 e21"><firstname class="po-field e22 e22"><textual class="po-textual">Matthew</textual></firstname><surname class="po-field e23 e23"><textual class="po-textual">McCormick</textual></surname></personname><personblurb class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">Matthew McCormick is a research economist whose work currently focuses on
                    systemic risk, network externalities, and housing finance. He is currently
                    employed at the Office of Financial Research within the U.S. Department of
                    Treasury. Prior to this, he worked as an economist at the Federal Housing
                    Finance Agency and the Bureau of Economic Analysis. He holds an M.A. in
                    Economics from George Mason University and a B.A. in Economics and Political
                    Science from Northwestern University. </textual></para></personblurb><affiliation class="po-record e26 e26"><jobtitle class="po-field e27 e27"><textual class="po-textual">Researcher</textual></jobtitle><orgname class="po-block e28 e28"><textual class="po-textual">Office of Financial Research</textual></orgname></affiliation><email class="po-field e29 e29"><textual class="po-textual">matthew.mccormick@treasury.gov</textual></email></author><author class="po-record e30 e30"><personname class="po-record e31 e31"><firstname class="po-field e32 e32"><textual class="po-textual">Nathan</textual></firstname><surname class="po-field e33 e33"><textual class="po-textual">Palmer</textual></surname></personname><personblurb class="po-container e34 e34"><para class="po-block e35 e35"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e36 e36"><jobtitle class="po-field e37 e37"><textual class="po-textual">Researcher</textual></jobtitle><orgname class="po-block e38 e38"><textual class="po-textual">Office of Financial Research</textual></orgname></affiliation><email class="po-field e39 e39"><textual class="po-textual">nathan.palmer@treasury.gov</textual></email></author><legalnotice class="po-container e40 e40"><para class="po-block e41 e41"><textual class="po-textual">This is a work of the United States Government and is in the public domain.</textual></para></legalnotice><keywordset class="po-table e42 e42" role="author"><keyword class="po-field e43 e43"><textual class="po-textual">literate programming</textual></keyword><keyword class="po-field e44 e44"><textual class="po-textual">XSLT</textual></keyword><keyword class="po-field e45 e45"><textual class="po-textual">unit testing</textual></keyword></keywordset></info><section class="po-hcontainer e46 e46"><title class="po-block e47 e47"><textual class="po-textual">Introduction</textual></title><para class="po-block e48 e48"><textual class="po-textual">We outline a (nearly) language-neutral approach to embedding in ordinary source code
            semantic information that we use to generate documentation for multiple audiences, unit
            tests, and code translation templates. Our approach is within the literate programming
            tradition for enhancing the usability of software documentation, specifically the
            variants that focus on inline documentation. Accordingly, we embed the structured
            documentation within the ordinary comment syntax available in all common programming
            languages.</textual><footnote class="po-popup e49 e49" xml:id="fnote000"><para class="po-block e50 e50"><textual class="po-textual">Our approach to the embedding of semantic information in source also has
                    parallels to McGrath’s (2005) concept of “Semantic Steganography.”</textual></para></footnote></para><para class="po-block e51 e51"><textual class="po-textual">Knuth (1984, 1992) introduced literate programming to negotiate the fundamental
            tension between the needs of two readerships for computer programs: humans and
            compilers. Knuth’s original recommendation and most implementations work from a hybrid
            literate document containing the information needed to generate both machine-readable
            code and human-readable documentation.</textual><footnote class="po-popup e52 e52" xml:id="fnote001"><para class="po-block e53 e53"><textual class="po-textual">Beebe (2012) provides a very useful bibliography of literate programming.
                    Pieterse, Kourie, and Boake (2004) survey a number of literate implementations,
                    identifying six essential qualities of literate programming, all emphasizing the
                    needs of the human user:</textual><itemizedlist class="po-table e54 e54"><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">Literate quality (crisp and artistic descriptions and
                                definitions)</textual></para></listitem><listitem class="po-container e57 e57"><para class="po-block e58 e58"><textual class="po-textual">Psychological order (arranged to maximize human
                                understanding)</textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Integrated documentation (commingling of documentation and
                                executable statements)</textual></para></listitem><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">Table of contents, index and cross references</textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">Pretty printing</textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">Verisimilitude (single source document for both documentation and
                                executable statements)</textual></para></listitem></itemizedlist><textual class="po-textual">
                </textual></para></footnote><textual class="po-textual">For example, Knuth’s (1984) first implementation, called WEB, provided two
            toolchains to export information from the literate source file: (a) TANGLE extracted
            executable source code for delivery to a Pascal compiler; and (b) WEAVE extracted
            documentation for delivery to a TeX interpreter.</textual></para><para class="po-block e67 e67"><textual class="po-textual">Despite its impeccable pedigree and a devoted community of supporters, literate
            programming as originally envisioned has not gained widespread acceptance. Wilson (2011)
            even calls it a </textual><quote class="po-inline e68 e68"><textual class="po-textual">beautiful idea that failed.</textual></quote><textual class="po-textual"> The </textual><quote class="po-inline e69 e69"><textual class="po-textual">psychological
                order</textual></quote><textual class="po-textual"> requirement that literate source documents be arranged to best serve
            the human reader implicitly places a heavy burden on the programmer, whose human-facing
            literate document must simultaneously satisfy an error-intolerant compiler. The
            programmer must have fluency in both the literate syntax and the compiler syntax. Even
            for coders with both skills, there is a cognitive cost to switching repeatedly between
            the two commingled dialects-- one unwoven and the other untangled. As a result, the
            original literate programming paradigm is perhaps best suited to applications where the
            emphasis is inverted: pretty printing is indispensable and the code itself is in a sense
            secondary, as in Leisch’s (2002) Sweave, which allows statistical code to be embedded in
            scientific source documents to enable reproducible research.</textual></para><para class="po-block e70 e70"><textual class="po-textual"> On the other hand, less </textual><quote class="po-inline e71 e71"><textual class="po-textual">orthodox</textual></quote><textual class="po-textual"> technologies in the literate tradition (i.e.,
            combining executable source code with structured documentation) have been quite
            successful. Javadoc and its generalized peer Doxygen, which rely on structured comments
            embedded in source code to generate documentation, are among the most prominent
            examples. Similarly, tools like Python’s pydoc generate documentation from docstrings,
            string literals that are retained and accessible at runtime as special properties of
            objects. Under both approaches, the comparison to orthodox literate programming is
            instructive: structured documentation is still embedded with executable source code, but
            the requirement of psychological ordering is dropped. The compiler, by being stubbornly
            inflexible, has won the battle over how to order the statements in the source
            file.</textual></para><para class="po-block e72 e72"><textual class="po-textual">Orthogonal to the literate programming paradigm, but still important for our project,
            is the realization by Peters (1999) that the usefulness of docstrings for documentation
            purposes could be harnessed to provide users with a simple, inline method for generating
            unit tests. This realization led to his creation of doctest.</textual></para><para class="po-block e73 e73"><textual class="po-textual">Our approach, outlined in the following sections, follows in the tradition of
            Javadoc-style inline documentation, but we use XML intermediates with XSLT not only to
            allow for the generation of documentation for multiple audiences, but additionally to
            define and generate unit tests, as in doctest, and to generate templates for code
            translation. Section 2 provides further context for our project, section 3 describes the
            targeted use cases, and section 4 concludes.</textual></para></section><section class="po-hcontainer e74 e74"><title class="po-block e75 e75"><textual class="po-textual">Context and objectives</textual></title><para class="po-block e76 e76"><textual class="po-textual">Function libraries play a prominent role in scientific computing.</textual><footnote class="po-popup e77 e77" xml:id="fnote002"><para class="po-block e78 e78"><textual class="po-textual">Examples are too numerous to survey here. Prominent contributions include
                    Anderson, et al. (1999), CERN (2004), NAG (2009), and Press, et al.
                    (2007).</textual></para></footnote><textual class="po-textual">A function library is a collection of well documented, callable
            routines of the form y = f(x), where each function takes some argument list, x, executes
            one or more statements depending only on x, and returns a list of values, y. Scientific
            functions tend to involve specialized, technical logic that can be obscure to
            non-experts. As a result, there is a greater-than-usual need for good documentation and
            extensive testing. At the same time, scientific routines typically adhere to the
            functional-programming convention of exhibiting no side effects. Routines without side
            effects are especially amenable to unit testing, and we restrict attention to this class
            of functions to contain the scope of this exercise. Lastly, scientific libraries are more
            likely than most to address technical issues that are abstract to the implementation
            context. For example, an invocation of a quadratic programming routine will have
            essentially the same meaning (execution logic) regardless of the language in which it is
            written; the same is not true for a resize_frame routine in a GUI windowing toolkit.
            Because of this, scientific routines are more amenable to porting from one programming
            language to another.</textual></para><para class="po-block e79 e79"><textual class="po-textual">Our technique is at once more and less ambitious than orthodox literate programming. We
            similarly target multiple simultaneous readerships, both human (e.g., coders, testers,
            analysts, etc.) and compilers/interpreters (e.g., C++, Python, Fortran, etc.). However,
            like Javadoc, and in keeping with Dijkstra’s (1972) admonition that, </textual><quote class="po-inline e80 e80"><textual class="po-textual">brainpower
                is by far our scarcest resource,</textual></quote><textual class="po-textual"> we concede the impracticality of
            psychological ordering. In particular, there is no </textual><quote class="po-inline e81 e81"><textual class="po-textual">tangling</textual></quote><textual class="po-textual"> to extract
            executable statements; instead we work with valid source files that can be delivered to
            the compiler as is. We also hesitate to propose our method as broadly applicable to any
            programming paradigm. For example, our source-code portability proposal would likely be
            more complicated in an object-oriented environment, due to the possible presence of
            state-altering side effects and the (typically) fragmented sequence of control. </textual></para><para class="po-block e82 e82"><textual class="po-textual">Since we use a form of inline documentation that, like Javadoc and others, exploits
            the existing commenting syntax available in some form in all common programming
            dialects, ours is highly versatile with respect to the choice of source language, to the
            point of being nearly language-neutral. This provides significant benefits when
            developing parallel implementations of scientific function libraries in a number of
            languages.</textual></para><para class="po-block e83 e83"><textual class="po-textual">On the ambitious side of the ledger, we are interested in more than simply
                </textual><quote class="po-inline e84 e84"><textual class="po-textual">weaving</textual></quote><textual class="po-textual"> handsome end-user documentation from embedded, structured
            documentation, although pretty printing is very much in scope. We also extend the basic
            methodology to encompass basic unit testing of functional logic. In the absence of side
            effects, it becomes straightforward to state the most common unit-test assertions
            declaratively and embed these declarations within comments in the source code. Due to
            the desire to be language-neutral, ours is not as straightforward or elegant as doctest,
            but it does provide many of the same benefits. Lastly, we use the template processor
            required by our documentation generation toolchain to offer a method for creating
            function prototypes-- including pseudocode-- for ports of an existing program to
            essentially an arbitrary target programming language. </textual></para><para class="po-block e85 e85"><textual class="po-textual">While none of the individual components of this approach is by itself novel, we find
            that at least within the restricted scope of scientific function libraries without side
            effects, significant benefits are provided by the flexibility of our approach and the
            synergistic effects of using all of the individual elements of inline
            documentation, unit test generation, and code translation in concert.</textual></para><para class="po-block e86 e86"><textual class="po-textual">Specifically, we note that the problem of code translation consists of three
            sub-problems: ensuring that the logic of a particular function is consistent across
            languages, performing the syntactic translation between languages, and optimizing the
            implementation within each language. Of these, the implementation is where a good
            programmer is needed most, both to write code that makes use of the appropriate idioms
            provided by a language, and to optimize the implementation of a particular set of logic.
            Thus, by providing a programmer with a template for a function that both defines the
            function signature and provides ready-made documentation from another language, we
            reduce unnecessary burdens on programmers porting the original source code. Additionally, by
            providing unit test routines, we enable easier verification of ported code. Finally, by
            examining discrepancies between implementations, we reduce the model risk inherent in
            any single implementation.</textual></para><para class="po-block e87 e87"><textual class="po-textual">We consider our approach to be a simplified variation of the literate programming
            paradigm, targeting multiple simultaneous readerships, both human (e.g., coders,
            testers, analysts, etc.) and compilers/interpreters (e.g., C++, Python, Fortran, etc.).
            We offer a prototype implementation in XSLT and DocBook.</textual></para></section><section class="po-hcontainer e88 e88"><title class="po-block e89 e89"><textual class="po-textual">Usage scenarios</textual></title><para class="po-block e90 e90"><textual class="po-textual">In this section, we describe the process in somewhat greater detail. As indicated
            above, the techniques cover three important usage scenarios for managing source code in
            function libraries.</textual></para><section class="po-hcontainer e91 e91"><title class="po-block e92 e92"><textual class="po-textual">End-user documentation</textual></title><para class="po-block e93 e93"><textual class="po-textual">Knuth’s (1984, 1992) original vision for literate programming emphasized the need
                for source code to communicate with human programmers as well as with compilers or
                interpreters. A well documented program should speak clearly to the coder about what
                the code is doing, and the programmer should speak back by enhancing and refining
                the documentation. Knuth quotes a well known passage from Hoare (1973, 3), </textual></para><para class="po-block e94 e94"><quote class="po-inline e95 e95"><textual class="po-textual">documentation must be regarded as an integral part of the process of design
                    and coding. A good programming language will encourage and assist the programmer
                    to write clear self-documenting code, and even perhaps to develop and display a
                    pleasant style of writing. The readability of programs is immeasurably more
                    important than their writeablility.</textual></quote></para><para class="po-block e96 e96"><textual class="po-textual">Knuth’s (1984) initial implementation, called WEB, mixed discussion and logic in a
                single source file, which is then pulled apart to create both executable code and
                typographic source for onward processing by Pascal and TeX, respectively. Figure 1
                depicts the basic structure of the workflow in WEB (adapted from Figure 1 in
                Pieterse, Kourie and Boake, 2004, 113):</textual></para><figure class="po-container e97 e97" xml:id="FIG001" xreflabel="Figure 1"><title class="po-block e98 e98"><textual class="po-textual">Figure 1</textual></title><mediaobject class="po-container e99 e99"><imageobject class="po-container e100 e100"><imagedata class="po-meta e101 e101" fileref="../../../vol8/graphics/Flood01/Flood01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e102 e102"><para class="po-block e103 e103"><textual class="po-textual">Literate programming workflow in WEB</textual></para></caption></figure><para class="po-block e104 e104"><textual class="po-textual">A key design decision here is to mix documentation and logic as co-equals in the
                source. Because the source document adheres to psychological ordering rather than
                executable ordering, a burden falls on the programmer to </textual><quote class="po-inline e105 e105"><textual class="po-textual">think
                    bilingually</textual></quote><textual class="po-textual"> (see Wilson, 2011) to understand how the source document
                will be simultaneously tangled and woven to the executable and typographic
                dialects.</textual></para><para class="po-block e106 e106"><textual class="po-textual">We adopt a variation on this basic workflow, similarly mixing documentation and
                logic in a single source file, depicted in Figure 2 (a familiar example of this same
                workflow is Javadoc):</textual></para><figure class="po-container e107 e107" xml:id="FIG002" xreflabel="Figure 2"><title class="po-block e108 e108"><textual class="po-textual">Figure 2</textual></title><mediaobject class="po-container e109 e109"><imageobject class="po-container e110 e110"><imagedata class="po-meta e111 e111" fileref="../../../vol8/graphics/Flood01/Flood01-002.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">Documentation and logic in Javadoc</textual></para></caption></figure><para class="po-block e114 e114"><textual class="po-textual">An important difference in this architecture relative to orthodox literate
                programming is the use of a compiler-valid source document. Because compilers impose
                rigid validation rules on executable code, this relationship can be and is typically
                managed by programming IDEs with facilities such as real-time validation, syntax
                highlighting, debuggers, profilers, etc., sharply reducing the bilingual
                burden.</textual></para><para class="po-block e115 e115"><textual class="po-textual">As described above, we embed documentation steganographically in the ordinary
                comment lines within the source code. A sample appears in Figure 3, using standard
                XML angle brackets as documentation markup within a Matlab or Octave source file.
                Comments containing content intended for delivery to the final end-user documents
                get a special syntax, </textual><quote class="po-inline e116 e116"><textual class="po-textual">%#</textual></quote><textual class="po-textual"> instead of simply </textual><quote class="po-inline e117 e117"><textual class="po-textual">%</textual></quote><textual class="po-textual">. Given a
                source document in this form, the comment processor performs four straightforward
                pre-processing steps, resulting in valid XML that encapsulates all of the content
                required for end-user documentation:</textual><orderedlist class="po-table e118 e118"><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">Wrap any executable statements in &lt;code&gt; tags</textual></para></listitem><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">Delete ordinary comment lines</textual></para></listitem><listitem class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">Convert documentation comments by removing the leading
                                </textual><quote class="po-inline e125 e125"><textual class="po-textual">%#</textual></quote><textual class="po-textual"> markers</textual></para></listitem><listitem class="po-container e126 e126"><para class="po-block e127 e127"><textual class="po-textual">Wrap the entire document in &lt;codefile&gt; tags</textual></para></listitem></orderedlist></para><figure class="po-container e128 e128" xml:id="FIG003" xreflabel="Figure 3"><title class="po-block e129 e129"><textual class="po-textual">Figure 3</textual></title><mediaobject class="po-container e130 e130"><imageobject class="po-container e131 e131"><imagedata class="po-meta e132 e132" fileref="../../../vol8/graphics/Flood01/Flood01-003.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e133 e133"><para class="po-block e134 e134"><textual class="po-textual">A working example of steganographic documentation</textual></para></caption></figure><para class="po-block e135 e135"><textual class="po-textual">An obvious (and planned) enhancement to this is to replace the angle brackets with
                a more felicitous markup scheme, such as Markdown, Textile or YAML.</textual><footnote class="po-popup e136 e136" xml:id="fnote003"><para class="po-block e137 e137"><textual class="po-textual">We are at a very preliminary prototyping stage currently, and are
                        evaluating various markup options. On Textile, see Allen (2012); on YAML,
                        see Ben-Kiki, Evans and Net (2009); on Markdown, see Gruber (2012). Use of a
                        non-XML syntax would an extra up-conversion step to achieve valid XML output
                        from the pre-processor.</textual></para></footnote><textual class="po-textual"> Note that we have prototyped this process on Matlab/Octave source files,
                but it should work with any programming language that supports inline comments
                containing arbitrary text. The pre-processing routine is therefore customized to
                each source language, but the subsequent processing steps would be the same for any
                source language. Given a valid XML representation output by the preprocessing step,
                the next processing phase is an XSLT transformation to a standard publication format
                such as DocBook or DITA. Transformation from this intermediate form to final print
                or web format is then straightforward via standard tools.</textual><footnote class="po-popup e138 e138" xml:id="fnote004"><para class="po-block e139 e139"><textual class="po-textual">Our prototype relies on DocBook, but we are evaluating DITA as an
                        alternative path. Supporting XSLT stylesheets for both (and/or additional)
                        publication standards should be possible. For further details on DocBook,
                        see Walsh (2010) and Stayton (2007); for further details on DITA see OASIS
                        (2010).</textual></para></footnote><textual class="po-textual">
            </textual></para></section><section class="po-hcontainer e140 e140"><title class="po-block e141 e141"><textual class="po-textual">Unit testing</textual></title><para class="po-block e142 e142"><textual class="po-textual">Section 3.1 outlines the basic process, which we also propose to extend to
                black-box unit testing. In this use-case, we embed structured unit-testing rules
                (rather than documentation content) within comments in the source code. There are
                precedents for this sort of inline testing (e.g., the aforementioned doctest package
                in Python), but to our knowledge these are limited to single-language contexts.
                There are also language-neutral domain-specific rule languages for unit testing
                (e.g., the TestML package; see Net, 2012), but these have not been used for inline
                tests. We propose to use a language-neutral rule syntax to specify unit tests
                declaratively, and then embed them in source-code comments. </textual></para><para class="po-block e143 e143"><textual class="po-textual">Programmatic unit testing is particularly important for scientific function
                libraries, partly because a well defined functional API will try to isolate logic so
                that relatively few dependencies exist between routines at the API level, but also
                because scientific routines frequently involve subtle and highly technical execution
                logic, so that errors in output may not be immediately obvious to human observers.
                (For example, do you know offhand whether this square-root calculation is correct:
                sqrt(88) =&gt; 9.276442 ?) Note that the steganographic method could also be
                extended to white-box testing, if the code generates a structured log file
                containing intermediate results.</textual></para></section><section class="po-hcontainer e144 e144"><title class="po-block e145 e145"><textual class="po-textual">Source code portability</textual></title><para class="po-block e146 e146"><textual class="po-textual">Scientific function libraries are frequently written in one programming language,
                and then ported to another language to support source-level compatibility. As noted
                above, this is more likely to occur for scientific code, because the concepts
                represented are typically unrelated to the programming dialect. Linear algebra is
                the same, whether implemented in C, Fortran or Java. Indeed, Feldman (1990) exploits
                the grammatical equivalence between Fortran 77 and C to implement a direct
                language-level converter. </textual><footnote class="po-popup e147 e147" xml:id="fnote005"><para class="po-block e148 e148"><textual class="po-textual">To a first approximation, Fortran 77 is a linguistic subset of C. Any
                        statement that can be represented in Fortran 77 can be represented in
                        C.</textual></para></footnote><textual class="po-textual"> This converter was then used to port the Numerical Recipes function
                library in that direction (see Press, et al., 2007).</textual></para><para class="po-block e149 e149"><textual class="po-textual">In general, grammatical equivalence will not hold, and programmatic language-level
                conversion cannot reasonably be achieved. Even where it is possible, there are
                typically optimizations and refactorings that an expert in the target language would
                want to apply. The upshot is that post-translation manual intervention to debug or
                refine the target code should naturally be part of the process. Nonetheless, for any
                function library written in a particular language, there will be some family of
                alternative languages to which it could (in principle) be ported.</textual><footnote class="po-popup e150 e150" xml:id="fnote006"><para class="po-block e151 e151"><textual class="po-textual">For example, at the extreme, it is theoretically possible to represent any
                        program written in a Turing-complete language in any other Turing-complete
                        language. In practice, we do not advise arbitrary translation.</textual></para></footnote><textual class="po-textual"> This family of languages then defines an equivalence class of </textual><quote class="po-inline e152 e152"><textual class="po-textual">mutual
                pseudocode</textual></quote><textual class="po-textual"> for the routine or library. That is, if one starts with a working
                program written language A, and wishes-- with the services of an expert in language
                B-- to port the code, then the original program (in A) can serve as pseudocode for
                the target program (in B). Most developers have personal experience with applying
                this general process, so we are not inventing anything new here. The only real
                innovation is the recognition that much of the programming effort required for such
                a port-- namely the documentation and testing-- can be specified declaratively and
                in a structured way, as described in sections 3.1 and 3.2. An accurate programmatic
                conversion of the documentation and test plan is possible, using the sort of XSLT
                transformations described above. What remains is for a target-language expert to
                re-implement the pseudocode (i.e., the verbatim copies of source-language executable
                statements) as optimized target-language code. Note finally that the
                post-translation availability of dual implementations of the identical scientific
                logic opens up the possibility of automated comparative unit testing: if both
                implementations are supposed to do the same thing, then they should (typically,
                within machine precision) return identical outputs for identical inputs.</textual></para></section></section><section class="po-hcontainer e153 e153"><title class="po-block e154 e154"><textual class="po-textual">Conclusions</textual></title><para class="po-block e155 e155"><textual class="po-textual">We have outlined a general approach to automated documentation, unit-testing and code
            portability for scientific function libraries, using the ordinary comment syntax as a
            vehicle to embed declarative logic steganographically in the source code. This addresses
            immediate and practical needs in our workplace, and may be useful to others similarly
            situated. We have a working prototype of significant portions of this tool chain, and
            are working to build it out further.</textual></para></section><bibliography class="po-hcontainer e156 e156"><title class="po-block e157 e157"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e158 e158" xml:id="Allen2012" xreflabel="Allen (2012)"><textual class="po-textual">Allen, Dean, 2012, </textual><quote class="po-inline e159 e159"><textual class="po-textual">Textile:
                A Humane Web Text Generator,</textual></quote><textual class="po-textual"> Internet resource, Textism, downloaded 15 April
            2012. </textual><link class="po-inline e160 e160" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.textism.com/tools/textile/</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e161 e161" xml:id="AndersonETAL1999" xreflabel="Anderson, et al. (1999)"><textual class="po-textual">Anderson, E., Z.
            Bai, C. Bischof, S. Blackford, J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S.
            Hammarling, A. McKenney, D. Sorensen, 1999, </textual><emphasis class="po-inline e162 e162"><textual class="po-textual">LAPACK Users' Guide, Third
                Edition</textual></emphasis><textual class="po-textual">, Society for Industrial and Applied Mathematics (SIAM).
                </textual><link class="po-inline e163 e163" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.netlib.org/lapack/lug/</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e164 e164" xml:id="Beebe2012" xreflabel="Beebe (2012)"><textual class="po-textual">Beebe, Nelson, 2012, </textual><quote class="po-inline e165 e165"><textual class="po-textual">A
                Bibliography of Literate Programming,</textual></quote><textual class="po-textual"> technical report, University of Utah.
                </textual><link class="po-inline e166 e166" xlink:actuate="onRequest" xlink:href="ftp://ftp.math.utah.edu/pub/tex/bib/litprog.ps.gz" xlink:show="new" xlink:type="simple"><textual class="po-textual">ftp://ftp.math.utah.edu/pub/tex/bib/litprog.ps.gz</textual></link></bibliomixed><bibliomixed class="po-block e167 e167" xml:id="BenKikiEvansNet2009" xreflabel="Ben-Kiki, Evans and Net (2009)"><textual class="po-textual">Ben-Kiki, Oren, Clark Evans and Ingy döt Net, 2009, </textual><quote class="po-inline e168 e168"><textual class="po-textual">YAML Ain’t Markup Language
                (YAMLTM), Version 1.2, 3rd Edition, Patched at 2009-10-01,</textual></quote><textual class="po-textual"> technical report,
            YAML.org, downloaded 18 April 2012. </textual><link class="po-inline e169 e169" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://yaml.org/spec/1.2/spec.pdf</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e170 e170" xml:id="CERN2004" xreflabel="CERN (2004)"><textual class="po-textual">CERN - European Organization for
            Nuclear Research, 2004, </textual><quote class="po-inline e171 e171"><textual class="po-textual">Colt: Open Source Libraries for High Performance
                Scientific and Technical Computing in Java,</textual></quote><textual class="po-textual"> Internet resource, downloaded 17
            April 2012. </textual><link class="po-inline e172 e172" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://acs.lbl.gov/software/colt/api/index.html</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e173 e173" xml:id="Dijkstra1972" xreflabel="Dijkstra (1972)"><textual class="po-textual">Dijkstra, E. W., 1972,
                </textual><quote class="po-inline e174 e174"><textual class="po-textual">The Humble Programmer [ACM Turing Lecture 1972],</textual></quote><textual class="po-textual">
            </textual><emphasis class="po-inline e175 e175"><textual class="po-textual">Communications of the ACM</textual></emphasis><textual class="po-textual">, 15(10), pp. 859-66.
          </textual><link class="po-inline e176 e176" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html</textual></link><textual class="po-textual">. doi:</textual><biblioid class="po-atom e177 doi e177"><textual class="po-textual">10.1145/355604.361591</textual></biblioid><textual class="po-textual">.
        </textual></bibliomixed><bibliomixed class="po-block e178 e178" xml:id="Feldman1990" xreflabel="Feldman (1990)"><textual class="po-textual">Feldman, S. I., 1990, </textual><quote class="po-inline e179 e179"><textual class="po-textual">A
                Fortran to C Converter,</textual></quote><textual class="po-textual">
            </textual><emphasis class="po-inline e180 e180"><textual class="po-textual">ACM SIGPLAN Fortran Forum</textual></emphasis><textual class="po-textual">, 9(2), 21-22.
                </textual><link class="po-inline e181 e181" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dl.acm.org/citation.cfm?id=101366%C3%DC</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e182 e182" xml:id="Gruber2012" xreflabel="Gruber (2012)"><textual class="po-textual">Gruber, John, 2012,
                </textual><quote class="po-inline e183 e183"><textual class="po-textual">Markdown,</textual></quote><textual class="po-textual"> Internet resource, Daring Fireball, downloaded 15 April
            2012. </textual><link class="po-inline e184 e184" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://daringfireball.net/projects/markdown/</textual></link></bibliomixed><bibliomixed class="po-block e185 e185" xml:id="Hellmann2011" xreflabel="Hellmann (2011)"><textual class="po-textual">Hellmann, Doug, 2011,
                </textual><emphasis class="po-inline e186 e186"><textual class="po-textual">The Python Standard Library by Example</textual></emphasis><textual class="po-textual">,
            Addison-Wesley.</textual></bibliomixed><bibliomixed class="po-block e187 e187" xml:id="Hoare1973" xreflabel="Hoare (1973)"><textual class="po-textual">Hoare, C. A. R., 1973, </textual><quote class="po-inline e188 e188"><textual class="po-textual">Hints
                on Programming Language Design,</textual></quote><textual class="po-textual"> technical report STAN-CS-73-403, Stanford
            Artificial Intelligence Laboratory, December.
                </textual><link class="po-inline e189 e189" xlink:actuate="onRequest" xlink:href="ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/73/403/CS-TR-73-403.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/73/403/CS-TR-73-403.pdf</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e190 e190" xml:id="Knuth1984" xreflabel="Knuth (1984)"><textual class="po-textual">Knuth, Donald E., 1984,
                </textual><quote class="po-inline e191 e191"><textual class="po-textual">Literate Programming,</textual></quote><textual class="po-textual">
          </textual><emphasis class="po-inline e192 e192"><textual class="po-textual">The Computer Journal</textual></emphasis><textual class="po-textual">, 27(2), 97-111. doi:</textual><biblioid class="po-atom e193 doi e193"><textual class="po-textual">10.1093/comjnl/27.2.97</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e194 e194" xml:id="Knuth1992" xreflabel="Knuth (1992)"><textual class="po-textual">Knuth, Donald E., 1992,
                </textual><emphasis class="po-inline e195 e195"><textual class="po-textual">Literate Programming</textual></emphasis><textual class="po-textual">, Center for the Study of Language and
            Information - Lecture Notes.</textual></bibliomixed><bibliomixed class="po-block e196 e196" xml:id="Leisch2002" xreflabel="Leisch (2002)"><textual class="po-textual">Leisch, Freidrich, 2002,
            </textual><quote class="po-inline e197 e197"><textual class="po-textual">Sweave: Dynamic generation of statistical reports using literate data
                analysis,</textual></quote><textual class="po-textual"> Compstat 2002 - Proceedings in Computational Statistics,
            575-580.
        </textual></bibliomixed><bibliomixed class="po-block e198 e198" xml:id="McGrath2005" xreflabel="McGrath (2005)"><textual class="po-textual">McGrath, Sean,
                2005, </textual><quote class="po-inline e199 e199"><textual class="po-textual">Semantic Steganography,</textual></quote><textual class="po-textual"> Internet resource, accessed July 17,
            2012. </textual><link class="po-inline e200 e200" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://seanmcgrath.blogspot.com/2005/04/semantic-steganography.html</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e201 e201" xml:id="Net2012" xreflabel="Net (2012)"><textual class="po-textual">Net, Ingy dot, 2012, </textual><quote class="po-inline e202 e202"><textual class="po-textual">TestML User
                Manual,</textual></quote><textual class="po-textual"> Internet resource, downloaded 18 April 2012.
                </textual><link class="po-inline e203 e203" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://testml.org/documentation/user-manual/</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e204 e204" xml:id="NAG2009" xreflabel="NAG (2009)"><textual class="po-textual">Numerical Algorithms Group Limited
            (NAG), 2009, </textual><quote class="po-inline e205 e205"><textual class="po-textual">NAG Library Manual, Mark 22,</textual></quote><textual class="po-textual"> Internet resource, downloaded
            17 April 2012.
                </textual><link class="po-inline e206 e206" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.nag.co.uk/numeric/fl/nagdoc_fl22/xhtml/FRONTMATTER/manconts.xml</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e207 e207" xml:id="OASIS2010" xreflabel="OASIS (2010)"><textual class="po-textual">OASIS, 2010, </textual><emphasis class="po-inline e208 e208"><textual class="po-textual">Darwin
                Information Typing Architecture (DITA), Version 1.2</textual></emphasis><textual class="po-textual">, OASIS Standard, 1
            December 2010, downloaded 18 April 2012.
                </textual><link class="po-inline e209 e209" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oasis-open.org/dita/v1.2/os/spec/DITA1.2-spec.pdf</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e210 e210" xml:id="Peters1999" xreflabel="Peters (1999)"><textual class="po-textual">Peters, Time, 1999,
                </textual><quote class="po-inline e211 e211"><textual class="po-textual">docstring-driven-testing,</textual></quote><textual class="po-textual"> comp.lang.python, accessed June 12,
            2012. </textual><link class="po-inline e212 e212" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://groups.google.com/forum/?fromgroups#!msg/comp.lang.python/DfzH5Nrt05E/Yyd3s7fPVxwJ</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e213 e213" xml:id="PieterseETAL2004" xreflabel="Pieterse, et al., (2004)"><textual class="po-textual">Pieterse, Vreda,
            Derrick G. Kourie, and Andrew Boake, 2004, </textual><quote class="po-inline e214 e214"><textual class="po-textual">A Case for Contemporary Literate
                Programming,</textual></quote><textual class="po-textual">
            </textual><emphasis class="po-inline e215 e215"><textual class="po-textual">Proceedings of SAICSIT</textual></emphasis><textual class="po-textual"> ’04, 2-9.
                </textual><link class="po-inline e216 e216" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://espresso.cs.up.ac.za/publications/vpieterse_etal_saicsit.pdf</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e217 e217" xml:id="PressETAL2007" xreflabel="Press, et al. (2007)"><textual class="po-textual">Press, William H., Saul
            A. Teukolsky, William T. Vetterling, and Brian P. Flannery, 2007, </textual><emphasis class="po-inline e218 e218"><textual class="po-textual">Numerical
                Recipes: The Art of Scientific Computing, 3rd Ed.</textual></emphasis><textual class="po-textual">, Cambridge University
            Press. </textual><link class="po-inline e219 e219" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.nr.com/</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e220 e220" xml:id="SchulteETAL2012" xreflabel="Schulte, et al., (2012)"><textual class="po-textual">Schulte, Eric, Dan
            Davison, Thomas Dye, and Carsten Dominik, 2012, </textual><quote class="po-inline e221 e221"><textual class="po-textual">A Multi-Language Computing
                Environment for Literate Programming and Reproducible Research,</textual></quote><textual class="po-textual">
            </textual><emphasis class="po-inline e222 e222"><textual class="po-textual">Journal of Statistical Software</textual></emphasis><textual class="po-textual">, 46(3), January.
                </textual><link class="po-inline e223 e223" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.jstatsoft.org/v46/i03/paper</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e224 e224" xml:id="SciPy2012" xreflabel="SciPy (2012)"><textual class="po-textual">SciPy Community, 2012, </textual><quote class="po-inline e225 e225"><textual class="po-textual">SciPy
                Reference Guide: Release 0.11.0.dev-bdfdc65,</textual></quote><textual class="po-textual"> technical report, downloaded 16
            April 2012. </textual><link class="po-inline e226 e226" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.scipy.org/doc/scipy/scipy-ref.pdf</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e227 e227" xml:id="Stayton2007" xreflabel="Stayton (2007)"><textual class="po-textual">Stayton, Bob, 2007,
                </textual><emphasis class="po-inline e228 e228"><textual class="po-textual">DocBook XSL: The Complete Guide (4th Edition)</textual></emphasis><textual class="po-textual">, Sagehill
            Enterprises. </textual><link class="po-inline e229 e229" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.sagehill.net/book-description.html</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e230 e230" xml:id="Walsh2010" xreflabel="Walsh (2010)"><textual class="po-textual">Walsh, Norman, 2010,
                </textual><emphasis class="po-inline e231 e231"><textual class="po-textual">DocBook 5: The Definitive Guide</textual></emphasis><textual class="po-textual">, O’Reilly Media.
                </textual><link class="po-inline e232 e232" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://shop.oreilly.com/product/9780596805012.do</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e233 e233" xml:id="Wilson2011" xreflabel="Wilson (2011)"><textual class="po-textual">Wilson, Greg, 2011,
                </textual><quote class="po-inline e234 e234"><textual class="po-textual">Literate Programming,</textual></quote><textual class="po-textual"> Internet resource, Software Carpentry,
            downloaded 14 April 2012.
            </textual><link class="po-inline e235 e235" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://software-carpentry.org/2011/03/4069/</textual></link></bibliomixed><bibliomixed class="po-block e236 e236" xml:id="ZaytsevLammel2011" xreflabel="Zaytsev and Lämmel (2011)"><textual class="po-textual">Zaytsev, Vadim
            and Lämmel, Ralf, 2011, </textual><quote class="po-inline e237 e237"><textual class="po-textual">A Unified Format for Language Documents,</textual></quote><textual class="po-textual"> in: B.
            Malloy, S. Staab, and M. van den Brand (eds.), </textual><emphasis class="po-inline e238 e238"><textual class="po-textual">Software Language Engineering,
                Lecture Notes in Computer Science</textual></emphasis><textual class="po-textual">, 6563, Springer Verlag, 206-225.
                </textual><link class="po-inline e239 e239" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.springerlink.com/content/126476612j05082n/</textual></link><textual class="po-textual">
        </textual></bibliomixed></bibliography></article></classedDocument>