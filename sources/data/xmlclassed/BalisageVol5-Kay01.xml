<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">A Streaming XSLT Processor</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Existing XSLT implementations build a tree representation of the source document in memory, and
are therefore limited to processing of documents that fit in memory. With many transformations, however,
there is a direct correspondence between the order of information in the output, and the order of the
corresponding information in the input. In such cases it ought to be possible to perform the transformation
without allocating memory to the entire source tree.</textual></para><para class="po-block e8 e8"><textual class="po-textual">The XSL Working Group within W3C has been working on a new version of the language designed
    to make streamed implementations feasible, and the author, who is editor of that specification, has
    at the same time been working on the implementation of streaming in the Saxon XSLT processor. This paper
    describes how far this work has progressed, and the way in which the implementation is structured.
    It adopts a chronological approach to the exposition, explaining how the streaming features have gradually
    developed from small beginnings.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Michael</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Kay</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Michael Kay is the editor of the W3C XSLT specification, and is a member of the XQuery
and XML Schema Working Groups. He is the developer of the Saxon XSLT, XQuery, and XML Schema processor.
He is the author of </textual><quote class="po-inline e15 e15"><textual class="po-textual">XSLT Programmer's Reference</textual></quote><textual class="po-textual"> (now in its fourth edition) and a contributor
to many other books.</textual></para><para class="po-block e16 e16"><textual class="po-textual">He is a member of the Advisory Board for Balisage 2010.  In 2009, he chaired the associated Symposium
on Processing XML Efficiently.</textual></para></personblurb><affiliation class="po-record e17 e17"><jobtitle class="po-field e18 e18"><textual class="po-textual">Director</textual></jobtitle><orgname class="po-block e19 e19"><textual class="po-textual">Saxonica Limited</textual></orgname></affiliation><email class="po-field e20 e20"><textual class="po-textual">mike@saxonica.com</textual></email></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Copyright Â© Michael Kay 2010</textual></para></legalnotice><keywordset class="po-table e23 e23" role="author"><keyword class="po-field e24 e24"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">Streaming</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">Push</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">Program Inversion</textual></keyword></keywordset></info><section class="po-hcontainer e28 e28"><title class="po-block e29 e29"><textual class="po-textual">Streaming: an Introduction</textual></title><para class="po-block e30 e30"><textual class="po-textual">The architecture of most XSLT processors is as shown in Figure 1. The XML parser is used
      to build a tree representation of the source document in memory. XSLT instructions are then
      executed, which cause the evaluation of XPath expressions, which select nodes from the source
      tree by navigating around this tree. Because the XPath axes (child, descendant, parent,
      ancestor, preceding-sibling, and so on) allow navigation around this tree in arbitrary
      directions, it is necessary for the entire tree to be held in memory for the duration of the
      transformation. For some XML documents, this is simply not feasible: even sample datasets
    representing virtual 3D city models run to 44Gbytes in size (</textual><xref class="po-milestone e31 e31" linkend="CityGML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para><figure class="po-container e32 e32" xml:id="fig1"><title class="po-block e33 e33"><textual class="po-textual">Fig 1: Architecture of an XSLT Processor</textual></title><mediaobject class="po-container e34 e34"><imageobject class="po-container e35 e35"><imagedata class="po-meta e36 e36" fileref="../../../vol5/graphics/Kay01/Kay01-001.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e37 e37"><para class="po-block e38 e38"><textual class="po-textual">In this schematic, arrows represent flow of control (not data flow). Thus the two
          controlling components (outlined bold) are the Parser and the XSLT engine; the parser
          writes the source tree and the XSLT engine reads it (via the XPath engine). The serializer
          is invoked by the XSLT engine to process one result tree event at a time, which means that
          the result tree does not actually need to be materialized in memory.</textual></para></caption></figure><para class="po-block e39 e39"><textual class="po-textual">By contrast, there is no need to hold the result tree in memory. Although the semantics of
      the language speak of a result tree, a naive execution of XSLT instructions causes nodes to be
      written to the result tree in document order, which means that data can be serialized (to
      lexical XML or HTML) as soon as it is generated. So the result tree is a fiction of the
      specification, and does not occupy real memory in a typical implementation.</textual></para><para class="po-block e40 e40"><textual class="po-textual">It has long been recognized that the need to hold the source tree in memory is a serious
    restriction for many applications. Researchers have made a number of attempts to tackle the problem:</textual></para><orderedlist class="po-table e41 e41"><listitem class="po-container e42 e42"><para class="po-block e43 e43"><textual class="po-textual">Some have concentrated on streaming XPath processors (</textual><xref class="po-milestone e44 e44" linkend="Barton2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
            </textual><xref class="po-milestone e45 e45" linkend="BarYossef2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e46 e46" linkend="Joshi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The focus here is on
          rewriting the reverse axes (such as preceding-sibling) in terms of forwards axes. There
          has been significant progress demonstrated in these projects, though they all leave out
          some of the most awkward features of the language, such as the </textual><code class="po-atom e47 e47"><textual class="po-textual">last()</textual></code><textual class="po-textual">
          function. However, streamed evaluation of a single XPath expression during a single pass
          of a source document does not help much with streamed evaluation of XSLT, since a
          stylesheet contains many XPath expressions, and the starting point for one is typically
          dependent on the nodes found by another.</textual></para></listitem><listitem class="po-container e48 e48"><para class="po-block e49 e49"><textual class="po-textual">Other projects have concentrated on streamed evaluation of XQuery (</textual><xref class="po-milestone e50 e50" linkend="Florescu2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e51 e51" linkend="Li2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Again these projects rely heavily
          on rewriting the execution plan. These results are difficult to translate to XSLT, because
          XQuery has the luxury of a flow-of-control that is fully statically analyzable (there is
          no polymorphism or dynamic despatch). In XQuery, the compiler can look at a function call
          and know which function it is calling; it can therefore determine what navigation is
          performed by the called function. Template rules in XSLT, by contrast, are fired
          dynamically based on input data.</textual></para></listitem><listitem class="po-container e52 e52"><para class="po-block e53 e53"><textual class="po-textual">Guo et al (</textual><xref class="po-milestone e54 e54" linkend="Guo2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) describe an approach to streamed XSLT processing that restricts the supported
          XSLT constructs to a small core. This core language is DTD-aware, and restricts match patterns to those
          that can be uniquely ascribed to an element declaration in the DTD grammar. XPath expressions appear only
          in the </textual><code class="po-atom e55 e55"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> instruction, and always select downwards by element name. As a result,
          the call hierarchy becomes statically tractable, as in the XQuery case.</textual></para></listitem><listitem class="po-container e56 e56"><para class="po-block e57 e57"><textual class="po-textual">Zergaoui (</textual><xref class="po-milestone e58 e58" linkend="Zergaoui2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) observes that many transformations
      are intrinsically non-streamable, because the events representing the result tree appear in a different
      order from the events from the source tree on which they depend. He therefore suggests that pure
      (zero-memory) streaming is an impractical goal, and that practical engineering solutions should
      strive rather to minimize the amount of buffering needed, without restricting the expressive
      capabilities of the transformation language.
             </textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Echoing this, Dvorakova (</textual><xref class="po-milestone e61 e61" linkend="Dvorakova2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e62 e62" linkend="Dvorakova2009a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">,
            </textual><xref class="po-milestone e63 e63" linkend="Dvorakova2009b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and her colleagues describe an approach that supports
          a rather larger subset of the XSLT language, though it still contains some serious limitations:
          match patterns in template rules are simple element names, path expressions can select
          downwards only, recursive structures in the schema are not allowed. Their approach,
          implemented in the Xord framework, is based on static analysis of the XSLT code in the
          context of a schema to determine the extent to which streaming can be employed, and the
          scope of input buffering needed to handle constructs (for example, non-order-preserving
          constructs) where pure streaming is not possible. (An implicit assumption of their
          approach, which sadly is not true in real life, is that an element name appearing in the
          match pattern of a template rule can be used to identify unambiguously a schema definition
          of the structure of the elements that match this rule.)</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">Others have adopted the approach that if XSLT cannot be streamed, then a different language
            is needed. STX </textual><xref class="po-milestone e66 e66" linkend="STX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is one example of an alternative transformation language, designed explicitly for streaming.
          Another is the INRIA XStream project (</textual><xref class="po-milestone e67 e67" linkend="Frisch2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) (not to be confused with other projects of the same name).
          STX abandons the attempt to be purely declarative, instead giving the programmer access to mutable
          variables which can be used to remember data from the input document that might be needed later in the transformation;
          this means that the responsibility for controlling memory usage rests entirely on the programmer.
          XStream, by contrast, is a purely functional language that relies heavily on partial evaluation of functions
          as soon as relevant inputs are available; the buffering of input is thus represented by the pool of partially-evaluated
          function calls, and the efficiency of the process depends strongly on the programmer having a good
          understanding of this execution model.
          </textual></para></listitem></orderedlist><para class="po-block e68 e68"><textual class="po-textual">What all this activity makes clear is that streaming of the XSLT language as currently defined is seriously
    difficult; it is unreasonable to treat streaming as a mere optimization that implementors can provide if they
    choose to apply themselves to the task.</textual></para><para class="po-block e69 e69"><textual class="po-textual">Since 2007 the W3C XSL Working Group has been working on enhancements to the XSLT language designed
    to make streaming a feasible proposition. A first working draft of XSLT 2.1 has been published (</textual><xref class="po-milestone e70 e70" linkend="Kay2010b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), 
      and an overview
    of the design approach is available in </textual><xref class="po-milestone e71 e71" linkend="Kay2010a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e72 e72"><textual class="po-textual">This paper describes how streaming is implemented in the Saxon XSLT processor (</textual><xref class="po-milestone e73 e73" linkend="Saxonica"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). This is influenced
    by the work of the W3C specification, but it is by no means an exact match to the specification in its current form:
    many features that should be streamable according to the specification are not yet streamable in Saxon, while Saxon
    succeeds in streaming some constructs that are non-streamable according to XSLT 2.1.</textual></para><para class="po-block e74 e74"><textual class="po-textual">Streaming facilities in Saxon have been developed over a number of years, and have become
      gradually more sophisticated in successive releases. In order to aid understanding, the
      facilities are therefore presented as a narrative, describing enhancements as they were
      introduced in successive releases. This includes features that have been implemented but not
      yet released at the time of writing, in what is destined to be Saxon 9.3.</textual></para></section><section class="po-hcontainer e75 e75"><title class="po-block e76 e76"><textual class="po-textual">Streamed XPath in the Schema Validator</textual></title><para class="po-block e77 e77"><textual class="po-textual">Since version 8.0, released in June 2004, Saxon has incorporated an XML Schema 1.0
      processor. This was introduced to underpin the schema-aware capabilities of the (then draft)
      XSLT 2.0 and XQuery 1.0 specifications, but can also be used as a freestanding validator in
      its own right.</textual></para><para class="po-block e78 e78"><textual class="po-textual">XML Schema 1.0 (XSD 1.0) allows uniqueness and referential constraints to be expressed by
      means of XPath expressions. For example, in a schema describing XSLT stylesheet documents, the
      constraint that every </textual><code class="po-atom e79 e79"><textual class="po-textual">with-param</textual></code><textual class="po-textual"> element within an </textual><code class="po-atom e80 e80"><textual class="po-textual">call-template</textual></code><textual class="po-textual">
      element must have a distinct value for its </textual><code class="po-atom e81 e81"><textual class="po-textual">name</textual></code><textual class="po-textual"> attribute might be expressed as
      follows:</textual></para><programlisting class="po-block e82 e82" xml:space="preserve"><textual class="po-textual">
      &lt;xs:element name="call-template" type="call-template-type"&gt;
        &lt;xs:unique&gt;
          &lt;xs:selector xpath="xsl:with-param"/&gt;
          &lt;xs:field xpath="@name"/&gt;
        &lt;/xs:unique&gt;
      &lt;/xs:element&gt;
    </textual></programlisting><para class="po-block e83 e83"><textual class="po-textual">In this example the two XPath expressions are very simple. XSD 1.0 allows them to be rather
      more complicated than these examples, but they are still restricted to a very small subset of
      XPath: downward selection only; no predicates; union operator allowed at the top level only.
      The specification explicitly states the reason why the subset is so small:</textual></para><blockquote class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">In order to reduce the burden on implementers, in particular implementers of streaming processors, 
    only restricted subsets of XPath expressions are allowed in {selector} and {fields}. </textual></para></blockquote><para class="po-block e86 e86"><textual class="po-textual">It was important to the designers of XML Schema 1.0 that a validator should be able to process its input document
    in a pure streaming manner with no buffering, and a subset of XPath was chosen to make this viable.</textual></para><para class="po-block e87 e87"><textual class="po-textual">Accordingly, Saxon 8.0 included in its schema processor a streamed implementation of this XPath subset.</textual></para><para class="po-block e88 e88"><textual class="po-textual">For various reasons, the schema validator in Saxon was implemented as a push pipeline
      (</textual><xref class="po-milestone e89 e89" linkend="Kay2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">); the component for evaluating uniqueness and referential constraints
      forms one of the steps in this pipeline. A SAX XML parser generates a sequence of parsing
      events (startElement, endElement, etc) which are piped into the validator, which in turn
      passes them on to the next stage in the process, whatever that might be. Streamed XPath
      evaluation therefore operates in push mode, and this design choice continues to affect the way
      the design evolves today. One of the great advantages of a push pipeline is that it is easy to
      direct parsing events to many different consumers: this is particularly useful with uniqueness
      constraints because many such constraints can be under evaluation at any one time, scoped to
      the same or different parent elements.</textual></para><para class="po-block e90 e90"><textual class="po-textual">The despatching of events to the listeners involved in evaluating a uniqueness constraint is handled by a component
      called the </textual><code class="po-atom e91 e91"><textual class="po-textual">WatchManager</textual></code><textual class="po-textual">; each of the listening components is called a </textual><code class="po-atom e92 e92"><textual class="po-textual">Watch</textual></code><textual class="po-textual">. For the example
      constraint given, the process is as follows:</textual></para><orderedlist class="po-table e93 e93"><listitem class="po-container e94 e94"><para class="po-block e95 e95"><textual class="po-textual">When the startElement event for the </textual><code class="po-atom e96 e96"><textual class="po-textual">xsl:call-template</textual></code><textual class="po-textual"> element is notified by the
          parser, the validator for the </textual><code class="po-atom e97 e97"><textual class="po-textual">xsl:call-template</textual></code><textual class="po-textual"> element is fired up. This
          creates a </textual><code class="po-atom e98 e98"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual"> for the uniqueness constraint. The
            </textual><code class="po-atom e99 e99"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual"> maintains a table of key values that have been encountered
          (initially empty) so that it can check these for uniqueness.</textual></para></listitem><listitem class="po-container e100 e100"><para class="po-block e101 e101"><textual class="po-textual">All parsing events are now notified to this </textual><code class="po-atom e102 e102"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual">. For each event, it
          checks whether the ancestor path in the document matches the path given in the
            </textual><code class="po-atom e103 e103"><textual class="po-textual">xs:selector</textual></code><textual class="po-textual"> element. In this case this is simply a test whether the event
          is a startElement event for an </textual><code class="po-atom e104 e104"><textual class="po-textual">xsl:with-param</textual></code><textual class="po-textual"> element. More generally, it is
          essentially a match of one list of element names against another list of element names,
          taking account of the fact that the </textual><code class="po-atom e105 e105"><textual class="po-textual">//</textual></code><textual class="po-textual"> operator can appear at the start of
          the path to indicate that it is not anchored to the root </textual><code class="po-atom e106 e106"><textual class="po-textual">xsl:call-template</textual></code><textual class="po-textual">
          element. When the matching startElement event is encountered, the
            </textual><code class="po-atom e107 e107"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual"> instantiates a </textual><code class="po-atom e108 e108"><textual class="po-textual">FieldWatch</textual></code><textual class="po-textual"> to process any nodes
          that match the expression in the </textual><code class="po-atom e109 e109"><textual class="po-textual">xs:field</textual></code><textual class="po-textual"> element.</textual></para></listitem><listitem class="po-container e110 e110"><para class="po-block e111 e111"><textual class="po-textual">The </textual><code class="po-atom e112 e112"><textual class="po-textual">FieldWatch</textual></code><textual class="po-textual"> is now notified of all parsing events, and when the
            </textual><code class="po-atom e113 e113"><textual class="po-textual">@name</textual></code><textual class="po-textual"> attribute is encountered, it informs the owning
            </textual><code class="po-atom e114 e114"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual">, which checks that its value does not conflict with any value
          previously notified. This process is more complex than might appear, because there can be
          multiple </textual><code class="po-atom e115 e115"><textual class="po-textual">xs:field</textual></code><textual class="po-textual"> elements to define a composite key, and furthermore, the
          field value can be an element rather than an attribute, in which case it may be necessary
          to assemble the value from multiple text nodes separated by comments or processing
          instructions. It is also necessary to check that the </textual><code class="po-atom e116 e116"><textual class="po-textual">FieldWatch</textual></code><textual class="po-textual"> fires exactly
          once. (A simplifying factor, however, is that XSD requires the element to have simple
          content.) </textual></para></listitem><listitem class="po-container e117 e117"><para class="po-block e118 e118"><textual class="po-textual">After detecting a </textual><code class="po-atom e119 e119"><textual class="po-textual">startElement</textual></code><textual class="po-textual"> event that matches its path expression, the
            </textual><code class="po-atom e120 e120"><textual class="po-textual">SelectorWatch</textual></code><textual class="po-textual"> must remain alert for further matching events. Before the
          corresponding </textual><code class="po-atom e121 e121"><textual class="po-textual">endElement</textual></code><textual class="po-textual"> event is encountered, another matching
            </textual><code class="po-atom e122 e122"><textual class="po-textual">startElement</textual></code><textual class="po-textual"> might be notified. This cannot happen in the above example.
          But consider the constraint that within each section of a chapter, the figure numbers must
          be unique: </textual></para><programlisting class="po-block e123 e123" xml:space="preserve"><textual class="po-textual">
      &lt;xs:element name="chapter" type="call-template-type"&gt;
        &lt;xs:unique&gt;
          &lt;xs:selector xpath=".//section"/&gt;
          &lt;xs:field xpath=".//figure"/&gt;
        &lt;/xs:unique&gt;
      &lt;/xs:element&gt;
      </textual></programlisting><para class="po-block e124 e124"><textual class="po-textual">It is entirely possible here for chapters to be nested within chapters, and for
          sections to be nested within sections. (It is not possible for figures to be nested within
          figures, however: the node selected by the </textual><code class="po-atom e125 e125"><textual class="po-textual">xs:field</textual></code><textual class="po-textual"> element must have simple
          content.) The </textual><code class="po-atom e126 e126"><textual class="po-textual">WatchManager</textual></code><textual class="po-textual"> may therefore be distributing events
          simultaneously to a large number of </textual><code class="po-atom e127 e127"><textual class="po-textual">Watch</textual></code><textual class="po-textual"> instances, even for a single
          uniqueness constraint; at the same time, of course, other uniqueness constraints may be
          active on the same elements or on different elements at a different level of the source
          tree.</textual></para></listitem></orderedlist></section><section class="po-hcontainer e128 e128"><title class="po-block e129 e129"><textual class="po-textual">Streaming Copy</textual></title><para class="po-block e130 e130"><textual class="po-textual">The next step in Saxon's journey towards becoming a streaming XSLT processor was to
      exploit the mechanisms described in the previous section in contexts other than schema
      validation. This was introduced in Saxon 8.5, released in August 2005, and subsequently
      extended. The facility used standard XSLT 2.0 syntax, but required the user to write code in a
      highly stereotyped way for streaming to be possible.</textual></para><section class="po-hcontainer e131 e131"><title class="po-block e132 e132"><textual class="po-textual">Initial implementation of Streaming Copy</textual></title><para class="po-block e133 e133"><textual class="po-textual">Typically, the user would write code like this:</textual></para><programlisting class="po-block e134 e134" xml:space="preserve"><textual class="po-textual">
      
&lt;xsl:function name="f:customers"&gt;
  &lt;xsl:copy-of select="doc('customers.xml')/*/customer"
       saxon:read-once="yes" xmlns:saxon="http://saxon.sf.net/"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="f:customers()"/&gt;
&lt;/xsl:template&gt;

    </textual></programlisting><para class="po-block e135 e135"><textual class="po-textual">Without the processing hint expressed by the </textual><code class="po-atom e136 e136"><textual class="po-textual">saxon:read-once</textual></code><textual class="po-textual"> attribute, this
        code would parse the source document </textual><code class="po-atom e137 e137"><textual class="po-textual">customers.xml</textual></code><textual class="po-textual"> and build a tree
        representation of the document in memory. It would then search the tree for the elements
        matching the path </textual><code class="po-atom e138 e138"><textual class="po-textual">/*/customer</textual></code><textual class="po-textual">, and for each of these in turn it would create a
        copy of the subtree rooted at this element, returning it from the function and then applying
        templates to it.</textual></para><para class="po-block e139 e139"><textual class="po-textual">It is easy to see that in this operation, building the tree representation of the large
          </textual><code class="po-atom e140 e140"><textual class="po-textual">customers.xml</textual></code><textual class="po-textual"> document is unnecessary; it can be bypassed if the elements
        matching </textual><code class="po-atom e141 e141"><textual class="po-textual">/*/customer</textual></code><textual class="po-textual"> can be recognized in the event stream issuing from the XML
        parser. Instead of one large tree, the processor can build a series of smaller trees, each
        representing a single customer record. So long as the size of the customer record is kept
        within bounds, there is then no limit on the number of customer records present in the input
        document. This is sometimes referred to as </textual><emphasis class="po-inline e142 e142"><textual class="po-textual">windowing</textual></emphasis><textual class="po-textual"> or
          </textual><emphasis class="po-inline e143 e143"><textual class="po-textual">burst-mode streaming</textual></emphasis><textual class="po-textual">: the source document is processed as a sequence
        of small trees, rather than as one large tree.</textual></para><para class="po-block e144 e144"><textual class="po-textual">The use of the </textual><code class="po-atom e145 e145"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual"> instruction here is significant. In the implementation, there is no physical
    copying taking place, because the original whole-document tree is never built. But the result is equivalent to the result
    of building the whole-document tree and then copying the sequence of subtrees. In particular, the nodes in one subtree
    are not linked in any way to the nodes in other subtrees; there is no way the application can navigate outside the boundaries
    of a subtree. Attempting to retrieve the ancestors or siblings of the </textual><code class="po-atom e146 e146"><textual class="po-textual">customer</textual></code><textual class="po-textual"> element returns nothing,
    just as it would with a true subtree copy.</textual></para><para class="po-block e147 e147"><textual class="po-textual">Saxon implements this construct by reusing the </textual><code class="po-atom e148 e148"><textual class="po-textual">WatchManager</textual></code><textual class="po-textual"> machinery
        described in the previous section. Having analyzed the </textual><code class="po-atom e149 e149"><textual class="po-textual">select</textual></code><textual class="po-textual"> attribute of the
          </textual><code class="po-atom e150 e150"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual"> instruction to confirm that it satisfies the constraints on
        streamable XPath expressions, the document </textual><code class="po-atom e151 e151"><textual class="po-textual">customers.xml</textual></code><textual class="po-textual"> is then processed
        using a SAX parser which sends parsing events to a </textual><code class="po-atom e152 e152"><textual class="po-textual">WatchManager</textual></code><textual class="po-textual"> which in this
        case notifies a new kind of </textual><code class="po-atom e153 e153"><textual class="po-textual">Watch</textual></code><textual class="po-textual">, a </textual><code class="po-atom e154 e154"><textual class="po-textual">CopyWatch</textual></code><textual class="po-textual">, of the start and
        end of elements matching the path expression; between these start and end events, the
          </textual><code class="po-atom e155 e155"><textual class="po-textual">CopyWatch</textual></code><textual class="po-textual"> is notified of all intermediate events and uses these to build a
        tree representing the </textual><code class="po-atom e156 e156"><textual class="po-textual">customer</textual></code><textual class="po-textual"> element.</textual></para><para class="po-block e157 e157"><textual class="po-textual">Note again that two elements matching the path can be active at the same time. This cannot happen with the example above, because
    the path </textual><code class="po-atom e158 e158"><textual class="po-textual">/*/customer</textual></code><textual class="po-textual"> has a fixed depth. But change the example to </textual><code class="po-atom e159 e159"><textual class="po-textual">//section</textual></code><textual class="po-textual">, and it is clear that
    the set of </textual><code class="po-atom e160 e160"><textual class="po-textual">section</textual></code><textual class="po-textual"> elements selected by the path can include one section that is a subtree of another. This situation
    requires some internal buffering: the language semantics require that the sections are delivered in document order, which means that
    the outermost section must be delivered before its nested sections. The trees representing the nested sections must therefore
    be held in memory, to be released for processing only when the </textual><code class="po-atom e161 e161"><textual class="po-textual">endElement</textual></code><textual class="po-textual"> event for the outermost section is
    notified. The code is written so that it is always prepared to do this buffering; in practice, it is very rarely needed, and
    no extra costs are incurred in the case where it is not needed. In some cases it would be possible to determine statically
    that no buffering will be needed, but this knowledge confers little benefit.</textual></para><para class="po-block e162 e162"><textual class="po-textual">The reader may be puzzled by the choice of name for the attribute
          </textual><code class="po-atom e163 e163"><textual class="po-textual">saxon:read-once="yes"</textual></code><textual class="po-textual">. Although the implementation of the
          </textual><code class="po-atom e164 e164"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual"> instruction in streaming mode is very different from the
        conventional execution plan, the functional behaviour is identical except in one minor
        detail: there is no longer a guarantee that if the </textual><code class="po-atom e165 e165"><textual class="po-textual">customers.xml</textual></code><textual class="po-textual"> file is read
        more than once within the same transformation, its contents will be the same each time. At
        the time this feature was first implemented, the XSLT 2.0 conformance rules required
        implementations to deliver stable results in this situation. The streaming implementation
        necessarily departed from this rule (the only practical way to enforce the rule is to make
        an in-memory copy of the tree), so the </textual><code class="po-atom e166 e166"><textual class="po-textual">saxon:read-once</textual></code><textual class="po-textual"> attribute was provided
        as a way for the user to assert that the file would not be read more than once, thus
        licensing the non-conformance in the case where the assertion was not honoured. In the final
        version of the XSLT 2.0 specification, there was explicit provision that implementations
        were allowed to provide a user option to waive the stability requirement for the
          </textual><code class="po-atom e167 e167"><textual class="po-textual">doc()</textual></code><textual class="po-textual"> function, thus making this extension conformant.</textual></para><para class="po-block e168 e168"><textual class="po-textual">A further complication in the implementation is caused by the fact that the
          </textual><code class="po-atom e169 e169"><textual class="po-textual">CopyWatch</textual></code><textual class="po-textual"> component delivers its results (the sequence of small
          </textual><code class="po-atom e170 e170"><textual class="po-textual">customer</textual></code><textual class="po-textual"> trees) using a push interface (it calls the next component in the
        pipeline to deliver each one in turn), whereas the </textual><code class="po-atom e171 e171"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual">
        instruction that calls the user-defined function expects to use a pull interface (it calls
        the XPath engine to deliver each one in turn). There is thus a push-pull conflict, which is
        resolved using the design described in </textual><xref class="po-milestone e172 e172" linkend="Kay2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and shown in Figure 2. The push
        code operates in one thread, writing the sequence of </textual><code class="po-atom e173 e173"><textual class="po-textual">customer</textual></code><textual class="po-textual"> trees to a cyclic
        buffer, which is then read by a parallel thread delivering the trees in response to requests
        from the </textual><code class="po-atom e174 e174"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> instruction.</textual></para><figure class="po-container e175 e175"><title class="po-block e176 e176"><textual class="po-textual">Figure 2: Two-thread processing model</textual></title><mediaobject class="po-container e177 e177"><imageobject class="po-container e178 e178"><imagedata class="po-meta e179 e179" fileref="../../../vol5/graphics/Kay01/Kay01-002.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e180 e180"><para class="po-block e181 e181"><textual class="po-textual">Thread One contains the parser and the push-mode evaluation of the streaming path
            expression (the WatchManager and CopyWatch). This emits a sequence of small trees (each
            representing one customer record) to the cyclic butter, from where they are read by the
            pull-mode XPath engine running in Thread Two. Arrow represent flow of control.</textual></para></caption></figure></section><section class="po-hcontainer e182 e182"><title class="po-block e183 e183"><textual class="po-textual">Refinements of the Streaming Copy feature</textual></title><para class="po-block e184 e184"><textual class="po-textual">In releases subsequent to Saxon 8.5, the streaming copy mechanism described in the previous section was enhanced in a number of ways,
    without changing its fundamentals.</textual></para><para class="po-block e185 e185"><textual class="po-textual">In Saxon 8.8 (September 2006) two changes were made. Firstly, the set of XPath expressions
        that could be handled in streaming mode was extended, to include union expressions and
        simple predicates. Secondly, the need for the two-thread model was eliminated in cases where
        no further processing of the copied subtrees was required: for example, in a transformation
        whose output contained these subtrees without modification.</textual></para><para class="po-block e186 e186"><textual class="po-textual">In Saxon 9.1 (July 2008) the mechanism was extended to XQuery, via a new extension
        function </textual><code class="po-atom e187 e187"><textual class="po-textual">saxon:stream()</textual></code><textual class="po-textual">, which was also made available in XSLT. This might be
        regarded as a pseudo-function: the call
          </textual><code class="po-atom e188 e188"><textual class="po-textual">saxon:stream(doc('customers.xml')/*/customer)</textual></code><textual class="po-textual"> delivers a copy of the value of
        its argument (that is, a sequence of </textual><code class="po-atom e189 e189"><textual class="po-textual">customer</textual></code><textual class="po-textual"> subtrees), but it requires its
        argument to conform to the syntax of streamable path expressions. </textual><footnote class="po-popup e190 e190"><para class="po-block e191 e191"><textual class="po-textual">Looking at this syntax, one might reasonably ask whether a pull pipeline would not
            deliver the result with less complexity. For this example, it probably would. The push
            code was used primarily because it already existed and could be reused. But I think this
            is no accident: I tend to the view that components implemented with a push model are
            likely to be reusable in a wider variety of configurations. For more details on push
            versus pull pipelines, see </textual><xref class="po-milestone e192 e192" linkend="Kay2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote></para><para class="po-block e193 e193"><textual class="po-textual">In Saxon 9.2 (August 2009) a further refinement was introduced to allow the processing of
        the input stream to terminate prematurely. For example, the query
          </textual><code class="po-atom e194 e194"><textual class="po-textual">saxon:stream(doc('customers.xml')/*/@version)</textual></code><textual class="po-textual"> will return the value of the
          </textual><code class="po-atom e195 e195"><textual class="po-textual">version</textual></code><textual class="po-textual"> attribute from the outermost element of the document, and will read
        no further once this has been seen. This makes it possible to obtain information from near
        the start of an XML document in constant time, regardless of the document size, which is
        especially useful in a pipeline when making decisions on how to route a document for
        processing based on information in its header. (It's a moot point whether this is consistent
        with the requirement in the XML 1.0 specification that all well-formedness errors in a
        document must be reported to the application. But the facility is so useful that we can
        ignore the standards-lawyers on this one.)</textual></para></section><section class="po-hcontainer e196 e196"><title class="po-block e197 e197"><textual class="po-textual">Streaming with Retained State</textual></title><para class="po-block e198 e198"><textual class="po-textual">A limitation of the streaming copy approach as outlined above is that there is no way of
        using the information in a subtree once the processing of that subtree has finished; so
        there is no way that the processing of one subtree can influence the processing of
        subsequent subtrees. (Saxon always had a workaround to this problem, the deprecated
          </textual><code class="po-atom e199 e199"><textual class="po-textual">saxon:assign</textual></code><textual class="po-textual"> instruction which introduces mutable variables to the language;
        but this plays havoc with optimisation).</textual></para><para class="po-block e200 e200"><textual class="po-textual">An answer to this problem was found in the form of the </textual><code class="po-atom e201 e201"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">
        instruction defined in the XSLT 2.1 working draft. This was implemented in Saxon 9.2 in the
        Saxon namespace (as </textual><code class="po-atom e202 e202"><textual class="po-textual">saxon:iterate</textual></code><textual class="po-textual">), but I will present it using the W3C syntax,
        which becomes available in Saxon 9.3.</textual></para><para class="po-block e203 e203"><textual class="po-textual">Consider the problem of processing a sequence of </textual><code class="po-atom e204 e204"><textual class="po-textual">transaction</textual></code><textual class="po-textual"> elements, and outputting the
        same sequence of elements but with an additional attribute holding the running balance on the account, obtained
        by accumulating the values of all the preceding transactions.</textual></para><para class="po-block e205 e205"><textual class="po-textual">The classic solution to this would use sibling recursion:</textual></para><programlisting class="po-block e206 e206" xml:space="preserve"><textual class="po-textual">
        &lt;xsl:template match="transaction"&gt;
          &lt;xsl:param name="balance" as="xs:decimal"/&gt;
          &lt;transaction value="{@value}" balance="{$balance + @value}"/&gt;
          &lt;xsl:apply-templates select="following-sibling::transaction[1]"&gt;
             &lt;xsl:with-param name="balance" select="$balance + @value"/&gt;
          &lt;/xsl:apply-templates&gt;
        &lt;/xsl:template&gt;</textual></programlisting><para class="po-block e207 e207"><textual class="po-textual">There are a number of difficulties with this approach. Firstly, everyone who has taught
        XSLT appears to agree that students have considerable difficulty producing the code above as
        the solution to this exercise, despite its brevity and apparent simplicity. Secondly, it
        relies rather heavily on the XSLT processor implementing tail call optimization; if you run
        this on a variety of popular XSLT processors, many of them will run out of stack space after
        processing 500 or so transactions, showing that they do not implement this optimization.
        Finally, the analysis needed to demonstrate that a streaming implementation of this code is
        feasible is far from easy, and one suspects that minor departures from this particular way
        of writing the code will invalidate any such analysis.</textual></para><para class="po-block e208 e208"><textual class="po-textual">For all these reasons, XSLT 2.1 introduces a new instruction </textual><code class="po-atom e209 e209"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">, which allows the solution to
      be expressed as follows:</textual></para><programlisting class="po-block e210 e210" xml:space="preserve"><textual class="po-textual">
        &lt;xsl:iterate select="transaction"&gt;
          &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;
          &lt;transaction value="{@value}" balance="{$balance + @value}"/&gt;
          &lt;xsl:next-iteration&gt;
             &lt;xsl:with-param name="balance" select="$balance + @value"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:iteration&gt;</textual></programlisting><para class="po-block e211 e211"><textual class="po-textual">This has the appearance of a simple loop rather than functional recursion; it behaves like
        the familiar </textual><code class="po-atom e212 e212"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> instruction with the added ability to set a parameter
        after the processing of one value which is then available for use when processing the next.
        A key difference compared with the recursive solution is that the set of transactions to be
        processed is identified in one place, the </textual><code class="po-atom e213 e213"><textual class="po-textual">select</textual></code><textual class="po-textual"> attribute of the
          </textual><code class="po-atom e214 e214"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual"> instruction, rather than being the product of a sequence of
        independent calls on </textual><code class="po-atom e215 e215"><textual class="po-textual">following-sibling</textual></code><textual class="po-textual">. A useful consequence of this difference
        is that termination is guaranteed.</textual></para><para class="po-block e216 e216"><textual class="po-textual">Another way of looking at </textual><code class="po-atom e217 e217"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual"> is as syntactic sugar for the
          </textual><code class="po-atom e218 e218"><textual class="po-textual">foldl</textual></code><textual class="po-textual"> higher-order function found in many functional programming languages:
        this applies a user-supplied function (the body of </textual><code class="po-atom e219 e219"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">) to each item of
        an input sequence (the value of the </textual><code class="po-atom e220 e220"><textual class="po-textual">select</textual></code><textual class="po-textual"> expression), with each iteration
        delivering an accumulated value of some kind, which is made available as a parameter to the
        user-supplied function when called to process the next item.</textual></para><para class="po-block e221 e221"><textual class="po-textual">Saxon 9.2 implements this new instruction (albeit in its own namespace) and allows the
          </textual><code class="po-atom e222 e222"><textual class="po-textual">select</textual></code><textual class="po-textual"> expression to select the stream of subtrees arising from a streaming
        copy operation: for example </textual><code class="po-atom e223 e223"><textual class="po-textual">&lt;xsl:iterate
          select="saxon:stream(doc('transactions'xml')/*/transaction"&gt;</textual></code><textual class="po-textual">. By this means,
        information computed while processing one input transaction can be made available while
        processing the next. The implementation of </textual><code class="po-atom e224 e224"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual"> in fact knows nothing
        about streaming; it is processing the sequence of subtrees just as it would process any
        other sequence of items.</textual></para></section><section class="po-hcontainer e225 e225"><title class="po-block e226 e226"><textual class="po-textual">Limitations of Streaming Copy</textual></title><para class="po-block e227 e227"><textual class="po-textual">The streaming copy feature has enabled many applications to be written using Saxon that
        would otherwise have been impossible because of the size of the input document. Many of the
        streaming use cases published by the W3C Working Group (</textual><xref class="po-milestone e228 e228" linkend="Cimprich2010"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) can be implemented using
        this feature. But despite the various refinements that have been described, there are some
        serious limitations:</textual></para><itemizedlist class="po-table e229 e229"><listitem class="po-container e230 e230"><para class="po-block e231 e231"><textual class="po-textual">There is no way of getting access to part of the streamed source document other than
      what is contained in the copied subtrees. This problem can be mitigated by using a union expression to select
      all the data that is needed. However, the programming then becomes rather complex.</textual></para></listitem><listitem class="po-container e232 e232"><para class="po-block e233 e233"><textual class="po-textual">The design pattern works well with "hedge-like" source documents: those where the hierarchy
            fans out quickly to a large number of small subtrees. But there are many large source
            documents that do not fit into this pattern - this arises particularly with
            "document-oriented" XML, but also for example with GML (Geography Markup Language) [gml]
            where individual geographical features represented in the data stream can each be of
            considerable size.</textual></para></listitem></itemizedlist><para class="po-block e234 e234"><textual class="po-textual">These limitations arise because streaming copy treats the input document as a flat
        sequence of elements, not really as a hierarchy. To address these limitations, it is
        necessary to restore the ability to process the input tree using recursive descent using
        template rules. The way in which template rules can be made to work in a streaming manner is
        the subject of the next section.</textual></para></section></section><section class="po-hcontainer e235 e235"><title class="po-block e236 e236"><textual class="po-textual">Streaming Templates</textual></title><para class="po-block e237 e237"><textual class="po-textual">Consider a stylesheet containing the following two rules:</textual></para><programlisting class="po-block e238 e238" xml:space="preserve"><textual class="po-textual">
      &lt;xsl:template match="*"&gt;
        &lt;xsl:copy&gt;
          &lt;xsl:apply-templates/&gt;
        &lt;/xsl:copy&gt;
      &lt;/xsl:template&gt;
      
      &lt;xsl:template match="note"/&gt;
      </textual></programlisting><para class="po-block e239 e239"><textual class="po-textual">This follows a familiar coding pattern: first a generic template which acts as the default processing for all
    elements in the source document (this example copies the element to the output, sans attributes, and uses the
    </textual><code class="po-atom e240 e240"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> instruction to invoke recursive processing of its children); then one or more templates
    for specific named elements to process them in a way that differs from the general rule. The effect of this stylesheet
    is to copy the source document to the result document unchanged except for the loss of all attributes, and of elements
    named </textual><code class="po-atom e241 e241"><textual class="po-textual">note</textual></code><textual class="po-textual"> together with their descendants.</textual></para><para class="po-block e242 e242"><textual class="po-textual">It is easy to see how this stylesheet could be implemented in a single pass over the
      source document, without building an in-memory tree. A simple filter can be applied to events
      emanating from the parser before passing them on to the serializer: all events are passed on
      unchanged, except for (a) events representing attribute nodes and (b) events that occur
      between the </textual><code class="po-atom e243 e243"><textual class="po-textual">startElement</textual></code><textual class="po-textual"> event and corresponding </textual><code class="po-atom e244 e244"><textual class="po-textual">endElement</textual></code><textual class="po-textual"> event
      for a </textual><code class="po-atom e245 e245"><textual class="po-textual">note</textual></code><textual class="po-textual"> element.</textual></para><para class="po-block e246 e246"><textual class="po-textual">In XSLT 2.1 streamability is a property of a </textual><emphasis class="po-inline e247 e247" role="ital"><textual class="po-textual">mode</textual></emphasis><textual class="po-textual"> (</textual><xref class="po-milestone e248 e248" linkend="Kay2010a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). 
      If a mode is declared to be streamable, then all the template rules in that mode must
      obey the restrictions placed on streamable templates. The analysis defined in the XSLT 2.1
      specification to determine streamability is rather complex; the rules currently implemented in
      Saxon are much simpler (and in most cases, more restrictive), while still allowing a wide
      class of transformations to be expressed. I will present first the Saxon 9.2 implementation,
      which is relatively easy to understand, and then the Saxon 9.3 extensions, which add
      considerable complexity and power.</textual></para><section class="po-hcontainer e249 e249"><title class="po-block e250 e250"><textual class="po-textual">Streaming Templates in Saxon 9.2</textual></title><para class="po-block e251 e251"><textual class="po-textual">Saxon 9.2 follows the principle that streamability is a property of a mode, though its
        restrictions on streamable templates are far more severe than those in the XSLT 2.1 draft.
        The rules for streamable templates can be summarised (in simplified form) as follows:</textual></para><itemizedlist class="po-table e252 e252"><listitem class="po-container e253 e253"><para class="po-block e254 e254"><textual class="po-textual">The match pattern must contain no predicates.</textual></para></listitem><listitem class="po-container e255 e255"><para class="po-block e256 e256"><textual class="po-textual">The template body may contain at most one </textual><emphasis class="po-inline e257 e257"><textual class="po-textual">drill-down construct</textual></emphasis><textual class="po-textual">. This may
            be an </textual><code class="po-atom e258 e258"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> instruction with defaulted </textual><code class="po-atom e259 e259"><textual class="po-textual">select</textual></code><textual class="po-textual">
            expression, or one of the following expressions or instructions applied to the context
            node: </textual><code class="po-atom e260 e260"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e261 e261"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e262 e262"><textual class="po-textual">string()</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e263 e263"><textual class="po-textual">data()</textual></code><textual class="po-textual"> (or implicit atomization), or one of a small number of other
            constructs.</textual></para></listitem><listitem class="po-container e264 e264"><para class="po-block e265 e265"><textual class="po-textual">The drill-down construct may have only the following as its containing (ancestor)
            instructions: </textual><code class="po-atom e266 e266"><textual class="po-textual">xsl:element</textual></code><textual class="po-textual">, literal result elements,
              </textual><code class="po-atom e267 e267"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e268 e268"><textual class="po-textual">xsl:attribute</textual></code><textual class="po-textual">, </textual><code class="po-atom e269 e269"><textual class="po-textual">xsl:comment</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e270 e270"><textual class="po-textual">xsl:processing-instruction</textual></code><textual class="po-textual">, </textual><code class="po-atom e271 e271"><textual class="po-textual">xsl:result-document</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e272 e272"><textual class="po-textual">xsl:variable</textual></code><textual class="po-textual">, </textual><code class="po-atom e273 e273"><textual class="po-textual">xsl:sequence</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e274 e274"><para class="po-block e275 e275"><textual class="po-textual">Apart from the drill-down construct and its ancestors, any expression within the template that
            has a dependency on the context item must fall into one of the following categories: (a)
            a function (for example, </textual><code class="po-atom e276 e276"><textual class="po-textual">local-name()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e277 e277"><textual class="po-textual">exists()</textual></code><textual class="po-textual">) that
            returns a local property of the node, or of one of its attributes or ancestors, or of an
            attribute of an ancestor; (b) an expression that returns the string value or typed value
            of an attribute of the node or an attribute of one of its ancestors.</textual></para></listitem></itemizedlist><para class="po-block e278 e278"><textual class="po-textual">The effect of these rules is that the stylesheet given above, with the addition of the declaration 
    </textual><code class="po-atom e279 e279"><textual class="po-textual">&lt;xsl:mode streamable="yes"/&gt;</textual></code><footnote class="po-popup e280 e280"><para class="po-block e281 e281"><textual class="po-textual">In Saxon 9.2, the element is in the Saxon namespace as </textual><code class="po-atom e282 e282"><textual class="po-textual">saxon:mode</textual></code></para></footnote><textual class="po-textual">,
    is fully streamable.</textual></para><para class="po-block e283 e283"><textual class="po-textual">These rules allow a wide variety of transformations to be expressed. However, they impose
        many arbitrary restrictions. For example, a template cannot contain the instruction
          </textual><code class="po-atom e284 e284"><textual class="po-textual">&lt;xsl:value-of select=". + 3"/&gt;</textual></code><textual class="po-textual">, because an addition expression
          (</textual><code class="po-atom e285 e285"><textual class="po-textual">+</textual></code><textual class="po-textual">) is not an acceptable ancestor of the implicit drill-down construct
          </textual><code class="po-atom e286 e286"><textual class="po-textual">data(.)</textual></code><textual class="po-textual">. To get around this restriction, it is possible to bind a variable to
        the value of </textual><code class="po-atom e287 e287"><textual class="po-textual">data(.)</textual></code><textual class="po-textual"> and then perform the addition using the value of the
        variable.</textual></para><para class="po-block e288 e288"><textual class="po-textual">To understand the reason for such arbitrary restrictions, it is necessary to understand
        something of the architecture of the implementation: whose explanation, indeed, is the main
        purpose of this paper.</textual></para><para class="po-block e289 e289"><textual class="po-textual">Traditionally, Saxon constructed the source tree using a push pipeline. XSLT instructions
        were then interpreted, and by-and-large, they evaluated their XPath subexpressions using a
        pull pipeline of iterator objects navigating the source tree, and generated output
        (including temporary trees) by pushing SAX-like events to a serializer or tree builder
        pipeline. To implement streaming templates, this model has been turned upside-down, almost
        literally. During streamed evaluation, everything operates in push mode, driven by events
        coming from the XML parser. In effect, the code implementing a template rule operating in
        push mode is a Jackson inversion (</textual><xref class="po-milestone e290 e290" linkend="Kay2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) of the code used to implement
        the same template rule in the traditional architecture. This inversion is analogous to
        rewriting a top-down parser as a bottom-up parser: instead of the application being in
        control and making </textual><code class="po-atom e291 e291"><textual class="po-textual">getNextInput()</textual></code><textual class="po-textual"> calls to the parser, the application becomes
        event-driven and is called when new input is available. In consequence, the application has
        to maintain its own stack to represent the current state; it can no longer rely on the call
        stack maintained by the compiler of the implementation language.</textual></para><para class="po-block e292 e292"><textual class="po-textual">The inverted code for a template is generated by the XSLT compiler, and consists (in Saxon
        9.2) of a sequence of pre-descent actions, a drill-down action, and a sequence of
        post-descent actions. The pre-descent actions generally involve writing
          </textual><code class="po-atom e293 e293"><textual class="po-textual">startElement</textual></code><textual class="po-textual"> events or evaluating complete instructions; the post-descent
        actions similarly involve either complete instructions or </textual><code class="po-atom e294 e294"><textual class="po-textual">endElement</textual></code><textual class="po-textual"> actions.
        These correspond to the instructions that are permitted as ancestors of the drill-drown
        construct: mainly instructions such as </textual><code class="po-atom e295 e295"><textual class="po-textual">xsl:element</textual></code><textual class="po-textual">, which are classified as
          </textual><emphasis class="po-inline e296 e296" role="ital"><textual class="po-textual">divisible</textual></emphasis><textual class="po-textual"> instructions representing the fact that their
        push-mode execution can be split into two halves, realised by the entry points
          </textual><code class="po-atom e297 e297"><textual class="po-textual">processLeft()</textual></code><textual class="po-textual"> and </textual><code class="po-atom e298 e298"><textual class="po-textual">processRight()</textual></code><textual class="po-textual">. The drill-down action is one
        of </textual><code class="po-atom e299 e299"><textual class="po-textual">apply</textual></code><textual class="po-textual">, </textual><code class="po-atom e300 e300"><textual class="po-textual">copy-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e301 e301"><textual class="po-textual">value-of</textual></code><textual class="po-textual">, or </textual><code class="po-atom e302 e302"><textual class="po-textual">skip</textual></code><textual class="po-textual">,
        and indicates what is to be done with the content of the matched element (the events that
        occur after the </textual><code class="po-atom e303 e303"><textual class="po-textual">startElement</textual></code><textual class="po-textual"> that activates the template rule and before the
        corresponding </textual><code class="po-atom e304 e304"><textual class="po-textual">endElement</textual></code><textual class="po-textual">). The value </textual><code class="po-atom e305 e305"><textual class="po-textual">skip</textual></code><textual class="po-textual"> causes these events to
        be skipped, and arises when the template rule contains no drill-down construct. The value
          </textual><code class="po-atom e306 e306"><textual class="po-textual">copy-of</textual></code><textual class="po-textual"> indicates that a subtree is to be built from these events;
          </textual><code class="po-atom e307 e307"><textual class="po-textual">value-of</textual></code><textual class="po-textual"> indicates that a string is to be constructed by concatenating the
        text nodes and ignoring everything else. Finally, the value </textual><code class="po-atom e308 e308"><textual class="po-textual">apply</textual></code><textual class="po-textual"> indicates
        that the events should be matched against template rules for the relevant mode; when a match
        occurs, the selected template rule will then receive the events until the matching
          </textual><code class="po-atom e309 e309"><textual class="po-textual">endElement</textual></code><textual class="po-textual"> event occurs.</textual></para><para class="po-block e310 e310"><textual class="po-textual">This is all implemented using the a </textual><code class="po-atom e311 e311"><textual class="po-textual">StreamingDespatcher</textual></code><textual class="po-textual"> that despatches events
        to the relevant template rules. This functions in a very similar way to the
          </textual><code class="po-atom e312 e312"><textual class="po-textual">WatchManager</textual></code><textual class="po-textual"> described earlier, and in the current Saxon 9.3 code base the
        two despatching classes have been combined into one.</textual></para></section><section class="po-hcontainer e313 e313"><title class="po-block e314 e314"><textual class="po-textual">Streamable Templates in Saxon 9.3</textual></title><para class="po-block e315 e315"><textual class="po-textual">Saxon 9.3 (not yet released at the time of submitting this paper) extends streamable templates to handle a much
      larger subset of the XSLT language, while still falling a little short of the capabilities defined in the XSLT 2.1 draft.</textual></para><para class="po-block e316 e316"><textual class="po-textual">The first extension is in the area of match patterns for templates. Saxon 9.3 integrates the two concepts of a match pattern
        and a streamable XPath expression. This makes sense because both are implemented by testing to see whether a given
        node matches the pattern; the only difference is that with an XSLT match pattern in non-streaming mode, the predicates can
        contain XPath expressions that perform arbitrary tree navigation. For XSD selector and field expressions, the parsing still
        artificially restricts the path expression to conform to the XSD-defined XPath subset, but the object that results from the parsing,
        and that is used at run-time, is a </textual><code class="po-atom e317 e317"><textual class="po-textual">Pattern</textual></code><textual class="po-textual"> object equivalent that used when starting from an XSLT match pattern.
        The pattern used in a streamable template rule can be any XSLT pattern provided it does not contain a predicate that is
        positional (for example, is numeric or calls </textual><code class="po-atom e318 e318"><textual class="po-textual">position()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e319 e319"><textual class="po-textual">last()</textual></code><textual class="po-textual">) or that uses
        the child, descendant, descendant-or-self, following, following-sibling, preceding, or preceding-sibling axes.</textual></para><para class="po-block e320 e320"><textual class="po-textual">The body of the template rule is inverted in the same way as with Saxon 9.2, but the
        rules for what it may contain are less restrictive. There is still a rule that only one
        downward selection is allowed: more specifically, in the expression tree (abstract syntax
        tree) representing the body of the template rule, there must be only one leaf node whose
        path to the root of the expression tree contains a downwards selection. This path through
        the expression tree is referred to as the </textual><emphasis class="po-inline e321 e321" role="ital"><textual class="po-textual">streaming route</textual></emphasis><textual class="po-textual">.
        This rule is relaxed in the case where the template contains a conditional instruction such
        as </textual><code class="po-atom e322 e322"><textual class="po-textual">xsl:choose</textual></code><textual class="po-textual">; in this case each branch of the conditional may make downwards
        selections. Unlike the XSLT 2.1 draft, Saxon does not currently allow a node in the streamed
        input document to be bound to a variable, or passed as a parameter to another template or
        function. A further rule is that the template must not return a node in the streamed
        document (for example, </textual><code class="po-atom e323 e323"><textual class="po-textual">&lt;xsl:sequence select="."/&gt;</textual></code><textual class="po-textual">) - this is because there
        is no way of analyzing what the caller attempts to do with such a node.</textual></para><para class="po-block e324 e324"><textual class="po-textual">It is also possible, of course, for the template rule to make no downward selection at all: this results in the subtree
        below the matched node being skipped.</textual></para><para class="po-block e325 e325"><textual class="po-textual">All the expressions that appear on the streaming route must be capable of push
        evaluation, that is, they must have an implementation that is event-driven. Saxon supports
        push evaluation at two different levels of granularity (</textual><xref class="po-milestone e326 e326" linkend="Kay2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
        parse-event granularity and item granularity; the corresponding event streams are referred
        to respectively as decomposed or composed streams. In the first case the expression
        evaluator is notified every time a parse event occurs (for example, startElement and
        endElement). In the second case, it is notified only for complete XDM items (nodes or atomic
        values). The </textual><code class="po-atom e327 e327"><textual class="po-textual">sum()</textual></code><textual class="po-textual"> function supports push evaluation at the item level, which
        means that given the expression </textual><code class="po-atom e328 e328"><textual class="po-textual">sum(.//value)</textual></code><textual class="po-textual">, each descendant
          </textual><code class="po-atom e329 e329"><textual class="po-textual">value</textual></code><textual class="po-textual"> element is assembled as a complete node, which is then atomized, and
        the resulting atomic values are notified one by one to the sum implementation, which adds
        each one in turn to the running total. By constrast, the functions </textual><code class="po-atom e330 e330"><textual class="po-textual">count()</textual></code><textual class="po-textual"> and
          </textual><code class="po-atom e331 e331"><textual class="po-textual">exists()</textual></code><textual class="po-textual"> have implementations that work at the parse-event level, which means
        that there is no need to build the nodes being counted as trees in memory: thus
          </textual><code class="po-atom e332 e332"><textual class="po-textual">count(.//employee)</textual></code><textual class="po-textual"> merely tallies the startElement events that match its
        argument expression </textual><code class="po-atom e333 e333"><textual class="po-textual">.//employee</textual></code><textual class="po-textual"> without ever building a tree representation of
        an </textual><code class="po-atom e334 e334"><textual class="po-textual">employee</textual></code><textual class="po-textual"> element.</textual></para><para class="po-block e335 e335"><textual class="po-textual">A push component that takes a composed stream (XDM items) as input is referred to as a </textual><emphasis class="po-inline e336 e336" role="ital"><textual class="po-textual">feed</textual></emphasis><textual class="po-textual">; an evaluator 
        that works on a decomposed stream (parse events) is referred to as a </textual><emphasis class="po-inline e337 e337" role="ital"><textual class="po-textual">watch</textual></emphasis><textual class="po-textual">. This classification
        is based on the nature of the input stream. Orthogonally, the component may deliver its result as either a composed or
        decomposed stream: so there are four categories overall: a composing and decomposing Watch, and a composing and decomposing Feed.
        Examples of the four categories are shown in the table below:
      </textual></para><table class="po-container e338 e338"><thead class="po-container e339 e339"><tr class="po-table e340 e340"><th class="po-field e341 e341"><textual class="po-textual">Input/Output</textual></th><th class="po-field e342 e342"><textual class="po-textual">Composed</textual></th><th class="po-field e343 e343"><textual class="po-textual">Decomposed</textual></th></tr></thead><tbody class="po-table e344 e344"><tr class="po-table e345 e345"><td class="po-block e346 e346"><textual class="po-textual">Composed</textual></td><td class="po-block e347 e347"><textual class="po-textual">remove($in, 3)</textual></td><td class="po-block e348 e348"><textual class="po-textual">&lt;e&gt;{$in}&lt;/e&gt;</textual></td></tr><tr class="po-table e349 e349"><td class="po-block e350 e350"><textual class="po-textual">Decomposed</textual></td><td class="po-block e351 e351"><textual class="po-textual">data($in)</textual></td><td class="po-block e352 e352"><textual class="po-textual">&lt;xsl:for-each select="$in"/&gt;</textual></td></tr></tbody></table><para class="po-block e353 e353"><textual class="po-textual">In general, the flow is that decomposed events arrive from the source XML parser. After
        some processing they are turned into composed items; these are then further processed, and
        eventually decomposed into events to be sent to the serializer. To make this more concrete
        consider the streaming template:</textual></para><programlisting class="po-block e354 e354" xml:space="preserve"><textual class="po-textual">
        &lt;xsl:template match="emp"&gt;
          &lt;employee name="{@name}" nr="{@empNr}"&gt;
            &lt;xsl:value-of select="distinct-values(skills/skill)"/&gt;
          &lt;/employee&gt;
        &lt;/xsl:template&gt;
        </textual></programlisting><para class="po-block e355 e355"><textual class="po-textual">The streaming route here contains a literal result element (</textual><code class="po-atom e356 e356"><textual class="po-textual">employee</textual></code><textual class="po-textual">), the
          </textual><code class="po-atom e357 e357"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> instruction, the </textual><code class="po-atom e358 e358"><textual class="po-textual">distinct-values()</textual></code><textual class="po-textual"> function call,
        and the path expression </textual><code class="po-atom e359 e359"><textual class="po-textual">skills/skill</textual></code><textual class="po-textual">. It also contains expressions added by the
        compiler, reflecting the implicit atomization and type checking performed by the
          </textual><code class="po-atom e360 e360"><textual class="po-textual">distinct-values()</textual></code><textual class="po-textual"> function, and the implicit call on
          </textual><code class="po-atom e361 e361"><textual class="po-textual">string-join()</textual></code><textual class="po-textual"> that is performed to insert separator spaces on behalf of the
          </textual><code class="po-atom e362 e362"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> instruction. The full expression tree is shown in Figure 3, with
          the streaming route highlighted.</textual></para><figure class="po-container e363 e363" xml:id="fig03"><title class="po-block e364 e364"><textual class="po-textual">Figure 3: The expression tree of a template, showing the streaming route</textual></title><mediaobject class="po-container e365 e365"><imageobject class="po-container e366 e366"><imagedata class="po-meta e367 e367" fileref="../../../vol5/graphics/Kay01/Kay01-003.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">The expression tree omits some nodes, for example type-checking operators, for clarity. The
          highlighted "path" node acts as the Watch, looking for events coming from the parser that match the
          pattern </textual><code class="po-atom e370 e370"><textual class="po-textual">skills/skill</textual></code><textual class="po-textual">. The </textual><code class="po-atom e371 e371"><textual class="po-textual">data()</textual></code><textual class="po-textual"> node composes these events into strings
          representing the typed value of the </textual><code class="po-atom e372 e372"><textual class="po-textual">skill</textual></code><textual class="po-textual"> elements; these are fed through the operators
          found on the streaming route until they reach the </textual><code class="po-atom e373 e373"><textual class="po-textual">&lt;employee&gt;</textual></code><textual class="po-textual"> element
          constructor, which delivers a stream of events representing the newly constructed element. Typically
          these events go straight to the serializer. The parts of the expression tree that are not on the streaming
          route (the two attribute constructors) are evaluated in pull-mode as normal.</textual></para></caption></figure><para class="po-block e374 e374"><textual class="po-textual">The </textual><code class="po-atom e375 e375"><textual class="po-textual">distinct-values()</textual></code><textual class="po-textual"> function implicitly atomizes its input. So the first
        thing that happens to the incoming data is that it is sent to a TypedValueWatch: this takes
        in a decomposed sequence of events and outputs a composed sequence of atomic values
        representing the typed values of the </textual><code class="po-atom e376 e376"><textual class="po-textual">skill</textual></code><textual class="po-textual"> elements. This is piped into a type
        checker that checks that the values in this sequence are all strings. The type-checked
        csequence is then piped into the component that evaluates the </textual><code class="po-atom e377 e377"><textual class="po-textual">distinct-values()</textual></code><textual class="po-textual">
        function, which again outputs a composed stream (this being identical to its input stream
        except that values are removed from the stream if they have been encountered before). The
          </textual><code class="po-atom e378 e378"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> instruction is initially compiled into a pipeline of primitive
        instructions that first joins adjacent text nodes, then atomizes, then inserts separators
        between adjacent strings, then converts the resulting string to a text node; in this case
        the optimizer knows from type analysis that the first two steps are superfluous, so we are
        left with a pipeline that takes a composed sequence of strings as its input, and produces a
        composed sequence comprising a single text node as its output. Finally, the component
        representing the literal result element </textual><code class="po-atom e379 e379"><textual class="po-textual">employee</textual></code><textual class="po-textual"> takes this composed input, and
        produces decomposed output consisting of a startElement event, two attribute events, a text
        node event, and an endElement event. Typically these events will be sent directly to the
        serializer.</textual></para><para class="po-block e380 e380"><textual class="po-textual">An expression, of course, may have more than one sub-expression, and it may be capable
        of push evaluation in respect of some of those sub-expressions but not others. All
        expressions support push evaluation in respect of sub-expressions that are singletons
        (cardinality zero-or-one). Thus, for example, the expression </textual><code class="po-atom e381 e381"><textual class="po-textual">(sum(.//value) +
          1)</textual></code><textual class="po-textual"> is streamable, because although there is no specific support for evaluating the
        addition in push mode, the system is capable of constructing the two singleton arguments and
        using the conventional pull-mode addition. Many expressions also benefit from a generic
        implementation in cases where an argument is a non-singleton sequence. This generic
        implementation buffers the argument sequence in memory and then uses the pull-mode
        implementation once the sequence is complete. This of course is not pure streaming, but it
        provides useful scaffolding to enable less commonly used expressions to appear in a
        streaming template while awaiting a pure streaming implementation. Currently this mechanism
        is used for comparison expressions such as </textual><code class="po-atom e382 e382"><textual class="po-textual">.//value = 17</textual></code><textual class="po-textual"> (recall that in XPath,
        this returns true if at least one of the </textual><code class="po-atom e383 e383"><textual class="po-textual">value</textual></code><textual class="po-textual"> elements is equal to 17); there
        is no technical reason that prevents the creation of a pure push-mode implementation of a
        general comparison expression with respect to either argument, but it has not yet been
        implemented, and it is not a top priority because in the vast majority of cases the
        arguments actually turn out to be singletons.</textual></para><para class="po-block e384 e384"><textual class="po-textual">The compile-time template inversion process operates by means of a recursive walk of the
        expression tree. At every level there must be at most one branch that performs downward
        selection; this branch is taken, and by this means the streaming route is identified. The
        process then attempts to identify the longest suffix of the streaming route that constitutes
        a streamable pattern. For example, if the body of the template is </textual><code class="po-atom e385 e385"><textual class="po-textual">&lt;xsl:value-of
          select="sum(.//value) + 1"/&gt;</textual></code><textual class="po-textual">, the streamable pattern is </textual><code class="po-atom e386 e386"><textual class="po-textual">.//value</textual></code><textual class="po-textual">. The
        immediate parent of this pattern on the streaming route must always be an expression that
        can be evaluated as a Watch. The number of expressions implemented as a Watch is suprisingly
        small:</textual></para><itemizedlist class="po-table e387 e387"><listitem class="po-container e388 e388"><para class="po-block e389 e389"><code class="po-atom e390 e390"><textual class="po-textual">TypedValueWatch</textual></code><textual class="po-textual"> handles all expressions that use the atomized value of the
            selected nodes.</textual></para></listitem><listitem class="po-container e391 e391"><para class="po-block e392 e392"><code class="po-atom e393 e393"><textual class="po-textual">StringValueWatch</textual></code><textual class="po-textual"> handles all expressions that use the string value of the
            selected nodes.</textual></para></listitem><listitem class="po-container e394 e394"><para class="po-block e395 e395"><code class="po-atom e396 e396"><textual class="po-textual">CountWatch</textual></code><textual class="po-textual"> handles the </textual><code class="po-atom e397 e397"><textual class="po-textual">count()</textual></code><textual class="po-textual">, </textual><code class="po-atom e398 e398"><textual class="po-textual">exists()</textual></code><textual class="po-textual">, and
              </textual><code class="po-atom e399 e399"><textual class="po-textual">empty()</textual></code><textual class="po-textual"> functions.</textual></para></listitem><listitem class="po-container e400 e400"><para class="po-block e401 e401"><code class="po-atom e402 e402"><textual class="po-textual">CopyWatch</textual></code><textual class="po-textual"> (the one we met earlier) handles </textual><code class="po-atom e403 e403"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e404 e404"><para class="po-block e405 e405"><code class="po-atom e406 e406"><textual class="po-textual">VoidWatch</textual></code><textual class="po-textual"> is used for templates or branches of a conditional that make no
            downwards selection.</textual></para></listitem><listitem class="po-container e407 e407"><para class="po-block e408 e408"><code class="po-atom e409 e409"><textual class="po-textual">SimpleContentWatch</textual></code><textual class="po-textual"> implements the rules for instructions such as
              </textual><code class="po-atom e410 e410"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> and </textual><code class="po-atom e411 e411"><textual class="po-textual">xsl:attribute</textual></code><textual class="po-textual">; specifically, it
            concatenates adjacent text nodes, removes empty text nodes, and reduces all other nodes
            to string values.</textual></para></listitem><listitem class="po-container e412 e412"><para class="po-block e413 e413"><code class="po-atom e414 e414"><textual class="po-textual">ApplyTemplatesWatch</textual></code><textual class="po-textual"> is used where the downwards selection appears in the select
            expression of an </textual><code class="po-atom e415 e415"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> instruction, and also supports
              </textual><code class="po-atom e416 e416"><textual class="po-textual">xsl:apply-imports</textual></code><textual class="po-textual"> and </textual><code class="po-atom e417 e417"><textual class="po-textual">xsl:next-match</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e418 e418"><para class="po-block e419 e419"><code class="po-atom e420 e420"><textual class="po-textual">ForEachWatch</textual></code><textual class="po-textual"> is used where the downwards selection appears in the select
            expression of an </textual><code class="po-atom e421 e421"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> instruction.</textual></para></listitem></itemizedlist><para class="po-block e422 e422"><textual class="po-textual">Most of these Watch implementations are composing: they emit a sequence of XDM items. 
        The two exceptions are the </textual><code class="po-atom e423 e423"><textual class="po-textual">ForEachWatch</textual></code><textual class="po-textual"> and the </textual><code class="po-atom e424 e424"><textual class="po-textual">ApplyTemplatesWatch</textual></code><textual class="po-textual">, which
        emit a sequence of parse events.</textual></para><para class="po-block e425 e425"><textual class="po-textual">We have already seen the </textual><code class="po-atom e426 e426"><textual class="po-textual">CopyWatch</textual></code><textual class="po-textual"> earlier in the paper: it is used for a
        simple streaming copy, as well as for </textual><code class="po-atom e427 e427"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual"> instructions appearing within
        a streaming template. When it receives a startElement event representing an element selected
        by its controlling pattern (we'll assume to keep things simple that it is watching for
        elements), it starts building a tree. All subsequent parse events until the matching
        endElement are directed to this tree builder. When the tree is complete, the node at the
        root of the tree is emitted to the Feed that implements the parent of the
          </textual><code class="po-atom e428 e428"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual"> instruction, that is, the parent expression in the streaming
        route through the expression tree. </textual></para><para class="po-block e429 e429"><textual class="po-textual">The </textual><code class="po-atom e430 e430"><textual class="po-textual">StringValueWatch</textual></code><textual class="po-textual"> and </textual><code class="po-atom e431 e431"><textual class="po-textual">TypedValueWatch</textual></code><textual class="po-textual"> work in a very
        similar way, except that instead of building a tree from the incoming events, they construct
        the string value or typed value of the node by concatenating the values of those events that
        represent text nodes.</textual></para><para class="po-block e432 e432"><textual class="po-textual">All these Watch implementations have a complication that has already been mentioned for Streaming Copy: a startElement
      event for a matching element might be notified while an existing matching element is already being processed; that is, the
      pattern that the Watch matches may select a node that is a descendant of another matched node. For this reason, the Watch
      does not actually construct the tree (or string value or typed value) directly; instead it creates an event receiver
      dedicated to this task, which it passes back to the WatchManager; the WatchManager then notifies all events to all active
      event receivers to do the necessary work, taking care of deactivating them when needed. When the endElement event occurs,
      the Watch passes the constructed tree to the next Feed in the streaming route only if the matched element has no matching
      ancestors; for an inner matched node, the tree is held in a queue until the outer tree is complete, since the outer tree
      comes first in document order and must therefore be notified to the waiting Feed before the inner trees. This queue
      again represents a departure from pure streaming; the XSLT 2.1 draft has an open issue on this question.</textual></para><para class="po-block e433 e433"><textual class="po-textual">The </textual><code class="po-atom e434 e434"><textual class="po-textual">ApplyTemplatesWatch</textual></code><textual class="po-textual"> is similarly notified of the startElement event for
        a node that matches the select expression of the </textual><code class="po-atom e435 e435"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual">
        instruction. It responds to this by searching for a matching template rule â this is
        possible because the constraints on match patterns in a streamable template ensure that the
        pattern can be evaluated when positioned at the startElement event (the object representing
        the event, it should be mentioned, provides methods to get local properties of the node such
        as the name and type annotation, and also to navigate to the node's ancestors and their
        attributes). Having identified the template to be applied, which because it is in a
        streaming mode will always have been compiled with template inversion, it then gets the
        Watch expression identified during the analysis of the called template, and nominates this
        Watch expression to the WatchManager. All events up to the corresponding endElement will
        therefore be sent by the WatchManager to the called template, where the same process
        continues recursively. At the same time, the same events are being sent to the calling
          </textual><code class="po-atom e436 e436"><textual class="po-textual">ApplyTemplatesWatch</textual></code><textual class="po-textual">, because as with </textual><code class="po-atom e437 e437"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual">, it is entirely
        possible for the </textual><code class="po-atom e438 e438"><textual class="po-textual">select</textual></code><textual class="po-textual"> expression of </textual><code class="po-atom e439 e439"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> to
        select an element that is a descendant of another element already being processed; the
        results of the processing of such nested elements will again be buffered.</textual></para><para class="po-block e440 e440"><textual class="po-textual">The </textual><code class="po-atom e441 e441"><textual class="po-textual">ForEachWatch</textual></code><textual class="po-textual"> operates in a very similar way to the
          </textual><code class="po-atom e442 e442"><textual class="po-textual">ApplyTemplatesWatch</textual></code><textual class="po-textual">, except that there is no need to search for a matching
        template. Rather, the body of the </textual><code class="po-atom e443 e443"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> instruction is compiled directly
        as an inverted template and is invoked unconditionally for each startElement event matching
        a selected node.</textual></para><para class="po-block e444 e444"><textual class="po-textual">A similar streaming implementation has been written for </textual><code class="po-atom e445 e445"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">; none
        is yet available for </textual><code class="po-atom e446 e446"><textual class="po-textual">xsl:for-each-group</textual></code><textual class="po-textual">, but it is expected that it will follow
        the same principles.</textual></para></section></section><section class="po-hcontainer e447 e447"><title class="po-block e448 e448"><textual class="po-textual">Conclusions</textual></title><para class="po-block e449 e449"><textual class="po-textual">Streaming of XSLT transformations has long been an aspiration, and many partial solutions have
  been developed over the years. It has proved difficult or impossible to create streaming implementations
  of the full XSLT language as defined by W3C.</textual></para><para class="po-block e450 e450"><textual class="po-textual">The draft XSLT 2.1 specification has been developed as a solution to this problem. It
      defines a subset of the full XSLT language that is intended to be streamable without requiring
      unknown magic on the part of the implementation, and at the same time it provides extensions
      to the language (such as </textual><code class="po-atom e451 e451"><textual class="po-textual">xsl:iterate</textual></code><textual class="po-textual">) that make it possible to write powerful
      transformations without straying from the streamable subset. The design of the language is
      informed by experience with both XSLT 2.0 and STX, and by a large collection of use cases
      describing problems that benefit from a streamed implementation.</textual></para><para class="po-block e452 e452"><textual class="po-textual">Successive releases of Saxon, some predating this work and some influenced by it, have provided partial
  solutions to the streaming challenge with increasing levels of sophistication. At the time of writing, there are
  many ideas in the specification that are not yet implemented in Saxon, and there are some features in the Saxon
  implementation that are not yet reflected in the specification. Nevertheless, development of the language
  standard and of an industrial implementation are proceeding in parallel, which is always a promising indicator
  that standards when they arrive will be timely and viable. Both the language and the implementation, however,
  still need a lot more work.</textual></para><para class="po-block e453 e453"><textual class="po-textual">Saxon's approach to the problem is based on using a push architecture end-to-end, to eliminate the
  source tree as an intermediary between push-based XML parsing/validation and pull-based XPath processing.
  Implementing the entire repertoire of XPath expressions and XSLT instructions in an event-based pipeline
  is challenging, to say the least. However, enough has been completed to show that the undertaking is viable,
  and a large enough subset is already available to users to enable some serious large-scale transformation
  tasks to be performed.</textual></para></section><bibliography class="po-hcontainer e454 e454"><title class="po-block e455 e455"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e456 e456" xml:id="Barton2003" xreflabel="Barton2003"><textual class="po-textual">Charles Barton et al.
    An Algorithm for Streaming XPath Processing with Forward and Backward Axes.
    In Proc. 19 Int Conf Data Eng, Banagalore, India, 5-8 March 2003. ISBN: 0-7803-7665-X 
    </textual><link class="po-inline e457 e457" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.research.ibm.com/xj/pubs/icde.pdf</textual></link></bibliomixed><bibliomixed class="po-block e458 e458" xml:id="BarYossef2004" xreflabel="BarYossef2004"><textual class="po-textual">Ziv Bar-Yossef, Marcus Fontoura, and Vanja Josifovski.
    On the Memory Requirements of XPath Evaluation over XML Streams.
    J Comp Sys Sci Vol 73 Iss 3 pp 391-441, May 2007, ISSN 0022-0000 
    </textual><link class="po-inline e459 e459" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.almaden.ibm.com/cs/people/fontoura/papers/pods2004.pdf</textual></link><textual class="po-textual">.
    doi: </textual><biblioid class="po-atom e460 doi e460"><textual class="po-textual">10.1016/j.jcss.2006.10.002</textual></biblioid><textual class="po-textual">.  
  </textual></bibliomixed><bibliomixed class="po-block e461 e461" xml:id="Cimprich2010" xreflabel="Cimprich2010"><textual class="po-textual">Petr Cimprich (ed). 
  Requirements and Use Cases for XSLT 2.1. W3C Working Draft 10 June 2010. 
    </textual><link class="po-inline e462 e462" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt-21-requirements/</textual></link></bibliomixed><bibliomixed class="po-block e463 e463" xml:id="CityGML" xreflabel="CityGML"><textual class="po-textual">Exchange and Storage of Virtual 3D City Models.
    Thomas H Kolbe (ed). </textual><link class="po-inline e464 e464" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.citygml.org/</textual></link><textual class="po-textual">. Retrieved 2010-07-10.</textual></bibliomixed><bibliomixed class="po-block e465 e465" xml:id="Dvorakova2008" xreflabel="Dvirakova2008"><textual class="po-textual">Jana DvoÅÃ¡kovÃ¡.
    A Formal Framework for Streaming XML Transformations.
    PhD Thesis, Comenius University, Bratislava, Slovenia, 2008.
  </textual></bibliomixed><bibliomixed class="po-block e466 e466" xml:id="Dvorakova2009a" xreflabel="Dvorakova2009a"><textual class="po-textual">Jana DvoÅÃ¡kovÃ¡.
    Automatic Streaming Processing of XSLT Transformations Based on Tree Transducers.
    Informatica: An International Journal of Computing and Informatics, 
    Special Issue - Intelligent and Distributed Computing, Slovene Society Informatika, 2009   
  </textual></bibliomixed><bibliomixed class="po-block e467 e467" xml:id="Dvorakova2009b" xreflabel="Dvorakova2009b"><textual class="po-textual">Jana DvoÅÃ¡kovÃ¡ and F Zavoral.
    Using Input Buffers for Streaming XSLT Processing, 
    Proceedings of the International Conference on Advances in Databases - GlobeNet/DB 2009, 
    Gosier, IEEE Computer Society Press, 2009.
    doi: </textual><biblioid class="po-atom e468 doi e468"><textual class="po-textual">10.1109/DBKDA.2009.25</textual></biblioid><textual class="po-textual">.  
  </textual></bibliomixed><bibliomixed class="po-block e469 e469" xml:id="Florescu2003" xreflabel="Florescu2003"><textual class="po-textual">Daniela Florescu et al.
    The BEA/XQRL Streaming XQuery Processor. In Proc. 29 VLDB, 2003, Berlin, Germany, pp 997-1008. ISBN:0-12-722442-4
    </textual><link class="po-inline e470 e470" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.vldb.org/conf/2003/papers/S30P01.pdf</textual></link></bibliomixed><bibliomixed class="po-block e471 e471" xml:id="Frisch2007" xreflabel="Frisch2007"><textual class="po-textual">Alain Frisch and Keisuke Nakano. Streaming
      XML transformations using term rewriting. PLAN-X 2007 Nice, France, 20 Jan 2007 pp 2-13.
        </textual><link class="po-inline e472 e472" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://yquem.inria.fr/~frisch/xstream/long.pdf</textual></link><textual class="po-textual">
  </textual></bibliomixed><bibliomixed class="po-block e473 e473" xml:id="GML"><textual class="po-textual">OpenGIS Geography Markup Language (GML) Encoding Standard.
    OGC (Open Geospatial Consortium). </textual><link class="po-inline e474 e474" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.opengeospatial.org/standards/gml</textual></link><textual class="po-textual">. Retrieved 2010-07-10.</textual></bibliomixed><bibliomixed class="po-block e475 e475" xml:id="Guo2004" xreflabel="Guo2004"><textual class="po-textual">Zhimao Guo, Min Li, Xiaoling Wang, and Aoying Zhou.
    Scalable XSLT Evaluation. In Proc 6 Asia-Pacific Web Conf, Hangzhou, China, 14-17 April 2004. ISBN 3-540-21371-6
    </textual><link class="po-inline e476 e476" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://arxiv.org/pdf/cs.DB/0408051</textual></link></bibliomixed><bibliomixed class="po-block e477 e477" xml:id="Kay2009" xreflabel="Kay2009"><textual class="po-textual">Michael Kay.
    You Pull, Iâll Push: on the Polarity of Pipelines.
    Presented at Balisage: The Markup Conference 2009, MontrÃ©al, Canada, August 11 - 14, 2009.
    In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009).
    doi: </textual><biblioid class="po-atom e478 doi e478"><textual class="po-textual">10.4242/BalisageVol3.Kay01</textual></biblioid><textual class="po-textual">.
  </textual></bibliomixed><bibliomixed class="po-block e479 e479" xml:id="Kay2010a" xreflabel="Kay2010a"><textual class="po-textual">Michael Kay.
  Streaming in XSLT 2.1. 
  Proc XML Prague 2010. 13-14 March 2010, Prague, Czech Rep.
    </textual><link class="po-inline e480 e480" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2010/files/XMLPrague_2010_Proceedings.pdf</textual></link></bibliomixed><bibliomixed class="po-block e481 e481" xml:id="Kay2010b" xreflabel="Kay2010b"><textual class="po-textual">Michael Kay (ed). XSL Transformations (XSLT) Version 2.1.
    W3C Working Draft 11 May 2010. </textual><link class="po-inline e482 e482" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt-21/</textual></link><textual class="po-textual">. </textual></bibliomixed><bibliomixed class="po-block e483 e483" xml:id="Li2005" xreflabel="Li2005"><textual class="po-textual">Xiaogang Li and Gagan Agrawal.
    Efficient evaluation of XQuery over streaming data. 
    In Proc. 31 VLDB, 2005, Trondheim, Norway, pp 265-276. ISBN 1-59593-154-6
    </textual><link class="po-inline e484 e484" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.vldb2005.org/program/paper/wed/p265-li.pdf</textual></link></bibliomixed><bibliomixed class="po-block e485 e485" xml:id="Joshi" xreflabel="Joshi"><textual class="po-textual">Amruta Joshi and Oleg Slezburg.
    CS276B Project Report: Streaming XPath Engine. Undated. </textual><link class="po-inline e486 e486" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www-cs-students.stanford.edu/~amrutaj/work/papers/xpath.pdf</textual></link><textual class="po-textual">
    Retrieved 2010-04-12</textual></bibliomixed><bibliomixed class="po-block e487 e487" xml:id="Saxonica" xreflabel="Saxonica"><textual class="po-textual">The Saxon XSLT and XQuery Processor.
    </textual><link class="po-inline e488 e488" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.saxonica.com/</textual></link><textual class="po-textual"> Retrieved 2010-07-10.</textual></bibliomixed><bibliomixed class="po-block e489 e489" xml:id="STX" xreflabel="STX"><textual class="po-textual">Streaming Transformations for XML (STX).
    </textual><link class="po-inline e490 e490" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://stx.sourceforge.net/</textual></link><textual class="po-textual"> Retrieved 2010-07-10. Contains links to articles and presentations by Tobias Trapp,
    Oliver Becker, and Petr Cimprich.</textual></bibliomixed><bibliomixed class="po-block e491 e491" xml:id="Zergaoui2009" xreflabel="Zergaoui2009"><textual class="po-textual">Mohamed Zergaoui. Memory management in
      streaming: Buffering, lookahead, or none. Which to choose? Int Symp on Processing XML
      Efficiently. 10 Aug 2009, Montreal, Canada. Balisage Series on Markup Technologies, vol. 4
      (2009). doi: </textual><biblioid class="po-atom e492 doi e492"><textual class="po-textual">10.4242/BalisageVol4.Zergaoui02</textual></biblioid><textual class="po-textual">.
        </textual><link class="po-inline e493 e493" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol4/html/Zergaoui02/BalisageVol4-Zergaoui02.html</textual></link><textual class="po-textual">
    </textual></bibliomixed></bibliography></article></classedDocument>