<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Axioms of Versioning</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">International Symposium on Versioning XML Vocabularies and Systems</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 11, 2008</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">The problems of language versioning can be better understood with the help of some formal axioms defining the relations among the extensions and semantics of languages. Such axioms allow us to specify what makes one language extensionally, syntactically, or semantically a subset, superset, or equivalent of another. The difference between syntactic and semantic compatibility makes clear how languages can grow in a forward-compatible way. The key to compatible versioning is to assign new semantics in the new version of a language for syntax that was already accepted in the prior version, but to which the prior version assigned no semantics.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Marc</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">de Graauw</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Marc de Graauw is an independent consultant and has worked in IT for 20 years; as an IT architect, he has contributed to digital exchanges in health care, criminal justice, insurance and social security. Marc is a frequent speaker at international conferences and regularly writes articles on health care, versioning and REST-vs-SOA. He lives and works in Amsterdam, the Netherlands.</textual></para></personblurb><affiliation class="po-record e14 e14"><orgname class="po-block e15 e15"><textual class="po-textual">Independent</textual></orgname></affiliation><email class="po-field e16 e16"><textual class="po-textual">marc@marcdegraauw.com</textual></email></author><legalnotice class="po-container e17 e17"><para class="po-block e18 e18"><textual class="po-textual">Copyright Marc de Graauw.  This work is licensed under a Creative Commons Attribution-No Derivative Works 3.0 Unported License.</textual></para></legalnotice><keywordset class="po-table e19 e19" role="author"><keyword class="po-field e20 e20"><textual class="po-textual">versioning</textual></keyword><keyword class="po-field e21 e21"><textual class="po-textual">semantics</textual></keyword><keyword class="po-field e22 e22"><textual class="po-textual">compatibility</textual></keyword></keywordset></info><section class="po-hcontainer e23 e23"><title class="po-block e24 e24"><textual class="po-textual">Introduction</textual></title><para class="po-block e25 e25"><textual class="po-textual">What is compatibility anyway? What does it mean when we say a version of a language is
         backward and/or forward compatible with another language? What does it mean when we say this
         of a document, or message, or schema, or an application? Does the notion of compatibility
         apply to languages at all, or does it only apply to documents or applications? And what is
         the difference between syntactical an semantical compatibility? </textual></para><para class="po-block e26 e26"><textual class="po-textual">Questions like these have lead me to explore the notion of compatibility in a more formal
         way. For efforts in achieving back- and forward compatibility in real life applications, a
         framework for understanding key notions in compatible versioning can be very useful. Key to
         understanding the working of advanced compatibility mechanisms is the semantical equivalence
         set. In this paper we shall define what it is, and explain why this notion is central to
         understanding compatibility.</textual></para><para class="po-block e27 e27"><textual class="po-textual">I will focus on message exchanges, since that is my main area of expertise, but the
         principles apply much wider. In general, they should apply to most computer-understandable
         document formats for data storage and/or exchange. More specific, I do not intend to cover
         natural language, other non-computer languages, programming languages or specifically
         multi-document data stores such as databases.</textual></para></section><section class="po-hcontainer e28 e28"><title class="po-block e29 e29"><textual class="po-textual">Languages, Sets and Extensions</textual></title><para class="po-block e30 e30"><textual class="po-textual">Consider a set U of language specifications in the above field. </textual></para><para class="po-block e31 e31"><textual class="po-textual">It's easy to define for each language specification the set of conforming document
         instances extensionally, as a set. For instance, the extension of UBL 1.0 is the set of all
         possible conforming UBL 1.0 instances, or the extension of HL7v3, May 2007 ballot is the set
         of all possible conforming HL7v3, May 2007 instances. (Often, language specifications for
         message exchange have many flavors and variations. HL7v3 has many versions ("ballots") and
         even those are hardly ever implemented as they are, but instead are localized to a
         particular national environment before implementation.) </textual></para><figure class="po-container e32 e32" floatstyle="1" xml:id="Bal2008graa030601" xreflabel="Bal2008graa030601"><mediaobject class="po-container e33 e33"><imageobject class="po-container e34 e34"><imagedata class="po-meta e35 e35" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-001.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual">Extension ELx of a Language</textual></para></caption></mediaobject></figure><para class="po-block e38 e38"><textual class="po-textual">If we show this pictorially, we get the above figure. Lx is a language specification which
         has all blue rectangles as conforming documents. The extension of Lx, ELx, are all blue
         rectangles. The complement (everything not in ELx) are all non-rectangular blue shapes, and
         all shapes in other colors.</textual></para><figure class="po-container e39 e39" floatstyle="1" xml:id="Bal2008graa030602" xreflabel="Bal2008graa030602"><mediaobject class="po-container e40 e40"><imageobject class="po-container e41 e41"><imagedata class="po-meta e42 e42" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-002.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">ELx as Subset of ELy</textual></para></caption></mediaobject></figure><para class="po-block e45 e45"><textual class="po-textual">The extension of the language Ly consisting of all rectangles in any color is a superset
         of the extension of Lx; for shorthand, we say Ly is a superlanguage of Lx.</textual></para><figure class="po-container e46 e46" floatstyle="1" xml:id="Bal2008graa030603" xreflabel="Bal2008graa030603"><mediaobject class="po-container e47 e47"><imageobject class="po-container e48 e48"><imagedata class="po-meta e49 e49" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-003.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e50 e50"><para class="po-block e51 e51"><textual class="po-textual">ELx as Subset of ELz</textual></para></caption></mediaobject></figure><para class="po-block e52 e52"><textual class="po-textual">Likewise, Lz, the language of all blue shapes, is a superlanguage of Lx.</textual></para><figure class="po-container e53 e53" floatstyle="1" xml:id="Bal2008graa030604" xreflabel="Bal2008graa030604"><mediaobject class="po-container e54 e54"><imageobject class="po-container e55 e55"><imagedata class="po-meta e56 e56" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-004.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e57 e57"><para class="po-block e58 e58"><textual class="po-textual">ELx as Intersection of ELz and ELy</textual></para></caption></mediaobject></figure><para class="po-block e59 e59"><textual class="po-textual">And Lx is (extensionally) also the intersection of Ly and Lz.</textual></para><para class="po-block e60 e60"><textual class="po-textual">Starting with a rather loose notion of "conformance" (let's assume for the moment this
         notion is unproblematic) it's easy to define relation between languages extensionally. A
         language Lx can be an extensional sublanguage of Ly: if every document conforming to Lx is
         also a conforming Ly document. If the reverse is true, all conforming Ly documents are also
         conforming Lx documents, Lx is an extensional superlanguage of Ly. If both are true, Lx and
         Ly are extensionally equivalent. Note that we only speak of extensional equivalence: for all
         we know, Lx may be about pasta recipes and Ly about reggae albums: if by some weird
         happenstance both languages have encoded their information in similar data formats, we can
         still compare the pasta and reggae languages extensionally.</textual></para></section><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">Accepting and Rejecting Documents</textual></title><figure class="po-container e63 e63" floatstyle="1" xml:id="Bal2008graa030605" xreflabel="Bal2008graa030605"><mediaobject class="po-container e64 e64"><imageobject class="po-container e65 e65"><imagedata class="po-meta e66 e66" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-005.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">Accept and Reject Behavior of Px</textual></para></caption></mediaobject></figure><para class="po-block e69 e69"><textual class="po-textual">Applications can read and write (produce and consume, send and receive) documents. For now
         we still suppose an application reads and writes the same set of documents. In the above
         picture, the implementation Px1 of language Lx accepts all blue rectangles (ELx), and
         rejects all other documents. So through accepting and rejecting, Px1 decides which documents
         are syntactically conformant with Lx (as implemented in Px1).</textual></para></section><section class="po-hcontainer e70 e70"><title class="po-block e71 e71"><textual class="po-textual">From Syntax to Semantics</textual></title><para class="po-block e72 e72"><textual class="po-textual">When we move from pure extensions, we must consider the semantics of a language. This is a
         difficult notion. At one extreme, a language may not consider semantics at all, and just
         define a syntactical data format, and leave all semantics up to applications. It's often
         said that "XML is just syntax". But if this is true, XML itself is not very interesting, and
         the real-world applications of XML, such as in UBL or HL7v3, certainly must include some
         semantics. At its highest level, those semantics are descriptions in natural language,
         defining for instance what an invoice or a medication prescription is. At a lower level,
         those semantics may be expressed in more formal ways. </textual></para><para class="po-block e73 e73"><textual class="po-textual">One way to (try to) express the semantics of messages in a messaging system with respect
         to forward and backward compatibility is to use formal semantics. This is – in my opinion –
         the wrong way. For simple (abstracted, theoretical) systems this might work. One would have
         to model the system and the encapsulated exchanged information using a language such as OWL.
         For real life purposes, this is hardly feasible. To make an OWL description of the
         underlying semantics of UBL or HL7v3 is a (much) larger undertaking than specifying a decent
         versioning mechanism to provide back- and forward compatibility to a reasonable degree: so
         using formal semantics to provide a framework and definitions for the notion of
         compatibility defeats the problem.</textual></para></section><section class="po-hcontainer e74 e74"><title class="po-block e75 e75"><textual class="po-textual">Semantics and Behavior</textual></title><para class="po-block e76 e76"><textual class="po-textual">A language specification of the kind under consideration should enable a capable engineer
         to implement a conforming application: an application which presumably can read an write
         conforming documents (let's assume for the moment the application can read every document it
         writes and vice versa). The application as a total then exhibits some behavior: if we use a
         word processor to read a document, we expect the word processor to display the stored text
         and formatting. If we use a medical application to send a prescription, we expect the
         receiving application to display the intended medication and applicable quantity and dosage. </textual></para><para class="po-block e77 e77"><textual class="po-textual">Languages may not define behavior very strictly. HL7v3 even goes at great length to stress
         is does not restrict application behavior at all, but I do not think this really holds.
         Obviously there are a great deal of application behaviors which are at odds with HL7v3
         specifications, such as displaying pasta recipes instead of medication prescriptions.</textual></para><para class="po-block e78 e78"><textual class="po-textual">The behavior of a message endpoint is not unproblematic. It's usually best to consider
         some message endpoint to a certain degree as a black box; to consider only what's going in
         and coming out, not what is inside. How it works is not relevant; what it does is relevant.
         But when sending messages, there often is no direct behavior (no response) associated. When
         I send you a message with my new home address, I may expect no response (or just a simple
         ask). I do expect future mail to be delivered to my new home address, however. the point is,
         there may never be new mail to me, so there may never be a response message showing the
         desired behavior. </textual></para><para class="po-block e79 e79"><textual class="po-textual">On a higher level, the behavior of a corresponding message endpoint may not be
         deterministic at all. When a general physician sends a medication prescription to a
         pharmacist, the pharmacist may overrule the general physician's decision: this is an
         independent professional judgment, based on the pharmacists own competence. </textual></para><para class="po-block e80 e80"><textual class="po-textual">So the behavior of a message endpoint is not unproblematic. I believe the solution is
         basically to take humans out of the box. We must consider the behavior of a receiving
         computer system when judging the behavior for a message, not the humans interpreting and
         acting on the information. The behavior of the application is also in need of human
         interpretation. For instance, a part of a medication prescription may be:</textual></para><para class="po-block e81 e81"><code class="po-atom e82 e82"><textual class="po-textual">&lt;code code=”27” codeSystem=”2.16.840.1.113883.2.4.4.5” /&gt;</textual></code></para><para class="po-block e83 e83"><textual class="po-textual">and the receiving application may display:</textual></para><para class="po-block e84 e84"><code class="po-atom e85 e85"><textual class="po-textual">"Dissolve in water"</textual></code></para><para class="po-block e86 e86"><textual class="po-textual">which is a faithful rendering of the information sent. However, instead of "Dissolve in
         water" the receiving application may also display some local code. In general, it is not
         possible to judge whether a receiving application behaves well without the judgment of a
         professional well acquainted with the messaging framework as well as the receiving
         application.</textual></para><para class="po-block e87 e87"><textual class="po-textual">So where does this leave us with behavior as a basis for a framework for compatible
         versioning? If we take a look a practical aspects, behavior is a near perfect fit. The most
         practical aspect of a framework for compatible versioning is testing the entire messaging
         chain. And especially for this aspect, behavior as a basis for semantic compatibility is
         perfect. The fact that there may – in real life – never be a response message showing the
         desired behavior is not relevant. Relevant is the fact that such behavior is a testable
         condition of the messaging chain. In a test, we can send an "update address" message and
         next test the printing of an address label. Likewise, the fact that behavior is not
         deterministic with a human "in the box" is not a problem: in testing, we generally want a
         professional judging whether the system does what it is supposed to do. Again, behavior as a
         basis for semantic compatibility is a perfect fit. </textual></para><para class="po-block e88 e88"><textual class="po-textual">If we have a certain implementation of a language specification, the reading of a document
         should result in a changed application state: for instance, the text on the screen has
         changed, or its internal data store has been updated, resulting in specific behavior if the
         data store is later queried. Let's assume, as most often is the case, that the behavior (the
         state change) is deterministic: if the application is in the same state before reading a
         document, then reading the document always results in the same end-state.</textual></para></section><section class="po-hcontainer e89 e89"><title class="po-block e90 e90"><textual class="po-textual">Behavior of Language Processors</textual></title><figure class="po-container e91 e91" floatstyle="1" xml:id="Bal2008graa030606" xreflabel="Bal2008graa030606"><mediaobject class="po-container e92 e92"><imageobject class="po-container e93 e93"><imagedata class="po-meta e94 e94" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-006.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">Behavior of Px</textual></para></caption></mediaobject></figure><para class="po-block e97 e97"><textual class="po-textual">We can show the behavior of a processor Px1 pictorially as in the above figure: for every
         document in ELx, Px1 exhibits some particular behavior. Px1 is partitioned, as it were, in
         behavioral compartments, one for each document.</textual></para><para class="po-block e98 e98"><textual class="po-textual">Of course it is quite common for messaging systems to have different behaviors for exactly
         the same document: for instance, a common property of reliable messaging is for an order to
         be executed, and a duplicate to be rejected (unless the original was lost, which is the
         raison d'être of reliable messaging). This is no serious obstacle to the model: for testing
         purposes, it is sufficient (and desirable) to assume a fixed start state for any sequence of
         messages, which makes the responses deterministic. For real life systems, if we wanted to
         model this aspect, we could assume the behavior to be determined by the message and (some
         aspect of) the state of the processor. Like before, I believe a framework in which testable
         scenario's can be described sufficient.</textual></para><para class="po-block e99 e99"><textual class="po-textual">Next we need to make some idealizations to get rid of all the processors. We'll simply
         assume every language specification is flawless (not hard to imagine, is it?) and there is a
         perfect processor for every language; we'll take that processor as an exemplar of the
         language. And we no longer assume a processor makes the same set of documents as it accepts.</textual></para></section><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">Syntactical Compatibility</textual></title><para class="po-block e102 e102"><textual class="po-textual">This allows us to define syntactic compatibility: a (language) processor is syntactically
         compatible with another (language) processor if they are able to exchange documents without
         syntactic failure: if they are able to accept each other's documents. A common case is when
         they implement the same language (version). </textual></para><figure class="po-container e103 e103" floatstyle="1" xml:id="Bal2008graa030608" xreflabel="Bal2008graa030608"><mediaobject class="po-container e104 e104"><imageobject class="po-container e105 e105"><imagedata class="po-meta e106 e106" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-007.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e107 e107"><para class="po-block e108 e108"><textual class="po-textual">Behavior with Disjunct ELX and ELy</textual></para></caption></mediaobject></figure><para class="po-block e109 e109"><textual class="po-textual">But the processors need not produce the same documents at all. Another common case is
         where one processor makes and sends orders, but does not receive orders, and the other
         processor receives orders and makes order confirmations, but no orders. Even though the
         processors make and accept different documents, it makes perfect sense to say they are
         syntactically compatible. So we can say a processor Px is compatible with a processor Py if
         Px makes only documents which Py accepts, and Py makes only documents which Px accepts. (It
         would be more common to say Px and Py are partial implementations of one and the same
         language, but that does not change the point.</textual></para><figure class="po-container e110 e110" floatstyle="1" xml:id="Bal2008graa030609" xreflabel="Bal2008graa030609"><mediaobject class="po-container e111 e111"><imageobject class="po-container e112 e112"><imagedata class="po-meta e113 e113" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-008.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e114 e114"><para class="po-block e115 e115"><textual class="po-textual">Behavior and Forward Compatiblity of Px and Px+1</textual></para></caption></mediaobject></figure><para class="po-block e116 e116"><textual class="po-textual">For versioning, the interesting case is twofold: for backward syntactical compatibility, a
         processor Px+1 should accept all documents produced by Px. and for forward syntactical
         compatibility, a processor Px should accept all documents produced by Px+1. The above
         picture highlights one variant, where Px and Px+1 both accept the same set of documents, but
         make different sets.</textual></para><para class="po-block e117 e117"><textual class="po-textual">The accept/reject reaction to a document is fundamental to the entire compatibility and
         versioning problem. However, the accept/reject distinction is not syntactical in nature. It
         is a behavioral aspect of a processor: accepting or rejecting is a response to a document,
         it attaches meaning to the document: acceptable! (or not). So the basic aspect which decides
         syntactical conformance in a sender/receiver (writer/reader, producer/consumer)
         configuration is itself semantical in nature.</textual></para><para class="po-block e118 e118"><textual class="po-textual">The key to enhance (future) compatibility on a syntactic level is to make processor accept
         more than they produce. In other words, a processor should not reject everything it could
         not produce itself, and should not reject everything it does not completely understand.
         Next, we'll see what to do with that un-understood "extra".</textual></para></section><section class="po-hcontainer e119 e119"><title class="po-block e120 e120"><textual class="po-textual">Semantical Equivalence Sets</textual></title><figure class="po-container e121 e121" floatstyle="1" xml:id="Bal2008graa030610" xreflabel="Bal2008graa030610"><mediaobject class="po-container e122 e122"><imageobject class="po-container e123 e123"><imagedata class="po-meta e124 e124" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-009.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e125 e125"><para class="po-block e126 e126"><textual class="po-textual">Behavior of Px</textual></para></caption></mediaobject></figure><para class="po-block e127 e127"><textual class="po-textual">In the above figure, we have a processor for a language which makes only blue rectangles,
         but accepts all rectangles. If we now associate some particular behavior which each class of
         documents, we get semantical equivalence sets. Not every document is normally associated
         with some unique behavior: we often have syntactical redundancy, as in C's i=1+1 and i+=1 or
         attribute order in XML: so there is a set of documents which excite the same behavior in a
         receiver. The pattern of syntactical forward compatibility, where a receiver accepts more
         than it can act upon, achieves the same: there is a set of documents for which trigger the
         same behavior: since the receiver does not understand the extra syntactical components, it
         cannot act upon them, and it therefore must act the same, whatever the extra content.</textual></para></section><section class="po-hcontainer e128 e128"><title class="po-block e129 e129"><textual class="po-textual">Semantics and Compatibility</textual></title><figure class="po-container e130 e130" floatstyle="1" xml:id="Bal2008graa030611" xreflabel="Bal2008graa030611"><mediaobject class="po-container e131 e131"><imageobject class="po-container e132 e132"><imagedata class="po-meta e133 e133" fileref="../../../vol2/graphics/deGraauw01/deGraauw01-010.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">Behavior of Px+1</textual></para></caption></mediaobject></figure><para class="po-block e136 e136"><textual class="po-textual">If a language Lx has a successor Lx+1, Lx+1 may specify additional behavior for documents
         accepted, but not produced by Lx: in the above figure, green and red rectangles. This has
         two consequences: - for every document produced by Px, Px+1 will behave as Px expects: it is
         therefore safe for Px to send messages to Px+1 - for documents produced by Px+1 which Px
         cannot produce (again the green and red rectangles) Px will exhibit the same behavior as for
         other documents in the same semantical equivalence set: the language designer of Lx+1 will
         know what behavior this is, and if it is deemed acceptable, it is safe for Px+1 to send
         messages to Px (if the behavior is not deemed acceptable, Px+1 must make sure in some way
         that Px will reject those documents, maybe through a "mustUnderstand" flag).</textual></para></section><section class="po-hcontainer e137 e137"><title class="po-block e138 e138"><textual class="po-textual">Conclusion</textual></title><para class="po-block e139 e139"><textual class="po-textual">The basics of compatible versioning thus are: 1. make sure Px accepts more documents than
         it produces (or fully understands), and, 2. partition the semantical equivalence sets of Px
         into smaller, more refined semantical equivalence sets for Px+1 with additional (new)
         behavior.</textual></para></section><appendix class="po-hcontainer e140 e140" xml:id="mul88"><title class="po-block e141 e141"><textual class="po-textual">Definitions
      </textual></title><para class="po-block e142 e142"><textual class="po-textual">This Appendix contains informal definitions of the concepts of compatibility.
      </textual></para><orderedlist class="po-table e143 e143"><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">
               Two languages are </textual><emphasis class="po-inline e146 e146"><textual class="po-textual">extensionally equivalent</textual></emphasis><textual class="po-textual"> if they accept the same set of documents.
            </textual></para></listitem><listitem class="po-container e147 e147"><para class="po-block e148 e148"><textual class="po-textual">
               A language is an </textual><emphasis class="po-inline e149 e149"><textual class="po-textual">extensional sublanguage </textual></emphasis><textual class="po-textual">of a second language if all documents accepted by the first language are also accepted by the second.
            </textual></para></listitem><listitem class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">
               If two processors behave the same for every document which belongs to a language Lx, the processors are </textual><emphasis class="po-inline e152 e152"><textual class="po-textual">behaviourally equivalent</textual></emphasis><textual class="po-textual"> for Lx.
            </textual></para></listitem><listitem class="po-container e153 e153"><para class="po-block e154 e154"><textual class="po-textual">
               Two languages are </textual><emphasis class="po-inline e155 e155"><textual class="po-textual">syntactically compatible</textual></emphasis><textual class="po-textual"> if they accept the documents produced by each other.
            </textual></para></listitem><listitem class="po-container e156 e156"><para class="po-block e157 e157"><textual class="po-textual">
               A language change is </textual><emphasis class="po-inline e158 e158"><textual class="po-textual">syntactically backward compatible</textual></emphasis><textual class="po-textual"> if a new receiver accepts all documents produced by an older sender.
            </textual></para></listitem><listitem class="po-container e159 e159"><para class="po-block e160 e160"><textual class="po-textual">
               A language change is </textual><emphasis class="po-inline e161 e161"><textual class="po-textual">syntactically forward compatible</textual></emphasis><textual class="po-textual"> if an old receiver accepts all documents produced by a new sender.
            </textual></para></listitem><listitem class="po-container e162 e162"><para class="po-block e163 e163"><textual class="po-textual">
               If two languages take the same documents as input, and their processors behave the same for every document, the languages are </textual><emphasis class="po-inline e164 e164"><textual class="po-textual">semantically equivalent</textual></emphasis><textual class="po-textual">.
            </textual></para></listitem><listitem class="po-container e165 e165"><para class="po-block e166 e166"><textual class="po-textual">
               The</textual><emphasis class="po-inline e167 e167"><textual class="po-textual"> semantical equivalence set </textual></emphasis><textual class="po-textual">of a document d is the set of documents which make a processor behave the same as d.
            </textual></para></listitem><listitem class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual">
               A language is a </textual><emphasis class="po-inline e170 e170"><textual class="po-textual">semantical superlanguage</textual></emphasis><textual class="po-textual"> of a second language if for all documents produced by the second language, processors of the first language behave the same as processors of the second language.
            </textual></para></listitem><listitem class="po-container e171 e171"><para class="po-block e172 e172"><textual class="po-textual">
               A later version of a language is </textual><emphasis class="po-inline e173 e173"><textual class="po-textual">semantically backward compatible</textual></emphasis><textual class="po-textual"> with an earlier version if the later version is a semantical superlanguage of the earlier one (an old sender may expect a newer, but semantically backward compatible, receiver to behave as the sender intended).
            </textual></para></listitem><listitem class="po-container e174 e174"><para class="po-block e175 e175"><textual class="po-textual">
               An earlier language is </textual><emphasis class="po-inline e176 e176"><textual class="po-textual">semantically forward compatible</textual></emphasis><textual class="po-textual"> with a later language  iff the later language is a semantical sublanguage of the earlier one (this is only possible if a language loses semantics).
            </textual></para></listitem><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">
               A later language </textual><emphasis class="po-inline e179 e179"><textual class="po-textual">semantically extends</textual></emphasis><textual class="po-textual"> and earlier language if the later language  introduces new behaviour for some documents accepted, but not produced by the earlier one.
            </textual></para></listitem></orderedlist></appendix><appendix class="po-hcontainer e180 e180"><title class="po-block e181 e181"><textual class="po-textual">Formal Axiomatization</textual></title><para class="po-block e182 e182"><textual class="po-textual">This appendix contains a formal account of the principles which are introduced informally in the main article.</textual></para><orderedlist class="po-table e183 e183" numeration="arabic"><listitem class="po-container e184 e184"><para class="po-block e185 e185"><textual class="po-textual">Let U be a set of (specifications of) software processable languages {L1, L2, ...
               Ln} </textual><orderedlist class="po-table e186 e186" numeration="lowerroman"><listitem class="po-container e187 e187"><para class="po-block e188 e188"><textual class="po-textual">This axiomatization does not concern itself with natural language</textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e189 e189"><para class="po-block e190 e190"><textual class="po-textual">The </textual><emphasis class="po-inline e191 e191"><textual class="po-textual">extension</textual></emphasis><textual class="po-textual"> of a language Lx is a set of conforming
               document instances ELx = {Dx1, Dx2, ... Dxn} </textual><orderedlist class="po-table e192 e192" numeration="lowerroman"><listitem class="po-container e193 e193"><para class="po-block e194 e194"><textual class="po-textual">Iff ELx = ELy then Lx and Ly are extensionally equivalent </textual><itemizedlist class="po-table e195 e195"><listitem class="po-container e196 e196"><para class="po-block e197 e197"><textual class="po-textual">Lx and Ly may still be different: they may define different
                                 semantics for the same syntactical construct</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e198 e198"><para class="po-block e199 e199"><textual class="po-textual">Iff ELx ⊂ ELy then Lx is an extensional sublanguage of
                     Ly</textual></para></listitem><listitem class="po-container e200 e200"><para class="po-block e201 e201"><textual class="po-textual">Iff ELx ⊃ ELy then Lx is an extensional superlanguage of
                     Ly</textual></para></listitem><listitem class="po-container e202 e202"><para class="po-block e203 e203"><textual class="po-textual">D is the set of all possible documents; or the union of all ELx where Lx
                        ∈ U </textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e204 e204"><para class="po-block e205 e205"><textual class="po-textual">For each Lx ∈ U there is a set of </textual><emphasis class="po-inline e206 e206"><textual class="po-textual">processors</textual></emphasis><textual class="po-textual"> Px =
               {Px1, Px2, ... Pxn} which implement Lx </textual><orderedlist class="po-table e207 e207" numeration="lowerroman"><listitem class="po-container e208 e208"><para class="po-block e209 e209"><textual class="po-textual">Each Pxy exhibits behaviour as defined in Lx</textual></para></listitem><listitem class="po-container e210 e210"><para class="po-block e211 e211"><textual class="po-textual">Processors can produce and consume documents</textual></para></listitem><listitem class="po-container e212 e212"><para class="po-block e213 e213"><textual class="po-textual">Each Pxy produces only documents it can consume itself</textual></para></listitem><listitem class="po-container e214 e214"><para class="po-block e215 e215"><textual class="po-textual">At consumption, Pxy may accept or reject documents</textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e216 e216"><para class="po-block e217 e217"><textual class="po-textual">The </textual><emphasis class="po-inline e218 e218"><textual class="po-textual">behaviour</textual></emphasis><textual class="po-textual"> of a processor Pxy of language Lx is a function
               Bxy </textual><orderedlist class="po-table e219 e219" numeration="lowerroman"><listitem class="po-container e220 e220"><para class="po-block e221 e221"><textual class="po-textual">The function Bxy takes as argument a document, and it's value is a
                        processor state </textual><itemizedlist class="po-table e222 e222"><listitem class="po-container e223 e223"><para class="po-block e224 e224"><textual class="po-textual">We assume a single processor state before each function
                                 execution, alternatively we could assume a &lt;state,
                                 document&gt; tuple as function argument</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e225 e225"><para class="po-block e226 e226"><textual class="po-textual">If for two processors Pxy and Pxz for language Lx for a document d Bxy(d)
                        = Bxz(d) then the two processors behave similar for d </textual><itemizedlist class="po-table e227 e227"><listitem class="po-container e228 e228"><para class="po-block e229 e229"><textual class="po-textual">Two processor states for language Lx are deemed equivalent if a
                                 human with thorough knowledge of language specification Lx
                                 considers the states equivalent. Details may vary insofar as the
                                 language specification allows it.</textual></para></listitem><listitem class="po-container e230 e230"><para class="po-block e231 e231"><textual class="po-textual">Processor equivalence is not intended to be formally or
                                 computably decidable; though in some cases it could be.</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e232 e232"><para class="po-block e233 e233"><textual class="po-textual">If ∀d ( d ∈ ELx → Bxy(d) = Bxz(d) ) then
                        Pxy and Pxz are behaviourally equivalent for Lx </textual><itemizedlist class="po-table e234 e234"><listitem class="po-container e235 e235"><para class="po-block e236 e236"><textual class="po-textual">If two processors behave the same for every document which
                                 belongs to a language Lx, the processors are behaviourally
                                 equivalent for Lx.</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e237 e237"><para class="po-block e238 e238"><textual class="po-textual">An </textual><emphasis class="po-inline e239 e239"><textual class="po-textual">ideal language</textual></emphasis><textual class="po-textual"> specifies all aspects of desired processor
               behaviour completely and unambiguously; assume all languages in U are ideal</textual></para></listitem><listitem class="po-container e240 e240"><para class="po-block e241 e241"><textual class="po-textual">A processor Px is an </textual><emphasis class="po-inline e242 e242"><textual class="po-textual">exemplary processor</textual></emphasis><textual class="po-textual"> of a language Lx if
               it fully implements language specification Lx; assume all processors for all
               languages in U are exemplary </textual><orderedlist class="po-table e243 e243" numeration="lowerroman"><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">Because they are (defined to be) exemplary, every two processors for a
                        language Lx are behaviourally equivalent</textual></para></listitem><listitem class="po-container e246 e246"><para class="po-block e247 e247"><textual class="po-textual">ELx = { d is a document ∧ Px accepts d }</textual></para></listitem><listitem class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual">The complement of ELx is the set of everything (normally, every document)
                        which is rejected by Px</textual></para></listitem><listitem class="po-container e250 e250"><para class="po-block e251 e251"><textual class="po-textual">The make set MLx = { d is a document ∧ Px can produce d
                     }</textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e252 e252"><para class="po-block e253 e253"><textual class="po-textual">A language Lx is </textual><emphasis class="po-inline e254 e254"><textual class="po-textual">syntactically compatible</textual></emphasis><textual class="po-textual"> with Ly iff MLx
               ⊂ ELy and MLy ⊂ ELx </textual><itemizedlist class="po-table e255 e255"><listitem class="po-container e256 e256"><para class="po-block e257 e257"><textual class="po-textual">Two languages are syntactically compatible if they accept the documents
                        produced by each other.</textual></para></listitem></itemizedlist><textual class="po-textual">
               </textual><orderedlist class="po-table e258 e258" numeration="lowerroman"><listitem class="po-container e259 e259"><para class="po-block e260 e260"><textual class="po-textual">A language Ln+1 is </textual><emphasis class="po-inline e261 e261"><textual class="po-textual">syntactically backward compatible</textual></emphasis><textual class="po-textual">
                        with Ln iff MLn ⊂ ELn+1 and Ln+1 is a successor of Ln </textual><itemizedlist class="po-table e262 e262"><listitem class="po-container e263 e263"><para class="po-block e264 e264"><textual class="po-textual">A language change is syntactically backward compatible if a new
                                 receiver accepts all documents produced by an older sender.</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e265 e265"><para class="po-block e266 e266"><textual class="po-textual">A language Ln is </textual><emphasis class="po-inline e267 e267"><textual class="po-textual">syntactically forward compatible</textual></emphasis><textual class="po-textual">
                        with Ln+1 iff MLn+1 ⊂ ELn and Ln+1 is a successor of Ln </textual><itemizedlist class="po-table e268 e268"><listitem class="po-container e269 e269"><para class="po-block e270 e270"><textual class="po-textual">A language change is syntactically forward compatible if an old
                                 receiver accepts all documents produced by a new sender.</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e271 e271"><para class="po-block e272 e272"><textual class="po-textual">A document d can be a member of the extension of any number of languages</textual></para><orderedlist class="po-table e273 e273" numeration="lowerroman"><listitem class="po-container e274 e274"><para class="po-block e275 e275"><textual class="po-textual">Px is an (exemplary) processor of Lx, Py is an (exemplary) processor of
                     language</textual></para></listitem><listitem class="po-container e276 e276"><para class="po-block e277 e277"><textual class="po-textual">Two languages Lx and Ly are </textual><emphasis class="po-inline e278 e278"><textual class="po-textual">semantically equivalent</textual></emphasis><textual class="po-textual"> iff
                     ELx = ELy ∧ ∀d ( (d ∈ ELx ) → Bx(d) =
                     By(d) )</textual></para><itemizedlist class="po-table e279 e279"><listitem class="po-container e280 e280"><para class="po-block e281 e281"><textual class="po-textual">If two languages Lx and Ly take the same documents as input, and their
                           exemplary processors behave the same for every document, the languages
                           are semantically equivalent.</textual></para></listitem><listitem class="po-container e282 e282"><para class="po-block e283 e283"><textual class="po-textual">Two languages can only be compared if their exemplary processors are
                           similar enough to be compared. </textual></para></listitem><listitem class="po-container e284 e284"><para class="po-block e285 e285"><textual class="po-textual">Not every two languages can be compared.</textual></para></listitem><listitem class="po-container e286 e286"><para class="po-block e287 e287"><textual class="po-textual">"Semantic" should not be interpreted in the sense of "formal
                           semantics".</textual></para></listitem></itemizedlist></listitem></orderedlist></listitem><listitem class="po-container e288 e288"><para class="po-block e289 e289"><textual class="po-textual">The </textual><emphasis class="po-inline e290 e290"><textual class="po-textual">semantical equivalence set</textual></emphasis><textual class="po-textual"> of a document d for Lx = { y
               ∈ ELx | Bx(d) = Bx(y) } </textual><orderedlist class="po-table e291 e291" numeration="lowerroman"><listitem class="po-container e292 e292"><para class="po-block e293 e293"><textual class="po-textual">Or: SLx,d = { y ∈ ELx | Bx(d) = Bx(y) } </textual><itemizedlist class="po-table e294 e294"><listitem class="po-container e295 e295"><para class="po-block e296 e296"><textual class="po-textual">The semantical equivalence set of a document d is the set of
                                 documents which make a processor behave the same as d</textual></para></listitem><listitem class="po-container e297 e297"><para class="po-block e298 e298"><textual class="po-textual">Semantical equivalence occurs for expressions which are
                                 semantically equivalent, such as i = i + 1 and i += 1 for C, or
                                 different attribute order in XML etc.</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e299 e299"><para class="po-block e300 e300"><textual class="po-textual">d ∈ SLx,d</textual></para></listitem><listitem class="po-container e301 e301"><para class="po-block e302 e302"><textual class="po-textual">Any two semantical equivalence sets of Lx are necessarily disjunct</textual></para><itemizedlist class="po-table e303 e303"><listitem class="po-container e304 e304"><para class="po-block e305 e305"><textual class="po-textual">If z ∈ SLx,e were also z ∈ SLx,d then every
                              member of SLx,e would be in SLx,d and vice versa and thus SLx,d =
                              SLx,e</textual></para></listitem></itemizedlist></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e306 e306"><para class="po-block e307 e307"><textual class="po-textual">A language Ly is a </textual><emphasis class="po-inline e308 e308"><textual class="po-textual">semantical superlanguage</textual></emphasis><textual class="po-textual"> of Lx iff
               ∀d ( d ∈ MLx → By(d) = Bx(d) ) </textual><orderedlist class="po-table e309 e309" numeration="lowerroman"><listitem class="po-container e310 e310"><para class="po-block e311 e311"><textual class="po-textual">For all documents produced by Px, Py behaves the same as Px </textual><itemizedlist class="po-table e312 e312"><listitem class="po-container e313 e313"><para class="po-block e314 e314"><textual class="po-textual">Equivalence in this case should be decided based on Lx; if Ly
                                 makes behavioural distinctions which are not mentioned in Lx,
                                 behaviour is still the same as far as Lx is concerned</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e315 e315"><para class="po-block e316 e316"><textual class="po-textual">It follows: ∀d ( d ∈ MLx → ∃SLy,d
                        ( SLy,d ⊂ ELy ∧ ( SLx,d ∩ MLx ) ⊂
                        SLy,d ∧ By(d) = Bx(d) ) ) </textual><itemizedlist class="po-table e317 e317"><listitem class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">For any document produced by Px, the part of its semantical
                                 equivalence set which Px can actually produce, is a subset of the
                                 semantical equivalence set of Py for this document</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e320 e320"><para class="po-block e321 e321"><textual class="po-textual">For all d ∈ ELx ∧ d ∉ MLx there may be many
                        equivalence sets in Ly for which By(d) ≠ Bx(d) </textual><itemizedlist class="po-table e322 e322"><listitem class="po-container e323 e323"><para class="po-block e324 e324"><textual class="po-textual">In other words: for documents accepted but not produced by Px,
                                 Ly may define additional behaviours</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e325 e325"><para class="po-block e326 e326"><textual class="po-textual">Lx is a semantical sublanguage of Ly iff Ly is a semantical superlanguage
                        of Lx</textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e327 e327"><para class="po-block e328 e328"><textual class="po-textual">A language Ln+1 is </textual><emphasis class="po-inline e329 e329"><textual class="po-textual">semantically backward compatible</textual></emphasis><textual class="po-textual"> with Ln
               iff Ln+1 is a semantical superlanguage of Ln and Ln+1 is a successor of Ln
                  </textual><orderedlist class="po-table e330 e330" numeration="lowerroman"><listitem class="po-container e331 e331"><para class="po-block e332 e332"><textual class="po-textual">An old sender may expect a newer, but semantically backward compatible,
                        receiver to behave as the sender intended</textual></para></listitem><listitem class="po-container e333 e333"><para class="po-block e334 e334"><textual class="po-textual">A language Ln is </textual><emphasis class="po-inline e335 e335"><textual class="po-textual">semantically forward compatible</textual></emphasis><textual class="po-textual">
                        with Ln+1 iff Ln+1 is a semantical sublanguage of Ln and Ln+1 is a successor
                        of Ln</textual></para></listitem><listitem class="po-container e336 e336"><para class="po-block e337 e337"><textual class="po-textual">Semantic forward compatibility is only possible if a language loses
                        semantics; i.e. its processors exhibit less functionality, and produce less
                        diverse documents</textual></para></listitem><listitem class="po-container e338 e338"><para class="po-block e339 e339"><textual class="po-textual">A processor cannot understand what it does not know about yet</textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e340 e340"><para class="po-block e341 e341"><textual class="po-textual">A language Ln+1 </textual><emphasis class="po-inline e342 e342"><textual class="po-textual">semantically extends</textual></emphasis><textual class="po-textual"> Ln iff ∃d ( d
               ∈ MLn+1 ∧ d ∈ ELn ∧ BLn+1 ≠ BLn ) </textual><itemizedlist class="po-table e343 e343"><listitem class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">Ln+1 introduces new behaviour for some documents accepted, but not
                        produced by Ln</textual></para></listitem></itemizedlist><textual class="po-textual">
               </textual><orderedlist class="po-table e346 e346" numeration="lowerroman"><listitem class="po-container e347 e347"><para class="po-block e348 e348"><textual class="po-textual">Assume Ln is syntactically forward compatible with Ln+1, Ln+1 is
                        semantically backward compatible with Ln, and Ln+1 semantically extends Ln </textual><itemizedlist class="po-table e349 e349"><listitem class="po-container e350 e350"><para class="po-block e351 e351"><textual class="po-textual">Pn accepts all documents produced by Pn+1, or: MLn+1 ⊂
                                 ELn</textual></para></listitem><listitem class="po-container e352 e352"><para class="po-block e353 e353"><textual class="po-textual">For documents produced by Pn, Pn+1 behaves as Pn would expect,
                                 or: ∀d( d ∈ MLn → Bn+1(d) = Bn(d)
                              )</textual></para></listitem><listitem class="po-container e354 e354"><para class="po-block e355 e355"><textual class="po-textual">But for some documents accepted, but not produced by Pn, Pn does
                                 not behave as Pn+1 would, or: ∃d ( d ∈ MLn+1
                                 ∧ d ∈ ELn ∧ d ∉ MLn
                                 ∧ BLn+1 ≠ BLn )</textual></para></listitem><listitem class="po-container e356 e356"><para class="po-block e357 e357"><textual class="po-textual">New senders send documents to old receivers, which do not behave
                                 as new receivers would behave</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e358 e358"><para class="po-block e359 e359"><textual class="po-textual">∀d (d ∈ MLn+1 ∧ d ∈ ELn
                        ∧ d ∉ MLn → ∃d'( d' ∈ MLn
                        ∧ Bn(d') = Bn(d) ) </textual><itemizedlist class="po-table e360 e360"><listitem class="po-container e361 e361"><para class="po-block e362 e362"><textual class="po-textual">For every document d, accepted but not produced by Pn, there is
                                 a document d' for which Pn behaves the same as for d, or: d'
                                 ∈ SLn,d (the semantical equivalence set of d for
                              Ln)</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e363 e363"><para class="po-block e364 e364"><textual class="po-textual">We can assume Ln </textual><emphasis class="po-inline e365 e365"><textual class="po-textual">transforms document</textual></emphasis><textual class="po-textual"> d to document
                        d' </textual><itemizedlist class="po-table e366 e366"><listitem class="po-container e367 e367"><para class="po-block e368 e368"><textual class="po-textual">If a language Ln accepts a document which it would not produce,
                                 it transforms it to a document which it could produce</textual></para></listitem><listitem class="po-container e369 e369"><para class="po-block e370 e370"><textual class="po-textual">There has to be no literal transformation</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e371 e371"><para class="po-block e372 e372"><textual class="po-textual">We now have: Bn(d') = Bn(d) ∧ Bn+1(d') ≠ Bn+1(d) </textual><itemizedlist class="po-table e373 e373"><listitem class="po-container e374 e374"><para class="po-block e375 e375"><textual class="po-textual">Pn behaves the same for d and the transformed d'; but Pn+1
                                 behaves differently</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem><listitem class="po-container e376 e376"><para class="po-block e377 e377"><textual class="po-textual">Iff it is acceptable that Bn(d') = Bn(d) for transformed documents, then
                        Pn </textual><emphasis class="po-inline e378 e378"><textual class="po-textual">may ignore</textual></emphasis><textual class="po-textual"> the semantical extension responsible for
                        Bn+1(d') ≠ Bn+1(d) </textual><itemizedlist class="po-table e379 e379"><listitem class="po-container e380 e380"><para class="po-block e381 e381"><textual class="po-textual">The fact that Ln is syntactically forward compatible with Ln+1
                                 enables Pn+1 to introduce new semantics without breaking existing
                                 Pn</textual></para></listitem><listitem class="po-container e382 e382"><para class="po-block e383 e383"><textual class="po-textual">We could say Ln is </textual><emphasis class="po-inline e384 e384"><textual class="po-textual">partially semantically forward
                                    compatible</textual></emphasis><textual class="po-textual"> with Ln+1; it only ignores semantics it
                                 may ignore</textual></para></listitem><listitem class="po-container e385 e385"><para class="po-block e386 e386"><textual class="po-textual">New senders can interact with old receivers; old receivers may
                                 ignore what they do not understand</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e387 e387"><para class="po-block e388 e388"><textual class="po-textual"> Iff it is not acceptable that Bn(d') = Bn(d) for transformed documents,
                        then Pn </textual><emphasis class="po-inline e389 e389"><textual class="po-textual">must understand</textual></emphasis><textual class="po-textual"> the semantical extension
                        responsible for Bn+1(d') ≠ Bn+1(d) </textual><itemizedlist class="po-table e390 e390"><listitem class="po-container e391 e391"><para class="po-block e392 e392"><textual class="po-textual">If Pn must understand d, then Pn should not process d</textual></para></listitem><listitem class="po-container e393 e393"><para class="po-block e394 e394"><textual class="po-textual">A Pn+1 must not send d to a Pn; or Pn should be adapted so that
                                 Pn rejects d (or: d ∉ ELn)</textual></para></listitem><listitem class="po-container e395 e395"><para class="po-block e396 e396"><textual class="po-textual">If a Pn+1 can send d to a Pn, then Ln should not be (completely)
                                 syntactically forward compatible with Ln+1</textual></para></listitem><listitem class="po-container e397 e397"><para class="po-block e398 e398"><textual class="po-textual">A processor should not accept what it must understand, yet
                                 cannot understand</textual></para></listitem></itemizedlist><textual class="po-textual">
                     </textual></para></listitem></orderedlist><textual class="po-textual">
            </textual></para></listitem></orderedlist></appendix><bibliography class="po-hcontainer e399 e399"><title class="po-block e400 e400"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e401 e401"><textual class="po-textual">UBL. </textual><link class="po-inline e402 e402" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ubl</textual></link></bibliomixed><bibliomixed class="po-block e403 e403"><textual class="po-textual">HL7v3. </textual><link class="po-inline e404 e404" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.hl7.org/</textual></link></bibliomixed><bibliomixed class="po-block e405 e405"><textual class="po-textual">Versioning XML with XML Schema, David Orchard, XTech 2008. </textual><link class="po-inline e406 e406" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://2008.xtech.org/public/schedule/detail/530</textual></link></bibliomixed><bibliomixed class="po-block e407 e407"><textual class="po-textual">Extending and Versioning Languages: Terminology, Draft TAG Finding 13 November 2007. </textual><link class="po-inline e408 e408" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/2001/tag/doc/versioning-20071113.html</textual></link></bibliomixed><bibliomixed class="po-block e409 e409"><textual class="po-textual">Extending and Versioning Languages: Strategies, Draft TAG Finding 17 September 2007. </textual><link class="po-inline e410 e410" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/2001/tag/doc/versioning-strategies-20070917.html</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>