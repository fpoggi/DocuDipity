<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Text Retrieval for XML-Encoded Corpora: A Lexical Approach</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2008</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 12 - 15, 2008</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">This paper describes some modifications done to an open source
      text retrieval package to make it XML-aware, and contrasts this lexical
      approach, in which XML documents are primarily treated as sequences of
      characters rather than trees, with the W3C XPath 1.0 and XQuery 2.0
      Full-Text facility.</textual></para><para class="po-block e8 e8"><textual class="po-textual">Specific usage scenarios are taken into consideration, including
      World Wide Web publication and the searching and analysis of text
      corpora for research purposes.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Liam</textual></firstname><othername class="po-field e12 e12"><textual class="po-textual">R. E.</textual></othername><surname class="po-field e13 e13"><textual class="po-textual">Quin</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Mr Quin has been involved with declarative, descriptive markup
        since the early 1980s. He wrote his open-source text retrieval system
        and first distributed it in the late 1980s.</textual></para><para class="po-block e16 e16"><textual class="po-textual">He has worked at the World Wide Web Consortium since 2001, where
        he is XML Activity Lead, or, informally, Mrs XML.</textual></para></personblurb><affiliation class="po-record e17 e17"><jobtitle class="po-field e18 e18"><textual class="po-textual">XML Activity lead</textual></jobtitle><orgname class="po-block e19 e19"><textual class="po-textual">W3C</textual></orgname></affiliation><email class="po-field e20 e20"><textual class="po-textual">liam@w3.org</textual></email></author><legalnotice class="po-container e21 e21"><para class="po-block e22 e22"><textual class="po-textual">Copyright © 2008 Liam R E Quin. Used by permission.</textual></para></legalnotice><keywordset class="po-table e23 e23" role="author"><keyword class="po-field e24 e24"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">Full Text</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">Information Retrieval</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">Natural Language Processing</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">Computational Linguistics</textual></keyword></keywordset></info><section class="po-hcontainer e29 e29"><title class="po-block e30 e30"><textual class="po-textual">Introduction</textual></title><para class="po-block e31 e31"><textual class="po-textual">The W3C XML Query Working Group has published a specification for
    performing full-text queries over instances of the XPath and XQuery Data
    Model using an extension of the XQuery syntax. This is a text retrieval
    facility that operates on an abstract representation of XML trees, rather
    than on text files that happen to contain markup. Elements and their
    attributes are reified into hierarchies of nodes, text leaps into the
    lacunæ and swims between them, and not a pointy bracket in sight.</textual></para><para class="po-block e32 e32"><textual class="po-textual">This paper compares the XQuery Full Text Facility with a more
    traditional open source text retrieval system, lq-text, and also explores
    the work done to make lq-text become more suitable to the processing needs
    of people who work with XML.</textual></para><para class="po-block e33 e33"><textual class="po-textual">Disadvantage and advantages of the two approaches are
    discussed.</textual></para></section><section class="po-hcontainer e34 e34"><title class="po-block e35 e35"><textual class="po-textual">A Brief Description of the Full Text Facility</textual></title><para class="po-block e36 e36"><textual class="po-textual">Although this paper is primarily concerned with a lexical approach,
    an understanding of the XPath 2 and XQuery approach is useful, and will be
    taken as a baseline for comparison.</textual></para><para class="po-block e37 e37"><textual class="po-textual">Informally, a full text search is a search to find all documents in
    a collection, or all elements of some specific type (for example)
    containing one or more specific words. For example, one might want to find
    all occurrences of the phrase “warm socks” in a multi-gigabyte corpus of
    text. The underlying assumption of full text is that the implementation
    uses an index that has been constructed separately in advance, although
    this is not necessarily true.</textual></para><section class="po-hcontainer e38 e38"><title class="po-block e39 e39"><textual class="po-textual">Primary characteristics</textual></title><para class="po-block e40 e40"><textual class="po-textual">XQuery 1.0 and XPath 2.0 Full-Text 1.0 [</textual><xref class="po-milestone e41 e41" linkend="FullText-2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] extends XPath 2.0 (and XQuery 1.0 in turn,
      which itself extends XPath 2.0) to add support for explicit syntax for
      full text searches.</textual></para><para class="po-block e42 e42"><textual class="po-textual">XPath 2.0 is node-based, matching text nodes which are contained
      by element nodes in a collection of XML document trees. The result is a
      Boolean value (when used in an XPath predicate) together with an
      optional numerical score or ranking.</textual></para><para class="po-block e43 e43"><textual class="po-textual">The Full-Text facility includes a large number of possible
      modifiers, many of which are optional features and may or may or be
      available in any given implementation. These include (for example) both
      query expansion through a thesaurus and also query narrowing using a
      different sort of thesaurus. One can search for two tokens (words, for
      English) within a certain number of tokens, sentences or even
      paragraphs. The optional features are marked as being “at risk” in W3C
      parlance, meaning that unimplemented (or unimplementable) features will
      be dropped from the draft specification before it is published as a W3C
      Recommendation.</textual></para></section></section><section class="po-hcontainer e44 e44"><title class="po-block e45 e45"><textual class="po-textual">A Brief Description of lq-text</textual></title><para class="po-block e46 e46"><textual class="po-textual">Lq-text is an open source text retrieval package that was first
    released in 1989. It has had sporadic development since then. Its main
    claims to fame are high precision, good performance (particularly when the
    data does not fit into available virtual memory), flexible concordance
    generation and an open, extensible, multi-process architecture.</textual></para><para class="po-block e47 e47"><textual class="po-textual">Lq-text operates on text files. It makes an index to the files; this
    index stores the location of each occurrence of each natural-language word
    in all of the files. The resulting index is stored efficiently, and
    generally takes between a quarter and three quarters of the storage size
    of the original documents. The index is an adjunct; lq-text also refers to
    the original files, although these can be compressed to save space if
    needed. The package is designed to work best with many small files rather
    than a few large ones.</textual></para><para class="po-block e48 e48"><textual class="po-textual">When lq-text indexes files, it can run a format-specific filter on
    each file before indexing it. The list of filters is currently built in to
    the software (but since it is open source, you can in fact change it if
    you wish).</textual></para><para class="po-block e49 e49"><textual class="po-textual">A suite of separate Unix programs operate on the index for
    retrieval; some of these will be described in this paper. They are used in
    conjunction with each other, using a documented text-based format to
    communicate.</textual></para><para class="po-block e50 e50"><textual class="po-textual">It is this open architecture that can be exploited to enable
    XML-specific searches, and that is the primary work described in this
    paper.</textual></para></section><section class="po-hcontainer e51 e51"><title class="po-block e52 e52"><textual class="po-textual">Commonalities Between The Approaches</textual></title><para class="po-block e53 e53"><textual class="po-textual">An underlying assumption is that some sort of indexing will have
    been performed before queries are run; this is of course for all full-text
    systems, and although in some cases the constructed indexes do not persist
    between invocations of the query software, usually the indexes are kept
    and re-used.</textual></para><para class="po-block e54 e54"><textual class="po-textual">Although the Full-Text facility operates on trees and lq-text
    operates on flat text files, in practice both systems are matching
    sequence of tokens against an index, and returning matches based on text
    content.</textual></para><para class="po-block e55 e55"><textual class="po-textual">The XQuery Update Facility allows queries to update documents, and,
    as a result, implementations must be able to re-index documents
    efficiently. Lq-text can also re-index documents, most efficiently when
    both the original and the new version are available.</textual></para></section><section class="po-hcontainer e56 e56"><title class="po-block e57 e57"><textual class="po-textual">Lq-text and XML: Objectives</textual></title><para class="po-block e58 e58"><textual class="po-textual">The author wanted to experiment to understand what work would be
    needed to make lq-text be useful for people working with XML documents.
    Some goals of this work included:</textual></para><itemizedlist class="po-table e59 e59"><listitem class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">Make minimal changes to the architecture and index and match
        format, because of limited programming resources;</textual></para></listitem><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">Retain a small index and efficient retrieval;</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">Solve common use cases rather than providing extensive and
        general mechanisms.</textual></para></listitem></itemizedlist><para class="po-block e66 e66"><textual class="po-textual">Although lq-text was not (at the start of the work) XML-aware, it
    has the ability to run a format-specific filter program when indexing any
    given document. There was already an SGML filter, but all it did was
    ensure that element and attribute names were not indexed. This filter was
    re-used for XML, modified to allow indexing of elements and attributes.
    But at that point the work had only begun.</textual></para><para class="po-block e67 e67"><textual class="po-textual">The following use cases were determined sufficient for
    experiments:</textual></para><itemizedlist class="po-table e68 e68"><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">Identify all documents containing two or more phrases in the
        same element, for any given element;</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">Refine the search to an element with a specific attribute set to
        a given value;</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">Highlight the matches of the search in context;</textual></para></listitem><listitem class="po-container e75 e75"><para class="po-block e76 e76"><textual class="po-textual">For a given match, print the parent element and its content, or
        the contents of the parent tag, or a given attribute value, or the
        name of the parent element... possibly constrained to any named
        ancestor element not just the parent.</textual></para></listitem></itemizedlist><para class="po-block e77 e77"><textual class="po-textual">This of course is much less than one might want in a full XML-aware
    text retrieval system. On the other hand, the XPath-based approach taken
    by the Full-Text facility does not support highlighting of matches or
    generation of concordances, and the author felt this to be essential
    functionality, both for research and for industrial or commercial
    use.</textual></para><para class="po-block e78 e78"><textual class="po-textual">The approach taken was to extend </textual><emphasis class="po-inline e79 e79" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual">, the concordance program, so the paper will
    describe the lq-text architecture and then </textual><emphasis class="po-inline e80 e80" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual">, and then explain the extensions that were
    added. After that, an example program will be shown that uses </textual><emphasis class="po-inline e81 e81" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> to solve one of the use cases given above.
    At that point we will be able to compare an XQuery or XSLT 2
    solution.</textual></para><para class="po-block e82 e82"><textual class="po-textual">Support for a subset of XML (“just enough XML, Eh?”) was
    implemented; this subset will also be described, as it may be of interest
    for other people considering adding XML support to older software.</textual></para></section><section class="po-hcontainer e83 e83"><title class="po-block e84 e84"><textual class="po-textual">Lq-text Architecture in Detail</textual></title><para class="po-block e85 e85"><textual class="po-textual">Before explaining how lq-text was extended, it is necessary to give
    at least an abbreviated account of how lq-text works.</textual></para><para class="po-block e86 e86"><textual class="po-textual">Lq-text builds and maintains a separate index for each set of
    documents, which it calls a </textual><emphasis class="po-inline e87 e87" role="ital"><textual class="po-textual">database</textual></emphasis><textual class="po-textual">.
    When building the index, lq-text applies simple </textual><emphasis class="po-inline e88 e88" role="ital"><textual class="po-textual">stemming</textual></emphasis><textual class="po-textual">, by reducing words to a root. Currently,
    only plural and possessive forms are recognised and recorded, and other
    forms are indexed separately. This code is specific to the English
    language, and may be removed in a future version, with stemming instead
    being done by term expansion at query time.</textual></para><para class="po-block e89 e89"><textual class="po-textual">Lq-text comprises a suite of separate programs, and each program
    always uses a single database. For the sake of simplicity in this paper we
    will assume that only a single lq-text database is in use at any time,
    unless otherwise stated.</textual></para><para class="po-block e90 e90"><textual class="po-textual">Some of the programs included with lq-text are listed for reference
    in the table. Only a few of them will be discussed further in this paper,
    but the table may give the reader a clearer sense of the software.</textual></para><table class="po-container e91 e91"><caption class="po-container e92 e92"><para class="po-block e93 e93"><textual class="po-textual">Lq-text Programs</textual></para></caption><col align="right" class="po-meta e94 e94" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col class="po-meta e95 e95" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e96 e96"><tr class="po-table e97 e97" valign="top"><th class="po-field e98 e98"><textual class="po-textual">Program</textual></th><th class="po-field e99 e99"><textual class="po-textual">Purpose</textual></th></tr></thead><tbody class="po-table e100 e100"><tr class="po-table e101 e101" valign="top"><td class="po-block e102 e102"><emphasis class="po-inline e103 e103" role="ital"><textual class="po-textual">lqaddfile</textual></emphasis></td><td class="po-block e104 e104"><textual class="po-textual">Used to add documents to the index, and to manipulate the
          index.</textual></td></tr><tr class="po-table e105 e105" valign="top"><td class="po-block e106 e106"><emphasis class="po-inline e107 e107" role="ital"><textual class="po-textual">lqunindexfile</textual></emphasis></td><td class="po-block e108 e108"><textual class="po-textual">removes a file from the index.</textual></td></tr><tr class="po-table e109 e109" valign="top"><td class="po-block e110 e110"><emphasis class="po-inline e111 e111" role="ital"><textual class="po-textual">lqphrase</textual></emphasis></td><td class="po-block e112 e112"><textual class="po-textual">matches one or more exact phrases</textual></td></tr><tr class="po-table e113 e113" valign="top"><td class="po-block e114 e114"><emphasis class="po-inline e115 e115" role="ital"><textual class="po-textual">lqquery</textual></emphasis></td><td class="po-block e116 e116"><textual class="po-textual">matches words or phrases, but supports wildcard expansion</textual></td></tr><tr class="po-table e117 e117" valign="top"><td class="po-block e118 e118"><emphasis class="po-inline e119 e119" role="ital"><textual class="po-textual">lqrank</textual></emphasis></td><td class="po-block e120 e120"><textual class="po-textual">reorders results based on the number of documents matched
          (quorum ranking)</textual></td></tr><tr class="po-table e121 e121" valign="top"><td class="po-block e122 e122"><emphasis class="po-inline e123 e123" role="ital"><textual class="po-textual">lqsort</textual></emphasis></td><td class="po-block e124 e124"><textual class="po-textual">sorts matches by various criteria e.g. by the word before the
          match</textual></td></tr><tr class="po-table e125 e125" valign="top"><td class="po-block e126 e126"><emphasis class="po-inline e127 e127" role="ital"><textual class="po-textual">lqshow</textual></emphasis></td><td class="po-block e128 e128"><textual class="po-textual">text-terminal (curses) program to show matched text</textual></td></tr><tr class="po-table e129 e129" valign="top"><td class="po-block e130 e130"><emphasis class="po-inline e131 e131" role="ital"><textual class="po-textual">lqsed</textual></emphasis></td><td class="po-block e132 e132"><textual class="po-textual">process documents, highlighting matches by insertion</textual></td></tr><tr class="po-table e133 e133" valign="top"><td class="po-block e134 e134"><emphasis class="po-inline e135 e135" role="ital"><textual class="po-textual">lqkwic</textual></emphasis></td><td class="po-block e136 e136"><textual class="po-textual">the main keyword in context concordance program</textual></td></tr></tbody></table><para class="po-block e137 e137"><textual class="po-textual">Once an index is built (for example with lqaddfile), it can be used.
    A sample search might be as follows:</textual></para><programlisting class="po-block e138 e138" xml:space="preserve"><textual class="po-textual">$ lqquery "on his face" | lqkwic</textual></programlisting><para class="po-block e139 e139"><textual class="po-textual">For one small corpus (Brewer's Dictionary of Phrase and Fable, with
    about 17,000 files) the results are as follows:</textual></para><programlisting class="po-block e140 e140" xml:space="preserve"><textual class="po-textual">==== Document 1: xml/1251.xml: Balafré ====
1:t which left a frightful scar </textual><emphasis class="po-inline e141 e141" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual"> (1550–1588).  So Ludovic Lesly, an
==== Document 2: xml/3720.xml: Cloud ====
2: He [Antony] has a cloud </textual><emphasis class="po-inline e142 e142" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual">.
==== Document 3: xml/6070.xml F ====
3: F is written </textual><emphasis class="po-inline e143 e143" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual">. “Rogue” is written on his face
4: face. “Rogue” is written </textual><emphasis class="po-inline e144 e144" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual">. The letter F used to be branded n
==== Document 4: xml/8745.xml Ill Omens ====
5: he happened to trip and fall </textual><emphasis class="po-inline e145 e145" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual">. This would have been considered a
6: shore at Bulverhythe he fell </textual><emphasis class="po-inline e146 e146" role="bold"><textual class="po-textual">on his face</textual></emphasis><textual class="po-textual">, and a great cry went forth that i</textual></programlisting><para class="po-block e147 e147"><textual class="po-textual">Here, the matched text is shown with a few words of context on
    either side, giving rise to the term </textual><emphasis class="po-inline e148 e148" role="ital"><textual class="po-textual">key word in
    context</textual></emphasis><textual class="po-textual">, KWIC, </textual><emphasis class="po-inline e149 e149" role="ital"><textual class="po-textual">index</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e150 e150"><textual class="po-textual">Two lq-text programs, </textual><emphasis class="po-inline e151 e151" role="ital"><textual class="po-textual">lqquery</textual></emphasis><textual class="po-textual"> and
    </textual><emphasis class="po-inline e152 e152" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual">, were combined in the search,
    using a Unix pipe; that is, both programs were run concurrently, with the
    output of one being fed as the input to the other. This is a usual way of
    working with lq-text, and although it sometimes requires some thought, it
    does mean that lq-text exploits multi-processor systems well, and also
    works well with Unix and Linux, which were designed to run pipelines of
    small programs very efficiently.</textual></para><para class="po-block e153 e153"><textual class="po-textual">This description begs the question, exactly what output is passed
    from </textual><emphasis class="po-inline e154 e154" role="ital"><textual class="po-textual">lqquery</textual></emphasis><textual class="po-textual"> to </textual><emphasis class="po-inline e155 e155" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> in the example? The answer to this question
    exposes the underlying index architecture, and can be seen by running just
    the first program without the second:</textual></para><programlisting class="po-block e156 e156" xml:space="preserve"><textual class="po-textual">$ lqquery "on his face"
3 0 41 2792 1251.xml
3 0 55 11703 3720.xml
3 0 15 14314 6070.xml
3 0 21 14314 6070.xml
3 0 75 17285 8745.xml
3 1 8 17285 8745.xml</textual></programlisting><para class="po-block e157 e157"><textual class="po-textual">The format, as can be determined by inspection, is a sequence of
    lines of text, and, in each line, a number of space-separated fields. Each
    line represents a single match, and just as there were six results before,
    there are six matches here. The fields are, from left to right, the number
    of words matched, the block in the file, the word in the block, the file
    number and (optionally) the filename.</textual></para><para class="po-block e158 e158"><textual class="po-textual">The lq-text index does not store exact locations for matches.
    Instead, the location to the nearest block number, and the word within the
    block, are stored. Blocks are by default 128 bytes in size. The result of
    this is that a match location within a file is usually represented by a
    pair of fairly small integers, but that finding the actual intended words
    to highlight requires accessing the file and counting words. This is a
    trade-off: a lq-text index is often much smaller than the indexed files,
    because the average English word is about 5 characters long (depending
    somewhat on the corpus), and it only takes 2 bytes in most cases to store
    the information about a match.</textual></para><para class="po-block e159 e159"><textual class="po-textual">Lines in the match list starting with a </textual><code class="po-atom e160 e160"><textual class="po-textual">#</textual></code><textual class="po-textual"> are
    considered to be comments, and lines of the form
    </textual><code class="po-atom e161 e161"><textual class="po-textual">{ variable = value }</textual></code><textual class="po-textual"> are used by
    </textual><emphasis class="po-inline e162 e162" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> to set values that can be used
    later, as we shall see.</textual></para><para class="po-block e163 e163"><textual class="po-textual">Lq-text programs generally both accept this match format as input
    and produce it as output, so that they can be combined. In particular, the
    </textual><emphasis class="po-inline e164 e164" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> program can both read and produce
    this format, as we shall see in the next section.</textual></para></section><section class="po-hcontainer e165 e165"><title class="po-block e166 e166"><textual class="po-textual">The lq-text lqkwic program</textual></title><para class="po-block e167 e167"><textual class="po-textual">The lqkwic program takes lq-text matches as input, and prints them
    using a user-supplied format, or a built-in format. Matches are grouped by
    file, and another format is used to print the start of each group of
    documents, and yet another can be supplied to be used at the end of each
    group.</textual></para><para class="po-block e168 e168"><textual class="po-textual">The format takes the form of a string with embedded variables that
    are interpolated each time the format is used. An example may clarify the
    format:</textual></para><programlisting class="po-block e169 e169" xml:space="preserve"><textual class="po-textual">$ lqquery "on his fa*" |
    lqkwic -S '' -A '' -s '${MatchNumber} ${MatchedText}\n'
1 on his father
2 on his face
3 on his favourite
4 on his face
5 on his father
6 on his face
7 on his face
8 on his father
9 on his favourite
10 on his face
11 on his face</textual></programlisting><para class="po-block e170 e170"><textual class="po-textual">Here, the formats for the start and end of each group of matches
    have been set to the empty string with </textual><code class="po-atom e171 e171"><textual class="po-textual">-S ''</textual></code><textual class="po-textual"> and </textual><code class="po-atom e172 e172"><textual class="po-textual">-A
    ''</textual></code><textual class="po-textual"> respectively. The per-match format is set to a string in which
    for each match the match number is printed, followed by a space, followed
    by the matched text and (indicated by </textual><code class="po-atom e173 e173"><textual class="po-textual">\n</textual></code><textual class="po-textual"> in the grand Unix
    tradition) a newline. The single quotes are used to surround the strings
    to prevent the Unix shell from seeing the dollar signs and treating them
    as references to shell variables.</textual></para><para class="po-block e174 e174"><textual class="po-textual">Although the MatchedText variable is obviously useful for testing,
    one would normally use it in conjunction with other variables, such as
    TextBefore and TextAfter. The purpose of this section is not to document
    lqkwic, but to give the reader an understanding of the sorts of things one
    can print, since lqkwic has uses that are far removed from concordance
    generation, and since we will shortly be taking advantage of such
    uses.</textual></para><para class="po-block e175 e175"><textual class="po-textual">The following table shows some of the variables available. In many
    cases, lqkwic must read the actual matched documents (or at least part of
    them), in order to evaluate the variables.</textual></para><table class="po-container e176 e176"><caption class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">The lqkwic formatting variables</textual></para></caption><col align="right" class="po-meta e179 e179" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col class="po-meta e180 e180" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e181 e181"><tr class="po-table e182 e182" valign="top"><th class="po-field e183 e183"><textual class="po-textual">Variable</textual></th><th class="po-field e184 e184"><textual class="po-textual">Description</textual></th></tr></thead><tbody class="po-table e185 e185"><tr class="po-table e186 e186" valign="top"><td class="po-block e187 e187"><textual class="po-textual">DocName</textual></td><td class="po-block e188 e188"><textual class="po-textual">the name of the current document, as stored in the database</textual></td></tr><tr class="po-table e189 e189" valign="top"><td class="po-block e190 e190"><textual class="po-textual">FileName</textual></td><td class="po-block e191 e191"><textual class="po-textual">the absolute path corresponding to ${DocName}</textual></td></tr><tr class="po-table e192 e192" valign="top"><td class="po-block e193 e193"><textual class="po-textual">DocTitle</textual></td><td class="po-block e194 e194"><textual class="po-textual">the title of the document</textual></td></tr><tr class="po-table e195 e195" valign="top"><td class="po-block e196 e196"><textual class="po-textual">FID</textual></td><td class="po-block e197 e197"><textual class="po-textual">the File Identifier Number of the document (an integer)</textual></td></tr><tr class="po-table e198 e198" valign="top"><td class="po-block e199 e199"><textual class="po-textual">FileNumber</textual></td><td class="po-block e200 e200"><textual class="po-textual">starts at 1, increases for each new document in the output</textual></td></tr><tr class="po-table e201 e201"><td class="po-block e202 e202"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e203 e203"/></tr><tr class="po-table e204 e204" valign="top"><td class="po-block e205 e205"><textual class="po-textual">BlockInFile, WordInBlock</textual></td><td class="po-block e206 e206"><textual class="po-textual">these determine the location of the match</textual></td></tr><tr class="po-table e207 e207" valign="top"><td class="po-block e208 e208"><textual class="po-textual">NumberOfWordsInPhrase</textual></td><td class="po-block e209 e209"><textual class="po-textual">the length in words of the phrase matched</textual></td></tr><tr class="po-table e210 e210" valign="top"><td class="po-block e211 e211"><textual class="po-textual">TextBefore</textual></td><td class="po-block e212 e212"><textual class="po-textual">the text in the document immediately before the match</textual></td></tr><tr class="po-table e213 e213" valign="top"><td class="po-block e214 e214"><textual class="po-textual">MatchedText</textual></td><td class="po-block e215 e215"><textual class="po-textual">the document text that exactly matches the phrase</textual></td></tr><tr class="po-table e216 e216" valign="top"><td class="po-block e217 e217"><textual class="po-textual">TextAfter</textual></td><td class="po-block e218 e218"><textual class="po-textual">the text in the document immediately after the match</textual></td></tr><tr class="po-table e219 e219"><td class="po-block e220 e220"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e221 e221"/></tr><tr class="po-table e222 e222" valign="top"><td class="po-block e223 e223"><textual class="po-textual">MatchNumber</textual></td><td class="po-block e224 e224"><textual class="po-textual">starts at 1 and increases for each match</textual></td></tr><tr class="po-table e225 e225" valign="top"><td class="po-block e226 e226"><textual class="po-textual">MatchWithinFile</textual></td><td class="po-block e227 e227"><textual class="po-textual">like MatchNumber but reset for each new document</textual></td></tr><tr class="po-table e228 e228" valign="top"><td class="po-block e229 e229"><textual class="po-textual">StartByte</textual></td><td class="po-block e230 e230"><textual class="po-textual">the byte offset in the file at which the match begins</textual></td></tr><tr class="po-table e231 e231" valign="top"><td class="po-block e232 e232"><textual class="po-textual">EndByte</textual></td><td class="po-block e233 e233"><textual class="po-textual">the byte offset in the file at which the match ends</textual></td></tr><tr class="po-table e234 e234" valign="top"><td class="po-block e235 e235"><textual class="po-textual">MatchLength</textual></td><td class="po-block e236 e236"><textual class="po-textual">length in bytes of ${MatchedText} (EndByte - StartByte)</textual></td></tr></tbody></table><para class="po-block e237 e237"><textual class="po-textual">There are also constructs for formatting variables, for padding them
    to a given width (measured in Unicode characters, not bytes), and for
    filtering them through routines that delete punctuation, convert
    punctuation to spaces, perform case conversion and so forth.</textual></para></section><section class="po-hcontainer e238 e238"><title class="po-block e239 e239"><textual class="po-textual">Extending lqkwic</textual></title><para class="po-block e240 e240"><textual class="po-textual">The following XML-specific variables were added as an experiment to
    try to understand how viable the approach would be:</textual></para><table class="po-container e241 e241"><caption class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">XML-specific Variables</textual></para></caption><col align="right" class="po-meta e244 e244" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col class="po-meta e245 e245" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e246 e246"><tr class="po-table e247 e247" valign="top"><th class="po-field e248 e248"><textual class="po-textual">Variable</textual></th><th class="po-field e249 e249"><textual class="po-textual">Description</textual></th></tr></thead><tbody class="po-table e250 e250"><tr class="po-table e251 e251" valign="top"><td class="po-block e252 e252"><textual class="po-textual">XML.Parent.Tag</textual></td><td class="po-block e253 e253"><textual class="po-textual">The content of the containing element's tag, between the
	  angle brackets</textual></td></tr><tr class="po-table e254 e254" valign="top"><td class="po-block e255 e255"><textual class="po-textual">XML.ContentBefore</textual></td><td class="po-block e256 e256"><textual class="po-textual">Content up to the &gt; of the start tag of the immediately enclosing parent element (including any tags and content that open and close entirely between the match and the parent tag)</textual></td></tr><tr class="po-table e257 e257" valign="top"><td class="po-block e258 e258"><textual class="po-textual">XML.Parent.Name</textual></td><td class="po-block e259 e259"><textual class="po-textual">the name of the parent element</textual></td></tr><tr class="po-table e260 e260" valign="top"><td class="po-block e261 e261"><textual class="po-textual">XML.Parent.EndTag</textual></td><td class="po-block e262 e262"><textual class="po-textual">the content of the parent element's end tag</textual></td></tr><tr class="po-table e263 e263" valign="top"><td class="po-block e264 e264"><textual class="po-textual">XML.ContentAfter</textual></td><td class="po-block e265 e265"><textual class="po-textual">content up to the &lt; of the parent's end tag</textual></td></tr></tbody></table><para class="po-block e266 e266"><textual class="po-textual">It is not clear that this is sufficient to answer our use case of
    finding multiple phrases in the same XML element. To do that, we would
    need a way to identify parent elements and compare them.</textual></para><para class="po-block e267 e267"><textual class="po-textual">One could use the File number and the byte offset of the matched
    text (</textual><code class="po-atom e268 e268"><textual class="po-textual">${StartByte}</textual></code><textual class="po-textual">), but this is not sufficient, because
    there may be close and open tags between matches of two phrases.</textual></para><para class="po-block e269 e269"><textual class="po-textual">One approach to finding phrases with a common containing element
    named (of type) E would be to find all of the start and end tags for E,
    and then use the file, block and word within block numbers to perform
    range algebra.</textual></para><para class="po-block e270 e270"><textual class="po-textual">But it would be more efficient if this were not needed. In a corpus
    of many files, it is likely that the element E will occur in many files,
    perhaps many times, and searching for them all will be too slow.</textual></para><para class="po-block e271 e271"><textual class="po-textual">If lqkwic could print the location of the parent tag, a much simpler
    faster algorithm would be possible.</textual></para><para class="po-block e272 e272"><textual class="po-textual">The notation </textual><code class="po-atom e273 e273"><textual class="po-textual">-&gt;startbyte</textual></code><textual class="po-textual"> or
    </textual><code class="po-atom e274 e274"><textual class="po-textual">-&gt;endbyte</textual></code><textual class="po-textual"> was added; after any XML variable name, it
    generates the corresponding byte offset in the matched file.</textual></para><para class="po-block e275 e275"><textual class="po-textual">In addition, the notation </textual><code class="po-atom e276 e276"><textual class="po-textual">XML.parent.Tag.e</textual></code><textual class="po-textual"> was added,
    to be similar to the XPath notation </textual><code class="po-atom e277 e277"><textual class="po-textual">ancestor::e</textual></code><textual class="po-textual">; it is
    possible that a future version of </textual><emphasis class="po-inline e278 e278" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual">
    will use the XPath notation, as long as there is no danger that users will
    be confused into thinking that lq-text is using a node-based model
    internally.</textual></para><para class="po-block e279 e279"><textual class="po-textual">The search for a parent tag is implemented by reading the matched
    document at the block containing the match, and for some distance
    beforehand. lqkwic then searches backwards from the match to find an open
    tag which has no corresponding close tag in the intervening distance. It
    is worth noting that this sort of approach is not generally possible with
    SGML, where empty elements have no end tag. The syntactic innovation of
    XML was to require empty tags to have a trailing slash, as in &lt;p/&gt;
    or &lt;p id="p301" /&gt;, and this enables the software to skip empty
    elements reliably. Start and end tags can be skipped more easily of
    course, although the algorithm used for backwards parsing does rely on
    attributes not containing unquoted &lt; or &gt; signs.</textual></para><para class="po-block e280 e280"><textual class="po-textual">Unfortunately, backwards parsing suffers from a major drawback: the
    search for the parent tag will fail if it is too far away. Although lqkwic
    could in theory read arbitrarily back in the file, this could mean that
    presenting matches in a dictionary would be very expensive, with every
    match processed necessitating a search back to the start of a large
    document.</textual></para><para class="po-block e281 e281"><textual class="po-textual">In practice, an in-memory cache may be sufficient to achieve
    reasonable performance in most cases. Another possibility might be to
    store parent pointers in the index. For now, lq-text is primarily intended
    for working with many thousands of small files; use XSLT to split large
    files before indexing them.</textual></para></section><section class="po-hcontainer e282 e282"><title class="po-block e283 e283"><textual class="po-textual">A sample program</textual></title><para class="po-block e284 e284"><textual class="po-textual">We are now in a position to find all elements E that contain all of
    a set of phrases P0 ... Pn, as follows:</textual></para><para class="po-block e285 e285"><textual class="po-textual">First, match the phrases, and, for each match, use a format of the
    form </textual><code class="po-atom e286 e286"><textual class="po-textual">${xml.contentbefore.E-&gt;endbyte}</textual></code><textual class="po-textual"> to find the end byte
    of the start tag of the parent element of type E; that is, the location
    just after the </textual><code class="po-atom e287 e287"><textual class="po-textual">&gt;</textual></code><textual class="po-textual"> at the end of the start tag. If two
    matches have the same value for the start tag, and are in the same file,
    then they share the same XML ancestor E.</textual></para><para class="po-block e288 e288"><textual class="po-textual">We can match the phrases with a single invocation of </textual><emphasis class="po-inline e289 e289" role="ital"><textual class="po-textual">lqrank</textual></emphasis><textual class="po-textual"> except for one difficulty: there is no way
    to determine, for a given match, to which phrase it corresponds, so we
    cannot determine whether an element contains all of the phrases.</textual></para><para class="po-block e290 e290"><textual class="po-textual">The </textual><emphasis class="po-inline e291 e291" role="ital"><textual class="po-textual">lqrank</textual></emphasis><textual class="po-textual"> program has the ability
    (when instructed with the </textual><code class="po-atom e292 e292"><textual class="po-textual">-g</textual></code><textual class="po-textual"> option) to output a line,
    </textual><code class="po-atom e293 e293"><textual class="po-textual">{ q = N }</textual></code><textual class="po-textual"> where N is an integer, to
    identify to which result set the following matches correspond. This is
    available to </textual><emphasis class="po-inline e294 e294" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> formats as the
    variable </textual><code class="po-atom e295 e295"><textual class="po-textual">g.q</textual></code><textual class="po-textual"> (the </textual><code class="po-atom e296 e296"><textual class="po-textual">g</textual></code><textual class="po-textual"> stands for </textual><emphasis class="po-inline e297 e297" role="ital"><textual class="po-textual">glue</textual></emphasis><textual class="po-textual">, the unpublished and unfinished lq-text
    integration language).</textual></para><para class="po-block e298 e298"><textual class="po-textual">Using this, it becomes a relatively simple matter in a language such
    as Perl, Python or even the Unix shell, to run</textual></para><programlisting class="po-block e299 e299" xml:space="preserve"><emphasis class="po-inline e300 e300" role="ital"><textual class="po-textual">print phrases one per line</textual></emphasis><textual class="po-textual"> |
    lqrank -r all -g -F - |
    lqkwic -s '${FID} ${g.q}
    ${xml.contentbefore.E-&gt;endbyte} ${Match}\n'</textual></programlisting><para class="po-block e301 e301"><textual class="po-textual">Each match is in this way prefixed by the numeric identifier of the
    document in the index (FID), the phrase number and the byte offset of the
    end of the nearest ancestor E element's end tag. The
    </textual><code class="po-atom e302 e302"><textual class="po-textual">-F -</textual></code><textual class="po-textual"> option makes </textual><emphasis class="po-inline e303 e303" role="ital"><textual class="po-textual">lqrank</textual></emphasis><textual class="po-textual"> read the list of phrases to match from its
    input, rather than expecting them as command-line arguments; one could
    also use the Unix </textual><emphasis class="po-inline e304 e304" role="ital"><textual class="po-textual">xargs</textual></emphasis><textual class="po-textual"> program for this
    purpose.</textual></para><para class="po-block e305 e305"><textual class="po-textual">Next we must group the matches by file identifier and startbyte, and
    if every different phrase occurred at least once, we print all the matches
    for that file identifier and startbyte.</textual></para><para class="po-block e306 e306"><textual class="po-textual">The result can then be fed to </textual><emphasis class="po-inline e307 e307" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> to generate a concordance, or perhaps to
    fetch information about the parent element, or both.</textual></para><para class="po-block e308 e308"><textual class="po-textual">The program outlined here (and given in full in the appendix, in the
    Perl programming language) is intended as an example of the sort of
    flexibility that might be achieved as lq-text becomes more XML
    aware.</textual></para></section><section class="po-hcontainer e309 e309"><title class="po-block e310 e310"><textual class="po-textual">Unicode</textual></title><para class="po-block e311 e311"><textual class="po-textual">In 1988, the use of 8-bit character sets was pretty usual; lq-text
    is at least 8-bit clean for data, so that conversion to UTF-8 seemed a
    simple matter, and also has some locale awareness. There were two tricky
    parts to the process of adding UTF-8 support. The first was to ensure that
    characters, rather than bytes, were counted when formatting, and of course
    that a UTF-8 octet sequence was never split part-way through.</textual></para><para class="po-block e312 e312"><textual class="po-textual">The second difficulty was much harder: making sure that combining
    characters are never split from their corresponding base character. This
    last is not yet complete, but initial work using the GNOME glibc library
    is promising. This is the main issue preventing lq-text from being
    shipped, at present, and may have been completed by the time this paper is
    presented in August 2008.</textual></para><para class="po-block e313 e313"><textual class="po-textual">Software cannot tell by inspecting a singly byte (or octet, as
    standards people say, in case 9-bit systems should reoccur) whether that
    octet forms part of a longer UTF-8 sequence. One needs to scan backwards
    to check, because the </textual><emphasis class="po-inline e314 e314" role="ital"><textual class="po-textual">first</textual></emphasis><textual class="po-textual"> octet is the
    one that indicates the number of octets to follow in the sequence that
    constitutes a single character. This is of course easy to deal with as
    long as one can scan backwards a little. For diacritical marks and other
    combining characters, however, one must consult a database. The author
    could not help but wish that a single bit in the character representation
    could have been reserved for this purpose, but that would have prevented
    Unicode from being backwards-compatible with ISO 8859-1, a goal at the
    time Unicode was designed. A future version of lq-text may use its own
    database, with only the character properties that lq-text needs, perhaps
    created automatically at the same time as each database so as to take
    locale information into account.</textual></para></section><section class="po-hcontainer e315 e315"><title class="po-block e316 e316"><textual class="po-textual">Comparing with XQuery 1.0 or XSLT 2 + Full Text</textual></title><para class="po-block e317 e317"><textual class="po-textual">The published draft of Full-Text does not support concordance
    generation, although some implementations in practice (such as MarkLogic)
    do appear to offer the necessary functionality through product-specific
    extensions. The author of this paper considers match highlighting to be
    essential functionality in practice. A future version of Full-Text may
    well include it.</textual></para><para class="po-block e318 e318"><textual class="po-textual">Let us then assume, as we must, that we are using an XQuery or XSLT
    implementation that supports in some way identifying match locations, and
    hence allows highlighting.</textual></para><section class="po-hcontainer e319 e319"><title class="po-block e320 e320"><textual class="po-textual">Advantages of Full-Text</textual></title><orderedlist class="po-table e321 e321"><listitem class="po-container e322 e322"><para class="po-block e323 e323"><textual class="po-textual">With Full-Text, XPath predicates and axes are available, so
          that one can easily find ancestors, parents, position in the element
          tree, and so forth. The lexical approach is very limited in this
          regard.</textual></para></listitem><listitem class="po-container e324 e324"><para class="po-block e325 e325"><textual class="po-textual">Full-Text is (or probably will soon be) a standard, and one
          can easily move between implementations. The necessity of using
          vendor extensions for highlighting reduces this somewhat, but of
          course there is only one implementation of lq-text, albeit with
          source code freely available.</textual></para></listitem><listitem class="po-container e326 e326"><para class="po-block e327 e327"><textual class="po-textual">An XPath implementation with Full-Text might have indexes for
          element location that enable higher performance, for example by
          using one CPU to find elements and another to resolve the text
          search. Although this sort of optimisation is largely at the
          research level today, it is likely to find its way into products,
          both closed and open source, in the near future. Lq-text uses
          multiple programs, which can run on separate CPUs of course (and
          will do so without any action from the user on a multi-CPU system)
          but there are no plans for finer-grained parallelism.</textual></para></listitem><listitem class="po-container e328 e328"><para class="po-block e329 e329"><textual class="po-textual">The Full-Text facility is designed to work with Unicode and
          XML-based language support, giving a high degree of
          internationalisation. Although the author is adding Unicode support
          to lq-text (which previously, because it predated Unicode, used
          8-bit character sets and a locale-based mechanism), it is not yet
          complete and pervasive.</textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">Since lq-text is not tree-based, it does not currently have
          any means to respect xml:lang, nor does it have any understanding of
          namespaces. Prefixed elements and attribute names are not currently
          handled. A solution involving the XML indexing filter is being
          considered for both of these issues, but its effectiveness is as yet
          unknown.</textual></para></listitem><listitem class="po-container e332 e332"><para class="po-block e333 e333"><textual class="po-textual">The Full_text XPath extension is already in wider use than
          lq-text; training, support, books and forums are available for it,
          but not for lq-text.</textual></para></listitem></orderedlist></section><section class="po-hcontainer e334 e334"><title class="po-block e335 e335"><textual class="po-textual">Advantages of a lexical approach</textual></title><orderedlist class="po-table e336 e336"><listitem class="po-container e337 e337"><para class="po-block e338 e338"><textual class="po-textual">Open access to the match list supports flexibility and
          extensibility. The use of separate programs also allows intermediate
          results to be cached or stored and compared easily. By contrast,
          XQuery (where Full-Text is most likely to be found) is a large
          monolithic language. Open Source XQuery implementations are mostly
          in Java, which does not lend itself to good performance if a JVM
          must be started for each query, for example outside a servlet
          environment. None the less it should be mentioned that the fastest
	  readily available indexed XQuery implementation in the
	  author's experience is in Java, and once
          the JVM is started, is very fast.</textual></para></listitem><listitem class="po-container e339 e339"><para class="po-block e340 e340"><textual class="po-textual">Because the data is not forced into the shape of a tree, it is
          possible to experiment, for example with overlapping markup. The
          generation of results by </textual><emphasis class="po-inline e341 e341" role="ital"><textual class="po-textual">lqkwic</textual></emphasis><textual class="po-textual"> can
          include a span from start element to corresponding end element,
	  regardless of other start or end tags.  Although XQuery
	  and XPath 2.0 Full-Text allows for matching as if tags were
	  absent, it does not give good control over which tags are to
	  be treated as word boundaries and which not.  But this is
	  a difficult thing to do at query-time in any case, and
      neither system today has a complete answer for this.</textual></para></listitem><listitem class="po-container e342 e342"><para class="po-block e343 e343"><textual class="po-textual">Lq-text can be used to generate non-XML results, for example a
          bitmap image representing a graph of word occurrence. XQuery and
          XSLT are limited to text and XML, although one can certainly write
          out SVG with them.</textual></para><figure class="po-container e344 e344"><title class="po-block e345 e345"><textual class="po-textual">Occurrences of four-digit numbers</textual></title><mediaobject class="po-container e346 e346"><imageobject class="po-container e347 e347"><imagedata class="po-meta e348 e348" fileref="../../../vol1/graphics/Quin01/Quin01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><para class="po-block e349 e349"><textual class="po-textual">A graph showing four-digit numbers along the x-axis, from
            1500 to 1890 (presumably most of which represent years), and on
            the y-axis the number of times that number occurs in the corpus
            (17,000 entries from </textual><emphasis class="po-inline e350 e350" role="ital"><textual class="po-textual">Brewer's Dictionary of
            Phrase and Fable</textual></emphasis><textual class="po-textual">).</textual></para></figure></listitem><listitem class="po-container e351 e351"><para class="po-block e352 e352"><textual class="po-textual">Experiments with Salton-style similarity functions,
          clustering, and other Information Retrieval techniques might
          eventually find their way back from work like this and into a future
          Full-Text specification. See, for example </textual><xref class="po-milestone e353 e353" linkend="Salton-1989"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or </textual><xref class="po-milestone e354 e354" linkend="Konchady2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for
          descriptions of some applicable information retrieval
          techniques.</textual></para></listitem><listitem class="po-container e355 e355"><para class="po-block e356 e356"><textual class="po-textual">Lq-text lies more in the world of traditional Unix text
          processing than in the world of relational databases. If one is
          primarily interested in finding content in a database, Full-Text is
          a clear winner. If one is more interested in exploring or searching
          text, perhaps lq-text has something to offer.</textual></para></listitem></orderedlist></section><section class="po-hcontainer e357 e357"><title class="po-block e358 e358"><textual class="po-textual">JEXE: Just Enough XML, Eh?</textual></title><para class="po-block e359 e359"><textual class="po-textual">Some XML features were harder to see how to support than others.
      The author has no intent to support all of XML at this time, but just
      enough to be useful. This is regardless of how the XML is parsed. The
      following features are not supported, and are unlikely to be
      supported:</textual></para><orderedlist class="po-table e360 e360"><listitem class="po-container e361 e361"><para class="po-block e362 e362"><textual class="po-textual">CDATA sections; you can use entities instead. This is because
          the retrieval software does not scan the document from the start
          each time, but from the middle, and cannot determine whether markup
          is part of a marked section.</textual></para></listitem><listitem class="po-container e363 e363"><para class="po-block e364 e364"><textual class="po-textual">External general entities (and XInclude); it is more useful
          for people working with XML as files to know the file than the
          document; if you want to resolve included entities, use a
          pre-processor such as </textual><emphasis class="po-inline e365 e365" role="ital"><textual class="po-textual">xmllint</textual></emphasis><textual class="po-textual">
          before indexing.</textual></para></listitem><listitem class="po-container e366 e366"><para class="po-block e367 e367"><textual class="po-textual">Arbitrary namespace support; the limit on namespaces is that
          all </textual><emphasis class="po-inline e368 e368" role="ital"><textual class="po-textual">xmlns</textual></emphasis><textual class="po-textual"> declarations must come
          before any regular attributes. In other words, the order of
          attributes (or pseudo-attributes) is significant. This may change in
          the future; it is because of a limitation in the indexer to do with
          the amount of available look-ahead.</textual></para></listitem><listitem class="po-container e369 e369"><para class="po-block e370 e370"><textual class="po-textual">General entities; although support is planned for entities,
          the plan is to read the replacement text from a per-database
          configuration file. This is already done by lqkwic, but should also
          be done by the indexer. This means that per-document entities are
          not supported. External entities are not supported: the unit of
          retrieval is the file, not the document.</textual></para></listitem><listitem class="po-container e371 e371"><para class="po-block e372 e372"><textual class="po-textual">The internal subset; currently lq-text can skip over an
          internal subset correctly in most cases (it is possible to construct
          an internal subset that will confuse it, I suspect, although this is
          always detected and a warning issued), but it is not parsed.</textual></para></listitem><listitem class="po-container e373 e373"><para class="po-block e374 e374"><textual class="po-textual">Fixed and defaulted attribute values; without reading a DTD or
          internal subset, there are no default values. This could be thought
          of as a minimization feature of SGML that was overlooked during the
          design of XML.</textual></para></listitem><listitem class="po-container e375 e375"><para class="po-block e376 e376"><textual class="po-textual">XML Notations; if the DTD were to be read, it might be
          possible to associate a URI or a MIME content type with a different
          tokenisation system, but the document author cannot know what MIME
          type will be used if a file is served on the Web; the DTD is not
          authoritative, and currently lq-text does not use HTTP to fetch
          things, but only works with local files. If lq-text used HTTP,
          behaviour would be based on the content type header for downloaded
          entities, not on any notation value in the DTD. For a local file,
          the notation value could be treated as a list of plausible content
          types, perhaps, but in practice content sniffing is more likely to
          work.</textual></para></listitem></orderedlist><para class="po-block e377 e377"><textual class="po-textual">The result of this is that a JEXE document consists of an XML
      declaration (the encoding, if given, must be in UTF-8, however), an
      optional doctype declaration to point at an external DTD to be ignored,
      and then one (or more) simple element trees. Elements may have
      attributes, and may also declare namespaces. Namespace prefixes may be
      “normalised” based on a per-database configuration file, with elements
      in a default namespace that is associated with a URI given an explicit
      prefix [This feature is not implemented at the time of writing]. Numeric
      character references are expanded on indexing. Entity references are
      replaced by their per-database string values on retrieval; the plan is
      to index entity references both with their entity name and with their
      expanded value.</textual></para><para class="po-block e378 e378"><textual class="po-textual">The resulting XML can be parsed “from the middle out” for the
      purposes of retrieval.</textual></para><para class="po-block e379 e379"><textual class="po-textual">Although there is only support for a subset of XML, enough of the
      syntax is understood that you can index any XML document. However, some
      features, such as CDATA sections, permit the construction of documents
      that will confuse retrieval, even though the actual CDATA sections will
      be correctly parsed. A possible work-around is to process documents with
      XSLT before indexing them, creating surrogate documents.</textual></para></section><section class="po-hcontainer e380 e380"><title class="po-block e381 e381"><textual class="po-textual">Future Work</textual></title><para class="po-block e382 e382"><textual class="po-textual">The work has shown that adding some simple XML support to lq-text
      is possible, but leaves a lot to be desired. For people already using
      lq-text, the support described in this paper is useful, but it is
      unlikely to persuade many people to try the package for the first
      time.</textual></para><para class="po-block e383 e383"><textual class="po-textual">Adding more support for “just enough XML” will make the package
      more interesting. In the short term, extending the Unicode support is
      necessary before a release, as is more thorough testing and (as always)
      more documentation. After that, changes in the indexer to add support
      for (just enough) namespaces, general text entities and numeric
      character references have been sketched out.</textual></para><para class="po-block e384 e384"><textual class="po-textual">There are no plans to use a full XML parser right now; although
      the author had originally intended to do so, the difficulty in tracking
      exact byte positions in the input delayed the work, and at this point
      although it is now possible, it has become a matter of human
      resources.</textual></para><para class="po-block e385 e385"><textual class="po-textual">It is possible that the work here would be enough to enable
      lq-text to be used by an implementor of XQuery, and the author would
      like to do experiments in that area.</textual></para><para class="po-block e386 e386"><textual class="po-textual">Searching a corpus of documents with disparate markup can be
      difficult with either approach, because one tends to write patterns that
      depend on the markup retrieved. One approach is to try to map queries at
      runtime; this can be a difficult problem of matching incompatible
      hierarchies of elements; see </textual><xref class="po-milestone e387 e387" linkend="Euzenat-2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> on various
      approaches to the problem of matching ontologies. A more pragmatic
      approach is to re-write documents before indexing them, perhaps with
      XSLT. This approach works with both approaches to text retrieval, but
      can be tedious. An intermediate approach might be to define some XPath
      expressions, or to use a W3C XML Schema to impost some specific types,
      to identify sections, titles, paragraphs, and to mark which elements are
      considered to break apart words, phrases and paragraphs. The index could
      then include this information alongside the element structure. More
      experiments in this area are planned.</textual></para></section><section class="po-hcontainer e388 e388"><title class="po-block e389 e389"><textual class="po-textual">Conclusions</textual></title><para class="po-block e390 e390"><textual class="po-textual">The author's original goal in adding XML support to lq-text was to
      use lq-text to help optimise an XQuery implementation. After
      experimenting with an XQuery implementation that supported Full-Text,
      the author decided instead to focus on enhancing lq-text to see if the
      results would be useful. It turns out that they are indeed useful, and
      development is continuing.</textual></para><para class="po-block e391 e391"><textual class="po-textual">It must be admitted, however, that any advantage of lq-text over
      sophisticated XQuery implementations is likely to diminish over
      time.</textual></para><para class="po-block e392 e392"><textual class="po-textual">The subset of XML supported (and with planned support), “just
      enough XML, Eh?” (JEXE), may be worth documenting separately.</textual></para></section></section><bibliography class="po-hcontainer e393 e393"><title class="po-block e394 e394"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e395 e395" xml:id="Adolphs-2006" xreflabel="Adolphs, 2006"><textual class="po-textual">Adolphs,
    Svenja, “Introducing Electronic Text Analysis” (Routledge, 2006). A very
    clear and impressively slender introduction to the application of
    information retrieval, and especially the keyword-in-context list, to
    literary and linguistic research.</textual></bibliomixed><bibliomixed class="po-block e396 e396" xml:id="Baeza-Yates-1999" xreflabel="Baeza-Yates and Marais, 1999"><textual class="po-textual">Baeza-Yates, Ricardo, and Marais, H., “Modern
    Information Retrieval” (ACM Press, 1999). Describes information retrieval
    mostly from the perspective of a researcher in text retrieval rather than
    a programmer or a user, and assumes more background knowledge,
    particularly in mathematics, than Manu Konchady’s book, so may be best
    read second.</textual></bibliomixed><bibliomixed class="po-block e397 e397" xml:id="Euzenat-2007" xreflabel="Euzenat and Shvaiko, 2007"><textual class="po-textual">Euzenat, Jérôme and Shvaiko, Pavel, “Ontology
    Matching” (Springer, 2007); a surprisingly clear introduction to problems
    such as relating two or more different classification schemes (such as XML
    schemas) over the same subject matter, although the presentation uses a
    mathematical notation, and some background in formal logic may be
    helpful.</textual></bibliomixed><bibliomixed class="po-block e398 e398" xml:id="Konchady2006" xreflabel="Konchady2006"><textual class="po-textual">Konchady,
    Manu, “Text Mining Application Programming” (Charles River Media, Boston
    USA, 2006). A useful programmer-level introduction to topics relating to
    implementing and using text retrieval, part-of-speech tagging, clustering
    and other topics, together with just enough mathematics, but not specific
    to any particular language. Includes CD-ROM with code samples in Perl,
    however.</textual></bibliomixed><bibliomixed class="po-block e399 e399" xml:id="Salton-1989" xreflabel="Salton, 1989"><textual class="po-textual">Salton, Gerald,
    “Automatic Text Processing” (Addison-Wesley, 1989). Perhaps a little
    dated, but the late Dr. Salton was extremely influential in the field. His
    earlier, 1983, book formed the basis for a single chapter of this work,
    but the 1983 book is harder to find today.</textual></bibliomixed><bibliomixed class="po-block e400 e400" xml:id="FullText-2007" xreflabel="W3C Full-Text, 2007"><textual class="po-textual">Sihem
    Amer-Yahia, Chavdar Botev, Stephen Buxton, Pat Case, Jochen Doerre, Mary
    Holstege, Jim Melton, Michael Rys and Jayavel Shanmugasundaram (Editors),
    “XQuery 1.0 and XPath 2.0 Full-Text 1.0” [online]. [cited 18th April
    2008].
    </textual><link class="po-inline e401 e401" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-full-text-10/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>