<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">In pursuit of streamable stylesheet functions in XSLT 3.0</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2014</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 5 - 8, 2014</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">With the XSLT Working Draft being in Last Call since December 2013 and the XSL
                Working Group working hard to get the latest bugs fixed, it is only a matter of time
                that the XSLT 3.0 Draft becomes a Candidate Recommendation, locked for changes and
                suitable for implementors to adopt.</textual></para><para class="po-block e8 e8"><textual class="po-textual">One of the bugs the Working Group received was about the inability to create
                stylesheet functions that take streamable nodes as an argument. The group considered
                the omission and decided to ask me to write up a proposal. We discussed several
                iterations of the proposal until recently it was adopted and added to the internal
                Working Draft. </textual></para><para class="po-block e9 e9"><textual class="po-textual">This paper investigates the ways in which stylesheet functions can be made
                streamable and why it is such a complex to task to make them so. It summarizes the
                rules that have been adopted so far according to the public bug entry and shows the
                possibilities it gives for stylesheet and package authors. While the impact on the
                specification is minimal, the impact for authors of packages and stylesheet authors
                in general is potentially big and opens up a whole world of new possibilities in
                streaming.</textual></para></abstract><author class="po-record e10 e10"><personname class="po-record e11 e11"><firstname class="po-field e12 e12"><textual class="po-textual">Abel</textual></firstname><surname class="po-field e13 e13"><textual class="po-textual">Braaksma</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Abel Braaksma is an invited expert of the XSL and XQuery Working Group and is
                    creator and owner of </textual><link class="po-inline e16 e16" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Exselt</textual></link><textual class="po-textual">, a
                    streaming XSLT 3.0 processor. Next to his XSL work for the Working Group he runs
                    a consultancy and outsourcing firm </textual><link class="po-inline e17 e17" xlink:actuate="onRequest" xlink:href="http://abrasoft.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Abrasoft</textual></link><textual class="po-textual">, specializing in data aggregation and XML in .NET
                    environments. He has over 15 years experience in XML and related technologies.
                    You can contact him about Exselt or XML, XSLT and C# / F# related inquiries. His
                    personal thoughts on technological challenges and XSLT in particular are
                    collected on his blog </textual><link class="po-inline e18 e18" xlink:actuate="onRequest" xlink:href="http://undermyhat.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://undermyhat.org</textual></link><textual class="po-textual">.</textual></para></personblurb><email class="po-field e19 e19"><textual class="po-textual">abel[-at-]exselt.net</textual></email><affiliation class="po-record e20 e20"><jobtitle class="po-field e21 e21"><textual class="po-textual">Owner/creator</textual></jobtitle><orgname class="po-block e22 e22"><link class="po-inline e23 e23" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Exselt, a streaming XSLT 3.0 processor</textual></link></orgname></affiliation><affiliation class="po-record e24 e24"><orgname class="po-block e25 e25"><link class="po-inline e26 e26" xlink:actuate="onRequest" xlink:href="http://abrasoft.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Abrasoft Consulting</textual></link></orgname></affiliation><affiliation class="po-record e27 e27"><orgname class="po-block e28 e28"><textual class="po-textual">Blog: </textual><link class="po-inline e29 e29" xlink:actuate="onRequest" xlink:href="http://undermyhat.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">Undermyhat.org</textual></link></orgname></affiliation></author><legalnotice class="po-container e30 e30"><para class="po-block e31 e31"><textual class="po-textual">Copyright © 2014 by the author. Used with permission.</textual></para></legalnotice><keywordset class="po-table e32 e32" role="author"><keyword class="po-field e33 e33"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e34 e34"><textual class="po-textual">XSLT 3.0</textual></keyword><keyword class="po-field e35 e35"><textual class="po-textual">XPath 3.0</textual></keyword><keyword class="po-field e36 e36"><textual class="po-textual">Streaming</textual></keyword><keyword class="po-field e37 e37"><textual class="po-textual">Streamable-stylesheet-functions</textual></keyword><keyword class="po-field e38 e38"><textual class="po-textual">Guaranteed-streamability</textual></keyword><keyword class="po-field e39 e39"><textual class="po-textual">Stylesheet-functions</textual></keyword><keyword class="po-field e40 e40"><textual class="po-textual">User-defined-functions</textual></keyword><keyword class="po-field e41 e41"><textual class="po-textual">Packages</textual></keyword><keyword class="po-field e42 e42"><textual class="po-textual">Recursive-functions</textual></keyword></keywordset></info><section class="po-hcontainer e43 e43" xml:id="notes"><title class="po-block e44 e44"><textual class="po-textual">Notes</textual></title><note class="po-container e45 e45" xreflabel="Updates"><para class="po-block e46 e46"><textual class="po-textual">This paper discusses very recent changes to the XSLT 3.0 specification that are
                still under discussion in the related BugZilla bug entries. When the specification
                is updated, rules laid out in this paper need updating as well. I will publish those
                updates at </textual><link class="po-inline e47 e47" xlink:actuate="onRequest" xlink:href="http://exselt.net/papers" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://exselt.net/papers</textual></link><textual class="po-textual">
                in DocBook and PDF formats.</textual></para></note><note class="po-container e48 e48" xreflabel="Prerequisites"><para class="po-block e49 e49"><textual class="po-textual">To read and understand this paper, a basic understanding of XSLT 3.0 and streaming
                is desirable. For an introduction on streaming, you can refer to two earlier papers
                in this series, </textual><xref class="po-milestone e50 e50" linkend="Braaksma14a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, about the </textual><emphasis class="po-inline e51 e51" role="ital"><textual class="po-textual">Ten
                    rules of thumb of streaming</textual></emphasis><textual class="po-textual"> and </textual><xref class="po-milestone e52 e52" linkend="Braaksma14b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, about
                </textual><emphasis class="po-inline e53 e53" role="ital"><textual class="po-textual">Streaming XSLT design patterns</textual></emphasis><textual class="po-textual">.</textual></para></note></section><section class="po-hcontainer e54 e54" xml:id="disclaimer"><title class="po-block e55 e55"><textual class="po-textual">Disclaimer</textual></title><para class="po-block e56 e56"><textual class="po-textual">This paper relies on information that can be found in the public </textual><xref class="po-milestone e57 e57" linkend="XsltLastCall"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> at the time of this writing, and in some of the public XSLT
            3.0 BugZilla bugs (see </textual><xref class="po-milestone e58 e58" linkend="W3cBugzilla"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). While I am an </textual><emphasis class="po-inline e59 e59" role="ital"><textual class="po-textual">invited expert</textual></emphasis><textual class="po-textual"> for the XSL Working Group, I do not speak at
            there behalf, and any thoughts I lay out in this paper are my own and are not
            necessarily the thoughts of the XSL Working Group.</textual></para><para class="po-block e60 e60"><textual class="po-textual">Changes to the Last Call Working Draft will be discussed through the same BugZilla and
            will ultimately result in the publication of a new version of the specification in </textual><xref class="po-milestone e61 e61" linkend="Xslt30Latest"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Where this paper refers to XPath, XPath functions and
            operators or the XDM, it uses </textual><xref class="po-milestone e62 e62" linkend="XPathRec"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e63 e63" linkend="FuncOpRec"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
            and </textual><xref class="po-milestone e64 e64" linkend="XdmRec"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e65 e65"><textual class="po-textual">Since the XSLT 3.0 specification is not final yet, it is possible that syntax or
            semantics of constructs used in this paper change in the future or are dropped in their
            entirety. Large parts of this paper rely on discussions and conclusions of functionality
            reported in the public section of BugZilla. Where the text of this paper deviates from
            the public Working Draft and where these changes are publicly available through
            BugZilla, I will state so by using footnotes.</textual></para></section><section class="po-hcontainer e66 e66"><title class="po-block e67 e67"><textual class="po-textual">Introduction</textual></title><para class="po-block e68 e68"><textual class="po-textual">Streamability analysis is a complex subject, yet the basics are, as is often the case,
            relatively trivial: just write your stylesheet in such a way that it only uses the child
            axis, plus an occasional escape to node properties such as attributes on the ancestor or
            self axes, and you have essentially written a streamable stylesheet.</textual></para><para class="po-block e69 e69"><textual class="po-textual">But in practice, it is not so trivial. Rules in the specification are complex and even
            hard-core spec-readers have trouble following them. They are meant for implementors and
            not necessarily for programmers or users, which is why these rules have to take care of
            every possible corner case and yet make sure that for general use, the rules work with
            the least possible surprises.</textual></para><para class="po-block e70 e70"><textual class="po-textual">This paper tries to fill in the gap between spec-prose and tutorial. While there
            currently are no tutorials on the subject of streamable stylesheet functions, this paper
            aims to explain the basics and several rather advanced concepts such as recursive
            streamable functions, in a way that it becomes understandable for a larger
            public.</textual></para><para class="po-block e71 e71"><textual class="po-textual">A streamable stylesheet function is a function that can take a streamed node from a
            streaming input document, while still passing the tests for being guaranteed streamable.
            Being able to write streamable stylesheet functions is import for package designers, so
            that they can create functions that work alike for streaming and non-streaming
            scenarios.</textual></para><para class="po-block e72 e72"><textual class="po-textual">This paper first introduces you to part of the terminology used in the specification
            and at several sections in this paper, see </textual><xref class="po-milestone e73 e73" linkend="terminology"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. It then
            explains typical use-cases for streamable functions in </textual><xref class="po-milestone e74 e74" linkend="case-for-functions"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, after which it explains the challenges we face when
            dealing with streamability analysis and streamable functions in </textual><xref class="po-milestone e75 e75" linkend="challenge"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. </textual></para><para class="po-block e76 e76"><textual class="po-textual">Streamability of standard, non-recursive functions is explained in </textual><xref class="po-milestone e77 e77" linkend="posture-sweep"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e78 e78" linkend="multiple-arguments"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">; and the rather
            complex subject of streamability for recursive functions is dealt with in depth in </textual><xref class="po-milestone e79 e79" linkend="recursion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and its sub-sections. Futher sections deal with packages and
            function inheritance with respect to streamability (see </textual><xref class="po-milestone e80 e80" linkend="packages"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and
            a proposal for a general improvement to the analysis of the posture in </textual><xref class="po-milestone e81 e81" linkend="terminology"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. And in </textual><xref class="po-milestone e82 e82" linkend="miscelleneous"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> several related
            subjects are covered on inline functions, partial function application, named function
            refverences and dynamic function calls. </textual></para><para class="po-block e83 e83"><textual class="po-textual">The current state of the specification is discussed in </textual><xref class="po-milestone e84 e84" linkend="specification-status"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and the current state of processors with regard to
            streamability analysis of stylesheet functions in </textual><xref class="po-milestone e85 e85" linkend="status-processors"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e86 e86" xml:id="terminology"><title class="po-block e87 e87"><textual class="po-textual">Streaming terminology</textual></title><para class="po-block e88 e88"><textual class="po-textual"> This section will briefly discussed terminology used throughout this paper. This
            overview does not try to be complete.</textual></para><para class="po-block e89 e89"><textual class="po-textual">
            </textual><itemizedlist class="po-table e90 e90"><listitem class="po-container e91 e91"><para class="po-block e92 e92"><emphasis class="po-inline e93 e93" role="ital"><textual class="po-textual">Guaranteed streamable:</textual></emphasis><textual class="po-textual"> determines
                        whether a particular construct, instruction or declaration is streamable
                        according to the streamability rules in section 19 of the XSLT 3.0
                        specification. If it is, any processor that is conformant with the
                        streamability feature will be able to process your input using streaming,
                        that is, by reading the input in forward-only mode without keeping the whole
                        document in memory.</textual></para></listitem><listitem class="po-container e94 e94"><para class="po-block e95 e95"><emphasis class="po-inline e96 e96" role="ital"><textual class="po-textual">Posture:</textual></emphasis><textual class="po-textual"> the posture of a construct
                        determines the state of a streamed node in the output of that construct.
                        Often, this will be the same as the input posture. It is used in
                        streamability analysis to determine whether a construct returns streamed
                        nodes and in what way. Many constructs are capable of returning streamed
                        nodes, but if all rules are followed, the usages of these constructs are
                        limited in such a way that they can only return a subset that is compatible
                        with streaming. The different postures are:</textual><itemizedlist class="po-table e97 e97"><listitem class="po-container e98 e98"><para class="po-block e99 e99"><emphasis class="po-inline e100 e100" role="ital"><textual class="po-textual">Grounded:</textual></emphasis><textual class="po-textual"> the construct
                                    does not return a reference to a streamed node. An expression or
                                    instruction operating on a grounded posture is allowed to be
                                    free-ranging. Examples: </textual><code class="po-atom e101 e101"><textual class="po-textual">fn:currentDateTime</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e102 e102"><textual class="po-textual">fn:copy-of</textual></code><textual class="po-textual">, </textual><code class="po-atom e103 e103"><textual class="po-textual">xsl:copy-of</textual></code><textual class="po-textual">, a
                                    variable reference.</textual></para></listitem><listitem class="po-container e104 e104"><para class="po-block e105 e105"><emphasis class="po-inline e106 e106" role="ital"><textual class="po-textual">Climbing:</textual></emphasis><textual class="po-textual"> the construct can
                                    return nodes that refer climb the tree through the ancestor or
                                    attribute axis. Examples: </textual><code class="po-atom e107 e107"><textual class="po-textual">parent::foo</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e108 e108"><textual class="po-textual">author/@name</textual></code><textual class="po-textual">, </textual><code class="po-atom e109 e109"><textual class="po-textual">..</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e110 e110"><para class="po-block e111 e111"><emphasis class="po-inline e112 e112" role="ital"><textual class="po-textual">Striding:</textual></emphasis><textual class="po-textual"> the construct can
                                    return non-overlapping nodes, typically only on the child axis.
                                    Examples: any child-select expression, any match pattern,
                                        </textual><code class="po-atom e113 e113"><textual class="po-textual">fn:zero-or-one</textual></code><textual class="po-textual">,
                                    </textual><code class="po-atom e114 e114"><textual class="po-textual">fn:outermost</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e115 e115"><para class="po-block e116 e116"><emphasis class="po-inline e117 e117" role="ital"><textual class="po-textual">Crawling:</textual></emphasis><textual class="po-textual"> the construct can
                                    return overlapping nodes on a downward axis. Examples:
                                        </textual><code class="po-atom e118 e118"><textual class="po-textual">foo/descendant-or-self::bar</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e119 e119"><textual class="po-textual">./b//c</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e120 e120"><para class="po-block e121 e121"><emphasis class="po-inline e122 e122" role="ital"><textual class="po-textual">Roaming:</textual></emphasis><textual class="po-textual"> the construct can
                                    return nodes that can be anywhere in the input tree. Examples:
                                        </textual><code class="po-atom e123 e123"><textual class="po-textual">following::node()</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e124 e124"><textual class="po-textual">ancestor::foo/bar</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e125 e125"><textual class="po-textual">preceding-sibling::price</textual></code><textual class="po-textual">.</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e126 e126"><para class="po-block e127 e127"><emphasis class="po-inline e128 e128" role="ital"><textual class="po-textual">Sweep:</textual></emphasis><textual class="po-textual"> the sweep of a construct
                        determines how the current read position of the input stream is changed as a
                        result of executing the construct. The different sweeps are:</textual><itemizedlist class="po-table e129 e129"><listitem class="po-container e130 e130"><para class="po-block e131 e131"><emphasis class="po-inline e132 e132" role="ital"><textual class="po-textual">Motionless:</textual></emphasis><textual class="po-textual"> the read
                                    position does not change. This is true for expressions that only
                                    operate on grounded nodes or data, and for expressions that
                                    request a property of a node or the ancestor axis</textual><footnote class="po-popup e133 e133"><para class="po-block e134 e134"><textual class="po-textual">The ancestor-or-self axis is available during
                                            streaming and requesting properties on nodes on that
                                            axis is allowed. However, it is not possible to navigate
                                            away from that axis, doing so would result in a
                                            free-ranging and roaming expression.</textual></para></footnote><textual class="po-textual">. Examples: </textual><code class="po-atom e135 e135"><textual class="po-textual">fn:has-children(.)</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e136 e136"><textual class="po-textual">@name</textual></code><textual class="po-textual">, </textual><code class="po-atom e137 e137"><textual class="po-textual">if(./name()) then ...</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e138 e138"><textual class="po-textual">ancestor-or-self::para/@xml:lang</textual></code><textual class="po-textual">, any constant
                                    and any expression not operating on a streamed node.</textual></para></listitem><listitem class="po-container e139 e139"><para class="po-block e140 e140"><emphasis class="po-inline e141 e141" role="ital"><textual class="po-textual">Consuming:</textual></emphasis><textual class="po-textual"> the read
                                    position changes in a forward-only direction. Any expression
                                    that requires read-ahead is considered a consuming expression,
                                    unless the current node is a childless node, such as text- and
                                    comment nodes. Consuming constructs form the heart of
                                    streamability analysis. Any construct may have at most one
                                    consuming construct. Examples: </textual><code class="po-atom e142 e142"><textual class="po-textual">fn:count(foo)</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e143 e143"><textual class="po-textual">x/y</textual></code><textual class="po-textual">, </textual><code class="po-atom e144 e144"><textual class="po-textual">&lt;xsl:value-of select="name"
                                        /&gt;</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e145 e145"><para class="po-block e146 e146"><emphasis class="po-inline e147 e147" role="ital"><textual class="po-textual">Free-ranging:</textual></emphasis><textual class="po-textual"> the construct
                                    cannot be evaluated by using forward-only movement of the read
                                    pointer of the input stream, for instance when evaluation of a
                                    filter expression requires look-ahead. Typically, a free-ranging
                                    construct is also roaming. Examples: </textual><code class="po-atom e148 e148"><textual class="po-textual">foo[bar]</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e149 e149"><textual class="po-textual">parent::author/book</textual></code><textual class="po-textual">, any </textual><code class="po-atom e150 e150"><textual class="po-textual">xsl:sort</textual></code><textual class="po-textual">
                                    on streamed nodes, </textual><code class="po-atom e151 e151"><textual class="po-textual">@* | foo</textual></code><textual class="po-textual">, </textual><code class="po-atom e152 e152"><textual class="po-textual">if(a) then b
                                        else c</textual></code><textual class="po-textual">, </textual><code class="po-atom e153 e153"><textual class="po-textual">fn:reverse(index)</textual></code><textual class="po-textual">.</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e154 e154"><para class="po-block e155 e155"><emphasis class="po-inline e156 e156" role="ital"><textual class="po-textual">Usage:</textual></emphasis><textual class="po-textual"> the usage determines what an
                        operand of a construct does when it receives a streamed node as argument.
                        The following usages are defined:</textual><itemizedlist class="po-table e157 e157"><listitem class="po-container e158 e158"><para class="po-block e159 e159"><emphasis class="po-inline e160 e160" role="ital"><textual class="po-textual">Inspection:</textual></emphasis><textual class="po-textual"> if the argument
                                    is a streamed node, it will inspect the node, but not consume
                                    the node, resulting in a motionless sweep (assuming no other
                                    part of the expression or construct consumes the input). An
                                    inspection operand is the only operand that can take a climbing,
                                    motionless expression as its argument.</textual></para></listitem><listitem class="po-container e161 e161"><para class="po-block e162 e162"><emphasis class="po-inline e163 e163" role="ital"><textual class="po-textual">Absorption:</textual></emphasis><textual class="po-textual"> if the argument
                                    is a streamed node, it will consume the node, resulting in a
                                    consuming sweep. Examples are arguments of </textual><code class="po-atom e164 e164"><textual class="po-textual">fn:data</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e165 e165"><textual class="po-textual">fn:string</textual></code><textual class="po-textual">, constructor functions,
                                        </textual><code class="po-atom e166 e166"><textual class="po-textual">xsl:value-of/@select</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e167 e167"><textual class="po-textual">xsl:apply-templates/@select</textual></code><textual class="po-textual"> and text value and
                                    attribute value templates.</textual></para></listitem><listitem class="po-container e168 e168"><para class="po-block e169 e169"><emphasis class="po-inline e170 e170" role="ital"><textual class="po-textual">Transmission:</textual></emphasis><textual class="po-textual"> if the
                                    argument is a streamed node, the result will also be a streamed
                                    node. Depending on the function or construct, this can result in
                                    any kind of sweep. Examples are arguments of
                                        </textual><code class="po-atom e171 e171"><textual class="po-textual">fn:outermost</textual></code><textual class="po-textual">, </textual><code class="po-atom e172 e172"><textual class="po-textual">fn:remove</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e173 e173"><textual class="po-textual">fn:subsequence</textual></code><textual class="po-textual">,
                                        </textual><code class="po-atom e174 e174"><textual class="po-textual">xsl:sequence/@select</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e175 e175"><para class="po-block e176 e176"><emphasis class="po-inline e177 e177" role="ital"><textual class="po-textual">Navigation:</textual></emphasis><textual class="po-textual"> if the argument
                                    is a streamed node, there is no guarantee that calling the
                                    construct will be streamable. Typically, a navigational operand
                                    will result in free-ranging and roaming streamability analysis
                                    results. Examples are arguments of
                                        </textual><code class="po-atom e178 e178"><textual class="po-textual">xsl:call-template</textual></code><textual class="po-textual"> (the implicit context item,
                                    making it impossible to use this instruction with streamed
                                    nodes), first argument of </textual><code class="po-atom e179 e179"><textual class="po-textual">fn:fold-left</textual></code><textual class="po-textual">, last
                                    argument of </textual><code class="po-atom e180 e180"><textual class="po-textual">fn:key</textual></code><textual class="po-textual">, </textual><code class="po-atom e181 e181"><textual class="po-textual">fn:innermost</textual></code><textual class="po-textual">, any
                                    untyped argument to a stylesheet function not specifically
                                    marked streamable.</textual></para></listitem></itemizedlist></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><para class="po-block e182 e182"><textual class="po-textual">The combination of posture, sweep and usage determines whether a certain construct is
            guaranteed streamable or not. Constructs can be nested, and constructs have operands.
            What exactly constitutes a construct and operands is outside the scope of this paper</textual><footnote class="po-popup e183 e183"><para class="po-block e184 e184"><textual class="po-textual">See section 19 of the XSL 3.0 specification.</textual></para></footnote><textual class="po-textual">, except for stylesheet functions, which will be explained in the following
            sections.</textual></para></section><section class="po-hcontainer e185 e185" xml:id="case-for-functions"><title class="po-block e186 e186"><textual class="po-textual">A case for streamable functions</textual></title><para class="po-block e187 e187"><textual class="po-textual">Functions are a nice machinery in XSLT 2.0 that have surplaced most of the
                </textual><code class="po-atom e188 e188"><textual class="po-textual">xsl:call-template</textual></code><textual class="po-textual"> scenarios from XSLT 1.0. The benefit of being able to
            create a function and call it directly inside an XPath expression or in a pattern filter
            has shown its use-cases. More often than not, functions tend to operate on atomic types,
            such as strings and integers, because the natural habitat for nodes processing is done
            declaratively by template matching. This is often called </textual><emphasis class="po-inline e189 e189" role="ital"><textual class="po-textual">The XSLT
                way of doing things</textual></emphasis><textual class="po-textual">, see </textual><xref class="po-milestone e190 e190" linkend="Welker08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e191 e191" linkend="Gerstbach06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e192 e192" linkend="Lenz05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, and even today, this is still
            often advocated on the XSL Mailing List</textual><footnote class="po-popup e193 e193"><para class="po-block e194 e194"><textual class="po-textual">See </textual><link class="po-inline e195 e195" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/xsl/xsl-list/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XSL Mailing List
                        at Mulberry Tech's</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual"> and on discussion fora such as StackOverflow</textual><footnote class="po-popup e196 e196"><para class="po-block e197 e197"><textual class="po-textual">See, for instance, </textual><link class="po-inline e198 e198" xlink:actuate="onRequest" xlink:href="http://stackoverflow.com/questions/2835567/xslt-templates-and-recursion" xlink:show="new" xlink:type="simple"><textual class="po-textual">StackOverflow question 2835567 on templates and recursion</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual"> and Experts-Exchange.com. However, even advocates of using templates over
            (recursive) functions, such as Dimitre Novatchev, sometimes choose a function over a
            template based scenario because it is clearer or because it is simply a better tool for
            that particular job</textual><footnote class="po-popup e199 e199"><para class="po-block e200 e200"><textual class="po-textual">See, for instance, his answer in </textual><link class="po-inline e201 e201" xlink:actuate="onRequest" xlink:href="http://stackoverflow.com/questions/16631213/writing-a-recursive-function-xslt-xpath-for-computing-new-values" xlink:show="new" xlink:type="simple"><textual class="po-textual">question 16631213 at StackOverflow</textual></link><textual class="po-textual">, which uses recursion on element
                    nodes, it's an example where functions are arguably a better choice than
                    template matching.</textual></para></footnote><textual class="po-textual">, or in the words of Jeni Tennison in </textual><xref class="po-milestone e202 e202" linkend="Tennison01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">: </textual><blockquote class="po-container e203 e203"><para class="po-block e204 e204"><emphasis class="po-inline e205 e205" role="ital"><textual class="po-textual">“If the result follows the structure of the source, then
                        a push method is more natural — the source drives the process. If the result
                        has a substantially different structure from the source, then a pull method
                        is more natural — the result drives the process.”</textual></emphasis></para></blockquote></para><para class="po-block e206 e206"><textual class="po-textual">It should be said: in XSLT 3.0, the natural way of doing things with nodes from an
            input tree is to use template declarations. This is no other than previous XSLT
            versions. Perhaps it is even stronger now that it is possible to apply templates on
            atomic values such as sequences of strings as well</textual><footnote class="po-popup e207 e207"><para class="po-block e208 e208"><textual class="po-textual">See section </textual><link class="po-inline e209 e209" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#dt-pattern" xlink:show="new" xlink:type="simple"><textual class="po-textual">5.6
                        Patterns</textual></link><textual class="po-textual">, specifically the part on </textual><emphasis class="po-inline e210 e210" role="ital"><textual class="po-textual">predicate
                        patterns</textual></emphasis><textual class="po-textual"> in the XSLT 3.0 Working Draft.</textual></para></footnote><textual class="po-textual">. But this does not help with complex patterns, which can only be replaced by
            functions. Also, it does not help in scenarios where reusing a result in an expression
            is important, which is where functions come into play: they can be used inside
            expressions and call-template nor apply-template can do that (unless wrapped inside a
            function, that is).</textual></para><para class="po-block e211 e211"><textual class="po-textual">The current working draft, which is in Last Call, does not have a provision for
            streamable functions. That is, it is impossible in any which way to pass a streamed node
            to a function. Dimitre Novatchev's example from the StackOverflow question would
            therefore not be possible in a streaming scenario. Now that more and more people have
            gotten used to write functions, and with the advent of (precompiled) XSLT packages
            containing lots and lots of library functions, it seems unfair that they cannot continue
            doing so in streamable scenarios, nor does it seem fair that library vendors will not
            have any means to create library packages with functions that are
            streaming-aware.</textual></para><para class="po-block e212 e212"><textual class="po-textual">The XSL Working Group has considered this and as the solution of </textual><link class="po-inline e213 e213" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple"><textual class="po-textual">Bug 25679</textual></link><textual class="po-textual">
            shows, the proposal was considered and adopted into the internal working draft. The
            following sections will explain my personal analysis on the situation and </textual><xref class="po-milestone e214 e214" linkend="specification-status"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> will summarize which parts of this analysis match
            the specification. Since the discussion on this bug report is not final yet, anything in
            that section is very preliminary and may change without prior notice.</textual></para></section><section class="po-hcontainer e215 e215" xml:id="stylesheet-functions"><title class="po-block e216 e216"><textual class="po-textual">Stylesheet functions in streaming scenarios before they were allowed to be
            streamable</textual></title><para class="po-block e217 e217"><textual class="po-textual">In the current XSL Transformations 3.0 Last Call Working Draft, calls on stylesheet
            functions are analysed based on the declared type of the arguments. If an argument is
            typed as an atomizing type, such as </textual><code class="po-atom e218 e218"><textual class="po-textual">xs:string</textual></code><textual class="po-textual"> or </textual><code class="po-atom e219 e219"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">,
            the usage of that argument will be </textual><emphasis class="po-inline e220 e220" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual">, in other
            words, it will absorb a streamed node, which in most cases results in a </textual><emphasis class="po-inline e221 e221" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> sweep. The result of such function calls is defined
            as </textual><emphasis class="po-inline e222 e222" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">. If the argument is untyped or is a type
            that can take nodes, it is disallowed to pass a streamed node to the function call,
            because there is no way of knowing statically what will happen with that node inside the
            function. I call this the </textual><emphasis class="po-inline e223 e223" role="ital"><textual class="po-textual">safe bet</textual></emphasis><textual class="po-textual">: disallowing
            streamed nodes as arguments makes streamability analysis easier. Example:</textual><figure class="po-container e224 e224" xml:id="f-square" xreflabel="Code listing: calculate square"><programlisting class="po-block e225 e225" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:square"&gt;
    &lt;xsl:param name="i" as="xs:integer" /&gt;
    &lt;xsl:value-of select="$i * $i" /&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="number"&gt;
    &lt;xsl:sequence select="f:square(.)" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure></para><para class="po-block e226 e226"><textual class="po-textual">In this example, the function </textual><code class="po-atom e227 e227"><textual class="po-textual">f:square</textual></code><textual class="po-textual"> takes an argument </textual><code class="po-atom e228 e228"><textual class="po-textual">$i</textual></code><textual class="po-textual">
            that is of type </textual><code class="po-atom e229 e229"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">. Upon calling the function, the processor will
            have to atomize the value or node. To do so, it must process all its children, which is
            why such a usage is considered </textual><emphasis class="po-inline e230 e230" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">. In this
            case, the element </textual><code class="po-atom e231 e231"><textual class="po-textual">number</textual></code><textual class="po-textual"> will be atomized.</textual></para><para class="po-block e232 e232"><textual class="po-textual">This is a typical way of writing functions and it works perfectly well with streaming.
            However, if you want the argument to be a node and get some properties of a node or
            process the node's children, it gets trickier, since passing a node to a function is
            disallowed with streaming. Consider the following:</textual></para><para class="po-block e233 e233"><textual class="po-textual">
            </textual><figure class="po-container e234 e234" xml:id="f-hasname" xreflabel="Code listing: get attribute of ancestor"><programlisting class="po-block e235 e235" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:hasname"&gt;
    &lt;xsl:param name="n" as="item()" /&gt;
    &lt;xsl:sequence select="
        if($n/ancestor::node()[@name]) 
        then true() 
        else false()" /&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="author[f:hasname(.)]"&gt;
    &lt;xsl:text&gt;Has name attribute in ancestor!&lt;/xsl:text&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
        </textual></para><para class="po-block e236 e236"><textual class="po-textual">In this example, the call to the function is not streamable. We pass on a node to the
            function and the rules in the current Working Draft state that it has usage </textual><emphasis class="po-inline e237 e237" role="ital"><textual class="po-textual">navigation</textual></emphasis><footnote class="po-popup e238 e238"><para class="po-block e239 e239"><textual class="po-textual">Before user-defined stylesheet functions were allowed to be streamable and
                    take on streamed nodes, the rules were as in the current Working Draft:
                        </textual><quote class="po-inline e240 e240"><textual class="po-textual">For a call to a stylesheet function, the general streamability rules
                        apply. There is one operand role for each argument in the function
                        signature, and its operand usage is the type-determined usage based on the
                        declared type of that argument.</textual></quote><textual class="po-textual">, see section </textual><link class="po-inline e241 e241" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-function-calls" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.12 Streamability of Function Calls</textual></link><textual class="po-textual"> in XSLT 3.0 Working Draft.
                    Please note that this and other references to the WD will change when the next
                    version of the specification comes out.</textual></para></footnote><textual class="po-textual">, which has the effect that the whole expression, in this case the match
            pattern </textual><code class="po-atom e242 e242"><textual class="po-textual">author[f:hasname(.)]</textual></code><textual class="po-textual">, will be </textual><emphasis class="po-inline e243 e243" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e244 e244" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">, in other
            words, it is not </textual><emphasis class="po-inline e245 e245" role="ital"><textual class="po-textual">guaranteed streamable</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e246 e246"><textual class="po-textual">It is possible to call the function in some situations, by using the
                </textual><code class="po-atom e247 e247"><textual class="po-textual">fn:copy-of</textual></code><textual class="po-textual"> or </textual><code class="po-atom e248 e248"><textual class="po-textual">fn:snapshot</textual></code><textual class="po-textual"> functions. But that means that
            users of your function must have enough knowledge to know what atomizing or </textual><emphasis class="po-inline e249 e249" role="ital"><textual class="po-textual">grounding</textual></emphasis><textual class="po-textual"> function to use before passing on an argument. In
            this particular case, it would make little sense to use either of these functions,
            because a match pattern must be motionless, so it is not possible to use the function in
            a match pattern predicate expression. This is essentially true for any function that
            does not consume the input tree. With the current rules in place, even if a function
            does not consume the input tree, you still need to create a copy of the tree to call
            that function. Hardly efficient and in many cases impossible with streaming, because the
            input node may simply be too big to be copied.</textual></para><para class="po-block e250 e250"><textual class="po-textual">Were you to use it in another context, you still have to choose between
                </textual><code class="po-atom e251 e251"><textual class="po-textual">fn:copy-of</textual></code><textual class="po-textual"> and </textual><code class="po-atom e252 e252"><textual class="po-textual">fn:snapshot</textual></code><textual class="po-textual">. This function would not work
            with </textual><code class="po-atom e253 e253"><textual class="po-textual">fn:copy-of</textual></code><textual class="po-textual">, because that function does not copy the ancestor axis. In
            other words, you must know the internals of the function to find out that you need to
            call it with a call to </textual><code class="po-atom e254 e254"><textual class="po-textual">fn:snapshot</textual></code><textual class="po-textual">. And even then, if the function requires
            information from the original document, such as the </textual><emphasis class="po-inline e255 e255" role="ital"><textual class="po-textual">base-uri</textual></emphasis><textual class="po-textual"> or other properties that are not copied with either of those
            functions, you are out of luck.</textual></para><para class="po-block e256 e256"><textual class="po-textual">In essence, these rules disallow stylesheet authors to write a function that take
            nodes as arguments, and in the case of library package authors, they will not be able to
            write functions that take nodes that work the same way in a streaming scenario and a
            non-streaming one. They would have to educate library function users how to use their
            functions in a streaming scenario and many functions will never work in streaming
            scenarios because their usage would always be </textual><emphasis class="po-inline e257 e257" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> even though the function body does not actually consume the
            input node. In other words, it makes writing functions for use in streamable stylesheets
            next to useless.</textual></para></section><section class="po-hcontainer e258 e258" xml:id="challenge"><title class="po-block e259 e259"><textual class="po-textual">The challenge of streamable stylesheet functions</textual></title><para class="po-block e260 e260"><textual class="po-textual">It is often trivial to see at a glance that a function is </textual><emphasis class="po-inline e261 e261" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> and that it would not hurt using it on a streamed input node.
            Take, for instance, </textual><xref class="po-milestone e262 e262" linkend="f-hasname"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> from the previous section. It only uses
            the ancestor axis and tests whether one exists with an attribute </textual><code class="po-atom e263 e263"><textual class="po-textual">@name</textual></code><textual class="po-textual">.
            Since walking the ancestor axis is motionless (the processor is required to keep a stack
            of the ancestor nodes and their properties) and the attribute axis is too, any call on
            that function would be motionless with respect to its argument.</textual></para><para class="po-block e264 e264"><textual class="po-textual">This shows us one thing: it is possible to write functions that can be statically
            analyzed to be </textual><emphasis class="po-inline e265 e265" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">. But this function has
            special properties: the body of the function is </textual><emphasis class="po-inline e266 e266" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> and the result of the function is </textual><emphasis class="po-inline e267 e267" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">. That means, it can never return any nodes, it can either
            return </textual><code class="po-atom e268 e268"><textual class="po-textual">true()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e269 e269"><textual class="po-textual">false()</textual></code><textual class="po-textual">. But can we always statically
            determine that that is the case? Let us write a slightly different function, this time
            we return the attribute node, instead of testing for it:</textual></para><para class="po-block e270 e270"><textual class="po-textual">
            </textual><figure class="po-container e271 e271" xreflabel="Code listing: return attribute node"><programlisting class="po-block e272 e272" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:hasname"&gt;
   &lt;xsl:param name="n" as="item()" /&gt;
   &lt;xsl:sequence select="$n/ancestor::node()/@name" /&gt;
&lt;/xsl:function&gt;

&lt;!-- guaranteed streamable: --&gt;
&lt;xsl:template match="author[f:hasname(.)]"&gt;
   &lt;xsl:text&gt;Has name attribute in ancestor!&lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;!-- potentially guaranteed streamable: --&gt;
&lt;xsl:template match="*"&gt;
   &lt;xsl:apply-templates select="author/f:hasname(.)" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
        </textual></para><para class="po-block e273 e273"><textual class="po-textual">The function still takes a node as its argument, but this time it returns a reference
            to an attribute of the ancestor axis of that node. The attribute axis has </textual><emphasis class="po-inline e274 e274" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture, which is limited in that you cannot
            navigate downwards again from it. In the first usage of this function, in the predicate
            of the pattern, the input is the current node, but a predicate only has to be true
            (nodes are there) or false (no nodes). After that, there is no navigation away from the
                </textual><emphasis class="po-inline e275 e275" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture, so this could be considered
            streamable.</textual></para><para class="po-block e276 e276"><textual class="po-textual">If we take a look at the second example, we see there an
                </textual><code class="po-atom e277 e277"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual">. By definition, assuming the rest of your
            stylesheet is guaranteed streamable, any apply-templates will be an atomizing construct:
            templates must be grounded and therefore, passing on nodes to a template will atomize
            those nodes. Just as we saw before, atomizing means that the node is consumed. In
            streamability terms this means it has usage </textual><emphasis class="po-inline e278 e278" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual">. But to consume a node, its children must be visited, which
            is a downward movement. The argument has a </textual><emphasis class="po-inline e279 e279" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">
            posture because it ends with </textual><code class="po-atom e280 e280"><textual class="po-textual">f:hasname(.)</textual></code><textual class="po-textual">, which we know returns attribute
            nodes, which are </textual><emphasis class="po-inline e281 e281" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e282 e282"><textual class="po-textual">There is a caveat, however: if the </textual><emphasis class="po-inline e283 e283" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">
            expression returns childless nodes, consuming such a node will not harm the streaming
            process: there are no children to consume. The </textual><emphasis class="po-inline e284 e284" role="ital"><textual class="po-textual">General
                Streamability Rules</textual></emphasis><footnote class="po-popup e285 e285"><para class="po-block e286 e286"><textual class="po-textual">See section 19.8.1. in XSL Transformations 3.0.</textual></para></footnote><textual class="po-textual"> in the specification have a special provision for this: childless nodes with
            a </textual><emphasis class="po-inline e287 e287" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture are allowed in an </textual><emphasis class="po-inline e288 e288" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> context.</textual></para><para class="po-block e289 e289"><textual class="po-textual">So it can be made streamable, right? Wrong! For a construct to be streamable it must
            be statically determinable to be so. Here, we have a function with an unspecified return
            type. If we had written </textual><code class="po-atom e290 e290"><textual class="po-textual">as="attribute()"</textual></code><textual class="po-textual">, the processor would be able to
            detemine that the returned nodes would always be childless and it could be used in an
                </textual><emphasis class="po-inline e291 e291" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> context.</textual></para><para class="po-block e292 e292"><textual class="po-textual">But this is only one example. What happens when the stylesheet function returns a
                </textual><emphasis class="po-inline e293 e293" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> node and we pass it a </textual><emphasis class="po-inline e294 e294" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> expression? What happens if the function returns
                </textual><emphasis class="po-inline e295 e295" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> (overlapping) nodes and the input is
                </textual><emphasis class="po-inline e296 e296" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">? And how about recursive functions, or
            within packages, with abstract or overriden functions?</textual></para><para class="po-block e297 e297"><textual class="po-textual">Let us look at some possible approaches to tackle these issues.</textual></para><section class="po-hcontainer e298 e298" xml:id="approach-1" xreflabel=""><title class="po-block e299 e299"><textual class="po-textual">Approach 1: analyzing stylesheet functions statically on their own</textual></title><para class="po-block e300 e300"><textual class="po-textual">Arguably the easiest approach from both the user's point of view and for
                implementors alike is to try to find a method to analyze the streamability of
                stylesheet functions statically, without taking into account any possible context
                the stylesheet function is called in.</textual></para><para class="po-block e301 e301"><textual class="po-textual">Suppose you have a stylesheet function </textual><code class="po-atom e302 e302"><textual class="po-textual">my:for-each</textual></code><textual class="po-textual"> which traverses
                all nodes in a node set and returns a certain aggregate result. By its definition,
                traversing the node set, it will consume the input tree, just like
                    </textual><code class="po-atom e303 e303"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> would. Writing such a function that it works equally
                well for different kinds of input postures is hard, perhaps even impossible. A
                function call like </textual><code class="po-atom e304 e304"><textual class="po-textual">my:for-each(head//section)</textual></code><textual class="po-textual"> may have to traverse over
                overlapping nodes, the expression in the argument is a </textual><emphasis class="po-inline e305 e305" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> expression and looping over a </textual><emphasis class="po-inline e306 e306" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> node set is not allowed in streaming because certain
                buffering is required to cache the overlapping nodes. If the loop is not going to
                consume the individual nodes, this is alright</textual><footnote class="po-popup e307 e307"><para class="po-block e308 e308"><textual class="po-textual">See section </textual><link class="po-inline e309 e309" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-xsl-for-each" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.4.17 Streamability of </textual><code class="po-atom e310 e310"><textual class="po-textual">xsl:for-each</textual></code></link><textual class="po-textual"> in the XSLT
                        3.0 Working Draft, specifically the rule </textual><quote class="po-inline e311 e311"><textual class="po-textual">The posture of the
                            instruction is the posture of the contained sequence constructor,
                            assessed with the context posture and context item type set to the
                            posture and type of the select expression.</textual></quote><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">, but otherwise, it is not </textual><emphasis class="po-inline e312 e312" role="ital"><textual class="po-textual">guaranteed
                    streamable</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e313 e313"><textual class="po-textual">For such a function to be statically analyzable without knowing what context it is
                used in, it is allowed to traverse the input tree, but it is not allowed to consume
                the individual nodes of the streamed input tree. A function that can potentially
                work with any input posture, albeit </textual><emphasis class="po-inline e314 e314" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">,
                    </textual><emphasis class="po-inline e315 e315" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e316 e316" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> might look like the following:</textual></para><para class="po-block e317 e317"><textual class="po-textual">
                </textual><figure class="po-container e318 e318" xml:id="my-for-each1" xreflabel="Code listing: streamable my:for-each working with any argument posture"><programlisting class="po-block e319 e319" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="my:for-each1"&gt;
    &lt;xsl:param name="$node-set" as="node()*" /&gt;
    &lt;xsl:for-each select="$node-set"&gt;
        &lt;xsl:sequence select="./@name" /&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e320 e320"><textual class="po-textual">This example loops over all the nodes, but does not consume the individual nodes,
                it only requests a property of those nodes using the attribute axis, which is
                motionless and its result is </textual><emphasis class="po-inline e321 e321" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">. And a
                motionless expression on either a </textual><emphasis class="po-inline e322 e322" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">,
                    </textual><emphasis class="po-inline e323 e323" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e324 e324" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> context is always allowed</textual><footnote class="po-popup e325 e325"><para class="po-block e326 e326"><textual class="po-textual">That the attribute axis in any context results in a posture of </textual><emphasis class="po-inline e327 e327" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> and a sweep of </textual><emphasis class="po-inline e328 e328" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> follows from the rules in section </textual><link class="po-inline e329 e329" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#general-streamability-rules" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.1 General Rules for Streamability</textual></link><textual class="po-textual">, rule 2.e and the rules
                        on the axis steps itself, which can be found in </textual><link class="po-inline e330 e330" xlink:actuate="onRequest" xlink:href="http://http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple"><textual class="po-textual"> 19.8.7.7 Streamability of Axis Steps</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">. </textual></para><para class="po-block e331 e331"><textual class="po-textual">Even though this example is exemplary for showing the possibility of writing a
                function that can take any posture, it limits our possibilities greatly. Suppose we
                want to write an implementation of </textual><code class="po-atom e332 e332"><textual class="po-textual">my:for-each</textual></code><textual class="po-textual"> that </textual><emphasis class="po-inline e333 e333" role="ital"><textual class="po-textual">does</textual></emphasis><textual class="po-textual"> consume the individual nodes in the streamed node
                set, for instance as in the following example:</textual></para><para class="po-block e334 e334"><textual class="po-textual">
                </textual><figure class="po-container e335 e335" xml:id="my-for-each2" xreflabel="Code listing: streamable my:for-each failing with argument postures climbing and crawling"><programlisting class="po-block e336 e336" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="my:for-each2"&gt;
    &lt;xsl:param name="$node-set" as="node()*" /&gt;
    &lt;xsl:for-each select="$node-set"&gt;
        &lt;xsl:value-of select="child::*[self::author | self::author-name]" /&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e337 e337"><textual class="po-textual">Whether or not this example would use the child axis within the
                    </textual><code class="po-atom e338 e338"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> or directly without the loop, for the streamability
                analysis this does not matter. The child axis, if applied on a </textual><emphasis class="po-inline e339 e339" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e340 e340" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> axis, is
                always </textual><emphasis class="po-inline e341 e341" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and has a sweep of </textual><emphasis class="po-inline e342 e342" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><footnote class="po-popup e343 e343"><para class="po-block e344 e344"><textual class="po-textual">The rule that a child axis is not </textual><emphasis class="po-inline e345 e345" role="ital"><textual class="po-textual">guaranteed
                            streamable</textual></emphasis><textual class="po-textual"> if applied on an axis other than an axis with
                            </textual><emphasis class="po-inline e346 e346" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture follows from </textual><link class="po-inline e347 e347" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.7 Streamability of Axis Steps</textual></link><textual class="po-textual"> in the XSLT Working Draft,
                        in the table under item 6 in the list.</textual></para></footnote><textual class="po-textual">. This means that the expression </textual><code class="po-atom e348 e348"><textual class="po-textual">my:for-each2(child::book)</textual></code><textual class="po-textual">
                is allowed, but the expressions </textual><code class="po-atom e349 e349"><textual class="po-textual">my:for-each2(listing//book)</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e350 e350"><textual class="po-textual">my:for-each(title/ancestor::book)</textual></code><textual class="po-textual"> are not, because the latter two
                have arguments with </textual><emphasis class="po-inline e351 e351" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e352 e352" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> postures respectively and can therefor not be
                consumed.</textual></para><para class="po-block e353 e353"><textual class="po-textual">This leaves us with essentially two options for static analysis of streamable
                stylesheet functions, without having to take the function calls into account:</textual><itemizedlist class="po-table e354 e354"><listitem class="po-container e355 e355"><para class="po-block e356 e356"><emphasis class="po-inline e357 e357" role="ital"><textual class="po-textual">Option 1:</textual></emphasis><textual class="po-textual"> force stylesheet authors to
                            only write functions that are capable of dealing with any input posture.
                            This means that the body of functions must be motionless, or if they are
                            not, they must use a </textual><emphasis class="po-inline e358 e358" role="ital"><textual class="po-textual">higher-order
                                operand</textual></emphasis><footnote class="po-popup e359 e359"><para class="po-block e360 e360"><textual class="po-textual">A </textual><emphasis class="po-inline e361 e361" role="ital"><textual class="po-textual">higher-order operand</textual></emphasis><textual class="po-textual"> is an
                                    operand that can change focus, such as </textual><code class="po-atom e362 e362"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual">
                                    or </textual><code class="po-atom e363 e363"><textual class="po-textual">xsl:for-each-group</textual></code><textual class="po-textual">, see the </textual><link class="po-inline e364 e364" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#dt-higher-order-operand" xlink:show="new" xlink:type="simple"><textual class="po-textual">definition of </textual><emphasis class="po-inline e365 e365" role="ital"><textual class="po-textual">higher-order
                                            operand</textual></emphasis></link><textual class="po-textual"> in the XSLT 3.0 Working
                                    Draft.</textual></para></footnote><textual class="po-textual"> such as the shown </textual><code class="po-atom e366 e366"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> construct in the
                            example.</textual></para></listitem><listitem class="po-container e367 e367"><para class="po-block e368 e368"><emphasis class="po-inline e369 e369" role="ital"><textual class="po-textual">Option 2:</textual></emphasis><textual class="po-textual"> limit the allowed posture
                            to only one posture, so that caller and callee are guaranteed to have
                            the same input posture, always. Most likely candidate is the </textual><emphasis class="po-inline e370 e370" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture, because it is the most
                            common posture when processing an input document. This would mean that
                            the argument that can take nodes always has its context posture set to
                                </textual><emphasis class="po-inline e371 e371" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and that the only allowed
                            argument posture when calling the function must also be </textual><emphasis class="po-inline e372 e372" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">.</textual></para></listitem></itemizedlist></para><para class="po-block e373 e373"><textual class="po-textual">Both options have severe drawbacks, but they have the advantage of being very
                clear-cut and easy to communicate or explain. As it turns out, the current approach
                taken by the XSL Working Group, as explained in </textual><link class="po-inline e374 e374" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple"><textual class="po-textual">XSL Bug
                    25679</textual></link><textual class="po-textual">, takes the approach of </textual><emphasis class="po-inline e375 e375" role="ital"><textual class="po-textual">Option 2</textual></emphasis><textual class="po-textual">:
                the result posture of a function must be </textual><emphasis class="po-inline e376 e376" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">
                or </textual><emphasis class="po-inline e377 e377" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> and the argument to a function must
                also be </textual><emphasis class="po-inline e378 e378" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e379 e379" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">. To accomplish this, the parameter that can take nodes,
                which can at most be one parameter, will have a context posture of </textual><emphasis class="po-inline e380 e380" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and is by itself </textual><emphasis class="po-inline e381 e381" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e382 e382"><title class="po-block e383 e383"><textual class="po-textual">Approach 2: analyzing stylesheet functions from the function call</textual></title><para class="po-block e384 e384"><textual class="po-textual">Radically different from the previous approach is to analyze the function's body
                only when we actually know what the context is of the argument that takes a streamed
                node. For this approach, we simply ignore analyzing the declaration of the function
                on itself.</textual></para><para class="po-block e385 e385"><textual class="po-textual">If we take the example from </textual><xref class="po-milestone e386 e386" linkend="my-for-each2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and call it with a
                    </textual><emphasis class="po-inline e387 e387" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> argument, for instance
                    </textual><code class="po-atom e388 e388"><textual class="po-textual">my:for-each2(*/books/book)</textual></code><textual class="po-textual">, the processor, upon encountering such
                function call, takes the posture of the argument and sets the context posture of
                    </textual><code class="po-atom e389 e389"><textual class="po-textual">$node-set</textual></code><textual class="po-textual"> to this posture, in this case: </textual><emphasis class="po-inline e390 e390" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">. With this posture, the processor can now analyze the
                function body and return a result of that analysis, not surprisingly the same as in
                the previous section: a </textual><emphasis class="po-inline e391 e391" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> sweep and a
                    </textual><emphasis class="po-inline e392 e392" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> result posture (because the function
                does not return any nodes, the result is </textual><emphasis class="po-inline e393 e393" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">).</textual></para><para class="po-block e394 e394"><textual class="po-textual">If user were to call the function with a </textual><emphasis class="po-inline e395 e395" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual">
                argument, say </textual><code class="po-atom e396 e396"><textual class="po-textual">my:for-each2(*/books//book)</textual></code><textual class="po-textual"> (mark the extra slash), the
                parameter </textual><code class="po-atom e397 e397"><textual class="po-textual">$node-set</textual></code><textual class="po-textual"> is set to a context posture of </textual><emphasis class="po-inline e398 e398" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> and the resulting analysis of the whole function
                body will be </textual><emphasis class="po-inline e399 e399" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e400 e400" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">. Exactly as expected. And with a </textual><emphasis class="po-inline e401 e401" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> argument, or even a </textual><emphasis class="po-inline e402 e402" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> argument, the result would be the same.</textual></para><para class="po-block e403 e403"><textual class="po-textual">Doing the same analysis for the first example, </textual><xref class="po-milestone e404 e404" linkend="my-for-each1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the
                result would be different each time, showing the advantage of this approach:</textual></para><para class="po-block e405 e405"><textual class="po-textual">
                </textual><table border="1px" cellpadding="3" class="po-container e406 e406" frame="border" rules="all" xml:id="table-for-each1-analysis" xreflabel="Table I: Posture and sweep of my:for-each1 function, depending on argument"><colgroup class="po-null e407 e407" span="1"><col align="left" class="po-meta e408 e408" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e409 e409" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e410 e410" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e411 e411" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e412 e412"><tr class="po-table e413 e413"><th class="po-field e414 e414"><textual class="po-textual">Argument posture</textual></th><th class="po-field e415 e415"><textual class="po-textual">Function posture </textual><code class="po-atom e416 e416"><textual class="po-textual">my:for-each1</textual></code></th><th class="po-field e417 e417"><textual class="po-textual">Resulting posture for function-call</textual></th><th class="po-field e418 e418"><textual class="po-textual">Resulting sweep for function call</textual></th></tr></thead><tbody class="po-table e419 e419"><tr class="po-table e420 e420"><td class="po-block e421 e421"><textual class="po-textual">Grounded</textual></td><td class="po-block e422 e422"><textual class="po-textual">Grounded</textual></td><td class="po-block e423 e423"><textual class="po-textual">Grounded</textual></td><td class="po-block e424 e424"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e425 e425"><td class="po-block e426 e426"><textual class="po-textual">Climbing</textual></td><td class="po-block e427 e427"><textual class="po-textual">Climbing</textual></td><td class="po-block e428 e428"><textual class="po-textual">Climbing</textual></td><td class="po-block e429 e429"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e430 e430"><td class="po-block e431 e431"><textual class="po-textual">Striding</textual></td><td class="po-block e432 e432"><textual class="po-textual">Climbing</textual></td><td class="po-block e433 e433"><textual class="po-textual">Climbing</textual></td><td class="po-block e434 e434"><textual class="po-textual">Motionless or consuming</textual></td></tr><tr class="po-table e435 e435"><td class="po-block e436 e436"><textual class="po-textual">Crawling</textual></td><td class="po-block e437 e437"><textual class="po-textual">Climbing</textual></td><td class="po-block e438 e438"><textual class="po-textual">Climbing</textual></td><td class="po-block e439 e439"><textual class="po-textual">Motionless or consuming</textual></td></tr><tr class="po-table e440 e440"><td class="po-block e441 e441"><textual class="po-textual">Roaming</textual></td><td class="po-block e442 e442"><textual class="po-textual">Roaming</textual></td><td class="po-block e443 e443"><textual class="po-textual">Roaming</textual></td><td class="po-block e444 e444"><textual class="po-textual">Free-ranging</textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para><para class="po-block e445 e445"><textual class="po-textual">The advantage is clear, by postponing analysis of the function body until it is
                called, the programmer has more flexibility in creating the function and the user
                will get an error if he uses the function with an invalid argument. This is also the
                disadvantage: without a clear rule how to call the function, the user may have
                trouble understanding why one argument works and the other does not. The previous
                table showed a function, </textual><code class="po-atom e446 e446"><textual class="po-textual">my:for-each1</textual></code><textual class="po-textual">, that works with any posture as
                argument input (except </textual><emphasis class="po-inline e447 e447" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual">, but that posture
                will always result in an unstreamable result, whether it is a user-defined function,
                a build-in function or any other construct). The following table shows the drawback
                of this approach, where only upon calling the function it becomes apparent that
                certain postures are disallowed:</textual></para><para class="po-block e448 e448"><textual class="po-textual">
                </textual><table border="1px" cellpadding="3" class="po-container e449 e449" frame="border" rules="all" xml:id="table-for-each2-analysis" xreflabel="Table II: Posture and sweep of my:for-each2 function, depending on argument"><colgroup class="po-null e450 e450" span="1"><col align="left" class="po-meta e451 e451" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e452 e452" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e453 e453" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e454 e454" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e455 e455"><tr class="po-table e456 e456"><th class="po-field e457 e457"><textual class="po-textual">Argument posture</textual></th><th class="po-field e458 e458"><textual class="po-textual">Function posture </textual><code class="po-atom e459 e459"><textual class="po-textual">my:for-each2</textual></code></th><th class="po-field e460 e460"><textual class="po-textual">Resulting posture for function-call</textual></th><th class="po-field e461 e461"><textual class="po-textual">Resulting sweep for function call</textual></th></tr></thead><tbody class="po-table e462 e462"><tr class="po-table e463 e463"><td class="po-block e464 e464"><textual class="po-textual">Grounded</textual></td><td class="po-block e465 e465"><textual class="po-textual">Grounded</textual></td><td class="po-block e466 e466"><textual class="po-textual">Grounded</textual></td><td class="po-block e467 e467"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e468 e468"><td class="po-block e469 e469"><textual class="po-textual">Climbing</textual></td><td class="po-block e470 e470"><textual class="po-textual">Roaming</textual></td><td class="po-block e471 e471"><textual class="po-textual">Roaming</textual></td><td class="po-block e472 e472"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e473 e473"><td class="po-block e474 e474"><textual class="po-textual">Striding</textual></td><td class="po-block e475 e475"><textual class="po-textual">Striding</textual></td><td class="po-block e476 e476"><textual class="po-textual">Striding</textual></td><td class="po-block e477 e477"><textual class="po-textual">Consuming</textual></td></tr><tr class="po-table e478 e478"><td class="po-block e479 e479"><textual class="po-textual">Crawling</textual></td><td class="po-block e480 e480"><textual class="po-textual">Roaming</textual></td><td class="po-block e481 e481"><textual class="po-textual">Roaming</textual></td><td class="po-block e482 e482"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e483 e483"><td class="po-block e484 e484"><textual class="po-textual">Roaming</textual></td><td class="po-block e485 e485"><textual class="po-textual">Roaming</textual></td><td class="po-block e486 e486"><textual class="po-textual">Roaming</textual></td><td class="po-block e487 e487"><textual class="po-textual">Free-ranging</textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para><para class="po-block e488 e488"><textual class="po-textual">As we can see, only one argument posture (bar </textual><emphasis class="po-inline e489 e489" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">, which is always allowed), </textual><emphasis class="po-inline e490 e490" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, is allowed with the function </textual><code class="po-atom e491 e491"><textual class="po-textual">my:for-each2</textual></code><textual class="po-textual">,
                and its sweep is </textual><emphasis class="po-inline e492 e492" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">. This is similar to our
                expectations, as in the previous section, we already saw that this function only
                worked with a </textual><emphasis class="po-inline e493 e493" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> argument posture. But in the
                previous approach, for </textual><emphasis class="po-inline e494 e494" role="ital"><textual class="po-textual">Option 2</textual></emphasis><textual class="po-textual">, we considered this
                the only allowed posture for function arguments to stylesheet functions, which made
                it pretty clear for end users. Here, the user does not know beforehand what the
                argument posture can be, in fact, he needs intricate knowledge of the function body
                to find out what posture is allowed.</textual></para><para class="po-block e495 e495"><textual class="po-textual">While this approach allows more flexibility, it also introduces more room for
                error, at least at the static development stage. Of course, the documentation of a
                function could contain information of how it should be used, but who reads
                documentation anyway?</textual></para><para class="po-block e496 e496"><textual class="po-textual">Another advantage, though, is the potential that many existing functions might
                "just work". In fact, quite some functions that can be found online are often short
                and meant for a certain given input. As it turns out, if you take, for instance, a
                look at the functions on </textual><link class="po-inline e497 e497" xlink:actuate="onRequest" xlink:href="http://www.xsltfunctions.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">www.xsltfunctions.com</textual></link><textual class="po-textual"> that can take nodes as their arguments, quite some
                of them are streamable right out of the box if we would allow this approach.</textual></para></section><section class="po-hcontainer e498 e498"><title class="po-block e499 e499"><textual class="po-textual">Approach 3: analyzing stylesheet functions based on static posture assessments</textual></title><para class="po-block e500 e500"><textual class="po-textual">If we try to combine the previous two approaches into one, and try to achieve both
                static analysis of function bodies and clear information for the users of the
                functions, we achieve that by decorating the functions with an extra attribute that
                can take one or more postures. Let us call the attribute
                    </textual><code class="po-atom e501 e501"><textual class="po-textual">argument-posture</textual></code><textual class="po-textual"> and add it to </textual><code class="po-atom e502 e502"><textual class="po-textual">xsl:param</textual></code><textual class="po-textual">, with at most
                one parameter allowed to have that attribute (the challenge of multiple arguments
                that can take nodes is discussed in </textual><xref class="po-milestone e503 e503" linkend="multiple-arguments"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The value
                for the attribute is set to be one or more of </textual><code class="po-atom e504 e504"><textual class="po-textual">grounded climbing striding
                    crawling roaming</textual></code><textual class="po-textual">. The postures </textual><emphasis class="po-inline e505 e505" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">
                and </textual><emphasis class="po-inline e506 e506" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> are redundant, because the former is
                always allowed and results in a </textual><emphasis class="po-inline e507 e507" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> sweep
                and the latter is never allowed, resulting in a </textual><emphasis class="po-inline e508 e508" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual"> sweep.</textual></para><para class="po-block e509 e509"><textual class="po-textual">If we take the previous example, </textual><code class="po-atom e510 e510"><textual class="po-textual">my:for-each1</textual></code><textual class="po-textual"> and rewrite it with
                this additional decorating attribute, it looks like this:</textual></para><para class="po-block e511 e511"><textual class="po-textual">
                </textual><figure class="po-container e512 e512" xml:id="my-for-each1-decorated" xreflabel="Code listing: streamable my:for-each with decorated parameter"><programlisting class="po-block e513 e513" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="my:for-each1" as="attribute()*"&gt;
    &lt;xsl:param name="$node-set"
        as="node()*"
        argument-posture="climbing striding crawling" /&gt;

    &lt;xsl:for-each select="$node-set"&gt;
        &lt;xsl:sequence select="./@name" /&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e514 e514"><textual class="po-textual">This tells the processor that the programmer declares the function to be
                streamable with each and every one of these postures. The processor can then
                statically assess the function body with each posture one by one and report back
                whether or not this assessment is correct or not. In this case, it would compile
                successfully, because all postures yield correct results.</textual></para><para class="po-block e515 e515"><textual class="po-textual">Still, you might argue, the different input postures do not necessarily mean that
                the sweeps are all the same. True, but the sweep is something that can never be
                statically determined for a declaration, as it is dependent on the context of the
                caller. For instance, if the function is called with a </textual><emphasis class="po-inline e516 e516" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> but </textual><emphasis class="po-inline e517 e517" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> argument,
                the resulting sweep is also </textual><emphasis class="po-inline e518 e518" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">, because the
                    </textual><code class="po-atom e519 e519"><textual class="po-textual">xsl:for-each</textual></code><textual class="po-textual"> with a </textual><emphasis class="po-inline e520 e520" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">
                argument and its body containing a </textual><emphasis class="po-inline e521 e521" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">
                sequence constructor all together yield a </textual><emphasis class="po-inline e522 e522" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> call to the function, even though it is striding. This is
                true, for instance, for the following call:</textual></para><para class="po-block e523 e523"><textual class="po-textual">
                </textual><figure class="po-container e524 e524" xml:id="my-for-each-in-match-pattern" xreflabel="Code listing: calling function with motionless striding argument"><programlisting class="po-block e525 e525" xml:space="preserve"><textual class="po-textual">&lt;xsl:template match="books/book[my:for-each1(.) = 'Swift')]"&gt;
    &lt;h1&gt;Books from Swift!&lt;/h1&gt;
    &lt;xsl:apply-templates /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e526 e526"><textual class="po-textual">This example shows the power of the current rules in the XSL Working Draft. The
                existing rules allow a function call inside a predicate in a pattern. Because the
                context item expression, </textual><code class="po-atom e527 e527"><textual class="po-textual">(.)</textual></code><textual class="po-textual"> is </textual><emphasis class="po-inline e528 e528" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> and takes the context posture as its result posture,
                which in this case is </textual><emphasis class="po-inline e529 e529" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, the result of
                calling the function with this argument is also </textual><emphasis class="po-inline e530 e530" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> and has a result posture of </textual><emphasis class="po-inline e531 e531" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> (which follows from our table above). Finally, the result
                must be atomized to be able to compare it to a string. For a </textual><emphasis class="po-inline e532 e532" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> expression that returns an attribute, atomization is
                allowed and motionless.</textual></para><para class="po-block e533 e533"><textual class="po-textual">As we can see, this third approach gives us more flexibility, but the drawback is
                that it requires programmers to understand what a posture is. One of the design
                goals of the streamability rules is that they can be applied without knowing all the
                internals, and bringing one of those internals, the posture of a construct, to the
                surface, may not be desirable.</textual></para><para class="po-block e534 e534"><textual class="po-textual">In the next sections we dive deeper in the analysis of stylesheet functions and
                try to come up with a set of rules that works for different inputs, not only
                    </textual><emphasis class="po-inline e535 e535" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, and that works also with recursion or
                non-final packaged functions, subjects that have not yet been touched in this
                section.</textual></para></section></section><section class="po-hcontainer e536 e536" xml:id="posture-sweep"><title class="po-block e537 e537"><textual class="po-textual">In pursuit of flexible rules for guaranteed streamable stylesheet functions</textual></title><para class="po-block e538 e538"><textual class="po-textual">The previous section introduced three possible approaches. In the following sections
            we will research these approaches further. In fact, the focus will be on </textual><emphasis class="po-inline e539 e539" role="ital"><textual class="po-textual">Approach 2</textual></emphasis><textual class="po-textual"> above.</textual></para><para class="po-block e540 e540"><textual class="po-textual">In the specification, under the rules on path expressions</textual><footnote class="po-popup e541 e541"><para class="po-block e542 e542"><textual class="po-textual">See 19.8.7.6 Streamability of Axis Steps in XSL Transformations 3.0.</textual></para></footnote><textual class="po-textual"> and axis steps</textual><footnote class="po-popup e543 e543"><para class="po-block e544 e544"><textual class="po-textual">See 19.8.7.7 Streamability of Axis Steps in XSL Transformations 3.0.</textual></para></footnote><textual class="po-textual">, a table shows what happens if the output posture of one part of the path
            expression is the input posture of the other part of it. Stylesheet functions are not
            much difference. If we take the lessons learned in that section and we reproduce that
            table here and adjust it slightly for stylesheet functions, we can deduct that the
            following rules apply:</textual></para><para class="po-block e545 e545"><textual class="po-textual">
            </textual><table border="1px" cellpadding="3" class="po-container e546 e546" frame="border" rules="all" xml:id="posture-sweep-table" xreflabel="Table III: Posture and sweep of stylesheet functions"><colgroup class="po-null e547 e547" span="1"><col align="left" class="po-meta e548 e548" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e549 e549" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e550 e550" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e551 e551" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e552 e552"><tr class="po-table e553 e553"><th class="po-field e554 e554"><textual class="po-textual">Argument posture</textual></th><th class="po-field e555 e555"><textual class="po-textual">Function posture</textual></th><th class="po-field e556 e556"><textual class="po-textual">Resulting posture</textual></th><th class="po-field e557 e557"><textual class="po-textual">Allowed sweep</textual><superscript class="po-atom e558 e558"><textual class="po-textual">a</textual></superscript></th></tr></thead><tfoot class="po-null e559 e559"><tr class="po-table e560 e560"><td class="po-block e561 e561" colspan="4"><para class="po-block e562 e562"><textual class="po-textual">
                            </textual><superscript class="po-atom e563 e563"><textual class="po-textual">a)
                            This is the highest allowed resulting sweep of the
                            function body resulting in the given result posture,
                            if the sweep is higher then the sweep of the
                            function body is effectively free-ranging.</textual></superscript><textual class="po-textual">
                        </textual></para><textual class="po-textual">
                        </textual><para class="po-block e564 e564"><textual class="po-textual">
                            </textual><superscript class="po-atom e565 e565"><textual class="po-textual">b)
                            The term "direct-transitional" is not a posture, it
                            applies to constructs such as "$n/self::foo" or
                            "$n", where $n is the streamed
                            parameter. Such expressions are motionless and take the
                            posture of their input as their output posture.</textual></superscript><textual class="po-textual">
                        </textual></para><textual class="po-textual">
                        </textual><para class="po-block e566 e566"><textual class="po-textual">
                            </textual><superscript class="po-atom e567 e567"><textual class="po-textual">c)
                            The current rules on streamability do not allow a
                            striding or crawling posture after a climbing or crawling 
                            posture, the result of such analysis is always roaming and 
                            free-ranging.</textual></superscript><textual class="po-textual">
                        </textual></para><textual class="po-textual">
                        </textual></td></tr></tfoot><tbody class="po-table e568 e568"><tr class="po-table e569 e569"><td class="po-block e570 e570"><textual class="po-textual">Grounded</textual></td><td class="po-block e571 e571"><textual class="po-textual">Any</textual></td><td class="po-block e572 e572"><textual class="po-textual">Grounded</textual></td><td class="po-block e573 e573"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e574 e574"><td class="po-block e575 e575"><textual class="po-textual">Any</textual></td><td class="po-block e576 e576"><textual class="po-textual">Grounded</textual></td><td class="po-block e577 e577"><textual class="po-textual">Grounded</textual></td><td class="po-block e578 e578"><textual class="po-textual">Sweep of function body</textual></td></tr><tr class="po-table e579 e579"><td class="po-block e580 e580"><textual class="po-textual">Any</textual></td><td class="po-block e581 e581"><emphasis class="po-inline e582 e582" role="ital"><textual class="po-textual">Direct-transitional</textual><superscript class="po-atom e583 e583"><textual class="po-textual">b</textual></superscript></emphasis></td><td class="po-block e584 e584"><textual class="po-textual">argument posture</textual></td><td class="po-block e585 e585"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e586 e586"><td class="po-block e587 e587"><textual class="po-textual">Climbing</textual></td><td class="po-block e588 e588"><textual class="po-textual">Climbing</textual></td><td class="po-block e589 e589"><textual class="po-textual">Climbing</textual></td><td class="po-block e590 e590"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e591 e591"><td class="po-block e592 e592"><textual class="po-textual">Climbing</textual></td><td class="po-block e593 e593"><textual class="po-textual">Striding</textual><superscript class="po-atom e594 e594"><textual class="po-textual">c</textual></superscript></td><td class="po-block e595 e595"><textual class="po-textual">Roaming</textual></td><td class="po-block e596 e596"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e597 e597"><td class="po-block e598 e598"><textual class="po-textual">Climbing</textual></td><td class="po-block e599 e599"><textual class="po-textual">Crawling</textual><superscript class="po-atom e600 e600"><textual class="po-textual">c</textual></superscript></td><td class="po-block e601 e601"><textual class="po-textual">Roaming</textual></td><td class="po-block e602 e602"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e603 e603"><td class="po-block e604 e604"><textual class="po-textual">Striding</textual></td><td class="po-block e605 e605"><textual class="po-textual">Climbing</textual></td><td class="po-block e606 e606"><textual class="po-textual">Climbing</textual></td><td class="po-block e607 e607"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e608 e608"><td class="po-block e609 e609"><textual class="po-textual">Striding</textual></td><td class="po-block e610 e610"><textual class="po-textual">Striding</textual></td><td class="po-block e611 e611"><textual class="po-textual">Striding</textual></td><td class="po-block e612 e612"><textual class="po-textual">Consuming</textual></td></tr><tr class="po-table e613 e613"><td class="po-block e614 e614"><textual class="po-textual">Striding</textual></td><td class="po-block e615 e615"><textual class="po-textual">Crawling</textual></td><td class="po-block e616 e616"><textual class="po-textual">Crawling</textual></td><td class="po-block e617 e617"><textual class="po-textual">Consuming</textual></td></tr><tr class="po-table e618 e618"><td class="po-block e619 e619"><textual class="po-textual">Crawling</textual></td><td class="po-block e620 e620"><textual class="po-textual">Climbing</textual></td><td class="po-block e621 e621"><textual class="po-textual">Climbing</textual></td><td class="po-block e622 e622"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e623 e623"><td class="po-block e624 e624"><textual class="po-textual">Crawling</textual></td><td class="po-block e625 e625"><textual class="po-textual">Striding</textual><superscript class="po-atom e626 e626"><textual class="po-textual">c</textual></superscript></td><td class="po-block e627 e627"><textual class="po-textual">Roaming</textual></td><td class="po-block e628 e628"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e629 e629"><td class="po-block e630 e630"><textual class="po-textual">Crawling</textual></td><td class="po-block e631 e631"><textual class="po-textual">Crawling</textual><superscript class="po-atom e632 e632"><textual class="po-textual">c</textual></superscript></td><td class="po-block e633 e633"><textual class="po-textual">Roaming</textual></td><td class="po-block e634 e634"><textual class="po-textual">Free-ranging</textual></td></tr><tr class="po-table e635 e635"><td class="po-block e636 e636"><textual class="po-textual">Roaming</textual></td><td class="po-block e637 e637"><textual class="po-textual">any</textual></td><td class="po-block e638 e638"><textual class="po-textual">Roaming</textual></td><td class="po-block e639 e639"><textual class="po-textual">Free-ranging</textual></td></tr></tbody></table><textual class="po-textual">
            
            
        </textual></para><para class="po-block e640 e640"><textual class="po-textual">To determine the posture of a function body, it is easiest to consider the argument
            that can take nodes similar to the context item expression </textual><code class="po-atom e641 e641"><textual class="po-textual">"."</textual></code><textual class="po-textual">. This
            expression is motionless on itself, but if used with usage </textual><emphasis class="po-inline e642 e642" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> it may become </textual><emphasis class="po-inline e643 e643" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> 
            depending on the input posture of the expression or instruction it appears in, called the </textual><emphasis class="po-inline e644 e644" role="ital"><textual class="po-textual">context posture</textual></emphasis><textual class="po-textual">. For functions that means, it takes the
            posture of the argument to that function, in other words, the </textual><emphasis class="po-inline e645 e645" role="ital"><textual class="po-textual">context posture</textual></emphasis><textual class="po-textual"> of the parameter that can take streamed nodes is the
            posture of the argument to the function. Example:</textual></para><para class="po-block e646 e646"><textual class="po-textual">
            </textual><figure class="po-container e647 e647" xml:id="f-third-child" xreflabel="Code listing: striding streamable function that can take streamed nodes"><programlisting class="po-block e648 e648" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:thirdchild" as="element()"&gt;
    &lt;xsl:param name="n" as="node()" /&gt;
    &lt;xsl:sequence select="$n/child::*[3]" /&gt;
&lt;/xsl:function&gt;

&lt;!-- guaranteed streamable: --&gt;
&lt;xsl:template match="author"&gt;
    &lt;xsl:apply-templates select="f:thirdchild(.)" /&gt;
&lt;/xsl:template&gt;

&lt;!-- not guaranteed streamable: --&gt;
&lt;xsl:template match="author"&gt;
    &lt;xsl:apply-templates select="f:thirdchild(.//book)" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
        </textual></para><para class="po-block e649 e649"><textual class="po-textual">The body of the function </textual><code class="po-atom e650 e650"><textual class="po-textual">f:thirdchild</textual></code><textual class="po-textual"> has a posture </textual><emphasis class="po-inline e651 e651" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> because of the child axis step. The usage of the
            function is </textual><emphasis class="po-inline e652 e652" role="ital"><textual class="po-textual">transitional</textual></emphasis><textual class="po-textual">, which means it can return
            nodes. Using the table above, we can lookup the result posture and sweep of any call to
            the function. The first use in this example is in </textual><code class="po-atom e653 e653"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual">,
            which we have seen before takes a usage of </textual><emphasis class="po-inline e654 e654" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual">, meaning that overlapping nodes are not allowed</textual><footnote class="po-popup e655 e655"><para class="po-block e656 e656"><textual class="po-textual">A public bug entry </textual><link class="po-inline e657 e657" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25185" xlink:show="new" xlink:type="simple"><textual class="po-textual">Bug
                        25185</textual></link><textual class="po-textual"> tries to resolve this by allowing limited buffering of crawling
                    postures in a absorption contexts such as these, if that bug is accepted and
                    resolved, overlapping nodes as with crawling posture is allowed with usage
                    absorption, at least in the general case.</textual></para></footnote><textual class="po-textual">. The operand here is a call to our function with the current node as
            argument. Inside any template, by definition the context posture, and thus the posture
            of the context item expression, is </textual><emphasis class="po-inline e658 e658" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">. The
            table then gives us for argument is </textual><emphasis class="po-inline e659 e659" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">,
            function body is </textual><emphasis class="po-inline e660 e660" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, then result posture is
            also </textual><emphasis class="po-inline e661 e661" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and the sweep is </textual><emphasis class="po-inline e662 e662" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e663 e663"><textual class="po-textual">Looking at the second use of the function we see another
                </textual><code class="po-atom e664 e664"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual">, this time with a </textual><emphasis class="po-inline e665 e665" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> path expression (the descendant axis is returns a crawling
            posture, it can have overlapping nodes) as argument to the function. From the table this
            gives us for argument is </textual><emphasis class="po-inline e666 e666" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual">, function body
                </textual><emphasis class="po-inline e667 e667" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> the result posture of </textual><emphasis class="po-inline e668 e668" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and a sweep of </textual><emphasis class="po-inline e669 e669" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">. Even without the table we can see from the argument that
            it returns overlapping nodes and that a processor will have to potentially look back and
            forward to find the third child of each overlapping node. If there is no overlap, this
            problem would not arise, but statically we do not know that, and the processor has to
            assume the worst.</textual></para></section><section class="po-hcontainer e670 e670" xml:id="multiple-arguments"><title class="po-block e671 e671"><textual class="po-textual">Multiple arguments that can take nodes</textual></title><para class="po-block e672 e672"><textual class="po-textual">With streaming, it is not possible to have one construct take multiple downward select
            expressions, or more generally, multiple consuming expressions. Suppose we were to allow
            a function call to take multiple arguments that are streamed nodes, this rule would
            backfire. An function call such as </textual><code class="po-atom e673 e673"><textual class="po-textual">f:equals(foo, bar)</textual></code><textual class="po-textual"> has two downward
            select expressions, </textual><code class="po-atom e674 e674"><textual class="po-textual">foo</textual></code><textual class="po-textual"> and </textual><code class="po-atom e675 e675"><textual class="po-textual">bar</textual></code><textual class="po-textual">. Because there is no way the
            processor can know in what order these appear in the input document, it is possible that
                </textual><code class="po-atom e676 e676"><textual class="po-textual">foo</textual></code><textual class="po-textual"> appears before </textual><code class="po-atom e677 e677"><textual class="po-textual">bar</textual></code><textual class="po-textual">, or the other way around, which
            means that the processor may have to look back to find the other child. This is the
            general reason why multiple downward selects are not allowed in any single
            construct.</textual></para><para class="po-block e678 e678"><textual class="po-textual">We could argue that one argument can be a </textual><emphasis class="po-inline e679 e679" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">
            node and another a streamed node. But that does not help us much further, because it
            hits the same problems as with the non-streamable functions we showed earlier: how can
            we tell the user of the function to choose between </textual><code class="po-atom e680 e680"><textual class="po-textual">fn:snapshot</textual></code><textual class="po-textual"> and
                </textual><code class="po-atom e681 e681"><textual class="po-textual">fn:copy-of</textual></code><textual class="po-textual"> and how can he determine what argument can take a streamed
            node and what argument cannot?</textual></para><para class="po-block e682 e682"><textual class="po-textual">Another argument to allow multiple arguments that can take nodes is that one argument
            can be motionless in the function body and the other is not. Together they would be
            consuming, or if both are motionless, together they would be motionless. But this still
            does not deal with the fact that to get a node into the function, that node first needs
            to be consumed, unless it is the context node or an ancestor of the context node. These
            restrictions would be very limiting and also very hard to define in spec
            language.</textual></para><para class="po-block e683 e683"><textual class="po-textual">The resolution is to keep things simple. Instead of allowing multiple arguments that
            take nodes, streamable functions can have a maximum of one parameter that can take
            nodes. The other arguments must either be non-node types, or absent.</textual></para></section><section class="po-hcontainer e684 e684" xml:id="recursion"><title class="po-block e685 e685"><textual class="po-textual">Recursive streamable functions</textual></title><para class="po-block e686 e686"><textual class="po-textual">In </textual><xref class="po-milestone e687 e687" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
            in </textual><xref class="po-milestone e688 e688" linkend="posture-sweep"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> we have seen that it is
            possible to write functions with any kind of result posture. The result posture is then
            dependent on the argument passed to the function. This works for the trivial case where
            the function body is simple and can be analyzed. But what happens if we try to apply
            those rules with a function body that is recursive?</textual></para><para class="po-block e689 e689"><textual class="po-textual">For this section I consider four kinds of recursion</textual><footnote class="po-popup e690 e690"><para class="po-block e691 e691"><textual class="po-textual">The XSL Transformations 3.0 Working Draft does not use this terminology, but
                    it helps differentiate different situations for this discussion.</textual></para></footnote><textual class="po-textual">:</textual><itemizedlist class="po-table e692 e692"><listitem class="po-container e693 e693"><para class="po-block e694 e694"><emphasis class="po-inline e695 e695" role="ital"><textual class="po-textual">Direct recursion:</textual></emphasis><textual class="po-textual"> function calls itself
                        inside the body of the function.</textual></para></listitem><listitem class="po-container e696 e696"><para class="po-block e697 e697"><emphasis class="po-inline e698 e698" role="ital"><textual class="po-textual">Indirect recursion:</textual></emphasis><textual class="po-textual"> function calls
                        itself indirectly through another function it calls.</textual></para></listitem><listitem class="po-container e699 e699"><para class="po-block e700 e700"><emphasis class="po-inline e701 e701" role="ital"><textual class="po-textual">Indeterminate recursion:</textual></emphasis><textual class="po-textual"> function
                        applies templates and a template at some level calls the function.</textual></para></listitem><listitem class="po-container e702 e702"><para class="po-block e703 e703"><emphasis class="po-inline e704 e704" role="ital"><textual class="po-textual">Dynamic recursion:</textual></emphasis><textual class="po-textual"> a dynamic function
                        call resolves, or can resolve to a function which is currently
                        executed.</textual></para></listitem></itemizedlist></para><section class="po-hcontainer e705 e705" xml:id="direct-recursion"><title class="po-block e706 e706"><textual class="po-textual">Direct recursion</textual></title><para class="po-block e707 e707"><textual class="po-textual">To understand the challenges when dealing with recursive functions it is enough to
                look at a most trivial example, which is clearly streamable and uses infinite direct
                recursion:</textual></para><para class="po-block e708 e708"><textual class="po-textual">
                </textual><figure class="po-container e709 e709" xml:id="f-recur" xreflabel="Code listing: trivial direct recursion"><programlisting class="po-block e710 e710" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:recur"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:sequence select="f:recur($n)" /&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="x"&gt;
    &lt;xsl:apply-templates select="f:recur(y)" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">

            </textual></para><para class="po-block e711 e711"><textual class="po-textual">This function does not have an exit-clause for the recursion and will run
                indefinitely, likely causing a stackoverflow error. But it is legal XSLT and it is
                streamable in the sense that it no movement occurs on the streamed argument.</textual></para><para class="po-block e712 e712"><textual class="po-textual">If we analyze this function using </textual><xref class="po-milestone e713 e713" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, we run into a problem:</textual><itemizedlist class="po-table e714 e714"><listitem class="po-container e715 e715"><para class="po-block e716 e716"><textual class="po-textual">First we need to determine the posture of the argument to the
                            function, here it is </textual><emphasis class="po-inline e717 e717" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e718 e718"><para class="po-block e719 e719"><textual class="po-textual">This sets the posture of </textual><code class="po-atom e720 e720"><textual class="po-textual">$n</textual></code><textual class="po-textual"> to </textual><emphasis class="po-inline e721 e721" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> as well. The next step is to determine the
                            posture and sweep of the function body.</textual></para></listitem><listitem class="po-container e722 e722"><para class="po-block e723 e723"><textual class="po-textual">To determine that, we need to determine the posture and sweep of the
                            contained sequence constructor, which is a single
                                </textual><code class="po-atom e724 e724"><textual class="po-textual">xsl:sequence</textual></code><textual class="po-textual"> with here one operand, the
                            select-expression.</textual></para></listitem><listitem class="po-container e725 e725"><para class="po-block e726 e726"><textual class="po-textual">The posture and sweep of </textual><code class="po-atom e727 e727"><textual class="po-textual">xsl:sequence</textual></code><textual class="po-textual"> is equal to the
                            posture and sweep of its select expression</textual><footnote class="po-popup e728 e728"><para class="po-block e729 e729"><textual class="po-textual">See </textual><link class="po-inline e730 e730" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-xsl-sequence" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.4.33 Streamability of </textual><code class="po-atom e731 e731"><textual class="po-textual">xsl:sequence</textual></code><textual class="po-textual"> in XSL
                                        Transformations 3.0</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">, here </textual><code class="po-atom e732 e732"><textual class="po-textual">f:recur($n)</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e733 e733"><para class="po-block e734 e734"><textual class="po-textual">We know the posture of </textual><code class="po-atom e735 e735"><textual class="po-textual">$n</textual></code><textual class="po-textual">, but to determine the posture
                            of the function call </textual><code class="po-atom e736 e736"><textual class="po-textual">f:recur</textual></code><textual class="po-textual"> we need to analyze the
                            function body again, which we already did, but without having a
                            conclusive sweep or posture yet. We've reached an eternal analysis loop,
                            the function is </textual><emphasis class="po-inline e737 e737" role="ital"><textual class="po-textual">non-analyzable</textual></emphasis><textual class="po-textual">.</textual></para></listitem></itemizedlist></para><para class="po-block e738 e738"><textual class="po-textual">It is not trivial to resolve this dead end situation. One way forward could be to
                split the function body artificially into two operands and analyze each
                individually: one for the part without the recursion point</textual><footnote class="po-popup e739 e739"><para class="po-block e740 e740"><textual class="po-textual">I use the term </textual><emphasis class="po-inline e741 e741" role="ital"><textual class="po-textual">recursion point</textual></emphasis><textual class="po-textual"> for the
                        place in the code where the recursion is invoked, but this is not a term
                        that is used in the specification.</textual></para></footnote><textual class="po-textual">, setting the recursive function to the empty sequence </textual><code class="po-atom e742 e742"><textual class="po-textual">()</textual></code><textual class="po-textual">,
                and one for the argument to the recursion point. This will help somewhat, but feels
                wrong and is hard to proof right. What would happen if a function returns streamed
                nodes and gets a </textual><emphasis class="po-inline e743 e743" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> input and the output is
                of a different posture?</textual></para><para class="po-block e744 e744"><textual class="po-textual">Looking back at </textual><xref class="po-milestone e745 e745" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> we can deduct that
                any function call with a </textual><emphasis class="po-inline e746 e746" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e747 e747" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> argument must yield a </textual><emphasis class="po-inline e748 e748" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e749 e749" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> result. The
                only argument that is allowed to return a different result posture is an input with
                a </textual><emphasis class="po-inline e750 e750" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture. This makes sense, because the
                natural process for streaming is to go through the input document depth-first, which
                is the </textual><emphasis class="po-inline e751 e751" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture and once you change
                direction upwards, you cannot go down again: it would make a construct roaming. To
                summarize, we can consider that:</textual><itemizedlist class="po-table e752 e752"><listitem class="po-container e753 e753"><para class="po-block e754 e754"><textual class="po-textual">A </textual><emphasis class="po-inline e755 e755" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> input argument must
                            remain climbing to be streamable, so if the input is climbing, the
                            recursive argument must also be climbing and the body cannot contain an
                            expression in another direction.</textual></para></listitem><listitem class="po-container e756 e756"><para class="po-block e757 e757"><textual class="po-textual">A </textual><emphasis class="po-inline e758 e758" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> input argument can
                            change to </textual><emphasis class="po-inline e759 e759" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> but not to
                                </textual><emphasis class="po-inline e760 e760" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> in recursion, because
                            that would validate the next point. If it changes to </textual><emphasis class="po-inline e761 e761" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> the whole function body must be
                            motionless, because you cannot both climb and consume, and if it stays
                                </textual><emphasis class="po-inline e762 e762" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> the whole function body
                            must be </textual><emphasis class="po-inline e763 e763" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and can be either
                            motionless or consuming.</textual></para></listitem><listitem class="po-container e764 e764"><para class="po-block e765 e765"><textual class="po-textual">A </textual><emphasis class="po-inline e766 e766" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> input argument can only
                            take motionless expressions, it cannot turn magically back into
                                </textual><emphasis class="po-inline e767 e767" role="ital"><textual class="po-textual">striding</textual></emphasis><footnote class="po-popup e768 e768"><para class="po-block e769 e769"><textual class="po-textual">See the table under </textual><link class="po-inline e770 e770" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7..7 Streamability of Axis Steps in XSL
                                        Transformations 3.0</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual"> nor is it allowed to have a </textual><emphasis class="po-inline e771 e771" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> expression operate on another </textual><emphasis class="po-inline e772 e772" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> expression.</textual></para></listitem><listitem class="po-container e773 e773"><para class="po-block e774 e774"><textual class="po-textual">Anything </textual><emphasis class="po-inline e775 e775" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> will always stay
                                </textual><emphasis class="po-inline e776 e776" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual">.</textual></para></listitem></itemizedlist></para><para class="po-block e777 e777"><textual class="po-textual">The following table shows what this means for different argument postures of calls
                to a function, what the recursive argument (the one at the recursion point) can be
                and the result posture of the recursive call is and what the posture of the function
                body must be (it must be the same) and what the sweep is of the recursive call. The
                last column stresses the maximum sweep of the function body with the given
                arguments. Note that all these analyses are </textual><emphasis class="po-inline e778 e778" role="ital"><textual class="po-textual">in the context
                    of the initial function call</textual></emphasis><textual class="po-textual">, not the recursive call, which makes it
                possible to allow one function body to take different postures as input:</textual></para><para class="po-block e779 e779"><textual class="po-textual">
                </textual><table border="1px" cellpadding="3" class="po-container e780 e780" frame="border" rules="all" xml:id="table-recursive-calls" xreflabel="Table IV: Posture and sweep of recursive stylesheet function calls"><colgroup class="po-null e781 e781" span="1"><col align="left" class="po-meta e782 e782" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e783 e783" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e784 e784" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e785 e785" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e786 e786" span="1" width="1.0*"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e787 e787"><tr class="po-table e788 e788"><th align="left" class="po-field e789 e789"><textual class="po-textual">Argument posture</textual></th><th align="left" class="po-field e790 e790"><textual class="po-textual">Recursive argument posture</textual></th><th align="left" class="po-field e791 e791"><textual class="po-textual">Recursive function body &amp; call posture</textual><superscript class="po-atom e792 e792"><textual class="po-textual">a</textual></superscript></th><th align="left" class="po-field e793 e793"><textual class="po-textual">Recursive function call sweep</textual></th><th align="left" class="po-field e794 e794"><textual class="po-textual">Maximum function body sweep</textual></th></tr></thead><tfoot class="po-null e795 e795"><tr class="po-table e796 e796"><td class="po-block e797 e797" colspan="5"><para class="po-block e798 e798"><textual class="po-textual">
                                    </textual><superscript class="po-atom e799 e799"><textual class="po-textual">a)
                                        The function body must match the recursive call
                                        posture or be grounded, otherwise the posture is
                                        roaming.</textual></superscript><textual class="po-textual">
                                </textual></para><textual class="po-textual">
                                    </textual><para class="po-block e800 e800"><textual class="po-textual">
                                        </textual><superscript class="po-atom e801 e801"><textual class="po-textual">b)
                                            In fact, if the argument is grounded, the recursive
                                            argument will also be grounded.</textual></superscript><textual class="po-textual">
                                    </textual></para><textual class="po-textual">
                                    </textual><para class="po-block e802 e802"><textual class="po-textual">
                                        </textual><superscript class="po-atom e803 e803"><textual class="po-textual">c)
                                            Because on a next iteration, the argument will be
                                            crawling, not striding anymore, it would be a crawling
                                            expr. on a crawling expr. which is not guaranteed
                                            streamable.</textual></superscript><textual class="po-textual">
                                    </textual></para><textual class="po-textual">
                                </textual></td></tr></tfoot><tbody class="po-table e804 e804"><tr class="po-table e805 e805"><td class="po-block e806 e806"><textual class="po-textual">Grounded</textual></td><td class="po-block e807 e807"><textual class="po-textual">Any (grounded)</textual><superscript class="po-atom e808 e808"><textual class="po-textual">b</textual></superscript></td><td class="po-block e809 e809"><textual class="po-textual">Grounded</textual><superscript class="po-atom e810 e810"><textual class="po-textual">b</textual></superscript></td><td class="po-block e811 e811"><textual class="po-textual">Motionless</textual></td><td class="po-block e812 e812"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e813 e813"><td class="po-block e814 e814"><textual class="po-textual">any</textual></td><td class="po-block e815 e815"><emphasis class="po-inline e816 e816" role="ital"><textual class="po-textual">Direct-transitional</textual></emphasis></td><td align="left" class="po-block e817 e817"><textual class="po-textual">Posture of argument</textual></td><td class="po-block e818 e818"><textual class="po-textual">Motionless</textual></td><td align="left" class="po-block e819 e819"><textual class="po-textual">Consuming</textual></td></tr><tr class="po-table e820 e820"><td class="po-block e821 e821"><textual class="po-textual">Climbing</textual></td><td class="po-block e822 e822"><textual class="po-textual">Climbing</textual></td><td class="po-block e823 e823"><textual class="po-textual">Climbing</textual></td><td class="po-block e824 e824"><textual class="po-textual">Motionless</textual></td><td class="po-block e825 e825"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e826 e826"><td class="po-block e827 e827"><textual class="po-textual">Climbing</textual></td><td class="po-block e828 e828"><textual class="po-textual">Non-climbing</textual></td><td class="po-block e829 e829"><textual class="po-textual">Roaming</textual></td><td class="po-block e830 e830"><textual class="po-textual">Free-ranging</textual></td><td class="po-block e831 e831"><textual class="po-textual">n/a</textual></td></tr><tr class="po-table e832 e832"><td class="po-block e833 e833"><textual class="po-textual">Striding</textual></td><td class="po-block e834 e834"><textual class="po-textual">Climbing</textual></td><td class="po-block e835 e835"><textual class="po-textual">Climbing</textual></td><td class="po-block e836 e836"><textual class="po-textual">Motionless</textual></td><td class="po-block e837 e837"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e838 e838"><td class="po-block e839 e839"><textual class="po-textual">Striding</textual></td><td class="po-block e840 e840"><textual class="po-textual">Striding</textual></td><td class="po-block e841 e841"><textual class="po-textual">Striding</textual></td><td class="po-block e842 e842"><textual class="po-textual">Consuming</textual></td><td class="po-block e843 e843"><textual class="po-textual">Consuming</textual></td></tr><tr class="po-table e844 e844"><td class="po-block e845 e845"><textual class="po-textual">Striding</textual></td><td class="po-block e846 e846"><textual class="po-textual">Crawling</textual></td><td class="po-block e847 e847"><textual class="po-textual">Roaming</textual><superscript class="po-atom e848 e848"><textual class="po-textual">c</textual></superscript></td><td class="po-block e849 e849"><textual class="po-textual">Free-ranging</textual><superscript class="po-atom e850 e850"><textual class="po-textual">c</textual></superscript></td><td class="po-block e851 e851"><textual class="po-textual">n/a</textual></td></tr><tr class="po-table e852 e852"><td class="po-block e853 e853"><textual class="po-textual">Crawling</textual></td><td class="po-block e854 e854"><textual class="po-textual">Climbing</textual></td><td class="po-block e855 e855"><textual class="po-textual">Climbing</textual></td><td class="po-block e856 e856"><textual class="po-textual">Motionless</textual></td><td class="po-block e857 e857"><textual class="po-textual">Motionless</textual></td></tr><tr class="po-table e858 e858"><td class="po-block e859 e859"><textual class="po-textual">Crawling</textual></td><td class="po-block e860 e860"><textual class="po-textual">Non-climbing</textual></td><td class="po-block e861 e861"><textual class="po-textual">Roaming</textual></td><td class="po-block e862 e862"><textual class="po-textual">Free-ranging</textual></td><td class="po-block e863 e863"><textual class="po-textual">n/a</textual></td></tr><tr class="po-table e864 e864"><td class="po-block e865 e865"><textual class="po-textual">Roaming</textual></td><td class="po-block e866 e866"><textual class="po-textual">any</textual></td><td class="po-block e867 e867"><textual class="po-textual">Roaming</textual></td><td class="po-block e868 e868"><textual class="po-textual">Free-ranging</textual></td><td class="po-block e869 e869"><textual class="po-textual">n/a</textual></td></tr></tbody></table><textual class="po-textual">
            </textual></para><para class="po-block e870 e870"><textual class="po-textual">For this table to work in practice, we can allow at most one recursion point, or
                each recursion point must have the same posture </textual><emphasis class="po-inline e871 e871" role="ital"><textual class="po-textual">and</textual></emphasis><textual class="po-textual"> at most one can be consuming. Once you have found the posture
                and sweeps of the recursive function call, you can continue the analysis of the
                function body and then apply the previous </textual><xref class="po-milestone e872 e872" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e873 e873"><textual class="po-textual">The rules in this table are laid out in such a way that it is not possible to have
                a </textual><emphasis class="po-inline e874 e874" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> expression as the argument to a
                recursive function at a recursion point and somewhere else in the same function body
                a consuming construct or a non-climbing result. This is necessary, because if we
                would allow the combination of a </textual><emphasis class="po-inline e875 e875" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">
                recursion point and a </textual><emphasis class="po-inline e876 e876" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> function body,
                then on either the initial call (with a </textual><emphasis class="po-inline e877 e877" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">
                argument) or the recursive call (if the initial call would have been </textual><emphasis class="po-inline e878 e878" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> for instance) would call the function with an
                incompatible </textual><emphasis class="po-inline e879 e879" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture, which would then
                be consumed. And a </textual><emphasis class="po-inline e880 e880" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture can never be
                consumed. More specifically, it prevents a function like the following to be
                considered streamable:</textual></para><para class="po-block e881 e881"><textual class="po-textual">
                </textual><figure class="po-container e882 e882" xml:id="f-climbstri" xreflabel="Code listing: non-streamable climbing and consuming"><programlisting class="po-block e883 e883" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:climbstri"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:choose&gt;
        &lt;xsl:when test="f:climbstri($n/ancestor::foo)/contains(., 'bar')"&gt;
            &lt;xsl:text&gt;Found it&lt;/xsl:text&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="$n" /&gt;
        &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e884 e884"><textual class="po-textual">Glancing over the example might already give a hint as to why it cannot possibly
                be streamable: the </textual><code class="po-atom e885 e885"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> can consume a streamed node and that
                streamed node is likely to be at a climbing axis because of the climbing posture of
                the recursive argument. If we take the item in the table into account and consider
                calling this function with a striding argument, as with </textual><code class="po-atom e886 e886"><textual class="po-textual">f:climbstr(a/b)</textual></code><textual class="po-textual">
                then we find in the entry for </textual><emphasis class="po-inline e887 e887" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and
                    </textual><emphasis class="po-inline e888 e888" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> that the body of the function must
                at most be motionless. It is consuming, because of the </textual><code class="po-atom e889 e889"><textual class="po-textual">xsl:value-of</textual></code><textual class="po-textual"> so
                the analysis fails and the function is </textual><emphasis class="po-inline e890 e890" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual">
                and </textual><emphasis class="po-inline e891 e891" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e892 e892"><textual class="po-textual">If we go back to our original example (see </textual><xref class="po-milestone e893 e893" linkend="f-recur"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) and apply
                the rules of this table, we have one recursion point, </textual><code class="po-atom e894 e894"><textual class="po-textual">f:recur($n)</textual></code><textual class="po-textual">, the
                argument is </textual><emphasis class="po-inline e895 e895" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual">, that is, it is
                motionless and takes the posture of its caller, in this case the caller of the
                function. According to the table above, we can use any posture as input, which will
                then become the result posture, and the sweep of the function body follows as
                    </textual><emphasis class="po-inline e896 e896" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e897 e897" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">. In our case, the call has a child-select expression in
                    </textual><code class="po-atom e898 e898"><textual class="po-textual">f:recur(y)</textual></code><textual class="po-textual">, which has posture </textual><emphasis class="po-inline e899 e899" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and sweep </textual><emphasis class="po-inline e900 e900" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">. The
                result posture and sweep of the whole template is then </textual><emphasis class="po-inline e901 e901" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e902 e902" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e903 e903" xml:id="indirect-recursion"><title class="po-block e904 e904"><textual class="po-textual">Indirect recursion</textual></title><para class="po-block e905 e905"><textual class="po-textual">With indirect recursion there are extra layers of calls before the recursion takes
                place, as in A calls B calls C calls A again. The question that rises is whether the
                rules in </textual><xref class="po-milestone e906 e906" linkend="direct-recursion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> also hold if a function calls itself
                indirectly. Indirect recursion is a type of recursion that can also be determined
                statically. Let us look at an example:</textual></para><para class="po-block e907 e907"><textual class="po-textual">
                </textual><figure class="po-container e908 e908" xml:id="f-filterattr" xreflabel="Code listing: indirect recursion"><programlisting class="po-block e909 e909" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:filterattr"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:param name="filter" /&gt;
    &lt;xsl:sequence select="$n/@*[name() = $filter]" /&gt;
    &lt;!-- indirect recursion --&gt;
    &lt;xsl:sequence select="f:take-ancestor($n, $filter)" /&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="f:take-ancestor"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:param name="filter" /&gt;
    &lt;xsl:sequence select="
        if($n) 
        (: indirect recursion :)
        then f:filterattr($n/ancestor::element()[1], $filter) 
        else ()" /&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e910 e910"><textual class="po-textual">The example is a very verbose and clumsy way of getting all attributes of all
                ancestor-or-self nodes that have a certain name. For instance, with the
                following input and stylesheet, the output will be </textual><code class="po-atom e911 e911"><textual class="po-textual">3.14 1.64</textual></code><textual class="po-textual">:</textual></para><para class="po-block e912 e912"><textual class="po-textual">
                </textual><figure class="po-container e913 e913" xml:id="f-input-doc" xreflabel="Code listing: input document"><programlisting class="po-block e914 e914" xml:space="preserve"><textual class="po-textual">&lt;foo version="1.64" name="john"&gt;
    &lt;zed&gt;
        &lt;bar version="3.14" id="1234"&gt;
    &lt;/zed&gt;
&lt;/foo&gt;</textual></programlisting></figure><textual class="po-textual">
                </textual><figure class="po-container e915 e915" xml:id="f-stylesheet" xreflabel="Code listing: indirect recursive function call example"><programlisting class="po-block e916 e916" xml:space="preserve"><textual class="po-textual">&lt;xsl:mode on-no-match="shallow-skip" /&gt;

&lt;xsl:template match="bar"&gt;
    &lt;xsl:value-of select="f:filterattr(., 'version')" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e917 e917"><textual class="po-textual">But whether it is clumsy or not is not the matter. It serves as a basic example of
                indirect recursion and the function is clearly streamable because it only traverses
                the ancestor and attribute axes, which are motionless. However, the question is, of
                course, whether this example is streamable by following the rules from 
                    </textual><xref class="po-milestone e918 e918" linkend="table-recursive-calls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e919 e919"><textual class="po-textual">If we try that a first time, we quickly find that it is not immediately obvious
                how to apply it, because the functions above are not directly recursive. Recall that
                we said in </textual><xref class="po-milestone e920 e920" linkend="direct-recursion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> we wrote </textual><quote class="po-inline e921 e921"><textual class="po-textual"> we can allow at most
                    one recursion point, or each recursion point must have the same posture and at
                    most one can be consuming </textual></quote><textual class="po-textual">. There are two recursion points here, the one
                inside </textual><code class="po-atom e922 e922"><textual class="po-textual">f:filterattr</textual></code><textual class="po-textual"> that calls </textual><code class="po-atom e923 e923"><textual class="po-textual">f:take-ancestor</textual></code><textual class="po-textual"> and the one
                inside </textual><code class="po-atom e924 e924"><textual class="po-textual">f:take-ancestor</textual></code><textual class="po-textual"> that calls </textual><code class="po-atom e925 e925"><textual class="po-textual">f:filterattr</textual></code><textual class="po-textual">. The
                posture of the first one takes the input posture of the argument, it is </textual><emphasis class="po-inline e926 e926" role="ital"><textual class="po-textual">Direct-transitional</textual></emphasis><textual class="po-textual">, the second one traverses the
                ancestor axis, which gives it a </textual><emphasis class="po-inline e927 e927" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture.
                Finally, the argument inside the template example in </textual><xref class="po-milestone e928 e928" linkend="f-stylesheet"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
                has itself a posture of </textual><emphasis class="po-inline e929 e929" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, because the
                context item expression takes the </textual><emphasis class="po-inline e930 e930" role="ital"><textual class="po-textual">context posture</textual></emphasis><textual class="po-textual">
                which in the case of </textual><code class="po-atom e931 e931"><textual class="po-textual">xsl:template</textual></code><textual class="po-textual"> is </textual><emphasis class="po-inline e932 e932" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e933 e933"><textual class="po-textual">In short, if we start at the template, we start with posture </textual><emphasis class="po-inline e934 e934" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, then </textual><emphasis class="po-inline e935 e935" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> again
                (because it is </textual><emphasis class="po-inline e936 e936" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual">), then </textual><emphasis class="po-inline e937 e937" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> and on the next recursive iteration this
                repeats, but now from </textual><emphasis class="po-inline e938 e938" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> as input to
                    </textual><code class="po-atom e939 e939"><textual class="po-textual">f:filter-attr</textual></code><textual class="po-textual">, then </textual><emphasis class="po-inline e940 e940" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> again
                (because </textual><emphasis class="po-inline e941 e941" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual"> takes over the posture
                of the argument) and so it continues climbing until all recursive iterations have
                finished.</textual></para><para class="po-block e942 e942"><textual class="po-textual">This breaks the rule we set to ourselves: the posture changed from </textual><emphasis class="po-inline e943 e943" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> to </textual><emphasis class="po-inline e944 e944" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">.
                Yet, we also established that the example functions were streamable. The conflict
                arises from the argument </textual><code class="po-atom e945 e945"><textual class="po-textual">$n</textual></code><textual class="po-textual"> being </textual><emphasis class="po-inline e946 e946" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual">, which works like a cameleon and changes the
                posture along the way. One resolution to this specific situation is to allow
                    </textual><emphasis class="po-inline e947 e947" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual">, provided the rest of the
                body of the function is motionless, in which case it does no harm. Another, perhaps
                easier solution is to force the </textual><emphasis class="po-inline e948 e948" role="ital"><textual class="po-textual">same posture in, same posture
                    out</textual></emphasis><textual class="po-textual"> rule and rewrite the argument to this function as follows:</textual></para><para class="po-block e949 e949"><textual class="po-textual">
                </textual><figure class="po-container e950 e950" xml:id="f-stylesheet-fixed" xreflabel="Code listing: fixed indirect recursive function call"><programlisting class="po-block e951 e951" xml:space="preserve"><textual class="po-textual">&lt;xsl:mode on-no-match="shallow-skip" /&gt;

&lt;xsl:template match="bar"&gt;
    &lt;xsl:value-of select="f:filterattr(./ancestor-or-self::*[1], 'version')" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e952 e952"><textual class="po-textual">The change to using the ancestor-or-self axis also changes the initial posture to
                    </textual><emphasis class="po-inline e953 e953" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">, which in turn changes the posture of
                    </textual><code class="po-atom e954 e954"><textual class="po-textual">$n</textual></code><textual class="po-textual"> to be </textual><emphasis class="po-inline e955 e955" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> as well, making
                all postures in all recursion points climbing.</textual></para><para class="po-block e956 e956"><textual class="po-textual">While this relatively trivial example seemed to show an edge-case because it used
                a recursive argument posture of </textual><emphasis class="po-inline e957 e957" role="ital"><textual class="po-textual">direct-transitional</textual></emphasis><textual class="po-textual">, it taught us two things: one, even a trivial
                example can quickly appear hard once we try to apply streamability rules on them and
                two, to keep things simple, it is best to stick a set of ground rules, even though
                that potentially means that we slightly limit certain use-cases.</textual></para><para class="po-block e958 e958"><textual class="po-textual">In practice, indirect recursion is found pretty rarely in XSLT programming, even
                though XSLT is itself a functional language, it is much more common to use direct
                recursion. But if a scenario requires indirect recursion, it is possible, even with
                streaming.</textual></para></section><section class="po-hcontainer e959 e959" xml:id="indeterminate-recursion"><title class="po-block e960 e960"><textual class="po-textual">Indeterminate recursion</textual></title><para class="po-block e961 e961"><textual class="po-textual">Another challenge comes from indeterminate recursion as in the following
            example:</textual></para><para class="po-block e962 e962"><textual class="po-textual">
            </textual><figure class="po-container e963 e963" xml:id="f-indeter" xreflabel="Code listing: trivial indeterminate recursion"><programlisting class="po-block e964 e964" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:indeter"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:apply-templates select="$n" mode="streamable" /&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="*" mode="streamable"&gt;
    &lt;xsl:sequence select="f:indeter(.)" /&gt;
&lt;/xsl:template&gt;</textual></programlisting></figure><textual class="po-textual">
        </textual></para><para class="po-block e965 e965"><textual class="po-textual">In this situation, the analysis of the function declaration and the template
            declaration can be done independently, without ever finding the recursion point.
            However, when this code is run, the recursion kicks in (assuming the argument is an
            element). There is, however, one big advantage to this type of recursion: the rules on
            templates define that the result of a template declaration must be </textual><emphasis class="po-inline e966 e966" role="ital"><textual class="po-textual">grounded</textual></emphasis><footnote class="po-popup e967 e967"><para class="po-block e968 e968"><textual class="po-textual">See section </textual><link class="po-inline e969 e969" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamable-templates" xlink:show="new" xlink:type="simple"><textual class="po-textual">6.6.3, Streamable Templates in XSL Transformations 3.0</textual></link><textual class="po-textual">, second
                    bullet-point: </textual><quote class="po-inline e970 e970"><textual class="po-textual">The sequence constructor contained in the body of the
                        xsl:template element is grounded</textual></quote><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">. Therefore, by definition, the result of any
                </textual><code class="po-atom e971 e971"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> is also </textual><emphasis class="po-inline e972 e972" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">, which gives the function body above a </textual><emphasis class="po-inline e973 e973" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> posture as well. In turn, the call to </textual><code class="po-atom e974 e974"><textual class="po-textual">f:indeter</textual></code><textual class="po-textual">
            results in a </textual><emphasis class="po-inline e975 e975" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> posture, which concludes the
            circle. In addition, any select-expression in </textual><code class="po-atom e976 e976"><textual class="po-textual">xsl:apply-templates</textual></code><textual class="po-textual"> must be
            atomizable, which in streamability terms means that it cannot be </textual><emphasis class="po-inline e977 e977" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e978 e978" role="ital"><textual class="po-textual">crawling</textual></emphasis><footnote class="po-popup e979 e979"><para class="po-block e980 e980"><textual class="po-textual">One exception is allowed for selections that only select childless nodes, such
                    as attribute nodes. These are </textual><emphasis class="po-inline e981 e981" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> but do
                    not contain children and are henceforth allowed.</textual></para></footnote><textual class="po-textual">. This leads us to a temporary conclusion: if the arguments to a function are
                </textual><emphasis class="po-inline e982 e982" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> they can be used in indeterminate
            recursive functions. If the arguments are not </textual><emphasis class="po-inline e983 e983" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">, the analysis fails and makes the call on the function
                </textual><emphasis class="po-inline e984 e984" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e985 e985" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e986 e986"><textual class="po-textual">Following </textual><xref class="po-milestone e987 e987" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and taking the same
                approach that the body of the function should be analyzed during the call to the
                function, we can conclude that it is impossible for a function body to apply
                templates on something else then a </textual><emphasis class="po-inline e988 e988" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">
                posture. The one exception that is allowed in the General Streamability Rules</textual><footnote class="po-popup e989 e989"><para class="po-block e990 e990"><textual class="po-textual">See </textual><link class="po-inline e991 e991" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#general-streamability-rules" xlink:show="new" xlink:type="simple"><textual class="po-textual">Section 19.8.1 General Streamability Rules in XSL Transformations
                            3.0</textual></link><textual class="po-textual">, item 1.b.iii.A.I.</textual></para></footnote><textual class="po-textual">is for a </textual><emphasis class="po-inline e992 e992" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture of childless
                nodes, which only applies to the attribute axis. This means that we can consider the
                following example streamable as well, even though we pass a </textual><emphasis class="po-inline e993 e993" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">, or even a </textual><emphasis class="po-inline e994 e994" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual">
                expression to the function:</textual></para><para class="po-block e995 e995"><textual class="po-textual">
                </textual><figure class="po-container e996 e996" xml:id="f-apply-attribs" xreflabel="Code listing: climbing result accepting crawling posture"><programlisting class="po-block e997 e997" xml:space="preserve"><textual class="po-textual">&lt;xsl:function name="f:apply-attribs"&gt;
    &lt;xsl:param name="n" /&gt;
    &lt;xsl:apply-templates select="$n/@*" /&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
            </textual></para><para class="po-block e998 e998"><textual class="po-textual">Whether or not that function will be called indeterminate-recursively or not is
                irrelevant, because on the second iteration, the selection will be empty, because
                attribute nodes do not have children.</textual></para><para class="po-block e999 e999"><textual class="po-textual">In short: indeterminate recursion does not have influence on the streamability
                analysis, nor does it break it. The existing rules suffice.</textual></para></section><section class="po-hcontainer e1000 e1000"><title class="po-block e1001 e1001"><textual class="po-textual">Dynamic recursion</textual></title><para class="po-block e1002 e1002"><textual class="po-textual">Dynamic recursion looks a bit like indeterminate recursion in the sense that
                whether or not recursion takes place cannot be determined statically. In XPath 3.0,
                it is possible to bind a variable to a function</textual><footnote class="po-popup e1003 e1003"><para class="po-block e1004 e1004"><textual class="po-textual">See section </textual><link class="po-inline e1005 e1005" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-eval-function-call" xlink:show="new" xlink:type="simple"><textual class="po-textual">3.1.5.1
                            Evaluating Static and Dynamic Function Calls</textual></link><textual class="po-textual"> in the XPath 3.0
                        Recommendation.</textual></para></footnote><textual class="po-textual">, this is commonly referred to as higher order functions. The concept is
                not new, already in 2001, Dimitre Novatchev showed in his paper
                    </textual><xref class="po-milestone e1006 e1006" linkend="Novatchev01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that writing higher order functions is possible
                in XSLT 1.0 by means of what he calls </textual><emphasis class="po-inline e1007 e1007" role="ital"><textual class="po-textual">template
                    references</textual></emphasis><footnote class="po-popup e1008 e1008"><para class="po-block e1009 e1009"><textual class="po-textual">See page 4 of his paper </textual><xref class="po-milestone e1010 e1010" linkend="Novatchev01"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">, a concept also applied to the functional coding patterns in
                    </textual><xref class="po-milestone e1011 e1011" linkend="Mangano05"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, which was further popularized as </textual><emphasis class="po-inline e1012 e1012" role="ital"><textual class="po-textual">the Novatchev technique</textual></emphasis><textual class="po-textual"> in </textual><xref class="po-milestone e1013 e1013" linkend="Kay08"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
                It took until XSLT and XPath 3.0 that function items became first-class citizens,
                see my own paper </textual><xref class="po-milestone e1014 e1014" linkend="Braaksma13"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for an extended coverage of that subject
                for XSLT and </textual><xref class="po-milestone e1015 e1015" linkend="Grust13"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a coverage for XQuery and
                databases.</textual></para><para class="po-block e1016 e1016"><textual class="po-textual">For the rest of this section, we will assume you have a basic understanding of
                higher order functions in XSLT and XPath. The closure of higher order functions
                cannot contain the context item, so for our analysis we should only worry about
                arguments that can be streamed nodes, just like with regular functions.</textual></para><para class="po-block e1017 e1017"><textual class="po-textual">The nature of a dynamic function call is that the function it refers to is only
                known at runtime, when the variable is bound to a function item. As a result, there
                is not much we can say of the posture and sweep of the function it refers to until
                it is actually invoked. Following the rules on streamability, the result of binding
                a variable to a function item is always grounded. This makes sense, because at the
                moment of binding, a function item is assigned to a variable and no streamed nodes
                are possibly involved in the result.</textual></para><para class="po-block e1018 e1018"><textual class="po-textual">Once a function item is evaluated, its arguments are known. Provided that the
                arguments themselves are not </textual><emphasis class="po-inline e1019 e1019" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and
                    </textual><emphasis class="po-inline e1020 e1020" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">, the analysis will thenceforth
                look at the bound function. If this function is streamable, we can do the analysis
                from the previous sections as if it was a direct function call. The biggest
                difference lies in the fact that the analysis is done during execution. This means
                that an error for whether a call is not streamable will be a dynamic error.</textual></para><para class="po-block e1021 e1021"><textual class="po-textual">This is no different for dynamic recursion. If dynamic evaluation leads to a
                recursive call, the posture of the argument, the recursive call and the function
                body must be matched to </textual><xref class="po-milestone e1022 e1022" linkend="table-recursive-calls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. If the result is
                    </textual><emphasis class="po-inline e1023 e1023" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1024 e1024" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">, the recursive call is not guaranteed
                streamable.</textual></para><para class="po-block e1025 e1025"><textual class="po-textual">While it is theoretically possible to allow such dynamic streamability rules, the
                rules in the specification are meant to </textual><emphasis class="po-inline e1026 e1026" role="ital"><textual class="po-textual">guarantee</textual></emphasis><textual class="po-textual">
                streamability statically. As a result, any potential </textual><emphasis class="po-inline e1027 e1027" role="ital"><textual class="po-textual">dynamic</textual></emphasis><textual class="po-textual"> streamability is prohibited. Processors may allow dynamic
                streamability as a vendor extension, but the specification will consider passing a
                node to a dynamic function call </textual><emphasis class="po-inline e1028 e1028" role="ital"><textual class="po-textual">not guaranteed
                    streamable</textual></emphasis><textual class="po-textual">, dynamic recursion, as suggested in this section, is
                therefor not possible with the current set of rules on </textual><emphasis class="po-inline e1029 e1029" role="ital"><textual class="po-textual">static
                    guaranteed streamability</textual></emphasis><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e1030 e1030" xml:id="analyzable"><title class="po-block e1031 e1031"><textual class="po-textual">Analyzable and non-analyzable functions</textual></title><para class="po-block e1032 e1032"><textual class="po-textual">Analyzable stylesheet functions are functions that can be analyzed by themselves,
                as we saw in </textual><xref class="po-milestone e1033 e1033" linkend="approach-1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Non-analyzable stylesheet functions are
                those that can only be analyzed from the function call, because the body of the
                function on itself cannot be analyzed without knowing what the argument is. Most of
                the previous sections was about non-analyzable function calls.</textual></para><para class="po-block e1034 e1034"><textual class="po-textual">Spec-wise, the term </textual><emphasis class="po-inline e1035 e1035" role="ital"><textual class="po-textual">non-analyzable</textual></emphasis><textual class="po-textual"> refers to the
                set of functions that cannot be analyzed statically and are given very conservative
                assumptions on streamability. This is true for recursive stylesheet functions and
                non-final streamable functions (see </textual><xref class="po-milestone e1036 e1036" linkend="packages"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). The term </textual><emphasis class="po-inline e1037 e1037" role="ital"><textual class="po-textual">non-analyzable</textual></emphasis><textual class="po-textual"> does not necessarily mean that the
                function is not analyzable, however, the general rule is that it requires a call, or
                knowledge of the context of a call to the function to find out whether or not the
                function is streamable. We have seen in the previous sections that it is possible to
                allow quite a variety of postures, even for non-analyzable functions, but in the
                specification such functions are limited to a posture of </textual><emphasis class="po-inline e1038 e1038" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and are always considered </textual><emphasis class="po-inline e1039 e1039" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> even if in fact they are not.</textual></para></section></section><section class="po-hcontainer e1040 e1040" xml:id="packages"><title class="po-block e1041 e1041"><textual class="po-textual">Non-final streamable functions in packages</textual></title><para class="po-block e1042 e1042"><textual class="po-textual">In XSLT 3.0, a new feature, </textual><emphasis class="po-inline e1043 e1043" role="ital"><textual class="po-textual">packages</textual></emphasis><textual class="po-textual"> allows
            programmers to create a collection of modes, functions, named and matching templates,
            accumulators etc and pack them in a, potentially pre-compilable, </textual><emphasis class="po-inline e1044 e1044" role="ital"><textual class="po-textual">package</textual></emphasis><textual class="po-textual">, which can then be included in other packages or stylesheets
            with </textual><code class="po-atom e1045 e1045"><textual class="po-textual">xsl:use-package</textual></code><footnote class="po-popup e1046 e1046"><para class="po-block e1047 e1047"><textual class="po-textual">See section </textual><link class="po-inline e1048 e1048" xlink:actuate="onRequest" xlink:href="https://www.w3.org/XML/Group/qtspecs/specifications/xslt-30/html/Overview.html#package-dependencies" xlink:show="new" xlink:type="simple"><textual class="po-textual">3.6.1 Dependencies between Packages</textual></link><textual class="po-textual"> in XSLT 3.0 Working
                    Draft.</textual></para></footnote><textual class="po-textual">. Components in that package can have a </textual><emphasis class="po-inline e1049 e1049" role="ital"><textual class="po-textual">visibility</textual></emphasis><textual class="po-textual"> attribute that can be set to </textual><emphasis class="po-inline e1050 e1050" role="ital"><textual class="po-textual">public</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1051 e1051" role="ital"><textual class="po-textual">private</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1052 e1052" role="ital"><textual class="po-textual">final</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1053 e1053" role="ital"><textual class="po-textual">abstract</textual></emphasis><textual class="po-textual">. If the visibility is
            set to </textual><emphasis class="po-inline e1054 e1054" role="ital"><textual class="po-textual">private</textual></emphasis><textual class="po-textual"> it can only be used in the local
            package, and if it is set to </textual><emphasis class="po-inline e1055 e1055" role="ital"><textual class="po-textual">final</textual></emphasis><textual class="po-textual"> the declaration
            cannot be overridden, but can be used also in other packages. Visibility </textual><emphasis class="po-inline e1056 e1056" role="ital"><textual class="po-textual">abstract</textual></emphasis><textual class="po-textual"> means there is no implementation yet, and it must be
            implemented by a using package (one that includes the package). And </textual><emphasis class="po-inline e1057 e1057" role="ital"><textual class="po-textual">public</textual></emphasis><textual class="po-textual">, the default, means that a declaration can be
            overridden by using </textual><code class="po-atom e1058 e1058"><textual class="po-textual">xsl:override</textual></code><textual class="po-textual">, which will then take precedence over the
            original implementation. This can be considered similar to </textual><emphasis class="po-inline e1059 e1059" role="ital"><textual class="po-textual">virtual
                methods</textual></emphasis><textual class="po-textual"> in object-oriented languages like C++ and C#.</textual></para><para class="po-block e1060 e1060"><textual class="po-textual">The result for determining whether a function can be </textual><emphasis class="po-inline e1061 e1061" role="ital"><textual class="po-textual">guaranteed
                streamable</textual></emphasis><textual class="po-textual"> or not cannot be determined statically at the moment that a
            package is compiled, because it is possible that it will later be overridden and any
            calls to that function can be impacted if the implementation, and the streamability,
            changes.</textual></para><para class="po-block e1062 e1062"><textual class="po-textual">As briefly explained in the previous section, if a function is defined with visibility
                </textual><emphasis class="po-inline e1063 e1063" role="ital"><textual class="po-textual">abstract</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1064 e1064" role="ital"><textual class="po-textual">public</textual></emphasis><textual class="po-textual">, in other words, if they are non-final and non-private, then they are
            considered </textual><emphasis class="po-inline e1065 e1065" role="ital"><textual class="po-textual">non-analyzable</textual></emphasis><textual class="po-textual"> by the specification. This
            means that the processor cannot, and does not have to, try to analyze function calls too
            deeply: it only expects a </textual><emphasis class="po-inline e1066 e1066" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture and it will
            not try to determine whether or not the function is consuming or motionless when you
            call the function: it assumes the worst and will consider the call </textual><emphasis class="po-inline e1067 e1067" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1068 e1068"><textual class="po-textual">A proposal from me in the bug entry </textual><footnote class="po-popup e1069 e1069"><para class="po-block e1070 e1070"><textual class="po-textual">See </textual><link class="po-inline e1071 e1071" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple"><textual class="po-textual">Bug
                        25679</textual></link><textual class="po-textual"> in W3C's BugZilla, which discusses the implications of allowing
                    streamable stylesheet functions.</textual></para></footnote><textual class="po-textual">awaits reaction from the working group. It shows a way that processors can
            use to statically detemine the posture of non-final streamable functions. However, if
            that proposal were excepted, it will pose limitations on overriding non-final streamable
            stylesheet functions. I think, however, that not being able to override a function, and
            not being able to write non-final functions, is too severe a limitation. Even if a
            function is non-final, if you override it to make it final, you will have to rewrite the
            whole function body, you cannot use </textual><code class="po-atom e1072 e1072"><textual class="po-textual">xsl:original()</textual></code><textual class="po-textual">, because that would call
            into the non-final function again, which takes too much of conservative approach.</textual></para><para class="po-block e1073 e1073"><textual class="po-textual">An alternative approach is the approach taken for the recursive functions in the
            previous sections. For all analysis there, we always considered the function call itself
            to get the whole picture. For functions that are non-final, such an approach can also
            work. Because the processor only knows what function to call when it encounters the
            function call itself, it should include the body of that function at that moment into
            the analysis. This can be done statically, there is no need to first run the
            stylesheet.</textual></para><para class="po-block e1074 e1074"><textual class="po-textual">A potential problem, however, still arises if someone writes a package function that
            works correctly with a </textual><emphasis class="po-inline e1075 e1075" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> result posture, but
            cannot be used if that is changed into a function override with a </textual><emphasis class="po-inline e1076 e1076" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> result posture. Even more, a </textual><emphasis class="po-inline e1077 e1077" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> function could be changed into a </textual><emphasis class="po-inline e1078 e1078" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual"> function, which will greatly impede existing calls to that
            function. One way to remedy that is to disallow overriding functions with a different
            result posture or with a different sweep. That means that any given call will need to be
            analyzed against the new function and the </textual><code class="po-atom e1079 e1079"><textual class="po-textual">xsl:original()</textual></code><textual class="po-textual"> function call, as
            if it still existed in scope, otherwise it will not be possible for the processor to
            determine whether there is a change in posture or sweep.</textual></para><para class="po-block e1080 e1080"><textual class="po-textual">Whether or not this turns out to be a feasible option in practice remains to be seen.
            After all, there is always a trade-off between usability of a feature and the complexity
            of the rules or the complexity for implementations. If the rules become too complex for
            anybody to understand, then there is littly chance it will be used in practice, and
            there will be little incentive for existing implementors to implement such feature, let
            alone write specification-tests for it.</textual></para></section><section class="po-hcontainer e1081 e1081" xml:id="type-determined"><title class="po-block e1082 e1082"><textual class="po-textual">An improvement: type-determined posture</textual></title><para class="po-block e1083 e1083"><textual class="po-textual">In the past few sections we have seen that analyzing a function that can return nodes
            can be quite hard and intricate. However, if you know what type your function will
            return, you can use the </textual><code class="po-atom e1084 e1084"><textual class="po-textual">as</textual></code><textual class="po-textual">-attribute on the </textual><code class="po-atom e1085 e1085"><textual class="po-textual">xsl:function</textual></code><textual class="po-textual">
            declaration. This will tell the processor that the result must be converted into the
            type defined in that attribute.</textual></para><para class="po-block e1086 e1086"><textual class="po-textual">In cases where the type is not a node, the processor can go much further with static
            analysis than in situations where the type is not known, because if the type is not
            known, the processor must assume the worst. Suppose you declare the function with
                </textual><code class="po-atom e1087 e1087"><textual class="po-textual">as="xs:integer"</textual></code><textual class="po-textual">, there is no way your function can return nodes. For
            recursion this is a big help, because the processor now knows the result of the
            recursion will not contain nodes. Whether or not there is overlap in the argument
            expression is now less relevant and the posture of any function call, even the recursive
            ones, will always be </textual><emphasis class="po-inline e1088 e1088" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">. This makes the
            requirement to match the argument with the result posture go away and simplifies both
            writing and analysis.</textual></para><para class="po-block e1089 e1089"><textual class="po-textual">Let us look at an example, adopted from an example by Michael Sperberg-McQueen:</textual></para><para class="po-block e1090 e1090"><textual class="po-textual">
            </textual><figure class="po-container e1091 e1091" xml:id="f-fqgi" xreflabel="Code listing: type determined posture"><programlisting class="po-block e1092 e1092" xml:space="preserve"><textual class="po-textual">&lt;!-- mimicking what can also be written as
     string-join(('', reverse(ancestor-or-self::*)/name()), '/') --&gt;
&lt;xsl:function name="f:fqgi" as="xs:string"&gt;
    &lt;xsl:param name="n" as="node()"/&gt;
    &lt;xsl:choose&gt;
        &lt;xsl:when test="count($n/ancestor::*) = 0"&gt;
            &lt;xsl:value-of select="'/' || name($n)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="concat(
                name($n), 
                '/', 
                f:fqgi($n/parent::*))"/&gt;
        &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</textual></programlisting></figure><textual class="po-textual">
        </textual></para><para class="po-block e1093 e1093"><textual class="po-textual">The example takes a node, processes its parents recursively and returns the names in
            reverse order (deepest first) separated by slashes. Because the function is declared to
            return a </textual><emphasis class="po-inline e1094 e1094" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> result, namely
                </textual><code class="po-atom e1095 e1095"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">, there is no need to assume the function can return nodes,
            because it cannot. Through </textual><xref class="po-milestone e1096 e1096" linkend="table-recursive-calls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> we find
            that if the argument posture is </textual><emphasis class="po-inline e1097 e1097" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and the
            recursive argument posture is </textual><emphasis class="po-inline e1098 e1098" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">, as is the
            case here, the recursive function call is considered </textual><emphasis class="po-inline e1099 e1099" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> as well and the function body must then result in either a
                </textual><emphasis class="po-inline e1100 e1100" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1101 e1101" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> posture.</textual></para><para class="po-block e1102 e1102"><textual class="po-textual">In this case, the function call itself does not have to be set to be </textual><emphasis class="po-inline e1103 e1103" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">, because we know from the </textual><code class="po-atom e1104 e1104"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">
            result type that the result will always be </textual><emphasis class="po-inline e1105 e1105" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual">.
            This simplifies the analysis in that we can now consider the function argument to be of
            either </textual><emphasis class="po-inline e1106 e1106" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1107 e1107" role="ital"><textual class="po-textual">inspection</textual></emphasis><textual class="po-textual"> usage. If the function body as a whole consumes the node
            referenced by </textual><code class="po-atom e1108 e1108"><textual class="po-textual">$n</textual></code><textual class="po-textual"> it will be </textual><emphasis class="po-inline e1109 e1109" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> and
            the analysis fails, because a climbing expression with </textual><emphasis class="po-inline e1110 e1110" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual"> usage is not allowed. Because the only other operands on the
            streamed argument are </textual><code class="po-atom e1111 e1111"><textual class="po-textual">fn:count</textual></code><textual class="po-textual"> and </textual><code class="po-atom e1112 e1112"><textual class="po-textual">fn:name</textual></code><textual class="po-textual">, both having
            inspection operand usage and both being motionless, the result of the analysis as a
            whole is that the function is guaranteed streamable, does not consume the streamed
            argument which we can summarize as having usage </textual><emphasis class="po-inline e1113 e1113" role="ital"><textual class="po-textual">inspection</textual></emphasis><textual class="po-textual">, and while it is direct-recursive we know it can be called
            with any argument, albeit </textual><emphasis class="po-inline e1114 e1114" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1115 e1115" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1116 e1116" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1117 e1117"><textual class="po-textual">We could expand the type-determined analysis further by including whether or not the
            streamable argument has a cardinality of zero-or-one or has a cardinality of
            zero-or-more. In the case of zero-or-one there is no way that overlapping nodes can be
            passed on to the function, which can simplify analysis of a function call with a
                </textual><emphasis class="po-inline e1118 e1118" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> argument, because it will fail dynamically
            if the </textual><emphasis class="po-inline e1119 e1119" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> argument returns more than one node.
            This special-case scenario has meanwhile been tackled and been generalized for any
            situation and cardinality</textual><footnote class="po-popup e1120 e1120"><para class="po-block e1121 e1121"><textual class="po-textual">See the resolution to </textual><link class="po-inline e1122 e1122" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25185" xlink:show="new" xlink:type="simple"><textual class="po-textual">Public XSLT
                        Bug 25185</textual></link><textual class="po-textual"> on how crawling posture is now allowed in atomizing
                    contexts.</textual></para></footnote><textual class="po-textual">, which can also by applied to stylesheet function call arguments.</textual></para></section><section class="po-hcontainer e1123 e1123" xml:id="miscelleneous"><title class="po-block e1124 e1124"><textual class="po-textual">Miscelleneous</textual></title><section class="po-hcontainer e1125 e1125" xml:id="inline-functions"><title class="po-block e1126 e1126"><textual class="po-textual">Inline functions and streamability</textual></title><para class="po-block e1127 e1127"><textual class="po-textual">Inline functions are a new XPath 3.0 capability</textual><footnote class="po-popup e1128 e1128"><para class="po-block e1129 e1129"><textual class="po-textual">See section </textual><link class="po-inline e1130 e1130" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-inline-func" xlink:show="new" xlink:type="simple"><textual class="po-textual">3.1.7 Inline Function Expressions</textual></link><textual class="po-textual"> in the XPath 3.0
                        Recommendation.</textual></para></footnote><textual class="po-textual"> that allows you to write an anonymous function inside an XPath
                expression. The definition of inline function expressions prohibits referencing the
                context item, which makes it not directly possible to refer to the context. However,
                the closure of an inline function contains all local variable bindings, which makes
                it possible to refer to a variable outside of the inline function, which itself
                could be bound to a streamed node. The streamability rules for
                    </textual><code class="po-atom e1131 e1131"><textual class="po-textual">xsl:variable</textual></code><textual class="po-textual"> and </textual><code class="po-atom e1132 e1132"><textual class="po-textual">xsl:param</textual></code><textual class="po-textual"> prohibit referencing a
                streamed node, but one exception is inside a streamable stylesheet function, where
                it is possible to have a parameter bound to a streamed node.</textual></para><para class="po-block e1133 e1133"><textual class="po-textual">There are two solutions possible. One is to come up with complex rules for inline
                functions referencing the streamed parameter, the other is to simply prohibit using
                a streamed parameter inside an inline function body. This in itself would not be
                consistent with the definition in XPath, which states that all local variable
                bindings are available in the dynamic context of the inline function, which leads us
                to a third option: simply disallow inline function expressions within the body of a
                streamable stylesheet function.</textual></para><para class="po-block e1134 e1134"><textual class="po-textual">This third option would be in line with the current streamability rules for inline
                function declarations</textual><footnote class="po-popup e1135 e1135"><para class="po-block e1136 e1136"><textual class="po-textual">See section </textual><link class="po-inline e1137 e1137" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-inline-functions" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.14 Streamability of Inline Function Declarations</textual></link><textual class="po-textual"> in the
                        XSLT 3.0 Working Draft.</textual></para></footnote><textual class="po-textual">, which states that they are, by definition, </textual><emphasis class="po-inline e1138 e1138" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1139 e1139" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual">, simply
                because it is not possible to pass a streamed node into the closure of the inline
                function body.</textual></para></section><section class="po-hcontainer e1140 e1140" xml:id="partial-function-application"><title class="po-block e1141 e1141"><textual class="po-textual">Partial function application and streamability</textual></title><para class="po-block e1142 e1142"><textual class="po-textual">Partial function application is also a new XPath 3.0 capability by writing down a
                question mark as a placeholder for an argument</textual><footnote class="po-popup e1143 e1143"><para class="po-block e1144 e1144"><textual class="po-textual">See section </textual><link class="po-inline e1145 e1145" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#dt-partial-function-application" xlink:show="new" xlink:type="simple"><textual class="po-textual">3.1.5 Static Function Calls, definition for Partial Function
                            Application</textual></link><textual class="po-textual"> in the XPath 3.0 Recommendation.</textual></para></footnote><textual class="po-textual">, and apply the other arguments already. The result is a function item
                with less arguments than the original and some arguments already filled in. An
                example is the expression </textual><code class="po-atom e1146 e1146"><textual class="po-textual">index-of(?, ?, "http://my-collation")</textual></code><textual class="po-textual">, which
                returns a function item that presets the collation argument to
                    </textual><code class="po-atom e1147 e1147"><textual class="po-textual">http://my-collation</textual></code><textual class="po-textual">, resulting in a two-argument function that
                always uses the same collation.</textual></para><para class="po-block e1148 e1148"><textual class="po-textual">The current rules are under the rules on function calls</textual><footnote class="po-popup e1149 e1149"><para class="po-block e1150 e1150"><textual class="po-textual">See section </textual><link class="po-inline e1151 e1151" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-function-calls" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.12 Streamability of Function Calls</textual></link><textual class="po-textual"> in the XSLT 3.0
                        Working Draft.</textual></para></footnote><textual class="po-textual"> state that, unless the function is focus-dependent, that the </textual><emphasis class="po-inline e1152 e1152" role="ital"><textual class="po-textual">general streamability rules</textual></emphasis><textual class="po-textual"> apply, which means that it is
                treated as a normal function call, but the placeholder arguments are ignored.</textual></para><para class="po-block e1153 e1153"><textual class="po-textual">If we take into consideration that binding a streamed node to a variable and
                passing it around is prohibited, a similar rule should be applied to partial
                function application: if the function is a streamable stylesheet function, the
                argument that can take a streamed node, must be the placeholder, or a grounded node
                must be supplied, otherwise it would become a </textual><emphasis class="po-inline e1154 e1154" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1155 e1155" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">
                expression. </textual></para><para class="po-block e1156 e1156"><textual class="po-textual">In other words, partial function application works with user-defined streamable
                stylesheet functions, as long as you do not try to bind a streaming node from the
                current context to it. You should do that at a later stage, when you actually call
                the function.</textual></para></section><section class="po-hcontainer e1157 e1157" xml:id="function-references"><title class="po-block e1158 e1158"><textual class="po-textual">Named function references and streamability</textual></title><para class="po-block e1159 e1159"><textual class="po-textual">Named function references are another XPath 3.0 feature</textual><footnote class="po-popup e1160 e1160"><para class="po-block e1161 e1161"><textual class="po-textual">See section </textual><link class="po-inline e1162 e1162" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-named-function-ref" xlink:show="new" xlink:type="simple"><textual class="po-textual"> 3.1.6
                            Named Function References</textual></link><textual class="po-textual"> in the XPath 3.0 Recommendation.</textual></para></footnote><textual class="po-textual">: you can create a function item of an existing function by using the
                syntax </textual><code class="po-atom e1163 e1163"><textual class="po-textual">FunctionName#ArgCount</textual></code><textual class="po-textual">, where </textual><code class="po-atom e1164 e1164"><textual class="po-textual">ArgCount</textual></code><textual class="po-textual"> is a literal
                giving the arity of the function. For instance, </textual><code class="po-atom e1165 e1165"><textual class="po-textual">count#0</textual></code><textual class="po-textual"> will give a
                reference to the zero-argument function of </textual><code class="po-atom e1166 e1166"><textual class="po-textual">count</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e1167 e1167"><textual class="po-textual">my:filter#3</textual></code><textual class="po-textual"> will give a reference to a three-argument function
                    </textual><code class="po-atom e1168 e1168"><textual class="po-textual">my:filter</textual></code><textual class="po-textual">. </textual></para><para class="po-block e1169 e1169"><textual class="po-textual">The function item returned by such an expression can be called as a normal
                function by applying parentheses and arguments, which in turn will call the function
                you referred to to begin with. In practice, this syntax is useful for binding
                variables to existing named functions.</textual></para><para class="po-block e1170 e1170"><textual class="po-textual">Creating a named function reference is an atomic action and does not involve
                references to nodes. As a result, a named function reference itself is always
                grounded. There is one exception, if you try to create a reference to a function
                that is focus-dependent. In such cases, just like in previous rules, the result is
                    </textual><emphasis class="po-inline e1171 e1171" role="ital"><textual class="po-textual">roaming</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1172 e1172" role="ital"><textual class="po-textual">free-ranging</textual></emphasis><textual class="po-textual">. This is in fact the current rule for streamability of
                named function references in the specification</textual><footnote class="po-popup e1173 e1173"><para class="po-block e1174 e1174"><textual class="po-textual">See section </textual><link class="po-inline e1175 e1175" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-named-function-ref" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.13 Streamability of Named Function References</textual></link><textual class="po-textual"> in the XSLT
                        3.0 Working Draft.</textual></para></footnote><textual class="po-textual">.</textual></para><para class="po-block e1176 e1176"><textual class="po-textual">Since stylesheet functions by definition cannot be focus-dependent, this exception
                does not apply to named function references that refer to a (streamable) stylesheet
                function.</textual></para></section><section class="po-hcontainer e1177 e1177" xml:id="dynamic-function-calls"><title class="po-block e1178 e1178"><textual class="po-textual">Dynamic function calls and streamability</textual></title><para class="po-block e1179 e1179"><textual class="po-textual">A dynamic function call, also a new XPath 3.0 feature</textual><footnote class="po-popup e1180 e1180"><para class="po-block e1181 e1181"><textual class="po-textual">See section </textual><link class="po-inline e1182 e1182" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-dynamic-function-invocation" xlink:show="new" xlink:type="simple"><textual class="po-textual">3.2.2 Dynamic Function Call</textual></link><textual class="po-textual"> in the XPath 3.0
                        Recommendation.</textual></para></footnote><textual class="po-textual">, is a call to a function item that is bound to a variable. Suppose you
                have </textual><code class="po-atom e1183 e1183"><textual class="po-textual">&lt;xsl:variable name="fref" select=" 'name#1' " /&gt;</textual></code><textual class="po-textual">, which binds
                the one-argument version of the name-function to </textual><code class="po-atom e1184 e1184"><textual class="po-textual">$fref</textual></code><textual class="po-textual">, then you can
                call that function by adding parentheses and arguments, the same way you would have
                done if the variable were the actual function:
                </textual><code class="po-atom e1185 e1185"><textual class="po-textual">$fref(child::*[1])</textual></code><textual class="po-textual">.</textual></para><para class="po-block e1186 e1186"><textual class="po-textual">Since it is not possible to know at runtime what function the variable is bound
                to, analysis can only take place once the function is actually called. The current rules</textual><footnote class="po-popup e1187 e1187"><para class="po-block e1188 e1188"><textual class="po-textual">See section </textual><link class="po-inline e1189 e1189" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-dynamic-function-calls" xlink:show="new" xlink:type="simple"><textual class="po-textual">19.8.7.9 Streamability of Dynamic Function Calls</textual></link><textual class="po-textual"> in the XSLT 3.0
                        Working Draft.</textual></para></footnote><textual class="po-textual"> state that all arguments have operand usage </textual><emphasis class="po-inline e1190 e1190" role="ital"><textual class="po-textual">navigation</textual></emphasis><textual class="po-textual">, which means that you can only call a dynamic function
                when you actually create a </textual><emphasis class="po-inline e1191 e1191" role="ital"><textual class="po-textual">grounded</textual></emphasis><textual class="po-textual"> copy of a
                streamed node. In case you wanted to apply it to a streamed node you are out of
                luck.</textual></para><para class="po-block e1192 e1192"><textual class="po-textual">The rules make an exception in case the signature of the function item is known,
                in which case </textual><emphasis class="po-inline e1193 e1193" role="ital"><textual class="po-textual">type-determined usage</textual></emphasis><textual class="po-textual">, as in part
                explained in </textual><xref class="po-milestone e1194 e1194" linkend="type-determined"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, can be used. That means that, if an
                argument is declared as a non-node type, the usage typically becomes </textual><emphasis class="po-inline e1195 e1195" role="ital"><textual class="po-textual">absorption</textual></emphasis><textual class="po-textual">.</textual></para></section></section><section class="po-hcontainer e1196 e1196" xml:id="specification-status"><title class="po-block e1197 e1197"><textual class="po-textual">Streamability of stylesheet functions according to the specification</textual></title><para class="po-block e1198 e1198"><textual class="po-textual">The current approach taken by the rules in </textual><link class="po-inline e1199 e1199" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple"><textual class="po-textual">Bug 25679</textual></link><textual class="po-textual"> is a
            pessimistic one. For stylesheet functions to return nodes, they must be </textual><emphasis class="po-inline e1200 e1200" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> and are allowed to be either </textual><emphasis class="po-inline e1201 e1201" role="ital"><textual class="po-textual">motionless</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1202 e1202" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">. As a further
            limitation, which actually follows from forcing the </textual><emphasis class="po-inline e1203 e1203" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> posture on function bodies, is that the argument to the
            function must itself also be </textual><emphasis class="po-inline e1204 e1204" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual">. In fact, it is
            not possible, by the current definition, to have a streamed node with </textual><emphasis class="po-inline e1205 e1205" role="ital"><textual class="po-textual">crawling</textual></emphasis><textual class="po-textual"> or </textual><emphasis class="po-inline e1206 e1206" role="ital"><textual class="po-textual">climbing</textual></emphasis><textual class="po-textual"> posture
            act as an argument to a streamable stylesheet function.</textual></para><para class="po-block e1207 e1207"><textual class="po-textual">By limiting the result posture of the stylesheet function to one allowed posture, it
            is easier to write rules for both analyzable and non-analyzable stylesheet functions,
            see </textual><xref class="po-milestone e1208 e1208" linkend="analyzable"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. However, because the bug entry is quite fresh and the
            discussion is still ongoing, there is little conclusive I can tell about the rules that
            will eventually make it into the next public version of the specification</textual><footnote class="po-popup e1209 e1209"><para class="po-block e1210 e1210"><textual class="po-textual">The next version will probably be a </textual><emphasis class="po-inline e1211 e1211" role="ital"><textual class="po-textual">Candidate
                        Recommendation</textual></emphasis><textual class="po-textual">, considering that the current status is </textual><emphasis class="po-inline e1212 e1212" role="ital"><textual class="po-textual">Last Call Working Draft</textual></emphasis><textual class="po-textual">, meaning that the
                    specification is ready for implementors and only bugs found that come from
                    implementation issues will be fixed. No new features will be added.</textual></para></footnote><textual class="po-textual">. For instance, in </textual><link class="po-inline e1213 e1213" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679#c1" xlink:show="new" xlink:type="simple"><textual class="po-textual">Comment#1</textual></link><textual class="po-textual">
            of the same public bug entry I have proposed some of the rules from </textual><xref class="po-milestone e1214 e1214" linkend="posture-sweep-table"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Whether or not any or all of these suggestions will
            make it into the specification will remain to be seen.</textual></para><para class="po-block e1215 e1215"><textual class="po-textual">Even if the specification will only allow relatively pessimistic stylesheet functions,
            vendors are still allowed to use wider rules on streamability. In the case of functions,
                </textual><link class="po-inline e1216 e1216" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Exselt</textual></link><textual class="po-textual"> will allow any function that is streamable, as explained
            in the previous section, by using an optimistic operational mode at user option.</textual></para><section class="po-hcontainer e1217 e1217"><title class="po-block e1218 e1218"><textual class="po-textual">The </textual><code class="po-atom e1219 e1219"><textual class="po-textual">streamable</textual></code><textual class="po-textual"> attribute on </textual><code class="po-atom e1220 e1220"><textual class="po-textual">xsl:function</textual></code></title><para class="po-block e1221 e1221"><textual class="po-textual">In none of the previous sections in this paper have I mentioned the
                    </textual><code class="po-atom e1222 e1222"><textual class="po-textual">streamable</textual></code><textual class="po-textual"> attribute on an </textual><code class="po-atom e1223 e1223"><textual class="po-textual">xsl:function</textual></code><textual class="po-textual"> declaration.
                Since most of the paper discussed streamability of a stylesheet function in the
                context of the function call, whether or not a function is streamable then depends
                on its implementation and there is no need for the processor to know beforehand what
                functions to analyze and what not.</textual></para><para class="po-block e1224 e1224"><textual class="po-textual">The streamability rules in the specification are made such that the processor must
                statically determine whether or not a function declaration is streamable or not.
                Since it is likely that any given stylesheet will have both streamable and
                non-streamable stylesheet functions, it is necessary to tell the processor which are
                and which are not streamable. For that, the </textual><code class="po-atom e1225 e1225"><textual class="po-textual">xsl:function</textual></code><textual class="po-textual"> declaration
                gets a new attribute, similar to the attribute of </textual><code class="po-atom e1226 e1226"><textual class="po-textual">xsl:accumulator</textual></code><textual class="po-textual"> and
                    </textual><code class="po-atom e1227 e1227"><textual class="po-textual">xsl:mode</textual></code><textual class="po-textual">, which determines whether or not a function should be
                analyzed for streamability.</textual></para><para class="po-block e1228 e1228"><textual class="po-textual">The attribute takes a value of </textual><code class="po-atom e1229 e1229"><textual class="po-textual">yes</textual></code><textual class="po-textual"> or </textual><code class="po-atom e1230 e1230"><textual class="po-textual">no</textual></code><textual class="po-textual">. If the value
                is </textual><code class="po-atom e1231 e1231"><textual class="po-textual">yes</textual></code><textual class="po-textual">, then the function must be </textual><emphasis class="po-inline e1232 e1232" role="ital"><textual class="po-textual">guaranteed
                    streamable</textual></emphasis><textual class="po-textual"> and the function can be called with a streamable node as
                an argument.</textual></para><para class="po-block e1233 e1233"><textual class="po-textual">I think that such an attribute is not necessary if we take the approach in this
                paper and analyze the entire function only upon the actual function call. If that
                function call is inside a streamable context and a streamable node is passed as an
                argument, the body of the function is analyzed with the context posture of the
                streamable argument set as the posture of the streamable parameter reference.</textual></para></section></section><section class="po-hcontainer e1234 e1234" xml:id="status-processors"><title class="po-block e1235 e1235"><textual class="po-textual">Status of current processors with respect to streamable stylesheet functions</textual></title><para class="po-block e1236 e1236"><textual class="po-textual">Since streamable stylesheet functions are a relative recent addition to the
            specification and lots of it is not yet publicly available, there are currently no
            processors available that fully support streamable stylesheet functions.</textual></para><para class="po-block e1237 e1237"><textual class="po-textual">At the time of this writing, of the two streaming processors that I know of, </textual><link class="po-inline e1238 e1238" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Exselt</textual></link><textual class="po-textual"> and </textual><link class="po-inline e1239 e1239" xlink:actuate="onRequest" xlink:href="http://saxonica.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">Saxon</textual></link><textual class="po-textual">, the former currently has a full streamability analysis for all
            constructs but a limited ability to analyze stylesheet functions for streamability.
            However, the available set of tests is still growing and the rules on streamability may
            change between now and the actual presentation of this paper, or even afterwards, since
            the specification is not final yet and work on streamable stylesheet functions may
            change the current rules. Apart from analyzing a function for streamability, Exselt
            chooses an optimistic streaming approach: if you write your stylesheet in a correct way
            with forward expressions only, your stylesheet will process streaming input in a
            streamable way.</textual></para><para class="po-block e1240 e1240"><textual class="po-textual">For Saxon, I do not know the actual current status on streamable stylesheet functions,
            but I do know that they plan to do it in the not-so-far future.</textual></para><para class="po-block e1241 e1241"><textual class="po-textual">If you are interested in streaming, or more specifically in streamable stylesheet
            functions, keep an eye out on the website of Exselt and Saxon as it is likely that in
            the near future, both processors will support this feature.</textual></para></section><section class="po-hcontainer e1242 e1242" xml:id="conclusion"><title class="po-block e1243 e1243"><textual class="po-textual">Conclusion</textual></title><para class="po-block e1244 e1244"><textual class="po-textual">The previous sections have shown that writing streamable stylesheet functions is not
            that hard, as long as you do not require recursion, or want to write overridable
            non-final functions. But if you do require recursion, the simplest rule to remember is
                </textual><emphasis class="po-inline e1245 e1245" role="ital"><textual class="po-textual">same posture in, same posture out</textual></emphasis><textual class="po-textual">. As long as you
            stick to that rule, and forget about the exceptional cases, you are in safe streaming
            waters.</textual></para><para class="po-block e1246 e1246"><textual class="po-textual">We have also seen that the current resolution in the specification taken to allow
            streamable stylesheet functions is far more limiting, allowing only a posture of
                </textual><emphasis class="po-inline e1247 e1247" role="ital"><textual class="po-textual">striding</textual></emphasis><textual class="po-textual"> for the input arguments and in the case of
            recursive functions or non-final functions, always concludes that a call to such a
            function is </textual><emphasis class="po-inline e1248 e1248" role="ital"><textual class="po-textual">consuming</textual></emphasis><textual class="po-textual">, even if it is not. This
            conservative approach has a valid reason, though: it tries to keep things simple and the
            rules understandable and implementable. But even with this limitations in mind, it gives
            stylesheet authors quite a wide range of possibilities to write streamable stylesheet
            functions.</textual></para><para class="po-block e1249 e1249"><textual class="po-textual">This paper has shown how a relative small change to the specification opens up the way
            for stylesheet and library package writers to write streamable stylesheet functions,
            which can be used in both streamable and non-streamable scenarios alike</textual><footnote class="po-popup e1250 e1250"><para class="po-block e1251 e1251"><textual class="po-textual">Any streamable construct will work exactly the same in a non-streaming
                    scenario. Functions or modes written with streaming in mind can be used with
                    both streaming and non-streaming input without alterations.</textual></para></footnote><textual class="po-textual">. This change was an important and vital one and has brought us very close to
            making the streamability rules as mature as they can be and ready for widespread use in
            stylesheets and packages. Hopefully this paper has given potential library writers a
            strong hint that they should take the extra step to write their library packages with
            streamability in mind to be useful for both the streaming and non-streaming
            markets.</textual></para></section><bibliography class="po-hcontainer e1252 e1252"><title class="po-block e1253 e1253"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e1254 e1254" xml:id="Braaksma13" xreflabel="Braaksma 2013"><textual class="po-textual">
            Braaksma, Abel. </textual><quote class="po-inline e1255 e1255"><textual class="po-textual">Efficient XML processing with XSLT 3.0 and higher order functions</textual></quote><textual class="po-textual">: pp 23-40.
            Presented at </textual><emphasis class="po-inline e1256 e1256" role="ital"><textual class="po-textual">XML Prague 2013, a conference on markup languages and data on the web</textual></emphasis><textual class="po-textual">, Prague, Czechia, Feb 8-10, 2013. 
            In XML Prague Proceedings 2013.
            </textual><link class="po-inline e1257 e1257" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2013/files/xmlprague-2013-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://archive.xmlprague.cz/2013/files/xmlprague-2013-proceedings.pdf</textual></link><textual class="po-textual">.
            Web.            
        </textual></bibliomixed><bibliomixed class="po-block e1258 e1258" xml:id="Braaksma14a" xreflabel="Braaksma 2014a"><textual class="po-textual">
            Braaksma, Abel. 
            </textual><quote class="po-inline e1259 e1259"><textual class="po-textual">Streaming for the masses, an introduction to streaming with XSLT</textual></quote><textual class="po-textual">: pp 29-80.
            Presented at </textual><emphasis class="po-inline e1260 e1260" role="ital"><textual class="po-textual">XML Prague 2014, a conference on markup languages and data on the web</textual></emphasis><textual class="po-textual">, Prague, Czechia, Feb 14-16, 2014. 
            In XML Prague Proceedings 2014.
            </textual><link class="po-inline e1261 e1261" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1262 e1262" xml:id="Braaksma14b" xreflabel="Braaksma 2014b"><textual class="po-textual">Braaksma, Abel. 
            </textual><quote class="po-inline e1263 e1263"><textual class="po-textual">Streaming Design Patterns or: How I Learned to Stop Worrying and Love the
                Stream</textual></quote><textual class="po-textual">: pp 24-53.
            Presented at </textual><emphasis class="po-inline e1264 e1264" role="ital"><textual class="po-textual">XML Prague 2014, a conference on markup languages and data on the web</textual></emphasis><textual class="po-textual">, Prague, Czechia, Feb 14-16, 2014. 
            In XML Prague Proceedings 2014.
            </textual><link class="po-inline e1265 e1265" xlink:actuate="onRequest" xlink:href="http://xmllondon.com/2014/xmllondon-2014-proceedings.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xmllondon.com/2014/xmllondon-2014-proceedings.pdf</textual></link><textual class="po-textual">.
            Web. doi:</textual><biblioid class="po-atom e1266 doi e1266"><textual class="po-textual">10.14337/xmllondon14.braaksma01</textual></biblioid><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e1267 e1267" xml:id="Grust13" xreflabel="Grust 2013"><textual class="po-textual">
            Grust, Torsten and Ulrich, Alexander.
            </textual><quote class="po-inline e1268 e1268"><textual class="po-textual">First-Class Functions for First-Order Database Engines</textual></quote><textual class="po-textual">
            Presented at </textual><emphasis class="po-inline e1269 e1269" role="ital"><textual class="po-textual">International Symposium on Database Programming Languages</textual></emphasis><textual class="po-textual">.
            In Proceedings of the 14th International Symposium on Database Programming Languages (DBPL 2013), Trento, Italy.
            arXiv:1308.0158: 
            </textual><link class="po-inline e1270 e1270" xlink:actuate="onRequest" xlink:href="http://arxiv.org/pdf/1308.0158v1" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://arxiv.org/pdf/1308.0158v1</textual></link><textual class="po-textual">.
        </textual></bibliomixed><bibliomixed class="po-block e1271 e1271" xml:id="FuncOpRec" xreflabel="XPath and XQuery F&amp;O 3.0"><textual class="po-textual">
            Kay, Michael.
            </textual><quote class="po-inline e1272 e1272"><textual class="po-textual">XPath and XQuery Functions and Operators 3.0 Recommendation</textual></quote><textual class="po-textual">
            8 April 2014. W3 Consortium. W3C Recommendation.
            </textual><link class="po-inline e1273 e1273" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-functions-30/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1274 e1274" xml:id="Gerstbach06" xreflabel="Gerstbach 2006"><textual class="po-textual">
            Gerstbach, Peter.
            </textual><quote class="po-inline e1275 e1275"><textual class="po-textual">Generating Structured Documents to Create Reports by Integrating Data from CMS/DMS and EAI Systems</textual></quote><textual class="po-textual">: pp 27-28.
            Master thesis. At: Softwaretechnik und Interaktive Systeme der Technischen Universit¨at Wien. May 2006.
            </textual><link class="po-inline e1276 e1276" xlink:actuate="onRequest" xlink:href="http://www.gerstbach.at/2006/thesis/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.gerstbach.at/2006/thesis/</textual></link><textual class="po-textual">. Web.
        </textual></bibliomixed><bibliomixed class="po-block e1277 e1277" xml:id="Kay08" xreflabel="Kay 2008"><textual class="po-textual">
            Kay, Michael.
            </textual><quote class="po-inline e1278 e1278"><textual class="po-textual">XSLT 2.0 and XPath 2.0 Programmer's Reference</textual></quote><textual class="po-textual">
            2nd edition, 5 May 2008: pp 251+. Published by O'Reilly Media. ISBN: 0470192747. Print.
        </textual></bibliomixed><bibliomixed class="po-block e1279 e1279" xml:id="Lenz05" xreflabel="Lenz 2005"><textual class="po-textual">
            Lenz, Evan.
            </textual><quote class="po-inline e1280 e1280"><textual class="po-textual">XSLT 1.0 Pocket Reference (Pocket Reference)</textual></quote><textual class="po-textual">.
            1st edition, 19 August 2005: pp 23-40. Published by O'Reilly Media. ISBN: 0596100086. 
            Chapter 3 (pages 23-40) is available online: </textual><link class="po-inline e1281 e1281" xlink:actuate="onRequest" xlink:href="http://lenzconsulting.com/how-xslt-works/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://lenzconsulting.com/how-xslt-works/</textual></link><textual class="po-textual">.
            Print.
        </textual></bibliomixed><bibliomixed class="po-block e1282 e1282" xml:id="Mangano05" xreflabel="Mangano 2005"><textual class="po-textual">
            Mangano, San.
            </textual><quote class="po-inline e1283 e1283"><textual class="po-textual">XSLT Cookbook, 2nd Edition, Solutions and Examples for XML and XSLT Developers</textual></quote><textual class="po-textual">
            2nd edition, 21 December 2005: pp 686-732. Published by O'Reilly Media. ISBN: 0596009747.
            Print.            
        </textual></bibliomixed><bibliomixed class="po-block e1284 e1284" xml:id="Novatchev01" xreflabel="Novatchev 2001"><textual class="po-textual">
            Novatchev, Dimitre.
            </textual><quote class="po-inline e1285 e1285"><textual class="po-textual">The Functional Programming Language XSLT — A proof through examples</textual></quote><textual class="po-textual">
            November 2001.
            Seen at: </textual><emphasis class="po-inline e1286 e1286" role="ital"><textual class="po-textual">Sommer Semester 2010 course material University of Magdeburg 2010</textual></emphasis><textual class="po-textual">
            </textual><link class="po-inline e1287 e1287" xlink:actuate="onRequest" xlink:href="http://edu.cs.uni-magdeburg.de/EC/lehre/sommersemester-2010/funktionale-programmierung/uebungen/gruppe-2/aufgabenblatt-12/XSLTasFP.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://edu.cs.uni-magdeburg.de/EC/lehre/sommersemester-2010/funktionale-programmierung/uebungen/gruppe-2/aufgabenblatt-12/XSLTasFP.pdf</textual></link><textual class="po-textual">.
            Online reference: </textual><link class="po-inline e1288 e1288" xlink:actuate="onRequest" xlink:href="http://fxsl.sourceforge.net/articles/FuncProg/Functional%20Programming.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                http://fxsl.sourceforge.net/articles/FuncProg/Functional%20Programming.html</textual></link><textual class="po-textual">. Print.
        </textual></bibliomixed><bibliomixed class="po-block e1289 e1289" xml:id="Tennison01" xreflabel="Tennison 2001"><textual class="po-textual">
            Tennison, Jeni.
            </textual><quote class="po-inline e1290 e1290"><textual class="po-textual">Rescuing XSLT from Niche Status.</textual></quote><textual class="po-textual">.
            17 February 2001.
            MulberryTech XSL Mailing List Archive. </textual><link class="po-inline e1291 e1291" xlink:actuate="onRequest" xlink:href="http://www.biglist.com/lists/xsl-list/archives/200102/msg01143.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">
                http://www.biglist.com/lists/xsl-list/archives/200102/msg01143.html</textual></link><textual class="po-textual">. Web.
        </textual></bibliomixed><bibliomixed class="po-block e1292 e1292" xml:id="W3cBugzilla" xreflabel="W3C BugZilla"><textual class="po-textual">
            Various contributors.
            </textual><quote class="po-inline e1293 e1293"><textual class="po-textual">Bugzilla - Public W3C Bug / Issue tracking system</textual></quote><textual class="po-textual">
            1997 - 2014. W3 Consortium.
            </textual><link class="po-inline e1294 e1294" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://www.w3.org/Bugs/Public/</textual></link><textual class="po-textual">. 
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1295 e1295" xml:id="Welker08" xreflabel="Welker 2008"><textual class="po-textual">
            Welker, Eddie.
            </textual><quote class="po-inline e1296 e1296"><textual class="po-textual">Advantages of push-style XSLT over pull-style</textual></quote><textual class="po-textual">
            25 November 2008. 
            </textual><link class="po-inline e1297 e1297" xlink:actuate="onRequest" xlink:href="http://www.eddiewelker.com/2008/11/25/push-style-xslt-vs-pull-style/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.eddiewelker.com/2008/11/25/push-style-xslt-vs-pull-style/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1298 e1298" xml:id="XdmRec" xreflabel="XQuery and XPath Data Model 3.0"><textual class="po-textual">
            Walsh, Norman; Berglund, Anders; Snelson, John.
            </textual><quote class="po-inline e1299 e1299"><textual class="po-textual">XQuery and XPath Data Model 3.0 Recommendation</textual></quote><textual class="po-textual">
            8 April 2014. W3 Consortium. W3C Recommendation.
            </textual><link class="po-inline e1300 e1300" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1301 e1301" xml:id="XPathRec" xreflabel="XPath 3.0"><textual class="po-textual">
            Robie, Jonathan; Chamberlin, Don; Dyck, Michael; Snelson, John.
            </textual><quote class="po-inline e1302 e1302"><textual class="po-textual">XML Path Language (XPath) 3.0 Recommendation</textual></quote><textual class="po-textual">
            8 April 2014. W3 Consortium. W3C Recommendation.
            </textual><link class="po-inline e1303 e1303" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-30/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1304 e1304" xml:id="XProc" xreflabel="XProc"><textual class="po-textual">
            Walsh, Norman; Milowski, Alex; Thompson, Henry S.
            </textual><quote class="po-inline e1305 e1305"><textual class="po-textual">XProc: An XML Pipeline Language</textual></quote><textual class="po-textual">
            11 May 2010. W3 Consortium. W3C Recommendation.
            </textual><link class="po-inline e1306 e1306" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xproc/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xproc/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1307 e1307" xml:id="Xslt30Latest" xreflabel="XSLT Latest Version"><textual class="po-textual">
            Kay, Michael.
            </textual><quote class="po-inline e1308 e1308"><textual class="po-textual">XSL Transformations (XSLT) Version 3.0, Latest Version</textual></quote><textual class="po-textual">
            Undated. W3 Consortium. W3C Working Draft / Last Call Working Draft / Candidate Recommendation / Proposed Recommendation / Recommendation.
            </textual><link class="po-inline e1309 e1309" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt-30/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed><bibliomixed class="po-block e1310 e1310" xml:id="XsltLastCall" xreflabel="XSLT Last Call WD"><textual class="po-textual">
            Kay, Michael.
            </textual><quote class="po-inline e1311 e1311"><textual class="po-textual">XSL Transformations (XSLT) Version 3.0 W3C Last Call Working Draft</textual></quote><textual class="po-textual">
            12 December 2013. W3 Consortium. Last Call Working Draft.
            </textual><link class="po-inline e1312 e1312" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2013/WD-xslt-30-20130201/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2013/WD-xslt-30-20130201/</textual></link><textual class="po-textual">.
            Web.
        </textual></bibliomixed></bibliography></article></classedDocument>