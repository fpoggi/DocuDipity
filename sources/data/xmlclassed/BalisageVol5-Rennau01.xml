<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Java Integration of XQuery - an Information Unit-Oriented Approach</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">An infrastructure for integrating XQuery into Java systems is described. 
        The infrastructure comprises a new API (XQJPLUS, built on the standard API XQJ) 
        and a tool for Java code generation. The basic idea of the approach is to deliver query 
        results not in terms of query result items, but in terms of “information units”,
        ready-to-use entities assembled from the result items. The assembly process is guided by control 
        information embedded into the query result, so that the query controls exactly 
        what will be delivered, and in which form. Information units can represent 
        information in a great variety of forms, including many map types and 
        custom objects. The information units produced by a query are collected into 
        a special container ("info tray") which offers name-based, intuitive access
        to the units. The query-specific structure of an info tray may be formally defined 
        by a tray schema from which an "info shape" can be generated, a Java class representing 
        a specific kind of info tray and offering compiler checked data access. 
        Info trays also support data integration, as their possibly
        very heterogeneous contents can be addressed in a uniform way, using path-like
        expressions.
      </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Hans-Jürgen</textual></firstname><othername class="po-field e11 e11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></othername><surname class="po-field e12 e12"><textual class="po-textual">Rennau</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior programmer</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">bits - Büro für Informations-Technologie und Software GmbH</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">rennau@bits-ac.com</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Copyright © 2010 by the author.  Used with
permission.</textual></para></legalnotice><keywordset class="po-table e21 e21" role="author"><keyword class="po-field e22 e22"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">Java</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XQJ</textual></keyword></keywordset></info><section class="po-hcontainer e25 e25" xml:id="Introduction"><title class="po-block e26 e26"><textual class="po-textual">Introduction</textual></title><para class="po-block e27 e27"><textual class="po-textual">
      To model information as XML offers remarkable advantages: the information is itemized in a way 
      that endows each item with a name and an identity; each item has a context which in turn can be 
      identified; and all items are exposed to navigation and querying.
    </textual></para><para class="po-block e28 e28"><textual class="po-textual">
      These gains are not limited to the scope of single documents – they scale globally, 
      thanks to the concepts of document URIs and namespaces. Using these concepts together 
      makes it possible to fuse the total set of accessible XML resources into one single, 
      homogeneous information space, within which document borders are crossed by single 
      steps. Those resources need not store the data as XML: it suffices to 
      </textual><emphasis class="po-inline e29 e29" role="ital"><textual class="po-textual">expose</textual></emphasis><textual class="po-textual"> them as XML, e.g. creating XML documents on the 
      fly and supporting an XPath or XQuery interface. Relational databases, comma-delimited 
      files and web services are all examples of resources which can be exposed as XML.
    </textual></para><para class="po-block e30 e30"><textual class="po-textual">
      XQuery </textual><xref class="po-milestone e31 e31" linkend="W3C-XQuery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is a language designed to live in and work with
      this XML-based information space. 
      Many tasks of information processing can be handled by XQuery with amazing conciseness
      and simplicity. Much software could delegate certain information processing tasks
      to XQuery, thus using XQuery in a similar way to a client delegating processing tasks to a 
      server. This integration is helped by the fact that XQuery is not constrained to 
      produce XML. XQuery generates instances of the XDM data model, which means it can 
      produce heterogeneous sequences of nodes and atomic values. So XQuery can deliver 
      what is needed by its “clients” in a fine-tuned way.
    </textual></para><para class="po-block e32 e32"><textual class="po-textual">
      Object-oriented programs are among those that can benefit from using XQuery. In the case of
      Java programs, this possibility is made more attractive by the existence of a standardized
      XQuery API – the XQJ </textual><xref class="po-milestone e33 e33" linkend="JSR-XQJ"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. 
      This API fully supports the fine-grained data exchange between the languages required 
      to let XQuery deliver exactly what is needed - for example a sequence of numbers, and 
      only that.
    </textual></para><para class="po-block e34 e34"><textual class="po-textual">
      Imagine a Java application that must process large and complex XML resources. 
      Assume a message describes an approaching freight train, and the message must serve as 
      the data source for many kinds of information, like arrival times, properties and 
      quantities of goods, numbers and technical details of wagons, etc. Efficiency is highest
      and complexity is lowest if we let XQuery perform the largest possible chunks 
      of processing, producing many of those “partial” results in a single pass.
    </textual></para><para class="po-block e35 e35"><textual class="po-textual">
      The XQJ makes this possible in principle. It is very easy – although very tedious – 
      to write the required Java code, using as input the XQuery result and producing as 
      output the various objects desired (for instance documents, string collections, 
      string-to-string maps, string-to-node maps, Properties objects, …). The code would 
      iterate over the result items and handle them in accordance with their item type and the 
      position in the result stream. (Yes, some agreement between Java developer and query 
      author would be necessary in order to guide these decisions – e.g. “first the strings 
      of code list #1, then an agreed upon separator element, then the terms of code list #2, 
      then a separator, then alternating document names and document nodes”.)
    </textual></para><para class="po-block e36 e36"><textual class="po-textual">
      In principle it is very easy, but it is very tedious, and it is extremely brittle: the 
      slightest change in the query result – for example, a change in the sequence 
      of the XML documents or code lists – will likely break the Java code. This breaking 
      might easily go unnoticed, as the Java method might still produce sets and a map, 
      only with incorrect content.
    </textual></para><para class="po-block e37 e37"><textual class="po-textual">
      It's clear that the option to let the query produce complex multi-item results is 
      problematic as long as there is no new channel opened through which the query author can 
      push his intent clearly and explicitly “up” into the Java layer, structuring and associating 
      content with meaning, as he would do within an XML document. This paper describes a new API, 
      XQJPLUS, that addresses the issue of how XQuery can deliver structured, self-describing results 
      in a secure and efficient way. Key aspects will be the simplicity, robustness and safety of 
      the Java code, as well as the new responsibilities of the query code.
    </textual></para></section><section class="po-hcontainer e38 e38"><title class="po-block e39 e39"><textual class="po-textual">Conceptual framework</textual></title><para class="po-block e40 e40"><textual class="po-textual">
      XML models information in terms of the Infoset and information items </textual><xref class="po-milestone e41 e41" linkend="W3C-Infoset"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. 
      XPath 2.0 extends the model and defines the XDM </textual><xref class="po-milestone e42 e42" linkend="W3C-XDM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 
      a model expressing information as a sequence of items which are nodes and/or atomic values.
    </textual></para><para class="po-block e43 e43"><textual class="po-textual">
      The XDM is an achievement that can hardly be overestimated. It allows for representing all kinds 
      of commonly used information in a unified, platform-independent way. However, 
      computer programs are written in program languages, most of which cannot express XDM values 
      directly. Therefore, XDM-supplied information must be “translated” into items of the computer language's 
      internal data model. In Java, for example, the standard API for XQuery (XQJ) translates XDM items 
      into a set of Java data items like primitive type items and objects of various types like 
      String, Integer, QName, Element, etc. 
    </textual></para><para class="po-block e44 e44"><textual class="po-textual">
      XQuery programs produce a sequence of XDM items. Integration of XQuery into other languages 
      should translate the items one-to-one into language-native data items – which 
      is what XQJ accomplishes. So far, so good. But is this enough?
    </textual></para><para class="po-block e45 e45"><textual class="po-textual">      
      </textual><emphasis class="po-inline e46 e46" role="ital"><emphasis class="po-inline e47 e47" role="bold"><textual class="po-textual">Information units</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e48 e48"><textual class="po-textual">
      Information </textual><emphasis class="po-inline e49 e49" role="ital"><textual class="po-textual">items</textual></emphasis><textual class="po-textual"> are not necessarily the desired 
      </textual><emphasis class="po-inline e50 e50" role="bold"><textual class="po-textual">information units</textual></emphasis><textual class="po-textual">. For instance, the unit actually 
      wanted might be an array of strings, or a string-to-string map, a string-to-node map, 
      a Properties object etc. Any language not based on the XDM itself will use units 
      of information which are not an unambiguous one-to-one mapping of an XDM item type, 
      but correspond to an aggregation or transformation of itemized information. In 
      this sense, every computer language can be regarded as a specific information platform 
      with its own set of information unit types.
    </textual></para><para class="po-block e51 e51"><textual class="po-textual">      
      </textual><emphasis class="po-inline e52 e52" role="ital"><emphasis class="po-inline e53 e53" role="bold"><textual class="po-textual">XQuery integration based on information units</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e54 e54"><textual class="po-textual">
      To maximize the benefits of XQuery integration, the assembly of information items 
      into commonly used information units should not be left to individual applications, 
      as this would amount to frequent reinvention of the wheel or, worse, cause unwillingness 
      to integrate XQuery at all. An alternative would be an </textual><emphasis class="po-inline e55 e55" role="bold"><textual class="po-textual">information 
      unit-oriented API.</textual></emphasis><textual class="po-textual"> This API should be able to deliver useful information 
      units like string-to-string maps, implementing their assembly from query result items 
      behind the API’s façade. But before attempting to design the assembly and retrieval of 
      information units, the information content of such units should be modeled.    
    </textual></para><para class="po-block e56 e56"><textual class="po-textual">      
      </textual><emphasis class="po-inline e57 e57" role="ital"><emphasis class="po-inline e58 e58" role="bold"><textual class="po-textual">Information unit: properties</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e59 e59"><textual class="po-textual">
      An information unit contains information, but what properties does it have beside that? 
      How about a name and meta data, how should the unit type be modeled? A good starting point is to model 
      information units as components with properties.    
    </textual></para><para class="po-block e60 e60"><textual class="po-textual">      
      </textual><emphasis class="po-inline e61 e61" role="ital"><emphasis class="po-inline e62 e62" role="bold"><textual class="po-textual">Information unit: assembly</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e63 e63"><textual class="po-textual">
      Information units are not necessarily one-to-one mappings of the XDM items. In particular,
      they may represent aggregations and transformations of XDM items. How are these items
      assembled into information units? Probably the 
      most general and flexible way is to apply the concept of “markup” to result sequences: 
      the XQuery result augments the target information with meta information controlling the 
      unit assembly.   
    </textual></para><para class="po-block e64 e64"><textual class="po-textual">      
      </textual><emphasis class="po-inline e65 e65" role="ital"><emphasis class="po-inline e66 e66" role="bold"><textual class="po-textual">Information unit: access via information tray</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e67 e67"><textual class="po-textual">
      XML exposes the information items as members of an Infoset, that is, as parts of a tree. 
      What should be the structural unit that contains a number of information units? The 
      approach described in this paper introduces the concept of an “information tray” 
      (</textual><emphasis class="po-inline e68 e68" role="bold"><textual class="po-textual">info tray</textual></emphasis><textual class="po-textual">, for short) which is a generic collection 
      of information units, offering name-based access to information units as well as the 
      possibility to expose them as nested structures. The word “tray” is meant to combine 
      the idea of “tree” with a notion of convenience.
    </textual></para><para class="po-block e69 e69"><textual class="po-textual">      
      </textual><emphasis class="po-inline e70 e70" role="ital"><emphasis class="po-inline e71 e71" role="bold"><textual class="po-textual">Tray schema</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e72 e72"><textual class="po-textual">
      An info tray is a generic, name-aware data container, comparable to maps and XML 
      documents. As with maps and documents, the meaning of names depends on the tray 
      instance one is dealing with. Within a particular instance, the unit name 
      “SampleDescription” might address a unit which is an element node, a name 
      “ProjectActivities” might address a unit which is a string-to-string map, while 
      a third name “DepartmentList” might address nothing, as it is not used by the tray. 
      To express this situation, some kind of tray schema should define which names are 
      used and what exactly they address. Note that if an XQuery program is designed to 
      create a tray, the query result itself may be modeled in terms of a tray schema.   
    </textual></para><para class="po-block e73 e73"><textual class="po-textual">      
      </textual><emphasis class="po-inline e74 e74" role="ital"><emphasis class="po-inline e75 e75" role="bold"><textual class="po-textual">From info tray to info shape</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e76 e76"><textual class="po-textual">
      Consider an XQuery API delivering query results as info trays. Further consider 
      the availability of a tray schema which defines for a particular query the names 
      and data types of the information units which it produces. Then it is a small step 
      to imagine that such a tray schema could be compiled into a query-specific variant 
      of a tray which would expose an access interface exactly fitted to the available 
      information units. Their names and types could be combined into signatures which 
      exclude any name/type mismatches. Such a tray variant which represents the exact 
      “shape” of the information produced by a particular query might be called an 
      </textual><emphasis class="po-inline e77 e77" role="bold"><textual class="po-textual">info shape</textual></emphasis><textual class="po-textual">. It would offer type-safe, 
      compiler-guarded access to information units, for example like this:    
      </textual><programlisting class="po-block e78 e78" xml:space="preserve"><textual class="po-textual">String getOrganizatonLongName();
Map&lt;String,String&gt; getProjectActivities();</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e79 e79"><textual class="po-textual">
      which amounts to a Java binding not of Infosets in terms of info items, but query 
      results in terms of ready-to-use information units.
    </textual></para><para class="po-block e80 e80"><textual class="po-textual">      
      </textual><emphasis class="po-inline e81 e81" role="ital"><emphasis class="po-inline e82 e82" role="bold"><textual class="po-textual">Info path and info space</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e83 e83"><textual class="po-textual">
      Like an XML document, an info tray associates information with names and supports
      the nesting of named information. When we associate the tray as a whole with a name, then
      any information unit within a set of info trays can be described in terms of a simple
      path consisting of a tray name and one or more unit names. If we add to this path a trailing 
      part navigating </textual><emphasis class="po-inline e84 e84" role="ital"><textual class="po-textual">into</textual></emphasis><textual class="po-textual"> the unit, we arrive at the 
      concept of an </textual><emphasis class="po-inline e85 e85" role="bold"><textual class="po-textual">info path</textual></emphasis><textual class="po-textual"> addressing
      contents found in a set of info trays in a similar way to an XPath addressing the
      contents of an XML document. Thus an </textual><emphasis class="po-inline e86 e86" role="bold"><textual class="po-textual">info space</textual></emphasis><textual class="po-textual"> 
      simply denotes a set of info trays, associating each tray with a name.
    </textual></para></section><section class="po-hcontainer e87 e87"><title class="po-block e88 e88"><textual class="po-textual">XQJPLUS</textual></title><para class="po-block e89 e89"><textual class="po-textual">
      The remainder of this paper introduces XQJPLUS, which is several things: an API and its 
      implementation, a tool for generating Java components and, arguably, a style 
      for integrating XQuery into Java. XQJPLUS is an attempt to elaborate and implement 
      the conceptual framework sketched in the preceding section. The framework will serve 
      as a reference when describing XQJPLUS, a single context within which to inspect 
      various details.
    </textual></para><note class="po-container e90 e90"><title class="po-block e91 e91"><textual class="po-textual">XQJPLUS is not limited to the use of info trays</textual></title><para class="po-block e92 e92"><textual class="po-textual">
         XQJPLUS offers many features which facilitate the work with XQJ and which are
         independent of whether one actually uses info trays. Examples are a query 
         registration facility, automatic adaptation of the query base URI to the 
         query file URI, simplified parameter type handling, and simplified result 
         retrieval in the case of homogeneously-typed query results. These aspects are 
         ignored in the rest of this paper which concentrates on the possibilities 
         offered by info trays and info shapes.         
       </textual></para></note></section><section class="po-hcontainer e93 e93" xml:id="Getting-started-with-XQJPLUS"><title class="po-block e94 e94"><textual class="po-textual">Getting started with XQJPLUS - an illustrative example</textual></title><para class="po-block e95 e95"><textual class="po-textual">
      The goal of this section is to demonstrate how Java programs can be simplified by 
      integrating XQuery in an “information unit-oriented way”, receiving from XQuery 
      information in the form of named, ready-to-use entities. So the example 
      should be studied with two questions in mind: How would I get the work done 
      without XQuery? And how would I do it using XQuery, but without information 
      unit-oriented access to the query result? See </textual><xref class="po-milestone e96 e96" linkend="USGS-evaluation-query"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
      for a complete listing of the XQuery program which performs the evaluations
      used by the Java code.
    </textual></para><para class="po-block e97 e97"><textual class="po-textual">
      The example considers the evaluation of data obtained from 
      “National Water Information System (NWIS) Water-Quality Web Services”. See
      </textual><xref class="po-milestone e98 e98" linkend="USGS-WS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for technical documentation on how to use these
      web services. More specifically, we evaluate an XML file obtained from 
      the NWIS Result Service. It contains water quality sampling results 
      reported for the first three months of 2010, collected in the state 
      of Minnesota. The data can be obtained from the following URI:
      </textual><programlisting class="po-block e99 e99" xml:space="preserve"><textual class="po-textual">http://qwwebservices.usgs.gov/Result/search?organization=USGS-MN&amp;startDateLo=
01-01-2010&amp;startDateHi=03-31-2010&amp;mimeType=xml</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e100 e100"><textual class="po-textual">      
      See </textual><xref class="po-milestone e101 e101" linkend="USGS-example-data"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a sample of
      the data. The structure can be summarized as a sequence of activity 
      reports (</textual><code class="po-atom e102 e102"><textual class="po-textual">(&lt;Activity&gt;</textual></code><textual class="po-textual"> elements), each one containing 
      a description of the activity (</textual><code class="po-atom e103 e103"><textual class="po-textual">&lt;ActivityDescription&gt;</textual></code><textual class="po-textual">) 
      and a sequence of result reports (</textual><code class="po-atom e104 e104"><textual class="po-textual">&lt;Result&gt;</textual></code><textual class="po-textual"> 
      elements). Let us start with a set of simple evaluations.
    </textual></para><section class="po-hcontainer e105 e105"><title class="po-block e106 e106"><textual class="po-textual">A set of simple evaluations</textual></title><para class="po-block e107 e107"><emphasis class="po-inline e108 e108" role="ital"><emphasis class="po-inline e109 e109" role="bold"><textual class="po-textual">evaluation "projectIds"</textual></emphasis></emphasis></para><para class="po-block e110 e110"><textual class="po-textual">
        Desired result: a sorted list of project identifiers (</textual><code class="po-atom e111 e111"><textual class="po-textual">&lt;ProjectIdentifier&gt;</textual></code><textual class="po-textual">), 
        delivered as a </textual><code class="po-atom e112 e112"><textual class="po-textual">SortedSet&lt;String&gt;</textual></code><textual class="po-textual"> object. A string representation of 
        the result might look like this:
        </textual><programlisting class="po-block e113 e113" xml:space="preserve"><textual class="po-textual">
860700319
860700379
NAWQA</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e114 e114"><emphasis class="po-inline e115 e115" role="ital"><emphasis class="po-inline e116 e116" role="bold"><textual class="po-textual">evaluation “projectActivities”</textual></emphasis></emphasis></para><para class="po-block e117 e117"><textual class="po-textual">
        Desired result: a nested map, where outer keys are project identifiers, 
        inner keys are timestamps (obtained by concatenating </textual><code class="po-atom e118 e118"><textual class="po-textual">&lt;ActivityStartDate&gt;</textual></code><textual class="po-textual"> and 
        </textual><code class="po-atom e119 e119"><textual class="po-textual">&lt;Time&gt;</textual></code><textual class="po-textual">) and inner values are activity identifiers. 
      </textual></para><para class="po-block e120 e120"><textual class="po-textual">
       Desired result data type: </textual><code class="po-atom e121 e121"><textual class="po-textual">Map&lt;String, Map&lt;String,String&gt;&gt;</textual></code><textual class="po-textual">.
        A string representation might look like this:       
        </textual><programlisting class="po-block e122 e122" xml:space="preserve"><textual class="po-textual">
860700319= (2 entries)
   2010-01-21#10:20:00=sun1dmnspl.01.01000102
   2010-02-09#09:30:00=sun1dmnspl.01.01000105
   
860700379= (1 entries)
   2010-01-22#12:01:00=sun1dmnspl.01.01000103
   
NAWQA= (2 entries)
   2010-01-20#09:20:00=sun1dmnspl.01.01000101
   2010-02-10#11:00:00=sun1dmnspl.01.01000104</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e123 e123"><emphasis class="po-inline e124 e124" role="ital"><emphasis class="po-inline e125 e125" role="bold"><textual class="po-textual">evaluation “fractionResults”</textual></emphasis></emphasis></para><para class="po-block e126 e126"><textual class="po-textual">
        Desired result: a nested map with outer keys specifying the sample kind 
        (concatenation of </textual><code class="po-atom e127 e127"><textual class="po-textual">&lt;CharacteristicName&gt;</textual></code><textual class="po-textual"> and 
        </textual><code class="po-atom e128 e128"><textual class="po-textual">&lt;ResultSampleFractionText&gt;</textual></code><textual class="po-textual">), inner keys specifying the timestamp 
        (concatenation of </textual><code class="po-atom e129 e129"><textual class="po-textual">&lt;ActivityStartDate&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e130 e130"><textual class="po-textual">&lt;Time&gt;</textual></code><textual class="po-textual">) 
        and inner values a list of result values (each one a concatenation of 
        </textual><code class="po-atom e131 e131"><textual class="po-textual">&lt;ResultMeasureValue&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e132 e132"><textual class="po-textual">&lt;MeasureUnitCode&gt;</textual></code><textual class="po-textual">) 
        obtained for this combination of sample kind and time. 
      </textual></para><para class="po-block e133 e133"><textual class="po-textual">
       Desired result data type: </textual><code class="po-atom e134 e134"><textual class="po-textual">Map&lt;String, Map&lt;String, String[]&gt;&gt;</textual></code><textual class="po-textual">.
        A string representation might look like this:       
        </textual><programlisting class="po-block e135 e135" xml:space="preserve"><textual class="po-textual">…
Ammonia and ammonium/Dissolved=
   2010-01-20#09:20:00=
      0.49 [mg/l NH4]
      0.384 [mg/l as N]
   2010-01-21#10:20:00=
      0.283 [mg/l as N]
      0.36 [mg/l NH4]
   2010-01-22#12:01:00=
      0.08 [mg/l NH4]
      0.062 [mg/l as N]
   2010-02-09#09:30:00=
      0.307 [mg/l as N]
      0.40 [mg/l NH4]
   2010-02-10#11:00:00=
      0.55 [mg/l NH4]
      0.431 [mg/l as N]
   
Ammonia and ammonium/Total=
   2010-01-21#10:20:00=
      0.29 [mg/l as N]
      0.38 [mg/l NH4]
   2010-02-09#09:30:00=
      0.33 [mg/l as N]
      0.42 [mg/l NH4]
…</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e136 e136"><emphasis class="po-inline e137 e137" role="ital"><emphasis class="po-inline e138 e138" role="bold"><textual class="po-textual">evaluation “activityResults”</textual></emphasis></emphasis></para><para class="po-block e139 e139"><textual class="po-textual">
        Desired result: a map associating </textual><code class="po-atom e140 e140"><textual class="po-textual">UsgsResult</textual></code><textual class="po-textual"> object arrays with string keys. The 
        key specifies the activity identifier and the objects are custom objects 
        representing an activity as described by one </textual><code class="po-atom e141 e141"><textual class="po-textual">&lt;Activity&gt;</textual></code><textual class="po-textual"> element. It is 
        assumed that </textual><code class="po-atom e142 e142"><textual class="po-textual">UsgsResult</textual></code><textual class="po-textual"> objects can be loaded from </textual><code class="po-atom e143 e143"><textual class="po-textual">&lt;Activity&gt;</textual></code><textual class="po-textual"> 
        element information items. 
      </textual></para><para class="po-block e144 e144"><textual class="po-textual">
        Desired result data type: </textual><code class="po-atom e145 e145"><textual class="po-textual">Map&lt;String, UsgsResult[]&gt;</textual></code><textual class="po-textual">.
        A string representation of the result might look like this:
        </textual><programlisting class="po-block e146 e146" xml:space="preserve"><textual class="po-textual">
key=sun1dmnspl.01.01000101
result object:
============================================
ResultValueTypeName=Calculated
ResultStatusIdentifier=Preliminary
MeasureUnitCode=mg/l NH4
AnalysisStartDate=--
ResultSampleFractionText=Dissolved
CharacteristicName=Ammonia and ammonium
PreparationStartDate=--
USGSPCode=71846
ResultMeasureValue=0.49

...</textual></programlisting><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e147 e147"><title class="po-block e148 e148"><textual class="po-textual">Obtaining the results via info tray</textual></title><para class="po-block e149 e149"><textual class="po-textual">
        XQJPLUS offers the possibility to let the query create an info tray, 
        a collection of information units which may be conveniently accessed. 
        The following code snippet demonstrates how the evaluations defined in 
        the preceding section might be performed from a Java developer’s perspective.
        </textual><programlisting class="po-block e150 e150" xml:space="preserve"><textual class="po-textual">
// *** prepare query
// *****************
xq.registerQueryFile(queryName, queryFile);

// *** load info tray
// ******************
InfoTray tray = xq.execQuery2InfoTray(queryName, new FileInputStream(inputFile), null);

// *** read results
// *****************
SortedSet&lt;String&gt; projectIds =                       tray.getStringSortedSetObject("projectIds");
Map&lt;String, Map&lt;String, String&gt;&gt; projectActivities = tray.getNestedMapString2StringObject("projectActivities");
Map&lt;String, Map&lt;String, String[]&gt;&gt; fractionResults = tray.getNestedMapString2StringsObject("fractionResults");
Map&lt;String, Object[]&gt; activityResults =              tray.getMapString2CustomObjectsObject("activityResults");

// *** process results
// ******************* 
// ...</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e151 e151"><textual class="po-textual">
        The various results are “information units” which the Java code may 
        conveniently pick from the tray: selecting the appropriate getter method 
        (depending on the unit’s data type) and specifying the result name as a 
        parameter.  
      </textual></para></section><section class="po-hcontainer e152 e152" xml:id="Obtaining-via-info-shape"><title class="po-block e153 e153"><textual class="po-textual">Obtaining the results via generated info shape</textual></title><para class="po-block e154 e154"><textual class="po-textual">
        Using an info tray, Java code can contain two kinds of errors not
        detected at compile time: using a wrong access method for a given
        unit name, and using a unit name which does not occur at all in
        the tray. If this is an issue, one may work with </textual><emphasis class="po-inline e155 e155" role="ital"><textual class="po-textual">
        info shapes</textual></emphasis><textual class="po-textual"> instead of info trays. An info shape is a
        query-specific Java class plus interfaces, providing type-safe 
        access exactly tailored to fit the query results. The Java code 
        is generated from a succinct “tray schema” describing the result. 
        A minimal version of such a schema would just state the names and 
        data types of the units, as well as a distribution of the units 
        over one or more read interfaces. See </textual><xref class="po-milestone e156 e156" linkend="Tray-schema"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> 
        for a listing of the schema used to generate the Java resources 
        used in this section. The schema is compiled into two Java 
        interfaces and a back-end Java class. As an example, 
        an excerpt of interface </textual><code class="po-atom e157 e157"><textual class="po-textual">ProjectData</textual></code><textual class="po-textual"> looks like this:      
        </textual><programlisting class="po-block e158 e158" xml:space="preserve"><textual class="po-textual">
public interface ProjectData {

//data access
    public SortedSet&lt;String&gt; getProjectIds() throws XQPException;
    public Map&lt;String,Map&lt;String,String&gt;&gt; getProjectActivities() throws XQPException;

//meta data access
    public Map&lt;String,String&gt; getProjectIdsMetaData() throws XQPException;
    public Map&lt;String,String&gt; getProjectActivitiesMetaData() throws XQPException;

// more signatures left out …
}</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e159 e159"><textual class="po-textual">
        These generated Java components can be used for even simpler and safer 
        Java access to the query results. This time, we let the query generate
        an info shape, rather than an info tray. The info shape is an object
        of the generated class </textual><code class="po-atom e160 e160"><textual class="po-textual">ResultReport</textual></code><textual class="po-textual">, from which we
        obtain the interfaces: 
        </textual><programlisting class="po-block e161 e161" xml:space="preserve"><textual class="po-textual">
// *** create and load info shape
// ******************************
ResultReport resultReport = 
   xq.execQuery2InfoShape(queryName, new FileInputStream(inputFile), null, new ResultReport());
     
ResultData  resultData  = resultReport.getInterfaceResultData();
ProjectData projectData = resultReport.getInterfaceProjectData();</textual></programlisting><textual class="po-textual">
        We use these interfaces to read the query results:
        </textual><programlisting class="po-block e162 e162" xml:space="preserve"><textual class="po-textual">
// *** read results
// ****************
SortedSet&lt;String&gt; projectIds                       = projectData.getProjectIds();
Map&lt;String, Map&lt;String, String&gt;&gt; projectActivities = projectData.getProjectActivities();
Map&lt;String, Map&lt;String, String[]&gt;&gt; fractionResults = resultData.getFractionResults();
Map&lt;String, UsgsResult[]&gt; activityResults          = resultData.getActivityResults();	</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e163 e163"><textual class="po-textual">
        When using such an info shape, rather than an info tray, mismatches between unit
        name and the unit's data type are excluded. A further advantage is the 
        delivery of custom objects as instances of their specific type, rather than 
        instances of </textual><code class="po-atom e164 e164"><textual class="po-textual">Object</textual></code><textual class="po-textual">.
      </textual></para></section><section class="po-hcontainer e165 e165" xml:id="Information-unit-oriented-access"><title class="po-block e166 e166"><textual class="po-textual">Information unit-oriented access</textual></title><para class="po-block e167 e167"><textual class="po-textual">
        Whether working with an info tray or an info shape - the API client deals with
        information units, rather than information items. The units are named and have
        a granularity adapted to the client's requirements, rather than being dictated by the
        XQuery data model. </textual><xref class="po-milestone e168 e168" linkend="from-items-to-units"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> summarizes the process 
        which enables this information unit-oriented access.
      </textual></para><figure class="po-container e169 e169" xml:id="from-items-to-units"><title class="po-block e170 e170"><textual class="po-textual">From XDM items to information units</textual></title><mediaobject class="po-container e171 e171"><imageobject class="po-container e172 e172"><imagedata class="po-meta e173 e173" fileref="../../../vol5/graphics/Rennau01/Rennau01-001.jpg" format="jpg" width="80%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e174 e174"><para class="po-block e175 e175"><textual class="po-textual">Schematic representation of how query execution is coupled to the generation of an info tray. 
              A query – myquery.xq – is executed and produces a sequence of XDM items. These are passed to the 
              assembly machine, which transforms them into a set of named information units. The units are stored 
              for later delivery. Delivery is enabled by a spectrum of get methods, each one dedicated to a 
              specific unit data type.
          </textual></para></caption></figure></section><section class="po-hcontainer e176 e176" xml:id="Example-summing-up"><title class="po-block e177 e177"><textual class="po-textual">Summing up</textual></title><para class="po-block e178 e178"><textual class="po-textual">
        The example demonstrated the possibility to supply Java code with the results of XQuery
        evaluations in a convenient and intuitive way. What was the price to pay for this
        convenience, how much effort had to be made in the XQuery layer? The query constructing
        the info tray (or the info shape, if the tray schema was compiled into Java code)
        comprises 111 lines of code, including comments. (See </textual><xref class="po-milestone e179 e179" linkend="USGS-evaluation-query"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a full listing.) An experienced 
        XQuery developer can write the code in an hour or two. Adding in the fact that
        on the Java developer's side no learning or understanding of XQuery was
        required, leads to the conclusion that the integration of XQuery into Java may
        offer an interesting perspective in general - and especially so if realized in an 
        information unit-oriented way.
      </textual></para></section></section><section class="po-hcontainer e180 e180" xml:id="Information-units"><title class="po-block e181 e181"><textual class="po-textual">Information units</textual></title><para class="po-block e182 e182"><textual class="po-textual">
      This section deals with several aspects of information units. It starts with an 
      elaboration of the concept, followed by an overview of the data types which an information 
      unit may represent.  The main part is a description how information units are assembled from 
      XQuery result items. Finally, the use of meta data is explained.
    </textual></para><section class="po-hcontainer e183 e183"><title class="po-block e184 e184"><textual class="po-textual">Concept</textual></title><para class="po-block e185 e185"><textual class="po-textual">
         The term </textual><emphasis class="po-inline e186 e186" role="ital"><emphasis class="po-inline e187 e187" role="bold"><textual class="po-textual">information unit</textual></emphasis></emphasis><textual class="po-textual"> 
         should capture the idea of a convenient entity to use when 
         accessing, processing or delivering information. Of course, what is convenient depends on 
         the situation and on taste. But as a starting point one may postulate that XDM items – nodes 
         and atomic values – certainly </textual><emphasis class="po-inline e188 e188" role="ital"><textual class="po-textual">are</textual></emphasis><textual class="po-textual"> information units, but 
         not the only ones one might wish for. A node or, say, a string can be exactly what one wants 
         to deal with. Note however the general limitation that the XDM model has only two ways 
         to express aggregation: (a) by a tree structure found within the content of a node, and 
         (b) by regarding a sequence of items as an XDM value. The first must be unravelled using 
         tree navigation, and the second is a primitive collection approach. From an application 
         programmer’s point of view, this may be insufficient.
       </textual></para><para class="po-block e189 e189"><emphasis class="po-inline e190 e190" role="ital"><emphasis class="po-inline e191 e191" role="bold"><textual class="po-textual">Motivating example</textual></emphasis></emphasis></para><para class="po-block e192 e192"><textual class="po-textual">
        Consider the situation that some processing requires as input a particular string-to-string
        mapping, for example mapping project identifiers to project names. Such a mapping can 
        easily be represented by an XML structure, for example:
        </textual><programlisting class="po-block e193 e193" xml:space="preserve"><textual class="po-textual">
&lt;projects&gt;
   &lt;project id=”…” name=”…”/&gt;
   &lt;project id=”…” name=”…”/&gt;
&lt;/projects&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e194 e194"><textual class="po-textual">
        This ease of representation should not be confused with ease of usage. The Java type 
        </textual><code class="po-atom e195 e195"><textual class="po-textual">Map&lt;String, String&gt;</textual></code><textual class="po-textual"> is tailored exactly for the purpose of working 
        with a string-to-string mapping. At least in situations where only key-based 
        access is desired (as opposed to querying the sets of keys or values), the map may be 
        considered simpler and more straightforward. After all, working with the XML 
        representation one would have to be aware of three paths: one leading from the 
        map root to the nodes representing map entries, one leading from the entry root 
        to the key and one leading from the entry root to the value. (In the example, 
        the paths would be “project”, “@id” and “@name”.) These paths would have to be 
        supplied either by convention (for example using standardized element names 
        “map” and “entry” and attribute names “key” and “value”), or by explicit meta 
        information. So the XML representation needs meta 
        information. Another aspect: the navigation from key to value can be 
        achieved in different ways, e.g. via XPath or via DOM methods. So the XML 
        representation is not unambiguous and explicit as to the appropriate usage 
        style. Apart from that, the map access is probably more efficient. Taking 
        these aspects together, one may conclude that XML’s wonderful ability to 
        represent almost any kind of information does not imply that it is always 
        the most appropriate format for using or processing that information. This is where 
        “information units” come into play.
      </textual></para><para class="po-block e196 e196"><textual class="po-textual">
        Before continuing, let's briefly compare the use of information units with data binding. 
        Data binding replaces an XML structure by a one-to-one object 
        representation. This is like a “push” model: the XML comes first and dictates 
        the object representation, which is essentially a translation of the item tree 
        into an object tree. Information units, on the other hand, constitute 
        a “pull” model: what comes first is the desired representation of information; 
        it is assembled by </textual><emphasis class="po-inline e197 e197" role="ital"><textual class="po-textual">using</textual></emphasis><textual class="po-textual"> XDM items, rather 
        than echoing them.
      </textual></para><para class="po-block e198 e198"><emphasis class="po-inline e199 e199" role="ital"><emphasis class="po-inline e200 e200" role="bold"><textual class="po-textual">Modelling information units</textual></emphasis></emphasis></para><para class="po-block e201 e201"><textual class="po-textual">
        An information unit encapsulates data. It should also contain information about the data, 
        as becomes obvious when one considers an element information item as a general prototype of information 
        units. An element has 
        </textual><itemizedlist class="po-table e202 e202"><listitem class="po-container e203 e203"><para class="po-block e204 e204"><textual class="po-textual">content, which is the data represented by its child nodes</textual></para></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">a name, serving to distinguish it from other (sibling) elements</textual></para></listitem><listitem class="po-container e207 e207"><para class="po-block e208 e208"><textual class="po-textual">attributes, a set of named atomic values associated with the element</textual></para></listitem><listitem class="po-container e209 e209"><para class="po-block e210 e210"><textual class="po-textual">a type, which is a description of what kind of content to expect</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e211 e211"><textual class="po-textual">
        XQJPLUS defines the following generic model of an information unit: it has
        </textual><itemizedlist class="po-table e212 e212"><listitem class="po-container e213 e213"><para class="po-block e214 e214"><textual class="po-textual">
              </textual><emphasis class="po-inline e215 e215" role="ital"><textual class="po-textual">content</textual></emphasis><textual class="po-textual">, which is an 
              instance of a programming language's data type</textual></para></listitem><listitem class="po-container e216 e216"><para class="po-block e217 e217"><textual class="po-textual">
              a </textual><emphasis class="po-inline e218 e218" role="ital"><textual class="po-textual">name</textual></emphasis><textual class="po-textual">, serving to 
              distinguish it from other, sibling units</textual></para></listitem><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">
              </textual><emphasis class="po-inline e221 e221" role="ital"><textual class="po-textual">meta data</textual></emphasis><textual class="po-textual">, which is 
              a set of named string values associated with the unit</textual></para></listitem><listitem class="po-container e222 e222"><para class="po-block e223 e223"><textual class="po-textual">
              a </textual><emphasis class="po-inline e224 e224" role="ital"><textual class="po-textual">type description</textual></emphasis><textual class="po-textual"> 
              composed of three components:</textual></para><itemizedlist class="po-table e225 e225"><listitem class="po-container e226 e226"><para class="po-block e227 e227"><textual class="po-textual">a physical type (QName)</textual></para></listitem><listitem class="po-container e228 e228"><para class="po-block e229 e229"><textual class="po-textual">a semantic type (QName)</textual></para></listitem><listitem class="po-container e230 e230"><para class="po-block e231 e231"><textual class="po-textual">an implementation type (a string)</textual></para></listitem></itemizedlist></listitem></itemizedlist><textual class="po-textual">        
        </textual></para><para class="po-block e232 e232"><emphasis class="po-inline e233 e233" role="ital"><emphasis class="po-inline e234 e234" role="bold"><textual class="po-textual">content</textual></emphasis></emphasis></para><para class="po-block e235 e235"><textual class="po-textual">
        XQJPLUS constrains the content to be a single Java object, or an array of Java objects.
      </textual></para><para class="po-block e236 e236"><emphasis class="po-inline e237 e237" role="ital"><emphasis class="po-inline e238 e238" role="bold"><textual class="po-textual">name</textual></emphasis></emphasis></para><para class="po-block e239 e239"><textual class="po-textual">
        The name distinguishes an information unit among siblings. The concept of siblings relates to 
        a collection of units, which is not an inherent part of the model of an information unit. XQJPLUS 
        introduces a distinct concept – the info tray – to model collections of information units. So the 
        name of an information unit serves to distinguish it from other units within the same info tray. 
        Info trays will be discussed in </textual><xref class="po-milestone e240 e240" linkend="Information-tray"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      </textual></para><para class="po-block e241 e241"><emphasis class="po-inline e242 e242" role="ital"><emphasis class="po-inline e243 e243" role="bold"><textual class="po-textual">meta data</textual></emphasis></emphasis></para><para class="po-block e244 e244"><textual class="po-textual">
        Any information unit is associated with a set of named values, modelled as a 
        QName-to-string mapping.
      </textual></para><para class="po-block e245 e245"><emphasis class="po-inline e246 e246" role="ital"><emphasis class="po-inline e247 e247" role="bold"><textual class="po-textual">type description</textual></emphasis></emphasis></para><para class="po-block e248 e248"><textual class="po-textual">
        The type description comprises three names. The contents are guaranteed to be an instance of the
        </textual><emphasis class="po-inline e249 e249" role="ital"><emphasis class="po-inline e250 e250" role="bold"><textual class="po-textual">physical type</textual></emphasis></emphasis><textual class="po-textual">, which is the data
        type defined in the programming language. 
        Note that this may be an interface type or a base type of the data type that is used, 
        in which case the underlying data type is only partially revealed by the physical type. The 
        underlying type is however fully revealed by the </textual><emphasis class="po-inline e251 e251" role="ital"><emphasis class="po-inline e252 e252" role="bold"><textual class="po-textual">
        implementation type.</textual></emphasis></emphasis><textual class="po-textual"> 
      </textual></para><para class="po-block e253 e253"><textual class="po-textual">
        The </textual><emphasis class="po-inline e254 e254" role="ital"><emphasis class="po-inline e255 e255" role="bold"><textual class="po-textual">semantic type</textual></emphasis></emphasis><textual class="po-textual"> is a name meant to 
        identify what the content “means”. For example, while the physical type may specify the content to be a string-to-string
        map, the semantic type might identify the contents to be a mapping of project identifier to project name. To specify 
        this, a name like “{http://www.example.com/ns/proj}projectIdTable” might be invented. Note that the semantic type 
        only identifies by specifying a QName, it does not define or describe. XQJPLUS does not define the interpretation of the
        semantic type.
      </textual></para><note class="po-container e256 e256"><title class="po-block e257 e257"><textual class="po-textual">on physical type names</textual></title><para class="po-block e258 e258"><textual class="po-textual">
          XQJPLUS implements the integration of XQuery into Java – therefore the physical type amounts to a Java type. 
          However, the concept of an information unit and its properties is not tied to a specific language, and XQJPLUS 
          attempts to preserve the language-independence of the concept as far as possible. Therefore the physical  
          type of an information unit is not defined to be a Java type name, but a QName representing an “abstract” type 
          that might be implemented by different languages. For example, a string-to-string map can be represented by 
          many other languages, too. The physical type name is “map_string_to_string_object”, while the corresponding 
          Java type name is “</textual><code class="po-atom e259 e259"><textual class="po-textual">java.util.Map&lt;String,String&gt;</textual></code><textual class="po-textual">”. If, for example, a Perl implementation
          of XQJPLUS existed, the corresponding Perl type name would probably be </textual><code class="po-atom e260 e260"><textual class="po-textual">Hash</textual></code><textual class="po-textual">.
        </textual></para><para class="po-block e261 e261"><textual class="po-textual">
          The physical type is defined to be a QName. XQJPLUS uses physical type names without a namespace URI, 
          suggesting this pattern: standard physical types are in no namespace; any custom physical type 
          (that is, physical types introduced by project-specific extensions of XQJPLUS) must use a name 
          with a namespace URI.
        </textual></para></note></section><section class="po-hcontainer e262 e262"><title class="po-block e263 e263"><textual class="po-textual">Available physical types</textual></title><para class="po-block e264 e264"><textual class="po-textual">
        As the results of a query execution are delivered as information units, a key question is: what 
        Java types are available? How is the concept of an information unit implemented in terms of Java 
        types? If we compare XQJPLUS with a restaurant where the XQuery developer is the cook and the 
        Java developer a potential guest, the range of available Java types is like the menu. Without 
        a glance at that range, the value of XQJPLUS cannot be assessed.
      </textual></para><para class="po-block e265 e265"><textual class="po-textual">
        </textual><emphasis class="po-inline e266 e266" role="ital"><textual class="po-textual">Note:</textual></emphasis><textual class="po-textual"> The preceding subsection introduced the notion of 
        physical types which are mapped to Java type names. In the current subsection the Java type names 
        are used, although the physical type is defined as a QName which is usually different 
        from the Java type name.
      </textual></para><para class="po-block e267 e267"><textual class="po-textual">
        As a starting point, consider the Java types which the underlying XQJ API delivers.
      </textual></para><para class="po-block e268 e268"><textual class="po-textual">
        </textual><table class="po-container e269 e269"><caption class="po-container e270 e270"><para class="po-block e271 e271"><textual class="po-textual">
              </textual><emphasis class="po-inline e272 e272" role="bold"><emphasis class="po-inline e273 e273" role="ital"><textual class="po-textual">Summary of Java types delivered by XQJ.</textual></emphasis></emphasis><textual class="po-textual">
            </textual></para></caption><col align="left" class="po-meta e274 e274" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e275 e275" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e276 e276"><tr class="po-table e277 e277" valign="top"><th align="left" class="po-field e278 e278" valign="top"><textual class="po-textual">category</textual></th><th align="left" class="po-field e279 e279" valign="top"><textual class="po-textual">types</textual></th></tr></thead><tbody class="po-table e280 e280"><tr class="po-table e281 e281" valign="top"><td class="po-block e282 e282"><emphasis class="po-inline e283 e283" role="bold"><textual class="po-textual">atomic types</textual></emphasis></td><td class="po-block e284 e284"><textual class="po-textual">Boolean, BigDecimal, BigInteger, Byte, Double, Duration, Float, Integer, Long, QName, Short, String, XMLGregorianCalendar</textual></td></tr><tr class="po-table e285 e285" valign="top"><td class="po-block e286 e286"><emphasis class="po-inline e287 e287" role="bold"><textual class="po-textual">node types</textual></emphasis></td><td class="po-block e288 e288"><textual class="po-textual">Document, Element, Attr, Text, Comment, ProcessingInstruction</textual></td></tr></tbody></table><textual class="po-textual">
      </textual></para><para class="po-block e289 e289"><textual class="po-textual">
        This spectrum is included and extended by XQJPLUS.
        </textual><table class="po-container e290 e290"><caption class="po-container e291 e291"><para class="po-block e292 e292"><textual class="po-textual">
              </textual><emphasis class="po-inline e293 e293" role="bold"><emphasis class="po-inline e294 e294" role="ital"><textual class="po-textual">Summary of Java types delivered by XQJPLUS. 
              Note that for each type a single object variant and an array variant is supported,
              e.g. String and String[].</textual></emphasis></emphasis><textual class="po-textual">
            </textual></para></caption><col align="left" class="po-meta e295 e295" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e296 e296" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e297 e297"><tr class="po-table e298 e298" valign="top"><th align="left" class="po-field e299 e299" valign="top"><textual class="po-textual">category</textual></th><th align="left" class="po-field e300 e300" valign="top"><textual class="po-textual">types</textual></th></tr></thead><tbody class="po-table e301 e301"><tr class="po-table e302 e302" valign="top"><td class="po-block e303 e303"><emphasis class="po-inline e304 e304" role="bold"><textual class="po-textual">atomic types</textual></emphasis></td><td class="po-block e305 e305"><textual class="po-textual">Boolean, BigDecimal, BigInteger, Byte, Double, Duration, Float, Integer, Long, QName, Short, String, XMLGregorianCalendar</textual></td></tr><tr class="po-table e306 e306" valign="top"><td class="po-block e307 e307"><emphasis class="po-inline e308 e308" role="bold"><textual class="po-textual">node types</textual></emphasis></td><td class="po-block e309 e309"><textual class="po-textual">Document, Element, Attr, Text, Comment, ProcessingInstruction</textual></td></tr><tr class="po-table e310 e310" valign="top"><td class="po-block e311 e311" valign="top"><emphasis class="po-inline e312 e312" role="bold"><textual class="po-textual">maps</textual></emphasis></td><td class="po-block e313 e313" valign="top"><textual class="po-textual">
                </textual><para class="po-block e314 e314"><textual class="po-textual">Map&lt;String,T&gt;, T=String, String[], Node, Node[], Boolean, Object, Object[]</textual></para><textual class="po-textual">
                </textual><para class="po-block e315 e315"><textual class="po-textual">Map&lt;String,Map&lt;String,T&gt;&gt;, T=String, String[], Node, Object</textual></para><textual class="po-textual">
              </textual></td></tr><tr class="po-table e316 e316" valign="top"><td class="po-block e317 e317"><emphasis class="po-inline e318 e318" role="bold"><textual class="po-textual">collections</textual></emphasis></td><td class="po-block e319 e319"><textual class="po-textual">List&lt;String&gt;, List&lt;Node&gt;, Set&lt;String&gt;, Set&lt;Node&gt;, SortedSet&lt;String&gt;, Queue&lt;String&gt;</textual></td></tr><tr class="po-table e320 e320" valign="top"><td class="po-block e321 e321"><emphasis class="po-inline e322 e322" role="bold"><textual class="po-textual">miscellaneous</textual></emphasis></td><td class="po-block e323 e323"><textual class="po-textual">java.util.Properties</textual></td></tr><tr class="po-table e324 e324" valign="top"><td class="po-block e325 e325"><emphasis class="po-inline e326 e326" role="bold"><textual class="po-textual">custom types</textual></emphasis></td><td class="po-block e327 e327"><textual class="po-textual">(any type implementing LoadableFromXML)</textual></td></tr><tr class="po-table e328 e328" valign="top"><td class="po-block e329 e329"><emphasis class="po-inline e330 e330" role="bold"><textual class="po-textual">exceptions</textual></emphasis></td><td class="po-block e331 e331"><textual class="po-textual">InfoTrayLoadingException</textual></td></tr><tr class="po-table e332 e332" valign="top"><td class="po-block e333 e333"><emphasis class="po-inline e334 e334" role="bold"><textual class="po-textual">info tray</textual></emphasis></td><td class="po-block e335 e335"><textual class="po-textual">InfoTray</textual></td></tr></tbody></table><textual class="po-textual">

      </textual></para><para class="po-block e336 e336"><textual class="po-textual">
        The extension compared to XQJ has four aspects:
        </textual><itemizedlist class="po-table e337 e337"><listitem class="po-container e338 e338"><para class="po-block e339 e339"><textual class="po-textual">XQJPLUS units can have either a single object type or an array type</textual></para></listitem><listitem class="po-container e340 e340"><para class="po-block e341 e341"><textual class="po-textual">XQJPLUS adds further type categories (maps, collections, …)</textual></para></listitem><listitem class="po-container e342 e342"><para class="po-block e343 e343"><textual class="po-textual">XQJPLUS units can have custom types (!)</textual></para></listitem><listitem class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">XQJPLUS units can be nested (using InfoTray or InfoTray[] as physical types)</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e346 e346"><textual class="po-textual">  
        </textual><emphasis class="po-inline e347 e347" role="bold"><emphasis class="po-inline e348 e348" role="ital"><textual class="po-textual">support for array types</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e349 e349"><textual class="po-textual">
        The query result which XQJ delivers is one single, unstructured sequence of items. 
        It is not possible to express any grouping of items into sub sequences. For example, 
        if the result consists of 10 strings, there is no way to communicate explicitly that 
        the first six strings should be viewed as one array, followed by a single item, 
        followed by an array of three items. In XQJPLUS, on the other hand, the result could 
        be delivered as three units, two of which are arrays.
      </textual></para><para class="po-block e350 e350"><textual class="po-textual">
        </textual><emphasis class="po-inline e351 e351" role="bold"><emphasis class="po-inline e352 e352" role="ital"><textual class="po-textual">added categories</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e353 e353"><textual class="po-textual">
        </textual><emphasis class="po-inline e354 e354" role="ital"><textual class="po-textual">Map types</textual></emphasis><textual class="po-textual"> are thought to be especially useful, 
        as XML evaluations often yield information which can be modelled as a map. The map 
        keys are strings, the map values can be strings, booleans, nodes or custom objects 
        (see below). Maps can be simple or nested. </textual><emphasis class="po-inline e355 e355" role="ital"><textual class="po-textual">Collection types</textual></emphasis><textual class="po-textual"> 
        are probably less important than maps, due to the general support for array 
        types. The type </textual><emphasis class="po-inline e356 e356" role="ital"><code class="po-atom e357 e357"><textual class="po-textual">java.util.Properties</textual></code></emphasis><textual class="po-textual"> is 
        currently the only type of category "miscellaneous", but the addition of other types is 
        intended. Admitting </textual><emphasis class="po-inline e358 e358" role="ital"><textual class="po-textual">exception objects</textual></emphasis><textual class="po-textual"> as information 
        units enables query authors to communicate error conditions in a unified way.
      </textual></para><para class="po-block e359 e359"><textual class="po-textual">
        </textual><emphasis class="po-inline e360 e360" role="bold"><emphasis class="po-inline e361 e361" role="ital"><textual class="po-textual">custom types</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e362 e362"><textual class="po-textual">
        Information units can be custom type objects. Custom types are (presently) required to 
        implement the interface </textual><code class="po-atom e363 e363"><textual class="po-textual">LoadableFromXML</textual></code><textual class="po-textual">, which is part of the main 
        package of XQJPLUS. It contains a single method </textual><code class="po-atom e364 e364"><textual class="po-textual">loadFromXML</textual></code><textual class="po-textual"> which 
        loads an object with data received as an XML node. The construction of custom type 
        objects will be discussed in a later section.
      </textual></para><para class="po-block e365 e365"><textual class="po-textual">
        </textual><emphasis class="po-inline e366 e366" role="bold"><emphasis class="po-inline e367 e367" role="ital"><textual class="po-textual">nested units</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e368 e368"><textual class="po-textual">
        An information unit may be an </textual><code class="po-atom e369 e369"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> object, which represents 
        a collection of named information units. (See 
        </textual><xref class="po-milestone e370 e370" linkend="Information-tray"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for a discussion of info trays.) This amounts 
        to supporting a type of unit which is a tree consisting of </textual><code class="po-atom e371 e371"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual">
        objects as internal nodes and non-</textual><code class="po-atom e372 e372"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> objects as leaf nodes.
        In fact, a query result as a whole can be regarded as such a tree. Note that
        the tree of info trays and non-tray leaves must not be confused with an
        XML tree. A leaf of the latter contains an atomic value; a leaf of the
        former may, for example, contain an XML document, or a mapping of strings to 
        XML documents.
      </textual></para><para class="po-block e373 e373"><textual class="po-textual">
        Information units are retrieved from an info tray by calling a specific getter method 
        which has the unit’s physical type as return type. See </textual><xref class="po-milestone e374 e374" linkend="read-access"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> 
        for more information about API access to information units.
      </textual></para></section><section class="po-hcontainer e375 e375" xml:id="The-assembly-process-basics"><title class="po-block e376 e376"><textual class="po-textual">The assembly process - basics</textual></title><para class="po-block e377 e377"><textual class="po-textual">
         After deciding which physical types XQJPLUS must support, we can investigate their assembly.
         The assembly is wholly controlled by the XQuery code. XQuery 
         thus provides both the </textual><emphasis class="po-inline e378 e378" role="ital"><textual class="po-textual">information content</textual></emphasis><textual class="po-textual"> and the </textual><emphasis class="po-inline e379 e379" role="ital"><textual class="po-textual">control information</textual></emphasis><textual class="po-textual"> 
         required to transform this content into a collection of information units.
       </textual></para><para class="po-block e380 e380"><textual class="po-textual">
        Let us look at an example. The following XQuery snippet produces two result items – a 
        </textual><emphasis class="po-inline e381 e381" role="ital"><textual class="po-textual">control item</textual></emphasis><textual class="po-textual"> and a </textual><emphasis class="po-inline e382 e382" role="ital"><textual class="po-textual">data item</textual></emphasis><textual class="po-textual"> - 
        which together will command the assembly of an information unit consisting of a string-to-string map:
        </textual><programlisting class="po-block e383 e383" xml:space="preserve"><textual class="po-textual">&lt;xqjp:part name="activityTimes" 
           type="map_string_to_string_object"
           entryPath="activity"
           keyPath="@id"
           valuePath="@time"
           sematype="usgs:activityTimes" /&gt;,

&lt;activities&gt;{
   for $a in //Activity/ActivityDescription return
      &lt;activity id="{$a/ActivityIdentifier}" 
                time="{concat($a/ActivityStartDate, 'T', $a/ActivityStartTime/Time)}" /&gt;
}&lt;/activities&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e384 e384"><textual class="po-textual">
        The control item </textual><code class="po-atom e385 e385"><textual class="po-textual">&lt;xqjp:part&gt;</textual></code><textual class="po-textual"> announces 
        the construction of an information unit with name “activityTimes” and physical type 
        “map_string_to_string_object”. This type name corresponds to the Java type 
        </textual><code class="po-atom e386 e386"><textual class="po-textual">Map&lt;String,String&gt;</textual></code><textual class="po-textual">. The data to be written into the map follow 
        in the next result item, which is a </textual><emphasis class="po-inline e387 e387" role="ital"><textual class="po-textual">data item</textual></emphasis><textual class="po-textual">, 
        rather than a control item. 
        The assembly of the information unit (a map object) from the contents of the data item (an element node) is 
        configured by the control item’s attributes “entryPath”, “keyPath” and “valuePath”. The values of these attributes 
        are interpreted as XPath expressions. The entry path is applied to the data item’s root and leads to the nodes 
        representing the map entries. The other paths are applied to these nodes, one at a time, yielding a map entry’s key 
        and value, respectively.
      </textual></para><para class="po-block e388 e388"><textual class="po-textual">
        Another example illustrates the mapping of a result item sequence to several information units. The query generates 
        three information units, named “projectList”, “organizationProfiles” and “countActivities". To achieve this, it produces 
        a stream of data items with control items interspersed.
      </textual></para><para class="po-block e389 e389"><textual class="po-textual">
        </textual><programlisting class="po-block e390 e390" xml:space="preserve"><textual class="po-textual">&lt;xqjp:part name=”projectList” 
           type=”strings”/&gt;, 
distinct-values(//ProjectIdentifier),

&lt;xqjp:part name=”organizationProfiles” 
           type=”nodes”/&gt;
&lt;orgProfile&gt;…&lt;/orgProfile&gt;,
&lt;orgProfile&gt;…&lt;/orgProfile&gt;,
&lt;orgProfile&gt;…&lt;/orgProfile&gt;,

&lt;xqjp:part name=”countActivities” type=”integer”&gt;,
count(//ActivityIdentifier)</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e391 e391"><textual class="po-textual">
        The examples illustrate the basic rules of the assembly process. 
      </textual></para><para class="po-block e392 e392"><emphasis class="po-inline e393 e393" role="ital"><emphasis class="po-inline e394 e394" role="bold"><textual class="po-textual">Rule #1: control information is placed in top-level control items</textual></emphasis></emphasis></para><para class="po-block e395 e395"><textual class="po-textual">
        Control information is contained by top-level control items. Each result item is either a data item or a control item. 
        Data and control information is never mixed within result items.
      </textual></para><para class="po-block e396 e396"><emphasis class="po-inline e397 e397" role="ital"><emphasis class="po-inline e398 e398" role="bold"><textual class="po-textual">Rule #2: special control items define information units</textual></emphasis></emphasis></para><para class="po-block e399 e399"><textual class="po-textual">
        Each information unit created by the query is defined by a control item (</textual><code class="po-atom e400 e400"><textual class="po-textual">&lt;xqjp:part&gt;</textual></code><textual class="po-textual"> element) which specifies 
        all unit properties: name, meta information, type (physical, semantic, implementation types). Exceptions to this 
        rule are units defined to be an info tray. The assembly of such complex units is discussed in a special section.
      </textual></para><para class="po-block e401 e401"><emphasis class="po-inline e402 e402" role="ital"><emphasis class="po-inline e403 e403" role="bold"><textual class="po-textual">Rule #3: the source data belonging to an information unit follow the unit’s definition</textual></emphasis></emphasis></para><para class="po-block e404 e404"><textual class="po-textual">
        The source data belonging to a unit are given by all the result items which immediately 
        </textual><emphasis class="po-inline e405 e405" role="ital"><textual class="po-textual">follow</textual></emphasis><textual class="po-textual"> the unit-defining control item and come before the 
        next control item. So the basic structure of a query result generating an 
        info tray looks like this:
        </textual><programlisting class="po-block e406 e406" xml:space="preserve"><textual class="po-textual">...
&lt;xqjp:part name="x" type="..."/&gt;,
- source data items for unit "x",

&lt;xqjp:part name="y" type="..."/&gt;,
- source data items for unit "y",

&lt;xqjp:part name="z" type="..."/&gt;,
- source data items for unit "z",
...</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e407 e407"><textual class="po-textual">
        Two exceptions to the rule are units which are themselves info trays and unit definitions 
        which reference control variables (see next section).
      </textual></para><para class="po-block e408 e408"><textual class="po-textual">
         </textual><emphasis class="po-inline e409 e409" role="ital"><textual class="po-textual">Note:</textual></emphasis><textual class="po-textual"> For a comprehensive list of all control items
         defined by XQJPLUS, see </textual><xref class="po-milestone e410 e410" linkend="The-control-items"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      </textual></para></section><section class="po-hcontainer e411 e411" xml:id="The-assembly-process-advanced"><title class="po-block e412 e412"><textual class="po-textual">The assembly process - advanced</textual></title><para class="po-block e413 e413"><emphasis class="po-inline e414 e414" role="ital"><emphasis class="po-inline e415 e415" role="bold"><textual class="po-textual">Namespace context</textual></emphasis></emphasis></para><para class="po-block e416 e416"><textual class="po-textual">
        Unit assembly is often controlled by XPath expressions. The namespace context in which
        to evaluate those expressions is created by special control items. Example:
        </textual><programlisting class="po-block e417 e417" xml:space="preserve"><textual class="po-textual">
&lt;xqjp:setNamespaceContext&gt;
   &lt;xqjp:binding prefix="data" uri="http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/"/&gt;
   &lt;xqjp:binding prefix="eval" uri="http://www.bits-ac.com/usgs"/&gt;
&lt;/xqjp:setNamespaceContext&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e418 e418"><emphasis class="po-inline e419 e419" role="ital"><emphasis class="po-inline e420 e420" role="bold"><textual class="po-textual">Control variables</textual></emphasis></emphasis></para><para class="po-block e421 e421"><textual class="po-textual">
        Since the data items of the query result are the source data for 
        unit assembly, you may want to </textual><emphasis class="po-inline e422 e422" role="ital"><emphasis class="po-inline e423 e423" role="bold"><textual class="po-textual">reuse
        </textual></emphasis></emphasis><textual class="po-textual"> source data in the assembly of different units. A simple example 
        is a query which produces two string-to-string maps, where the second interchanges the 
        keys and values used by the first – for example a “code2text” map and a “text2code” map. To 
        achieve this without repeating the source data one may use control variables. A control 
        variable is declared by a special control item (</textual><code class="po-atom e424 e424"><textual class="po-textual">&lt;xqjp:setVar&gt;</textual></code><textual class="po-textual">), which specifies 
        a name and minimal type information (atomic or node, single value or sequence). During the 
        assembly process, all data items following the declaration and preceding the next control 
        item are bound to a variable of the declared name. Thereafter, they can be referenced 
        by unit-defining control items (</textual><code class="po-atom e425 e425"><textual class="po-textual">&lt;xqjp:part&gt;</textual></code><textual class="po-textual">) via a special attribute (“source”). 
        The following XQuery code illustrates this possibility by generating two maps backed by 
        the same data item. Map “activity2time” is string-to-string, whereas the inverse map 
        “time2activity” is string-to-string[]. Both maps are assembled from the contents of 
        control variable “activityDates”.
      </textual></para><para class="po-block e426 e426"><textual class="po-textual">
        </textual><programlisting class="po-block e427 e427" xml:space="preserve"><textual class="po-textual">(: set variable "activityDates" 
 : ============================ :)
&lt;xqjp:setVar name="activityDates" vtype="node" /&gt;,

&lt;activityDates&gt;{
   for $date in distinct-values(//ActivityStartDate)
   let $activities := //ActivityStartDate[. eq $date]/../ActivityIdentifier
   return 
      &lt;activityDate date="{$date}"&gt;{$activities}&lt;/activityDate&gt;
}&lt;/activityDates&gt;,

(: define information units 
 : ======================== :)
&lt;xqjp:part name="time2activities" 
           type="map_string_to_strings_object" 
           sematype="wq:timeActivities"
           impltype="java.util.TreeMap"
           source="$activityDates"
           entryPath="activityDate"
           keyPath="@date"
           valuePath="ActivityIdentifier" /&gt;,
&lt;xqjp:part name="activity2time" 
           type="map_string_to_string_object" 
           sematype="wq:activityTimes"
           source="$activityDates"
           entryPath="activityDate/ActivityIdentifier"
           keyPath="."
           valuePath="../@date" /&gt;</textual></programlisting><textual class="po-textual">        
      </textual></para><para class="po-block e428 e428"><emphasis class="po-inline e429 e429" role="ital"><emphasis class="po-inline e430 e430" role="bold"><textual class="po-textual">Information units that are themselves trays</textual></emphasis></emphasis></para><para class="po-block e431 e431"><textual class="po-textual">
        As an information unit may itself be an info tray, the result item stream must somehow 
        delimit the begin and end of such an embedded tray. To do so, use a </textual><code class="po-atom e432 e432"><textual class="po-textual">&lt;xqjp:complexPartBegin&gt;
        </textual></code><textual class="po-textual"> and a </textual><code class="po-atom e433 e433"><textual class="po-textual">&lt;xqjp:complexPartEnd&gt;</textual></code><textual class="po-textual"> control item. As an embedded tray is an 
        information unit, the begin marker also plays the role of a unit-defining item. It must 
        specify the unit name and may specify a semantic type and meta data, just like any other unit-defining item.
      </textual></para></section><section class="po-hcontainer e434 e434"><title class="po-block e435 e435"><textual class="po-textual">The assembly process - how XQuery constructs Java custom objects</textual></title><para class="po-block e436 e436"><textual class="po-textual">
         As mentioned before, an information unit may contain custom objects, that is, objects of a type which is not a Java 
         standard type. Here are a few physical types involving custom objects:
        </textual><variablelist class="po-table e437 e437"><varlistentry class="po-record e438 e438"><term class="po-block e439 e439"><textual class="po-textual">custom_object</textual></term><listitem class="po-container e440 e440"><para class="po-block e441 e441"><textual class="po-textual">single custom object</textual></para></listitem></varlistentry><varlistentry class="po-record e442 e442"><term class="po-block e443 e443"><textual class="po-textual">custom_objects</textual></term><listitem class="po-container e444 e444"><para class="po-block e445 e445"><textual class="po-textual">an array of custom objects</textual></para></listitem></varlistentry><varlistentry class="po-record e446 e446"><term class="po-block e447 e447"><textual class="po-textual">map_string_to_custom_object_object</textual></term><listitem class="po-container e448 e448"><para class="po-block e449 e449"><textual class="po-textual">a string-to-customObject map</textual></para></listitem></varlistentry><varlistentry class="po-record e450 e450"><term class="po-block e451 e451"><textual class="po-textual">map_string_to_custom_object_objects</textual></term><listitem class="po-container e452 e452"><para class="po-block e453 e453"><textual class="po-textual">an array of string-to-customObject maps</textual></para></listitem></varlistentry><varlistentry class="po-record e454 e454"><term class="po-block e455 e455"><textual class="po-textual">nested_map_string_to_custom_object_object</textual></term><listitem class="po-container e456 e456"><para class="po-block e457 e457"><textual class="po-textual">a string-to-(string-to-customObject) map</textual></para></listitem></varlistentry></variablelist><textual class="po-textual">        
      </textual></para><para class="po-block e458 e458"><textual class="po-textual">
        Presently, XQJPLUS allows only those types as custom types which implement the interface 
        </textual><code class="po-atom e459 e459"><textual class="po-textual">LoadableFromXML</textual></code><textual class="po-textual">. This interface is defined in the main package of 
        XQJPLUS and contains a single method signature:
        </textual><programlisting class="po-block e460 e460" xml:space="preserve"><textual class="po-textual">void loadFromXML(Node source);</textual></programlisting><textual class="po-textual">        
      </textual></para><para class="po-block e461 e461"><textual class="po-textual">
        An underlying assumption is that the objects can be built in a two-step way, first instantiating them using a 
        parameter-less default constructor, then calling the load method. Later versions of XQJPLUS may support 
        other categories of custom types which can be constructed using different interfaces.
      </textual></para><para class="po-block e462 e462"><textual class="po-textual">
        The actual custom type is a special construction attribute ( “customType”). This construction attribute is 
        always required if the physical type involves custom objects. Example:
        </textual><programlisting class="po-block e463 e463" xml:space="preserve"><textual class="po-textual">&lt;xqjp:part name="placeObjects" 
           type="custom_objects"
           customType="com.bits_ac.xqjplus.appl.Place"
/&gt;,</textual></programlisting><textual class="po-textual">        
      </textual></para><para class="po-block e464 e464"><textual class="po-textual">
        The query code has to provide the data source in the usual way, that is, either by subsequent data items or 
        using the “source” attribute. The XML nodes to be used for loading the custom objects must of course provide 
        the XML data structure expected by the particular custom type’s “loadFromXML” method.
      </textual></para></section><section class="po-hcontainer e465 e465"><title class="po-block e466 e466"><textual class="po-textual">Meta data</textual></title><para class="po-block e467 e467"><textual class="po-textual">
         An information unit is associated with meta data, which are a set of named values. The names are QNames, and
         the values are strings. The meta data fall into two groups: 
         </textual><itemizedlist class="po-table e468 e468"><listitem class="po-container e469 e469"><para class="po-block e470 e470"><emphasis class="po-inline e471 e471" role="ital"><textual class="po-textual">standard meta data</textual></emphasis><textual class="po-textual"> have XQJPLUS-defined semantics</textual></para></listitem><listitem class="po-container e472 e472"><para class="po-block e473 e473"><emphasis class="po-inline e474 e474" role="ital"><textual class="po-textual">custom meta data</textual></emphasis><textual class="po-textual"> have custom semantics</textual></para></listitem></itemizedlist><textual class="po-textual">
       </textual></para><para class="po-block e475 e475"><textual class="po-textual">
        Most standard meta data are automatically assigned by XQJPLUS. Custom meta data are always assigned by the 
        unit-defining control item.
      </textual></para><para class="po-block e476 e476"><emphasis class="po-inline e477 e477" role="ital"><emphasis class="po-inline e478 e478" role="bold"><textual class="po-textual">Custom meta data</textual></emphasis></emphasis></para><para class="po-block e479 e479"><textual class="po-textual">
        Associating a unit with custom meta data is straightforward: they are specified either as attributes or as child 
        elements of the unit-defining control item (</textual><code class="po-atom e480 e480"><textual class="po-textual">&lt;xqjp:part&gt;</textual></code><textual class="po-textual"> or 
        </textual><code class="po-atom e481 e481"><textual class="po-textual">&lt;xqjp:complexPartBegin&gt;</textual></code><textual class="po-textual">). The name of a meta data item is the respective attribute’s or 
        element’s name; the value is its string value. If a meta data item is specified by an attribute, the 
        attribute name must have a non-empty namespace URI. If a meta data item is specified as a child element, the 
        element name may or may not be in a namespace.
      </textual></para><para class="po-block e482 e482"><textual class="po-textual">
        The following example demonstrates the use of both, attributes and child elements:
        </textual><programlisting class="po-block e483 e483" xml:space="preserve"><textual class="po-textual">&lt;xqjp:part name="startDates" 
           type="string_sortedset_object" 
           sematype="usgs:activityStartTimes"
           bi:cr="{current-date()}" &gt;
    &lt;bi:min&gt;{min($startDates)}&lt;/bi:min&gt;
    &lt;bi:max&gt;{max($startDates)}&lt;/bi:max&gt;
    &lt;meta:documentation&gt;The activity start dates, as reported by the NWIS result 
    service.&lt;/meta:documentation&gt;
&lt;/xqjp:part&gt;,)</textual></programlisting><textual class="po-textual">        
      </textual></para><para class="po-block e484 e484"><textual class="po-textual">
        The definition of unit “startDates” specifies three custom meta data items (“cr”, “min” and “max”) and a 
        standard meta data item “documentation”.
      </textual></para><para class="po-block e485 e485"><emphasis class="po-inline e486 e486" role="ital"><emphasis class="po-inline e487 e487" role="bold"><textual class="po-textual">Standard meta data</textual></emphasis></emphasis></para><para class="po-block e488 e488"><textual class="po-textual">
        Standard meta data have a name in the namespace “http://www.bits-ac.com/xqjplus/meta”. With the exception of 
        “documentation”, which is provided by the query in the same way as custom meta data, standard meta data are 
        automatically assigned by XQJPLUS when transforming a query result into an info tray. Currently, there are four 
        kinds of automatically assigned standard meta data: “length” and the three type specifications “ptype”, “stype”, 
        “itype”.
      </textual></para><para class="po-block e489 e489"><emphasis class="po-inline e490 e490" role="ital"><emphasis class="po-inline e491 e491" role="bold"><textual class="po-textual">Standard meta data item “length”</textual></emphasis></emphasis></para><para class="po-block e492 e492"><textual class="po-textual">
        It contains the number of objects contained by the unit: if the unit has an array type, it is the number of array items, 
        otherwise it is “1” or “0” depending on whether the unit actually contains data or is empty.
      </textual></para><para class="po-block e493 e493"><emphasis class="po-inline e494 e494" role="ital"><emphasis class="po-inline e495 e495" role="bold"><textual class="po-textual">Standard meta data “ptype”, “stype”, “itype”</textual></emphasis></emphasis></para><para class="po-block e496 e496"><textual class="po-textual">
        They contain the names of physical type, semantic type and implementation type, respectively. So the type information 
        is available as meta data.
      </textual></para><para class="po-block e497 e497"><textual class="po-textual">
        </textual><emphasis class="po-inline e498 e498" role="ital"><emphasis class="po-inline e499 e499" role="bold"><textual class="po-textual">Note.</textual></emphasis></emphasis><textual class="po-textual"> The implementation type can be 
        specified by the unit-defining control item, using attribute “impltype”. Strictly speaking, this is not meta data 
        information, but assembly control information. Therefore the value of “itype” may depend on the query text, 
        although it is automatically assigned.
      </textual></para></section></section><section class="po-hcontainer e500 e500" xml:id="Information-tray"><title class="po-block e501 e501"><textual class="po-textual">Information tray (info tray)</textual></title><para class="po-block e502 e502"><textual class="po-textual">
      When an information unit is created, it is placed on an information tray (info tray). 
      This section introduces info trays. After defining the concept, the information flow into and out of the tray is described: 
      the loading of a tray with information units, and the reading of units contained by the tray. The final subsection 
      introduces tray-level meta data.
    </textual></para><section class="po-hcontainer e503 e503"><title class="po-block e504 e504"><textual class="po-textual">Concept</textual></title><para class="po-block e505 e505"><textual class="po-textual">
         An info tray is a collection of information units. Viewed as a component, its only properties are 
         </textual><itemizedlist class="po-table e506 e506"><listitem class="po-container e507 e507"><para class="po-block e508 e508"><textual class="po-textual">
               a partially ordered list of information units
             </textual></para></listitem><listitem class="po-container e509 e509"><para class="po-block e510 e510"><textual class="po-textual">
               tray-level meta data
             </textual></para></listitem><listitem class="po-container e511 e511"><para class="po-block e512 e512"><textual class="po-textual">
               an optional resource ID
             </textual></para></listitem></itemizedlist><textual class="po-textual">
        The list of </textual><emphasis class="po-inline e513 e513" role="ital"><textual class="po-textual">information units</textual></emphasis><textual class="po-textual"> 
        is partially ordered, as the order of two information units is irrelevant if they have 
        different names, but relevant if they have the same name. </textual><emphasis class="po-inline e514 e514" role="ital"><textual class="po-textual">Meta data</textual></emphasis><textual class="po-textual">
        are a set of named string values providing information about the tray.
        The </textual><emphasis class="po-inline e515 e515" role="ital"><textual class="po-textual">resource ID</textual></emphasis><textual class="po-textual"> is a QName identifying the tray instance 
        within a set of tray instances.  
      </textual></para><para class="po-block e516 e516"><textual class="po-textual">
        The info tray concept is independent of the mechanisms of loading the tray. XQJPLUS represents the
        general concept of an info tray by a class </textual><code class="po-atom e517 e517"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual">; and it models the loading from 
        an XQuery result by providing a subclass of </textual><code class="po-atom e518 e518"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> implementing such a loading method. Other 
        subclasses of </textual><code class="po-atom e519 e519"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> might be developed which load the tray from, say, an XSLT or XProc result, 
        or a set of delimited files or yet other kinds of data sources. Note that the read access methods are all harboured 
        by the </textual><code class="po-atom e520 e520"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> level, as they reference only the assembled information units, never any information 
        about the assembly process. In consequence, once the tray is loaded the actual loading mechanism is 
        invisible from the Java perspective and may be replaced at any time. 
      </textual></para><para class="po-block e521 e521"><textual class="po-textual">
        The interface of an info tray contains 
        </textual><itemizedlist class="po-table e522 e522"><listitem class="po-container e523 e523"><para class="po-block e524 e524"><textual class="po-textual">
              a method for </textual><emphasis class="po-inline e525 e525" role="ital"><textual class="po-textual">loading</textual></emphasis><textual class="po-textual"> the information units from a data source
            </textual></para></listitem><listitem class="po-container e526 e526"><para class="po-block e527 e527"><textual class="po-textual">
              methods for </textual><emphasis class="po-inline e528 e528" role="ital"><textual class="po-textual">adding</textual></emphasis><textual class="po-textual"> information units
            </textual></para></listitem><listitem class="po-container e529 e529"><para class="po-block e530 e530"><textual class="po-textual">
              methods for </textual><emphasis class="po-inline e531 e531" role="ital"><textual class="po-textual">reading</textual></emphasis><textual class="po-textual"> information units
            </textual></para></listitem><listitem class="po-container e532 e532"><para class="po-block e533 e533"><textual class="po-textual">a method for </textual><emphasis class="po-inline e534 e534" role="ital"><textual class="po-textual">validating</textual></emphasis><textual class="po-textual"> the info tray against a tray schema</textual></para></listitem></itemizedlist><textual class="po-textual">
        The validation of an info tray will be dealt with in </textual><xref class="po-milestone e535 e535" linkend="Tray-validation"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      </textual></para></section><section class="po-hcontainer e536 e536"><title class="po-block e537 e537"><textual class="po-textual">The load process</textual></title><para class="po-block e538 e538"><textual class="po-textual">
         An info tray is loaded by adding information units one by one. The intended pattern is to let subclasses of
         </textual><code class="po-atom e539 e539"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> define a data source-specific load method which assembles the units in a source-specific 
         way and adds them to the tray by calling the base class’s </textual><code class="po-atom e540 e540"><textual class="po-textual">add</textual></code><textual class="po-textual"> methods.
       </textual></para><para class="po-block e541 e541"><emphasis class="po-inline e542 e542" role="ital"><emphasis class="po-inline e543 e543" role="bold"><code class="po-atom e544 e544"><textual class="po-textual">add</textual></code><textual class="po-textual"> methods</textual></emphasis></emphasis></para><para class="po-block e545 e545"><textual class="po-textual">
        The source-specific loading is made as simple as possible by arming </textual><code class="po-atom e546 e546"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> with a
        comprehensive set of source-independent </textual><code class="po-atom e547 e547"><textual class="po-textual">add</textual></code><textual class="po-textual"> methods. These methods receive a unit's completely assembled 
        data content, along with meta data and unit name. For each supported physical type, there is a 
        special </textual><code class="po-atom e548 e548"><textual class="po-textual">add</textual></code><textual class="po-textual"> method. Some examples:
        </textual><programlisting class="po-block e549 e549" xml:space="preserve"><textual class="po-textual">void addString(String partName, 
               String content, 
               Map&lt;String,String&gt; meta);

void addStrings(String partName, 
                String[] content, 
                Map&lt;String,String&gt; meta);

void addMapString2Node(String partName, 
                       Map&lt;String,Node&gt; content, 
                       Map&lt;String,String&gt; meta);</textual></programlisting><textual class="po-textual">
        </textual><emphasis class="po-inline e550 e550" role="ital"><emphasis class="po-inline e551 e551" role="bold"><textual class="po-textual">Note</textual></emphasis></emphasis><textual class="po-textual">: the semantic type is communicated 
        as a meta data item, while the physical type is implied by the choice of the method and the implementation type is 
        determined by the actual content.
      </textual></para><para class="po-block e552 e552"><emphasis class="po-inline e553 e553" role="ital"><emphasis class="po-inline e554 e554" role="bold"><textual class="po-textual">load methods</textual></emphasis></emphasis></para><para class="po-block e555 e555"><textual class="po-textual">
        Source-dependent load methods are defined by subclasses of </textual><code class="po-atom e556 e556"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual">. XQJPLUS provides 
        the subclass </textual><code class="po-atom e557 e557"><textual class="po-textual">XQueryResponse</textual></code><textual class="po-textual">, defining a method
        </textual><programlisting class="po-block e558 e558" xml:space="preserve"><textual class="po-textual">void loadXQuerySequence(XQSequence seq);</textual></programlisting><textual class="po-textual">
        The method iterates over the result sequence, assembling information units as defined by the control items 
        and adding them to the tray by calling the base class’s </textual><code class="po-atom e559 e559"><textual class="po-textual">add</textual></code><textual class="po-textual"> methods.
      </textual></para></section><section class="po-hcontainer e560 e560" xml:id="read-access"><title class="po-block e561 e561"><textual class="po-textual">Read access</textual></title><para class="po-block e562 e562"><textual class="po-textual">
         The info tray offers convenient read access to its information units. Access is always to one unit at a time. 
         The access to a unit can be grouped as follows:
         </textual><itemizedlist class="po-table e563 e563"><listitem class="po-container e564 e564"><para class="po-block e565 e565"><textual class="po-textual">reading the unit contents</textual></para></listitem><listitem class="po-container e566 e566"><para class="po-block e567 e567"><textual class="po-textual">reading the unit type information</textual></para></listitem><listitem class="po-container e568 e568"><para class="po-block e569 e569"><textual class="po-textual">reading the unit meta data</textual></para></listitem></itemizedlist><textual class="po-textual">
       </textual></para><para class="po-block e570 e570"><textual class="po-textual">
        The unit is usually specified by name – see below for details.
      </textual></para><para class="po-block e571 e571"><emphasis class="po-inline e572 e572" role="ital"><emphasis class="po-inline e573 e573" role="bold"><textual class="po-textual">reading the unit contents</textual></emphasis></emphasis></para><para class="po-block e574 e574"><textual class="po-textual">
        For each supported physical type of information units, there is an access method returning an instance 
        of the physical type and accepting as input a unit name. (Use Clark notation for names in a namespace.)
        When there are several units with that name, the first is delivered. Examples for methods reading unit contents:
        </textual><programlisting class="po-block e575 e575" xml:space="preserve"><textual class="po-textual">
String        getString(String name);
String[]      getStrings(String name);
Node          getNode(String name);
Node[]        getNodes(String name);
Properties    getPropertiesObject(String name);
Properties[]  getPropertiesObjects(String name);
Object        getCustomObject(String name);
InfoTray      getInfoTray(String name);
Map&lt;String,String&gt;     getMapString2StringObject(String name);
Map&lt;String,String[]&gt;   getMapString2StringsObject(String name);
Map&lt;String,String[]&gt;[] getMapString2StringsObjects(String name);</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e576 e576"><textual class="po-textual">
        A tray may indeed contain several units with the same name. In order to retrieve them, first 
        obtain a cursor and then use it to iterate over those units. The code can rely on all units with 
        a common name to have the same physical type, as a violation of this constraint would be detected during tray 
        loading and generate an exception. In the following example code, the common physical type is a single node:
        </textual><programlisting class="po-block e577 e577" xml:space="preserve"><textual class="po-textual">
InfoTrayCursor cursor = getCursorByPartName("laboratory");
while (cursor.hasNext()) {
   Node currentUnit = getNode(cursor.next());
   // process the contents …
}</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e578 e578"><textual class="po-textual">
        This pattern is based on the fact that for each physical type there is a second read method
        expecting a unit index as input, rather than a unit name. The unit index is a non-negative number
        identifying the unit within the tray independently of its name. 
      </textual></para><para class="po-block e579 e579"><textual class="po-textual">
        </textual><emphasis class="po-inline e580 e580" role="ital"><textual class="po-textual">Note:</textual></emphasis><textual class="po-textual"> When using a unit name repeatedly, each unit with that name 
        has its own meta data, just like any other unit.
      </textual></para><para class="po-block e581 e581"><emphasis class="po-inline e582 e582" role="ital"><emphasis class="po-inline e583 e583" role="bold"><textual class="po-textual">reading the unit type information</textual></emphasis></emphasis></para><para class="po-block e584 e584"><textual class="po-textual">
        The info tray offers separate methods for reading a unit’s physical, semantic or implementation type. Only name-based 
        access is offered, as the type information must not vary between units which have the same name.
      </textual></para><para class="po-block e585 e585"><emphasis class="po-inline e586 e586" role="ital"><emphasis class="po-inline e587 e587" role="bold"><textual class="po-textual">reading the unit meta data</textual></emphasis></emphasis></para><para class="po-block e588 e588"><textual class="po-textual">
        Unit meta data can be retrieved on bloc as a </textual><code class="po-atom e589 e589"><textual class="po-textual">Map&lt;String,String&gt;</textual></code><textual class="po-textual">, on bloc as a 
        </textual><code class="po-atom e590 e590"><textual class="po-textual">Map&lt;QName,String&gt;</textual></code><textual class="po-textual"> or itemwise, specifying the meta data item name as a QName 
        or a Clark string. As when reading unit content, the unit is identified either by name or by passing a cursor.
      </textual></para><para class="po-block e591 e591"><emphasis class="po-inline e592 e592" role="ital"><emphasis class="po-inline e593 e593" role="bold"><textual class="po-textual">reading tray meta data</textual></emphasis></emphasis></para><para class="po-block e594 e594"><textual class="po-textual">
        Tray meta data are retrieved in a similar way as unit meta data. 
      </textual></para></section><section class="po-hcontainer e595 e595"><title class="po-block e596 e596"><textual class="po-textual">Meta data</textual></title><para class="po-block e597 e597"><textual class="po-textual">
         Not only the individual information units are associated with meta data, but also the info tray as a whole (and  
         implicitly, also any info shape generated for the info tray). Standard meta data are distinguished from custom 
         meta data.
       </textual></para><para class="po-block e598 e598"><emphasis class="po-inline e599 e599" role="ital"><emphasis class="po-inline e600 e600" role="bold"><textual class="po-textual">Custom meta data</textual></emphasis></emphasis></para><para class="po-block e601 e601"><textual class="po-textual">
        Tray-level custom meta data are specified via a dedicated control item (</textual><code class="po-atom e602 e602"><textual class="po-textual">&lt;xqjp:trayMeta&gt;</textual></code><textual class="po-textual">). The mapping of attributes and 
         child elements to meta data items is the same as with unit-related meta data.
      </textual></para><para class="po-block e603 e603"><emphasis class="po-inline e604 e604" role="ital"><emphasis class="po-inline e605 e605" role="bold"><textual class="po-textual">Standard meta data</textual></emphasis></emphasis></para><para class="po-block e606 e606"><textual class="po-textual">
        The namespace of tray-level standard meta data is the same as of unit-level ones. Two standard meta data items can be 
        specified by the query – “documentation” and “name”. The latter is meant to identify the specific type of a tray created by 
        a specific query, comparable to the name of an XML document’s root element. Other standard meta data items are 
        assigned automatically. These are:
        </textual><itemizedlist class="po-table e607 e607"><listitem class="po-container e608 e608"><para class="po-block e609 e609"><textual class="po-textual">“length” specifies the number of top-level units</textual></para></listitem><listitem class="po-container e610 e610"><para class="po-block e611 e611"><textual class="po-textual">“unitNames” is the sorted set of top-level unit names, rendered as a white-space separated list</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para></section></section><section class="po-hcontainer e612 e612" xml:id="Tray-schema"><title class="po-block e613 e613"><textual class="po-textual">Tray schema</textual></title><para class="po-block e614 e614"><textual class="po-textual">
      Like an XML document, an info tray has a structure that can be described independently of the actual data 
      content. XQJPLUS supplies a simple XML vocabulary that can be used to specify a tray schema which may 
      (a) constrain the tray structure, (b) control the generation of an </textual><emphasis class="po-inline e615 e615" role="bold"><textual class="po-textual">
      </textual><emphasis class="po-inline e616 e616" role="ital"><textual class="po-textual">info shape</textual></emphasis></emphasis><textual class="po-textual">, which is Java code offering enhanced 
      safety and convenience of data access. An info shape consists of a Java class
      plus interfaces representing an info tray with a specific structure.
    </textual></para><section class="po-hcontainer e617 e617"><title class="po-block e618 e618"><textual class="po-textual">Purpose</textual></title><para class="po-block e619 e619"><textual class="po-textual">
        There are three main purposes for creating a tray schema:
        </textual><itemizedlist class="po-table e620 e620"><listitem class="po-container e621 e621"><para class="po-block e622 e622"><textual class="po-textual">to facilitate the cooperation between Java developer and XQuery developer</textual></para></listitem><listitem class="po-container e623 e623"><para class="po-block e624 e624"><textual class="po-textual">to validate a tray instance, e.g. before starting to use it</textual></para></listitem><listitem class="po-container e625 e625"><para class="po-block e626 e626"><textual class="po-textual">to generate an info shape</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e627 e627"><emphasis class="po-inline e628 e628" role="ital"><emphasis class="po-inline e629 e629" role="bold"><textual class="po-textual">Constraining the tray structure</textual></emphasis></emphasis></para><para class="po-block e630 e630"><textual class="po-textual">
        To constrain the tray structure, the following kinds of information can be expressed:
        </textual><itemizedlist class="po-table e631 e631"><listitem class="po-container e632 e632"><para class="po-block e633 e633"><textual class="po-textual">the names and types of contained information units</textual></para></listitem><listitem class="po-container e634 e634"><para class="po-block e635 e635"><textual class="po-textual">cardinality constraints referring to the repeated use of unit names</textual></para></listitem><listitem class="po-container e636 e636"><para class="po-block e637 e637"><textual class="po-textual">cardinality constraints referring to the contents of units</textual></para></listitem><listitem class="po-container e638 e638"><para class="po-block e639 e639"><textual class="po-textual">meta data constraints (tray-level and unit-level meta data)</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e640 e640"><emphasis class="po-inline e641 e641" role="ital"><emphasis class="po-inline e642 e642" role="bold"><textual class="po-textual">Controlling the Java binding</textual></emphasis></emphasis></para><para class="po-block e643 e643"><textual class="po-textual">
        If the tray is used as input for generating Java code (or other language code), the tray schema must contain further 
        information controlling the language binding. In case of Java code, this consists of class and interface names, 
        as well as a distribution of the unit names over the supporting interfaces.
      </textual></para></section><section class="po-hcontainer e644 e644" xml:id="Tray-schema-example"><title class="po-block e645 e645"><textual class="po-textual">A simple example</textual></title><para class="po-block e646 e646"><textual class="po-textual">
          Here is a minimal schema from which the info shape demonstrated in 
          </textual><xref class="po-milestone e647 e647" linkend="Obtaining-via-info-shape"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> was generated:
          </textual><programlisting class="po-block e648 e648" xml:space="preserve"><textual class="po-textual">
&lt;ts:traySchema xmlns:ts="http://www.bits-ac.com/xqjplus/traySchema"
               xmlns:java="http://www.bits-ac.com/xqjplus/traySchema/java-binding"&gt;

   &lt;!-- ============== --&gt;
   &lt;!-- tray structure --&gt;
   &lt;!-- ============== --&gt;

   &lt;ts:tray&gt;
      &lt;ts:part name="fractionResults" type="nested_map_string_to_strings_object" /&gt;
      &lt;ts:part name="activityResults" type="map_string_to_custom_objects_object" 
               customType="com.bits_ac.xqjplus.appl.UsgsResult" /&gt;
      &lt;ts:part name="projectIds" type="string_sortedset_object" /&gt;      
      &lt;ts:part name="projectActivities" type="nested_map_string_to_string_object" /&gt;
   &lt;/ts:tray&gt;

   &lt;!-- ============ --&gt;
   &lt;!-- Java binding --&gt;
   &lt;!-- ============ --&gt;

   &lt;!-- implementation class --&gt;
   &lt;java:trayBinding className="ResultReport" 
                     package="com.bits_ac.xqjplus.appl" &gt;

   &lt;!-- interfaces --&gt;
      &lt;java:iface name="ResultData" package="com.bits_ac.xqjplus.appl"&gt;
         &lt;java:part ref="fractionResults"/&gt;
         &lt;java:part ref="activityResults"/&gt;
      &lt;/java:iface&gt;

      &lt;java:iface name="ProjectData" package="com.bits_ac.xqjplus.appl"&gt;
         &lt;java:part ref="projectIds"/&gt;
         &lt;java:part ref="projectActivities"/&gt;
      &lt;/java:iface&gt;
   &lt;/java:trayBinding&gt;

   &lt;!-- mapping customType =&gt; className --&gt;
   &lt;java:customTypeBindings&gt;
      &lt;java:customTypeBinding customType=".*" className="$1"/&gt;
   &lt;/java:customTypeBindings&gt;
&lt;/ts:traySchema&gt;</textual></programlisting><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e649 e649"><title class="po-block e650 e650"><textual class="po-textual">Constraining meta data</textual></title><para class="po-block e651 e651"><textual class="po-textual">
          The structure part of the tray schema shown above is minimal, as it does not constrain the 
          use of meta data. Meta data can be constrained by
          </textual><itemizedlist class="po-table e652 e652"><listitem class="po-container e653 e653"><para class="po-block e654 e654"><textual class="po-textual">stating names of mandatory meta data</textual></para></listitem><listitem class="po-container e655 e655"><para class="po-block e656 e656"><textual class="po-textual">constraining the values of meta data items</textual></para></listitem><listitem class="po-container e657 e657"><para class="po-block e658 e658"><textual class="po-textual">excluding the use of other meta data names apart from the schema-specified names</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e659 e659"><textual class="po-textual">
        The following example adds more constraints:
        </textual><programlisting class="po-block e660 e660" xml:space="preserve"><textual class="po-textual">&lt;ts:part name="projectIds" type="string_sortedset_object" 
      unitOccurs="+" 
      contentOccurs="?"&gt;
   &lt;ts:meta name="bi:priorityRemark" use="required" /&gt;
   &lt;ts:meta name="bi:projectCodeList" use="required" &gt;
      &lt;ts:enumeration value="internal"/&gt;
      &lt;ts:enumeration value="external"/&gt;
   &lt;/ts:meta&gt;
   &lt;ts:meta name="bi:source" use="optional"&gt;
      &lt;ts:pattern value="usgs-..-\d{8}.xml"/&gt;
   &lt;/ts:meta&gt;
&lt;/ts:part&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e661 e661"><textual class="po-textual">
        The “unitOccurs” attribute (which defaults to “1”) specifies that the tray may contain more than one unit with 
        name “projectIds”. According to “contentOccurs” (also defaulting to “1”), each unit may contain zero or 
        one data items. (Note that non-array physical types can have only “?” or “1” as value of “contentOccurs”.)  
        Two meta data items are mandatory (“bi:priorityRemark” and “bi:projectCodeList”), for one of which 
        value constraints are specified. The meta data item “bi:source” is optional, but when it occurs it 
        must match the specified constraint.
      </textual></para><para class="po-block e662 e662"><textual class="po-textual">
        By default, meta data are “open” – there may be more meta data than specified in the tray schema. To exclude 
        this possibility, use the attribute “metaClosed" with a value of "true" on the </textual><code class="po-atom e663 e663"><textual class="po-textual">&lt;ts:part&gt;</textual></code><textual class="po-textual"> element.
      </textual></para></section><section class="po-hcontainer e664 e664" xml:id="Tray-validation"><title class="po-block e665 e665"><textual class="po-textual">Tray validation</textual></title><para class="po-block e666 e666"><textual class="po-textual">
      The </textual><code class="po-atom e667 e667"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> class offers a method </textual><code class="po-atom e668 e668"><textual class="po-textual">validate</textual></code><textual class="po-textual">, which validates the tray contents against a tray 
      schema. Note that this validation ignores all schema parts relating to the language binding. If errors are detected, 
      the validation writes one or more </textual><code class="po-atom e669 e669"><textual class="po-textual">InfoTrayLoadingException</textual></code><textual class="po-textual"> units, so that after validation the
      diagnostics can be read from those units.
    </textual></para><para class="po-block e670 e670"><textual class="po-textual">
      The main purpose of validation is to support the development process. When the query has reached maturity, 
      it should guarantee to either deliver a tray that conforms to the agreed upon schema, or it should itself construct 
      </textual><code class="po-atom e671 e671"><textual class="po-textual">InfoTrayLoadingException</textual></code><textual class="po-textual"> units with appropriate diagnostics. In other words it should not leave the
      construction of exceptions to the validation. Following these steps for tray processing will help minimize problems:
      </textual><itemizedlist class="po-table e672 e672"><listitem class="po-container e673 e673"><para class="po-block e674 e674"><textual class="po-textual">
            </textual><emphasis class="po-inline e675 e675" role="ital"><textual class="po-textual">always</textual></emphasis><textual class="po-textual"> check for buffered exceptions before starting to 
            use the tray</textual></para></listitem><listitem class="po-container e676 e676"><para class="po-block e677 e677"><textual class="po-textual">in the pre-production phase call </textual><code class="po-atom e678 e678"><textual class="po-textual">validate</textual></code><textual class="po-textual"> before checking for buffered exceptions; 
            later this call can be removed
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e679 e679"><textual class="po-textual">
      Suggested sample code:
      </textual><programlisting class="po-block e680 e680" xml:space="preserve"><textual class="po-textual">tray.validate();                   // remove this line when the underlying query has matured …
if (tray.hasLoadingExceptions()) { // but ALWAYS check for buffered exceptions!
   for (InfoTrayLoadingException e: tray.getLoadingExceptions()) {
   // process exception ...
} else {
   // normal processing of tray contents ...
}</textual></programlisting><textual class="po-textual">
    </textual></para></section></section><section class="po-hcontainer e681 e681"><title class="po-block e682 e682"><textual class="po-textual">Info shape</textual></title><section class="po-hcontainer e683 e683"><title class="po-block e684 e684"><textual class="po-textual">Code generation</textual></title><para class="po-block e685 e685"><textual class="po-textual">
      Once a tray is constrained by a tray schema, the possible use of the tray is defined exactly, and exact 
      answers are implied to the following questions: 
      </textual><itemizedlist class="po-table e686 e686"><listitem class="po-container e687 e687"><para class="po-block e688 e688"><textual class="po-textual">which unit names are available</textual></para></listitem><listitem class="po-container e689 e689"><para class="po-block e690 e690"><textual class="po-textual">which physical type belongs to a given unit name</textual></para></listitem><listitem class="po-container e691 e691"><para class="po-block e692 e692"><textual class="po-textual">which meta data items can be expected</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e693 e693"><textual class="po-textual">
      If, for example, the tray schema determines that the unit name “projectIds” uses a physical type “strings”, then 
      it is clear that data retrieval for this unit name (a) is possible and  (b) must use the getter variant which delivers 
      a string array:
      </textual><programlisting class="po-block e694 e694" xml:space="preserve"><textual class="po-textual">String[] pnames = tray.getStrings (“projectNames“);</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e695 e695"><textual class="po-textual">
      To pass this unit name to a different getter method – say, the variant delivering a node – will 
      result in an exception. From here it is a small step to generate a Java class which exposes the 
      precise set of possible read methods, making their signatures error-proof by removing the name 
      parameter as a parameter and shifting it into the method name:
      </textual><programlisting class="po-block e696 e696" xml:space="preserve"><textual class="po-textual">String[] pnames = shape.getProjectNames();</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e697 e697"><textual class="po-textual">
      This way, the name and physical type of the unit have become inseparable, excluding mismatches. The 
      generated implementation of this method consists in a call of the generic tray method:
      </textual><programlisting class="po-block e698 e698" xml:space="preserve"><textual class="po-textual">public String[] getProjectNames() throws XQPException {
   return dataSource.getStrings("projectNames");
}</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e699 e699"><textual class="po-textual">
      Such code generation is supplied by the code generator of XQJPLUS. The code generator takes a tray schema as 
      input and produces an </textual><emphasis class="po-inline e700 e700" role="bold"><textual class="po-textual">info shape</textual></emphasis><textual class="po-textual">:
      a  query-specific class which is backed by an </textual><code class="po-atom e701 e701"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> member and defines 
      the specific access methods as described above. Along with this class, interfaces are generated according to the 
      directions given in the tray schema.
    </textual></para></section><section class="po-hcontainer e702 e702"><title class="po-block e703 e703"><textual class="po-textual">Info shape</textual></title><para class="po-block e704 e704"><textual class="po-textual">
      Whereas an info tray is a generic data container, an 
      </textual><emphasis class="po-inline e705 e705" role="ital"><textual class="po-textual">info shape</textual></emphasis><textual class="po-textual"> is a specific data container, reflecting 
      particular choices concerning the names and types of information units. Hence the name -
      it reflects the particular "shape" resulting from those choices. As described in the
      preceding section, info shapes are generated by the code generator of XQJPLUS.
    </textual></para><para class="po-block e706 e706"><textual class="po-textual">
      To give an example, the simple tray schema shown in </textual><xref class="po-milestone e707 e707" linkend="Tray-schema-example"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> 
      implies the following info shape:
      </textual><programlisting class="po-block e708 e708" xml:space="preserve"><textual class="po-textual">
public class ResultReport implements LoadableFromInfoTray, ResultData, ProjectData {
    protected InfoTray dataSource;
    ...
//data access
    public Map&lt;String,Map&lt;String,String[]&gt;&gt; getFractionResults()   throws XQPException {...}
    public Map&lt;String,UsgsResult[]&gt;         getActivityResults()   throws XQPException {...}
    public SortedSet&lt;String&gt;                getProjectIds()        throws XQPException {...}
    public Map&lt;String,Map&lt;String,String&gt;&gt;   getProjectActivities() throws XQPException {...}

//meta data access
    public Map&lt;String,String&gt; getFractionResultsMetaData()   throws XQPException {...}
    public Map&lt;String,String&gt; getActivityResultsMetaData()   throws XQPException {...}
    public Map&lt;String,String&gt; getProjectIdsMetaData()        throws XQPException {...}
    public Map&lt;String,String&gt; getProjectActivitiesMetaData() throws XQPException {...}

//deliver interfaces  
    public ResultData getInterfaceResultData() {...}
    public ProjectData getInterfaceProjectData() {...}
    ...
}</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e709 e709"><textual class="po-textual">
      The advantages for the Java developer are obvious – compiler-guarded access to the information unit with
      no worries about using the right names and the right physical types. Further advantage: when 
      a unit’s physical type uses custom objects, the generated method delivers instances of the custom type, 
      rather than of type </textual><code class="po-atom e710 e710"><textual class="po-textual">Object</textual></code><textual class="po-textual">:
      </textual><programlisting class="po-block e711 e711" xml:space="preserve"><textual class="po-textual">    public Map&lt;String,UsgsResult[]&gt; getActivityResults() throws XQPException {...}</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e712 e712"><textual class="po-textual">
      The tray schema controls the generation of interfaces which contain only subsets of the info shape’s read 
      methods. This approach parcels out the results of complex XQuery processing in such a way that Java components 
      can reduce their dependence on the tray design: if the structure of the tray is changed, for example a unit is removed 
      or added, the impact is limited to the users of particular interfaces.
    </textual></para></section></section><section class="po-hcontainer e713 e713"><title class="po-block e714 e714"><textual class="po-textual">Info path and info space</textual></title><para class="po-block e715 e715"><textual class="po-textual">
      This section briefly explores how info trays create a new possibility of data integration. 
      Note that this aspect of info trays does not depend on whether the trays are 
      constructed by XQuery or any other means. Indirectly, however, the possibility of loading 
      info trays with XQuery further increases the potential for data integration, as it favours 
      the use of XML resources as input, a good approach to integration in the first place 
      (compare </textual><xref class="po-milestone e716 e716" linkend="Introduction"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
    </textual></para><para class="po-block e717 e717"><textual class="po-textual">
      The introduction of this paper emphasized the way XML and XPath together create a uniform 
      information space encompassing any XML resource accessible via document URI. On the other 
      hand, from an application programmer’s point of view it is often desirable to access 
      information in formats other than XML documents – hence the concepts of information units 
      and info trays described in this paper. And, of course, this also explains the popularity 
      of data binding. So we can ask: do info trays fall out of that uniform information space, 
      in a similar way to the products of data binding?
    </textual></para><para class="po-block e718 e718"><textual class="po-textual">
      Compared with data binding, the introduction of info tray objects creates a radically different 
      situation, as info trays are generic data containers. Trays identify their 
      units by QNames, and so the contents of an info tray can be addressed by path 
      expressions similar to XPath expressions. If we associate info trays as a 
      whole with an identifying QName – call it a “resource ID” – we can collect any number of
      info trays into a set so that the content of any one of those 
      trays is addressable in a uniform way.
    </textual></para><para class="po-block e719 e719"><textual class="po-textual">
      For this purpose XQJPLUS introduces the concepts of an 
      </textual><emphasis class="po-inline e720 e720" role="bold"><textual class="po-textual">info path</textual></emphasis><textual class="po-textual"> and an 
      </textual><emphasis class="po-inline e721 e721" role="bold"><textual class="po-textual">info space</textual></emphasis><textual class="po-textual">, and it supplies the definition of an 
      info tray with a property called resourceID, typed as a QName. 
    </textual></para><para class="po-block e722 e722"><emphasis class="po-inline e723 e723" role="ital"><emphasis class="po-inline e724 e724" role="bold"><textual class="po-textual">Info space</textual></emphasis></emphasis></para><para class="po-block e725 e725"><textual class="po-textual">
      An info space is simply a set of info trays. Within the set, the resource IDs must be unique, 
      so that an info space is essentially a mapping of resource IDs to owner trays. The name 
      “info space” is meant to evoke the notion of navigation and uniform accessibility: any content 
      of any member tray can be addressed in a uniform way, using info paths as detailed below.
    </textual></para><para class="po-block e726 e726"><emphasis class="po-inline e727 e727" role="ital"><emphasis class="po-inline e728 e728" role="bold"><textual class="po-textual">Info path</textual></emphasis></emphasis></para><para class="po-block e729 e729"><textual class="po-textual">
      An info path is a string expression addressing data within an info space. Like an XPath, 
      it is composed of steps, and the trailing part of it can in fact be a real XPath, as long as 
      the info path points into an information unit containing nodes. Outwardly, an info path 
      looks like an XPath: it is a sequence of steps, and these steps can be grouped into three 
      consecutive sections:
    </textual></para><para class="po-block e730 e730"><textual class="po-textual">
        </textual><itemizedlist class="po-table e731 e731"><listitem class="po-container e732 e732"><para class="po-block e733 e733"><emphasis class="po-inline e734 e734" role="bold"><textual class="po-textual">(1) tray selection</textual></emphasis></para><para class="po-block e735 e735"><textual class="po-textual"> - the first step identifies a particular 
              info tray within the info space.
            </textual></para></listitem><listitem class="po-container e736 e736"><para class="po-block e737 e737"><emphasis class="po-inline e738 e738" role="bold"><textual class="po-textual">(2) information unit selection</textual></emphasis></para><para class="po-block e739 e739"><textual class="po-textual"> - one or more steps identify a particular information unit 
              within the tray.
            </textual></para></listitem><listitem class="po-container e740 e740"><para class="po-block e741 e741"><emphasis class="po-inline e742 e742" role="bold"><textual class="po-textual">(3) intra-unit navigation</textual></emphasis></para><para class="po-block e743 e743"><textual class="po-textual"> - an optional 
              trailing part of the info path navigates into the particular unit identified by the 
              preceding steps.
            </textual></para></listitem></itemizedlist><textual class="po-textual">  
    </textual></para><para class="po-block e744 e744"><textual class="po-textual">
      See </textual><xref class="po-milestone e745 e745" linkend="example-infopath"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for an example. 
    </textual></para><figure class="po-container e746 e746" xml:id="example-infopath"><title class="po-block e747 e747"><textual class="po-textual">Example of an info path</textual></title><mediaobject class="po-container e748 e748"><imageobject class="po-container e749 e749"><imagedata class="po-meta e750 e750" fileref="../../../vol5/graphics/Rennau01/Rennau01-002.jpg" format="jpg" width="50%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e751 e751"><para class="po-block e752 e752"><textual class="po-textual">This info path selects the value of a map entry with key "Ammonium"; the map is
            selected as a specific information unit found in a specific info tray.
          </textual></para></caption></figure><para class="po-block e753 e753"><textual class="po-textual">
      The steps selecting info tray and information unit consist of QNames. The trailing steps
      defining intra-unit navigation, on the other hand, have a syntax and semantics which 
      are determined by the physical type of the unit in question. To achieve a precise
      understanding of how an info path is decomposed and evaluated, consider this string:
      </textual><programlisting class="po-block e754 e754" xml:space="preserve"><textual class="po-textual">infospace://a/b/c/d</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e755 e755"><textual class="po-textual">
      The prefix “infospace://” indicates that the string represents an info path, rather than an XPath. 
      The path is evaluated in the context of a specific info space. This 
      space cannot be inferred from the path expression. The step “a” identifies a tray within 
      that info space. The next step “b” identifies a unit within that tray. If this unit does 
      not contain nested units (in other words, if it is not a tray or an array of trays), then 
      the remaining steps “c/d” navigate into that unit. On the other hand, if the unit identified 
      by “b” does contain nested units, than “c” identifies a unit within “b”, and the interpretation 
      of the next step “d” again depends on the type of the unit identified by the preceding step. 
      In summary, the unit selection comprises one or more steps, and it ends with the first step 
      identifying a “primary unit”, a unit not containing other units. If this step is not the last 
      step of the info path, the remaining steps constitute an intra-unit path; otherwise, the path 
      identifies that unit as a whole, rather than parts of it.
    </textual></para><para class="po-block e756 e756"><textual class="po-textual">
      As already mentioned, the semantics of the intra-unit path depend on the unit’s physical 
      type. The following table gives a few examples.

        </textual><table class="po-container e757 e757"><caption class="po-container e758 e758"><para class="po-block e759 e759"><emphasis class="po-inline e760 e760" role="bold"><emphasis class="po-inline e761 e761" role="ital"><textual class="po-textual">Interpretation of intra-unit paths - examples.</textual></emphasis></emphasis></para></caption><col align="left" class="po-meta e762 e762" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e763 e763" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e764 e764"><tr class="po-table e765 e765" valign="top"><th align="left" class="po-field e766 e766" valign="top"><textual class="po-textual">Unit type (physical)</textual></th><th align="left" class="po-field e767 e767" valign="top"><textual class="po-textual">Interpretation of the intra-unit path</textual></th></tr></thead><tbody class="po-table e768 e768"><tr class="po-table e769 e769" valign="top"><td class="po-block e770 e770"><emphasis class="po-inline e771 e771" role="bold"><textual class="po-textual">node</textual></emphasis></td><td class="po-block e772 e772"><textual class="po-textual">XPath</textual></td></tr><tr class="po-table e773 e773" valign="top"><td class="po-block e774 e774"><emphasis class="po-inline e775 e775" role="bold"><textual class="po-textual">string-to-string map</textual></emphasis></td><td class="po-block e776 e776"><textual class="po-textual">step 1: map key; no further steps allowed</textual></td></tr><tr class="po-table e777 e777" valign="top"><td class="po-block e778 e778"><emphasis class="po-inline e779 e779" role="bold"><textual class="po-textual">string-to-node map</textual></emphasis></td><td class="po-block e780 e780"><textual class="po-textual">step 1: map key; remaining steps: XPath</textual></td></tr><tr class="po-table e781 e781" valign="top"><td class="po-block e782 e782"><emphasis class="po-inline e783 e783" role="bold"><textual class="po-textual">string-to-(string-to-string map)</textual></emphasis></td><td class="po-block e784 e784"><textual class="po-textual">step 1: outer map key; step 2: inner map key</textual></td></tr><tr class="po-table e785 e785" valign="top"><td class="po-block e786 e786"><emphasis class="po-inline e787 e787" role="bold"><textual class="po-textual">string-to-(string-to-node map)</textual></emphasis></td><td class="po-block e788 e788"><textual class="po-textual">step 1: outer map key; step 2: inner map key; remaining steps: XPath</textual></td></tr><tr class="po-table e789 e789" valign="top"><td class="po-block e790 e790"><emphasis class="po-inline e791 e791" role="bold"><textual class="po-textual">properties</textual></emphasis></td><td class="po-block e792 e792"><textual class="po-textual">property name</textual></td></tr><tr class="po-table e793 e793" valign="top"><td class="po-block e794 e794"><emphasis class="po-inline e795 e795" role="bold"><textual class="po-textual">string</textual></emphasis></td><td class="po-block e796 e796"><textual class="po-textual">not applicable</textual></td></tr><tr class="po-table e797 e797" valign="top"><td class="po-block e798 e798"><emphasis class="po-inline e799 e799" role="bold"><textual class="po-textual">date</textual></emphasis></td><td class="po-block e800 e800"><textual class="po-textual">not applicable</textual></td></tr></tbody></table><textual class="po-textual">
    </textual></para><para class="po-block e801 e801"><textual class="po-textual">
      </textual><emphasis class="po-inline e802 e802" role="ital"><textual class="po-textual">Note on multiplicity.</textual></emphasis><textual class="po-textual"> The unit to which the intra-unit 
      path must be applied can be a sequence of objects, rather than a single object. There 
      are two sources of multiplicity: (i) several units can have the same name, and (ii) 
      the physical type may be an object array, rather than a single object. If the intra-unit 
      path is applied to more than one object, the evaluation is repeated for each one and the 
      results are united. 
    </textual></para><para class="po-block e803 e803"><textual class="po-textual">
      </textual><emphasis class="po-inline e804 e804" role="ital"><textual class="po-textual">Note on step indexes and unit selection.</textual></emphasis><textual class="po-textual"> For steps dedicated 
      to unit selection, a special index syntax applies (for example: a/b[2.3]/c), allowing to target 
      both sources of multiplicity (see above) separately. 
    </textual></para><para class="po-block e805 e805"><emphasis class="po-inline e806 e806" role="ital"><emphasis class="po-inline e807 e807" role="bold"><textual class="po-textual">Class InfoSpace</textual></emphasis></emphasis></para><para class="po-block e808 e808"><textual class="po-textual">
      The XQJPLUS class </textual><code class="po-atom e809 e809"><textual class="po-textual">InfoSpace</textual></code><textual class="po-textual"> represents an info space. Besides methods for adding 
      and removing trays from the space, it offers several methods for evaluating info paths, 
      distinguished by the result type (string, string array, node, node array), as well as a method 
      for setting/extending the namespace context for info path evaluation. An 
      </textual><code class="po-atom e810 e810"><textual class="po-textual">InfoSpace</textual></code><textual class="po-textual"> object represents a collection of information which combines high flexibility 
      (and possibly great heterogeneity) of information models with a unified, string-based access 
      model. This makes </textual><code class="po-atom e811 e811"><textual class="po-textual">InfoSpace</textual></code><textual class="po-textual"> objects an option for the design of highly configurable software: 
      configurations supply info path strings which connect generic functionality to actual input 
      collected from info spaces. As well as this, unified addressability of data supports data 
      integration in general. Just as XPath provides this addressability for XML data, info path 
      provides this addressability for info space data.
    </textual></para></section><section class="po-hcontainer e812 e812"><title class="po-block e813 e813"><textual class="po-textual">The cooperation of Java and XQuery developers</textual></title><para class="po-block e814 e814"><textual class="po-textual">
      XQJPLUS is designed to facilitate the cooperation of the Java and XQuery developers. Typically, 
      the cooperation between developers is based on interfaces. The “interface” to the XQuery 
      developer’s work is a tray design, which can be formally captured by a tray schema. Optionally, 
      this tray schema can in turn be compiled into a set of Java interfaces.  A suggested workflow is:
      </textual><orderedlist class="po-table e815 e815"><listitem class="po-container e816 e816"><para class="po-block e817 e817"><textual class="po-textual">The Java and XQuery developers discuss the information to be extracted from a set of XML resources.</textual></para></listitem><listitem class="po-container e818 e818"><para class="po-block e819 e819"><textual class="po-textual">
            They design the tray and document it using a 
            </textual><emphasis class="po-inline e820 e820" role="ital"><textual class="po-textual">tray schema</textual></emphasis><textual class="po-textual">.
          </textual></para></listitem><listitem class="po-container e821 e821"><para class="po-block e822 e822"><textual class="po-textual">The tray schema is compiled into an </textual><emphasis class="po-inline e823 e823" role="ital"><textual class="po-textual">
            info shape</textual></emphasis><textual class="po-textual">, a Java class and interfaces.</textual></para></listitem><listitem class="po-container e824 e824"><para class="po-block e825 e825"><textual class="po-textual">The XQuery developer writes a prototype query which produces a valid tray.</textual></para></listitem><listitem class="po-container e826 e826"><para class="po-block e827 e827"><textual class="po-textual">The Java developer can begin to code against the info shape.</textual></para></listitem><listitem class="po-container e828 e828"><para class="po-block e829 e829"><textual class="po-textual">
            The XQuery developer produces incremental versions of the query, eventually
            replacing the prototype with a real implemention.
          </textual></para></listitem></orderedlist><textual class="po-textual">  
    </textual></para></section><section class="po-hcontainer e830 e830"><title class="po-block e831 e831"><textual class="po-textual">Reusing XQJPLUS in other integration infrastructures</textual></title><para class="po-block e832 e832"><textual class="po-textual">
      XQuery is integrated by XQJPLUS in such a way as to maximize the 
      possibility of reuse when developing other integration software that is based on information units. 
      The prospect of reuse exists on three levels: changing the underlying 
      XQuery API (currently: XQJ), changing the type of information resource (currently: XQuery) and 
      changing the programming language integrating the information resource (currently: Java).
    </textual></para><para class="po-block e833 e833"><emphasis class="po-inline e834 e834" role="ital"><emphasis class="po-inline e835 e835" role="bold"><textual class="po-textual">Replacing the XQJ API</textual></emphasis></emphasis></para><para class="po-block e836 e836"><textual class="po-textual">
      XQJPLUS is based on XQJ. However, it would be easy to create a version based on a different XQuery API, e.g. 
      Saxon’s s9api </textual><xref class="po-milestone e837 e837" linkend="S9API"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Only the tray loading method would have to be adapted, and in doing so the
      only part that would need to be changed is the “extraction” of a Java data item from the Java representation of an XDM item.
    </textual></para><para class="po-block e838 e838"><emphasis class="po-inline e839 e839" role="ital"><emphasis class="po-inline e840 e840" role="bold"><textual class="po-textual">Replacing XQuery</textual></emphasis></emphasis></para><para class="po-block e841 e841"><textual class="po-textual">
      XQJPLUS integrates XQuery. A similar integration of other information resources, e.g. XSLT or 
      XProc results, could reuse a major part of the software, namely the </textual><code class="po-atom e842 e842"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> class. In fact, only a 
      new subclass of </textual><code class="po-atom e843 e843"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual"> would have to be created, which implements the loading of a tray from the
      chosen type of information resource. In particular note that the generation of Java code (info shapes) does  
      not need to be changed, as it is independent of the information resource underlying the tray. The major problem to 
      be solved would be to control the assembly of information units: the control exerted by XQuery result items 
      might prove difficult to attain with other sources. 
    </textual></para><para class="po-block e844 e844"><emphasis class="po-inline e845 e845" role="ital"><emphasis class="po-inline e846 e846" role="bold"><textual class="po-textual">Replacing Java</textual></emphasis></emphasis></para><para class="po-block e847 e847"><textual class="po-textual">
      The integration of XQuery into other languages – e.g. C# or C++ - could be modelled on XQJPLUS. First, produce 
      a language-specific version of </textual><code class="po-atom e848 e848"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual">. Then implement the loading of the tray from an XQuery 
      result, using the </textual><code class="po-atom e849 e849"><textual class="po-textual">InfoTray</textual></code><textual class="po-textual">’s generic </textual><code class="po-atom e850 e850"><textual class="po-textual">add</textual></code><textual class="po-textual"> methods. Finally, extend the tray schema language 
      by a new language binding vocabulary, and implement the code generation controlled by that vocabulary.
    </textual></para></section><section class="po-hcontainer e851 e851"><title class="po-block e852 e852"><textual class="po-textual">Information units versus data binding</textual></title><para class="po-block e853 e853"><textual class="po-textual">
      Information units are read from an info tray or an info shape. In both cases, “getter” methods 
      are used to obtain data originating from XML resources. This is an apparent similarity to data 
      binding. But there are two fundamental differences.
    </textual></para><para class="po-block e854 e854"><textual class="po-textual">
      </textual><emphasis class="po-inline e855 e855" role="bold"><emphasis class="po-inline e856 e856" role="ital"><textual class="po-textual">evaluation versus repetition</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e857 e857"><textual class="po-textual">
      Info trays and shapes represent evaluation results, whereas the objects created by data binding 
      represent the original resources, and echo their structure. Data binding essentially repeats 
      information, rather than evaluates it.
    </textual></para><para class="po-block e858 e858"><textual class="po-textual">
      </textual><emphasis class="po-inline e859 e859" role="bold"><emphasis class="po-inline e860 e860" role="ital"><textual class="po-textual">information units versus items</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e861 e861"><textual class="po-textual">
      As data binding reflects the original information content, it also reflects its structure as a 
      tree of atomic items. Information units, on the other hand, are entities designed to support 
      the Java code in an optimal way, free to use alternatives to atomic values and trees.
    </textual></para><para class="po-block e862 e862"><textual class="po-textual">
      These differences can be made less obvious by the many forms of customizing which different 
      data binding technologies support. They introduce limited possibilities to avoid a one-to-one 
      repetition of structure and information content. But this amounts to variations on the theme 
      of repetition, rather than a transition from repetition to evaluation. This becomes especially 
      clear when considering the price to be paid for any deviation from the structure and content 
      implied by the original resource. 
    </textual></para><para class="po-block e863 e863"><textual class="po-textual">
      If the main interest lies in accessing single items that can be identified by paths known at 
      compile time – for example extracting parameters from a SOAP request or a configuration - data 
      binding offers considerable advantages to the Java developer, whereas information units are of 
      very limited use. But evaluating the XML resources and creating new information from them is an 
      activity data binding is little concerned with. If such evaluation is important, XQuery in general, 
      and XQuery-powered information units in particular offer an option that should be considered.
    </textual></para></section><section class="po-hcontainer e864 e864"><title class="po-block e865 e865"><textual class="po-textual">Conclusion</textual></title><para class="po-block e866 e866"><textual class="po-textual">
      The integration of XQuery into Java may be viewed as a specimen of a very general kind of integration: 
      the integration of “pure information processing” into object-oriented languages. Here, “pure information processing” 
      denotes a side-effect free processing of information. As mentioned earlier, the W3C-developed XDM is a unified 
      information model applicable to a vast spectrum of information, accessible to processing languages marked by 
      precision, conciseness and efficiency. As a matter of fact, “information processing”, as it has become possible
      thanks to the work done by W3C, is a new kind of program activity, which can be distinguished from other activities 
      conceptually, and structurally factored out. It is a promising perspective to practise such separation where feasible, 
      factoring out information processing, delegating it to specialized components – e.g. XQuery code – in as large chunks 
      as possible, and integrating the results in a seamless way. This is an architectural pattern which XQJPLUS strives to 
      support.
    </textual></para></section><section class="po-hcontainer e867 e867"><title class="po-block e868 e868"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e869 e869"><textual class="po-textual">
      David A. Lee gave me advice concerning the technical preparation of the manuscript, and I-Lin Kuo
      checked my use of the NWIS Water Quality Web Services. Lauren Wood helped me generously with the
      English text, sacrificing much time to the elimination of errors and awkward phrasing. 
      Xia Li helped me in every way: taking part in the technical preparation of the manuscript, 
      reading drafts, discussing issues, making many valuable suggestions and simply encouraging 
      me with her vivid, tireless interest. To all of you - thank you!
    </textual></para></section><appendix class="po-hcontainer e870 e870" xml:id="USGS-example-data"><title class="po-block e871 e871"><textual class="po-textual">Sample of the data evaluated in the example section</textual></title><para class="po-block e872 e872"><textual class="po-textual">
      The data evaluated in </textual><xref class="po-milestone e873 e873" linkend="Getting-started-with-XQJPLUS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> were obtained from 
      the Result Service of “National Water Information System (NWIS) Water-Quality Web 
      Services” </textual><xref class="po-milestone e874 e874" linkend="USGS-WS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. They contain water quality sampling results 
      reported for the first three months of 2010, collected in the state of Minnesota, 
      including both final and preliminary results. The data can be obtained from the 
      following URI:
      </textual><programlisting class="po-block e875 e875" xml:space="preserve"><textual class="po-textual">
http://qwwebservices.usgs.gov/Result/search?organization=USGS-MN&amp;startDateLo=
01-01-2010&amp;startDateHi=03-31-2010&amp;mimeType=xml</textual></programlisting><textual class="po-textual"> 
    </textual></para><para class="po-block e876 e876"><textual class="po-textual">
       Here comes a small sample of the data. "..." indicate left out parts.
     </textual></para><programlisting class="po-block e877 e877" xml:space="preserve"><textual class="po-textual">
&lt;WQX xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns="http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/"
     xsi:schemaLocation="http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/ 
     http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/index.xsd"&gt;
   &lt;Organization&gt;
      &lt;OrganizationDescription&gt;
         &lt;OrganizationIdentifier&gt;USGS-MN&lt;/OrganizationIdentifier&gt;
         &lt;OrganizationFormalName&gt;USGS Minnesota Water Science Center&lt;/OrganizationFormalName&gt;
      &lt;/OrganizationDescription&gt;
      ...
      &lt;Activity&gt;
         &lt;ActivityDescription&gt;
            &lt;ActivityIdentifier&gt;sun1dmnspl.01.01000101&lt;/ActivityIdentifier&gt;
            &lt;ActivityTypeCode&gt;Sample-Routine&lt;/ActivityTypeCode&gt;
            &lt;ActivityMediaName&gt;Water&lt;/ActivityMediaName&gt;
            &lt;ActivityMediaSubdivisionName&gt;Surface Water&lt;/ActivityMediaSubdivisionName&gt;
            &lt;ActivityStartDate&gt;2010-01-20&lt;/ActivityStartDate&gt;
            &lt;ActivityStartTime&gt;
               &lt;Time&gt;09:20:00&lt;/Time&gt;
               &lt;TimeZoneCode&gt;CST&lt;/TimeZoneCode&gt;
            &lt;/ActivityStartTime&gt;
            &lt;ProjectIdentifier&gt;NAWQA&lt;/ProjectIdentifier&gt;
            &lt;ActivityConductingOrganizationText&gt;U.S. Geological Survey-Water Resources 
            Discipline&lt;/ActivityConductingOrganizationText&gt;
            &lt;MonitoringLocationIdentifier&gt;USGS-05288705&lt;/MonitoringLocationIdentifier&gt;
            &lt;ActivityCommentText&gt;A-0210094 Attention: Charlie Patton TPCN (2) TPCN filters: 50mL 
            each&lt;/ActivityCommentText&gt;
            &lt;HydrologicCondition&gt;Stable, low stage&lt;/HydrologicCondition&gt;
            &lt;HydrologicEvent&gt;Under ice cover&lt;/HydrologicEvent&gt;
         &lt;/ActivityDescription&gt;
         &lt;SampleDescription&gt;
            &lt;SampleCollectionMethod&gt;
               &lt;MethodIdentifier&gt;15&lt;/MethodIdentifier&gt;
               &lt;MethodIdentifierContext&gt;USGS parameter code 82398&lt;/MethodIdentifierContext&gt;
               &lt;MethodName&gt;Equal width increment, non-isokinetic&lt;/MethodName&gt;
            &lt;/SampleCollectionMethod&gt;
            &lt;SampleCollectionEquipmentName&gt;Open-Mouth Bottle&lt;/SampleCollectionEquipmentName&gt;
         &lt;/SampleDescription&gt;
         &lt;Result&gt;
            &lt;ResultDescription&gt;
               &lt;CharacteristicName&gt;Depth&lt;/CharacteristicName&gt;
               &lt;ResultMeasure&gt;
                  &lt;ResultMeasureValue&gt;0.30&lt;/ResultMeasureValue&gt;
                  &lt;MeasureUnitCode&gt;ft&lt;/MeasureUnitCode&gt;
               &lt;/ResultMeasure&gt;
               &lt;ResultStatusIdentifier&gt;Preliminary&lt;/ResultStatusIdentifier&gt;
               &lt;ResultValueTypeName&gt;Actual&lt;/ResultValueTypeName&gt;
               &lt;USGSPCode&gt;81903&lt;/USGSPCode&gt;
            &lt;/ResultDescription&gt;
            &lt;ResultLabInformation&gt;
               &lt;LaboratoryName&gt;U.S. Geological Survey-Water Resources Discipline&lt;/LaboratoryName&gt;
               &lt;AnalysisStartDate&gt;--&lt;/AnalysisStartDate&gt;
            &lt;/ResultLabInformation&gt;
            &lt;LabSamplePreparation&gt;
               &lt;PreparationStartDate&gt;--&lt;/PreparationStartDate&gt;
            &lt;/LabSamplePreparation&gt;
         &lt;/Result&gt;
         &lt;Result&gt;
            &lt;ResultDescription&gt;
               &lt;CharacteristicName&gt;Nitrite&lt;/CharacteristicName&gt;
               &lt;ResultSampleFractionText&gt;Dissolved&lt;/ResultSampleFractionText&gt;
               &lt;ResultMeasure&gt;
                  &lt;ResultMeasureValue&gt;0.087&lt;/ResultMeasureValue&gt;
                  &lt;MeasureUnitCode&gt;mg/l&lt;/MeasureUnitCode&gt;
               &lt;/ResultMeasure&gt;
               &lt;ResultStatusIdentifier&gt;Preliminary&lt;/ResultStatusIdentifier&gt;
               &lt;ResultValueTypeName&gt;Calculated&lt;/ResultValueTypeName&gt;
               &lt;USGSPCode&gt;71856&lt;/USGSPCode&gt;
            &lt;/ResultDescription&gt;
            &lt;ResultLabInformation&gt;
               &lt;AnalysisStartDate&gt;--&lt;/AnalysisStartDate&gt;
            &lt;/ResultLabInformation&gt;
            &lt;LabSamplePreparation&gt;
               &lt;PreparationStartDate&gt;--&lt;/PreparationStartDate&gt;
            &lt;/LabSamplePreparation&gt;
         &lt;/Result&gt;
         &lt;Result&gt;
            &lt;ResultDescription&gt;
               &lt;CharacteristicName&gt;Nitrate&lt;/CharacteristicName&gt;
               &lt;ResultSampleFractionText&gt;Dissolved&lt;/ResultSampleFractionText&gt;
               &lt;ResultMeasure&gt;
                  &lt;ResultMeasureValue&gt;1.66&lt;/ResultMeasureValue&gt;
                  &lt;MeasureUnitCode&gt;mg/l&lt;/MeasureUnitCode&gt;
               &lt;/ResultMeasure&gt;
               &lt;ResultStatusIdentifier&gt;Preliminary&lt;/ResultStatusIdentifier&gt;
               &lt;ResultValueTypeName&gt;Calculated&lt;/ResultValueTypeName&gt;
               &lt;USGSPCode&gt;71851&lt;/USGSPCode&gt;
            &lt;/ResultDescription&gt;
            &lt;ResultLabInformation&gt;
               &lt;AnalysisStartDate&gt;--&lt;/AnalysisStartDate&gt;
            &lt;/ResultLabInformation&gt;
            &lt;LabSamplePreparation&gt;
               &lt;PreparationStartDate&gt;--&lt;/PreparationStartDate&gt;
            &lt;/LabSamplePreparation&gt;
         &lt;/Result&gt;       
         &lt;Result&gt;
            &lt;ResultDescription&gt;
               &lt;CharacteristicName&gt;Ammonia and ammonium&lt;/CharacteristicName&gt;
               &lt;ResultSampleFractionText&gt;Dissolved&lt;/ResultSampleFractionText&gt;
               &lt;ResultMeasure&gt;
                  &lt;ResultMeasureValue&gt;0.49&lt;/ResultMeasureValue&gt;
                  &lt;MeasureUnitCode&gt;mg/l NH4&lt;/MeasureUnitCode&gt;
               &lt;/ResultMeasure&gt;
               &lt;ResultStatusIdentifier&gt;Preliminary&lt;/ResultStatusIdentifier&gt;
               &lt;ResultValueTypeName&gt;Calculated&lt;/ResultValueTypeName&gt;
               &lt;USGSPCode&gt;71846&lt;/USGSPCode&gt;
            &lt;/ResultDescription&gt;
            &lt;ResultLabInformation&gt;
               &lt;AnalysisStartDate&gt;--&lt;/AnalysisStartDate&gt;
            &lt;/ResultLabInformation&gt;
            &lt;LabSamplePreparation&gt;
               &lt;PreparationStartDate&gt;--&lt;/PreparationStartDate&gt;
            &lt;/LabSamplePreparation&gt;
         &lt;/Result&gt;
         ...
      ...
   &lt;/Organization&gt;
&lt;/WQX&gt;</textual></programlisting></appendix><appendix class="po-hcontainer e878 e878" xml:id="USGS-evaluation-query"><title class="po-block e879 e879"><textual class="po-textual">XQuery code performing the evaluations described in the example section</textual></title><para class="po-block e880 e880"><textual class="po-textual">
      The query performed the evaluations described in </textual><xref class="po-milestone e881 e881" linkend="Getting-started-with-XQJPLUS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
      It produces a sequence of control items (</textual><code class="po-atom e882 e882"><textual class="po-textual">&lt;xqjp:XXX&gt;</textual></code><textual class="po-textual">) and data items, which 
      generic Java code (XQJPLUS) assembles into an info tray.
    </textual></para><programlisting class="po-block e883 e883" xml:space="preserve"><textual class="po-textual">
declare namespace xqjp="http://www.bits-ac.com/xqjplus/control";
declare namespace meta="http://www.bits-ac.com/xqjplus/meta";
declare default element namespace "http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/";

declare variable $projectIds := 
   for $n in distinct-values(//ActivityDescription/ProjectIdentifier)
   order by $n return $n;

(: *** namespace context *** 
 : ========================= :)
&lt;xqjp:setNamespaceContext&gt;
   &lt;xqjp:binding prefix="data" uri="http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/"/&gt;
   &lt;xqjp:binding prefix="meta" uri="http://www.bits-ac.com/xqjplus/meta"/&gt;
   &lt;xqjp:binding prefix="usgs" uri="http://www.bits-ac.com/usgs"/&gt;
&lt;/xqjp:setNamespaceContext&gt;,

(: *** tray meta data *** 
 : ====================== :)
&lt;xqjp:trayMeta meta:name="balisageDemoTray"
               meta:documentation="Creates the info tray used in section 'Getting started with XQJPLUS'."/&gt;,

(: *** info unit "projectIds"
 : ========================== :)
&lt;xqjp:part name="projectIds" 
           type="string_sortedset_object"
           sematype="usgs:projectIds"/&gt;,
$projectIds,

(: *** info unit "projectActivities"
 : ================================= :)
&lt;xqjp:part name="projectActivities" 
           type="nested_map_string_to_string_object"
           impltype="java.util.TreeMap"
           sematype="usgs:projectActivities"
           outerEntryPath="data:project"
           outerKeyPath="@id"
           innerEntryPath="data:activity"
           innerKeyPath="@time"
           innerValuePath="@activityId"/&gt;,

&lt;projectData&gt;{
   for $p in $projectIds
   let $myActivities := //Activity[ActivityDescription/ProjectIdentifier eq $p]
   return
      &lt;project id="{$p}"&gt;{
         for $a in $myActivities
         return
            &lt;activity&gt;{
               attribute time {$a/ActivityDescription/concat(ActivityStartDate, "#", ActivityStartTime/Time)},
               attribute activityId {$a/ActivityDescription/ActivityIdentifier}
            }&lt;/activity&gt;
      }&lt;/project&gt;
}&lt;/projectData&gt;,

(: *** info unit "activityResults"
 : ============================= :)
&lt;xqjp:part name="activityResults" 
           type="map_string_to_custom_objects_object"
           impltype="java.util.TreeMap"
           customType="com.bits_ac.xqjplus.appl.UsgsResult"
           sematype="usgs:projectActivities"
           entryPath="data:activity"
           keyPath="@id"
           valuePath="data:Result"/&gt;,

&lt;resultObjects&gt;{
   for $a in //Activity
   return
      &lt;activity id="{$a//ActivityIdentifier}"&gt;{$a/Result}&lt;/activity&gt;
}&lt;/resultObjects&gt;,

(: *** info unit "fractionResults"
 : =============================== :)
&lt;xqjp:part name="fractionResults" 
           type="nested_map_string_to_strings_object"
           impltype="java.util.TreeMap"
           sematype="usgs:fractionResults"
           outerEntryPath="data:fractionResults"
           outerKeyPath="@name"
           innerEntryPath="data:entry"
           innerKeyPath="@time"
           innerValuePath="data:result/@uvalue"/&gt;,

&lt;allFractionResults&gt;{
   for $f in distinct-values(//ResultDescription/CharacteristicName/string-join((., ../ResultSampleFractionText), "/"))
   let $charName := replace($f, "/.*", "")
   let $fractionText := if (contains($f, "/")) then replace($f, ".*/", "") else ()
   let $myResults := //Result[ResultDescription/CharacteristicName eq $charName and (
                      not($fractionText) and not(ResultDescription/ResultSampleFractionText)
                      or ResultDescription/ResultSampleFractionText eq $fractionText)]
   let $times :=  
      for $t in distinct-values($myResults/../ActivityDescription/concat(ActivityStartDate, "#", ActivityStartTime/Time)) 
      order by $t return $t
   order by lower-case($f)
   return
      &lt;fractionResults name="{$f}"&gt;{
         for $time in $times
         let $myTimeResults := 
            $myResults[../ActivityDescription/concat(ActivityStartDate, "#", ActivityStartTime/Time) eq $time]
         order by $time
         return
            &lt;entry time="{$time}"&gt;{
               for $r in $myTimeResults
               let $rvalue := $r/ResultDescription/ResultMeasure/(ResultMeasureValue, MeasureUnitCode)
               let $rvalue := 
                  if ($rvalue) then $rvalue else $r/ResultLabInformation//(MeasureValue, MeasureUnitCode)
               return
                  &lt;result uvalue="{concat($rvalue[1], " [", $rvalue[2], "]")}"/&gt;
            }&lt;/entry&gt;
      }&lt;/fractionResults&gt;
}&lt;/allFractionResults&gt;
</textual></programlisting></appendix><appendix class="po-hcontainer e884 e884" xml:id="The-control-items"><title class="po-block e885 e885"><textual class="po-textual">The control items defined by XQJPLUS</textual></title><para class="po-block e886 e886"><textual class="po-textual">
         In </textual><xref class="po-milestone e887 e887" linkend="The-assembly-process-basics"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and </textual><xref class="po-milestone e888 e888" linkend="The-assembly-process-advanced"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
         several code examples show how XQuery code controls the construction of an info tray. Those sections
         describe the main principles. This appendix provides a brief description of all control items 
         defined by XQJPLUS.
       </textual></para><para class="po-block e889 e889"><emphasis class="po-inline e890 e890" role="bold"><emphasis class="po-inline e891 e891" role="ital"><code class="po-atom e892 e892"><textual class="po-textual">xqjp:setNamespaceContext</textual></code></emphasis></emphasis></para><para class="po-block e893 e893"><textual class="po-textual">
        When interpreting namespace-sensitive contents of control items - e.g. construction attributes containing XPath
        expressions, or attribute </textual><code class="po-atom e894 e894"><textual class="po-textual">sematype</textual></code><textual class="po-textual"> which specifies the semantic type - XQJPLUS uses a special namespace context which 
        is </textual><emphasis class="po-inline e895 e895" role="ital"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> the namespace context of the respective control item itself. This 
        second namespace context is set or extended by </textual><code class="po-atom e896 e896"><textual class="po-textual">xqjp:setNamespaceContext</textual></code><textual class="po-textual"> control items. 
        Example:
        </textual><programlisting class="po-block e897 e897" xml:space="preserve"><textual class="po-textual">
&lt;xqjp:setNamespaceContext&gt;
   &lt;xqjp:binding prefix="meta" uri="http://www.bits-ac.com/xqjplus/meta"/&gt;
   &lt;xqjp:binding prefix="usgs" uri="http://www.bits-ac.com/usgs"/&gt;
   &lt;xqjp:binding prefix="tns" uri="http://qwwebservices.usgs.gov/schemas/WQX-Outbound/2_0/"/&gt;
&lt;/xqjp:setNamespaceContext&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e898 e898"><emphasis class="po-inline e899 e899" role="ital"><emphasis class="po-inline e900 e900" role="bold"><code class="po-atom e901 e901"><textual class="po-textual">xqjp:part</textual></code></emphasis></emphasis></para><para class="po-block e902 e902"><textual class="po-textual">
        The item defines an information unit. The name and physical type are given by the attributes “name” and “type”, and the semantic 
        type and implementation type by “sematype” and “impltype”. Note that the latter can be used to control the type 
        actually used to instantiate an interface, for example a collection interface. Construction attributes may control the 
        assembly process; the range of construction attributes and their default values are specific to each physical type. 
        A “source” attribute may reference the contents of a control variable as a data source. Further attributes must be in 
        a namespace and specify the meta data of the unit. Child elements, if present, specify further meta data. Example:
        </textual><programlisting class="po-block e903 e903" xml:space="preserve"><textual class="po-textual">&lt;xqjp:part xmlns:bi="http://www.bits-ac.com/usgs"
           name="fractionResults" 
           source="$fractionResults"
           type="nested_map_string_to_strings_object"
           sematype="bi:fractionResults"
           impltype="java.util.TreeMap"
           outerEntryPath="d:fractionResults"
           outerKeyPath="@name"
           innerEntryPath="d:entry"
           innerKeyPath="@time"
           innerValuePath="d:result/@uvalue"
           bi:source="mn-20100101-200330"
           bi:cr="{current-date()}"
&gt;
   &lt;laboratories&gt;{string-join(//LaboratoryName, “; “)&lt;/laboratories&gt;
&lt;/xqjp:part&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e904 e904"><textual class="po-textual">
        The defined unit has the name “fractionResults” (which has no namespace URI), a physical type corresponding 
        to the Java type </textual><code class="po-atom e905 e905"><textual class="po-textual">Map&lt;String,&lt;String, String[]&gt;&gt;</textual></code><textual class="po-textual">, as well as semantic and implementation types as 
        specified by the attributes “sematype” and “impltype”. The example specifies all five construction attributes 
        defined for the actual physical type (“outerEntryPath”, “outerKeyPath”, “innerEntryPath”, “innerKeyPath”, 
        “innerValuePath”) . If not specified, they would have defaulted to the values “*”, “@outerKey”, 
        “*”, “@key” and “*”, respectively. As meta data, “bi:source”, “bi:cr” and “laboratories” are specified. Note
        that a special namespace treatment is applied to namespace-sensitive contents, e.g. to construction attributes 
        which are defined to contain an XPath expression - see preceding section.
      </textual></para><para class="po-block e906 e906"><emphasis class="po-inline e907 e907" role="ital"><emphasis class="po-inline e908 e908" role="bold"><code class="po-atom e909 e909"><textual class="po-textual">xqjp:setVar</textual></code></emphasis></emphasis></para><para class="po-block e910 e910"><textual class="po-textual">
        The item defines a control variable. The name and variable type are given by the attributes “name” and “vtype”. The variable 
        type must be one of: node, nodes, string, strings. Example:
        </textual><programlisting class="po-block e911 e911" xml:space="preserve"><textual class="po-textual">&lt;xqjp:setVar name="fractionResults" vtype="node"/&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e912 e912"><emphasis class="po-inline e913 e913" role="ital"><emphasis class="po-inline e914 e914" role="bold"><code class="po-atom e915 e915"><textual class="po-textual">xqjp:error</textual></code></emphasis></emphasis></para><para class="po-block e916 e916"><textual class="po-textual">
        The item signals an error which makes normal tray loading impossible. The item specifies an error code and detail information, 
        both of which will be used on the Java side when constructing an exception object. The details are represented by the control 
        item’s child elements. A special attribute “abort” specifies if the assembly process shall be continued or abandoned after 
        processing this control item. (Continuation might be desirable in order to collect further error information.) Example:
        </textual><programlisting class="po-block e917 e917" xml:space="preserve"><textual class="po-textual">&lt;xqjp:error code="SOURCE_NOT_AVAILABLE" abort=”true”&gt;
   &lt;xqjp:sourceURI&gt;foo.xml&lt;/xqjp:sourceURI&gt;
&lt;/xqjp:error&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e918 e918"><emphasis class="po-inline e919 e919" role="ital"><emphasis class="po-inline e920 e920" role="bold"><code class="po-atom e921 e921"><textual class="po-textual">xqjp:trayMeta</textual></code></emphasis></emphasis></para><para class="po-block e922 e922"><textual class="po-textual">
        The item provides tray-level meta data. The data can be specified by attributes or child elements, 
        just like unit-level meta data are specified by an </textual><code class="po-atom e923 e923"><textual class="po-textual">&lt;xqjp:part&gt;</textual></code><textual class="po-textual"> element. Note 
        that the standard meta data “name” and “documentation” have names in the namespace 
        {http://www.bits-ac.com/xqjplus/meta}. Example:
        </textual><programlisting class="po-block e924 e924" xml:space="preserve"><textual class="po-textual">
&lt;xqjp:trayMeta smeta:name="bi:usgsResultEvaluation"
               bi:vsn="0.41"
               xmlns:smeta=”http://www.bits-ac.com/xqjplus/meta”
               xmlns:bi=”http://www.bits-ac.com/xqjplus/usgs”/&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e925 e925"><emphasis class="po-inline e926 e926" role="ital"><emphasis class="po-inline e927 e927" role="bold"><code class="po-atom e928 e928"><textual class="po-textual">xqjp:complexPartBegin</textual></code></emphasis></emphasis></para><para class="po-block e929 e929"><textual class="po-textual">
        The item opens the definition of a unit whose physical type is either a single info tray 
        or an array of info trays. The name of the unit is given by attribute “name”, the physical 
        type by attribute “type”. (The physical type must be either “infotray” or “infotrays”.) 
        An attribute </textual><code class="po-atom e930 e930"><textual class="po-textual">sematype</textual></code><textual class="po-textual"> may specify the semantic type, and further attributes 
        and child elements may specify meta data of the unit in the same way as with 
        </textual><code class="po-atom e931 e931"><textual class="po-textual">xqjp:part</textual></code><textual class="po-textual"> items.
        Examples:
        </textual><programlisting class="po-block e932 e932" xml:space="preserve"><textual class="po-textual">&lt;xqjp:complexPartBegin name="msgEvaluations" type="infotrays"/&gt;,
&lt;xqjp:complexPartBegin name="msgEvaluation" type="infotray" sematype="ws:eval" bi:vsn="1.0"/&gt;,</textual></programlisting><textual class="po-textual">        
      </textual></para><para class="po-block e933 e933"><emphasis class="po-inline e934 e934" role="ital"><emphasis class="po-inline e935 e935" role="bold"><code class="po-atom e936 e936"><textual class="po-textual">xqjp:complexPartEnd</textual></code></emphasis></emphasis></para><para class="po-block e937 e937"><textual class="po-textual">
        The item closes the definition of a unit which was opened by a preceding 
        </textual><code class="po-atom e938 e938"><textual class="po-textual">&lt;xqjp:complexPartBegin&gt;</textual></code><textual class="po-textual"> item. The unit closed is the innermost
        unit not yet closed. There are no attributes allowed. Example:
        </textual><programlisting class="po-block e939 e939" xml:space="preserve"><textual class="po-textual">&lt;xqjp:complexPartEnd /&gt;</textual></programlisting><textual class="po-textual">
      </textual></para></appendix><bibliography class="po-hcontainer e940 e940"><title class="po-block e941 e941"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e942 e942" xml:id="S9API" xreflabel="S9API"><textual class="po-textual">Michael Kay. Technical Documentation.
      </textual><link class="po-inline e943 e943" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.saxonica.com/documentation/using-xquery/api-query.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e944 e944" xml:id="USGS-WS" xreflabel="USGS Web Services"><textual class="po-textual">U.S. Geological Survey (USGS).
      Technical Documentation of USGS Water-Quality Web Services. 
      </textual><link class="po-inline e945 e945" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://qwwebservices.usgs.gov/technical-documentation.html</textual></link><textual class="po-textual"> .</textual></bibliomixed><bibliomixed class="po-block e946 e946" xml:id="W3C-Infoset" xreflabel="W3C Information Set"><textual class="po-textual">John Cowan and Richard Tobin, eds. 
      XML Information Set W3C Recommendation 4 February 2004.
      </textual><link class="po-inline e947 e947" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e948 e948" xml:id="W3C-XDM" xreflabel="W3C XDM"><textual class="po-textual">Mary Fernandez et al, eds. 
      XQuery 1.0 and XPath 2.0 Data Model (XDM) W3C Recommendation 23 January 2007.
      </textual><link class="po-inline e949 e949" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e950 e950" xml:id="W3C-XQuery" xreflabel="W3C XQuery"><textual class="po-textual">Scott Boag et al, eds. 
      XQuery 1.0: An XML Query Language W3C Recommendation 23 January 2007.
      </textual><link class="po-inline e951 e951" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e952 e952" xml:id="JSR-XQJ" xreflabel="XQJ Spec"><textual class="po-textual">Jim Melton et al, eds. 
      JSR 225: XQuery API for JavaTM (XQJ) 1.0 Specfication.
      </textual><link class="po-inline e953 e953" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jcp.org/en/jsr/detail?id=225</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>