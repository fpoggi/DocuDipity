<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">RESTful Service Description Language (RSDL)</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Describing RESTful Services Without Tight Coupling</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">RESTful Service Description Language (RSDL) is an XML vocabulary for designing and
        documenting hypermedia-driven RESTful Services. RSDL takes a purist hypermedia-driven
        approach to REST design, requiring that a service have a single entry point, and focusing
        the design on resources, links, and media types.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Jonathan</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Robie</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Jonathan Robie is an architect and chair of the IIG REST Governance Board at EMC
          Corporation, an editor of JSONiq, a query language for JSON and XML, and the lead editor
          of the W3C XQuery and XPath specifications. Before joining EMC, Jonathan worked on the
          Apache Qpid implementation of AMQP for Red Hat, was the Program Manager for DataDirect
          XQuery, and worked on the architectural team for three XML databases: Software AG's
          Tamino, Texcel, and POET's CMS. He received an Infoworld Innovator 2005 award for his work
          on XQuery.</textual></para></personblurb><affiliation class="po-record e15 e15"><orgname class="po-block e16 e16"><textual class="po-textual">EMC Corporation</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">jonathan.robie@emc.com</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Rob</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">Cavicchio</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">Rob Cavicchio is an Information Architect at EMC. He designs technical documentation,
          and implements and supports tools that enable efficient documentation management. He has
          worked in the technical writing field since 1994.</textual></para></personblurb><affiliation class="po-record e24 e24"><orgname class="po-block e25 e25"><textual class="po-textual">EMC Corporation</textual></orgname></affiliation><email class="po-field e26 e26"><textual class="po-textual">rob.cavicchio@emc.com</textual></email></author><author class="po-record e27 e27"><personname class="po-record e28 e28"><firstname class="po-field e29 e29"><textual class="po-textual">Rémon</textual></firstname><surname class="po-field e30 e30"><textual class="po-textual">Sinnema</textual></surname></personname><personblurb class="po-container e31 e31"><para class="po-block e32 e32"><textual class="po-textual">Rémon Sinnema is a developer and Security Champion at EMC Corporation, member of the
          IIG REST Governance Board at EMC Corporation, member of the OASIS XACML Technical
          Committee, and lead editor of the XACML REST Profile.</textual></para></personblurb><affiliation class="po-record e33 e33"><orgname class="po-block e34 e34"><textual class="po-textual">EMC Corporation</textual></orgname></affiliation><email class="po-field e35 e35"><textual class="po-textual">remon.sinnema@emc.com</textual></email></author><author class="po-record e36 e36"><personname class="po-record e37 e37"><firstname class="po-field e38 e38"><textual class="po-textual">Erik</textual></firstname><surname class="po-field e39 e39"><textual class="po-textual">Wilde</textual></surname></personname><personblurb class="po-container e40 e40"><para class="po-block e41 e41"><textual class="po-textual">Erik Wilde works as an architect at EMC's Information Intelligence Group (IIG). He is
          a self-proclaimed Web Plumber and Ecosystem Gardener, and has spent the majority of the
          last several years working on issues around service architectures, SOA, REST, and other
          questions of open service systems. Before joining EMC, Erik worked at UC Berkeley's School
          of Information, where he focused on questions around open data and open services, and
          taught courses about Web Architecture and XML. Erik is a native of Berlin, Germany, and
          received his Ph.D. from ETH Zürich in Switzerland.</textual></para></personblurb><affiliation class="po-record e42 e42"><orgname class="po-block e43 e43"><textual class="po-textual">EMC Corporation</textual></orgname></affiliation><email class="po-field e44 e44"><textual class="po-textual">erik.wilde@emc.com</textual></email></author><legalnotice class="po-container e45 e45"><para class="po-block e46 e46"><textual class="po-textual">Except where otherwise noted, this content is licensed under a Creative Commons Attribution 3.0 License.  Schemas and stylesheets in this document are licensed under an Apache 2.0 License.</textual></para></legalnotice></info><section class="po-hcontainer e47 e47"><title class="po-block e48 e48"><textual class="po-textual">Introduction</textual></title><para class="po-block e49 e49"><textual class="po-textual">RESTful Service Description Language (RSDL) is an XML vocabulary for designing and
      documenting hypermedia-driven RESTful Services. RSDL takes a purist hypermedia-driven approach
      to REST design, requiring that a service have a single entry point, and focusing the design on
      resources, links, and media types. By representing the concepts of REST in a formal
      vocabulary, RSDL helps designers of an interface think more clearly about the design process.
      In our work at EMC Corporation, we teach and coach RESTful design, evaluate proposed REST
      interfaces for products and internal services, and produce documentation for these interfaces.
      We created RSDL to make our work more efficient, and we have begun using it as a teaching
      tool, a standard format for specifications that allows us to track design changes in source
      code control, test for design consistency with specification-driven programs, and produce
      documentation.</textual></para><para class="po-block e50 e50"><textual class="po-textual">The REST community has little consensus on how to document a RESTful service beyond this
      well-known Roy Fielding quote: </textual><blockquote class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Any effort spent describing what methods to use on what URIs of interest should be
          entirely defined within the scope of the processing rules for a media type (and, in most
          cases, already defined by existing media types). [Failure here implies that out-of-band
          information is driving interaction instead of hypertext.]</textual></para></blockquote><textual class="po-textual">While this gives excellent guidance about things that should not be documented,
      it tells us that we should focus on documenting a media type without telling us how to do so.
      Well-designed RESTful services are loosely coupled, allowing a client to use the service with
      no prior knowledge beyond an initial URI and a set of media types. But this gives little
      concrete guidance to a person who is specifying a RESTful service, and needs to know precisely
      what information should be provided to a client, which fundamential concepts should be
      documented for a media type, how dependencies on multiple media types in a single service
      should be represented, where to document semantics specific to the application domain, or how
      to organize all of the information that belongs in a specification. </textual></para><para class="po-block e53 e53"><textual class="po-textual">This paper presents RESTful Service Description Language (RSDL, pronounced "risdle"), an
      XML vocabulary that provides a structured way to specify a RESTful service. RSDL is still
      being developed.</textual></para></section><section class="po-hcontainer e54 e54"><title class="po-block e55 e55"><textual class="po-textual">What should a RESTful service description describe?</textual></title><para class="po-block e56 e56"><textual class="po-textual">The description for a RESTful service should describe semantics specific to the service
      that go beyond functionality known to a generic REST client. In RSDL, every RESTful service
      has a single entry point, which corresponds to a home resource, and all other resources can be
      discovered from the home resource using links. The structure of a RSDL description enforces
      these design constraints. </textual></para><para class="po-block e57 e57"><textual class="po-textual">A RSDL description focuses on describing the following items:</textual></para><itemizedlist class="po-table e58 e58"><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Media types, with documentation and an optional link to a schema or description that
          documents each media type used in a service. This includes the kinds of response bodies
          sent by the server, and how to find links in them and identify specific kinds of
          link.</textual></para></listitem><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">Resources, designating one resource as the service entry point.</textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">Links for each resource and the resources they refer to.</textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">Methods allowed for each resource, and the associated requests and responses.</textual></para></listitem><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">HTTP headers, including custom headers.</textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">Authentication mechanisms and identity providers, which can be specified for the
          entire service or at the individual resource level.</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">URI parameters and URI templates.</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">HTTP status codes, which are described at the service level (not at the individual
          request level or the resource level), but can be referenced at the request level if need
          be.</textual></para></listitem></itemizedlist><para class="po-block e75 e75"><textual class="po-textual">It is important to clearly understand the relationship between services, resources, links,
      URIs, methods, representations, and media types. A RESTful service is a collection of
      resources, which are identified by URIs. To start using a service, a client needs an entry
      point. A service's published entry point is the URI of the home resource. All other resources
      should be discoverable from the home resource using links, which identify URIs that refer to
      other resources, and can be used for HTTP requests. A client can do a </textual><code class="po-atom e76 e76"><textual class="po-textual">GET</textual></code><textual class="po-textual"> to
      obtain a representation of a resource in, say, XML or JSON. A representation is a sequence of
      bytes that represents the current state of a resource; the syntax and semantics of a
      representation are defined by the corresponding media type. Note that a representation is not
      the same thing as a resource, it is merely the data required to represent the resource's
      state. You cannot send HTTP requests to a representation, you send HTTP requests to a
      resource. You cannot parse or generate a resource, you can parse or generate a representation.
      These distinctions are important, and they are reflected in the structure of RSDL. For
      instance, a media type can provide schemas or descriptions that describe the structure of its
      representations. A resource describes the HTTP requests that can be applied to a resource. In
      RSDL, we view links as an abstraction that represents the potential relationship among
      resources, they have a concrete representation in a given media type. If a given resource has
      both an XML representation and a JSON representation, the same links will be represented in
      different ways by the two media types.</textual></para><para class="po-block e77 e77"><textual class="po-textual">In addition to information that is provided for the benefit of REST clients, some other
      aspects of a REST design should be specified in a structured way simply for the purpose of
      fostering consistent design in the implementation. The design and structure of URIs is a
      particularly important example of this—clients should treat URIs as opaque, but server-side
      implementations need to understand the URIs they respond to, and URIs often contain metadata
      that is useful for someone who is learning an API interactively, so consistent structure in
      URIs is important. The purist side of us would like to leave the structure of URIs completely
      out of the specification, but in practice, the URI formats often link the specification to the
      actual implementation. RSDL allow the structure of a URI to be specified, and variable
      portions of a URI can be specified using a URI template (</textual><xref class="po-milestone e78 e78" linkend="rfc6570"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Our
      documentation stylesheets omit the URI structure in client API documentation for all resources
      except the home resource.</textual></para><para class="po-block e79 e79"><textual class="po-textual">This information is highly structured, with many cross references and semantic
      constraints, but it is typically documented in formats like HTML, Wiki pages, or word
      processing documents, which offer no aid in getting the structure right. And although this
      information is often reused in many different ways, it is not generally created in formats
      that foster reuse. Beyond that, an XML representation of a RESTful web service is extremely
      useful for teaching RESTful service design, creating and maintain designs over time alongside
      implementation code, guiding the process of design, visualizing and evaluating service designs
      created by others, generating various forms of human and machine-readable documentation,
      providing data for testing clients, and generating stubs for server-side code. The structure
      of RSDL's schema can guide the design process, nudging designs to be more RESTful</textual><footnote class="po-popup e80 e80"><para class="po-block e81 e81"><textual class="po-textual">It cannot, of course, force a design to be RESTful, and we are confident that RSDL
          will also be used to create poor designs, but RSDL enforces some important constraints,
          makes it easier to get some important aspects of RESTful design right, and makes it easier
          to create RESTful designs collaboratively and verify them using software. A good notation
          can facilitate good design, but it does not magically produce good design. </textual></para></footnote><textual class="po-textual">.</textual></para><para class="po-block e82 e82"><textual class="po-textual">A RESTful service typically needs to document additional information beyond normal HTTP
      semantics. RSDL allows the following to be documented either in schemas or documentation
      associated with a mediatype, or in documentation elements, which allow documentation to be
      written in HTML, DocBook, or other formats, and can be placed throughout a RSDL description.
      This information includes:</textual></para><itemizedlist class="po-table e83 e83"><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">Application semantics that are orthogonal to REST per se. This is information that is
          completely unknown to a generic REST client, but this information largely defines what the
          application is all about. This includes the application semantics of most XML elements or
          JSON properties. For instance, in Atom, these semantics include the meaning of container
          elements like feeds, entries, and content, and metadata elements like author, category,
          and contributor, etc. In the HTML media type, these semantics include all intended browser
          behavior implied by the data that does not involve the use of links.</textual></para></listitem><listitem class="po-container e86 e86"><para class="po-block e87 e87"><textual class="po-textual">Protocol semantics added by a particular media type. For instance, the Atom Publishing
          Protocol specifies that a POST to a collection URI adds a new member to a collection, a
          side-effect that would be difficult for a generic client to discover if it had no
          knowledge of the media type.</textual></para></listitem></itemizedlist><para class="po-block e88 e88"><textual class="po-textual"> The best-known description language for REST is </textual><xref class="po-milestone e89 e89" linkend="WADL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. WADL provides a
      detailed, well-structured description of a REST interface, but the structure of WADL is driven
      by URI patterns and server-side implementation concerns rather than hypermedia-driven design.
      WADL has been criticized for inviting URI-based tight coupling between the client and the
      server, so that changes to server-side code can break existing clients. From a REST
      perspective, the main problem with WADL is that it exposes interfaces using static metadata,
      instead of describing conventions for discovering and using links, and even provides tools to
      create stub code for clients and servers from the WADL description, code that is guaranteed to
      rely on this static metadata. WADL directly exposes URIs and fixed paths instead of relying on
      links, documents specific errors instead of relying on generic HTTP processing, and does not
      distinguish information needed to specify the server from information provided to the client
      interface. </textual></para><para class="po-block e90 e90"><textual class="po-textual">In many ways, RSDL is similar to WADL, with a great deal of overlap in the information
      that is represented. But RSDL is designed for hypermedia-driven services. In RSDL, every
      service has a single published entry point, which corresponds to a home resource, and all
      other resources can be discovered from the home resource using links. Like WADL, RSDL
      describes resources and relationships among resources, but RSDL always uses links to describe
      relationships. Like WADL, RSDL describes the methods that can be used for to a given resource,
      but RSDL does not describe expected error codes for each method; instead, it relies on the use
      of generic HTTP status codes; if specific semantics are required, e.g. to document the use of
      a redirect for authentication purposes, RSDL allows the semantics of a given status code to be
      documented globally for the service. Like WADL, RSDL allows schemas that describe expected
      formats for representations, but RSDL also allows descriptions in other formats, including W3C
      XML Schemas, Relax-NG, JSON Schema, HTML descriptions, text-based descriptions, or anything
      else that can be referred to with a URI. </textual></para></section><section class="po-hcontainer e91 e91"><title class="po-block e92 e92"><textual class="po-textual">A Sample RSDL Description</textual></title><para class="po-block e93 e93"><textual class="po-textual">The following RSDL example describes a simple service that supports a collection of
      documents. The service uses several media types: an XML Home document as the entry point, an
      atom feed to represent the collection of documents, an HTML description that describes the
      service, and a media type for the documents used in the service. The schema for RSDL is
      provided </textual><link class="po-inline e94 e94" linkend="appx-rsdl.rnc" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">in an appendix</textual></link><textual class="po-textual">. Documentation is embedded at
      many points in the description, using a separate documentation module that is included. The
      appendixes provide documentation modules for </textual><link class="po-inline e95 e95" linkend="appx-html-subset" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">HTML</textual></link><textual class="po-textual"> and
        </textual><link class="po-inline e96 e96" linkend="appx-docbook-subset" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">DocBook</textual></link><textual class="po-textual">, this example uses the HTML
      module.</textual></para><programlisting class="po-block e97 e97" xml:space="preserve"><textual class="po-textual">
      </textual><emphasis class="po-inline e98 e98"><textual class="po-textual">The Documents Service</textual></emphasis><textual class="po-textual">

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service name="Documents" 
  identity-provider-ref="idp" 
  xmlns="http://identifiers.emc.com/rsdl"
  xmlns:html="http://www.w3.org/1999/xhtml/"&gt;

  &lt;documentation&gt;This RESTful service provides a simple ATOM feed that allows documents to be read,
    created, modified, or deleted. &lt;/documentation&gt;

  &lt;start ref="res-home"/&gt;

  &lt;media-types&gt;
    &lt;media-type id="med-document" name="application/vnd.example.document+xml"&gt;
      &lt;documentation&gt; The media type for the service described by this RSDL description.&lt;/documentation&gt;
      &lt;description href="example.com/mediatypes/documents.rnc" type="rnc"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-home-xml" name="application/home+xml"&gt;
      &lt;documentation&gt; Home Documents for HTTP Services: XML Syntax &lt;/documentation&gt;
      &lt;description href="http://tools.ietf.org/html/draft-wilde-home-xml-01.html" type="html"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-atom" name="application/atom+xml"&gt;
      &lt;documentation&gt; Atom feeds, updateable using AtomPub conventions, with feed paging.
      &lt;/documentation&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-html" name="text/html"&gt;
      &lt;documentation&gt; HTML documents. &lt;/documentation&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;

  &lt;resources&gt;
    &lt;resource id="res-home" name="home"&gt;
      &lt;location uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-documents" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-about" resource-ref="res-about"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-home-xml" entity="resources"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-documents" name="documents"&gt;
      &lt;location uri="/documents"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-first" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-next" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-last" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-previous" resource-ref="res-documents"/&gt;

        &lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
          &lt;documentation&gt; 
            In an ATOM feed, we use the alternate link relation to indicate the member
            type. 
          &lt;/documentation&gt;
        &lt;/link&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-atom" entity="atom:feed"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
        &lt;method name="POST"&gt;
          &lt;request&gt;
            &lt;documentation&gt;Creates a document&lt;/documentation&gt;
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/request&gt;
          &lt;response&gt;
            &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-document" name="document"&gt;
      &lt;documentation&gt; &lt;/documentation&gt;
      &lt;location template="/document/{oid}"&gt;
        &lt;var name="oid"&gt;
          &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
        &lt;/var&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-document"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;

        &lt;method name="PUT"&gt;
          &lt;request&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/request&gt;
        &lt;/method&gt;

        &lt;method name="DELETE"/&gt;

      &lt;/methods&gt;
    &lt;/resource&gt;

    &lt;resource id="res-about" name="about" public="true"&gt;
      &lt;documentation&gt;An HTML page describing the service.&lt;/documentation&gt;
      &lt;location uri="/about"/&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-html" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;

  &lt;/resources&gt;

  &lt;link-relations&gt;
    &lt;documentation&gt; Link relations used in the media-type. IANA link relations can be found &lt;ref
        uri="http://www.iana.org/assignments/link-relations/link-relations.xml"&gt;here&lt;/ref&gt;. Non-IANA
      link relations will be registered on identifiers.example.com. &lt;/documentation&gt;

    &lt;link-relation id="rel-about" name="about"/&gt;
    &lt;link-relation id="rel-alternate" name="alternate"/&gt;
    &lt;link-relation id="rel-self" name="self"/&gt;
    &lt;link-relation id="rel-edit" name="edit"/&gt;
    &lt;link-relation id="rel-first" name="first"/&gt;
    &lt;link-relation id="rel-last" name="last"/&gt;
    &lt;link-relation id="rel-next" name="next"/&gt;
    &lt;link-relation id="rel-previous" name="previous"/&gt;
    &lt;link-relation id="rel-parent" name="parent"/&gt;

    &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;

  &lt;/link-relations&gt;

  &lt;headers&gt;
    &lt;header id="hea-authenticate" name="WWW-Authenticate" type="request"/&gt;
  &lt;/headers&gt;

  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;       
    &lt;/mechanism&gt;
    &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;        
  &lt;/authentication&gt;

  &lt;status-codes&gt;
    &lt;status id="sta-unauthorized" code="401"&gt;
      &lt;documentation&gt; The request requires authentication. When this status code is returned, the
        response contains one or more &lt;ref header="hea-authenticate"/&gt; headers that each contain an
          &lt;ref mechanism="aut-http"&gt;authentication challenge&lt;/ref&gt;. &lt;/documentation&gt;
    &lt;/status&gt;
  &lt;/status-codes&gt;
&lt;/service&gt;

    </textual></programlisting><para class="po-block e99 e99"><textual class="po-textual">This example will be examined in more detail in the following section.</textual></para></section><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">The Structure of a RSDL Description</textual></title><para class="po-block e102 e102"><textual class="po-textual">In this section, we will explore the structure of a RSDL description, using the example
      from the previous section. </textual></para><section class="po-hcontainer e103 e103"><title class="po-block e104 e104"><textual class="po-textual">Service</textual></title><para class="po-block e105 e105"><textual class="po-textual">The top-level element for a RSDL description is the service element. Here is the
        structure of the service element, in Relax-NG Compact syntax, together with the optional
        attribute used to designate an identity provider for authentication, and a start element
        that identifies the home resource.</textual></para><programlisting class="po-block e106 e106" xml:space="preserve"><textual class="po-textual">
start = service
service =
    element service {
        id?,
        name,
        identity-provider-ref?,
        documentation?,
        service-start,
        media-types,
        resources,
        link-relations?,
        headers?,
        authentication?,
        status-codes?,
        uri-parameters?
    }
    
service-start = element start { idref }
idref = attribute ref { xsd:IDREF }

identity-provider-ref = attribute identity-provider-ref { xsd:IDREF }    
        </textual></programlisting><para class="po-block e107 e107"><textual class="po-textual">Consider the following fragment:</textual></para><programlisting class="po-block e108 e108" xml:space="preserve"><textual class="po-textual">
&lt;service name="Documents"    
  identity-provider-ref="idp"
  xmlns="http://identifiers.emc.com/rsdl"
  xmlns:html="http://www.w3.org/1999/xhtml/"&gt;

  &lt;documentation&gt; This RESTful service provides a simple ATOM feed that allows documents to be read,
    created, modified, or deleted. &lt;/documentation&gt;

  &lt;start ref="res-home"/&gt;

  !!! SNIP !!!
  
 &lt;/service&gt;
        </textual></programlisting><para class="po-block e109 e109"><textual class="po-textual">The </textual><code class="po-atom e110 e110"><textual class="po-textual">name</textual></code><textual class="po-textual"> of a service is provided primarily for human beings who need to
        refer to the service. REST clients do not use a name to identify a service, they enter a
        service using the URI of the home resource.</textual><footnote class="po-popup e111 e111"><para class="po-block e112 e112"><textual class="po-textual">Some REST designers object to naming services or resources because the names are not
            part of the interface. We believe that names are important because human beings need a
            convenient way to refer to things that they are discussing, and they can be helpful
            metadata in some systems that use RSDL descriptions.</textual></para></footnote></para><para class="po-block e113 e113"><textual class="po-textual">The </textual><code class="po-atom e114 e114"><textual class="po-textual">identity-provider-ref</textual></code><textual class="po-textual"> attribute refers to an identity provider that can
        be used to authenticate for the service. This attribute is an </textual><code class="po-atom e115 e115"><textual class="po-textual">IDREF</textual></code><textual class="po-textual"> that refers
        to an identity provider in the </textual><code class="po-atom e116 e116"><textual class="po-textual">authentication</textual></code><textual class="po-textual"> element, which is discussed
        later. If an identity provider is specified, all resources require authentication by
        default, unless declared public (this is described in the section on
        </textual><code class="po-atom e117 e117"><textual class="po-textual">resources</textual></code><textual class="po-textual">). If no identity provider is specified, resources do not require
        authentication by default, but an individual resource can specify an identity
        provider.</textual></para><para class="po-block e118 e118"><textual class="po-textual">The </textual><code class="po-atom e119 e119"><textual class="po-textual">start</textual></code><textual class="po-textual"> element identifies the home resource, which is the published
        entry point for the service. Because every RESTful service should have a single published
        entry point, the </textual><code class="po-atom e120 e120"><textual class="po-textual">start</textual></code><textual class="po-textual"> element is required. </textual></para></section><section class="po-hcontainer e121 e121"><title class="po-block e122 e122"><textual class="po-textual">Media Types</textual></title><para class="po-block e123 e123"><textual class="po-textual">In RSDL, media types describe the resource representations used in a REST service. In
        the systems we design, it is quite common for a service to use multiple media types; for
        instance, the example we are discussing is focused on documents, but it also uses XML Home
        Documents to provide a set of available links in the home resource, uses Atom and AtomPub
        with feeds to represent collections, and uses HTML to provide a human-readable description
        of the service. The resource representations for a media type may be in XML, for which there
        are standard schema languages, but they may also use JSON or any other format, and the
        authoritative description for a given media type may be a document available in HTML, text,
        PDF, or some other format. Some media types are shared among multiple specifications, other
        media types have no authoritative description. Two media types may represent the same
        properties in XML and JSON respectively. Because of this, media type descriptions in RSDL
        allow reference to any available schema or description in formats we use, but they do not
        require a schema or a description, and a media type can be documented directly in its
          </textual><code class="po-atom e124 e124"><textual class="po-textual">documentation</textual></code><textual class="po-textual"> element. Because some services need both XML and JSON
        representations, we also allow RSDL descriptions to avoid duplication by specifying
        properties in resources rather than in the media types, and documenting the manner in which
        properties are mapped to the corresponding </textual><code class="po-atom e125 e125"><textual class="po-textual">+xml</textual></code><textual class="po-textual"> or </textual><code class="po-atom e126 e126"><textual class="po-textual">+json</textual></code><textual class="po-textual"> media
        types. This is described in the section on </textual><code class="po-atom e127 e127"><textual class="po-textual">resources</textual></code><textual class="po-textual">. </textual></para><para class="po-block e128 e128"><textual class="po-textual">The following schema fragment describes RSDL media types. </textual></para><programlisting class="po-block e129 e129" xml:space="preserve"><textual class="po-textual">
media-types = element media-types { documentation?, media-type* }
media-type = element media-type { id?, name, documentation?, description* }
media-type-ref = attribute media-type-ref { xsd:IDREF }

description = element description { type, href, documentation? }
type = attribute type { "rnc" | "rng" | "xsd" | "JSONSchema" | "sedola" | "text" | "html" }
href = attribute href { xsd:anyURI }        
      </textual></programlisting><para class="po-block e130 e130"><textual class="po-textual">The </textual><code class="po-atom e131 e131"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute of a media type description refers to the language of
        the document referred to by the </textual><code class="po-atom e132 e132"><textual class="po-textual">href</textual></code><textual class="po-textual"> attribute. It can be an XML schema (in
        Relax-NG Compact Syntax (</textual><code class="po-atom e133 e133"><textual class="po-textual">rnc</textual></code><textual class="po-textual">), Relax-NG (</textual><code class="po-atom e134 e134"><textual class="po-textual">rng</textual></code><textual class="po-textual">), or W3C XML Schema
          (</textual><code class="po-atom e135 e135"><textual class="po-textual">xsd</textual></code><textual class="po-textual">), a JSON Schema (</textual><code class="po-atom e136 e136"><textual class="po-textual">JSONSchema</textual></code><textual class="po-textual">), a human readable description
        (in </textual><code class="po-atom e137 e137"><textual class="po-textual">text</textual></code><textual class="po-textual"> or </textual><code class="po-atom e138 e138"><textual class="po-textual">html</textual></code><textual class="po-textual">), or Sedola (</textual><code class="po-atom e139 e139"><textual class="po-textual">sedola</textual></code><textual class="po-textual">), an XML format
        that provides a structured description of a media type with cross-references into the
        document that defines it.</textual><footnote class="po-popup e140 e140"><para class="po-block e141 e141"><textual class="po-textual">We use </textual><xref class="po-milestone e142 e142" linkend="sedola"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> to describe standard media types such as Atom and
            HTML in the same structured way. If we were writing these media types ourselves, we
            would use RSDL to specify the service, and generate Sedola from the RSDL
            description.</textual></para></footnote><textual class="po-textual">
      </textual></para><para class="po-block e143 e143"><textual class="po-textual">Here are the media types for our example:</textual></para><programlisting class="po-block e144 e144" xml:space="preserve"><textual class="po-textual">
  &lt;media-types&gt;
    &lt;media-type id="med-document" name="application/vnd.example.document+xml"&gt;
      &lt;documentation&gt; The media type for the service described by this RSDL description.&lt;/documentation&gt;
      &lt;description href="example.com/mediatypes/documents.rnc" type="rnc"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-home-xml" name="application/home+xml"&gt;
      &lt;documentation&gt; Home Documents for HTTP Services: XML Syntax &lt;/documentation&gt;
      &lt;description href="http://tools.ietf.org/html/draft-wilde-home-xml-01.html" type="html"/&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-atom" name="application/atom+xml"&gt;
      &lt;documentation&gt; Atom feeds, updateable using AtomPub conventions, with feed paging.
      &lt;/documentation&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-html" name="text/html"&gt;
      &lt;documentation&gt; HTML documents. &lt;/documentation&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;        
      </textual></programlisting><para class="po-block e145 e145"><textual class="po-textual">Note that the </textual><code class="po-atom e146 e146"><textual class="po-textual">media-type</textual></code><textual class="po-textual"> for
          </textual><code class="po-atom e147 e147"><textual class="po-textual">application/vnd.example.document+xml</textual></code><textual class="po-textual"> provides both inline documentation and a
        schema, the </textual><code class="po-atom e148 e148"><textual class="po-textual">media-type</textual></code><textual class="po-textual"> for </textual><code class="po-atom e149 e149"><textual class="po-textual">application/home+xml</textual></code><textual class="po-textual"> provides inline
        documentation and a reference to an HTML page, and the </textual><code class="po-atom e150 e150"><textual class="po-textual">media-type</textual></code><textual class="po-textual">s for
          </textual><code class="po-atom e151 e151"><textual class="po-textual">application/atom+xml</textual></code><textual class="po-textual"> and </textual><code class="po-atom e152 e152"><textual class="po-textual">text/html</textual></code><textual class="po-textual"> provide only brief inline
        documentation. </textual></para></section><section class="po-hcontainer e153 e153"><title class="po-block e154 e154"><textual class="po-textual">Resources</textual></title><para class="po-block e155 e155"><textual class="po-textual">Resources are at the heart of RSDL, which provides rich support for them. Here is a
        schema fragment for resources:</textual></para><programlisting class="po-block e156 e156" xml:space="preserve"><textual class="po-textual">
resources = element resources { id?, documentation?, resource* }
resource =
    element resource {
        documentation?,
        id,
        name,
        identity-provider-ref?,
        public?,
        status?,
        extends?,
        location?,
        properties?,
        links?,
        methods
    }
    
name = attribute name { text }
public = attribute public { "true" }

status = implementation-status?, design-status?
implementation-status =
    attribute implementation-status {
        "future" | "assigned" | "poc" | "partial" | "complete" | "passed"
    }
design-status =
    attribute design-status { "future" | "assigned" | "poc" | "partial" | "complete" | "approved" }
    
# A resource can extend an existing resource definition, inheriting what it already defines.
extends = attribute extends { xsd:IDREF }

location = element location { documentation?, (uri | (uri-template, var*)) }
uri = attribute uri { xsd:anyURI }
uri-template = attribute template { xsd:string }
# uri-parameter-ref indicates that the value is supplied by the client, using a URI parameter.
# If no uri-parameter-ref is present, the value is supplied by the server.
var = element var { documentation?, id?, name, uri?, uri-parameter-ref? }

properties = element properties { documentation?, property* }
property = element property { id?, name, documentation? }

links = element links { documentation?, link* }
link = element link { link-relation-ref, resource-ref, status?, documentation? }
resource-ref = attribute resource-ref { xsd:IDREF }
link-relation-ref = attribute link-relation-ref { xsd:anyURI }

methods = element methods { method* }
method = element method { id?, method-name, status?, request?, response? }
method-name = attribute name { http-method }

request = element request { documentation?, request-uri-parameters?, header-refs?, representation* }
response =
    element response { documentation?, response-status-codes?, header-refs?, representation* }
request-uri-parameters = element uri-parameters { request-uri-parameter }
request-uri-parameter = element uri-parameter { idref }
# When possible, avoid documenting status codes at the individual request level.
# If you have to, declare it globally and refer to it from the request.
response-status-codes =
    element status-codes {
        element status-code { ref }*
    }
# When possible, avoid documenting headers at the individual request level.
# If you have to, declare it globally and refer to it from the request.    
header-refs = element header-refs { documentation?, header-ref* }
header-ref = element header-ref { ref }
representation = element representation { documentation?, media-type-ref, entity? }
entity = attribute entity { text }
http-method = "GET" | "PUT" | "HEAD" | "POST" | "DELETE" | "TRACE" | "OPTIONS" | "CONNECT" | "PATCH"    
      </textual></programlisting><para class="po-block e157 e157"><textual class="po-textual">Let's look at three resources from our example. The home resource for our example is an
        XML Home Document. In our own designs, we frequently use </textual><xref class="po-milestone e158 e158" linkend="json-home"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, or
          </textual><xref class="po-milestone e159 e159" linkend="xml-home"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> as the home document for a resource, but Atom feeds are also
        popular as home documents, and some services use a single application-domain object as the
        home document. Here is the RSDL description of an XML Home Document resource:</textual></para><programlisting class="po-block e160 e160" xml:space="preserve"><textual class="po-textual">
    &lt;resource id="res-home" name="home"&gt;
      &lt;location uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;      
        &lt;link link-relation-ref="rel-documents" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-about" resource-ref="res-about"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-home-xml" entity="resources"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;</textual></programlisting><para class="po-block e161 e161"><textual class="po-textual">In this example, the methods and the links define the interface for the resource. Like
        the name of a service, the name of a resource is not part of the interface. Neither is the
          </textual><code class="po-atom e162 e162"><textual class="po-textual">id</textual></code><textual class="po-textual">, it exists to allow cross-reference in a RSDL description. Nor is the
          </textual><code class="po-atom e163 e163"><textual class="po-textual">location</textual></code><textual class="po-textual"> element, which is optional.</textual></para><para class="po-block e164 e164"><textual class="po-textual">A method specifies an HTTP method name that is supported for the resource in which it
        contains and the </textual><code class="po-atom e165 e165"><textual class="po-textual">request</textual></code><textual class="po-textual"> or </textual><code class="po-atom e166 e166"><textual class="po-textual">response</textual></code><textual class="po-textual"> associated with the method.
        In the above example, a </textual><code class="po-atom e167 e167"><textual class="po-textual">GET</textual></code><textual class="po-textual"> method results in a response that contains the
        representation of an XML Home Document, which was specified in the media types we discussed
        in an earlier section.</textual></para><para class="po-block e168 e168"><textual class="po-textual">The links each define a transition to another resource. Each link contains a reference
        to a globally declared link relation, discussed later, and the resource to which the link
        resolves. One link element is created for each (</textual><code class="po-atom e169 e169"><textual class="po-textual">link-relation-ref</textual></code><textual class="po-textual">,
          </textual><code class="po-atom e170 e170"><textual class="po-textual">resource-ref</textual></code><textual class="po-textual">) pair. Note that RSDL allows links to be defined only in terms
        of link relations, not in terms of the structure of URIs. A link refers to a resource, not a
        representation; to find the available representations for a resource, look at the resource
        and see what it returns for </textual><code class="po-atom e171 e171"><textual class="po-textual">GET</textual></code><textual class="po-textual">. In this example, the second link contains a
        reference to a globally declared link relation with the id </textual><code class="po-atom e172 e172"><textual class="po-textual">rel-documents</textual></code><textual class="po-textual">, which
        is defined as follows: </textual></para><programlisting class="po-block e173 e173" xml:space="preserve"><textual class="po-textual">
      &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;
      </textual></programlisting><para class="po-block e174 e174"><textual class="po-textual">It also contains a reference to the resource with the id </textual><code class="po-atom e175 e175"><textual class="po-textual">res-documents</textual></code><textual class="po-textual">, an
        Atom feed which is described below:</textual></para><programlisting class="po-block e176 e176" xml:space="preserve"><textual class="po-textual">
    &lt;resource id="res-documents" name="documents"&gt;
      &lt;location uri="/documents"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-documents"/&gt;
        
        &lt;link link-relation-ref="rel-first" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-next" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-last" resource-ref="res-documents"/&gt;
        &lt;link link-relation-ref="rel-previous" resource-ref="res-documents"/&gt;

        &lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
          &lt;documentation&gt; 
            In an ATOM feed, we use the alternate link relation to indicate the member
            type. 
          &lt;/documentation&gt;
        &lt;/link&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-atom" entity="atom:feed"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
        &lt;method name="POST"&gt;
          &lt;request&gt;
            &lt;documentation&gt;Creates a document&lt;/documentation&gt;          
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/request&gt;
          &lt;response&gt;
            &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;          
            &lt;representation media-type-ref="med-document" entity="document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
  </textual></programlisting><para class="po-block e177 e177"><textual class="po-textual">This resource is an Atom feed that supports paging and adding new documents. The
        following link relations refer to the IANA standard link relations used for paging:</textual></para><programlisting class="po-block e178 e178" xml:space="preserve"><textual class="po-textual">
&lt;link-relation id="rel-first" name="first"/&gt;
&lt;link-relation id="rel-last" name="last"/&gt;
&lt;link-relation id="rel-next" name="next"/&gt;
&lt;link-relation id="rel-previous" name="previous"/&gt;
   </textual></programlisting><para class="po-block e179 e179"><textual class="po-textual">Because this resource supports AtomPub, it has a POST method. Both the request and the
        response refer to the </textual><code class="po-atom e180 e180"><textual class="po-textual">document</textual></code><textual class="po-textual"> entity, as defined by the media type with the
        identifier </textual><code class="po-atom e181 e181"><textual class="po-textual">med-document</textual></code><textual class="po-textual">.</textual></para><programlisting class="po-block e182 e182" xml:space="preserve"><textual class="po-textual">      
&lt;method name="POST"&gt;
    &lt;request&gt;
        &lt;documentation&gt;Creates a document&lt;/documentation&gt;
        &lt;representation media-type-ref="med-document" entity="document"/&gt;
    &lt;/request&gt;
    &lt;response&gt;
        &lt;documentation&gt;Returns the newly created document&lt;/documentation&gt;
        &lt;representation media-type-ref="med-document" entity="document"/&gt;
    &lt;/response&gt;
&lt;/method&gt;  
   </textual></programlisting><para class="po-block e183 e183"><textual class="po-textual">This resource uses the IANA standard </textual><code class="po-atom e184 e184"><textual class="po-textual">alternate</textual></code><textual class="po-textual"> link relation to describe
        the type of the collection's members:</textual></para><programlisting class="po-block e185 e185" xml:space="preserve"><textual class="po-textual">
&lt;link link-relation-ref="rel-alternate" resource-ref="res-document"&gt;
   &lt;documentation&gt; 
       In an ATOM feed, we use the alternate link relation to indicate the member type. 
   &lt;/documentation&gt;
&lt;/link&gt; 
      </textual></programlisting><para class="po-block e186 e186"><textual class="po-textual">Here is the resource that corresponds to the member type:</textual></para><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual">
    &lt;resource id="res-document" name="document"&gt;
      &lt;location template="/document/{oid}"&gt;
        &lt;var name="oid"&gt;
          &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
        &lt;/var&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-self" resource-ref="res-document"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;

        &lt;method name="PUT"&gt;
          &lt;request&gt;
            &lt;representation media-type-ref="med-document" entity="res-document"/&gt;
          &lt;/request&gt;
        &lt;/method&gt;

        &lt;method name="DELETE"/&gt;

      &lt;/methods&gt;
    &lt;/resource&gt;
    </textual></programlisting><para class="po-block e188 e188"><textual class="po-textual">Sometimes a resource has different authentication constraints than other resources in
        the same service. In our example, the </textual><code class="po-atom e189 e189"><textual class="po-textual">about</textual></code><textual class="po-textual"> resource does not require
        authentication, even though the service has specified authentication globally. This is
        expressed using the </textual><code class="po-atom e190 e190"><textual class="po-textual">public=true</textual></code><textual class="po-textual"> attribute:</textual></para><programlisting class="po-block e191 e191" xml:space="preserve"><textual class="po-textual">
&lt;resource id="res-about" name="about" public="true"&gt;
    &lt;documentation&gt;An HTML page describing the service.&lt;/documentation&gt;
    &lt;location uri="/about"/&gt;
    &lt;methods&gt;
        &lt;method name="GET"&gt;
            &lt;response&gt;
                &lt;representation media-type-ref="med-html" entity="html"/&gt;
            &lt;/response&gt;
        &lt;/method&gt;
    &lt;/methods&gt;
&lt;/resource&gt;
      </textual></programlisting><para class="po-block e192 e192"><textual class="po-textual">The opposite situation is also common - a service may need no authentication on most
        resources, but require authentication for specific resources such as a payment resource, or
        perhaps one resource uses a different kind of authentication from others. Both can be
        expressed using an </textual><code class="po-atom e193 e193"><textual class="po-textual">identity-provider-ref</textual></code><textual class="po-textual"> attribute on the resource, specifying
        the authentication to be used.</textual></para><para class="po-block e194 e194"><textual class="po-textual">The </textual><code class="po-atom e195 e195"><textual class="po-textual">location</textual></code><textual class="po-textual"> element is always optional, and is not part of the client
        interface. It specifies a location URI or a URI template that describes the format of a URI
        that resolves to a given resource. Here are two location elements that illustrate both
        possibilities:</textual></para><programlisting class="po-block e196 e196" xml:space="preserve"><textual class="po-textual">
&lt;location uri="/about"/&gt;            
        </textual></programlisting><programlisting class="po-block e197 e197" xml:space="preserve"><textual class="po-textual">
&lt;location template="/document/{oid}"&gt;
    &lt;var name="oid"&gt;
        &lt;documentation&gt; Identifier for the document. &lt;/documentation&gt;
    &lt;/var&gt;
&lt;/location&gt;  
        </textual></programlisting><para class="po-block e198 e198"><textual class="po-textual">A variable in a URI template sometimes corresponds to a URI parameter that should be
        provided by the client. This can be expressed by adding a </textual><code class="po-atom e199 e199"><textual class="po-textual">uri-parameter-ref</textual></code><textual class="po-textual">
        attribute to the variable:</textual></para><programlisting class="po-block e200 e200" xml:space="preserve"><textual class="po-textual">
&lt;location template="/document/{oid}"&gt;
    &lt;var name="oid" uri-parameter-ref="par-oid"/&gt;
&lt;/location&gt;  
        </textual></programlisting><para class="po-block e201 e201"><textual class="po-textual">URI parameters can also be specified in a request. For instance, if we want to allow an
        Atom feed to be sorted, we could provide a URI parameter to specify the sort in the
          </textual><code class="po-atom e202 e202"><textual class="po-textual">GET</textual></code><textual class="po-textual"> request:</textual></para><programlisting class="po-block e203 e203" xml:space="preserve"><textual class="po-textual">
&lt;method name="GET"&gt;
    &lt;request&gt;
        &lt;uri-parameters&gt;
            &lt;uri-parameter ref="par-sortby"/&gt; 
        &lt;/uri-parameters&gt;            
    &lt;/request&gt;
    &lt;response&gt;
        &lt;representation media-type-ref="med-atom" entity="feed"/&gt;
    &lt;/response&gt;
&lt;/method&gt;        
        </textual></programlisting><para class="po-block e204 e204"><textual class="po-textual">On a </textual><code class="po-atom e205 e205"><textual class="po-textual">resource</textual></code><textual class="po-textual"> element, the </textual><code class="po-atom e206 e206"><textual class="po-textual">extends</textual></code><textual class="po-textual"> attribute allows one
        resource to inherit all items from an existing resource and extend it by adding further
        items or override existing items. For instance, the following description creates an
          </textual><code class="po-atom e207 e207"><textual class="po-textual">invoice</textual></code><textual class="po-textual"> resource that inherits everything found in a </textual><code class="po-atom e208 e208"><textual class="po-textual">document</textual></code><textual class="po-textual">
        resource, and adds a link to represent the customer for an invoice:</textual></para><programlisting class="po-block e209 e209" xml:space="preserve"><textual class="po-textual">
&lt;resource id="res-invoice" name="invoice" extends="res-document"&gt;
  &lt;links&gt;
    &lt;link link-relation-ref="rel-customer" resource-ref="res-customer"/&gt;
  &lt;/links&gt;  
&lt;/resource&gt;
        </textual></programlisting><para class="po-block e210 e210"><textual class="po-textual">Status attributes on a </textual><code class="po-atom e211 e211"><textual class="po-textual">resource</textual></code><textual class="po-textual"> element can be used to track both the
        design status and the implementation status:</textual></para><programlisting class="po-block e212 e212" xml:space="preserve"><textual class="po-textual">      
&lt;resource id="res-document" name="document" design-status="approved" implementation-status="poc"&gt;      
      </textual></programlisting><para class="po-block e213 e213"><code class="po-atom e214 e214"><textual class="po-textual">property</textual></code><textual class="po-textual"> elements can be used to specify properties of a resource. This is
        typically done when more than one media type represents the same resource, in order to
        minimize redundant specification. In this case, the media types should describe how a
        property is mapped to its representation. Note that property elements are defined purely by
        documentation, they do not have a standard type system or a standard set of
        datatypes.</textual></para><programlisting class="po-block e215 e215" xml:space="preserve"><textual class="po-textual">
&lt;properties&gt;
    &lt;property name="expiration"&gt;
        &lt;documentation&gt;A date, representing the expiration date of the document.&lt;/documentation&gt;
    &lt;/property&gt;   
&lt;/properties&gt;        
      </textual></programlisting></section><section class="po-hcontainer e216 e216"><title class="po-block e217 e217"><textual class="po-textual">Link Relations</textual></title><para class="po-block e218 e218"><textual class="po-textual">Link relations are declared globally. We recommend that even IANA standard link
        relations be documented for a service, because there are many standard link relations, and
        their meaning is not completely specified, their meaning needs to be specified concretely
        for a given service. Link relations are declared globally and referred to from individual
        resources. If the name of a link relation is not registered with IANA, its name should be a
        URI, such as </textual><code class="po-atom e219 e219"><textual class="po-textual">identifiers.example.com/linkrel/documents</textual></code><textual class="po-textual">.</textual></para><programlisting class="po-block e220 e220" xml:space="preserve"><textual class="po-textual">
  &lt;link-relations&gt;
    &lt;documentation&gt; Link relations used in the media-type. IANA link relations can be found &lt;ref
        uri="http://www.iana.org/assignments/link-relations/link-relations.xml"&gt;here&lt;/ref&gt;. Non-IANA
      link relations will be registered on identifiers.example.com. &lt;/documentation&gt;

    &lt;link-relation id="rel-about" name="about"/&gt;
    &lt;link-relation id="rel-alternate" name="alternate"/&gt;
    &lt;link-relation id="rel-self" name="self"/&gt;
    &lt;link-relation id="rel-edit" name="edit"/&gt;
    &lt;link-relation id="rel-first" name="first"/&gt;
    &lt;link-relation id="rel-last" name="last"/&gt;
    &lt;link-relation id="rel-next" name="next"/&gt;
    &lt;link-relation id="rel-previous" name="previous"/&gt;
    &lt;link-relation id="rel-parent" name="parent"/&gt;

    &lt;link-relation id="rel-documents" name="identifiers.example.com/linkrel/documents"/&gt;

  &lt;/link-relations&gt;        
      </textual></programlisting></section><section class="po-hcontainer e221 e221"><title class="po-block e222 e222"><textual class="po-textual">Headers</textual></title><para class="po-block e223 e223"><textual class="po-textual">Headers are declared globally. We recommend that even standard HTTP headers be
        documented for a service, so that clients know what is required.</textual></para><programlisting class="po-block e224 e224" xml:space="preserve"><textual class="po-textual">
  &lt;headers&gt;
    &lt;header id="hea-authenticate" name="WWW-Authenticate" type="request"/&gt;
  &lt;/headers&gt;        
      </textual></programlisting></section><section class="po-hcontainer e225 e225"><title class="po-block e226 e226"><textual class="po-textual">Authentication</textual></title><para class="po-block e227 e227"><textual class="po-textual">Authentication mechanisms and identity providers are declared globally. Here is the
        schema fragment for authentication:</textual></para><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">
authentication = element authentication { mechanism*,  identity-provider* }
mechanism = element mechanism { id?, name, authentication-type, documentation?, scheme* }
mechanism-ref = attribute mechanism-ref { xsd:IDREF }
identity-provider = element identity-provider { id, mechanism-ref }
authentication-type = attribute authentication-type { text }
scheme = element scheme { id?, name, documentation?, scheme-parameter* }
scheme-parameter = element parameter { id?, name, documentation? }        
        </textual></programlisting><para class="po-block e229 e229"><textual class="po-textual">Here is the authentication used in our example:</textual></para><programlisting class="po-block e230 e230" xml:space="preserve"><textual class="po-textual">
  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;
      &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;       
    &lt;/mechanism&gt;
  &lt;/authentication&gt;        
      </textual></programlisting></section><section class="po-hcontainer e231 e231"><title class="po-block e232 e232"><textual class="po-textual">Status Codes</textual></title><para class="po-block e233 e233"><textual class="po-textual">Status codes are declared globally. In order to avoid tight coupling, we do not provide
        a direct mechanism for documenting status codes for an individual request (the documentation
        for a request can refer to globally declared status codes as necessary). We recommend that a
        service document any uncommon status codes or uncommon uses of status codes at the service
        level so that clients can be prepared to handle them. Details of error conditions can be
        reported with </textual><xref class="po-milestone e234 e234" linkend="draft-nottingham-http-problem-04"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> conventions using the
          </textual><code class="po-atom e235 e235"><textual class="po-textual">http-problem</textual></code><textual class="po-textual"> element, as specified in the schema</textual></para><programlisting class="po-block e236 e236" xml:space="preserve"><textual class="po-textual">
status-codes = element status-codes { documentation?, status-code* }
status-code = element status { code, id, documentation?, http-problem? }
status-code-ref = attribute ref { xsd:IDREF }
code = attribute code { HTTP-status-enum }
HTTP-status-enum =
    "100"
    | "101"
    | "102"
    | "200"
    | "201"
    | "203"
    | "204"
    | "205"
    | "206"
    | "207"
    | "208"
    | "301"
    | "302"
    | "303"
    | "304"
    | "305"
    | "306"
    | "307"
    | "308"
    | "400"
    | "401"
    | "402"
    | "403"
    | "404"
    | "405"
    | "406"
    | "407"
    | "408"
    | "409"
    | "410"
    | "411"
    | "412"
    | "413"
    | "414"
    | "415"
    | "416"
    | "417"
    | "418"
    | "420"
    | "422"
    | "423"
    | "424"
    | "425"
    | "426"
    | "428"
    | "429"
    | "431"
    | "444"
    | "449"
    | "450"
    | "451"
    | "494"
    | "495"
    | "496"
    | "497"
    | "499"
    | "500"
    | "501"
    | "502"
    | "503"
    | "504"
    | "505"
    | "506"
    | "507"
    | "508"
    | "509"
    | "510"
    | "511"
    | "598"
    | "599"        
      </textual></programlisting></section><section class="po-hcontainer e237 e237"><title class="po-block e238 e238"><textual class="po-textual">URI Parameters</textual></title><para class="po-block e239 e239"><textual class="po-textual">URI parameters are declared globally, and can be referenced from </textual><code class="po-atom e240 e240"><textual class="po-textual">request</textual></code><textual class="po-textual">s
        in </textual><code class="po-atom e241 e241"><textual class="po-textual">method</textual></code><textual class="po-textual">s.</textual></para><programlisting class="po-block e242 e242" xml:space="preserve"><textual class="po-textual">
  &lt;uri-parameters&gt;
    &lt;uri-parameter id="par-sortby" name="sortby" datatype="string"&gt;
      &lt;documentation&gt;
        Specifies a sort order for the collection.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
  &lt;/uri-parameters&gt;         
      </textual></programlisting></section><section class="po-hcontainer e243 e243"><title class="po-block e244 e244"><textual class="po-textual">Documentation Modules</textual></title><para class="po-block e245 e245"><textual class="po-textual">The content allowed within a </textual><code class="po-atom e246 e246"><textual class="po-textual">documentation</textual></code><textual class="po-textual"> element is defined by a separate
        module that is imported.</textual></para><programlisting class="po-block e247 e247" xml:space="preserve"><textual class="po-textual">
include "documentation.rnc"        
      </textual></programlisting><para class="po-block e248 e248"><textual class="po-textual">We have defined modules </textual><link class="po-inline e249 e249" linkend="appx-html-subset" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">for HTML</textual></link><textual class="po-textual"> and </textual><link class="po-inline e250 e250" linkend="appx-docbook-subset" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">for DocBook</textual></link><textual class="po-textual">. A </textual><code class="po-atom e251 e251"><textual class="po-textual">documentation</textual></code><textual class="po-textual"> element can
        have a title, which is treated much like a section header, and an </textual><code class="po-atom e252 e252"><textual class="po-textual">inline</textual></code><textual class="po-textual">
        attribute. Documentation that contains code examples, tables, multiple sections, or large
        amounts of text can be marked </textual><code class="po-atom e253 e253"><textual class="po-textual">inline="false"</textual></code><textual class="po-textual"> so that a stylesheet can convert
        it to endnotes, a popup window, or whatever representation is appropriate to the format the
        stylesheet produces.</textual></para><para class="po-block e254 e254"><textual class="po-textual">Here is the first part of the HTML documentation module:</textual></para><programlisting class="po-block e255 e255" xml:space="preserve"><textual class="po-textual">
namespace html = "http://www.w3.org/1999/xhtml/"
namespace docbook = "http://docbook.org/ns/docbook"

documentation = element documentation { inline?, doc-title?, html }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

html =  html-content*
html-content = (html-element | text | ref)
html-element = element html:* { html-attribute*, html-content* }
html-attribute = attribute * { text? }</textual></programlisting><para class="po-block e256 e256"><textual class="po-textual">Documentation frequently needs to refer to items from the RSDL description itself, so we
        support typed references interspersed with documentation:</textual></para><programlisting class="po-block e257 e257" xml:space="preserve"><textual class="po-textual">
ref = element ref {
  (  attribute idref { xsd:IDREF }
  | attribute uri { xsd:anyURI }
  | attribute media-type { xsd:IDREF }
  | attribute header { xsd:IDREF }
  | attribute mechanism { xsd:IDREF }
  | attribute identity-provider { xsd:IDREF }
  | attribute scheme { xsd:IDREF }
  | attribute scheme-parameter { xsd:IDREF }
  | attribute status-code { xsd:IDREF }
  | attribute uri-parameter { xsd:IDREF }
  | attribute resources { xsd:IDREF }
  | attribute resource { xsd:IDREF }
  | attribute var { xsd:IDREF }
  | attribute property { xsd:IDREF } 
  | attribute header { xsd:IDREF } 
  | attribute method { xsd:IDREF } 
  ),
  text?  # Uses the name of the referred item if not provided
}       
      </textual></programlisting><para class="po-block e258 e258"><textual class="po-textual">We have already seen an example that uses </textual><code class="po-atom e259 e259"><textual class="po-textual">ref</textual></code><textual class="po-textual"> elements in the
          </textual><code class="po-atom e260 e260"><textual class="po-textual">documentation</textual></code><textual class="po-textual"> element for a </textual><code class="po-atom e261 e261"><textual class="po-textual">mechanism</textual></code><textual class="po-textual">:</textual></para><programlisting class="po-block e262 e262" xml:space="preserve"><textual class="po-textual">
  &lt;authentication&gt;
    &lt;mechanism id="aut-http" name="HTTP Authentication" authentication-type="rfc2617"&gt;
      &lt;documentation&gt; 
        We use HTTP Authentication as defined in &lt;ref uri="http://tools.ietf.org/html/rfc2617"&gt;RFC 2617&lt;/ref&gt; 
        with custom schemes. If an unauthenticated user tries to access a protected resource, a 
        &lt;ref status-code="sta-unauthorized"/&gt; status is returned, along with one or more 
        &lt;ref header="hea-authenticate"/&gt; headers, each of which contains an authentication 
        &lt;html:em&gt;challenge&lt;/html:em&gt;. The challenges consist of a scheme followed by one or more parameters. 
      &lt;/documentation&gt;
      &lt;scheme name="basic"&gt;
        &lt;parameter name="realm"/&gt;
      &lt;/scheme&gt;
      &lt;identity-provider id="idp" mechanism-ref="aut-http"/&gt;      
    &lt;/mechanism&gt;
  &lt;/authentication&gt;        
        </textual></programlisting></section></section><section class="po-hcontainer e263 e263"><title class="po-block e264 e264"><textual class="po-textual">Initial Experience</textual></title><para class="po-block e265 e265"><textual class="po-textual">RSDL is quite new. We have recently started using it for some REST projects in the
      Information Intelligence Group at EMC Corporation. In this section, we would like to share our
      experiences so far.</textual></para><para class="po-block e266 e266"><textual class="po-textual">We have found RSDL a valuable teaching tool in the hands of a teacher who is comfortable
      editing XML. On two projects, one of the authors was involved with an early design that was
      having difficulty ramping up the design, and responded by editing a RSDL description on a
      shared screen during a phone call with an engineer from the project. In each case, it was easy
      to copy similar designs from existing RSDL descriptions and modify them, then provide the RSDL
      description to the engineer as an initial skeleton for the design. With a standard description
      language, we believe we will be able to grow a library of common REST design patterns that can
      be copied and modified to design a REST interface.</textual></para><para class="po-block e267 e267"><textual class="po-textual">Before RSDL, we maintained our REST specifications largely in Wikis, and a single design
      was frequently distributed across many Wiki pages. As a specification matured, it was
      difficult to keep these pages in sync, with accurate cross-references. More than one page
      might purport to represent the same design, different pages might represent the same
      information in more than one way, and the Wiki pages did little to enforce REST conventions.
      RSDL makes it much easier to version a design. By checking a RSDL description into source code
      control, reviewers can see changes in the design specification along with code changes, and it
      is always possible to retrieve the design specification that corresponds to a particular
      version of the code.</textual></para><para class="po-block e268 e268"><textual class="po-textual">Before RSDL, user documentation was created from information in these Wikis, initially by
      converting it to DocBook. RSDL allows this to be done using an XSLT transformation. We expect
      to integrate RSDL into our documentation tool chain. </textual></para><para class="po-block e269 e269"><textual class="po-textual">While the structure of a URI should not be provided to clients, we have found that it is
      important for actually implementing a service. For instance, if the URI structure is included,
      skeleton code could be generated to create stubs that can be used to implement a server, using
      a REST framework such as JAX-RS for Java. </textual></para><para class="po-block e270 e270"><textual class="po-textual">We have been experimenting with REST clients that perform QA testing using a RSDL
      description. One of us wrote a REST client that takes a RSDL file as input and issues HTTP
      requests, navigating the service, and ensuring that each response corresponds to the RSDL
      description and reporting any deviations. In effect, the test client infers the design from
      the actual implementation, and compares it to the design specified by the RSDL description. As
      a result, we found missing resources and links in the implementation, and resources that had
      been implemented but not specified, and methods that should not be available on a resource. We
      also found code that did not properly handle edge cases for data provided via URI templates
      (in the future, we may develop a fuzzer to test for this kind of problem). We have used this
      test client in our build process. When a new resource is implemented, or an existing one is
      changed, we can test to see if the RSDL was also updated appropriately. If not, the build
      fails. Because both the build process and the documentation are synchronized with the
      specification, we can guarantee that the specification, the code, and the documentation are
      kept in sync.</textual></para></section><section class="po-hcontainer e271 e271"><title class="po-block e272 e272"><textual class="po-textual">Future Work</textual></title><para class="po-block e273 e273"><textual class="po-textual">This section describes some tools that have not yet been written, or in very early stages,
      that we are considering implementing.</textual></para><para class="po-block e274 e274"><textual class="po-textual">RSDL Lint is an XSLT transform that checks a RSDL description for internal consistency. In
      its current form, it ensures that an </textual><code class="po-atom e275 e275"><textual class="po-textual">IDREF</textual></code><textual class="po-textual"> refers to an element of the
      appropriate type, ensures that identifiers follow our in-house standards, screens for media
      types that we do not allow in our interfaces, and warns of items that cannot be reached from
      the home resource by navigation. It can be integrated into the build process, raising either
      errors or warnings. We expect to expand the functionality of RSDL Lint significantly.</textual></para><para class="po-block e276 e276"><textual class="po-textual">When documenting REST APIs, we often want to capture the results of concrete scenarios
      running on a server and show the entire sequence of calls, including the URIs, requests, and
      responses. We are writing a tool executes a message flow using an XML vocabulary that refers
      to the components of a RSDL description. This tool generates HTML to document the requests and
      responses of the message flow. As the specification evolves, or the data in the server
      changes, the message flow can be run again to create up-to-date documentation. </textual></para><para class="po-block e277 e277"><textual class="po-textual">We plan to experiment with domain-specific editors and browsers for RSDL, including the
      ability to select templates that implement standard RESTful design patterns so that they can
      be modified.</textual></para></section><section class="po-hcontainer e278 e278"><title class="po-block e279 e279"><textual class="po-textual">Conclusions</textual></title><para class="po-block e280 e280"><textual class="po-textual">RSDL provides a formal notation that can be used to think more clearly about the model for
      a RESTful service. It is an XML vocabulary designed for loosely-coupled, hypermedia-driven
      RESTful design, and supports the rich structure and cross references of a REST service. We
      find it useful as a teaching tool, a design tool, and a way to represent known design patterns
      that can be copied and modified in a new RESTful service. RSDL can be used to generate
      documentation in various formats. </textual></para><para class="po-block e281 e281"><textual class="po-textual">As a machine-readable description, RSDL can be used for software-based testing of design
      consistency constraints, dynamic testing of the implementation based on the design, and in a
      variety of other tools. These tools can be integrated with the build process, identifying
      mismatches between the specification and the implementation. By versioning a RSDL description
      together with source code, reviewers can see changes in the design specification along with
      code changes, and it is always possible to retrieve the design specification that corresponds
      to a particular version of the code.</textual></para><para class="po-block e282 e282"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></section><appendix class="po-hcontainer e283 e283" xml:id="appx-rsdl.rnc"><title class="po-block e284 e284"><textual class="po-textual">RSDL Schema</textual></title><para class="po-block e285 e285"><textual class="po-textual">The following schema, in RELAX-NG compact syntax, defines RSDL.</textual></para><programlisting class="po-block e286 e286" xml:space="preserve"><textual class="po-textual">

default namespace rsdl = "http://identifiers.emc.com/rsdl"

include "documentation.rnc"

start = service
service =
    element service {
        id?,
        name,
        identity-provider-ref?,
        documentation?,
        service-start,
        media-types,
        resources,
        link-relations?,
        headers?,
        authentication?,
        status-codes?,
        uri-parameters?
    }
    
id = attribute id { xsd:ID }
idref = attribute ref { xsd:IDREF }

service-start = element start { idref }
identity-provider-ref = attribute identity-provider-ref { xsd:IDREF }

media-types = element media-types { documentation?, media-type* }
media-type = element media-type { id?, name, documentation?, description* }
media-type-ref = attribute media-type-ref { xsd:IDREF }
description = element description { type, href, documentation? }
type = attribute type { "rnc" | "rng" | "xsd" | "JSONSchema" | "sedola" | "text" | "html" }
href = attribute href { xsd:anyURI }

resources = element resources { id?, documentation?, resource* }
resource =
    element resource {
        documentation?,
        id,
        name,
        identity-provider-ref?,
        public?,
        status?,
        extends?,
        location?,
        properties?,
        links?,
        methods
    }
    
name = attribute name { text }
public = attribute public { "true" }

status = implementation-status?, design-status?
implementation-status =
    attribute implementation-status {
        "future" | "assigned" | "poc" | "partial" | "complete" | "passed"
    }
design-status =
    attribute design-status { "future" | "assigned" | "poc" | "partial" | "complete" | "approved" }
# A resource can extend an existing resource definition, inheriting what it already defines.

extends = attribute extends { xsd:IDREF }

location =
    element location {
        documentation?,
        (uri | (uri-template, var*))
    }
uri-template = attribute template { xsd:string }
# URI refers to a link relation. If absent, it is a local link relation, identified by name.
# uri-parameter-ref indicates that the value is supplied by the client, using a URI parameter.
#    If no uri-parameter-ref is present, the value is supplied by the server.
var = element var { documentation?, id?, name, uri?, uri-parameter-ref? }

properties = element properties { documentation?, property* }
property = element property { id?, name, documentation? }

links = element links { documentation?, link* }
link = element link { link-relation-ref, resource-ref, status?, documentation? }
resource-ref = attribute resource-ref { xsd:IDREF }
link-relation-ref = attribute link-relation-ref { xsd:anyURI }

methods = element methods { method* }
method = element method { id?, method-name, status?, request?, response? }
method-name = attribute name { http-method }
request = element request { documentation?, request-uri-parameters?, header-refs?, representation* }
response =
    element response { documentation?, response-status-codes?, header-refs?, representation* }
request-uri-parameters = element uri-parameters { request-uri-parameter }
request-uri-parameter = element uri-parameter { idref }
response-status-codes =
    element status-codes {
        element status-code { ref }*
    }

header-refs = element header-refs { documentation?, header-ref* }
header-ref = element header-ref { ref }

representation = element representation { documentation?, media-type-ref, entity? }
entity = attribute entity { text }

http-method = "GET" | "PUT" | "HEAD" | "POST" | "DELETE" | "TRACE" | "OPTIONS" | "CONNECT" | "PATCH"

link-relations = element link-relations { documentation?, link-relation* }
link-relation = element link-relation { documentation?, id, status, link-relation-name, href? }
link-relation-name = attribute name { xsd:anyURI }

headers = element headers { header* }
header = element header { id?, name, header-type, documentation? }
header-type = attribute type { "request" | "response" | "general" | "entity" }

authentication = element authentication { mechanism*, identity-provider? }
mechanism = element mechanism { id?, name, authentication-type, documentation?, scheme* }
mechanism-ref = attribute mechanism-ref { xsd:IDREF }
identity-provider = element identity-provider { id, mechanism-ref }
authentication-type = attribute authentication-type { text }
scheme = element scheme { id?, name, documentation?, scheme-parameter* }
scheme-parameter = element parameter { id?, name, documentation? }

status-codes = element status-codes { documentation?, status-code* }
status-code = element status { code, id, documentation?, http-problem? }
status-code-ref = attribute ref { xsd:IDREF }
code = attribute code { HTTP-status-enum }
HTTP-status-enum =
    "100"
    | "101"
    | "102"
    | "200"
    | "201"
    | "203"
    | "204"
    | "205"
    | "206"
    | "207"
    | "208"
    | "301"
    | "302"
    | "303"
    | "304"
    | "305"
    | "306"
    | "307"
    | "308"
    | "400"
    | "401"
    | "402"
    | "403"
    | "404"
    | "405"
    | "406"
    | "407"
    | "408"
    | "409"
    | "410"
    | "411"
    | "412"
    | "413"
    | "414"
    | "415"
    | "416"
    | "417"
    | "418"
    | "420"
    | "422"
    | "423"
    | "424"
    | "425"
    | "426"
    | "428"
    | "429"
    | "431"
    | "444"
    | "449"
    | "450"
    | "451"
    | "494"
    | "495"
    | "496"
    | "497"
    | "499"
    | "500"
    | "501"
    | "502"
    | "503"
    | "504"
    | "505"
    | "506"
    | "507"
    | "508"
    | "509"
    | "510"
    | "511"
    | "598"
    | "599"

http-problem = element problem { problemType, title, detail, supportId, more }
problemType = element problemType { xsd:anyURI }
title = element title { text }
detail = element detail { text }
supportId = element supportId { xsd:anyURI }
more = element more { foreign-element* }
foreign-element = element * - rsdl:* { any-attribute*, (foreign-element* | text)* }
any-attribute = attribute * { text? }

uri-parameters = element uri-parameters { documentation?, uri-parameter* }
uri-parameter =
    element uri-parameter { id?, name, documentation, datatype, value-range?, default-value? }
uri-parameter-ref = attribute uri-parameter-ref { xsd:IDREF }

datatype =
    attribute datatype {
        "string"
        | "boolean"
        | "decimal"
        | "float"
        | "double"
        | "duration"
        | "dateTime"
        | "time"
        | "date"
        | "hexBinary"
        | "base64Binary"
        | "anyURI"
        | "integer"
        | "language"
        | "ID"
        | "IDREF"
        | "integer"
        | "long"
        | "short"
        | "byte"
    }

value-range = element value-range { text }
default-value = element default { text }

uri = attribute uri { xsd:anyURI }

# ref elements are used in the documentation modules
ref =
    element ref {
        ((attribute idref { xsd:IDREF }
          | attribute uri { xsd:anyURI }
          | attribute media-type { xsd:IDREF }
          | attribute header { xsd:IDREF }
          | attribute mechanism { xsd:IDREF }
          | attribute identity-provider { xsd:IDREF }
          | attribute scheme { xsd:IDREF }
          | attribute scheme-parameter { xsd:IDREF }
          | attribute status-code { xsd:IDREF }
          | attribute uri-parameter { xsd:IDREF }
          | attribute resources { xsd:IDREF }
          | attribute resource { xsd:IDREF }
          | attribute var { xsd:IDREF }
          | attribute property { xsd:IDREF }
          | attribute header { xsd:IDREF }
          | attribute method { xsd:IDREF }),
         text?)
        # Uses the name of the referred item if not provided
        
    }

    </textual></programlisting></appendix><appendix class="po-hcontainer e287 e287" xml:id="appx-html-subset"><title class="po-block e288 e288"><textual class="po-textual">HTML module for RSDL Documentation</textual></title><programlisting class="po-block e289 e289" xml:space="preserve"><textual class="po-textual">
namespace html = "http://www.w3.org/1999/xhtml/"

documentation = element documentation { inline?, doc-title?, html }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

html =  html-content*
html-content = (html-element | text | ref)
html-element = element html:* { html-attribute*, html-content* }
html-attribute = attribute * { text? }      
    </textual></programlisting></appendix><appendix class="po-hcontainer e290 e290" xml:id="appx-docbook-subset"><title class="po-block e291 e291"><textual class="po-textual">DocBook module for RSDL Documentation</textual></title><programlisting class="po-block e292 e292" xml:space="preserve"><textual class="po-textual">
namespace docbook = "http://docbook.org/ns/docbook"

documentation = element documentation { inline?, doc-title?, docbook }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

docbook =  docbook-content*
docbook-content = (docbook-element | text | ref)
docbook-element = element docbook:* { docbook-attribute*, docbook-content* }
docbook-attribute = attribute * { text? }
      
    </textual></programlisting></appendix><appendix class="po-hcontainer e293 e293" xml:id="appx-xslt-stylesheet"><title class="po-block e294 e294"><textual class="po-textual">An XSLT Stylesheet for RSDL</textual></title><para class="po-block e295 e295"><textual class="po-textual">The following stylesheet converts a RSDL description to an HTML page.</textual></para><programlisting class="po-block e296 e296" xml:space="preserve"><textual class="po-textual">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:html="http://www.w3.org/1999/xhtml/"
    xmlns:rsdl="http://identifiers.emc.com/rsdl"&gt;
  &lt;xsl:output method="html" encoding ="utf-8" indent="no"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;

  &lt;xsl:key name="status" match="//rsdl:status-codes/rsdl:status" use="@code" /&gt;
    
  &lt;xsl:template match="/rsdl:service"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:call-template name="title"/&gt;&lt;/title&gt;
        &lt;xsl:call-template name="style"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div class="outline index"&gt;
          &lt;xsl:call-template name="index"/&gt;
        &lt;/div&gt;
        &lt;div class="outline reference"&gt;
          &lt;xsl:call-template name="reference"/&gt;
        &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="title"&gt;
    &lt;xsl:value-of select="@name"/&gt; REST Service
  &lt;/xsl:template&gt;

  &lt;xsl:template name="style"&gt;
    &lt;style type="text/css"&gt;
      body { margin: 0; padding: 0 0 0 16em; }
      h1, h2 { color: Navy; }
      h3 { color: Blue; }
      table { border-collapse: collapse; margin-bottom: 1em; }
      th, td { border: 1px solid; padding: 0.35em; vertical-align: top; }
      th { color: White; background-color: CornflowerBlue; text-align: left; border-color: Black; }
      td { border-color: DarkBlue; }
      .outline { vertical-align: top; padding: 1em; }
      .index { position: fixed; top: 0; left: 0; width: 16em; height: 96%; overflow: auto; font-size: smaller; }
      .reference { height: 100%; overflow: auto; }
      div { overflow: scroll; }
      .homeResource { 
        font-weight: bold; 
        font-size: smaller; 
        background-color: Green; 
        color: Yellow; 
        padding: 0.3em;
        margin-left: 1em;
        border-radius: 1em; 
      }
      #hint { 
        display: none; 
        font-size: small; 
        font-weight: normal;
        white-space: nowrap; 
        background-color: LightYellow; 
        color: DimGrey;
        border: 1px solid DimGrey;
        border-radius: 0.5em;
        padding: 0.5em; 
        margin-right: 0.5em;
      }
      #full { color: Green; margin-right: 0.2em; }
      #full:hover ~ #hint { display: inline; }
      #no { color: Red; margin-right: 0.2em; }
      #no:hover ~ #hint { display: inline; }
      #partial { color: Coral; margin-right: 0.3em; }
      #partial:hover ~ #hint { display: inline; }
      .one-piece { white-space: nowrap; text-wrap: none; }
      .center { text-align: center; }
      .button { 
        background-color: LightGrey; 
        color: Black; 
        font-size: smaller;
        border: 1px solid DarkGrey; 
        border-radius: 0.35em; 
        padding: 0.35em;
        text-decoration: none;
      }
      .header-suffix { font-size: small; }
    &lt;/style&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index"&gt;
    &lt;xsl:call-template name="index-resources"/&gt;
    &lt;xsl:call-template name="index-media-types"/&gt;
    &lt;xsl:call-template name="index-link-relations"/&gt;
    &lt;xsl:call-template name="index-uri-parameters"/&gt;
    &lt;xsl:call-template name="index-custom-headers"/&gt;
    &lt;xsl:call-template name="index-status-codes"/&gt;
    &lt;xsl:call-template name="index-authentication-mechanisms"/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index-resources"&gt;
    &lt;h3&gt;Resources&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:resources/rsdl:resource"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;xsl:call-template name="home-resource"/&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="home-resource"&gt;
	  &lt;xsl:if test="@id = /rsdl:service/@home-resource"&gt;
	    &lt;span class="homeResource"&gt;Home resource&lt;/span&gt;
	  &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="index-media-types"&gt;
    &lt;h3&gt;Media Types&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:media-types/rsdl:media-type"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-link-relations"&gt;
    &lt;h3&gt;Link Relations&lt;/h3&gt;
    &lt;xsl:for-each select="//rsdl:link-relations/rsdl:link-relation"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;a class="item"&gt;
        &lt;xsl:attribute name="style"&gt;
          top: &lt;xsl:value-of select="4 + position()"/&gt;em;
        &lt;/xsl:attribute&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
         &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;br/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-authentication-mechanisms"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:uri-mechanism"&gt;
      &lt;h3&gt;Authentication Mechanisms&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:authentication/rsdl:mechanism"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-status-codes"&gt;
    &lt;xsl:if test="//rsdl:status-codes/rsdl:status"&gt;
      &lt;h3&gt;Status Codes&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:status-codes/rsdl:status"&gt;
        &lt;xsl:sort select="@code"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@code"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-custom-headers"&gt;
    &lt;xsl:if test="//rsdl:custom-headers/rsdl:custom-header"&gt;
      &lt;h3&gt;Headers&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:custom-headers/rsdl:custom-header"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template name="index-uri-parameters"&gt;
    &lt;xsl:if test="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
      &lt;h3&gt;URI Parameters&lt;/h3&gt;
      &lt;xsl:for-each select="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;a class="item"&gt;
          &lt;xsl:attribute name="style"&gt;
            top: &lt;xsl:value-of select="4 + position()"/&gt;em;
          &lt;/xsl:attribute&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
           &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/a&gt;
        &lt;br/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="reference"&gt;
    &lt;h1&gt;&lt;xsl:call-template name="title"/&gt;&lt;/h1&gt;
    &lt;xsl:call-template name="resources"/&gt;
    &lt;xsl:call-template name="media-types"/&gt;
    &lt;xsl:call-template name="link-relations"/&gt;
    &lt;xsl:call-template name="uri-parameters"/&gt;
    &lt;xsl:call-template name="custom-headers"/&gt;
    &lt;xsl:call-template name="status-codes"/&gt;
    &lt;xsl:call-template name="authentication-mechanisms"/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="resources"&gt;
    &lt;h2&gt;Resources&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:resource"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;hr/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;xsl:call-template name="implemented"/&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;xsl:call-template name="home-resource"/&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates select="rsdl:documentation"/&gt;
      &lt;xsl:call-template name="authentication"/&gt;
      &lt;xsl:apply-templates select="*[local-name() != 'methods' and local-name() != 'documentation']"/&gt;
      &lt;xsl:call-template name="methods"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="authentication"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="/service/@identity-provider-ref and @public = 'true'"&gt;
        &lt;xsl:call-template name="no-authentication"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@identity-provider-ref"&gt;
        &lt;xsl:call-template name="identity-provider"&gt;
          &lt;xsl:with-param name="id" select="@identity-provider-ref"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="/service/@identity-provider-ref"&gt;
        &lt;xsl:variable name="id" select="/service/@identity-provider-ref"/&gt;
        &lt;h4&gt;Authentication&lt;/h4&gt;
        &lt;p&gt;
          &lt;xsl:apply-templates select="//authentication/identity-provider[@id = $id]"/&gt;
        &lt;/p&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:call-template name="no-authentication"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="no-authentication"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:mechanism"&gt;
      &lt;h4&gt;Authentication&lt;/h4&gt;
      &lt;p&gt;This resource requires no authentication.&lt;/p&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="identity-provider"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:variable name="idp" select="//rsdl:authentication/rsdl:identity-provider[@id = $id]"/&gt;
    &lt;xsl:variable name="mechanismId" select="$idp/@mechanism-ref"/&gt;
    &lt;xsl:variable name="mechanism" select="//rsdl:authentication/rsdl:mechanism[@id = $mechanismId]"/&gt;
    &lt;h4&gt;Authentication&lt;/h4&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;Mechanism&lt;/th&gt;
        &lt;th&gt;Identity Provider&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$mechanismId"/&gt;&lt;/xsl:attribute&gt;
            &lt;xsl:apply-templates select="$mechanism/@name"/&gt;
          &lt;/a&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:apply-templates select="$idp/rsdl:documentation"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/xsl:template&gt;
   
  &lt;xsl:template name="implemented"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@status = 'full'"&gt;
        &lt;span id="full"&gt;&amp;#x2714;&lt;/span&gt;&lt;span id="hint"&gt;Fully implemented&lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@status = 'partial'"&gt;
        &lt;span id="partial"&gt;?&lt;/span&gt;&lt;span id="hint"&gt;Partially implemented&lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;span id="no"&gt;&amp;#x2718;&lt;/span&gt;&lt;span id="hint"&gt;Not implemented&lt;/span&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:documentation"&gt;
    &lt;xsl:apply-templates select="text()|*"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:authentication"&gt;
    &lt;xsl:variable name="mechanism" select="@mechanism-ref"/&gt;
    &lt;h4&gt;Authentication&lt;/h4&gt;
    &lt;p&gt;
      &lt;a&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$mechanism"/&gt;&lt;/xsl:attribute&gt;
        &lt;xsl:value-of select="//rsdl:authentication/rsdl:mechanism[@id = $mechanism]/@name"/&gt;
      &lt;/a&gt;.&amp;#160; &lt;xsl:apply-templates select="*"/&gt;
    &lt;/p&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{local-name()}"&gt;
      &lt;xsl:apply-templates select="*|@*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
      
  &lt;xsl:template match="text()"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:ref"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@resource and ancestor::rsdl:resource/@id = @resource"&gt;
        &lt;code&gt;
          &lt;xsl:value-of select="@resource"/&gt;
        &lt;/code&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
		    &lt;xsl:choose&gt;
		      &lt;xsl:when test="@resource"&gt;
            &lt;xsl:variable name="id" select="@resource"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:resources/rsdl:resource[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
		      &lt;/xsl:when&gt;
          &lt;xsl:when test="@status-code"&gt;
            &lt;xsl:variable name="id" select="@status-code"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:status-codes/rsdl:status[@id = $id]/@code"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@uri-parameter"&gt;
            &lt;xsl:variable name="id" select="@uri-parameter"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:uri-parameters/rsdl:uri-parameter[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@custom-header"&gt;
            &lt;xsl:variable name="id" select="@custom-header"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:custom-headers/rsdl:custom-header[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@mechanism"&gt;
            &lt;xsl:variable name="id" select="@mechanism"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:authentication/rsdl:mechanism[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@media-type"&gt;
            &lt;xsl:variable name="id" select="@media-type"/&gt;
            &lt;xsl:call-template name="ref-by-id"&gt;
              &lt;xsl:with-param name="id" select="$id"/&gt;
              &lt;xsl:with-param name="name" select="//rsdl:media-types/rsdl:media-type[@id = $id]/@name"/&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:when&gt;
		      &lt;xsl:otherwise&gt;
            &lt;a&gt;
  		        &lt;xsl:attribute name="href"&gt;
  		          &lt;xsl:value-of select="@uri"/&gt;
  		        &lt;/xsl:attribute&gt;
  		        &lt;xsl:apply-templates select="*|text()"/&gt;
            &lt;/a&gt;
		      &lt;/xsl:otherwise&gt;
		    &lt;/xsl:choose&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="ref-by-id"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="name"/&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="text()"&gt;
          &lt;xsl:apply-templates select="*|text()"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;code&gt;
            &lt;xsl:value-of select="$name"/&gt;
          &lt;/code&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/a&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="methods"&gt;
    &lt;xsl:if test="rsdl:methods/rsdl:method"&gt;
      &lt;xsl:variable name="showStatus" select="rsdl:methods/rsdl:method/@status"/&gt;
      &lt;h4&gt;Supported Methods&lt;/h4&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;xsl:if test="$showStatus"&gt;
            &lt;th&gt;Status&lt;/th&gt;
          &lt;/xsl:if&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;xsl:if test="rsdl:methods/rsdl:method/rsdl:request"&gt;
            &lt;th&gt;Request&lt;/th&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="rsdl:methods/rsdl:method/rsdl:response"&gt;
            &lt;th&gt;Response&lt;/th&gt;
          &lt;/xsl:if&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:methods//rsdl:method"&gt;
          &lt;tr&gt;
            &lt;xsl:if test="$showStatus"&gt;
              &lt;td class="center"&gt;
                &lt;xsl:call-template name="implemented"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
            &lt;td&gt;
              &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
            &lt;/td&gt;
            &lt;xsl:if test="../rsdl:method/rsdl:request"&gt;
              &lt;td&gt;
                &lt;xsl:apply-templates select="rsdl:request/*"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
            &lt;xsl:if test="../rsdl:method/rsdl:response"&gt;
              &lt;td&gt;
                &lt;xsl:apply-templates select="rsdl:response/*"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:status-codes"&gt;
    &lt;em&gt;Status code&lt;xsl:if test="count(rsdl:status-code) &amp;gt; 0"&gt;s&lt;/xsl:if&gt;:&lt;/em&gt;&amp;#160;
    &lt;xsl:for-each select="rsdl:status-code"&gt;
      &lt;xsl:variable name="statusId" select="@status-code-ref"/&gt;
      &lt;a&gt;
        &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$statusId"/&gt;&lt;/xsl:attribute&gt;
        &lt;code&gt;&lt;xsl:value-of select="//rsdl:status-codes/rsdl:status[@id = $statusId]/@code"/&gt;&lt;/code&gt;
      &lt;/a&gt;
      &lt;xsl:if test="position() &amp;lt; count(../rsdl:status-code)"&gt;, &amp;#160;&lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:header"&gt;
    &lt;xsl:variable name="id" select="@header-ref"/&gt;
    &lt;em&gt;Header:&lt;/em&gt;&amp;#160;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;code&gt;
        &lt;xsl:apply-templates select="//rsdl:custom-headers/rsdl:custom-header[@id = $id]/@name"/&gt;
      &lt;/code&gt; 
    &lt;/a&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:representation"&gt;
    &lt;xsl:variable name="id" select="@media-type-ref"/&gt;
    &lt;xsl:if test="../rsdl:documentation"&gt;
      &lt;br/&gt;
    &lt;/xsl:if&gt;
    &lt;em&gt;Media type:&lt;/em&gt;&amp;#160;&lt;code&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$id"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="//rsdl:media-types/rsdl:media-type[@id = $id]/@name"/&gt;
    &lt;/a&gt;
    &lt;/code&gt;
    &lt;xsl:if test="@entity"&gt;, entity: &lt;code&gt;&lt;xsl:value-of select="@entity"/&gt;&lt;/code&gt;&lt;/xsl:if&gt;
    &lt;xsl:if test="@entry"&gt;
      &lt;xsl:variable name="resId" select="@entry"/&gt;
      &lt;xsl:text&gt;, entry:&lt;/xsl:text&gt;&amp;#160; 
      &lt;code&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$resId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
          &lt;xsl:value-of select="//rsdl:resources/rsdl:resource[@id = $resId]/@name"/&gt;
        &lt;/a&gt;
      &lt;/code&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="rsdl:documentation"&gt;
      &lt;br/&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;
    &lt;/xsl:if&gt;
    &lt;br/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:links"&gt;
    &lt;xsl:if test="rsdl:link"&gt;
      &lt;h4&gt;Links to other resources&lt;/h4&gt;
      &lt;xsl:variable name="showStatus" select="rsdl:link/@status"/&gt;
	    &lt;table&gt;
	      &lt;tr&gt;
	        &lt;xsl:if test="$showStatus"&gt; 
            &lt;th&gt;Status&lt;/th&gt;
	        &lt;/xsl:if&gt;
	        &lt;th&gt;Relation&lt;/th&gt;
	        &lt;th&gt;Resource&lt;/th&gt;
          &lt;xsl:if test="rsdl:link/rsdl:documentation"&gt;
	          &lt;th&gt;Description&lt;/th&gt;
          &lt;/xsl:if&gt;
	      &lt;/tr&gt;
	      &lt;xsl:for-each select="rsdl:link"&gt;
	        &lt;xsl:sort select="@resource-ref"/&gt;
          &lt;xsl:variable name="resId" select="@resource-ref"/&gt;
          &lt;xsl:variable name="relId" select="@link-relation-ref"/&gt;
	        &lt;tr&gt;
            &lt;xsl:if test="$showStatus"&gt;
              &lt;td class="center"&gt;
                &lt;xsl:call-template name="implemented"/&gt;
              &lt;/td&gt;
            &lt;/xsl:if&gt;
	          &lt;td&gt;
	            &lt;code&gt;
                &lt;a&gt;
                  &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$relId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
                  &lt;xsl:value-of select="//rsdl:link-relations/rsdl:link-relation[@id = $relId]/@name"/&gt;
                &lt;/a&gt;
	            &lt;/code&gt;
	          &lt;/td&gt;
	          &lt;td&gt;
	            &lt;code&gt;
	              &lt;a&gt;
	                &lt;xsl:attribute name="href"&gt;#&lt;xsl:value-of select="$resId"&gt;&lt;/xsl:value-of&gt;&lt;/xsl:attribute&gt;
	                &lt;xsl:value-of select="//rsdl:resources/rsdl:resource[@id = $resId]/@name"/&gt;
	              &lt;/a&gt;
              &lt;/code&gt;
	          &lt;/td&gt;
            &lt;xsl:if test="../rsdl:link/rsdl:documentation"&gt;
  	          &lt;td&gt;
  	            &lt;xsl:apply-templates select="rsdl:documentation/*|rsdl:documentation/text()"/&gt;
  	          &lt;/td&gt;
            &lt;/xsl:if&gt;
	        &lt;/tr&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="rsdl:location"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="../@id = /rsdl:service/@home-resource"&gt;
        &lt;h4&gt;Location&lt;/h4&gt;
        &lt;p&gt;
          Reach this resource at &lt;code&gt;&lt;xsl:value-of select="@href"/&gt;&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@template and rsdl:var[@uri-parameter-ref]"&gt;
        &lt;h4&gt;URI Parameters&lt;/h4&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Description&lt;/th&gt;
          &lt;/tr&gt;
          &lt;xsl:for-each select="rsdl:var"&gt;
            &lt;xsl:sort select="@name"/&gt;
            &lt;xsl:variable name="id" select="@uri-parameter-ref"/&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
              &lt;td&gt;&lt;xsl:apply-templates select="//rsdl:uri-parameters/rsdl:uri-parameter[@id = $id]/rsdl:documentation"/&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="authentication-mechanisms"&gt;
    &lt;xsl:if test="//rsdl:authentication/rsdl:mechanism"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Authentication Mechanisms&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:authentication/rsdl:mechanism"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates select="rsdl:documentation"/&gt;
        &lt;xsl:for-each select="rsdl:scheme"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;xsl:apply-templates select="." /&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:scheme"&gt;
    &lt;h4&gt;Scheme: &lt;em&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/em&gt;&lt;/h4&gt;
    &lt;xsl:if test="rsdl:documentation"&gt;
      &lt;p&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/p&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="rsdl:parameter"&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;th&gt;Parameter&lt;/th&gt;
          &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:parameter"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
         
  &lt;xsl:template name="status-codes"&gt;
    &lt;xsl:if test="//rsdl:status-codes/rsdl:status"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Status Codes&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:status-codes/rsdl:status"&gt;
        &lt;xsl:sort select="@code"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@code"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="custom-headers"&gt;
    &lt;xsl:if test="//rsdl:custom-headers/rsdl:custom-header"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;Headers&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:custom-headers/rsdl:custom-header"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&amp;#160;&amp;#160;&lt;span class="header-suffix"&gt;(&lt;xsl:value-of select="@type"/&gt;)&lt;/span&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="media-types"&gt;
    &lt;hr/&gt;
    &lt;h2&gt;Media-types&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:media-types/rsdl:media-type"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="rsdl:description"&gt;
    &lt;br/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@type = 'html'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          More information
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'sedola'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          Service registration
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'xsd'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          XML Schema
        &lt;/a&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@type = 'rnc'"&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="href"&gt;
            &lt;xsl:value-of select="@href"/&gt;
          &lt;/xsl:attribute&gt;
          Relax NG Schema
        &lt;/a&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="link-relations"&gt;
    &lt;hr/&gt;
    &lt;h2&gt;Link Relations&lt;/h2&gt;
    &lt;xsl:for-each select="//rsdl:link-relations/rsdl:link-relation"&gt;
      &lt;xsl:sort select="@name"/&gt;
      &lt;h3&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
      &lt;/h3&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template name="uri-parameters"&gt;
    &lt;xsl:if test="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
      &lt;hr/&gt;
      &lt;h2&gt;URI Parameters&lt;/h2&gt;
      &lt;xsl:for-each select="//rsdl:uri-parameters/rsdl:uri-parameter"&gt;
        &lt;xsl:sort select="@name"/&gt;
        &lt;h3&gt;
          &lt;a&gt;
            &lt;xsl:attribute name="name"&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/xsl:attribute&gt;
          &lt;/a&gt;
          &lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;
        &lt;/h3&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="rsdl:properties"&gt;
    &lt;xsl:if test="rsdl:property"&gt;
      &lt;h4&gt;Properties&lt;/h4&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
        &lt;xsl:for-each select="rsdl:property"&gt;
          &lt;xsl:sort select="@name"/&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;code&gt;&lt;xsl:value-of select="@name"/&gt;&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;&lt;xsl:apply-templates select="rsdl:documentation"/&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/table&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;
    
&lt;/xsl:stylesheet&gt;      
    </textual></programlisting></appendix><appendix class="po-hcontainer e297 e297" xml:id="appx-planets.rsdl"><title class="po-block e298 e298"><textual class="po-textual">RSDL Description for the Planets Service</textual></title><para class="po-block e299 e299"><textual class="po-textual">The following example is taken from </textual><xref class="po-milestone e300 e300" linkend="RWS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, chapter 5.</textual></para><programlisting class="po-block e301 e301" xml:space="preserve"><textual class="po-textual">
&lt;?xml version="1.0" ?&gt;
&lt;service name="Maps" 
  xmlns:html="http://www.w3.org/1999/xhtml/" xmlns="http://identifiers.emc.com/rsdl"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://identifiers.emc.com/rsdl rsdl.xsd"
  &gt;
  
  &lt;documentation&gt;
    This is an example from the book RESTful Web Services, chapter 5.
  &lt;/documentation&gt;
  
  &lt;start ref="res-planets"/&gt;  

  &lt;media-types&gt;
    &lt;media-type id="med-xhtml" name="application/xhtml+xml"&gt;
      &lt;documentation&gt;
        We are defining an XHTML &lt;html:em&gt;microformat&lt;/html:em&gt; by adding meaning using the &lt;html:code&gt;class&lt;/html:code&gt;
        attribute to elements. For example, adding &lt;html:code&gt;class="planets"&lt;/html:code&gt; to the 
        &lt;html:code&gt;ul&lt;/html:code&gt; element, we can turn a list into a list of planets. 
      &lt;/documentation&gt;
      &lt;description type="html" href="http://tools.ietf.org/html/rfc3236" /&gt;
    &lt;/media-type&gt;
    &lt;media-type id="med-png" name="image/png"&gt;
      &lt;description type="html" href="http://www.iana.org/assignments/media-types/image/png" /&gt;
    &lt;/media-type&gt;
  &lt;/media-types&gt;
  
  &lt;resources&gt;
    &lt;resource id="res-planets" name="planets"&gt;
      &lt;location  uri="/"/&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-place" name="place"&gt;
      &lt;location template="/{planet}/[{scoping-information}/][{place-name}]{?show}"&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="scoping-information" uri-parameter-ref="par-scoping-information"/&gt;
        &lt;var name="place-name" uri-parameter-ref="par-place-name"/&gt;
        &lt;var name="show" uri-parameter-ref="par-show"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-map" resource-ref="res-map"/&gt;
        &lt;link link-relation-ref="rel-point" resource-ref="res-point"/&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-point" name="point"&gt;
      &lt;location template="/{planet}/{latitude},{longitude}"&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-place" resource-ref="res-place"/&gt;
        &lt;link link-relation-ref="rel-point" resource-ref="res-point"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-map" name="map"&gt;
      &lt;location template="/{map-type}{scale}/{planet}/{latitude},{longitude}"&gt;
        &lt;var name="map-type" uri-parameter-ref="par-map-type"/&gt;
        &lt;var name="scale" uri-parameter-ref="par-scale"/&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;links&gt;
        &lt;link link-relation-ref="rel-image" resource-ref="res-image"/&gt;
        &lt;link link-relation-ref="rel-map" resource-ref="res-map"/&gt;
      &lt;/links&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-xhtml" entity="html"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
    
    &lt;resource id="res-image" name="image"&gt;
      &lt;location template="/{map-type}{scale}/{planet}/images/{latitude},{longitude}.png"&gt;
        &lt;var name="map-type" uri-parameter-ref="par-map-type"/&gt;
        &lt;var name="scale" uri-parameter-ref="par-scale"/&gt;
        &lt;var name="planet" uri-parameter-ref="par-planet"/&gt;
        &lt;var name="latitude" uri-parameter-ref="par-latitude"/&gt;
        &lt;var name="longitude" uri-parameter-ref="par-longitude"/&gt;
      &lt;/location&gt;
      &lt;methods&gt;
        &lt;method name="GET"&gt;
          &lt;response&gt;
            &lt;representation media-type-ref="med-png"/&gt;
          &lt;/response&gt;
        &lt;/method&gt;
      &lt;/methods&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;

  &lt;link-relations&gt;
    &lt;link-relation id="rel-place" name="place"&gt;
      &lt;documentation&gt;
        The target resource is a related place. Links of this type are found by looking for &lt;html:code&gt;a&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="place"&lt;/html:code&gt;. Additionally, you can find search links to places via
        the &lt;html:code&gt;form&lt;/html:code&gt; element with &lt;html:code&gt;id="searchPlace"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-point" name="point"&gt;
      &lt;documentation&gt;
        The target resource is a related point on a planet. Links of this type are found by looking for 
        &lt;html:code&gt;a&lt;/html:code&gt; elements with different values for the &lt;html:code&gt;class&lt;/html:code&gt; attribute,
        like &lt;html:code&gt;coordinates&lt;/html:code&gt;, &lt;html:code&gt;map_nav&lt;/html:code&gt;, &lt;html:code&gt;zoom_in&lt;/html:code&gt;, 
        and &lt;html:code&gt;zoom_out&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-map" name="map"&gt;
      &lt;documentation&gt;
        The target resource is a map related to the current resource. Links of this type are found by looking for 
        &lt;html:code&gt;a&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="map"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
    &lt;link-relation id="rel-image" name="image"&gt;
      &lt;documentation&gt;
        The target resource is an image related to the current resource. Links of this type are found by looking for 
        &lt;html:code&gt;img&lt;/html:code&gt;
        elements with &lt;html:code&gt;class="map"&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/link-relation&gt;
  &lt;/link-relations&gt;
  
  &lt;uri-parameters&gt;
    &lt;uri-parameter id="par-planet" name="planet" datatype="string"&gt;
      &lt;documentation&gt;
        Human friendly name of a planet, like &lt;html:code&gt;Earth&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-place-name" name="place-name" datatype="string"&gt;
      &lt;documentation&gt;
        Human friendly name of a place, like &lt;html:code&gt;Mount%20Rushmore&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-scoping-information" name="scoping-information" datatype="string"&gt;
      &lt;documentation&gt;
        A hierarchy of &lt;ref uri-parameter="par-place-name"&gt;place names&lt;/ref&gt; like 
        &lt;html:code&gt;/USA/New%20England/Maine/&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-map-type" name="map-type" datatype="string"&gt;
      &lt;documentation&gt;
        The type of map, like &lt;html:code&gt;satellite&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-scale" name="scale" datatype="string"&gt;
      &lt;documentation&gt;
        Dot followed by an integer, like &lt;html:code&gt;.1&lt;/html:code&gt;. A bigger number indicates more details.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-show" name="show" datatype="string"&gt;
      &lt;documentation&gt;
        Things to search for near a given place, like &lt;html:code&gt;diners&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-latitude" name="latitude" datatype="float"&gt;
      &lt;documentation&gt;
        Latitude on a planet, like &lt;html:code&gt;24.9195&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
    &lt;uri-parameter id="par-longitude" name="longitude" datatype="float"&gt;
      &lt;documentation&gt;
        Longitude on a planet, like &lt;html:code&gt;17.821&lt;/html:code&gt;.
      &lt;/documentation&gt;
    &lt;/uri-parameter&gt;
  &lt;/uri-parameters&gt;  
&lt;/service&gt;      
    </textual></programlisting></appendix><bibliography class="po-hcontainer e302 e302"><title class="po-block e303 e303"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e304 e304" xml:id="WADL" xreflabel="WADL"><textual class="po-textual">Marc Hadley, Sun Microsystems. </textual><emphasis class="po-inline e305 e305" role="ital"><textual class="po-textual">Web Application Description Language</textual></emphasis><textual class="po-textual">, W3C Member Submission 31 August 2009.
        </textual><link class="po-inline e306 e306" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/Submission/wadl/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e307 e307" xml:id="rfc6570" xreflabel="URI Templates"><textual class="po-textual">Joe Gregorio, Google; Roy Fielding,
      Adobe; Marc Hadley, MITRE; Mark Nottingham, Rackspace; David Orchard, Salesforce.com.
        </textual><emphasis class="po-inline e308 e308" role="ital"><textual class="po-textual">URI Template</textual></emphasis><textual class="po-textual">, IETF RFC 6570, March 2012.
        </textual><link class="po-inline e309 e309" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc6570</textual></link></bibliomixed><bibliomixed class="po-block e310 e310" xml:id="json-home" xreflabel="JSON Home Documents"><textual class="po-textual">Mark Nottingham, Rackspace.
        </textual><emphasis class="po-inline e311 e311" role="ital"><textual class="po-textual">Home Documents for HTTP APIs</textual></emphasis><textual class="po-textual">, May 8, 2013.
        </textual><link class="po-inline e312 e312" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ietf.org/id/draft-nottingham-json-home-03.txt</textual></link></bibliomixed><bibliomixed class="po-block e313 e313" xml:id="xml-home" xreflabel="XML Home Documents"><textual class="po-textual">Erik Wilde, EMC. </textual><emphasis class="po-inline e314 e314" role="ital"><textual class="po-textual">Home Documents for HTTP Services: XML Syntax</textual></emphasis><textual class="po-textual">, June 11, 2013.
        </textual><link class="po-inline e315 e315" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ietf.org/id/draft-wilde-home-xml-01.txt</textual></link></bibliomixed><bibliomixed class="po-block e316 e316" xml:id="rfc6838" xreflabel="Media Type       Specifications and Registration Procedures"><textual class="po-textual">N. Freed, Oracle; J.
      Klensin; T. Hansen, AT&amp;T Laboratories. </textual><emphasis class="po-inline e317 e317" role="ital"><textual class="po-textual">Media Type Specifications and
        Registration Procedures</textual></emphasis><textual class="po-textual">, IETF RFC 6838, January 2013.
        </textual><link class="po-inline e318 e318" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc6838</textual></link></bibliomixed><bibliomixed class="po-block e319 e319" xml:id="Burke" xreflabel="To WADL or not to WADL"><textual class="po-textual">Bill Burke. </textual><emphasis class="po-inline e320 e320" role="ital"><textual class="po-textual">To WADL or not to WADL</textual></emphasis><textual class="po-textual">, blog post, May 21, 2009.
        </textual><link class="po-inline e321 e321" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://bill.burkecentral.com/2009/05/21/to-wadl-or-not-to-wadl/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e322 e322" xml:id="hypertext-driven" xreflabel="REST APIs must be hypertext-driven"><textual class="po-textual">Roy
      Fielding. </textual><emphasis class="po-inline e323 e323" role="ital"><textual class="po-textual">REST APIs must be hypertext-driven</textual></emphasis><textual class="po-textual">, blog post, Mon
      20 Oct 2008.
        </textual><link class="po-inline e324 e324" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e325 e325" xml:id="draft-nottingham-json-home-02" xreflabel="Home Documents for HTTP APIs"><textual class="po-textual">
      </textual><emphasis class="po-inline e326 e326" role="ital"><textual class="po-textual">Home Documents for HTTP APIs</textual></emphasis><textual class="po-textual">.
        </textual><link class="po-inline e327 e327" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/draft-nottingham-json-home-02</textual></link></bibliomixed><bibliomixed class="po-block e328 e328" xml:id="draft-nottingham-http-problem-04" xreflabel="Problem Details for HTTP APIs"><textual class="po-textual">
      </textual><emphasis class="po-inline e329 e329" role="ital"><textual class="po-textual">Problem Details for HTTP APIs</textual></emphasis><textual class="po-textual">.
        </textual><link class="po-inline e330 e330" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://datatracker.ietf.org/doc/draft-nottingham-http-problem/</textual></link></bibliomixed><bibliomixed class="po-block e331 e331" xml:id="rfc3023" xreflabel="XML Media Types"><textual class="po-textual">
      </textual><emphasis class="po-inline e332 e332" role="ital"><textual class="po-textual">XML Media Types</textual></emphasis><textual class="po-textual">, IETF RFC 3023, MURATA Makoto (FAMILY Given),
      Simon St.Laurent, Daniel Kohn. </textual><link class="po-inline e333 e333" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc3023</textual></link></bibliomixed><bibliomixed class="po-block e334 e334" xml:id="rfc4288" xreflabel="Media Type Specifications and Registration Procedures"><textual class="po-textual">
      </textual><emphasis class="po-inline e335 e335" role="ital"><textual class="po-textual">Media Type Specifications and Registration Procedures</textual></emphasis><textual class="po-textual">, IETF
      RFC 4288, Ned Freed, John C. Klensin.
      </textual><link class="po-inline e336 e336" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc4288</textual></link></bibliomixed><bibliomixed class="po-block e337 e337" xml:id="rfc5839" xreflabel="Additional Media Type Structured Syntax Suffixes"><textual class="po-textual">
      </textual><emphasis class="po-inline e338 e338" role="ital"><textual class="po-textual">Additional Media Type Structured Syntax Suffixes</textual></emphasis><textual class="po-textual">, IETF RFC
      5830, Tony Hansen, Alexey Melnikov.
      </textual><link class="po-inline e339 e339" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tools.ietf.org/html/rfc4288</textual></link></bibliomixed><bibliomixed class="po-block e340 e340" xml:id="Aristotle" xreflabel="Does REST need a service description language"><textual class="po-textual">
      Aristotle Pagaltzis. </textual><emphasis class="po-inline e341 e341" role="ital"><textual class="po-textual">Does REST need a service description
        language?</textual></emphasis><textual class="po-textual">, blog post, May 27, 2007.
      </textual><link class="po-inline e342 e342" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://plasmasturm.org/log/460/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e343 e343" xml:id="Corey" xreflabel="How RESTful is Your API?"><textual class="po-textual">Cory House. </textual><emphasis class="po-inline e344 e344" role="ital"><textual class="po-textual">How RESTful is your API?</textual></emphasis><textual class="po-textual">, blog post, August 26, 2012.
        </textual><link class="po-inline e345 e345" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.bitnative.com/2012/08/26/how-restful-is-your-api/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e346 e346" xml:id="Fowler" xreflabel="Richardson Maturity Model"><textual class="po-textual">Martin Fowler. </textual><emphasis class="po-inline e347 e347" role="ital"><textual class="po-textual">Richardson Maturity Model: steps toward the glory of REST</textual></emphasis><textual class="po-textual">, blog post,
      18 March 2010.
      </textual><link class="po-inline e348 e348" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://martinfowler.com/articles/richardsonMaturityModel.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e349 e349" xml:id="Dare" xreflabel="What's Wrong with WADL?"><textual class="po-textual">Dare Obasanjo. </textual><emphasis class="po-inline e350 e350" role="ital"><textual class="po-textual">What's Wrong with WADL?</textual></emphasis><textual class="po-textual">, blog post, June 4, 2007.
        </textual><link class="po-inline e351 e351" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.25hoursaday.com/weblog/2007/06/04/WhatsWrongWithWADL.aspx</textual></link></bibliomixed><bibliomixed class="po-block e352 e352" xml:id="RiP" xreflabel="REST in Practice"><textual class="po-textual">Jim Webber, Savas Parastatidis and Ian
      Robinson. </textual><emphasis class="po-inline e353 e353" role="ital"><textual class="po-textual">REST in Practice: Hypermedia and Systems
        Architecture</textual></emphasis><textual class="po-textual">. O'Reilly Media; 1 edition (September 24, 2010). ISBN-13:
      978-0596805821. </textual></bibliomixed><bibliomixed class="po-block e354 e354" xml:id="RWS" xreflabel="RESTful Web Services"><textual class="po-textual">Leonard Richardson, Sam Ruby
        </textual><emphasis class="po-inline e355 e355" role="ital"><textual class="po-textual">RESTful Web Services</textual></emphasis><textual class="po-textual">. O'Reilly Media; Dec 17, 2008f.
      ISBN-13: 978-0596554606.</textual></bibliomixed><bibliomixed class="po-block e356 e356" xml:id="sedola" xreflabel="Sedola"><textual class="po-textual">Erik Wilde. </textual><emphasis class="po-inline e357 e357" role="ital"><textual class="po-textual">Service
        Documentation Language</textual></emphasis><textual class="po-textual">. 
      </textual><link class="po-inline e358 e358" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://github.com/dret/sedola/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e359 e359" xml:id="Fielding2000" xreflabel="Architectural Styles and the Design of Network-based Software Architectures, PhD Dissertation Thesis."><textual class="po-textual">Roy Thomas Fielding, </textual><emphasis class="po-inline e360 e360" role="ital"><textual class="po-textual">Architectural Styles and the Design of
        Network-based Software Architectures, PhD Dissertation Thesis</textual></emphasis><textual class="po-textual">, University of
      California, Irvine © 2000.
        </textual><link class="po-inline e361 e361" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm.</textual></link></bibliomixed></bibliography></article></classedDocument>