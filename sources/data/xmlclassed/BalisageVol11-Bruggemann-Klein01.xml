<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Generating Schema-Aware XML Editors in XForms</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">International Symposium on Native XML User Interfaces</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 5, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">From XForms, it is possible to provide simple user interfaces for editing XML
                documents. From an XSD schema, it is possible to see which elements and attributes
                may occur in valid documents and in which combinations. The XFGen system brings
                these together. XFGen builds an XForm from an XSD schema. That XForm can load, edit,
                and save any XML instance conforming to the schema. XFGen guarantees that every user
                interaction with the editor will preserve the validity of the instance. XForms makes
                it easy to edit structurally fixed XML-encoded forms; XFGen’s editors go beyond this
                simple case to allow arbitrary structural changes to the document.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Mustapha</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Maalej</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Technische Universität München</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">maalej@in.tum.de</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Anne</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">Brüggemann-Klein</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e24 e24"><jobtitle class="po-field e25 e25"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></jobtitle><orgname class="po-block e26 e26"><textual class="po-textual">Technische Universität München</textual></orgname></affiliation><email class="po-field e27 e27"><textual class="po-textual">brueggem@in.tum.de</textual></email></author><legalnotice class="po-container e28 e28"><para class="po-block e29 e29"><textual class="po-textual">Copyright © 2013 by the authors. Used with permission.</textual></para></legalnotice><keywordset class="po-table e30 e30" role="author"><keyword class="po-field e31 e31"><textual class="po-textual">XML editor</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">XForms</textual></keyword><keyword class="po-field e33 e33"><textual class="po-textual">XML Schema</textual></keyword></keywordset></info><section class="po-hcontainer e34 e34"><title class="po-block e35 e35"><textual class="po-textual">Introduction</textual></title><para class="po-block e36 e36"><textual class="po-textual">In his PhD work [</textual><xref class="po-milestone e37 e37" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], the first author of this paper,
            under the second author's supervision, is designing and implementing a system called
            XFGen, that generates a schema-aware XML editor XFGen(s) for each XSD schema s. The
            key achievement of this work is that the editor XFGen(s) is an XForms document that is
            capable of creating or loading, editing and saving any XML instance that conforms to the
            schema s; each user interaction with XFGen(s) preserves validity of the XML
            instance against schema s. XFGen(s) is much more than a form editor. It goes beyond
            letting users fill out data fields for a structurally static XML document in that it
            enables editing of structure, too. Each editor XFGen(s) is indeed a fully functional
            schema-aware XML editor. Here are some crucial properties of the editors that XFGen
            generates:</textual></para><itemizedlist class="po-table e38 e38"><listitem class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">Strictly schema-aware (schema instances always in schema-conformant
                    state).</textual></para></listitem><listitem class="po-container e41 e41"><para class="po-block e42 e42"><textual class="po-textual">Implemented as an (extended) XForms document.</textual></para></listitem><listitem class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Supporting a large part of XML Schema.</textual></para></listitem><listitem class="po-container e45 e45"><para class="po-block e46 e46"><textual class="po-textual">Completely independent of XML instances, capable of loading or creating from
                    scratch, editing and saving any schema-conformant document.</textual></para></listitem></itemizedlist><para class="po-block e47 e47"><textual class="po-textual">The generator XFGen covers nearly the complete XML Schema specification. It handles,
            most importantly:</textual></para><itemizedlist class="po-table e48 e48"><listitem class="po-container e49 e49"><para class="po-block e50 e50"><textual class="po-textual">Elements declared as complex types</textual></para></listitem><listitem class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Elements declared with simple content</textual></para></listitem><listitem class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">Recursive type definitions</textual></para></listitem><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">Mixed-content declarations</textual></para></listitem><listitem class="po-container e57 e57"><para class="po-block e58 e58"><textual class="po-textual">Multiple potential top-level elements (elements declared globally)</textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Identity constraints</textual></para></listitem><listitem class="po-container e61 e61"><para class="po-block e62 e62"><textual class="po-textual">Attribute declarations</textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">Predefined simple types</textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">A wide range of facets in simple type restrictions</textual></para></listitem><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">Union of simple types</textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">Lists of simple type</textual></para></listitem></itemizedlist><para class="po-block e71 e71"><textual class="po-textual">Other parts of XML Schema are also supported, but did not require great effort, since
            their support mostly rests on standard schema validation. They are: inheritance,
            substitution groups, namespaces, inclusions, attribute and element groups. Furthermore,
            we wish to emphasize that element and attribute declarations as well as type definitions
            can all be local or global.</textual></para><para class="po-block e72 e72"><textual class="po-textual">The remainder of this paper is organized into five sections as follows: The next
            section is about architecture; it illustrates the interplay between components and
            briefly describes the architecture of the editors that XFGen generates. The main part of
            the paper is a tour of principles that we have used with XFGen; we cover editing of data
            values, editing of non-recursive structures and editing of mixed content. After that, we
            have sections about implementation and related work, before we conclude. For further
            illustration, we provide an appendix with editor screen shots for the purchase order
            example from the XML Schema Recommendation </textual><xref class="po-milestone e73 e73" linkend="XSPrimer"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e74 e74"><textual class="po-textual">The complete XForms generator XFGen is ready for demo at Balisage 2013. In this paper,
            we point out some of the challenges of XForms as an implementation technology for a
            schema-aware editor and demonstrate some of the principles and techniques that make such
            editors possible. A complete description can be found in Maalej's PhD thesis [</textual><xref class="po-milestone e75 e75" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e76 e76"><title class="po-block e77 e77"><textual class="po-textual">Architecture</textual></title><para class="po-block e78 e78"><textual class="po-textual">Components and their interactions are illustrated in </textual><xref class="po-milestone e79 e79" linkend="fig.CMinUML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e80 e80" xml:id="fig.CMinUML"><title class="po-block e81 e81"><textual class="po-textual">Components and their interaction</textual></title><mediaobject class="po-container e82 e82"><imageobject class="po-container e83 e83"><imagedata class="po-meta e84 e84" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-001.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e85 e85"><textual class="po-textual">The editors (XForms documents) that XFGen produces are complex pieces of software that
            conceptually follow the Model-View-Controller (MVC) architecture. They are realized as
            extended XForms.</textual></para><para class="po-block e86 e86"><textual class="po-textual">The data of each editor consist of the XML instance, that is to be edited and can be
            loaded, freshly created, replaced and saved on demand, and of some auxiliary state,
            comprising among others prototype structures that can be copied into the XML instance
            during editing under action control. The editor's data are contained in the data-model
            section of the form. The form's data model also holds declarative constraints for the
            editor's data, expressed as XForms bindings, and actions that will be triggered during
            the form's life, for example for editing. Conceptually, with respect to MVC, some of the
            latter are part of the controller.</textual></para><para class="po-block e87 e87"><textual class="po-textual">The view of each editor is defined by templates of XForms widgets, that are embedded
            into a host language, most commonly HTML, but we have also tested XUL. The view is
            generated by XFGen.</textual></para><para class="po-block e88 e88"><textual class="po-textual">The controller of each editor consists of XForms actions and custom scripts that XFGen
            inserts into XForms; they are executed by the XForms engine in the XForms client.</textual></para></section><section class="po-hcontainer e89 e89"><title class="po-block e90 e90"><textual class="po-textual">A tour of principles for XForms editors</textual></title><para class="po-block e91 e91"><textual class="po-textual">What are the principles that govern how the XFGen-generated XForms editors are built?
            In this section we illustrate them incrementally by example. We show the XForms code
            that is generated and how it is executed in a browser, for a series of XSD examples. And
            we explain systematically the underlying principles.</textual></para><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">Displaying structures, editing data values</textual></title><para class="po-block e94 e94"><textual class="po-textual">We first present simplified editors that allow editing of purely textual element
                content, but just display the document structure, not yet enabling structural
                editing. These editors could be used as classical form editors for a
                structurally-fixed XML-encoded form. At first, we restrict ourselves to elements.
                This is not a severe restriction; it will be easy to add attributes and editing
                support for them. Furthermore, we do not allow mixed content yet. Finally, we
                exclude recursive type definitions for now; this feature of XML Schema requires
                further techniques, that fall outside the scope of this section.</textual></para><para class="po-block e95 e95"><textual class="po-textual">The challenge of this section is to generate a static structure of XForms widgets
                that only depends on the input schema but that is able to bind to any XML instance,
                that conforms to the schema, and to display it. The key idea is to generate a
                liberal structure of XForms widgets that is capable of displaying a superset of the
                required XML instances. For example, if the schema uses a choice operator, we
                generate widgets for all alternatives. Each widget tries to bind to some element in
                the XML instance, but only some of them succeed, depending on the choice that the
                current instance realizes. We rely on the fact that "superfluous" widgets do not
                display when the referenced nodes in the current XML instance do not exist. We call
                this principle </textual><emphasis class="po-inline e96 e96" role="bold"><textual class="po-textual">Liberal Inputs</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e97 e97"><textual class="po-textual">Let us look at the schema liberalInputsS, see </textual><xref class="po-milestone e98 e98" linkend="fig.liberalInputsS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. It provides one root element, xyz, that can have one or two subsequences of one
                or two subelements a and one or two subelements b. Element a is typed as xsd:int and
                element b is typed as xsd:boolean. Now we are looking at the editor that we have
                generated, the XForms document liberalInputsF, see </textual><xref class="po-milestone e99 e99" linkend="fig.liberalInputsF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">: It has a repeating group of one widget refering
                to an element a and one widget refering to an element b, each of which enables
                editing of the element's text content. Finally, let us load the editor with the XML
                instance liberalInputsI in </textual><xref class="po-milestone e100 e100" linkend="fig.liberalInputsI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that conforms to the
                schema liberalInputsS. Then, the XForms element xforms:repeat iterates over all
                children of element xyz in the current XML instance, displaying the appropriate
                input widget for each element a or b that is met, as illustrated in </textual><xref class="po-milestone e101 e101" linkend="fig.liberalInputsB"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. This form could in principle display any
                sequence of elements a and b, even those that do not conform to the type of element
                xyz, depending on the XML instance. But we may assume that the XML instance is valid
                with respect to the schema when it is loaded; and the user interactions that we will
                later introduce, always preserve validity. Hence, it does not matter that the widget
                structure is more liberal than the schema.</textual></para><figure class="po-container e102 e102" xml:id="fig.liberalInputsS"><title class="po-block e103 e103"><textual class="po-textual">XML Schema liberalInputsS</textual></title><mediaobject class="po-container e104 e104"><imageobject class="po-container e105 e105"><imagedata class="po-meta e106 e106" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-002.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e107 e107" xml:id="fig.liberalInputsF"><title class="po-block e108 e108"><textual class="po-textual">XForms liberalInputsF</textual></title><mediaobject class="po-container e109 e109"><imageobject class="po-container e110 e110"><imagedata class="po-meta e111 e111" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-003.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e112 e112" xml:id="fig.liberalInputsI"><title class="po-block e113 e113"><textual class="po-textual">XML instance liberalInputsI</textual></title><mediaobject class="po-container e114 e114"><imageobject class="po-container e115 e115"><imagedata class="po-meta e116 e116" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-004.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e117 e117" xml:id="fig.liberalInputsB"><title class="po-block e118 e118"><textual class="po-textual">Editor screen shot liberalInputsB</textual></title><mediaobject class="po-container e119 e119"><imageobject class="po-container e120 e120"><imagedata class="po-meta e121 e121" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-005.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e122 e122"><textual class="po-textual">Some further points and easy generalizations:</textual></para><itemizedlist class="po-table e123 e123"><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">XForms processors provide some processor-specific type-aware editing
                        support and complete validation for data values that are typed with
                        pre-defined XML Schema simple types. Hence, the example editor
                        liberalInputsF in </textual><xref class="po-milestone e126 e126" linkend="fig.liberalInputsF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> supports XForms
                        processor-dependent type-aware editing and complete validation of the
                        contents of elements a and b out of the box, as seen in </textual><xref class="po-milestone e127 e127" linkend="fig.liberalInputsB"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Custom simple types, which are defined
                        using restriction, union or list, require special treatment that is
                        described in Maalej's PhD thesis [</textual><xref class="po-milestone e128 e128" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></listitem><listitem class="po-container e129 e129"><para class="po-block e130 e130"><textual class="po-textual">If a schema has several globally declared elements, each of them is
                        allowed as the top-most element of a schema-conformant XML instance.
                        Following the Liberal Inputs principle, we generate a set of widgets for
                        each of these elements, and only one of them will display for any given XML
                        instance that is loaded into the editor, because only one of them will
                        successfully bind to the unique top-level element of the current XML
                        instance. Consequently, we can load the editor with any schema-conformant
                        document, regardless of its root element, and we can also switch to a
                        different root element during an edit session without changing the
                        editor.</textual></para></listitem><listitem class="po-container e131 e131"><para class="po-block e132 e132"><textual class="po-textual">The same idea as in the previous item is used when a type definition
                        contains the choice operator.</textual></para></listitem><listitem class="po-container e133 e133"><para class="po-block e134 e134"><textual class="po-textual">What if the schema allows for deeper element hierarchies? We must ensure
                        that bindings from widget elements into the XML instance can be expressed in
                        XPath, without consideration for expressive features of XML Schema such as
                        context-dependent element declarations. We achieve that by having the
                        hierarchy of XForms widgets mirror the element hierarchy of the schema,
                        following the XForms pattern </textual><emphasis class="po-inline e135 e135" role="ital"><textual class="po-textual">Stepwise
                        XPath</textual></emphasis><textual class="po-textual"> [D2003]]. Then bindings into the XML instance are
                        always defined relatively to the parent level, by element name only. There
                        is a catch, though: If two top-level elements of a type definition have the
                        same name but different types, then we have to generate two different widget
                        structures for them and cannot bind them into the XML instance by the
                        (ambiguous) element name. Fortunately, XML Schema forbids this type of
                        ambiguity.</textual></para></listitem><listitem class="po-container e136 e136"><para class="po-block e137 e137"><textual class="po-textual">Why did we preclude recursion in type definitions for the simple schemas
                        that we can handle in this section? Recursion in a type definition would
                        lead to an infinite, non-halting generation of widget structures. To stop
                        recursion when generating XForms widget structures, widgets would have to
                        refer to and reuse previously defined structures, a feature not provided by
                        XForms. Our solution is to expand XForms with a new type of reference
                        control and support it with an extension to the XForms processor. This
                        principle, </textual><emphasis class="po-inline e138 e138" role="bold"><textual class="po-textual">Reference Control</textual></emphasis><textual class="po-textual">, is further
                        explained in Maalej's PhD thesis [</textual><xref class="po-milestone e139 e139" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></listitem><listitem class="po-container e140 e140"><para class="po-block e141 e141"><textual class="po-textual">It is easy to extend our approach so far to attributes, by adding a set of
                        input widgets to the group of each element declaration, one for each
                        potential attribute. Once more, the Liberal Inputs principle applies.</textual></para></listitem><listitem class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">Just for purposes of display, we could also handle mixed content in
                        element instances, by letting the xforms:repeat iterate not only over
                        sub-elements but also over text node children. We use a different technique,
                        though, for supporting insert and delete of text nodes, which we explain
                        later in this paper.</textual></para></listitem></itemizedlist><para class="po-block e144 e144"><textual class="po-textual">We can now algorithmically describe how to generate an XForms editor that allows
                editing of text content but only displays structure [</textual><xref class="po-milestone e145 e145" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e146 e146"><title class="po-block e147 e147"><textual class="po-textual">Editing structures: The downwards-facing perspective</textual></title><para class="po-block e148 e148"><textual class="po-textual">One novelty of this work is that our editors support editing not only of data
                values, as demonstrated in the previous section, but also of structures. XForms
                provides some basic support for insertion and deletion of nodes in an XML instance,
                with its actions </textual><code class="po-atom e149 e149"><textual class="po-textual">xforms:insert</textual></code><textual class="po-textual"> and </textual><code class="po-atom e150 e150"><textual class="po-textual">xforms:delete</textual></code><textual class="po-textual"> that can
                be triggered under user control. The challenge is to make sure that editors only
                allow for schema-conformant changes of XML instances.</textual></para><para class="po-block e151 e151"><textual class="po-textual">In this section, we take the downwards-facing perspective. We demonstrate our
                    </textual><emphasis class="po-inline e152 e152" role="bold"><textual class="po-textual">Prototype</textual></emphasis><textual class="po-textual"> principle, which guarantees that only
                such element structures are inserted into an XML instance that by themselves conform
                to their declared type. We'll address the upward-facing perspective, how deletions
                and insertions of children nodes can be forced to respect their parent's type, in
                the next section.</textual></para><para class="po-block e153 e153"><textual class="po-textual">If we wish to insert an element that conforms to some type into an XML instance,
                we'll insert a whole structure, with subelements and attributes as required by the
                type. We precompute in XFGen one minimal structure that conforms to the type and
                call it the element's prototype [</textual><xref class="po-milestone e154 e154" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e155 e155"><textual class="po-textual">The </textual><code class="po-atom e156 e156"><textual class="po-textual">xforms:insert</textual></code><textual class="po-textual"> action cannot create new structures; rather, it can
                only clone structures that are already present somewhere in the form's model.
                Therefore, XFGen builds an auxiliary instance that holds all prototype element
                structures and attributes of the schema, which can then be cloned and inserted into
                the form's XML instance under action control.</textual></para><para class="po-block e157 e157"><textual class="po-textual">Once a prototype has been inserted into the XML instance, the user can further
                edit it. Right now, XFGen computes some arbitrary prototype that conforms to the
                required type definition and cannot be further reduced by omitting attributes or
                subelements. The schema author can influence which prototype is generated by the
                order of choice operands in a type definition. Currently, XFGen always instantiates
                the first choice operand for a prototype.</textual></para><para class="po-block e158 e158"><textual class="po-textual">The auxilliary instance with the prototypes for Schema liberalInputsS in </textual><xref class="po-milestone e159 e159" linkend="fig.liberalInputsS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is in </textual><xref class="po-milestone e160 e160" linkend="fig.liberalInputsP"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e161 e161" xml:id="fig.liberalInputsP"><title class="po-block e162 e162"><textual class="po-textual">Auxilliary instance liberalInputsP</textual></title><mediaobject class="po-container e163 e163"><imageobject class="po-container e164 e164"><imagedata class="po-meta e165 e165" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-006.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></section><section class="po-hcontainer e166 e166"><title class="po-block e167 e167"><textual class="po-textual">Editing structures: The upward-facing perspective</textual></title><para class="po-block e168 e168"><textual class="po-textual">We now address the problem how to support insertion and deletion of children nodes
                such that the result necessarily conforms to the parent node's type.</textual></para><para class="po-block e169 e169"><textual class="po-textual">Let us consider schema editControlsS in </textual><xref class="po-milestone e170 e170" linkend="fig.editControlsS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, that
                allows top-level element xyz to have subelements a, b and c with the following
                additional constraints: The subelements of xyz either form a nonempty sequence of a,
                followed by a nonempty sequence of b, or consist just of a single c. In compact
                regular-expression notation, that is
                    (a</textual><superscript class="po-atom e171 e171"><textual class="po-textual">+</textual></superscript><textual class="po-textual">b</textual><superscript class="po-atom e172 e172"><textual class="po-textual">+</textual></superscript><textual class="po-textual">)|c.</textual></para><figure class="po-container e173 e173" xml:id="fig.editControlsS"><title class="po-block e174 e174"><textual class="po-textual">Schema editControlsS</textual></title><mediaobject class="po-container e175 e175"><imageobject class="po-container e176 e176"><imagedata class="po-meta e177 e177" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-007.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e178 e178"><textual class="po-textual">Our goal is to offer a finite number of primitive edit operations, so that any
                schema-conformant sequence u</textual><subscript class="po-atom e179 e179"><textual class="po-textual">1</textual></subscript><textual class="po-textual">...u</textual><subscript class="po-atom e180 e180"><textual class="po-textual">m</textual></subscript><textual class="po-textual"> of
                children of xyz can be transformed into any other schema-conformant sequence
                    v</textual><subscript class="po-atom e181 e181"><textual class="po-textual">1</textual></subscript><textual class="po-textual">...v</textual><subscript class="po-atom e182 e182"><textual class="po-textual">n</textual></subscript><textual class="po-textual"> by applying a finite
                number of the primitive edit operations, one after another, in such a way that each
                intermediate step leads also to a schema-conformant intermediate sequence.</textual></para><para class="po-block e183 e183"><textual class="po-textual">In our example, we generate the following set of primitive edit operations:</textual></para><itemizedlist class="po-table e184 e184"><listitem class="po-container e185 e185"><para class="po-block e186 e186"><textual class="po-textual">P1: insert a</textual></para></listitem><listitem class="po-container e187 e187"><para class="po-block e188 e188"><textual class="po-textual">P2: insert b</textual></para></listitem><listitem class="po-container e189 e189"><para class="po-block e190 e190"><textual class="po-textual">P3: delete a</textual></para></listitem><listitem class="po-container e191 e191"><para class="po-block e192 e192"><textual class="po-textual">P4: delete b</textual></para></listitem><listitem class="po-container e193 e193"><para class="po-block e194 e194"><textual class="po-textual">P5: delete ab, insert c</textual></para></listitem><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">P6: delete c, insert ab</textual></para></listitem><listitem class="po-container e197 e197"><para class="po-block e198 e198"><textual class="po-textual">P7: insert c</textual></para></listitem><listitem class="po-container e199 e199"><para class="po-block e200 e200"><textual class="po-textual">P8: delete c</textual></para></listitem><listitem class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">P9: insert ab</textual></para></listitem><listitem class="po-container e203 e203"><para class="po-block e204 e204"><textual class="po-textual">P10: delete ab</textual></para></listitem></itemizedlist><para class="po-block e205 e205"><textual class="po-textual">For simplicity's sake, we include "P7: insert c" in our supply of primitive edit
                operations, although it can never be used in a schema-conformant transformation. We
                can only insert a c if we also delete every a and b that might be present. And we
                can break down such a combined operation into a number of primitive edits, first
                deleting any single a and b except one, respectively, with P3 and P4, and then
                deleting the last remaining sequence ab and simultaneously inserting c with P5.
                Following the same argument, P8, P9 and P10 can also never be used in a
                schema-conformant transformation.</textual></para><para class="po-block e206 e206"><textual class="po-textual">We cannot do without primitive P5 simulating P5 by the sequence P3 P4 P7, since
                intermediate states would not be schema-conformant.</textual></para><para class="po-block e207 e207"><textual class="po-textual">Of course, unwise application of primitive edit operations can lead to
                non-schema-conformant states. If we apply P5 in the middle of sequence aab, between
                a and b, we erroneously get the invalid sequence ac.</textual></para><para class="po-block e208 e208"><textual class="po-textual">Our claim is the following: For any complex type definition, we can compute a
                finite number of primitive edit operations such that we can transform any conformant
                sequence into any other conformant sequence using the primitive edit operations and
                having only conformant intermediate states. We stress once more that this is an
                "existential" claim. We do not care at this point, that our primitive edit
                operations can also generate non-conformant sequences when applied at wrong
                positions. Maalej [</textual><xref class="po-milestone e209 e209" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] has the algorithm to generate a
                sufficiently large but finite set of primitive edit operations. Further research is
                needed to investigate if one can compute a minimal such set or if a minimal set
                would be unique.</textual></para><para class="po-block e210 e210"><textual class="po-textual">Following a principle that we call </textual><emphasis class="po-inline e211 e211" role="bold"><textual class="po-textual">Liberal Edits</textual></emphasis><textual class="po-textual">,
                we include any of the primitive edit operations as one button in the editor's user
                interface at any position in the sequence of children of xyz, see
                editControlsUI.xml.</textual></para><para class="po-block e212 e212"><textual class="po-textual">We can do this generically, without refering to a specific instance, by utilizing
                    </textual><code class="po-atom e213 e213"><textual class="po-textual">xforms:repeat</textual></code><textual class="po-textual">, as previously. Note that we insert one set of
                buttons outside the </textual><code class="po-atom e214 e214"><textual class="po-textual">xforms:repeat</textual></code><textual class="po-textual"> to handle the beginning of the
                sequence.</textual></para><para class="po-block e215 e215"><textual class="po-textual">Finally, we still need to control which of the edit buttons that we have so
                liberally included in our editor are actually active and which are passive (not
                shown), to preclude illegal edits that lead to non-conformant documents.</textual></para><para class="po-block e216 e216"><textual class="po-textual">In our example, we could do this with XPath bindings into the instance. We can,
                for example, express that P3 is only active if there is another a among the children
                of xyz, apart from the one that is to be deleted.</textual></para><para class="po-block e217 e217"><textual class="po-textual">However, an educated guess leads us to believe that, in the general case, the
                expressive power of XPath is too weak compared to the power of regular expressions
                in XML Schema complex types. Hence, we offer a different approach that we call
                    </textual><emphasis class="po-inline e218 e218" role="bold"><textual class="po-textual">Try and Tell</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e219 e219"><textual class="po-textual">We bind to each edit button a script that experimentally performs the primitive
                edit operation on a copy of the current instance, validates the result and makes the
                button visible only if the result is in fact valid. These scripts are triggered by
                XForms refresh events that are activated after each user interaction, ensuring
                up-to-date visibility status of each edit button. The scripts are implemented in a
                scripting language for which the XForms processor provides an interface, in our case
                in XBL (see also the section on implementation below.</textual></para><para class="po-block e220 e220"><textual class="po-textual">We illustrate the effect of Try and Tell for schema editControls in </textual><xref class="po-milestone e221 e221" linkend="fig.editControlsS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> with a browser screenshot in </textual><xref class="po-milestone e222 e222" linkend="fig.editControlsB"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e223 e223" xml:id="fig.editControlsB"><title class="po-block e224 e224"><textual class="po-textual">Editor screen shot editControlsB</textual></title><mediaobject class="po-container e225 e225"><imageobject class="po-container e226 e226"><imagedata class="po-meta e227 e227" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-008.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></section><section class="po-hcontainer e228 e228"><title class="po-block e229 e229"><textual class="po-textual">Editing mixed content</textual></title><para class="po-block e230 e230"><textual class="po-textual">In XML Schema, elements that are typed to have element content can orthogonally be
                declared to be of mixed content, allowing text-node children to be interspersed at
                any position in an element's instantiation, at the beginning, the end and between
                element nodes. This is in contrast to the more powerful Relax NG, where the
                appearance of text nodes can be constrained by regular-expression rules in the same
                way as subelements. The orthogonal approach of XML Schema opens up the opportunity
                to decouple handling of text nodes in mixed content from the handling of structured
                content, in a simpler and platform-independent way.</textual></para><para class="po-block e231 e231"><textual class="po-textual">In a first attempt, we apply our principle Liberal Inputs to elements that are
                declared to be of mixed content, iterating in the form's user interface not only
                over the elements' child elements but also the child text nodes, generating input
                widgets in the user interface for display and editing of these text nodes. This will
                display and make editable any text nodes that are present in the current document
                instance but does not handle positions in the document instance where text nodes are
                allowed but do currently not exist. For this case, we introduce a new principle,
                    </textual><emphasis class="po-inline e232 e232" role="bold"><textual class="po-textual">Automatic Text Insertion</textual></emphasis><textual class="po-textual">. When the document
                instance is loaded into the form, we automatically trigger a script (written in
                JavaScript) that inserts dummy empty text nodes at any position where a text node is
                allowed by the schema but none is present in the instance. Then, input widgets
                appear at any position in the user interface, where text nodes are allowed by the
                schema, displaying an empty input field for the dummy text nodes and the original
                text for text nodes that were already present in the document instance. These text
                nodes can be edited via the input widgets; they can also be "deleted" by resetting
                their content to the empty string.</textual></para><para class="po-block e233 e233"><textual class="po-textual">Unfortunately, there is a glitch with this approch: The iteration in the form's
                user interface will also produce the set of buttons for primitive edit operations
                that would consequently also have to be managed. There is, however, a slightly
                different way to deal with text nodes without considering buttons for primitive edit
                operations: We couple the widgets for text nodes to the groups for element nodes
                within an </textual><code class="po-atom e234 e234"><textual class="po-textual">xforms:repeat</textual></code><textual class="po-textual"> and insert a further widget for a text node
                outside the </textual><code class="po-atom e235 e235"><textual class="po-textual">xforms:repeat</textual></code><textual class="po-textual">, to handle the text node that appears before
                the first element. We call this principle </textual><emphasis class="po-inline e236 e236" role="bold"><textual class="po-textual">Coupled
                    Inputs</textual></emphasis><textual class="po-textual"> and demonstrate its application with schema coupledInputsS in
                    </textual><xref class="po-milestone e237 e237" linkend="fig.coupledInputsS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, XForms coupledInputsF in </textual><xref class="po-milestone e238 e238" linkend="fig.coupledInputsF"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and browser screen shot coupledInputsB in </textual><xref class="po-milestone e239 e239" linkend="fig.coupledInputsB"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e240 e240" xml:id="fig.coupledInputsS"><title class="po-block e241 e241"><textual class="po-textual">Schema coupledInputsS</textual></title><mediaobject class="po-container e242 e242"><imageobject class="po-container e243 e243"><imagedata class="po-meta e244 e244" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-009.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e245 e245" xml:id="fig.coupledInputsF"><title class="po-block e246 e246"><textual class="po-textual">XForms coupledInputsF</textual></title><mediaobject class="po-container e247 e247"><imageobject class="po-container e248 e248"><imagedata class="po-meta e249 e249" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-010.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e250 e250" xml:id="fig.coupledInputsB"><title class="po-block e251 e251"><textual class="po-textual">Editor screen shot CoupledInputsB</textual></title><mediaobject class="po-container e252 e252"><imageobject class="po-container e253 e253"><imagedata class="po-meta e254 e254" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-011.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e255 e255"><textual class="po-textual">The last point to consider is how structural edit operations deal with text nodes.
                Here we modify the edit operation in such a way that empty text nodes are inserted
                as needed and that the contents of text nodes that are deleted together with a
                sequence of neighboring element nodes are copied into the remaining text node in
                front of them.</textual></para><para class="po-block e256 e256"><textual class="po-textual">This solution for mixed content is essentially platform independent. It uses a
                custom JavaScript script that is triggered by a built-in XForms event and accesses
                the document instance through the standard DOM interface. Furthermore, it utilizes
                the capability of XForms to associate the script with the event. It is worth
                mentioning, though, that XForms makes it really hard to insert text nodes in the
                middle of a sequence of nodes, demanding to sequentially build up of the sequence
                from front to back.</textual></para></section></section><section class="po-hcontainer e257 e257"><title class="po-block e258 e258"><textual class="po-textual">Implementation</textual></title><para class="po-block e259 e259"><textual class="po-textual">The system XFGen itself is a standard Java program. it uses Xerces to process XML
            Schema. The XForms documents that XFGen generates require extensions for some XSD
            features (recursive type definitions) or editing tasks (experimental evaluation to
            determine admissible edit operations dynamically). These extensions utilize XBL scripts
            that interact with certain data structures and methods of the XForms
                processor [</textual><xref class="po-milestone e260 e260" linkend="XBL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]</textual></para><para class="po-block e261 e261"><textual class="po-textual">XBL is a scripting language that was introduced by Mozilla and submitted to W3C, but
            has not been standardized by W3C. Some XForms processors, among them Orbeon Forms, offer
            interfaces for XBL scripts that can access internal data structures and functions of the
            XForms processor. These interfaces are not standardized. We have extended the Firefox
            plugin XForms processor, which incidentally is programmed in XBL itself, with XBL
            functions. Consequently, the more complex XForms documents that XFGen produces run only
            on this custom extension of the XForms Firefox plugin on old versions of Firefox. We
            refer to Dubinko's text on extending XForms [D2003].]</textual></para><para class="po-block e262 e262"><textual class="po-textual">Some XSD features can be more fully supported with an XForms processor that allows for
            XPath 2.0. Unfortunately, the Firefox plugin XForms processor that we use only
            supports XPath 1.0, as required by XForms. Consequently, support for some XSD
            features such as identity constraints is more cumbersome to define or even more limited
            in practice than conceptually necessary.</textual></para></section><section class="po-hcontainer e263 e263"><title class="po-block e264 e264"><textual class="po-textual">Related work</textual></title><para class="po-block e265 e265"><textual class="po-textual">We briefly discuss three papers that are related to our work [</textual><xref class="po-milestone e266 e266" linkend="RadhaICDCIT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">][</textual><xref class="po-milestone e267 e267" linkend="SongICWS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">][</textual><xref class="po-milestone e268 e268" linkend="DeWolfIADIS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e269 e269"><textual class="po-textual">Despite its title and stated intent, the paper by Radha [</textual><xref class="po-milestone e270 e270" linkend="RadhaICDCIT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and others does not really contribute anything specific to
            user interfaces. It is mainly concerned with semantic interpretation of XML Schema,
            given a generic DOM representation that sees the schema just as any XML document. A Java
            Swing user interface is presented without discussion how it was generated.</textual></para><para class="po-block e271 e271"><textual class="po-textual">Song and Lee [</textual><xref class="po-milestone e272 e272" linkend="SongICWS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] specifically address the XForms target
            platform. Their goal is to support user interfaces for Web Services. They also briefly
            address the task of semantic interpretation of XML Schema. As to schemas, we don't see
            that they support recursive type definitions. The editors that are generated can only
            generate new XML documents from scratch, not load existing documents. Editing of
            structures and of mixed content is supported, but only in a "one-way" approach; that is,
            edit decisions, for example for one alternative when a choice is given, cannot be
            revised. There is some support for custom simple data types, for some facets in
            restrictions and for union. The paper mentions lists but means presumably the
            enumeration facet, since only a finite number of items in the base type can be supported
            with </textual><code class="po-atom e273 e273"><textual class="po-textual">xforms:select1</textual></code><textual class="po-textual">.</textual></para><para class="po-block e274 e274"><textual class="po-textual">De Wolf and others [</textual><xref class="po-milestone e275 e275" linkend="DeWolfIADIS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] discuss problems that need to
            be solved when XForms is used as an implementation platform for an XML editor. They seek
            solutions mostly in extensions to the XForms standard. Some but not all of their
            proposed extensions have in fact found their way into the XForms 1.1
            specification.</textual></para><para class="po-block e276 e276"><textual class="po-textual">Our system XFGen supports a far greater range of XML Schema features than comparable
            systems. We delegate the semantic interpretation of XML Schema to Xerces. We have
            explicitly delineated some principles and algorithms of XFGen; further capabilities of
            XFGen are covered by Maalej in his PhD work [</textual><xref class="po-milestone e277 e277" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e278 e278"><title class="po-block e279 e279"><textual class="po-textual">Discussion, conclusions and further work</textual></title><para class="po-block e280 e280"><textual class="po-textual">Maalej in his PhD thesis [</textual><xref class="po-milestone e281 e281" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] covers further features of
            XML Schema:</textual></para><itemizedlist class="po-table e282 e282"><listitem class="po-container e283 e283"><para class="po-block e284 e284"><textual class="po-textual">Recursion in type definitions.</textual></para></listitem><listitem class="po-container e285 e285"><para class="po-block e286 e286"><textual class="po-textual">Custom simple types (restriction, list, union).</textual></para></listitem><listitem class="po-container e287 e287"><para class="po-block e288 e288"><textual class="po-textual">Identity constraints.</textual></para></listitem></itemizedlist><para class="po-block e289 e289"><textual class="po-textual">In principle, the XML editors that are generated by XFGen could be platform
            independent, but currently, they are not. We would need an alternative XForms processor
            that allows the necessary extensions and also runs in current browser. One candidate
            would be xf.js [</textual><xref class="po-milestone e290 e290" linkend="xf.js"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] in a more fully functional version, where
            we could use JavaScript to support the extensions.</textual></para><para class="po-block e291 e291"><textual class="po-textual">In this paper, we have not discussed the user-interface aspects of the editors that
            XFGen generates. We follow a template approach as indicated in </textual><xref class="po-milestone e292 e292" linkend="fig.CMinUML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. For the examples in this paper, we have defined basic
            templates with the HTML fieldset element. Obviously, more sophisticated custom templates
            that combine HTML with CSS need to be tried out.</textual></para><para class="po-block e293 e293"><textual class="po-textual">Although XFGen handles mixed content, the generated editors presumably work better for
            data-driven XML instances than for text-driven ones. Particularly with text-driven XML
            documents, we run into the largely unsolved usability problems of general XML editors.
            Our generated editors work probably best in cases in which a classical form-based
            interface is appropriate. Investigate further.</textual></para><para class="po-block e294 e294"><textual class="po-textual">Further documentation of this work will appear in Maalej's PhD thesis [</textual><xref class="po-milestone e295 e295" linkend="MMThesis"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e296 e296"><title class="po-block e297 e297"><textual class="po-textual">Acknowledgement</textual></title><para class="po-block e298 e298"><textual class="po-textual">The comments of the anonymous referees have been extraordinarily helpful. Thank
            you!</textual></para></section><appendix class="po-hcontainer e299 e299"><title class="po-block e300 e300"><textual class="po-textual">The purchase order example</textual></title><para class="po-block e301 e301"><textual class="po-textual">For further illustration, we include the purchase order example from the XML Schema
                Recommendation </textual><xref class="po-milestone e302 e302" linkend="XSPrimer"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> with the schema in </textual><xref class="po-milestone e303 e303" linkend="fig.purchaseOrderS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, an instance in </textual><xref class="po-milestone e304 e304" linkend="fig.purchaseOrderI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
            and two browser screen shots in </textual><xref class="po-milestone e305 e305" linkend="fig.purchaseOrderB"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e306 e306" xml:id="fig.purchaseOrderS"><title class="po-block e307 e307"><textual class="po-textual">Schema purchaseOrderS</textual></title><mediaobject class="po-container e308 e308"><imageobject class="po-container e309 e309"><imagedata class="po-meta e310 e310" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-012.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e311 e311" xml:id="fig.purchaseOrderI"><title class="po-block e312 e312"><textual class="po-textual">XML instance purchaseOrderI</textual></title><mediaobject class="po-container e313 e313"><imageobject class="po-container e314 e314"><imagedata class="po-meta e315 e315" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-013.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><figure class="po-container e316 e316" xml:id="fig.purchaseOrderB"><title class="po-block e317 e317"><textual class="po-textual">Editor screen shots purchaseOrderB</textual></title><mediaobject class="po-container e318 e318"><imageobject class="po-container e319 e319"><imagedata class="po-meta e320 e320" fileref="../../../vol11/graphics/Bruggemann-Klein01/Bruggemann-Klein01-014.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></appendix><bibliography class="po-hcontainer e321 e321"><title class="po-block e322 e322"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e323 e323" xml:id="RecXForms1.1" xreflabel="Boy09"><textual class="po-textual">John M. Boyer, </textual><emphasis class="po-inline e324 e324"><textual class="po-textual">XForms
                1.1</textual></emphasis><textual class="po-textual">, W3C Recommendation, W3C, October 2009,
                </textual><link class="po-inline e325 e325" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2009/REC-xforms-20091020/.</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e326 e326" xml:id="XSDatatypes" xreflabel="BPM04"><textual class="po-textual">Paul V. Biron, Kaiser Permanente, and
            Ashok Malhotra, </textual><emphasis class="po-inline e327 e327"><textual class="po-textual">XML Schema Part 2: Datatypes Second Edition</textual></emphasis><textual class="po-textual">, W3C
            Recommendation, W3C, October 2004,
                </textual><link class="po-inline e328 e328" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/.</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e329 e329" xml:id="XFormsEssentials" xreflabel="Dub03"><textual class="po-textual">Micah Dubinko, </textual><emphasis class="po-inline e330 e330"><textual class="po-textual">XForms
                Essentials</textual></emphasis><textual class="po-textual">, O’Reilly &amp; Associates, Inc., Sebastopol, CA, USA, 2003. </textual></bibliomixed><bibliomixed class="po-block e331 e331" xml:id="XBL" xreflabel="Hic12"><textual class="po-textual">Ian Hickson, </textual><emphasis class="po-inline e332 e332"><textual class="po-textual">XBL 2.0</textual></emphasis><textual class="po-textual">, W3C
            Candidate Recommendation, W3C, Mai 2012, </textual><link class="po-inline e333 e333" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xbl/.</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e334 e334" xml:id="MMThesis" xreflabel="Maa13"><textual class="po-textual">Mustapha Maalej, </textual><emphasis class="po-inline e335 e335"><textual class="po-textual">Generieren von
                XML-Editoren in XForms aus XML Schema</textual></emphasis><textual class="po-textual">, Ph.D. Thesis, TU München, 2013, In
            preparation. </textual></bibliomixed><bibliomixed class="po-block e336 e336" xml:id="xf.js" xreflabel="NBK13"><textual class="po-textual">Tobias Niedl and Anne Brüggemann-Klein,
                </textual><emphasis class="po-inline e337 e337"><textual class="po-textual">Processing XForms in HTML5-Enabled Browsers</textual></emphasis><textual class="po-textual">, Balisage 2013,
            2013. doi:</textual><biblioid class="po-atom e338 doi e338"><textual class="po-textual">10.4242/BalisageVol10.Niedl01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e339 e339" xml:id="RadhaICDCIT" xreflabel="RRK05"><textual class="po-textual">V. Radha, S. Ramakrishna, and N. Pradeep
            Kumar, </textual><emphasis class="po-inline e340 e340"><textual class="po-textual">Generic XML Schema Definition (XSD) to GUI Translator.</textual></emphasis><textual class="po-textual">,
            ICDCIT, Lecture Notes in Computer Science, vol. 3816, Springer, 2005, pp. 290–296. </textual></bibliomixed><bibliomixed class="po-block e341 e341" xml:id="SongICWS" xreflabel="SL07"><textual class="po-textual">Kisub Song and Kyong-Ho Lee, </textual><emphasis class="po-inline e342 e342"><textual class="po-textual">An
                Automated Generation of XForms Interfaces for Web Services</textual></emphasis><textual class="po-textual">, 2012 IEEE
            19th International Conference on Web Services (2007), 856–863. </textual></bibliomixed><bibliomixed class="po-block e343 e343" xml:id="XSStructures" xreflabel="TBMM04"><textual class="po-textual">Henry S. Thompson, David Beech, Murray
            Maloney, and Noah Mendelsohn, </textual><emphasis class="po-inline e344 e344"><textual class="po-textual">XML Schema Part 1: Structures Second
                Edition</textual></emphasis><textual class="po-textual">, W3C Recommendation, W3C, October 2004,
                </textual><link class="po-inline e345 e345" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/.</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e346 e346" xml:id="XSPrimer" xreflabel="WF04"><textual class="po-textual">Priscilla Walmsley and David C. Fallside,
                </textual><emphasis class="po-inline e347 e347"><textual class="po-textual">XML Schema Part 0: Primer Second Edition</textual></emphasis><textual class="po-textual">, W3C Recommendation,
            W3C, October 2004,
                </textual><link class="po-inline e348 e348" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/.</textual></link><textual class="po-textual">
        </textual></bibliomixed><bibliomixed class="po-block e349 e349" xml:id="DeWolfIADIS" xreflabel="WKdW04"><textual class="po-textual">Koen De Wolf, Frederik De Keukelaere,
            and Rik Van de Walle, </textual><emphasis class="po-inline e350 e350"><textual class="po-textual">Generic XForms-Based User Interface Generation for XML
                Schema</textual></emphasis><textual class="po-textual">, Proceedings of the IADIS International Conference e-Society 2004,
            7 2004, pp. 773–782. </textual></bibliomixed></bibliography></article></classedDocument>