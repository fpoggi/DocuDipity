<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="Bal2008Baum1020"><title class="po-block e1 e1"><textual class="po-textual">Freedom to Constrain</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">where does attribute constraint come from, mommy?</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2008</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 12 - 15, 2008</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">Where should attribute constraints live? In an external schema? In the document’s own
        metadata? In a separate file? Several possibilities are examined, raising lots of questions
        and offering a few answers.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Syd</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Bauman</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Syd Bauman is the technical person at the Brown University Women Writers Project,
          where he has worked since 1990, designing and maintaining a significantly extended
          TEI-conformant schema for encoding early printed books. He has served as the North
          American Editor of the Text Encoding Initiative Guidelines, has an AB from Brown
          University in political science, and has worked as an Emergency Medical Technician since
          1983.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior Programmer/Analyst</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Brown University Women Writers Project</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">Syd_Bauman@Brown.edu</textual></email><link class="po-inline e19 e19" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.stg.brown.edu/staff/syd.html</textual></link></author><legalnotice class="po-container e20 e20"><para class="po-block e21 e21"><textual class="po-textual">Copyright © 2008 Syd Bauman. Some rights reserved.</textual></para></legalnotice><keywordset class="po-table e22 e22" role="author"><keyword class="po-field e23 e23"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">attribute</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">TEI</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">ODD</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">constraint</textual></keyword></keywordset></info><para class="po-block e28 e28"><textual class="po-textual">It is clear that constraining document structure is a very
  important part of document production. We test whether or not our
  XML documents are properly constrained through the process of
  validation. </textual><quote class="po-inline e29 e29"><textual class="po-textual">The … purpose of validation is to subject a
  document … to a test, to determine whether it conforms to a given
  set of external criteria. … Our need to test is simply explained and
  understood (so much so that it rarely needs to be explicated): if
  there exists a point in a process where it is less expensive to
  discover and correct problems than it is to save the work of testing
  and fix at later points, it is profitable to introduce a
  test.</textual></quote><footnote class="po-popup e30 e30"><para class="po-block e31 e31"><textual class="po-textual">Piez, Wendell, “Beyond the ‘descriptive
  vs. procedural’ distinction”, presented at Extreme Markup Languages
  2001, Montréal, Canada. </textual><link class="po-inline e32 e32" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/extreme/proceedings/html/2001/Piez01/EML2001Piez01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.idealliance.org/papers/extreme/proceedings/html/2001/Piez01/EML2001Piez01.html</textual></link><textual class="po-textual">.
  </textual></para></footnote><textual class="po-textual">
  </textual></para><para class="po-block e33 e33"><textual class="po-textual">Michael Sperberg-McQueen may have summed this importance up
  best when he advised </textual><quote class="po-inline e34 e34"><textual class="po-textual">constrain your data early and
  often</textual></quote><textual class="po-textual">, which he often did.</textual><footnote class="po-popup e35 e35"><para class="po-block e36 e36"><textual class="po-textual">Sperberg-McQueen,
  C. Michael. Oral conversation, and multiple oral presentations
  throughout the 1990s. See, e.g., </textual><link class="po-inline e37 e37" xlink:actuate="onRequest" xlink:href="http://www.w3.org/People/cmsmcq/2001/darmstadt.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/People/cmsmcq/2001/darmstadt.html</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">
  (It helped that he lived in Chicago at the time.)</textual></para><para class="po-block e38 e38"><textual class="po-textual">So it is obvious that constraints need to be expressed in a
  formal language of some sort. Many such general-purpose formal
  languages are available, including closed schema languages like DTDs
  and RELAX NG, and open schema languages like Schematron and CLiX.
  Furthermore at least one literate encoding language exists in which
  such constraints along with documentation about them can be
  expressed. This language is called ODD (for “one document does it
  all”) — constraints expressed in other languages (DTDs, RELAX NG, or
  XML Schema; in theory others as well) can be derived from a set of
  constraints expressed in ODD.</textual><footnote class="po-popup e39 e39"><para class="po-block e40 e40"><textual class="po-textual">Burnard, Lou and Syd Bauman, eds. “4.3.2 Floating Texts.”
  </textual><emphasis class="po-inline e41 e41"><textual class="po-textual">TEI P5: Guidelines for Electronic Text Encoding and
  Interchange</textual></emphasis><textual class="po-textual">. Version 1.1.0. 2008-07-04. TEI Consortium.
  </textual><link class="po-inline e42 e42" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/html/DS.html#DSFLT " xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/html/DS.html#DSFLT
</textual></link><textual class="po-textual">  2008-08-30</textual></para></footnote><footnote class="po-popup e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Burnard, Lou and Syd Bauman, eds. “23.4 Implementation of an ODD System.”
  </textual><emphasis class="po-inline e45 e45"><textual class="po-textual">TEI P5: Guidelines for Electronic Text Encoding and
  Interchange</textual></emphasis><textual class="po-textual">. Version 1.1.0. 2008-07-04. TEI Consortium.
  </textual><link class="po-inline e46 e46" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html#IM " xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html#IM
</textual></link><textual class="po-textual">  2008-08-30</textual></para></footnote><footnote class="po-popup e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Sperberg-McQueen, C. Michael and Lou Burnard. “The Design of
  the TEI Encoding Scheme.” </textual><emphasis class="po-inline e49 e49"><textual class="po-textual">Computers and the
  Humanities</textual></emphasis><textual class="po-textual"> 1995. 29 (1) p. 17–39. doi:10.1007/BF01830314</textual></para></footnote><footnote class="po-popup e50 e50"><para class="po-block e51 e51"><textual class="po-textual">Burnard, Lou, Sebastian Rahtz. “RelaxNG
  with Son of ODD”, presented at Extreme Markup Languages 2004,
  Montréal, Canada. </textual><link class="po-inline e52 e52" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/Extreme/Proceedings/html/2004/Burnard01/EML2004Burnard01.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mulberrytech.com/Extreme/Proceedings/html/2004/Burnard01/EML2004Burnard01.pdf</textual></link><textual class="po-textual">.
  </textual></para></footnote><textual class="po-textual">
  Furthermore there are systems of constraint based on special-purpose
  languages, rather than general-purpose languages. The feature system
  declaration created by the Text Encoding Initiative (TEI) and now
  being incorporated into ISO 24610-2 is an example — a set of XML
  elements (the feature system declaration) that can be used to
  constrain the expression of another set of XML elements (the feature
  structure itself).</textual><footnote class="po-popup e53 e53"><para class="po-block e54 e54"><textual class="po-textual">Burnard, Lou and Syd Bauman, eds. “18 Feature Structures”
  </textual><emphasis class="po-inline e55 e55"><textual class="po-textual">TEI P5: Guidelines for Electronic Text Encoding and
  Interchange</textual></emphasis><textual class="po-textual">. Version 1.1.0. 2008-07-04. TEI Consortium.
  </textual><link class="po-inline e56 e56" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/FS.html   " xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/FS.html</textual></link><textual class="po-textual">
  2008-08-30</textual></para></footnote></para><para class="po-block e57 e57"><textual class="po-textual">So the choice of </textual><emphasis class="po-inline e58 e58"><textual class="po-textual">how</textual></emphasis><textual class="po-textual"> to express a
  particular constraint is not always obvious. But a related question
  is perhaps just as important: </textual><emphasis class="po-inline e59 e59"><textual class="po-textual">where</textual></emphasis><textual class="po-textual"> should
  these constraints be expressed? What are the consequences of
  expressing them in different places?</textual></para><para class="po-block e60 e60"><textual class="po-textual">This paper will attempt to shed light on these general
  questions by taking an in-depth look at the possible locations for
  the expression of one particular kind of constraint, and the
  consequences of those different locations. The constraint discussed
  will be that of limiting the value an attribute may take to one of
  an enumerated list of possible values. For simplicity the presumed
  setting for this constraint will be in a TEI document, but the
  principles should be equally applicable to any other encoding
  language that separates the document from its metadata, including
  DocBook or XHTML. The locations considered will be
  </textual><itemizedlist class="po-table e61 e61"><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">the “normal” way, in the formal closed schema (RELAX NG
    will be used as the example)</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">in a formal open schema (ISO Schematron will be used as the example)</textual></para></listitem><listitem class="po-container e66 e66"><para class="po-block e67 e67"><textual class="po-textual">in the metadata element (i.e.
    </textual><code class="po-atom e68 e68"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual">)</textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">in a separate metadata file</textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">in the metaschema file (i.e. the ODD file)</textual></para></listitem><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">no formal constraint</textual></para></listitem></itemizedlist><textual class="po-textual">
  Each of the latter methods will be compared to and contrasted with
  the first.</textual></para><section class="po-hcontainer e75 e75" xml:id="uc"><title class="po-block e76 e76"><textual class="po-textual">Use Case</textual></title><para class="po-block e77 e77"><textual class="po-textual">There are lots of reasons to wish to constrain markup
    constructs, in particular attribute values. One case worth
    considering is the markup project which has tens or hundreds of
    occurrences of a particular attribute in each of tens or hundreds
    of files, where the list of possible values for the attribute is
    different for each file.</textual></para><para class="po-block e78 e78"><textual class="po-textual">Imagine, e.g., an epigraphy project transcribing thousands
    of inscriptions on various objects. Imagine further that the
    inscriptions are divided among 27 separate files, organized by
    some criteria other than the kind of object that bears the
    inscription (e.g. date the object was discovered, current museum in
    which it is held, whatever). That which the text bearing object is
    made of is recorded in a TEI manuscript description on the
    </textual><code class="po-atom e79 e79"><textual class="po-textual">material=</textual></code><textual class="po-textual"> attribute of the
    </textual><code class="po-atom e80 e80"><textual class="po-textual">&lt;supportDesc&gt;</textual></code><textual class="po-textual"> element. Possible values might
    include </textual><code class="po-atom e81 e81"><textual class="po-textual">"bronze"</textual></code><textual class="po-textual">, </textual><code class="po-atom e82 e82"><textual class="po-textual">"marble"</textual></code><textual class="po-textual">,
    </textual><code class="po-atom e83 e83"><textual class="po-textual">"limestone"</textual></code><textual class="po-textual">, </textual><code class="po-atom e84 e84"><textual class="po-textual">"plaster"</textual></code><textual class="po-textual">,
    </textual><code class="po-atom e85 e85"><textual class="po-textual">"wood"</textual></code><textual class="po-textual">, etc.</textual></para><para class="po-block e86 e86"><textual class="po-textual">Such a typical humanities computing project is likely to have:
    </textual><itemizedlist class="po-table e87 e87"><listitem class="po-container e88 e88"><para class="po-block e89 e89"><textual class="po-textual">a subject matter expert</textual></para></listitem><listitem class="po-container e90 e90"><para class="po-block e91 e91"><textual class="po-textual">an XML expert</textual></para></listitem><listitem class="po-container e92 e92"><para class="po-block e93 e93"><textual class="po-textual">encoders — getting the extant text into
      XML-encoded digital form may be accomplished in a variety of
      ways:
      </textual><itemizedlist class="po-table e94 e94"><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">typed from source</textual></para></listitem><listitem class="po-container e97 e97"><para class="po-block e98 e98"><textual class="po-textual">post-OCR editing</textual></para></listitem><listitem class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">via an external vendor</textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">proofreaders, managers, web designers, research assistants, etc.</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e103 e103"><title class="po-block e104 e104"><textual class="po-textual">Background</textual></title><section class="po-hcontainer e105 e105"><title class="po-block e106 e106"><textual class="po-textual">Open vs Closed vs Extensible Schemas</textual></title><para class="po-block e107 e107"><textual class="po-textual">Formal schema languages can generally be categorized into
      one of two types: open or closed. A closed schema language like
      RELAX NG specifies a complete document grammar. Only those
      documents that meet all of the constraints of the grammar are
      considered valid; all others are rejected as invalid.</textual></para><para class="po-block e108 e108"><textual class="po-textual">An open schema language, like Schematron, specifies
      particular rules. Documents that violate the specified rules are
      rejected as invalid; all others are accepted as valid.</textual></para><para class="po-block e109 e109"><textual class="po-textual">One can think of closed schema languages as a white list
      spam filter, and closed schema languages as a black list spam
      filter. Using a white list (closed schema language) only e-mail
      from the addresses specified get through, all others are
      rejected as spam. Using a black list (open schema language) any
      e-mail that is on the list of problematic addresses is rejected
      as spam, all others are allowed through.</textual></para><para class="po-block e110 e110"><textual class="po-textual">Of course the situation is not as simple as that. One can
      specify some open constructs in many closed schema languages,
      and one can write sufficiently tight rules in most open
      languages that they behave like a closed language.</textual></para><para class="po-block e111 e111"><textual class="po-textual">For example, validation against the following complete
      RELAX NG grammar will permit any XML document as long as it has
      a </textual><code class="po-atom e112 e112"><textual class="po-textual">&lt;foo&gt;</textual></code><textual class="po-textual"> element with a </textual><code class="po-atom e113 e113"><textual class="po-textual">bar=</textual></code><textual class="po-textual">
      attribute as the first child of the root element.
      </textual><programlisting class="po-block e114 e114" xml:space="preserve"><textual class="po-textual">start = element * { any_attribute*, foo, any_element* }
any_attribute = attribute * { text }
any_element = element * { any* }
any = ( any_attribute | any_element | text )
any_sans_bar = ( attribute * - ( bar ) { text } | any_element | text )
foo = element foo { attribute bar { text }, any_sans_bar* }</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e115 e115"><textual class="po-textual">Conversely, validation against the following Schematron
      rule will permit only those documents that have one
      </textual><code class="po-atom e116 e116"><textual class="po-textual">&lt;platypus&gt;</textual></code><textual class="po-textual"> element with a </textual><code class="po-atom e117 e117"><textual class="po-textual">bill=</textual></code><textual class="po-textual">
      attribute that has the value </textual><code class="po-atom e118 e118"><textual class="po-textual">"duck"</textual></code><textual class="po-textual"> as the only
      child of the root </textual><code class="po-atom e119 e119"><textual class="po-textual">&lt;enigma&gt;</textual></code><textual class="po-textual"> element.
      </textual><programlisting class="po-block e120 e120" xml:space="preserve"><textual class="po-textual">  &lt;pattern&gt;
    &lt;rule context="/*"&gt;
      &lt;assert test="name(.)='enigma'"&gt;Root element must be "enigma"&lt;/assert&gt;
      &lt;report test="@*"&gt;Root "enigma" element can not have attributes&lt;/report&gt;
      &lt;assert test="count(child::*)=1"&gt;"enigma" can only have one child 
      ("platypus")&lt;/assert&gt;
      &lt;assert test="count(child::platypus)=1"&gt;"enigma" can only have one 
      "platypus" child&lt;/assert&gt;
      &lt;report test="child::text()[not(normalize-space(.)='')]"&gt;"enigma" is 
      not allowed to have text, just "platypus"&lt;/report&gt;
    &lt;/rule&gt;
    &lt;rule context="/enigma/platypus"&gt;
      &lt;assert test="@*[name(.)='bill']"&gt;"platypus" must have a bill= 
      attribute&lt;/assert&gt;
      &lt;report test="@*[not(name(.)='bill')]"&gt;"platypus" must not have any 
      attributes other than bill=&lt;/report&gt;
      &lt;report test="child::*"&gt;"platypus" must be empty (i.e., can not have 
      child elements)&lt;/report&gt;
      &lt;assert test="string-length( normalize-space(.) ) = 0"&gt;"platypus" 
      must be empty (i.e., can not contain text)&lt;/assert&gt;
    &lt;/rule&gt;
    &lt;rule context="/enigma/platypus/@bill"&gt;
      &lt;assert test="normalize-space(.)='duck'"&gt;The value of bill= of 
      "platypus" must be 'duck'&lt;/assert&gt;
    &lt;/rule&gt;
  &lt;/pattern&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e121 e121"><textual class="po-textual">These reverse uses of open and closed schema languages may
      be thought of as analogous to black-list or white-list spam
      filters that permit wildcards.</textual></para><para class="po-block e122 e122"><textual class="po-textual">Neither of the above examples are particularly good ways
      of performing the desired validation, but they serve as
      proofs-of-concept that when we refer to a schema language as
      “open” or “closed”, we may be referring to its default, and not
      its only, behavior.</textual></para><para class="po-block e123 e123"><textual class="po-textual">There is one further twist worth mentioning. Some modular
      XML document systems, including DocBook and TEI, permit a user
      of the system to generate (closed) schemas that contain not only
      the element and attribute declarations native to the system, but
      also additional declarations for constructs added by the
      user.</textual></para></section><section class="po-hcontainer e124 e124"><title class="po-block e125 e125"><textual class="po-textual">Literate Encoding</textual></title><para class="po-block e126 e126"><textual class="po-textual">Literate programming is a style of programming intended to
      make computer documentation better by, among other things,
      placing the documentation and source code in the same computer
      file. The TEI has applied this concept to the schemas used to
      validate documents to help ascertain whether or not they conform
      to the TEI Guidelines. The source code from which the schemas
      are generated and the prose documentation that make up the bulk
      of the TEI Guidelines are stored in one computer
      document.</textual></para><para class="po-block e127 e127"><textual class="po-textual">In order to facilitate this, and in order to help make it
      easy to extract formal schemas in any of a variety of popular
      languages, the formal constraints are (for the most part)
      expressed in the TEI language, rather than any particular schema
      language.</textual></para><para class="po-block e128 e128"><textual class="po-textual">Thus the TEI Guidelines proper (some 32 chapters of prose
      documentation), formal schemas expressed in RELAX NG, the XML
      DTD language, or the W3C Schema language, and reference
      documentation for those schemas, are all extracted from the same
      single document. We say that this “one document does” it all,
      and thus it is referred to as an ODD document.</textual></para></section></section><section class="po-hcontainer e129 e129"><title class="po-block e130 e130"><textual class="po-textual">In the Closed Schema (RELAX NG file)</textual></title><section class="po-hcontainer e131 e131"><title class="po-block e132 e132"><textual class="po-textual">how</textual></title><para class="po-block e133 e133"><textual class="po-textual">Many are probably quite familiar with the mechanism for
      constraining an enumerated attribute in a formal closed schema
      language. E.g., in RELAX NG (compact syntax), the possible
      values of the </textual><code class="po-atom e134 e134"><textual class="po-textual">type=</textual></code><textual class="po-textual"> attribute (in this case, of the
      </textual><code class="po-atom e135 e135"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> element) could be constrained with a
      construct like
      </textual><programlisting class="po-block e136 e136" xml:space="preserve"><textual class="po-textual">attribute type { "person" | "place" | "ship" | "sword" }</textual></programlisting><textual class="po-textual">
      A variety of readily available off-the-shelf software will test
      whether or not a document is valid with respect to a RELAX NG
      schema.</textual></para></section><section class="po-hcontainer e137 e137"><title class="po-block e138 e138"><textual class="po-textual">advantages</textual></title><para class="po-block e139 e139"><textual class="po-textual">This method is extremely common for a reason: it makes a
      lot of sense. In many, many cases XML document structure is
      already governed by an external closed schema. These external
      schemas, at least when written in one of the three major
      languages (DTD, RELAX NG, W3C XML Schema) are generally easy to
      read and process. They describe the constraint in a standard
      formal language that has wide software support, including open
      source validators.</textual></para><para class="po-block e140 e140"><textual class="po-textual">These languages typically provide the capability to
      specify a variety of structural and content constraints on XML
      documents. In particular, they provide the capability needed
      here: to constrain the set of possible values of the
      </textual><code class="po-atom e141 e141"><textual class="po-textual">type=</textual></code><textual class="po-textual"> attribute to one of a list of possibilities.
      </textual><footnote class="po-popup e142 e142"><para class="po-block e143 e143"><textual class="po-textual">DTDs impose greater restrictions on what the
      members of that list can be than the others: each possible value
      must be an XML Name.</textual></para></footnote></para></section><section class="po-hcontainer e144 e144"><title class="po-block e145 e145"><textual class="po-textual">disadvantages</textual></title><para class="po-block e146 e146"><textual class="po-textual">In many cases, the person or persons who write and
      maintain the external schema is not the same as the person or
      persons who create the XML instances (or the programs that write
      the XML instances) that conform to it. In these cases, those who
      create the instances often do not have either the necessary
      knowledge (e.g., knowing the schema language) or capability
      (e.g., having read-write access to the schema) to make changes
      to it.</textual></para><para class="po-block e147 e147"><textual class="po-textual">Furthermore in many cases (whether the instance creator is
      the same as the schema maintainer or not), a single external
      schema governs the validity of dozens or even tens of thousands
      of XML instances. But the desired constraints on a particular
      attribute may be different in different instances. Typically in
      these cases the schema limits the attribute to one of a set
      that is the union of all possible values in all governed
      documents. Here adding the additional constraint of </textual><quote class="po-inline e148 e148"><textual class="po-textual">only
      these values in </textual><emphasis class="po-inline e149 e149"><textual class="po-textual">this</textual></emphasis><textual class="po-textual"> document</textual></quote><textual class="po-textual">
      requires making a separate schema that is like the original in
      all respects except for the declaration of the
      </textual><code class="po-atom e150 e150"><textual class="po-textual">type=</textual></code><textual class="po-textual"> attribute of </textual><code class="po-atom e151 e151"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual">.</textual></para></section></section><section class="po-hcontainer e152 e152"><title class="po-block e153 e153"><textual class="po-textual">In the Open Schema (ISO Schematron)</textual></title><para class="po-block e154 e154"><textual class="po-textual">Many are probably quite familiar with the mechanism for
      constraining an enumerated attribute in a formal open schema
      language. E.g., in Schematron (DSDL part 4), the possible values
      of the </textual><code class="po-atom e155 e155"><textual class="po-textual">type=</textual></code><textual class="po-textual"> attribute of the TEI
      </textual><code class="po-atom e156 e156"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> element could be constrained with a
      construct like
      </textual><programlisting class="po-block e157 e157" xml:space="preserve"><textual class="po-textual">&lt;pattern&gt;
  &lt;rule context="tei:name/@type"&gt;
    &lt;assert test="normalize-space(.)='person'
               or normalize-space(.)='place'
               or normalize-space(.)='ship'
               or normalize-space(.)='sword'"&gt;
      Names can only be of people, places, ships, or swords
    &lt;/assert&gt;
  &lt;/rule&gt;
&lt;/pattern&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e158 e158"><textual class="po-textual">While the use of open vs closed schemas have a lot of
    advantages and disadvantages to the schema designer, with respect
    to this particular question, the advantages and disadvantages are
    primarily the same: while the constraint can be expressed in a
    formal, widely supported language, and can be tested with readily
    available tools, it is still in a separate file that may support
    many documents, that may not be accessible, and that uses a
    language that may be foreign to those who would like to change it.</textual></para><para class="po-block e159 e159"><textual class="po-textual">There is one additional disadvantage of Schematron in
    particular with respect to RELAX NG: it is harder to annotate the
    Schematron schema than the RELAX NG schema. RELAX NG deliberately
    permits elements from other namespaces to be mixed in with the
    RELAX NG specifications, and defines where annotations relating to
    particular structures should go. Furthermore, because the four
    tokens against which we are trying to validate are expressed as
    four separate elements (in the XML syntax), there is a place to
    annotate each separately (the </textual><code class="po-atom e160 e160"><textual class="po-textual">&lt;a:documentation&gt;</textual></code><textual class="po-textual">
    element follows the </textual><code class="po-atom e161 e161"><textual class="po-textual">&lt;rng:value&gt;</textual></code><textual class="po-textual"> element to which it
    refers). Schematron also has a built-in documentation feature (a
    </textual><code class="po-atom e162 e162"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual"> element), but because all four tokens are
    tucked into a single XPath expression, it is a bit harder to
    discuss them individually. This is partially confounded because
    </textual><code class="po-atom e163 e163"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual"> is not permitted in </textual><code class="po-atom e164 e164"><textual class="po-textual">&lt;rule&gt;</textual></code><textual class="po-textual">,
    </textual><code class="po-atom e165 e165"><textual class="po-textual">&lt;assert&gt;</textual></code><textual class="po-textual">, or </textual><code class="po-atom e166 e166"><textual class="po-textual">&lt;report&gt;</textual></code><textual class="po-textual">, making it
    difficult to put the documentation close to the code. This is
    partially alleviated because elements from foreign namespaces are
    permitted in those spaces, and inside </textual><code class="po-atom e167 e167"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual">. Thus
    something like the following construct could be used to provide
    documentation of such a constraint.
</textual><programlisting class="po-block e168 e168" xml:space="preserve"><textual class="po-textual">&lt;pattern&gt;
  &lt;p class="annotation"&gt;The various values for &lt;tei:att&gt;type&lt;/tei:att&gt; of 
    &lt;tei:gi&gt;name&lt;/tei:gi&gt; came about as follows: &lt;tei:list type="gloss"&gt;
      &lt;tei:label&gt;
        &lt;tei:val&gt;person&lt;/tei:val&gt;
      &lt;/tei:label&gt;
      &lt;tei:item&gt;Added 2007-04-17 when we removed &lt;tei:gi&gt;persName&lt;/tei:gi&gt;&lt;/tei:item&gt;
      &lt;tei:label&gt;
        &lt;tei:val&gt;place&lt;/tei:val&gt;
      &lt;/tei:label&gt;
      &lt;tei:item&gt;Added 2007-04-17 when we removed &lt;tei:gi&gt;placeName&lt;/tei:gi&gt;&lt;/tei:item&gt;
      &lt;tei:label&gt;
        &lt;tei:val&gt;ship&lt;/tei:val&gt;
      &lt;/tei:label&gt;
      &lt;tei:item&gt;Added 2007-04-17 in order to accommodate the various ship names&lt;/tei:item&gt;
      &lt;tei:label&gt;
        &lt;tei:val&gt;ship&lt;/tei:val&gt;
      &lt;/tei:label&gt;
      &lt;tei:item&gt;Added 2007-10-02 when we found a reference to "Excalibur" that the
        professor needed to annotate&lt;/tei:item&gt;
    &lt;/tei:list&gt;
  &lt;/p&gt;
  &lt;rule context="tei:name/@type"&gt;
    &lt;tei:note&gt;&lt;tei:att&gt;type&lt;/tei:att&gt; of &lt;tei:gi&gt;rs&lt;/tei:gi&gt; is matched elsewhere.&lt;/tei:note&gt;
    &lt;assert test=".='person' or .='place' or .='ship' or .='sword'"&gt; Names may only be 
      of people, places, ships, or swords &lt;/assert&gt;
  &lt;/rule&gt;
&lt;/pattern&gt;</textual></programlisting><textual class="po-textual">
</textual></para></section><section class="po-hcontainer e169 e169"><title class="po-block e170 e170"><textual class="po-textual">In the Metaschema (ODD file)</textual></title><section class="po-hcontainer e171 e171"><title class="po-block e172 e172"><textual class="po-textual">how</textual></title><para class="po-block e173 e173"><textual class="po-textual">The same constraint might be expressed, at a slightly
      higher level of abstraction and combined with some
      documentation, using the ODD literate encoding language:
      </textual><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">
&lt;attDef ident="</textual><emphasis class="po-inline e175 e175" role="bold"><textual class="po-textual">type</textual></emphasis><textual class="po-textual">"&gt;
  &lt;valList type="closed"&gt;
    &lt;valItem ident="</textual><emphasis class="po-inline e176 e176" role="bold"><textual class="po-textual">person</textual></emphasis><textual class="po-textual">"&gt;
      &lt;desc&gt;The name refers to a person&lt;/desc&gt;
    &lt;/valItem&gt;
    &lt;valItem ident="</textual><emphasis class="po-inline e177 e177" role="bold"><textual class="po-textual">place</textual></emphasis><textual class="po-textual">"&gt;
      &lt;desc&gt;The name refers to a political or man-made region, for example
        a city, country, hamlet, town, or neighborhood. For geographical
        places such as rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/desc&gt;
    &lt;/valItem&gt;
    &lt;valItem ident="</textual><emphasis class="po-inline e178 e178" role="bold"><textual class="po-textual">ship</textual></emphasis><textual class="po-textual">"&gt;
      &lt;desc&gt;The name refers to a ship, whether sea-worthy, interplanetary,
        or interstellar&lt;/desc&gt;
    &lt;/valItem&gt;
    &lt;valItem ident="</textual><emphasis class="po-inline e179 e179" role="bold"><textual class="po-textual">sword</textual></emphasis><textual class="po-textual">"&gt;
      &lt;desc&gt;The name refers to a sword&lt;/desc&gt;
    &lt;/valItem&gt;
  &lt;/valList&gt;
&lt;/attDef&gt;</textual></programlisting><textual class="po-textual">
      There exists software that will </textual><quote class="po-inline e180 e180"><textual class="po-textual">tangle</textual></quote><textual class="po-textual"> ODD
      specifications like the above into formal declarations in one of
      several schema languages, including RELAX NG. Then any of the
      same variety of readily available off-the-shelf software could
      be used to test validity.</textual></para><para class="po-block e181 e181"><textual class="po-textual">Furthermore, there exists software that will
      </textual><quote class="po-inline e182 e182"><textual class="po-textual">weave</textual></quote><textual class="po-textual"> the same specification above into easily
      readable hyperlinked documentation.</textual></para></section><section class="po-hcontainer e183 e183"><title class="po-block e184 e184"><textual class="po-textual">advantages</textual></title><para class="po-block e185 e185"><textual class="po-textual">The advantages of literate programming are well
      understood, and include more easily readable and understandable
      source code, and that documentation (because it is right next to
      the source code) is more likely to match the program and be
      updated when the source code changes.</textual><footnote class="po-popup e186 e186"><para class="po-block e187 e187"><textual class="po-textual">Knuth,
      Donald. </textual><emphasis class="po-inline e188 e188"><textual class="po-textual">Literate Programming</textual></emphasis><textual class="po-textual">, ISBN
      0-9370-7380-6.</textual></para></footnote><textual class="po-textual"> These advantages apply here as well.
      In addition, at least for those familiar with TEI, there is the
      advantage that the language used to describe the constraints is
      a TEI language, so schema designers are likely to be familiar
      with at least the documentation paradigm for the specialized
      schema-description elements, if not the elements themselves; in
      addition, they are likely familiar with the generic TEI elements
      (like </textual><code class="po-atom e189 e189"><textual class="po-textual">&lt;desc&gt;</textual></code><textual class="po-textual">, above) that are used in addition
      to the specialized elements.</textual></para></section><section class="po-hcontainer e190 e190"><title class="po-block e191 e191"><textual class="po-textual">disadvantages</textual></title><para class="po-block e192 e192"><textual class="po-textual">The disadvantages of the external schema (whether open or
      closed) are present here as well. Furthermore, an extra
      processing step is required to generate (i.e.
      </textual><quote class="po-inline e193 e193"><textual class="po-textual">tangle</textual></quote><textual class="po-textual">) a schema that itself can be used to
      validate instances using off-the-shelf software. In addition, at
      least for those who are not intimately familiar with TEI, there
      is the disadvantage that the language used to describe the
      constraints is primarily a TEI language, so schema designers may
      not be familiar with the specialized schema-description
      elements.</textual></para></section></section><section class="po-hcontainer e194 e194"><title class="po-block e195 e195"><textual class="po-textual">In the Metadata (</textual><code class="po-atom e196 e196"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual">)</textual></title><section class="po-hcontainer e197 e197" xml:id="pointing"><title class="po-block e198 e198"><textual class="po-textual">how — pointing</textual></title><para class="po-block e199 e199"><textual class="po-textual">It should be quite feasible to develop a mechanism for
      expressing the list of possible values of an attribute in the
      same document in a rather abstract way. For
      example:</textual><programlisting class="po-block e200 e200" xml:space="preserve"><textual class="po-textual">&lt;codeGrp elementTypes="name rs" attributes="type"&gt;
  &lt;codeDef xml:id="person"&gt;The name or string refers to a
    person&lt;/codeDef&gt;
  &lt;codeDef xml:id="place"&gt;The name or string refers to a
    political or man-made region, for example a city, country,
    hamlet, town, or neighborhood. For geographical places such as
    rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/codeDef&gt;
  &lt;codeDef xml:id="ship"&gt;The name or string refers to a ship,
    whether sea-worthy, interplanetary, or
    interstellar&lt;/codeDef&gt;
  &lt;codeDef xml:id="sword"&gt;The name or string refers to a
    sword, &lt;foreign xml:lang="fr"&gt;main-gauche&lt;/foreign&gt;, switchblade,
    or other edged weapon&lt;/codeDef&gt;
&lt;/codeGrp&gt;</textual></programlisting><textual class="po-textual">
      Given this encoding in the </textual><code class="po-atom e201 e201"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual">, the
      </textual><code class="po-atom e202 e202"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> element could have </textual><code class="po-atom e203 e203"><textual class="po-textual">type=</textual></code><textual class="po-textual">
      values of </textual><code class="po-atom e204 e204"><textual class="po-textual">"#person"</textual></code><textual class="po-textual">, </textual><code class="po-atom e205 e205"><textual class="po-textual">"#place"</textual></code><textual class="po-textual">, etc.
      Software could be developed to validate that the value of
      </textual><code class="po-atom e206 e206"><textual class="po-textual">type=</textual></code><textual class="po-textual"> of </textual><code class="po-atom e207 e207"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> is a URI that
      points to an element whose parent </textual><code class="po-atom e208 e208"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual"> has
      </textual><code class="po-atom e209 e209"><textual class="po-textual">"name"</textual></code><textual class="po-textual"> in its </textual><code class="po-atom e210 e210"><textual class="po-textual">elementTypes=</textual></code><textual class="po-textual"> list and
      </textual><code class="po-atom e211 e211"><textual class="po-textual">"type"</textual></code><textual class="po-textual"> in its </textual><code class="po-atom e212 e212"><textual class="po-textual">attributes=</textual></code><textual class="po-textual"> list. (I
      believe that Schematron code could probably be used for this
      test, but have not yet demonstrated this.) Note that the check
      does not specify the element type of the child of
      </textual><code class="po-atom e213 e213"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual">. This gives the flexibility to have
      special-purpose </textual><code class="po-atom e214 e214"><textual class="po-textual">&lt;codeDef&gt;</textual></code><textual class="po-textual">-like elements that
      might provide structured information about the value. E.g., one
      can well imagine the TEI’s </textual><code class="po-atom e215 e215"><textual class="po-textual">&lt;handNote&gt;</textual></code><textual class="po-textual"> element being
      used in this way.</textual></para></section><section class="po-hcontainer e216 e216"><title class="po-block e217 e217"><textual class="po-textual">advantages</textual></title><para class="po-block e218 e218"><textual class="po-textual">This mechanism has significant potential advantages,
      particularly in cases where one schema is used for many files
      which may have different attribute constraint requirements. For
      most users it is much easier to change something in the same
      file they are working on, rather then needing to make changes to
      an external schema, particularly an external schema that may be
      in a language the user does not know or in a file to which the
      user does not have write access, and particularly changes that
      might inadvertently invalidate other existing instances. Thus
      the encoder, as opposed to the schema-designer, can add, remove,
      or change a value quite easily.</textual></para><para class="po-block e219 e219"><textual class="po-textual">Another advantage is that the information about to what
      values the attribute is constrained, and what those values mean,
      is an integral part of the document. This means that this
      information will survive in the situation where a document
      instance is sent along without its schema or documentation.
      Furthermore the list of values in different files at a given
      project could be slightly different.</textual></para><para class="po-block e220 e220"><textual class="po-textual">Moreover, the particular system shown here has the
      advantage that it uses a mechanism most users are already
      familiar with: </textual><code class="po-atom e221 e221"><textual class="po-textual">xml:id=</textual></code><textual class="po-textual"> and relative URIs (i.e.,
      bare name fragment identifiers). It is worth noting, though,
      that there is no requirement that the URIs be bare name
      fragment identifiers, which permits this system to quickly and
      easily be changed to that which is discussed in </textual><xref class="po-milestone e222 e222" linkend="separate"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e223 e223"><title class="po-block e224 e224"><textual class="po-textual">disadvantages</textual></title><para class="po-block e225 e225"><textual class="po-textual">This system has obvious inefficiencies when multiple,
      perhaps thousands, of document instances share the same
      constraints — the same information is repeated in each
      file.</textual></para><para class="po-block e226 e226"><textual class="po-textual">Another significant disadvantage of this method is that we
      are using a non-standard language for constraint and
      documentation. The question, then, is whether or not this system
      is demonstrably significantly better than what can be obtained
      using standard languages.</textual><footnote class="po-popup e227 e227"><para class="po-block e228 e228"><textual class="po-textual">What some call
      </textual><emphasis class="po-inline e229 e229"><textual class="po-textual">Syd’s rule</textual></emphasis><textual class="po-textual">, and I have begun to call my
      </textual><emphasis class="po-inline e230 e230"><textual class="po-textual">wheel re-invention prevention convention</textual></emphasis><textual class="po-textual">:
      </textual><quote class="po-inline e231 e231"><textual class="po-textual">unless your method is significantly and demonstrably
      superior to the standard, you should be using the
      standard.</textual></quote><textual class="po-textual">.</textual></para></footnote></para><para class="po-block e232 e232"><textual class="po-textual">Lastly the fact that this system uses the URI pointing
      mechanism produces a disadvantages, one of which is
      severely problematic:
      </textual><itemizedlist class="po-table e233 e233"><listitem class="po-container e234 e234"><para class="po-block e235 e235"><textual class="po-textual">of minor annoyance is that the user needs to
  encode a hash-mark (</textual><quote class="po-inline e236 e236"><code class="po-atom e237 e237"><textual class="po-textual">#</textual></code></quote><textual class="po-textual">, U+0023) at
  the beginning of each value;</textual></para></listitem><listitem class="po-container e238 e238"><para class="po-block e239 e239"><textual class="po-textual">the fact that values are restricted to XML
  Names could be a problem in some situations;</textual></para></listitem><listitem class="po-container e240 e240"><para class="po-block e241 e241"><textual class="po-textual">but far more problematic, because
  </textual><code class="po-atom e242 e242"><textual class="po-textual">xml:id=</textual></code><textual class="po-textual"> needs to be unique within the document,
  any given possible attribute value can only occur on one
  attribute (although that attribute could be on multiple
  elements)</textual><textual class="po-textual"> — furthermore, no other element elsewhere in
      the document can use the same string as one of these attribute
      values as its identifier.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e243 e243"><title class="po-block e244 e244"><textual class="po-textual">how — co-reference</textual></title><para class="po-block e245 e245"><textual class="po-textual">Those last disadvantages that are the result of using
      </textual><code class="po-atom e246 e246"><textual class="po-textual">xml:id=</textual></code><textual class="po-textual"> and URIs could be circumvented by matching
      the attribute values, rather than using a true pointer (e.g.
      ID/IDREF or URI). In the </textual><code class="po-atom e247 e247"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual"> the enumeration
      of the possible attribute values would look almost the same, but
      would use a different attribute for storing the actual
      value.</textual></para><programlisting class="po-block e248 e248" xml:space="preserve"><textual class="po-textual">&lt;codeGrp elementTypes="name rs" attributes="type"&gt;
  &lt;codeDef attrVal="person"&gt;The name or string refers to a
    person&lt;/codeDef&gt;
  &lt;codeDef attrVal="place"&gt;The name or string refers to a
    political or man-made region, for example a city, country,
    hamlet, town, or neighborhood. For geographical places such as
    rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/codeDef&gt;
  &lt;codeDef attrVal="ship"&gt;The name or string refers to a ship,
    whether sea-worthy, interplanetary, or
    interstellar&lt;/codeDef&gt;
  &lt;codeDef attrVal="sword"&gt;The name or string refers to a
    sword, &lt;foreign xml:lang="fr"&gt;main-gauche&lt;/foreign&gt;, switchblade,
    or other edged weapon&lt;/codeDef&gt;
&lt;/codeGrp&gt;</textual></programlisting><para class="po-block e249 e249"><textual class="po-textual">Software could be developed to validate that the value of
      </textual><code class="po-atom e250 e250"><textual class="po-textual">type=</textual></code><textual class="po-textual"> of </textual><code class="po-atom e251 e251"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> is a string that
      matches the </textual><code class="po-atom e252 e252"><textual class="po-textual">attrVal=</textual></code><textual class="po-textual"> attribute of an element whose
      parent </textual><code class="po-atom e253 e253"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual"> has </textual><code class="po-atom e254 e254"><textual class="po-textual">"name"</textual></code><textual class="po-textual"> in its
      </textual><code class="po-atom e255 e255"><textual class="po-textual">elementTypes=</textual></code><textual class="po-textual"> list and </textual><code class="po-atom e256 e256"><textual class="po-textual">"type"</textual></code><textual class="po-textual"> in its
      </textual><code class="po-atom e257 e257"><textual class="po-textual">attribute=</textual></code><textual class="po-textual"> list. (I believe that Schematron code
      could probably be used for this test, but have not yet
      demonstrated this. Certainly XSLT 1.0 can transform this into
      simple Schematron; this I have demonstrated, see </textual><xref class="po-milestone e258 e258" linkend="codeGrp2Schematron"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.) Note that the check does not
      specify the element type of the child of
      </textual><code class="po-atom e259 e259"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual">. This gives the flexibility to have
      special-purpose </textual><code class="po-atom e260 e260"><textual class="po-textual">&lt;codeDef&gt;</textual></code><textual class="po-textual">-like elements that
      might provide structured information about the value. E.g., one
      can well imagine the TEI’s </textual><code class="po-atom e261 e261"><textual class="po-textual">&lt;handNote&gt;</textual></code><textual class="po-textual"> element
      being used in this way.</textual></para><para class="po-block e262 e262"><textual class="po-textual">This system avoids the disadvantages of using
      </textual><code class="po-atom e263 e263"><textual class="po-textual">xml:id=</textual></code><textual class="po-textual">, and yet has several advantages over
      external schema files. E.g., encoders can quickly and easily add
      values to closed lists, in a manner that does not run the the
      risk that they might break the rest of the schema. I find the
      case of the encoder who wishes to quickly and easily express
      stricter constraints on her attribute values in a given file
      than those that come with the generic external schema very
      compelling.</textual></para></section></section><section class="po-hcontainer e264 e264" xml:id="separate"><title class="po-block e265 e265"><textual class="po-textual">In the Metadata (separate file)</textual></title><para class="po-block e266 e266"><textual class="po-textual">In the method described in </textual><xref class="po-milestone e267 e267" linkend="pointing"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
    the values of the </textual><code class="po-atom e268 e268"><textual class="po-textual">type=</textual></code><textual class="po-textual"> attribute of
    </textual><code class="po-atom e269 e269"><textual class="po-textual">&lt;name&gt;</textual></code><textual class="po-textual"> are URIs. Because of this, it would be
    feasible to store the </textual><code class="po-atom e270 e270"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual"> element with
    </textual><code class="po-atom e271 e271"><textual class="po-textual">xml:id=</textual></code><textual class="po-textual"> attributes in a project-wide
    “attribute_definitions.xml” file. While this has the advantage
    of flexibility and reusability, it presents the sizable
    disadvantage that the attribute values would now depend on
    details of system features external to the document. E.g., the
    ability to validate </textual><code class="po-atom e272 e272"><textual class="po-textual">&lt;name
    type="../attribute_definitions.xml#sword"&gt;</textual></code><textual class="po-textual"> breaks if the
    current file is moved to a sub-directory.</textual></para><para class="po-block e273 e273"><textual class="po-textual">Furthermore, if the </textual><code class="po-atom e274 e274"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual"> is stored in a
    separate file, the maintenance issues are almost the same as those
    for a separate closed schema (e.g., a RELAX NG grammar), open
    schema (e.g., a Schematron schema), or metaschema (e.g., a TEI
    ODD): those who have reason to change the constraints expressed
    may not have the write-permissions necessary to do so, and if they
    do may be at risk for invalidating files other than the one being
    worked on.</textual></para><para class="po-block e275 e275"><textual class="po-textual">So in some cases (in particular, the scenario sketched out
    in </textual><xref class="po-milestone e276 e276" linkend="uc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) it makes lots of sense to leave the
    formal constraints for some aspects of a document in the metadata
    section of that document itself, e.g. in the
    </textual><code class="po-atom e277 e277"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual">. But having convinced ourselves there
    is a need to be able to express constraints in a different
    </textual><emphasis class="po-inline e278 e278"><textual class="po-textual">place</textual></emphasis><textual class="po-textual"> than is usual, why require a separate
    formal construct to express the constraint? Why not include RELAX
    NG, Schematron, or ODD markup constructs in the
    </textual><code class="po-atom e279 e279"><textual class="po-textual">&lt;teiHeader&gt;</textual></code><textual class="po-textual"> directly?</textual><footnote class="po-popup e280 e280"><para class="po-block e281 e281"><textual class="po-textual">Indeed, James
    Cummings and I have suggested this on more than one occasion. See,
    e.g., </textual><link class="po-inline e282 e282" xlink:actuate="onRequest" xlink:href="http://lists.village.virginia.edu/pipermail/tei-council/2005/005627.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://lists.village.virginia.edu/pipermail/tei-council/2005/005627.html</textual></link><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">
    This is worthy of consideration, but is outside the scope of the
    current paper.</textual></para></section><appendix class="po-hcontainer e283 e283" xml:id="codeGrp2Schematron"><title class="po-block e284 e284"><textual class="po-textual">&lt;codeGrp&gt; to Schematron</textual></title><para class="po-block e285 e285"><textual class="po-textual">The following XSLT 1.0 stylesheet is a proof-of-concept
  demonstration for transforming the </textual><code class="po-atom e286 e286"><textual class="po-textual">&lt;codeGrp&gt;</textual></code><textual class="po-textual">
  elements discussed above into Schematron that could be used to
  validate that an XML instance used only the mentioned possible
  values of the attribute specified.</textual></para><programlisting class="po-block e287 e287" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Tranform my mythical &lt;codeGrp&gt; elements into a Schematron schema --&gt;
&lt;!-- Copyleft 2008 Syd Bauman --&gt;
&lt;!-- Last updated: 2008-08-31 --&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;!-- only mess with &lt;codeGrp&gt; elements; if there are none, we do nothing --&gt;
    &lt;!-- Note that we presume each &lt;codeGrp&gt; has both elementTypes= and  --&gt;
    &lt;!-- attriubtes= specified and that their values are lists of one or more --&gt;
    &lt;!-- XML Names. No error-checking for this here, schema validation should --&gt;
    &lt;!-- have already flagged any that don't have both required attributes or --&gt;
    &lt;!-- have inappropriate values. --&gt;
    &lt;xsl:if test="//codeGrp"&gt;
      &lt;!-- if there is one (or more) we write out a Schematron schema --&gt;
      &lt;sch:schema&gt;
        &lt;sch:ns uri="http://www.tei-c.org/ns/1.0" prefix="tei"/&gt;
        &lt;!-- and process each &lt;codeGrp&gt; into it --&gt;
        &lt;xsl:apply-templates select="//codeGrp"/&gt;
      &lt;/sch:schema&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Each &lt;codeGrp&gt; becomes a Schematron &lt;pattern&gt; --&gt;
  &lt;xsl:template match="codeGrp"&gt;
    &lt;sch:pattern&gt;
      &lt;!-- append a blank to the GI list for easier parsing later --&gt;
      &lt;xsl:variable name="elementTypes" select="concat(normalize-space(@elementTypes),' ')"/&gt;
      &lt;!-- append a blank to the attribute name list for easier parsing later --&gt;
      &lt;xsl:variable name="attributes" select="concat(normalize-space(@attributes),' ')"/&gt;
      &lt;!-- Each GI/attribute pair becomes a Schematron &lt;rule&gt; --&gt;
      &lt;!-- A little more detail: each paired combination of --&gt;
      &lt;!-- 1. a GI listed on my elementTypes= attribute, and --&gt;
      &lt;!-- 2. an attribute name listed on my attributes= attribte --&gt;
      &lt;!-- becomes a &lt;rule&gt;. We do this by processing each GI in  --&gt;
      &lt;!-- a recursive template, which in turn calls another recursive --&gt;
      &lt;!-- template for the list of attributes. --&gt;
      &lt;xsl:call-template name="elementTypes"&gt;
        &lt;xsl:with-param name="gis" select="$elementTypes"/&gt;
        &lt;xsl:with-param name="attrs" select="$attributes"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/sch:pattern&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Each GI listed on the elementTypes= attribute gets processed separately --&gt;
  &lt;xsl:template name="elementTypes"&gt;
    &lt;xsl:param name="gis"/&gt;
    &lt;xsl:param name="attrs"/&gt;
    &lt;!-- Taking advantage of that ending blank, parse off the 1st GI --&gt;
    &lt;xsl:variable name="this_gi" select="substring-before($gis,' ')"/&gt;
    &lt;xsl:variable name="rest" select="substring-after($gis,' ')"/&gt;
    &lt;!-- call attributes template to do the work for this particular GI --&gt;
    &lt;xsl:call-template name="attributes"&gt;
      &lt;xsl:with-param name="gi" select="$this_gi"/&gt;
      &lt;xsl:with-param name="attrs" select="$attrs"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;!-- and do the same thing (via recursion) for the rest of the GIs, if any --&gt;
    &lt;xsl:if test="string-length($rest) &gt; 1"&gt;
      &lt;xsl:call-template name="elementTypes"&gt;
        &lt;xsl:with-param name="gis" select="$rest"/&gt;
        &lt;xsl:with-param name="attrs" select="$attrs"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Each attibute name on the attributes= attribute gets processed in combination --&gt;
  &lt;!-- with the current GI --&gt;
  &lt;xsl:template name="attributes"&gt;
    &lt;xsl:param name="gi"/&gt;
    &lt;xsl:param name="attrs"/&gt;
    &lt;!-- Taking advantage of that ending blank, parse off the 1st attribute --&gt;
    &lt;xsl:variable name="this_attr" select="substring-before($attrs,' ')"/&gt;
    &lt;xsl:variable name="rest" select="substring-after($attrs,' ')"/&gt;
    &lt;!-- make a rule out of it --&gt;
    &lt;xsl:element name="sch:rule"&gt;
      &lt;xsl:attribute name="context"&gt;
        &lt;!-- There must be a better way to do this ... --&gt;
        &lt;xsl:text&gt;tei:&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$gi"/&gt;
        &lt;xsl:text&gt;/@&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$this_attr"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:variable name="numVals" select="count(child::*/@attrVal)"/&gt;
      &lt;!-- if I have no children with attrVal= specified, then don't --&gt;
      &lt;!-- generate any assertions (luckily an emtpy &lt;rule&gt; is valid --&gt;
      &lt;!-- in Schematron). --&gt;
      &lt;xsl:if test="$numVals &gt; 0"&gt;
        &lt;xsl:element name="sch:assert"&gt;
          &lt;!-- Probably would be better to generate this test (i.e., the expression --&gt;
          &lt;!-- that is the value of this output test= attribute) only once per attrVal=, --&gt;
          &lt;!-- rather once for each attrVal= for each GI/attr combination. --&gt;
          &lt;xsl:attribute name="test"&gt;
            &lt;xsl:for-each select="child::*/@attrVal"&gt;
              &lt;xsl:text&gt;.='&lt;/xsl:text&gt;
              &lt;xsl:value-of select="."/&gt;
              &lt;xsl:text&gt;'&lt;/xsl:text&gt;
              &lt;xsl:if test="$numVals &gt; 1  and  position() != last()"&gt;
                &lt;xsl:text&gt; or &lt;/xsl:text&gt;
              &lt;/xsl:if&gt;
            &lt;/xsl:for-each&gt;
          &lt;/xsl:attribute&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:element&gt;
    &lt;!-- and do the same thing (via recursion) for the rest of the attributes, if any --&gt;
    &lt;xsl:if test="string-length($rest) &gt; 1"&gt;
      &lt;xsl:call-template name="attributes"&gt;
        &lt;xsl:with-param name="gi" select="$gi"/&gt;
        &lt;xsl:with-param name="attrs" select="$rest"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</textual></programlisting></appendix></article></classedDocument>