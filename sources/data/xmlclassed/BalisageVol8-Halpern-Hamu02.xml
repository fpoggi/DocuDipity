<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">
    TCS tcs: Tata Consultancy Services trash compactor script
  </textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">
    Design considerations in the implementation of a boil-this-corpus-down-to-a-sample-document tool
  </textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">
        Creation of representative sample(s) of a large document collection can be automated using XSLT.
        Such samples will be useful for analysis, as a preliminary document analysis step in vocabulary redesign
        or conversion and to guide design of storage, editing, and transformation processing.
        Design goals are: to work intuitively with default configuration and no schema, produce plausible output,
        and produce a range of outputs from a large representative set to a short but highly complex sample document.
        The technique can be conceptualized in passes: annotate structures as original or redundant;
        keep wrappers to accommodate original markup found lower in the hierarchy;
        retain required children and attributes; and collapse similar structures.
        Possible settings include redundancy thresholds, text compression techniques, target length, schema-awareness,
        schema intuitions, how much context to preserve around kept elements, and whether similar structures should be collapsed (overlaid).
      </textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Charlie</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Halpern-Hamu</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">
          Charlie has been working with structured text since 1991.
          During this time, he has acted as a content and systems architect, programmer, systems integrator, consultant,
          mentor, best-practices coordinator, trainer, book editor, project lead, department manager, and vice president.
          His consulting and training work has taken him all over North America
          as well as visits to South America, Europe, Australia and China.
          Charlie has a PhD in Computer Science from the University of Toronto and an MBA from Heriot-Watt University.
          He's good at making complex systems easy to understand. Or so he claims.
        </textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior Solutions Architect</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Tata Consultancy Services</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">charlie.hamu@tcs.com</textual></email></author><legalnotice class="po-container e19 e19"><para class="po-block e20 e20"><textual class="po-textual">Â© Copyright 2012, Tata Consultancy Services.</textual></para><para class="po-block e21 e21"><textual class="po-textual">Disclaimer: All views expressed in the publication are of the author and Tata Consultancy Services (TCS) does not warrant, either expressly or implied, the accuracy, appropriateness of the information in the publication. TCS disclaims any responsibility for content error, omissions and any responsibility associated with relying on the information provided in the publication.</textual></para></legalnotice><keywordset class="po-table e22 e22" role="author"><keyword class="po-field e23 e23"><textual class="po-textual">sample documents</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">sampling</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">big data</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">interoperability</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">quality</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">XSLT</textual></keyword><keyword class="po-field e29 e29"><textual class="po-textual">modelling</textual></keyword><keyword class="po-field e30 e30"><textual class="po-textual">querying</textual></keyword><keyword class="po-field e31 e31"><textual class="po-textual">software-based processing</textual></keyword><keyword class="po-field e32 e32"><textual class="po-textual">transforming</textual></keyword></keywordset></info><section class="po-hcontainer e33 e33"><title class="po-block e34 e34"><textual class="po-textual">
      Context
    </textual></title><para class="po-block e35 e35"><textual class="po-textual">
      Sample documents play a critical role in the development of most XML systems.
    </textual></para><para class="po-block e36 e36"><textual class="po-textual">
      But good sample documents are difficult to generate.
      There seem to be three basic approaches, each with its difficulties:
      </textual><orderedlist class="po-table e37 e37"><listitem class="po-container e38 e38"><para class="po-block e39 e39"><textual class="po-textual">
            </textual><emphasis class="po-inline e40 e40" role="bold"><textual class="po-textual">Craft.</textual></emphasis><textual class="po-textual">
            Artfully crafting sample documents by hand is usually a labor-intensive path
            to an artificial-feeling result.
            Hand-crafted samples can be especially frustrating when they go stale,
            when even minor schema changes necessitate significant rework.
          </textual></para></listitem><listitem class="po-container e41 e41"><para class="po-block e42 e42"><textual class="po-textual">
            </textual><citation class="po-atom e43 e43" linkend="Mad_Libs"><emphasis class="po-inline e44 e44" role="bold"><trademark class="po-null e45 e45"><textual class="po-textual">Mad Libs.</textual></trademark></emphasis></citation><textual class="po-textual">
            Automatically-generated samples are often so random and disconnected from reality
            that they are difficult for humans to comprehend and use.
            Based on all the possibilities of a schema, they include many combinations
            that simply would not occur in real life.
            The schema provides no guidance about the kinds of content
            that would make sense in each element, so contents are unfamiliar nonsense.
          </textual></para></listitem><listitem class="po-container e46 e46"><para class="po-block e47 e47"><textual class="po-textual">
            </textual><emphasis class="po-inline e48 e48" role="bold"><textual class="po-textual">Curation.</textual></emphasis><textual class="po-textual">
            Thoughtfully choosing some sample documents from a larger set of available documents
            is the approach most similar to the approach presented by this paper.
            The difficulty is that most XML corpora are like war:
            long stretches of boredom punctuated by moments of mildly increased interest.
            It's easy to miss those documents that have interesting, unusual markup.
            And it's easy to miss the interesting, unusual markup even within the documents chosen.
          </textual></para></listitem></orderedlist><textual class="po-textual">
    </textual></para><para class="po-block e49 e49"><textual class="po-textual">
      There is often a tension between brevity and completeness.
      It's easiest for a human to understand a shorter, simpler documents.
      Including more elements, in more contexts, requires longer, more complex documents.
    </textual></para></section><section class="po-hcontainer e50 e50"><title class="po-block e51 e51"><textual class="po-textual">
      Alternatives
    </textual></title><para class="po-block e52 e52"><textual class="po-textual">
      Before this paper was presented on Wednesday of the
      </textual><citation class="po-atom e53 e53" linkend="Balisage"><textual class="po-textual">Balisage conference,</textual></citation><textual class="po-textual">
      there was a discussion of approaches to creating sample documents
      at the preceding
      </textual><citation class="po-atom e54 e54" linkend="QA-QC"><textual class="po-textual">symposium on QA and QC</textual></citation><textual class="po-textual">
      on the Monday.
      The following alternatives were listed:
      </textual><itemizedlist class="po-table e55 e55"><listitem class="po-container e56 e56"><para class="po-block e57 e57"><textual class="po-textual">
            </textual><emphasis class="po-inline e58 e58" role="bold"><textual class="po-textual">Dale Waldt</textual></emphasis><textual class="po-textual">
            suggested starting with all XPaths
            (presumably FQGI, fully qualified generic identifier, ancestry paths) in a larger set,
            and finding an example of each.
          </textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">
            </textual><emphasis class="po-inline e61 e61" role="bold"><textual class="po-textual">Paul Ryan</textual></emphasis><textual class="po-textual">
            said he automated the extraction of all XPaths
            (again, presumably FQGIs) and automatically created Lorem Ipsum text.
          </textual></para></listitem><listitem class="po-container e62 e62"><para class="po-block e63 e63"><textual class="po-textual">
            </textual><emphasis class="po-inline e64 e64" role="bold"><textual class="po-textual">Murray Maloney</textual></emphasis><textual class="po-textual">
            spoke of running all variations, as determined by the possibilities allowed by the Schema.
          </textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">
            </textual><emphasis class="po-inline e67 e67" role="bold"><textual class="po-textual">John Cowan</textual></emphasis><textual class="po-textual">
            talked about how, with LexisNexis, it was easy to get a firehose blast of volumes of data.
            He talked about crafting a sample document that was actually true facts, though a constructed sample.
          </textual></para></listitem><listitem class="po-container e68 e68"><para class="po-block e69 e69"><textual class="po-textual">
            </textual><emphasis class="po-inline e70 e70" role="bold"><textual class="po-textual">Robert Stuart</textual></emphasis><textual class="po-textual">
            advised against real, or real-looking data,
            having once had an intelligence agency get upset with him
            when he to closely simulated, using public sources, the look of secret documents.
          </textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">
            </textual><emphasis class="po-inline e73 e73" role="bold"><textual class="po-textual">Syd Bauman</textual></emphasis><textual class="po-textual">
            said that when he needs a set of test documents to exercise a collection,
            he typically starts by cutting out the uninteresting TEI header metadata,
            and then keeping the first few paragraphs of each of several document.
            When he needs to generate test data about an instance
            he tends to need to be much pickier about which bits he keeps,
            and, in general, he does this by hand.
          </textual></para><para class="po-block e74 e74"><textual class="po-textual">
            For the cases where content could not be shared,
            Syd also mentioned that </textual><emphasis class="po-inline e75 e75" role="bold"><textual class="po-textual">Elliotte Rusty Harold</textual></emphasis><textual class="po-textual">
            had presented an XML Randomizer that worked like a neutron bomb on XML documents
            (my inappropriate analogy), scrambling the content but leaving the structures intact.
            </textual><citation class="po-atom e76 e76" linkend="Harold"><textual class="po-textual">[Harold]</textual></citation><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e77 e77"><para class="po-block e78 e78"><textual class="po-textual">
            </textual><emphasis class="po-inline e79 e79" role="bold"><textual class="po-textual">Debbie Lapeyre</textual></emphasis><textual class="po-textual">
            warned against taking the first ten pages,
            and relayed a anecdote in which the last thousand pages were very different
            from the first ten.
          </textual></para></listitem><listitem class="po-container e80 e80"><para class="po-block e81 e81"><textual class="po-textual">
            </textual><emphasis class="po-inline e82 e82" role="bold"><textual class="po-textual">Ian Gorman</textual></emphasis><textual class="po-textual">
            described taking all available content as the universe from which to choose.
            If I understood correctly, this is the approach automated by the current paper.
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e83 e83"><title class="po-block e84 e84"><textual class="po-textual">
      Goals
    </textual></title><para class="po-block e85 e85"><textual class="po-textual">
      The primary goal of this project is a tool to boil large sets of XML data
      down to smaller samples.
      The samples should maintain as much as possible of the variety and complexity
      of markup patterns, and remove as much as possible of the useless repetitions.
    </textual></para><para class="po-block e86 e86"><textual class="po-textual">
      Subsidiary design goals include:
      </textual><itemizedlist class="po-table e87 e87"><listitem class="po-container e88 e88"><para class="po-block e89 e89"><textual class="po-textual">
            </textual><emphasis class="po-inline e90 e90" role="bold"><textual class="po-textual">Plausible results.</textual></emphasis><textual class="po-textual">
            The hope is that the results will feel natural: compact, but recognizable.
          </textual></para></listitem><listitem class="po-container e91 e91"><para class="po-block e92 e92"><textual class="po-textual">
            </textual><emphasis class="po-inline e93 e93" role="bold"><textual class="po-textual">Good defaults.</textual></emphasis><textual class="po-textual">
            The default parameter settings should hit some kind of sweet spot.
            Is it presumptious to imagine that such a sweet spot exists?
            I imagine it to be something like this:
            one can say that the sample is
            </textual><quote class="po-inline e94 e94"><textual class="po-textual">complete</textual></quote><textual class="po-textual">
            and that at the same time it is manageably short.
          </textual></para></listitem><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">
            </textual><emphasis class="po-inline e97 e97" role="bold"><textual class="po-textual">Single dial.</textual></emphasis><textual class="po-textual">
            Given the trade-offs between brevity and completeness,
            it would be nice to have a single parameter that simultaneously adjusted
            all the other parameters towards one extreme or the other.
          </textual></para></listitem><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">
            </textual><emphasis class="po-inline e100 e100" role="bold"><textual class="po-textual">Ease over perfection.</textual></emphasis><textual class="po-textual">
            If the occassional result is invalid, because of a wrong guess
            about required elements, that's probably okay.
          </textual></para></listitem><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">
            </textual><emphasis class="po-inline e103 e103" role="bold"><textual class="po-textual">Use information from schema.</textual></emphasis><textual class="po-textual">
            If there is a schema available, it would be nice to take advantage of it.
            The goal would not to be to include elements only because they exist in the schema,
            but to avoid deleting elements that are required by the schema.
          </textual></para></listitem><listitem class="po-container e104 e104"><para class="po-block e105 e105"><textual class="po-textual">
            </textual><emphasis class="po-inline e106 e106" role="bold"><textual class="po-textual">Intuit schema.</textual></emphasis><textual class="po-textual">
            My guess is that in most real-life situations,
            required elements can be easily intuited.
            For example, if every
            </textual><code class="po-atom e107 e107"><textual class="po-textual">section</textual></code><textual class="po-textual">
            contains a
            </textual><code class="po-atom e108 e108"><textual class="po-textual">title,</textual></code><textual class="po-textual">
            it's reasonable to guess that
            </textual><code class="po-atom e109 e109"><textual class="po-textual">title</textual></code><textual class="po-textual">
            is required in
            </textual><code class="po-atom e110 e110"><textual class="po-textual">section.</textual></code><textual class="po-textual">
            Of course this rule of thumb can fail in one of two ways:
            </textual><orderedlist class="po-table e111 e111"><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">
                  </textual><emphasis class="po-inline e114 e114" role="bold"><textual class="po-textual">False positive.</textual></emphasis><textual class="po-textual">
                  It could be the case that every
                  </textual><code class="po-atom e115 e115"><textual class="po-textual">section</textual></code><textual class="po-textual">
                  in a sample contains a
                  </textual><code class="po-atom e116 e116"><textual class="po-textual">title,</textual></code><textual class="po-textual">
                  but only by chance. But even in this case, there's no denying that
                  a representative sample will contain a
                  </textual><code class="po-atom e117 e117"><textual class="po-textual">title</textual></code><textual class="po-textual">
                  for every
                  </textual><code class="po-atom e118 e118"><textual class="po-textual">section.</textual></code><textual class="po-textual">
                </textual></para></listitem><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">
                  </textual><emphasis class="po-inline e121 e121" role="bold"><textual class="po-textual">False negative.</textual></emphasis><textual class="po-textual">
                  It could be that the content model is more complicated, that
                  </textual><emphasis class="po-inline e122 e122" role="ital"><textual class="po-textual">either</textual></emphasis><textual class="po-textual">
                  </textual><code class="po-atom e123 e123"><textual class="po-textual">number</textual></code><textual class="po-textual">
                  or
                  </textual><code class="po-atom e124 e124"><textual class="po-textual">title</textual></code><textual class="po-textual">
                  is required on every
                  </textual><code class="po-atom e125 e125"><textual class="po-textual">section.</textual></code><textual class="po-textual">
                  As a result, the intuition will fail, and conclude
                  </textual><emphasis class="po-inline e126 e126" role="ital"><textual class="po-textual">both</textual></emphasis><textual class="po-textual">
                  </textual><code class="po-atom e127 e127"><textual class="po-textual">number</textual></code><textual class="po-textual">
                  and
                  </textual><code class="po-atom e128 e128"><textual class="po-textual">title</textual></code><textual class="po-textual">
                  to be optional.
                  I haven't had enough real-life experience with the tool yet
                  to conclude how much trouble this will create.
                </textual></para></listitem></orderedlist><textual class="po-textual">
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e129 e129"><title class="po-block e130 e130"><textual class="po-textual">
      Algorithm
    </textual></title><para class="po-block e131 e131"><textual class="po-textual">
      The algorithm, as implemented, involves multiple passes:
      </textual><orderedlist class="po-table e132 e132"><listitem class="po-container e133 e133"><para class="po-block e134 e134"><textual class="po-textual">
            </textual><emphasis class="po-inline e135 e135" role="bold"><textual class="po-textual">Annotate with signatures.</textual></emphasis><textual class="po-textual">
            This present implementation uses an attribute in a special namespace,
            </textual><code class="po-atom e136 e136"><textual class="po-textual">tcs:signature</textual></code><textual class="po-textual">
            to record the characteristics we're using to determine
            what counts as the same and what counts as different.
            This is configurable, and includes some combination of ancestry,
            previous siblings, element name, attributes specified and child elements.
          </textual></para><para class="po-block e137 e137"><textual class="po-textual">
            Because of the choice to use an attribute,
            it's easiest to annotate only elements,
            not attributes, processing-instructions or comments.
            In an attempt to increase efficiency, a signature-to-element key was introduced.
            This introduced the possibility of using the same key mechanism
            to annotate attributes, processing instructions and comments.
          </textual></para><para class="po-block e138 e138"><textual class="po-textual">
            The current implementation uses this first pass to shorten the text nodes.
            The reasoning is that there will be less text passing through the subsequent passes.
            This is really for ease of debugging: it actually seems to slow the process.
          </textual></para></listitem><listitem class="po-container e139 e139"><para class="po-block e140 e140"><textual class="po-textual">
            </textual><emphasis class="po-inline e141 e141" role="bold"><textual class="po-textual">Mark unique elements.</textual></emphasis><textual class="po-textual">
            The next pass is to indicate a small number of each signature to keep.
            As implemented the first one (or two or more ... configurable)
            of each unique-signature element is kept,
            but there's no requirement that the first elements be kept.
          </textual></para></listitem><listitem class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">
            </textual><emphasis class="po-inline e144 e144" role="bold"><textual class="po-textual">Mark wrapping elements.</textual></emphasis><textual class="po-textual">
            If an element is to be kept, obviously all its ancestor elements must be kept.
            The current implementation marks these ancestors in a separate pass.
          </textual></para></listitem><listitem class="po-container e145 e145"><para class="po-block e146 e146"><textual class="po-textual">
            </textual><emphasis class="po-inline e147 e147" role="bold"><textual class="po-textual">Mark required children.</textual></emphasis><textual class="po-textual">
            For all the elements that are to be kept,
            certain child elements need to be kept, as they are required ...
            or guessed to be.
          </textual></para><para class="po-block e148 e148"><textual class="po-textual">
            In addition, this is a good time to mark inline elements
            mixed in with the text of the elements that are being kept.
            The reason for doing this is to maintain the sense of the retained text.
            If not, it's likely we'll lose
            the second and subsequent emphasized words in a sentence.
          </textual></para></listitem><listitem class="po-container e149 e149"><para class="po-block e150 e150"><textual class="po-textual">
            </textual><emphasis class="po-inline e151 e151" role="bold"><textual class="po-textual">Prune unneeded elements.</textual></emphasis><textual class="po-textual">
            The final pass removes those elements that haven't been marked to be kept.
            The current implementation keeps all atrributes
            and also text, processing instruction and comment children of kept elements.
          </textual></para></listitem></orderedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e152 e152"><title class="po-block e153 e153"><textual class="po-textual">
      Efficiency
    </textual></title><para class="po-block e154 e154"><textual class="po-textual">
      In the course of developing the current implementation,
      several efficiency issues were encountered.
      Not all have yet been resolved.
      </textual><itemizedlist class="po-table e155 e155"><listitem class="po-container e156 e156"><para class="po-block e157 e157"><textual class="po-textual">
            </textual><emphasis class="po-inline e158 e158" role="bold"><textual class="po-textual">Regex text trimming.</textual></emphasis><textual class="po-textual">
            The current implementation keeps the first few words and the last few words
            of each text node. The regular expression processing to acheive this appears
            to be slow. My guess is that it has to do with backtracking, and might be
            improved by simply taking the first few words and not looking to keep the last.
          </textual></para></listitem><listitem class="po-container e159 e159"><para class="po-block e160 e160"><textual class="po-textual">
            </textual><emphasis class="po-inline e161 e161" role="bold"><textual class="po-textual">Best time to trim text.</textual></emphasis><textual class="po-textual">
            In the naÃ¯ve expectation that reducing the amount of text
            to be processed by subsequent passes would be an efficiency gain,
            the first pass does the trimming of the text nodes.
            But only a small number of text nodes are retained in the end,
            so it turns out to be more efficient to prune the tree first
            before abbreviating the text nodes.
          </textual></para><para class="po-block e162 e162"><textual class="po-textual">
            The truth is that the most useful results might come from untrimmed text.
          </textual></para></listitem><listitem class="po-container e163 e163"><para class="po-block e164 e164"><textual class="po-textual">
            </textual><emphasis class="po-inline e165 e165" role="bold"><textual class="po-textual">N-squared comparison to previous elements.</textual></emphasis><textual class="po-textual">
            Unlike text trimming, which isn't essential to the process,
            finding unique signatures is the purpose of the script, so it can't be skipped.
            The first implementation of the script used a comparison of the current
            </textual><code class="po-atom e166 e166"><textual class="po-textual">tcs:signature</textual></code><textual class="po-textual">
            with all the
            </textual><code class="po-atom e167 e167"><textual class="po-textual">tcs:signatures</textual></code><textual class="po-textual">
            on the with
            </textual><code class="po-atom e168 e168"><textual class="po-textual">preceding</textual></code><textual class="po-textual">
            axis.
            This obviously introduces an order
            </textual><emphasis class="po-inline e169 e169" role="ital"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">
            </textual><superscript class="po-atom e170 e170"><textual class="po-textual">2</textual></superscript><textual class="po-textual">
            inefficiency.
            The second attempt involved using a
            </textual><code class="po-atom e171 e171"><textual class="po-textual">key</textual></code><textual class="po-textual">
            to map signatures to elements,
            and an
            </textual><code class="po-atom e172 e172"><textual class="po-textual">intersect</textual></code><textual class="po-textual">
            to detect if the set of similar signatures
            includes elements that overlap with the
            </textual><code class="po-atom e173 e173"><textual class="po-textual">preceding</textual></code><textual class="po-textual">
            axis.
            This is someone more efficient, but on the same order.
          </textual></para><para class="po-block e174 e174"><textual class="po-textual">
            In order to work with large data sets, this needs to be resolved.
            The current solution is to use a non-XSLT streaming pass.
            The current implementation is not XML-aware, programmed using Perl regular expressions.
            It could be done using a streaming XML parser,
            but unless there are
            </textual><code class="po-atom e175 e175"><textual class="po-textual">tcs:signature</textual></code><textual class="po-textual">
            attributes that aren't actually markup in the documents, there will be no problem.
          </textual></para></listitem><listitem class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual">
            </textual><emphasis class="po-inline e178 e178" role="bold"><textual class="po-textual">Multiple passes vs complicated XPath.</textual></emphasis><textual class="po-textual">
            The current implementation consists of several passes as outlined above.
            In order to accommodate a non-XSLT streaming pass in the middle,
            the first pass is in a separate script from the last passes.
            It's almost certainly the case that several of these calculations
            could be strung together in a more complicated XPath expression.
            This might be easier to understand, or not.
            And it might be more efficient, or not.
            I imagine it might be elegant, in a way.
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e179 e179"><title class="po-block e180 e180"><textual class="po-textual">
      Parameters
    </textual></title><para class="po-block e181 e181"><textual class="po-textual">
      The following parameters have been implemented:
      </textual><itemizedlist class="po-table e182 e182"><listitem class="po-container e183 e183"><para class="po-block e184 e184"><textual class="po-textual">
            </textual><emphasis class="po-inline e185 e185" role="bold"><textual class="po-textual">Ancestor count.</textual></emphasis><textual class="po-textual">
            How much context should be included in an element's signature?
            Measured on a scale of zero to infinity, with 0 representing no ancestry,
            1 representing the the parent of the current element,
            2 representing the grandparent and parent,
            7 presumed to be the largest number ever needed short of
            8 which is taken to represent infinity (at a ninety-degree angle).
            Infinity seems to be a good default,
            as some XML processing operates on fully-qualified generic identifiers.
            Also, it's common for deeply nested elements have a tendency
            to stress stylesheets and other processing.
          </textual></para></listitem><listitem class="po-container e186 e186"><para class="po-block e187 e187"><textual class="po-textual">
            </textual><emphasis class="po-inline e188 e188" role="bold"><textual class="po-textual">Preceding-sibling count.</textual></emphasis><textual class="po-textual">
            How many preceding siblings should be included in an element's signature?
            A good default seems to be 1, looking only at the closest preceding sibling.
          </textual></para></listitem><listitem class="po-container e189 e189"><para class="po-block e190 e190"><textual class="po-textual">
            </textual><emphasis class="po-inline e191 e191" role="bold"><textual class="po-textual">Self count.</textual></emphasis><textual class="po-textual">
            Should the element name itself be include in its own signature?
            Surely the answer should be yes in most applications.
            For consistency, this parameter is included, on a scale from 0 (no) to 1 (yes).
          </textual></para></listitem><listitem class="po-container e192 e192"><para class="po-block e193 e193"><textual class="po-textual">
            </textual><emphasis class="po-inline e194 e194" role="bold"><textual class="po-textual">Attribute count.</textual></emphasis><textual class="po-textual">
            Should the element's specified attributes count as part of its signature?
            Measured on a scale of 0 (no) to 8 (all of them),
            with no sensible meaning for the numbers in between.
            The current script has a bug in that it doesn't sort the attribute names as it should.
            A good default seems to be to include the attributes names.
          </textual></para></listitem><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">
            </textual><emphasis class="po-inline e197 e197" role="bold"><textual class="po-textual">Child count.</textual></emphasis><textual class="po-textual">
            How many children should be included an element's signature?
            Again, this parameter is measured on a scale of 0 = none to 8 = infinity.
            The children are counted out in document order.
            The thought here is to distinguish between a
            </textual><code class="po-atom e198 e198"><textual class="po-textual">section</textual></code><textual class="po-textual">
            that starts with a
            </textual><code class="po-atom e199 e199"><textual class="po-textual">number</textual></code><textual class="po-textual">
            from a
            </textual><code class="po-atom e200 e200"><textual class="po-textual">section</textual></code><textual class="po-textual">
            that starts with a
            </textual><code class="po-atom e201 e201"><textual class="po-textual">title.</textual></code><textual class="po-textual">
            An overlapping effect can sometimes also be achieved by using using the preceding-sibling parameter:
            including a
            </textual><code class="po-atom e202 e202"><textual class="po-textual">section</textual></code><textual class="po-textual">
            not on its own merits,
            but because it contains a
            </textual><code class="po-atom e203 e203"><textual class="po-textual">title</textual></code><textual class="po-textual">
            that follows a
            </textual><code class="po-atom e204 e204"><textual class="po-textual">number.</textual></code><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">
            </textual><emphasis class="po-inline e207 e207" role="bold"><textual class="po-textual">Start words count.</textual></emphasis><textual class="po-textual">
            How many words should kept at the start when abbreviating a text node?
          </textual></para></listitem><listitem class="po-container e208 e208"><para class="po-block e209 e209"><textual class="po-textual">
            </textual><emphasis class="po-inline e210 e210" role="bold"><textual class="po-textual">Middle words count.</textual></emphasis><textual class="po-textual">
            What is the minimum number of words to delete from the middle of a text node?
            If there are less than this number of words in the middle, don't abbreviate.
          </textual></para></listitem><listitem class="po-container e211 e211"><para class="po-block e212 e212"><textual class="po-textual">
            </textual><emphasis class="po-inline e213 e213" role="bold"><textual class="po-textual">End words count.</textual></emphasis><textual class="po-textual">
            How many words should be kept at the end when abbreviating a text node?
            So, a text node is not abbreviated unless it contains start + middle + end words.
            Though these parameters are still available in the full code,
            more readable results are found more efficiently by simply taking the first
            </textual><quote class="po-inline e214 e214"><textual class="po-textual">sentence</textual></quote><textual class="po-textual">
            of each text node.
            This is the approach taken in the simplified code below.
          </textual></para></listitem><listitem class="po-container e215 e215"><para class="po-block e216 e216"><textual class="po-textual">
            </textual><emphasis class="po-inline e217 e217" role="bold"><textual class="po-textual">Repetition count.</textual></emphasis><textual class="po-textual">
            How many times would we like to see each signature?
            Since we may want to reduce a very large corpus to a still large sample,
            it doesn't make sense to follow the silly pattern of the other parameters,
            insisting that after 7 comes infinity.
            One discovery, working with the tool,
            is that the most effective way to get a bulkier sample
            is to include higher values for the various context parameters.
            This way, in addition to being simply bulkier,
            the extra included elements will show more variety.
            For this reason, the chosen default value is 1.
          </textual></para></listitem><listitem class="po-container e218 e218"><para class="po-block e219 e219"><textual class="po-textual">
            </textual><emphasis class="po-inline e220 e220" role="bold"><textual class="po-textual">Show deletions.</textual></emphasis><textual class="po-textual">
            Should comments be left in the sample to indicate where elements have been pruned?
            It can be helpful, when working with a smaller sample,
            to have indication of where elements have been deleted from the larger source.
            As implemented, the integer parameter is interpreted as a Boolean.
            But it might make sense to interpret as a number:
            showing some number of comments before stopping.
            To avoid overwhelming results, the default value is 0 = no.
          </textual></para></listitem><listitem class="po-container e221 e221"><para class="po-block e222 e222"><textual class="po-textual">
            </textual><emphasis class="po-inline e223 e223" role="bold"><textual class="po-textual">Debug signatures.</textual></emphasis><textual class="po-textual">
            Should the intermediate element signatures be shown in the final output?
            Like with the parameters above and below,
            it would make sense to interpret this value as a integer,
            rather than as a Boolean.
            The default value here is 0, meaning no
            </textual><code class="po-atom e224 e224"><textual class="po-textual">tcs:signatures</textual></code><textual class="po-textual">
            are shown.
          </textual></para></listitem><listitem class="po-container e225 e225"><para class="po-block e226 e226"><textual class="po-textual">
            </textual><emphasis class="po-inline e227 e227" role="bold"><textual class="po-textual">Debug marks.</textual></emphasis><textual class="po-textual">
            Should the intermediate
            </textual><code class="po-atom e228 e228"><textual class="po-textual">tcs:mark</textual></code><textual class="po-textual">
            attributes be shown?
            Again, this integer parameter might make better sense interpreted as a count,
            rather than interpreted as a Boolean.
            The
            </textual><code class="po-atom e229 e229"><textual class="po-textual">tcs:mark</textual></code><textual class="po-textual">
            attributes are added to all elements that are to be kept,
            with the value indicating the reason.
            Reasons include that the element had a unique signature
            (or was within the specified repetition count),
            that the element had a descendent that was to be kept,
            that the element was known or guessed to be a required child of a kept element,
            or that the element was an textual inline in the middle of kept text.
            The default value is 0, meaning no intermediate
            </textual><code class="po-atom e230 e230"><textual class="po-textual">tcs:mark</textual></code><textual class="po-textual">
            attributes are shown.
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e231 e231"><textual class="po-textual">
      The following parameters have been designed, but not yet implemented:
      </textual><itemizedlist class="po-table e232 e232"><listitem class="po-container e233 e233"><para class="po-block e234 e234"><textual class="po-textual">
            </textual><emphasis class="po-inline e235 e235" role="bold"><textual class="po-textual">Collapse parallel structures.</textual></emphasis><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e236 e236"><para class="po-block e237 e237"><textual class="po-textual">
            </textual><emphasis class="po-inline e238 e238" role="bold"><textual class="po-textual">Target length.</textual></emphasis><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e239 e239"><para class="po-block e240 e240"><textual class="po-textual">
            </textual><emphasis class="po-inline e241 e241" role="bold"><textual class="po-textual">Schema information.</textual></emphasis><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">
            </textual><emphasis class="po-inline e244 e244" role="bold"><textual class="po-textual">Text abbreviation.</textual></emphasis><textual class="po-textual">
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e245 e245"><title class="po-block e246 e246"><textual class="po-textual">
      Code
    </textual></title><para class="po-block e247 e247"><textual class="po-textual">
      To illustrate the key concepts, a reference implementation is presented here.
      This version of the script is stripped of comments, parameters and efficiencies.
      Please contact the author for the current revision of the full script.
      </textual><programlisting class="po-block e248 e248" xml:space="preserve"><textual class="po-textual">
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!-- TCS = Tata Consultancy Services; tcs = trash compactor script. --&gt;
&lt;!-- For brevity, this version is missing comments, parameters and efficiencies. --&gt;
&lt;transform xmlns='http://www.w3.org/1999/XSL/Transform' version='2.0'
           xmlns:xs='http://www.w3.org/2001/XMLSchema'
           xmlns:tcs='mailto:charlie.hamu@tcs.com'&gt;
    &lt;template match='/'&gt;
        &lt;variable name='signed'&gt;
            &lt;apply-templates select='node()' mode='sign' /&gt;
        &lt;/variable&gt;
        &lt;variable name='marked'&gt;
            &lt;apply-templates select='$signed' mode='mark' /&gt;
        &lt;/variable&gt;
        &lt;variable name='wrapped'&gt;
            &lt;apply-templates select='$marked' mode='wrap' /&gt;
        &lt;/variable&gt;
        &lt;variable name='needed'&gt;
            &lt;apply-templates select='$wrapped' mode='need' /&gt;
        &lt;/variable&gt;
        &lt;variable name='needed-2'&gt;
            &lt;apply-templates select='$needed' mode='need' /&gt;
        &lt;/variable&gt;
        &lt;variable name='wanted'&gt;
            &lt;apply-templates select='$needed-2' mode='want' /&gt;
        &lt;/variable&gt;
        &lt;variable name='pruned'&gt;
            &lt;apply-templates select='$wanted' mode='prune' /&gt;
        &lt;/variable&gt;
        &lt;sequence select='$pruned' /&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='sign'&gt;
        &lt;copy&gt;
            &lt;attribute name='tcs:signature' select='ancestor::*/name(),
                                                    preceding-sibling::*[1]/name(),
                                                    name(),
                                                    @*/name(),
                                                    *[1]/name()' /&gt;
            &lt;copy-of select='@*' /&gt;
            &lt;apply-templates select='node()' mode='sign' /&gt;
        &lt;/copy&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='mark'&gt;
        &lt;copy&gt;
            &lt;if test='not(preceding::*[@tcs:signature = current()/@tcs:signature])'&gt;
                &lt;attribute name='tcs:mark' select='"keep"' /&gt;
            &lt;/if&gt;
            &lt;copy-of select='@*' /&gt;
            &lt;apply-templates select='node()' mode='mark' /&gt;
        &lt;/copy&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='wrap'&gt;
        &lt;copy&gt;
            &lt;if test='not(@tcs:mark) and *//@tcs:mark'&gt;
                &lt;attribute name='tcs:mark' select='"wrap"' /&gt;
            &lt;/if&gt;
            &lt;copy-of select='@*' /&gt;
            &lt;apply-templates select='node()' mode='wrap' /&gt;
        &lt;/copy&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='want'&gt;
        &lt;copy&gt;
            &lt;copy-of select='@*' /&gt;
            &lt;if test='not(@tcs:mark) and ../@tcs:mark
                      and text()[normalize-space() ne ""]
                      and ../text()[normalize-space() ne ""]'&gt;
                &lt;attribute name='tcs:mark' select='"want"' /&gt;
            &lt;/if&gt;
            &lt;apply-templates select='node()' mode='want' /&gt;
        &lt;/copy&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='need'&gt;
        &lt;copy&gt;
            &lt;if test='not(@tcs:mark)
                      and ../@tcs:mark
                      and not(preceding-sibling::*[name() eq current()/name()])
                      and not(//*[name() eq current()/../name()
                                  and not(*[name() eq current()/name()])])'&gt;
                &lt;attribute name='tcs:mark' select='"need"' /&gt;
            &lt;/if&gt;
            &lt;copy-of select='@*' /&gt;
            &lt;apply-templates select='node()' mode='need' /&gt;
        &lt;/copy&gt;
    &lt;/template&gt;
    &lt;template match='*' mode='prune'&gt;
        &lt;if test='@tcs:mark'&gt;
            &lt;copy&gt;
                &lt;copy-of select='@* except @tcs:*' /&gt;
                &lt;apply-templates select='node()' mode='prune' /&gt;
            &lt;/copy&gt;
        &lt;/if&gt;
    &lt;/template&gt;
    &lt;template match='text()' mode='prune'&gt;
        &lt;value-of select='replace(.,"\.\s.+","...","s")' /&gt;
    &lt;/template&gt;
    &lt;template match='comment() | processing-instruction()' mode='#all'&gt;
        &lt;copy /&gt;
    &lt;/template&gt;
&lt;/transform&gt;</textual></programlisting><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e249 e249"><title class="po-block e250 e250"><textual class="po-textual">
      Discussion
    </textual></title><para class="po-block e251 e251"><textual class="po-textual">
      This paper was presented at Balisage 2012.
      </textual><citation class="po-atom e252 e252" linkend="Balisage"><textual class="po-textual">[Balisage]</textual></citation><textual class="po-textual">
      In the discussion after, the following points were raised by attendees.
      </textual><itemizedlist class="po-table e253 e253"><listitem class="po-container e254 e254"><para class="po-block e255 e255"><textual class="po-textual">
            </textual><emphasis class="po-inline e256 e256" role="bold"><textual class="po-textual">Pointers.</textual></emphasis><textual class="po-textual">
            It would be nice to link the samples, element-by-element, back to the full corpus,
            so that you could see the full context if curious.
          </textual></para></listitem><listitem class="po-container e257 e257"><para class="po-block e258 e258"><textual class="po-textual">
            </textual><emphasis class="po-inline e259 e259" role="bold"><textual class="po-textual">Randomize.</textual></emphasis><textual class="po-textual">
            Liam Quinn suggested that if you are taking a small sample from a larger set,
            it would be nice to be be able to randomize the selection,
            rather than just taking the first examples of each markup combination.
          </textual></para></listitem><listitem class="po-container e260 e260"><para class="po-block e261 e261"><textual class="po-textual">
            </textual><emphasis class="po-inline e262 e262" role="bold"><textual class="po-textual">Log the seed.</textual></emphasis><textual class="po-textual">
            As a follow-on suggestion, Lee says to log the seed used for the random selection,
            so that it can be recreated as required.
          </textual></para></listitem><listitem class="po-container e263 e263"><para class="po-block e264 e264"><textual class="po-textual">
            </textual><emphasis class="po-inline e265 e265" role="bold"><textual class="po-textual">Redo from back.</textual></emphasis><textual class="po-textual">
            Wendell Piez observed that in order to avoid redundant elements,
            in which for example, the first paragraph is included because we've never seen a paragraph before,
            but the second paragraph is included because it contains an inline,
            we can run the algorithm twice: once front to back and then a second time back to front.
          </textual></para></listitem><listitem class="po-container e266 e266"><para class="po-block e267 e267"><textual class="po-textual">
            </textual><emphasis class="po-inline e268 e268" role="bold"><textual class="po-textual">XQuery.</textual></emphasis><textual class="po-textual">
            There seemed to be general consensus that multiple passes were the natural approach,
            and that any attempt to collapse this into a single XPath expression or XQuery was misguided.
          </textual></para></listitem><listitem class="po-container e269 e269"><para class="po-block e270 e270"><textual class="po-textual">
            </textual><emphasis class="po-inline e271 e271" role="bold"><textual class="po-textual">Xmlsh.</textual></emphasis><textual class="po-textual">
            David Lee said the individual passes could be run together with xmlsh.
            This would be especially relevant if the inefficient have-I-seen-this-before pass
            were recast using another programming language.
          </textual></para></listitem><listitem class="po-container e272 e272"><para class="po-block e273 e273"><textual class="po-textual">
            </textual><emphasis class="po-inline e274 e274" role="bold"><textual class="po-textual">Efficiency.</textual></emphasis><textual class="po-textual">
            Michael Sperberg-McQueen said that the
            </textual><emphasis class="po-inline e275 e275" role="ital"><textual class="po-textual">n</textual></emphasis><superscript class="po-atom e276 e276"><textual class="po-textual">2</textual></superscript><textual class="po-textual">
            inefficiency could be solved, even in XSLT 1.0, using keys and Muenchian method. </textual><citation class="po-atom e277 e277" linkend="Tennison"><textual class="po-textual">[Tennison]</textual></citation><textual class="po-textual">
          </textual></para></listitem><listitem class="po-container e278 e278"><para class="po-block e279 e279"><textual class="po-textual">
            </textual><emphasis class="po-inline e280 e280" role="bold"><textual class="po-textual">Accummulators.</textual></emphasis><textual class="po-textual">
            Abel Braaksma said that XSLT 3.0 accumulators were designed to solve problems
            just like the have-I-seen-this-before inefficiency, and took the example back to the XSLT working group.
          </textual></para><para class="po-block e281 e281"><textual class="po-textual">
            My initial intuition was to add the current element's signature to the accumulated set
            as the element starts. But this is too soon, as we need to know about all preceding elements,
            not including the one we're on. On the other had, updating the accumulator at the end of the element
            would be too late, as we would not have had its signature as we reviewed all of its descendants.
            The naive fix would be to somehow put the current element's signature
            </textual><quote class="po-inline e282 e282"><textual class="po-textual">on deck</textual></quote><textual class="po-textual">
            so that it can be folded in to the accumulated list of all signatures
            as soon we hit the start of the next element.
            Rather than building this data structure ourselves,
            the elegant choice seems to be to avoid the temptation
            to add the
            </textual><emphasis class="po-inline e283 e283" role="ital"><textual class="po-textual">current</textual></emphasis><textual class="po-textual">
            element's signature to the accumulated set,
            but to rather add the
            </textual><emphasis class="po-inline e284 e284" role="ital"><textual class="po-textual">immediately preceding</textual></emphasis><textual class="po-textual">
            element's signature to the accumulator.
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><bibliography class="po-hcontainer e285 e285"><title class="po-block e286 e286"><textual class="po-textual">
      References
    </textual></title><bibliomixed class="po-block e287 e287" xml:id="Balisage"><textual class="po-textual">
      </textual><emphasis class="po-inline e288 e288" role="ital"><textual class="po-textual">Balisage: The Markup Conference,</textual></emphasis><textual class="po-textual">
      2012 August 7-10, Hotel Europa, Montreal, Canada,
      </textual><link class="po-inline e289 e289" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol8/contents.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://balisage.net/Proceedings/vol8/contents.html</textual></link><textual class="po-textual">
      (accessed 2012 August 17).
    </textual></bibliomixed><bibliomixed class="po-block e290 e290" xml:id="Harold"><textual class="po-textual">
      Harold, Elliote Rusty.
      Paper:
      </textual><quote class="po-inline e291 e291"><textual class="po-textual">Obsuring XML,</textual></quote><textual class="po-textual">
      </textual><emphasis class="po-inline e292 e292" role="ital"><textual class="po-textual">Proceedings of Extreme Markup Languages</textual></emphasis><textual class="po-textual">
      2005 August 1-5, Montreal, Canada.
      </textual><link class="po-inline e293 e293" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2005/Harold01/EML2005Harold01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2005/Harold01/EML2005Harold01.html</textual></link><textual class="po-textual">
      Presentation:
      </textual><quote class="po-inline e294 e294"><textual class="po-textual">Randomizing XML,</textual></quote><textual class="po-textual">
      </textual><link class="po-inline e295 e295" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/slides/extreme/randomizer/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://cafeconleche.org/slides/extreme/randomizer</textual></link><textual class="po-textual">
      (accessed 2012 August 20).
    </textual></bibliomixed><bibliomixed class="po-block e296 e296" xml:id="Mad_Libs"><textual class="po-textual">
      Penguin Group (USA).
      </textual><quote class="po-inline e297 e297"><textual class="po-textual">Mad Libs,</textual></quote><textual class="po-textual">
      </textual><link class="po-inline e298 e298" xlink:actuate="onRequest" xlink:href="http://www.madlibs.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://madlibs.com</textual></link><textual class="po-textual">
      (Accessed 2012 August 20).
    </textual></bibliomixed><bibliomixed class="po-block e299 e299" xml:id="QA-QC"><textual class="po-textual">
      </textual><emphasis class="po-inline e300 e300" role="ital"><textual class="po-textual">International Symposium on Quality Assurance and Quality Control in XML,</textual></emphasis><textual class="po-textual">
      2012 August 6, Hotel Europa, Montreal, Canada,
      </textual><link class="po-inline e301 e301" xlink:actuate="onRequest" xlink:href="http://balisage.net/QA-QC" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://balisage.net/QA-QC</textual></link><textual class="po-textual">
      (accessed 2012 August 17).
    </textual></bibliomixed><bibliomixed class="po-block e302 e302" xml:id="Tennison"><textual class="po-textual">
      Tennison, Jeni.
      </textual><quote class="po-inline e303 e303"><textual class="po-textual">Grouping using the Muenchian Method,</textual></quote><textual class="po-textual">
      </textual><link class="po-inline e304 e304" xlink:actuate="onRequest" xlink:href="http://jenitennison.com/xslt/grouping/muenchian.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jenitennison.com/xslt/grouping/muenchian.html</textual></link><textual class="po-textual">
      (accessed 2012 August 17).
    </textual></bibliomixed></bibliography></article></classedDocument>