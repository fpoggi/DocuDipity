<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">XTemp: Event-driven Testing and Monitoring of Business processes</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Leveraging XML, XPath and XSLT for a Practical Event Processing</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2011</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 2 - 5, 2011</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">XML has proved to be a scalable archival format for messages of various kinds (e.g. email with MarkMail). It is also increasingly used as format of choice for several event models and taxonomies (XES, OASIS/SAF, CEE, XDAS) that need be both processable and human readable. As many eBusiness processes are also relying on XML for message content and/or protocol, there is a need to monitor and validate the messages and documents being exchanged as well as their sequences. XTemp is an XML vocabulary and execution language that is event-centric and intended for the analysis of sequence of events that represent traces of business processes. It is designed for both log analysis and real-time execution. It leverages XPath and XSLT.</textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Jacques</textual></firstname><surname class="po-field e12 e12"><textual class="po-textual">Durand</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Jacques Durand is software architect at Fujitsu America, Inc. with a long-time involvement in XML standard organizations. He has extensive experience in XML-related testing, is chair of the Test Assertions Guideline OASIS committee and of the Testing and Monitoring of Internet Exchanges (TaMIE) committee in OASIS, where he is also member of the Technical Advisory Board. He has been leading testing activities for years in the WS-Interoperability consortium and in the ebXML technical committee, while contributing to XML user consortiums such as RosettaNet, OAGI.Prior to this he was a development lead in a Business Process Management company for 5 years. He earned a Ph.D. in rule-based systems and logic-programming from Nancy Univ., France.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior architect, R and D dir.</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Fujitsu America, Inc.</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">jdurand@us.fujitsu.com</textual></email></author><author class="po-record e19 e19"><personname class="po-record e20 e20"><firstname class="po-field e21 e21"><textual class="po-textual">Hyunbo</textual></firstname><surname class="po-field e22 e22"><textual class="po-textual">Cho</textual></surname></personname><personblurb class="po-container e23 e23"><para class="po-block e24 e24"><textual class="po-textual">Hyunbo Cho is a professor in the department of industrial and management engineering at the Pohang University of Science and Technology, South Korea. He received his B.S. and M.S. degrees in Industrial Engineering from Seoul National University in 1986 and 1988, respectively, and his Ph.D. in Industrial Engineering with a specialization in Manufacturing Systems Engineering from Texas A and M University in 1993. He was a recipient of the SME 1997 Outstanding Young Manufacturing Engineer Award. His areas of expertise include B2B integration, Testing and monitoring of B2B solutions, and Supply chain management. He is co-chair of the Testing and Monitoring of Internet Exchanges (TaMIE) committee in OASIS.</textual></para></personblurb><affiliation class="po-record e25 e25"><jobtitle class="po-field e26 e26"><textual class="po-textual">Professor</textual></jobtitle><orgname class="po-block e27 e27"><textual class="po-textual">Pohang University of Science and Technology</textual></orgname></affiliation><email class="po-field e28 e28"><textual class="po-textual">hcho@postech.ac.kr</textual></email></author><author class="po-record e29 e29"><personname class="po-record e30 e30"><firstname class="po-field e31 e31"><textual class="po-textual">Dale</textual></firstname><surname class="po-field e32 e32"><textual class="po-textual">Moberg</textual></surname></personname><personblurb class="po-container e33 e33"><para class="po-block e34 e34"><textual class="po-textual">Dale Moberg has been involved in defining or enabling reliable, secure systems for business collaboration since 1993. He has worked in product development, architecture, strategy, and research. Many of his activities have been concerned with integrating security standards for B2B such as digital signatures for nonrepudiation of origin and nonrepudiation of receipt. He has chaired or co-chaired ebXML TCs in OASIS working on eBusiness transactions choreography and agreements. He currently works on designs and functional requirements for products in areas of application integration, B2B gateways, business activity monitoring, and business intelligence. He holds a M.A. and Ph.D from Northwestern University, and a M.S. from Ohio State University and has worked in academic and commercial organizations.</textual></para></personblurb><affiliation class="po-record e35 e35"><jobtitle class="po-field e36 e36"><textual class="po-textual">Senior Scientist</textual></jobtitle><orgname class="po-block e37 e37"><textual class="po-textual">Axway</textual></orgname></affiliation><email class="po-field e38 e38"><textual class="po-textual">dmoberg@axway.com</textual></email></author><author class="po-record e39 e39"><personname class="po-record e40 e40"><firstname class="po-field e41 e41"><textual class="po-textual">Jungyub</textual></firstname><surname class="po-field e42 e42"><textual class="po-textual">Woo</textual></surname></personname><personblurb class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Jungyub Woo is a researcher at the Software and System Division of the National Institute of Standards and Technology (NIST), the technology laboratory of the US Department of Commerce.  He received his B.S. and M.S. degrees in Industrial Engineering from Postech (Pohang University of Science and Technology) in 2001 and 2003, respectively, and his Ph.D. in Industrial Engineering with a specialization in Manufacturing Systems Engineering from Postech (Pohang University of Science and Technology) in 2007. Dr. Woo has spearheaded development of the Business-to-Business test bed at NIST, which has been used by a number of industry and standards development organizations. Also he is researching for the Health Level Seven International (HL7) interoperability. His areas of expertise include Supply Chain Management, Manufacturing Management and Strategy, and Semantic Web.</textual></para></personblurb><affiliation class="po-record e45 e45"><jobtitle class="po-field e46 e46"><textual class="po-textual">Researcher</textual></jobtitle><orgname class="po-block e47 e47"><textual class="po-textual">National Institute of Standards and Technology (NIST)</textual></orgname></affiliation><email class="po-field e48 e48"><textual class="po-textual">jungyub.woo@nist.gov</textual></email></author><legalnotice class="po-container e49 e49"><para class="po-block e50 e50"><textual class="po-textual">Copyright © Fujitsu America, Inc., Pohang University, Axway, NIST: Used by permission.</textual></para></legalnotice><keywordset class="po-table e51 e51" role="author"><keyword class="po-field e52 e52"><textual class="po-textual">Document Testing</textual></keyword><keyword class="po-field e53 e53"><textual class="po-textual">Test Assertion</textual></keyword></keywordset></info><section class="po-hcontainer e54 e54"><title class="po-block e55 e55"><textual class="po-textual">Introduction</textual></title><section class="po-hcontainer e56 e56"><title class="po-block e57 e57"><textual class="po-textual">Objectives and Requirements</textual></title><para class="po-block e58 e58"><textual class="po-textual">XTemp is an acronym for 'XML Testing and Event-driven Monitoring of [business] Processes' also suggesting a strong 'temporal' aspect. The monitoring and testing of business processes and transactions serves anyone or a combination of these objectives:    
</textual></para><itemizedlist class="po-table e59 e59"><listitem class="po-container e60 e60"><para class="po-block e61 e61"><emphasis class="po-inline e62 e62" role="bold"><textual class="po-textual">Compliance with agreements.</textual></emphasis><textual class="po-textual"> These agreements may be business agreements such as SLAs, or regulatory compliance rules. They may also be infrastructure configuration agreements (e.g. ebXML CPA, WS-Policy). This category of testing includes SLA and SLO monitoring (service level agreements, objectives).
      </textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><emphasis class="po-inline e65 e65" role="bold"><textual class="po-textual">Business operations intelligence and improvement.</textual></emphasis><textual class="po-textual"> This involves monitoring of operations, either internal business processes or external message exchanges (eBusiness). The primary intent is to help improve or predict operations by enhancing visibility, generating reports, alarms and various metrics of dynamic business activities. This includes analysis of logs of processes and of business transactions.
      </textual></para></listitem><listitem class="po-container e66 e66"><para class="po-block e67 e67"><emphasis class="po-inline e68 e68" role="bold"><textual class="po-textual">Compliance with specifications.</textual></emphasis><textual class="po-textual">  This could be seens as a particular form of agreement compliance, involving the use of IT standards. Such specifications may be of a business transaction, business process definition, documents exchanged, or of infrastructure behavior (e.g. messaging protocol). This includes verifying that the execution trace of a business process  conforms to the process definitions (e.g. XPDL, BPMN, UML). In the B2B area, the actual message exchanges must obey specified choreographies (e.g. RosettaNet/GS1, OAGI) whether defined in a machine-processable manner (e.g. using ebXML ebBP) or not. Compliance to profiles on how to combine existing specifications - as in WS-I (http://www.ws-i.org/) - also falls in this category.
      </textual></para></listitem></itemizedlist><para class="po-block e69 e69"><textual class="po-textual">
In all these cases, it is assumed a business process generates a trace of its behavior - either as part of its business communicating function (messages) or as a log of its activities. It is also assumed that this trace can be modeled as events of various kinds, that are represented in - or may be mapped into - an XML format. This event format may be either a proprietary vocabulary or may follow a standard such as XES (http://www.xes-standard.org/), SAF (Symproms Automation Framework from OASIS), CEE (http://cee.mitre.org/), DMTF/CIM or XDAS. For example, a trace of exchanges between a Web client application and a Web service can be formatted in XML as done in [</textual><xref class="po-milestone e70 e70" linkend="wsi10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], including HTTP headers. 
    </textual></para><para class="po-block e71 e71"><textual class="po-textual">More detailed XTemp requirements are:  
      </textual><itemizedlist class="po-table e72 e72"><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">The same  test scripts should be executable either in a  “log analysis” mode where all events to be processed are already logged, or in a real-time monitoring mode where test script processing is driven by events as they occur, while having the ability to correlate these to past events. A mix of both situations must be handled as well.  XTemp assumes events to be stored in an “event board” that allows for past events selection and correlation.
	</textual></para></listitem><listitem class="po-container e75 e75"><para class="po-block e76 e76"><textual class="po-textual">The script language must support a notion of concurrent execution proper to the monitoring and analysis of interleaved “threads” (or sequential traces) of events, e.g. mimicking the concurrency of  business processes or of B2B exchanges.
	</textual></para></listitem><listitem class="po-container e77 e77"><para class="po-block e78 e78"><textual class="po-textual">The language must not be tied to a particular event format and content. Events in a log can be alarms, eBusiness policies, system configuration files, or B2B messages containing business documents. Any XML representation is acceptable provided that these events are timestamped in the same way, which may be done by using a thin common wrapper for all events.
	</textual></para></listitem><listitem class="po-container e79 e79"><para class="po-block e80 e80"><textual class="po-textual">XTemp must be an XML vocabulary itself, so that XTemp scripts can be generated easily from templates representing monitoring or testing design pattern – e.g. using user input provided  via forms and wizards. Another reason to design XTemp as an XML vocabulary is to support easy generation of XML test reports, by an intuitive mix of in-line externally-namespaced XML fragments with XTemp-computed values, in the way XSLT allows.
	</textual></para></listitem><listitem class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">Finally a significant subset of XTemp (“core”) must be entirely implementable in XSLT2.0, and usable at least for non real-time executions (log analysis use cases).  This makes it easy to develop and debug scripts over sample logs, before deploying for real-time monitoring. This is a major usability requirement, as debugging concurrent programs or workflow programs is not an easy task.
	</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e83 e83"><title class="po-block e84 e84"><textual class="po-textual">General Positioning of XTemp</textual></title><para class="po-block e85 e85"><textual class="po-textual">XTemp is workflow-capable in the sense that it provides a minimal set of operators that enable most workflow patterns, of which a good account has been provided in [</textual><xref class="po-milestone e86 e86" linkend="wcfp06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (see also http://www.workflowpatterns.com/). Compared with workflow languages that are also XML-based and support a notion of event (BPMN / XPDL, WS-BPEL), XTemp has more of an analytical focus. While BPMN and XPDL have restricted the use of events to include only those types of events that will affect the sequence or timing of activities of a process, XTemp is accessing past events for correlation and analysis. Consequently its concept of Event Board is  more than an event Source, but also a queryable repository of events that can be used off-line or live. 
    </textual></para><para class="po-block e87 e87"><textual class="po-textual">
  Because its focus is the analysis of processes and of transactions via the events they generate, the general execution model of XTemp is time-aware and event-centric. Time awareness is based on a notion of virtual present date/time (VP-time) associated with a script execution, and decoupled from the actual present time (AP-time). The VP-time which can be set as part of the execution context - i.e. independently from the script logic - allows for the same script to execute either in a live mode (consuming events as they occur) or deferred mode (i.e. for static analysis of past events) or yet in a way that combines consumption of both real-time and logged events. As explained in the execution model overview, concurrency in XTemp is based on the notion of VP-time.
    </textual></para><para class="po-block e88 e88"><textual class="po-textual">
XTemp may be viewed as “yet another concurrent programming language”, but it is the first one that leverages XML in three ways: (a) for input (event) processing, (b) for in-line report generation, and ( c) for its own syntax which allows for generating scripts from script templates using transforms. Conversely, XTemp could be defined as “yet another XML processing language” close to XSLT, but one with built-in support for event processing support and concurrency capability. How XTemp relates to XSLT is discussed in more details in the </textual><emphasis class="po-inline e89 e89" role="ital"><textual class="po-textual">Related Works</textual></emphasis><textual class="po-textual"> section.
    </textual></para></section></section><section class="po-hcontainer e90 e90"><title class="po-block e91 e91"><textual class="po-textual">Some Aspects of the Execution Model</textual></title><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">Event Processing</textual></title><para class="po-block e94 e94"><textual class="po-textual">
Because events often reflect on concurrent, distributed processes, XTemp supports a form of concurrency. However it is not intended for general concurrent programming and lacks many of the features found in such languages (e.g. advanced execution control as in coroutines, resource access control as semaphores or mutex). There are however two features that distinguish XTemp and highlight its analytic focus:
 </textual></para><para class="po-block e95 e95"><textual class="po-textual">
 </textual><itemizedlist class="po-table e96 e96"><listitem class="po-container e97 e97"><para class="po-block e98 e98"><textual class="po-textual">(1) Event consumption is mediated via one or more event board(s) that provide more than conventional pub-sub functions. The event board serves both as event source and/or event sink, but more importantly supports access to past events (e.g. event ordering and access based on date, indexed access based on a provided 'key'). It is a queryiable event history, yet querying is not distinguished from live consumption as both operations are performed using the same primitive ('catch'). Thus an event may be consumed (accessed) more than once by a script. In other words there is no difference between event querying and event listening.</textual></para></listitem><listitem class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">(2) Time handling in XTemp revolves around the notion of 'virtual present time' (VP-time), a value that is contextual to the execution of every statement, yet a value that can be manipulated and modified intentionally before and during execution, allowing some distance with the actual present (or execution time). The VP-time is conditioning event consumption and governs the notion of concurrency in XTemp: two script executions are 'concurrent' if their VP-times overlap, meaning they can catch the same events - or at least events occurring over the same period, as consumed events may be 'masked' by a script so that they will not be consumed twice.</textual></para></listitem></itemizedlist><textual class="po-textual"> 
  </textual></para><para class="po-block e101 e101"><textual class="po-textual">
The notion of VP-time combined with the access allowed by event boards makes it possible to synchronize script execution with events regardless of the actual time of their occurrence. This in turn allows for executing the same script 'live' or 'deferred' (i.e. for static analysis of past events) by simply modifying the initial VP-time value. 
  </textual></para></section><section class="po-hcontainer e102 e102"><title class="po-block e103 e103"><textual class="po-textual">Time Control</textual></title><para class="po-block e104 e104"><textual class="po-textual">
An XTemp script is composed of several script units called 'scriplets' that can invoke each other, with functional semantics with regard to the output they may or may not produce - XML fragments called 'X-effect' - the aggregation of which represents the complete script output called 'report'. Scriplet execution follows a (virtual) thread model: scriplets may be concurrent to each other if their VP-times overlap, but more important is how they influence each other's VP-times. By default, a scriplet invocation is 'synchronized' as it is blocking the invoking scriplet ('blocking' invocation) until completion of the invoked scriplet. This blocking means that the next statement after the invocation is set to the ending VP-time of the invoked scriplet - in which case both scriplets can still execute in a single thread implementation-wise as they cannot consume (or produce) same or co-occurring events.  A 'non-blocking' scriplet invocation will decouple the VP-times and allow both scriplets to access same or co-occurring events, with the effect of a parallel execution more aligned with a conventional and stronger meaning of concurrency. 
  </textual></para><para class="po-block e105 e105"><textual class="po-textual">
Even for static analysis over a log of past events, it may be convenient and more intuitive to script for concurrent executions. As illustrated later, a scriplet specialized for capturing a particular sequence of events independently from the main execution thread (i.e. represented by the invoking scriplet), should be scripted as fully concurrent to the invoking scriplet, whether the execution is live or not.    
  </textual></para><para class="po-block e106 e106"><textual class="po-textual">
XTemp concurrency features are minimal but sufficient to track (either live or deferred) most workflow execution patterns. Non-blocking scriplet invocation allows for matching conventional workflow forking (or 'and-split'). The merging (or 'and-join') of one or more concurrent workflow paths is supported in XTemp by using a single primitive ('wait') that allows for synchronizing with all kinds of clock events - e.g. a date or a scriplet completion. 
  </textual></para><para class="po-block e107 e107"><textual class="po-textual">
In addition to the scriplet invocation mode (blocking vs. non-blocking), the VP-time of a scriplet execution may be set at its invocation: a VP-time setting anterior to the VP-time of the invoking scriplet is called a backward invocation, while a VP-time setting future to the VP-time of the invoking scriplet is called a forward invocation. The invocation mode combined with VP-time setting allows for convenient expression of the logic behind various patterns of events:
      </textual><itemizedlist class="po-table e108 e108"><listitem class="po-container e109 e109"><para class="po-block e110 e110"><textual class="po-textual">A </textual><emphasis class="po-inline e111 e111" role="ital"><textual class="po-textual">backward, non-blocking</textual></emphasis><textual class="po-textual"> scriplet invocation will allow for querying past sequences of events, relative to a (current) event, without affecting the timing of the invoking scriplet.</textual></para></listitem><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">A </textual><emphasis class="po-inline e114 e114" role="ital"><textual class="po-textual">backward, blocking</textual></emphasis><textual class="po-textual"> scriplet invocation will allow for querying past sequences of events, relative to a (current) event, and to synchronize with the end of such a sequence in case it goes past the invoking VP-time.</textual></para></listitem><listitem class="po-container e115 e115"><para class="po-block e116 e116"><textual class="po-textual">A </textual><emphasis class="po-inline e117 e117" role="ital"><textual class="po-textual">forward, non-blocking</textual></emphasis><textual class="po-textual"> scriplet invocation will allow for capturing future sequences of events without affecting the timing - i.e. concerning access to 'current' events - of the invoking scriplet (in which case of course the 'current' events will now be 'past', once future events have occurred). This, when assigning the X-effect of scriplets to variables, supports the resolution of 'futures' as defined in concurrent languages.</textual></para></listitem><listitem class="po-container e118 e118"><para class="po-block e119 e119"><textual class="po-textual">A </textual><emphasis class="po-inline e120 e120" role="ital"><textual class="po-textual">forward, blocking</textual></emphasis><textual class="po-textual"> scriplet invocation will allow for capturing future sequences of events, relative to a (current) event, and to synchronize the invoking scriplet with the end of such a sequence for subsequent operations.</textual></para></listitem><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">A </textual><emphasis class="po-inline e123 e123" role="ital"><textual class="po-textual">current, non-blocking</textual></emphasis><textual class="po-textual"> scriplet invocation is equivalent to a conventional spawning of a thread in concurrent languages, or to a workflow forking ('and-split') of concurrent (generally different) paths of execution.</textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">A </textual><emphasis class="po-inline e126 e126" role="ital"><textual class="po-textual">current, blocking</textual></emphasis><textual class="po-textual"> scriplet invocation is equivalent to a conventional function invocation inside the same path (or thread) of execution, where the invoking scriplet will synchronize with the ending VP-time of the invoked scriplet.</textual></para></listitem></itemizedlist><textual class="po-textual">
  </textual></para><para class="po-block e127 e127"><textual class="po-textual">
In terms of concurrency semantics, XTemp cannot be considered an Actor language: scriplets are not aware of each other and do not communicate explicitly with each other. The model is rather of CSP (Communicating Sequential Processes), where scriplets behave as processes, consuming events and communicating via events only - except when a scriplet is starting another scriplet, in which case parameters may be passed. When scriplets do not communicate with each other e.g. by posting events, a single-threaded implementation of XTemp (such as most XSLT engines provide) is sufficient. When intended for static analysis of complete event boards (e.g. event logs), the subset of XTemp language identifed as 'core' - which excludes posting of new events - can be implemented in XSLT using conventional XSLT engines.
    </textual></para></section></section><section class="po-hcontainer e128 e128"><title class="po-block e129 e129"><textual class="po-textual">An Illustrated Overview of XTemp</textual></title><para class="po-block e130 e130"><textual class="po-textual">
      This article does not pretend to provide an exhaustive view of XTemp, but will emphasize some XML-related aspects, and how XML and related tools are leveraged. A more complete definition of XTemp canbe found in [</textual><xref class="po-milestone e131 e131" linkend="xtemp10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] along with an XSLT translator for "core" XTemp and a set of use cases on the Web page from the OASIS TaMIE TC (http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=tamie).
    </textual></para><section class="po-hcontainer e132 e132"><title class="po-block e133 e133"><textual class="po-textual">General Execution Paradigm</textual></title><para class="po-block e134 e134"><textual class="po-textual">An XTemp script is consuming events – either in real time or from a log.  XTemp is not entirely event-driven though: a script makes use of conventional algorithmic statements (branching, loops, exits, serial or concurrent sub-script invocations)  in order to control the flow of execution of testing/monitoring units called “scriplets”.  These scriplets may (or may not) synchronize with events. This combination of workflow-style control (allowing concurrency) and event synchronization is most appropriate for process monitoring and the analysis of related event patterns.  Scriplets provide a parameterized, reusable unit of execution and are assigned a date/time (their “virtual present time”) when executing. The script - or script package - is the largest unit of execution. The binding between the script and an actual event source (event board), is defined inside an “execution context” element separate from the script logic. 
      </textual></para><para class="po-block e135 e135"><emphasis class="po-inline e136 e136" role="bold"><textual class="po-textual">The XML practitioner take-away:</textual></emphasis><textual class="po-textual">  XTemp has constructs close to XSLT constructs, however its execution is not driven by XML patterns or templates. Its controls are workflow-like with a built-in concept of time and event, as it was designed to be familiar to business process designers and programmers. Yet, the  “core” conformance level of XTemp is implementable in XSLT2.0 or above, as this was a key requirement.  It is also designed for the XML practitioner: XPath has a central role for expression logic and event selection, and inline XML fragments of foreign namespaces allow for an intuitive generation of XML reports – in a way similar as XSLT does. 
      </textual></para><para class="po-block e137 e137"><emphasis class="po-inline e138 e138" role="ital"><textual class="po-textual">EXAMPLE 1: Periodic tallying of Purchase Order messages</textual></emphasis></para><para class="po-block e139 e139"><textual class="po-textual">The abbreviated monitoring script below illustrates some features of XTemp.</textual></para><para class="po-block e140 e140"><textual class="po-textual">
	</textual><itemizedlist class="po-table e141 e141"><listitem class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">The script is intended to produce a report showing how many Purchase Order events occurred every period of time ($period ) from a date/time ($initdate).</textual></para></listitem><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">The execution context &lt;execution-context&gt; at the beginning associates an event board  - here a simple log file - with a symbolic name (POlog), and declares some global variables. </textual></para></listitem><listitem class="po-container e146 e146"><para class="po-block e147 e147"><textual class="po-textual">The scriplet  named “mainloop” is iterating over each period of time, incrementing date ($currentdate) and counter ($mycounter) mutable variables.</textual></para></listitem><listitem class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">A monitoring report is initiated inline ( myreport:monitoringreport) and dynamically filled in a loop.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><programlisting class="po-block e150 e150" xml:space="preserve"><textual class="po-textual">
&lt;script-package 
...
		xmlns="http://docs.oasis-open.org/tamie/xtemp/200909"
		xmlns:myreport="http://www.abc.com/TBD/report"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		name="CUC-2"&gt;

  &lt;execution-context&gt;
    &lt;start-with scriplet="mymainloop"/&gt; &lt;!-- starting point --&gt;
    &lt;!-- global variables --&gt;
    &lt;var name="maxiter" type="integer"&gt;5&lt;/var&gt; 
    &lt;var name="initdate" type="dateTime"&gt;2009-10-08T11:12:00&lt;/var&gt; 
    &lt;var name="period" type="duration" expr="xs:dayTimeDuration('P1DT1H')"/&gt; &lt;!-- 1 day + 1 hour --&gt;
    &lt;event-board name="POlog" event-store="myeventlog" mode="source"/&gt;
  &lt;/execution-context&gt;

  &lt;!-- ======= scriplet: mymainloop ======= --&gt;
 
  &lt;scriplet name="mymainloop"&gt;
    &lt;myreport:monitoringreport period="{$period}"&gt; 

      &lt;loop&gt;
      …
	&lt;until expr="$mycounter ge $maxiter"/&gt;
	&lt;var name="currentevts"&gt;
	  &lt;start scriplet="doperiod" vptsync="true" vptset="$currentdate"&gt;
            &lt;with-param name="startperiod" expr="$currentdate"/&gt;
            &lt;with-param name="lengthperiod" expr="$period"/&gt;
	  &lt;/start&gt;
	&lt;/var&gt;
      …
	&lt;myreport:currentevts period="{$mycounter}" startdate="{$currentdate}"&gt;
	  &lt;eval expr="$currentevts"/&gt;
        &lt;/myreport:currentevts&gt;
	&lt;lvar-next name="mycounter" expr="$mycounter + 1 "/&gt;
	&lt;lvar-next name="currentdate" expr="($currentdate + $period)"/&gt;
	...
      &lt;/loop&gt;
    &lt;/myreport:monitoringreport&gt;
  &lt;/scriplet&gt; &lt;!-- mymainloop --&gt;

  &lt;!-- ======= scriplet: doperiod ======= --&gt;
  &lt;!-- The scriplet "doperiod" gathers various metrics for the period: 
average response time of Purchase Orders, total amount ordered, etc.  --&gt;

&lt;/script-package&gt;
	</textual></programlisting><para class="po-block e151 e151"><textual class="po-textual">
	</textual><itemizedlist class="po-table e152 e152"><listitem class="po-container e153 e153"><para class="po-block e154 e154"><textual class="po-textual">The scriplet “doperiod” below is catching all events related to a particular time period, which is bounded with a date/time ending specified in catch/@vptend. At each iteration, the current VP-time is implicitly incremented to the time the last event was caught. The following partial excerpt only illustrates event catching and makes abstraction of the computation of various metrics, illustrated in subsequent examples.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><programlisting class="po-block e155 e155" xml:space="preserve"><textual class="po-textual">
  &lt;!-- ======= scriplet: doperiod ======= --&gt;

  &lt;scriplet name="doperiod"&gt;
    &lt;param name="startperiod" type="dateTime"/&gt;
    &lt;param name="lengthperiod" type="duration"/&gt;

    &lt;var name="endperiod" type="dateTime"&gt;xsd:dateTime($startperiod + $lengthperiod)&lt;/var&gt;
    &lt;loop&gt;
      ...
	&lt;var name="po-event"&gt;
          &lt;catch eb=”POlog” vptend=”{$endperiod}”&gt;
            &lt;match&gt;
	      &lt;condition&gt;xtemp:content//myapp:PurchaseOrder&lt;/condition&gt;
            &lt;/match&gt;
          &lt;/catch&gt;
	&lt;/var&gt;
	&lt;until expr="not($po-event/xtemp:event)"/&gt;

      &lt;lvar-next name="count1" expr="$count1 + 1"/&gt;
      ...
    &lt;/loop&gt;
  &lt;/scriplet&gt; &lt;!-- doperiod --&gt;
	</textual></programlisting><para class="po-block e156 e156"><textual class="po-textual">An example of generated report from running this script over a sample event board is:
      </textual></para><programlisting class="po-block e157 e157" xml:space="preserve"><textual class="po-textual">
&lt;myreport:monitoringreport       
  xmlns:xtemp="http://docs.oasis-open.org/tamie/xtemp/200909"
  xmlns:myreport="http://www.abc.com/TBD/report"
  ...
  period="P1DT1H"&gt;
   &lt;myreport:currentevts period="0" startdate="2009-10-08T11:12:00" &gt;2&lt;/myreport:currentevts&gt;
   &lt;myreport:currentevts period="1" startdate="2009-10-09T12:12:00" &gt;0&lt;/myreport:currentevts&gt;
   &lt;myreport:currentevts period="2" startdate="2009-10-10T13:12:00" &gt;0&lt;/myreport:currentevts&gt;
   &lt;myreport:currentevts period="3" startdate="2009-10-11T14:12:00" &gt;1&lt;/myreport:currentevts&gt;
   &lt;myreport:currentevts period="4" startdate="2009-10-12T15:12:00" &gt;2&lt;/myreport:currentevts&gt;
   &lt;myreport:finaldate&gt;2009-10-13T16:12:00&lt;/myreport:finaldate&gt;
   &lt;myreport:elapsedtime&gt;P5DT5H&lt;/myreport:elapsedtime&gt;
&lt;/myreport:monitoringreport&gt;
	</textual></programlisting></section><section class="po-hcontainer e158 e158"><title class="po-block e159 e159"><textual class="po-textual">Some Convenient Algorithmic Constructs</textual></title><para class="po-block e160 e160"><textual class="po-textual">Three features are particularly helpful for testing and monitoring scripts: </textual></para><itemizedlist class="po-table e161 e161"><listitem class="po-container e162 e162"><para class="po-block e163 e163"><emphasis class="po-inline e164 e164" role="bold"><textual class="po-textual">Conditional branching: </textual></emphasis><textual class="po-textual">Two separate conditional statements are provided as in XSLT: simple condition and switch. For the latter,  XTemp  uses intuitive algorithmic keywords (if... else-if... else)  found in WS-BPEL, but opts for the cleaner switch packaging found in XSLT that puts all its conditions at the same level, the definition of a switch statement ('decide') distinct from a simple condition being the price to pay for this. </textual></para></listitem><listitem class="po-container e165 e165"><para class="po-block e166 e166"><emphasis class="po-inline e167 e167" role="bold"><textual class="po-textual">Loops with mutable variables: </textual></emphasis><textual class="po-textual">XTemp supports a general loop construct covering the two main iteration styles: for-each (element in a collection) and until (condition) or both.  An important feature for monitoring functions, is the introduction of mutable variables – even if their mutability is strongly constrained. Such mutable variables are called “loop variables” and are declared differently from other immutable variables. They can only be modified once in the body of a loop, and only just before the next iteration (i.e. their new value is effective at the next iteration only).</textual></para></listitem><listitem class="po-container e168 e168"><para class="po-block e169 e169"><emphasis class="po-inline e170 e170" role="bold"><textual class="po-textual">Exit: </textual></emphasis><textual class="po-textual">Exiting from a scriplet while gracefully closing a report element,  is done with the &lt;exit&gt; statement. This allows for simplified cascading test conditions as a sequence of distinct conditions. Depending whether the scriplet was started with the attribute @bubble-exit=”true” or not, an exit may propagate up to the invoking scriplet.</textual></para></listitem></itemizedlist><para class="po-block e171 e171"><textual class="po-textual">
Using both regular variables and mutable loop variables, is illustrated in the loop example below:
</textual></para><programlisting class="po-block e172 e172" xml:space="preserve"><textual class="po-textual">
&lt;loop&gt;
  &lt;on-start&gt;  &lt;!-- some mutable variables --&gt;
    &lt;lvar name="myitems" expr="$PO/lineItems/item"/&gt;
    &lt;lvar name="item" type="int"&gt;1&lt;/lvar&gt;
    &lt;lvar name="pototal" type="int"&gt;0&lt;/lvar&gt;
  &lt;/on-start&gt;
  &lt;until expr="$item gt fn:count($myitems)"/&gt;
  &lt;var name="myItemAmount"&gt;
    &lt;eval expr="$myitems[$item]/unitprice * $myitems[$item]/quantity"/&gt;
  &lt;/var&gt;
  &lt;var name="itemRebate"&gt;
    &lt;decide&gt;
      &lt;if expr="$myItemAmount gt 1000"&gt;
        &lt;eval expr="$myItemAmount * 0.10"/&gt;
      &lt;/if&gt;
      &lt;else&gt;
        &lt;eval expr="0"/&gt;
      &lt;/else&gt;
    &lt;/decide&gt;
  &lt;/var&gt;
  &lt;lvar-next name="pototal" expr="$pototal + ($myItemAmount -
$itemRebate) "/&gt;
  &lt;lvar-next name="item" expr="$item + 1"/&gt;
  &lt;on-final&gt;
    &lt;abc:mypototal&gt;&lt;eval expr="$pototal"/&gt;&lt;/abc:mypototal&gt;
  &lt;/on-final&gt;
&lt;/loop&gt;
	</textual></programlisting><para class="po-block e173 e173"><emphasis class="po-inline e174 e174" role="bold"><textual class="po-textual">The XML practitioner take-away:</textual></emphasis><textual class="po-textual">  Variables can be made mutable only where this capability is most needed: in loops (loop variables). They are distinguished from regular (immutable) variables by a different declaration syntax ( &lt;lvar&gt; vs. &lt;var&gt;), and are otherwise referenced similarly. It was acceptable to severely restrict the scope of mutable variables (local to a loop) and their mutation (only at the end of each iteration using &lt;lvar-next&gt;), while these restrictions made an XSLT implementation possible. An initialization loop section &lt;on-start&gt; inside the loop statement was then necessary to initiate their state,  while a  closing section &lt;on-final&gt; inside the loop was needed to extract the final values of mutable variables  e.g.  to report it as part of the X-effect.        </textual></para></section><section class="po-hcontainer e175 e175"><title class="po-block e176 e176"><textual class="po-textual">Event Processing</textual></title><para class="po-block e177 e177"><textual class="po-textual">A single statement &lt;catch&gt; is controlling event input, either for catching a single event or a pattern of events. An event pattern is a set of events correlated based on content, and often following some time-ordering constraint or time window constraint. An event pattern may be a well-correlated conversation such as a multi-message eBusiness transaction, or a more loosely defined co-occurrence of events e.g. close to each other in time but without well-established causality or common cause. </textual></para><para class="po-block e178 e178"><textual class="po-textual">In XTemp an event pattern may be expressed in two ways: (a) by using one catch statement for each event, and by controlling the sequence(s) of &lt;catch&gt; statements using other XTemp controls (scriplets, conditionals, loops), or (b) by using a combination of filters (&lt;match&gt; statements) inside a single catch. The former (a) is more appropriate when the pattern occurs over a significant time window (such as for some long-lasting business transactions)  or when the pattern is itself defined  dynamically depending on some event content, requiring some processing as it unfolds  (e.g. when a business transaction may unfold differently based on its initial event content). The latter (b) allows for a compact expression of deterministic patterns but more importantly allows for delegating the &lt;catch&gt; execution to specialized event processors that can optimize such processing (equivalent of query optimization in databases), e.g.  by delegating to a complex event processing (CEP) module.</textual></para><para class="po-block e179 e179"><emphasis class="po-inline e180 e180" role="ital"><textual class="po-textual">EXAMPLE 2: Catching some event pattern</textual></emphasis></para><para class="po-block e181 e181"><textual class="po-textual">The following catch statement selects a sequence of three events representing an exchange of three messages:</textual></para><para class="po-block e182 e182"><textual class="po-textual">
	</textual><itemizedlist class="po-table e183 e183"><listitem class="po-container e184 e184"><para class="po-block e185 e185"><textual class="po-textual">(E1) a Purchase Order request</textual></para></listitem><listitem class="po-container e186 e186"><para class="po-block e187 e187"><textual class="po-textual">(E2) a PO response (acceptance or rejection)</textual></para></listitem><listitem class="po-container e188 e188"><para class="po-block e189 e189"><textual class="po-textual">(E3) a generic receipt to the PO response</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e190 e190"><textual class="po-textual">These three events are ordered in time: E3 after E2 after E1. The correlation between these events is based on different content: </textual></para><itemizedlist class="po-table e191 e191"><listitem class="po-container e192 e192"><para class="po-block e193 e193"><textual class="po-textual">Between E1 and E2: the same value for the PO reference ("order-ref" element in message headers)</textual></para></listitem><listitem class="po-container e194 e194"><para class="po-block e195 e195"><textual class="po-textual">Between E2 and E3: the MessageID value present in E2, must equal the RefMessageID in E3.</textual></para></listitem></itemizedlist><programlisting class="po-block e196 e196" xml:space="preserve"><textual class="po-textual">
&lt;catch&gt;
  &lt;match event="E1"&gt;
    &lt;condition&gt;content/soap/Header/msgData/action = 'PORequest'&lt;/condition&gt;
  &lt;/match&gt;
  &lt;match event="E2" after="E1"&gt;
    &lt;condition&gt;(content/soap/Header/msgData/action = 'POAccept' | 'POReject') and 
content/soap/Header/msgData/property[@name = 'order_ref'] = 
$E1/content/soap/Header/msgData/property[@name = 'order_ref']&lt;/condition&gt;
  &lt;/match&gt;
  &lt;match event="E3" after="E2"&gt;
    &lt;condition&gt;content/soap/Header/msgData/action = 'Receipt' and 
content/soap/Header/msgData/property/RefMessageID = $E2/content/soap/Header/msgData/messageID
    &lt;/condition&gt;
  &lt;/match&gt;
&lt;/catch&gt;
	</textual></programlisting><para class="po-block e197 e197"><textual class="po-textual">
&lt;catch&gt; plays two roles: (1) synchronization operation  for real-time execution, and (2) event board querying for past events analysis (deferred processing). In both cases, &lt;catch&gt; is operating using an event board as event source: the only difference between live and deferred is the VP-time of execution compared with the timestamp of events in board. “Catching” an event pattern 'live' often involves a combination of real-time event consumption with querying past events.
</textual></para><para class="po-block e198 e198"><textual class="po-textual">In contrast, WS-BPEL event catching &lt;pick&gt; is designed to capture and process single events at a time, as its use of events is more as a process driver, than for analytical and diagnosis purpose.
</textual></para><para class="po-block e199 e199"><emphasis class="po-inline e200 e200" role="bold"><textual class="po-textual">The XML practitioner take-away:</textual></emphasis><textual class="po-textual">Xpath2.0 proved sufficient as expression language for event querying, selection and correlation. Because event pattern expressed in &lt;catch&gt; are usually well time-constrained and/or strongly correlated, large logs of (time-ordered) events are manageable without penalty using conventional XPath and XSLT processors.  Any XML-based event format - e.g. XES, SAF (Symproms Automation Framework from OASIS), CIM Events/Indications from DMTF  - can be accommodated, provided that these events are timestamped so they can be ordered by the event board. In the baseline “core” implementation of XTemp with XSLT2.0, the event log is a plain file of time-ordered event records.  Logs of events that have intermediate structures – e.g. events are grouped in “traces” under a log in XES – can also be handled without transformation. The event content is quite open, allowing for parts using binary encoding or attachments of various formats (e.g. MIME or SOAP attachments). However only the XML parts are queryable. 
</textual></para></section><section class="po-hcontainer e201 e201"><title class="po-block e202 e202"><textual class="po-textual">Concurrency</textual></title><para class="po-block e203 e203"><textual class="po-textual">The notion of concurrency is as necessary to the monitoring and validation of business transactions or processes as it is to the actual programming of these processes. The concurrency of threads or activities in the latter translates into the concurrency of related event sequences in the former. A set of typical workflow patterns, several of them involving concurrency can be found in [</textual><xref class="po-milestone e204 e204" linkend="wcfp06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. workflow language like WS-BPEL [</textual><xref class="po-milestone e205 e205" linkend="wsbpel07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] uses an advanced set of constructs to manage concurrency and synchronization (&lt;flow&gt;, &lt;links&gt;, &lt;joinCondition&gt;, &lt;sources&gt; and &lt;targets&gt;). </textual></para><para class="po-block e206 e206"><textual class="po-textual">However, the monitoring of concurrent sequences of activities  does not require the same sophistication in concurrency control as the actual execution of these activities, provided the events associated with these sequences have a known correlation logic, which is generally the case in choreographed eBusiness transactions (e.g. messages relating to the same procurement action will report the same PO reference)  and business process instances (e.g. a process instances initiated by an insurance claim, will generally report the claim number or originator ID across all its activities and events). Consequently XTemp has a minimal set of constructs for concurrency and synchronization: (1) the concurrent – or “non-blocking” - invocation of a scriplet, (&lt;sart scriplet=”abc” vptsync=”false”&gt;)  for tracking overlapping sequences of related events, and (2) a synchronization operator &lt;wait&gt;, for joining a group of concurrent scriplets if necessary. Most other forms of synchronization simply rely on event catching &lt;catch&gt;.</textual></para><para class="po-block e207 e207"><textual class="po-textual">The VP-time assigned to a scriplet invocation determines which events are accessible to the scriplet. This makes it possible to execute the same script either live or deferred over a log of events with same result, just by setting its initial VP-time to the same date/time relative to these events. Two scriplets are concurrent if their VP-time windows overlap. Concurrency  is “virtual” in XTemp to the extent that the notion of “present time” (of execution) is manipulated as a data item.  Even when the objective is only the analysis of past logs, concurrency actually simplifies the test scripting by allowing event processing to follow the logic of a particular sequence  regardless of its context (e.g. the processing of interleaved logs of PO transactions can be done by concurrent scriplets tracking each transaction). </textual></para><para class="po-block e208 e208"><emphasis class="po-inline e209 e209" role="bold"><textual class="po-textual">The XML practitioner take-away:</textual></emphasis><textual class="po-textual">“Core”  XTemp, including virtual concurrency,  is XSLT2.0-implementable for non-live executions over logs of events: this makes it very easy to verify the correctness of concurrent script over various events scenarios, before executing live. When a script has been validated over a log of events, the only modification needed before executing it live is a change in the @vptset value of its &lt;start-with&gt; statement in he execution context. The implementation of virtual concurrency is greatly simplified when the concurrent threads (here scriplets) do not communicate with each other.  This is the case for  the “core” conformance level of XTemp (no event posting). In such cases, an XSLT implementation is possible.  
</textual></para><para class="po-block e210 e210"><emphasis class="po-inline e211 e211" role="ital"><textual class="po-textual">EXAMPLE 3: Monitoring interleaved PO transactions</textual></emphasis></para><para class="po-block e212 e212"><textual class="po-textual">The following script is monitoring PO transactions. Each PO transaction is comprised of a PO request, and a returned PO response. PO transactions are generally intertwined, as many PO requests may be sent before the first response is obtained. The monitoring of each individual PO transaction is handled by an invocation of the “get-PO-response” scriplet. These invocations are non-blocking (@vptsync="false") meaning they execute in (virtual) concurrency with the main script and with each other. The concurrency is here virtual in the sense that these invocations may actually be executed serially, provided their concurrency semantics is preserved by setting the VP-time of each invocation to the time the transaction is started (PO request occurrence). Virtual concurrency makes scripting of such test cases quite intuitive, when distinct sequences of events need be analyzed that can be intertwined in their actual occurrence.</textual></para><para class="po-block e213 e213"><textual class="po-textual">In the script below:
	</textual><itemizedlist class="po-table e214 e214"><listitem class="po-container e215 e215"><para class="po-block e216 e216"><textual class="po-textual">The scriplet  “main” is looping over each Purchase Order catch. For each PO it invokes concurrently the “get-PO-response” scriplet, for tracking this PO transaction. The scriplet initiates a top report element &lt;myreport:results&gt;</textual></para></listitem><listitem class="po-container e217 e217"><para class="po-block e218 e218"><textual class="po-textual">The  “get-PO-response” scriplet is waiting no more than 10mn (@tryfor=”PT600S”) for a PO response, and generates an error report if no response is obtained in this delay.</textual></para></listitem><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">The outcome of the “get-PO-response” scriplet is captured by the enclosing (non-mutable) variable $poresponse. This outcome is an XML fragment reflecting on the status of the PO transaction, and containing metrics (elapsed time).</textual></para></listitem><listitem class="po-container e221 e221"><para class="po-block e222 e222"><textual class="po-textual">Although the assignment of the $poresponse variable in the main loop has (virtually) “waited” for the completion of the current PO transaction, the next PO to be caught in the loop may occur before the end of the previous PO transaction. This is made possible by the concurrent invocation of the “get-PO-response” scriplet, i.e. not blocking the course of the main loop. Yet, an interesting twist is that the actual execution of the main loop needs to wait the end of get-PO-response in order to consolidate its results in summary values (e.g. for a final report on average response time for all Pos). But  “virtual concurrency” is still achievable here as the scriplets “main” and “get-PO-response” have different VP-time values.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e223 e223"><textual class="po-textual">These three events are ordered in time: E3 after E2 after E1. The correlation between these events is based on different content: </textual></para><programlisting class="po-block e224 e224" xml:space="preserve"><textual class="po-textual">
&lt;script-package xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schema-version-id="0.4"
                ...
		xmlns="http://docs.oasis-open.org/tamie/xtemp/200909"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xmlns:myreport="http://www.abc.com/TBD/report"
		xmlns:myapp="http://www.abc.com/TBD/myapp"
		&gt;
&lt;scriplet name="main"&gt;
    &lt;myreport:results&gt;
      &lt;loop&gt;
        &lt;on-start&gt;
          &lt;lvar name="count1" type="integer"&gt;0&lt;/lvar&gt;
          &lt;lvar name="successcnt" type="integer"&gt;0&lt;/lvar&gt;
          &lt;lvar name="elapsedtotal" type="dayTimeDuration"&gt;PT0H&lt;/lvar&gt;
        &lt;/on-start&gt;

        &lt;var name="po-event"&gt;
          &lt;catch&gt;
            &lt;match&gt;&lt;condition&gt;xtemp:content/myapp:PurchaseOrder&lt;/condition&gt;&lt;/match&gt;
          &lt;/catch&gt;
        &lt;/var&gt;

        &lt;until expr="not($po-event/xtemp:event)"/&gt;

        &lt;var name="poresponse"&gt;
          &lt;start scriplet="get-PO-response" vptsync="false"&gt;
            &lt;with-param name="ref" expr="$po-event/xtemp:event/xtemp:content/myapp:PurchaseOrder/myapp:poref"/&gt;
            &lt;with-param name="time0" expr="$po-event/xtemp:event/@timestamp"/&gt;
          &lt;/start&gt;
        &lt;/var&gt;
	
        &lt;eval expr="$poresponse/myreport:error"/&gt;
        &lt;eval expr="$poresponse/myreport:messg"/&gt;

        &lt;lvar-next name="count1" expr="$count1 + 1 "/&gt;
        &lt;lvar-next name="elapsedtotal" expr="if ($poresponse//myreport:elapsed ) then 
          $elapsedtotal + xs:dayTimeDuration($poresponse//myreport:elapsed ) else $elapsedtotal "/&gt;
        &lt;lvar-next name="successcnt" expr="if ($poresponse//myreport:elapsed ) then 
          $successcnt + 1 else $successcnt "/&gt;
        &lt;on-final&gt;
          &lt;myreport:summary msgtype="{concat('TOTAL PO selected: ', $count1)}"/&gt;
          &lt;myreport:summary msgtype="{concat('TOTAL successful transactions: ', $successcnt)}"/&gt;
          &lt;myreport:summary msgtype="{concat('TOTAL successful elapsed time: ', $elapsedtotal)}"/&gt;
	  &lt;if expr="$successcnt gt 0"&gt;
	    &lt;myreport:summary&gt;AVERAGE RESPONSE TIME: 
              &lt;eval expr="minutes-from-duration($elapsedtotal) div $successcnt"/&gt; MINUTES, 
              &lt;eval expr="seconds-from-duration($elapsedtotal) div $successcnt"/&gt; SECONDS.
            &lt;/myreport:summary&gt;
	  &lt;/if&gt;
        &lt;/on-final&gt;

      &lt;/loop&gt;
    &lt;/myreport:results&gt;
  &lt;/scriplet&gt;

  &lt;scriplet name="get-PO-response"&gt;
    &lt;param name="ref" type="string"/&gt;
    &lt;param name="time0" type="dateTime"/&gt;

    &lt;var name="confirm-event"&gt;
      &lt;catch tryfor="PT600S"&gt;
        &lt;match&gt;
          &lt;condition&gt;xtemp:content/myapp:confirm[myapp:poref = $ref]&lt;/condition&gt;
        &lt;/match&gt;
      &lt;/catch&gt;
    &lt;/var&gt;
    &lt;if expr="not($confirm-event/xtemp:event)"&gt;
      &lt;myreport:error&gt;No confirm event for &lt;eval expr="$ref"/&gt; 
        received within 10 minutes of the PO&lt;/myreport:error&gt;
      &lt;exit/&gt;
    &lt;/if&gt;

    &lt;var name="resp-time" type="dateTime" expr="$confirm-event/xtemp:event/@timestamp"/&gt;
    &lt;myreport:messg&gt;Confirmation received for PO &lt;eval expr="$ref"/&gt;
      &lt;eval expr="concat('-SUCCESS: message:', $ref, 
		  ' Response received within:', 
		  minutes-from-duration($resp-time - $time0), ' MIN ',
		  seconds-from-duration($resp-time - $time0), ' SEC'
		  )"/&gt;
      &lt;myreport:elapsed&gt;&lt;eval expr="$resp-time - $time0"/&gt;&lt;/myreport:elapsed&gt;
    &lt;/myreport:messg&gt;
  &lt;/scriplet&gt;
&lt;/script-package&gt;
	</textual></programlisting><para class="po-block e225 e225"><textual class="po-textual">The XML monitoring report produced by this script over a sample event log is:</textual></para><programlisting class="po-block e226 e226" xml:space="preserve"><textual class="po-textual">
&lt;myreport:results xmlns:translator="translator"
           xmlns:xtemp="http://docs.oasis-open.org/tamie/xtemp/200909"
             xmlns:myreport="http://www.abc.com/TBD/report"
          ...
             xmlns="http://docs.oasis-open.org/tamie/xtemp/200909"&gt;
   &lt;myreport:error&gt;No confirm event for Name1 received within 10 minutes of the PO
     &lt;/myreport:error&gt;
   &lt;myreport:messg&gt;Confirmation received for PO Name2 -SUCCESS: message:Name2 
     Response received within:5 MIN 40 SEC&lt;myreport:elapsed&gt;PT5M40S&lt;/myreport:elapsed&gt;
   &lt;/myreport:messg&gt;
   &lt;myreport:error&gt;No confirm event for Name3 received within 10 minutes of the PO&lt;/myreport:error&gt;
   &lt;myreport:messg&gt;Confirmation received for PO Name4 -SUCCESS: message:Name4 
     Response received within:6 MIN 0 SEC&lt;myreport:elapsed&gt;PT6M&lt;/myreport:elapsed&gt;
   &lt;/myreport:messg&gt;

   &lt;myreport:summary msgtype="TOTAL PO selected: 4"/&gt;
   &lt;myreport:summary msgtype="TOTAL successful transactions: 2"/&gt;
   &lt;myreport:summary msgtype="TOTAL successful elapsed time: PT11M40S"/&gt;

   &lt;myreport:summary&gt;AVERAGE RESPONSE TIME: 5.5 MINUTES, 20 SECONDS.&lt;/myreport:summary&gt;

&lt;/myreport:results&gt;
	</textual></programlisting></section><section class="po-hcontainer e227 e227"><title class="po-block e228 e228"><textual class="po-textual">Generating Test Reports</textual></title><para class="po-block e229 e229"><textual class="po-textual">The primary output of a script execution is called an X-effect (for "XML side-effect"). The X-effect is a text output, which is generally well-formed serialized XML but may also just be plain text. The notion of X-effect is a generalization of the output produced by XML script languages such as XSLT, that can be a combination of in-line XML fragments with external namespaces and of computed values or fragments.
</textual></para><para class="po-block e230 e230"><textual class="po-textual">The X-effect of a script can be recursively defined as follows:
	</textual><itemizedlist class="po-table e231 e231"><listitem class="po-container e232 e232"><para class="po-block e233 e233"><textual class="po-textual">The X-effect of a scriplet execution is the concatenation of the X-effects of its child elements.</textual></para></listitem><listitem class="po-container e234 e234"><para class="po-block e235 e235"><textual class="po-textual">The X-effect of an XML fragment that does not contain any embedded XTemp statement (i.e. not using the xtemp namespace), is itself.</textual></para></listitem><listitem class="po-container e236 e236"><para class="po-block e237 e237"><textual class="po-textual">The X-effect of an XML fragment that contains some embedded XTemp statement, is the same fragment after substituting the XTemp statement with its X-effect.</textual></para></listitem><listitem class="po-container e238 e238"><para class="po-block e239 e239"><textual class="po-textual">The X-effect of an xtemp:eval statement, is the result of the evaluation of the embedded expression.</textual></para></listitem><listitem class="po-container e240 e240"><para class="po-block e241 e241"><textual class="po-textual">The X-effect of an XTemp statement other than xtemp:eval ( e.g. &lt;if&gt;, &lt;loop&gt;, &lt;start&gt;... ) is evaluated as specified in the definition of each statement.</textual></para></listitem><listitem class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">The X-effect of a loop is the concatenation of the X-effect of each iteration (if any), with the X-effect of the &lt;final&gt; statement (if any).</textual></para></listitem><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">The X-effect of a variable declaration is nil, as the X-effect of the contained statements is simply assigned to the variable as its value.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e246 e246"><textual class="po-textual">Two XTemp features could be seen as challenging for the production of X-effects, but ended up with intuitive X-effect semantics:</textual></para><para class="po-block e247 e247"><emphasis class="po-inline e248 e248" role="bold"><textual class="po-textual">Exits:</textual></emphasis><textual class="po-textual"> The execution of an &lt;xtemp:exit&gt; statements will simply cancel the production of X-effects of its following siblings (as these are not executed), meaning the X-effect of the embedding statements is preserved. The rule also applies to the following siblings of any conditional statement that executes &lt;xtemp:exit&gt; at any level inside.</textual></para><para class="po-block e249 e249"><emphasis class="po-inline e250 e250" role="bold"><textual class="po-textual">Concurrent executions:</textual></emphasis><textual class="po-textual">The rule for X-effect generation of a scriplet invoking another scriplet, is exactly the same regardless whether this invocation was blocking or non-blocking (i.e. serial or concurrent):
The combined X-effect of scriplets where one is started by the other, is following these rules:
When scriplet S1 "starts"  (either blocking or non-blocking ) scriplet S2, the X-effect of S1 is obtained by :
(1) capturing the X-effect of S2 at the end of S2 execution,
(2) substituting the &lt;starts scriplet="S2" vptsync="..." /&gt; statement in S1 with the X-effect of S2.
(3) generating the final X-effect of S1  at the end of its execution, after substitution in (2).
This rule applies recursively to all scriplet invocation trees, possibly combining  blocking and non-blocking invocations. The rationale for this, is that the tree-like structure of an XML report must generally match the hierarchy and order of scriplets *invocations* regardless of the actual course of their execution which may overlap or be concurrent in various ways. For example, the report produced by the previous script example  is naturally listing the results for each PO transaction in the order these PO were initiated – as a sequence of transaction reports, as a human reader would expect -, regardless of how these transactions executions were intertwined, e.g. even if the first PO transaction is also the last one to complete.
</textual></para><para class="po-block e251 e251"><textual class="po-textual">
</textual></para><para class="po-block e252 e252"><emphasis class="po-inline e253 e253" role="bold"><textual class="po-textual">The XML practitioner take-away: </textual></emphasis><textual class="po-textual">The production of XML test reports is most intuitive and readable when combining in-line XML fragments of foreign namespaces and computed fragments or values, as done in XSLT. Concurrent executions in XTemp, as well as breaking statements such as &lt;exit&gt; are not an obstacle to the use of these report generation techniques familiar to XSLT developers.  
</textual></para></section></section><section class="po-hcontainer e254 e254"><title class="po-block e255 e255"><textual class="po-textual">Related Works</textual></title><section class="po-hcontainer e256 e256"><title class="po-block e257 e257"><textual class="po-textual">XTemp and XSLT</textual></title><para class="po-block e258 e258"><textual class="po-textual">XSLT is computationally sufficient to process events in a 'deferred' mode (static analysis), assuming a representation of event boards as static XML files. However, when considering whether XSLT alone should be used - e.g. by defining appropriate design patterns for event handling and timing - the issue of usability and developer-friendliness arise. The declarative, functional design of XSLT based on scripts driven by template matching does not make it an intuitive language for workflow practitioners or more generally for analysts and developers familiar with the scripting of business processes designed along a state machine model with clearly defined state transitions for underlying data. It is the experience of the authors that it is critical to provide constructs familiar to target users and at the right level of abstraction, for a language to be well accepted. Consequently XTemp defines or imports concepts familiar to business process and workflow developers such as event catching, concurrent paths control and synchronization, timing of state transitions, exiting, mutable variables. The experience of the authors in analyzing and testing event traces is also that a balance must be reached between pattern-driven language with strong functional design such as XSLT and workflow languages like WS-BPEL.
    </textual></para><para class="po-block e259 e259"><textual class="po-textual">
On the other hand, XSLT and XPath have reached a level of maturity and expressiveness that cannot be ignored, and  XTemp is leveraging both to a large extent. XTemp1.0 is using XPath as expression language and relies extensively on its functions and operators library, in particular for its time and duration processing (e.g. XPath2.0 library). Shouldn't then XTemp be defined as an XSLT extension? Although such an approach is not ruled out in future versions, a couple of reasons weight in favor of keeping its syntax separate for now:
 </textual><itemizedlist class="po-table e260 e260"><listitem class="po-container e261 e261"><para class="po-block e262 e262"><textual class="po-textual">It is not clear to the authors whether and how </textual><emphasis class="po-inline e263 e263" role="ital"><textual class="po-textual">all</textual></emphasis><textual class="po-textual"> aspects of XSLT language semantics can be compatible with real-time processing of live events, concurrency, and other timing aspects. Whether future evolutions of XTemp can be defined as extensions to XSLT, will rely on an execution semantics more ambitious than the one presented here, and able to encompass all XSLT features in a time-sensitive, event-driven context.</textual></para></listitem><listitem class="po-container e264 e264"><para class="po-block e265 e265"><textual class="po-textual">Another reason for decoupling XTemp design from XSLT syntax, is the option - not yet investigated by the authors - of leveraging XQuery instead of XSLT for a scalable implementation. XQuery has powered XML content servers - e.g. MarkLogic server (see http://gcdnmirror.paultan.org/markmail.org/docs/faq.xqy), proving adequate for processing large repositories of relatively small items such as XML-formatted emails for searching and querying. Such repositories of XML content may provide a scalable implementation for event boards.</textual></para></listitem></itemizedlist><textual class="po-textual">
In spite of these open questions the XTemp design is still influenced by XSLT features - i.e. it matches feature-wise a subset of XSLT and its new features (variable mutability, event catching and time handling) are designed to be XSLT-implementable, even if not in an optimal way, at least for deferred executions - or analysis of static event boards. Implementability using XSLT - even for a restricted ('deferred') usage and for a subset of XTemp features called 'core' XTemp - is an important aspect of usability of the language. 
    </textual></para><para class="po-block e266 e266"><textual class="po-textual"> Among the features of XTemp beyond the 'core' subset (as defined by the 'core' conformance level in [</textual><xref class="po-milestone e267 e267" linkend="xtemp10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]) and considered challenging or impossible using conventional XSLT engines, are:
 </textual><itemizedlist class="po-table e268 e268"><listitem class="po-container e269 e269"><para class="po-block e270 e270"><textual class="po-textual">Event posting, as this provides ways for concurrent paths to depend on each other (event communication) that would require a level of concurrency control beyond what XSLT allows to emulate.</textual></para></listitem><listitem class="po-container e271 e271"><para class="po-block e272 e272"><textual class="po-textual">Definition of a complex event pattern inside a single 'catch' statement, which requires advanced processing of event boards (e.g. as supported by a dedicated query language). As explained later, the value of this feature is precisely in its delegation to more specialized processors, while it can be replaced by a flow of simpler 'catch' statements, even if less efficient.</textual></para></listitem><listitem class="po-container e273 e273"><para class="po-block e274 e274"><textual class="po-textual">Event masking, which implies some event state management associated with a script more than with the event board.</textual></para></listitem><listitem class="po-container e275 e275"><para class="po-block e276 e276"><textual class="po-textual">Concurrent path joining (as in workflow) using the 'wait' statement, which implies the ability to keep track of several concurrent paths and their execution status.</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e277 e277"><textual class="po-textual">Another approach in analyzing and testing the trace of business processes, is to rely on a simpler and more declarative 'rule' language (or 'pattern' language) usually implemented in XSLT, such as Schematron or Tamelizer (the latter being a recent implementation - see: http://code.google.com/p/tamelizer/ - of a test assertion language proposed in [</textual><xref class="po-milestone e278 e278" linkend="tag09"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] by one of the authors.) Such declarative languages in turn rely heavily on the expressive and processing power of XPath for the testing logic. But declarative test assertions or patterns are of little help when expressing complex test logic spanning sequences of events: although Xpath2.0 and above has a remarkable ability for expressing such correlation and validation logic in a single predicate expression, the readability and maintenability of such tests is poor. For example, the test suites for WS-I [</textual><xref class="po-milestone e279 e279" linkend="wsi10"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] were based on the above test assertion design and related analyzer tool. In these test suites XPath2.0 alone proved indeed able to handle complex choreographies of timestamped inputs such as Web services requests and responses, combined with related low-level messages such as resends or receipts and various hand-shaking procedures. But the resulting large XPath expressions are hardly readable and difficult to evolve or to update, requiring a level of skills and efforts in XPath programming beyond what most test engineers are ready or willing to exercise. The ability of above languages to chain test assertions or to compose rules, does not really help to break down this kind of complexity. It became clear that a more powerful yet more intuitive combination of logical expressions and procedural flow definition such as in XTemp, was needed. 
    </textual></para></section><section class="po-hcontainer e280 e280"><title class="po-block e281 e281"><textual class="po-textual">WS-BPEL and Workflow XML vocabularies</textual></title><para class="po-block e282 e282"><textual class="po-textual">Workflow languages such as WS-BPEL [</textual><xref class="po-milestone e283 e283" linkend="wsbpel07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and others XML vocabularies or notations (XPDL, BPMN) are intended to describe and drive business processes, more than to analyze and verify their behavior. To this extent, even if they share several seemingly equivalent algorithmic and synchronization constructs with XTemp, their purpose is rather complementary. The notion of event is used in WS-BPEL mostly as a dynamic input to business process instances, and not as an input for a more general analysis that may span several processes. The notion of correlation set is used for helping the selection of the next event that belongs to the same process, which is expected to depend on a predefined set of event attributes that define some event equivalence class. To this end, correlation sets are sufficient and efficient but unable to express more general event patterns needed in analysis and live monitoring.  The concept of event handler is intended in WS-BPEL as a device for helping drive process instances, typically as these events occur. It does not assume the capability of processing past events. Finally, the focus on analysis makes it possible for XTemp to only use a minimal set of constructs, compared with WS-BPEL.</textual></para></section><section class="po-hcontainer e284 e284"><title class="po-block e285 e285"><textual class="po-textual">XProc and Pipelining</textual></title><para class="po-block e286 e286"><textual class="po-textual">Although XSLT, XProc and XTemp share the same general purpose of advanced processing of XML inputs, and share several similar algorithmic constructs, it is interesting to stress the different nature of the entities behind these XML inputs and of their processing. The target unit for processing in XProc is a “document”, while it is an event in XTemp. Clearly, this distinction is not as much about content (a document can be represented as an event and vice-versa) as it is about the general nature of the processing of these items – as well as how these items relate to each other. In short, documents are to be validated, transformed, compared, merged.  Events have to be matched, correlated, waited for or queried.  </textual></para><para class="po-block e287 e287"><textual class="po-textual">A combination of documents that has to be part of the same processing flow is statically known in general (e.g. a business document + its possible includes + its XML schema + a set of codelists + some semantic rules).  Their role is well established as these documents will be assigned specific ports in an XProc pipeline.  In comparison, the set of events of interest for processing as a unit is generally unknown beforehand, determined dynamically by a tentative match with a pattern definition that may or may not succeed.  The document itself has a business value, and the value-add from Xproc is in its (efficient) validation, transform, or assembly.  Events generally have value not through individual processing, but in relation with each other. Consequently, the ability to correlate efficiently over a potentially large event repository is key in XTemp, while advanced, multistep processing and related pipeline optimization is not its goal.</textual></para><para class="po-block e288 e288"><textual class="po-textual">Similarly, although XSLT is computationally sufficient by itself to drive a chain of document processing or to analyze a log of events, its constructs do not support these paradigms in a way that is specific enough for practitioners to feel comfortable with the language, or for implementors to use appropriate modules or architectures.</textual></para></section><section class="po-hcontainer e289 e289"><title class="po-block e290 e290"><textual class="po-textual">Testbeds using XML vocabularies for Test Suite syntax</textual></title><para class="po-block e291 e291"><textual class="po-textual">
XML vocabularies have been used in B2B testbeds for test case and test suite representation. Two of the authors have been involved in an earlier, very limited version of XTemp [</textual><xref class="po-milestone e292 e292" linkend="etsl07"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] that did not have the same algorithmic capabilities nor leveraged XPath to the same extent. Implementations proved sufficient for the driving and verification of many B2B test cases, but lacked the ability to generate advanced reports that require data consolidation over several B2B exchanges. Other testbeds have also used XML vocabularies for test suites, that were developed at NIST [</textual><xref class="po-milestone e293 e293" linkend="wstb2b06"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and also in [</textual><xref class="po-milestone e294 e294" linkend="testHL7"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. These testbeds represent the state of the art in XML-based test suites. However they do not leverage fully the notions of event and test execution concurrency as means to a powerful analysis of B2B logs. Their focus is more on driving test cases than on test analysis.
</textual></para></section></section><section class="po-hcontainer e295 e295"><title class="po-block e296 e296"><textual class="po-textual">Conclusion</textual></title><para class="po-block e297 e297"><textual class="po-textual">
An XML language for event processing and analysis is presented, that fully leverages XML in three ways: as event format, as test script format, and as test report format. The concurrency semantics and execution required by a well-rounded event processing has proved to be quite compatible with the XML focus both as script format and incremental report generation, while a core version of the language could be implemented using XSLT2.0 which was a major requirement in terms of ease of deployment and convenience of script development and testing. The authors are working on deploying XTemp in their B2B testbed work and for advancing it as analysis and test language for eBusiness exchanges in various user consortiums. However, although the initial motivation was business process analysis and validation, the resulting event-centric design and general execution model appears to apply to more diverse event-driven monitoring and analysis applications. 
    </textual></para></section><bibliography class="po-hcontainer e298 e298"><title class="po-block e299 e299"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e300 e300" xml:id="wcfp06" xreflabel="RHAM06"><textual class="po-textual"> N. Russell, A.H.M. ter Hofstede, W.M.P. van der Aalst, and N. Mulyar. </textual><emphasis class="po-inline e301 e301" role="ital"><textual class="po-textual">Workflow Control-Flow Patterns: a Revised View</textual></emphasis><textual class="po-textual"> Technical report, BPM Center Report BPM-06-22 , </textual><link class="po-inline e302 e302" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.workflowpatterns.com/documentation/documents/BPM-06-22.pdf</textual></link><textual class="po-textual"> BPMcenter.org, 2006. 
    </textual></bibliomixed><bibliomixed class="po-block e303 e303" xml:id="wsi10" xreflabel="WSI10"><emphasis class="po-inline e304 e304" role="ital"><textual class="po-textual">WS-I Testing Tools V2 for Basic Profiles 1.2 and 2.0</textual></emphasis><textual class="po-textual">, Web Services Interoperability, 2010, </textual><link class="po-inline e305 e305" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ws-i.org/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e306 e306" xml:id="tag09" xreflabel="TAG09"><textual class="po-textual">Durand, J., Green, S., Kulvatunyou, S., and Rutt, T.; </textual><emphasis class="po-inline e307 e307" role="ital"><textual class="po-textual">Test assertions on steroids for XML artifacts </textual></emphasis><textual class="po-textual"> proceedings of "Balisage the markup conference"  </textual><link class="po-inline e308 e308" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/2009/Program.html </textual></link><textual class="po-textual"> August 2009
    </textual></bibliomixed><bibliomixed class="po-block e309 e309" xml:id="xtemp10" xreflabel="XTEMP10"><emphasis class="po-inline e310 e310" role="ital"><textual class="po-textual">XTemp: XML Testing and Event-driven Monitoring of Processes</textual></emphasis><textual class="po-textual">, Committee Specification Draft, OASIS, </textual><link class="po-inline e311 e311" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oasis-open.org/committees/download.php/41676/XTemp-1.0-csd01.pdf</textual></link><textual class="po-textual">, March 2011.
    </textual></bibliomixed><bibliomixed class="po-block e312 e312" xml:id="etsl07" xreflabel="ETSL07"><textual class="po-textual">Durand, J., Kulvatunyou,  S., Woo  J.,and Martin, M. ; </textual><emphasis class="po-inline e313 e313" role="ital"><textual class="po-textual">Testing and Monitoring E-Business using the Event-driven Test Scripting Language ;</textual></emphasis><textual class="po-textual"> proceedings I-ESA (Interoperability of Enterprise Systems and Applications), April 2007
    </textual></bibliomixed><bibliomixed class="po-block e314 e314" xml:id="wstb2b06" xreflabel="WSTB2B06"><textual class="po-textual">Jeong, B.; Woo, J.; Cho, H.; Kulvatunyou, B.; Lee, J. ; </textual><emphasis class="po-inline e315 e315" role="ital"><textual class="po-textual">A Web Service-based Reconfigurable Testbed for Business-to-Business (B2B) Integration</textual></emphasis><textual class="po-textual"> International Conference on Web Services (ICWS), </textual><link class="po-inline e316 e316" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.nist.gov/manuscript-publication-search.cfm?pub_id=822715</textual></link><textual class="po-textual"> September 2006
    </textual></bibliomixed><bibliomixed class="po-block e317 e317" xml:id="testHL7" xreflabel="TESTHL709"><textual class="po-textual">Namly, T., Aluc, G., Dogac, A. ; </textual><emphasis class="po-inline e318 e318" role="ital"><textual class="po-textual">An interoperability test framework for HL7-based systems ;</textual></emphasis><textual class="po-textual"> IEEE Trans Inf Technol Biomed. 2009 May;13(3):389-99.
    </textual></bibliomixed><bibliomixed class="po-block e319 e319" xml:id="wsbpel07" xreflabel="WSBPEL07"><emphasis class="po-inline e320 e320" role="ital"><textual class="po-textual">Web Services Business Process Execution Language Version 2.0;</textual></emphasis><textual class="po-textual"> OASIS standard, </textual><link class="po-inline e321 e321" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-OS.pdf</textual></link><textual class="po-textual">, April 2007.
    </textual></bibliomixed></bibliography></article></classedDocument>