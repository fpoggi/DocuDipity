<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Literate Programming: A Case Study and Observations</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">A newly revived interest in literate programming means that we need to look at what's been done in the past.  Literate Programming requires both the integration of computer programming code with its documentation, and the elimination of duplicate information between the code and the documentation.  It's the latter that has been overlooked in the past.  This paper describes a project that integrated programming code with its documentation, using a markup language, and discusses lessons that might be learned from it.  It also illustrates the use of, and discusses the advantages of using compact markup (as exemplified by SGML short references and Wiki markup) especially as it applies to using a markup language for literate programming.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Sam</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Wilmott</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Sam Wilmott started using markup languages in the late '60s. Since then he has led the development of typesetting/text-formatting systems for the Canadian Government Printing Office and for a major real-estate company, implemented one of the first SGML parsers (which was also the first pull-model markup parser), and is the originator of the </textual><xref class="po-milestone e14 e14" linkend="omnimark"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> programming language, with its strong support of SGML, XML, and text transformation.</textual></para><para class="po-block e15 e15"><textual class="po-textual">More recently Sam has been working the XSLT world: he has recently contributed to the implementation of an XSLT compiler and currently works as an XSLT programmer and analyst.  As a side project, he is working on new programming language ideas for markup language processing.</textual></para></personblurb><email class="po-field e16 e16"><textual class="po-textual">sam@wilmott.ca</textual></email></author><legalnotice class="po-container e17 e17"><para class="po-block e18 e18"><textual class="po-textual">Copyright Â© 2012 Sam Wilmott and Stilo International plc.</textual></para></legalnotice><keywordset class="po-table e19 e19" role="author"><keyword class="po-field e20 e20"><textual class="po-textual">Literate Programming</textual></keyword><keyword class="po-field e21 e21"><textual class="po-textual">Markup Language Implementation</textual></keyword><keyword class="po-field e22 e22"><textual class="po-textual">SGML</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">Short References</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">Wiki Markup</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">XML</textual></keyword></keywordset></info><section class="po-hcontainer e26 e26"><title class="po-block e27 e27"><textual class="po-textual">Why Literate Programming?</textual></title><para class="po-block e28 e28"><textual class="po-textual">First of all, I'd like to thank Stilo International</textual><footnote class="po-popup e29 e29"><para class="po-block e30 e30"><textual class="po-textual">Stilo International </textual><link class="po-inline e31 e31" xlink:actuate="onRequest" xlink:href="http://stilo.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://stilo.com</textual></link></para></footnote><textual class="po-textual"> for giving me access to some of their internal documents.  This paper wouldn't exist without their contribution.</textual></para><para class="po-block e32 e32"><xref class="po-milestone e33 e33" linkend="lp"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the integration of program code with its documentation, has been a feature of both the programming and the documentation fields for over thirty years.  It got off to a good start with </textual><xref class="po-milestone e34 e34" linkend="knuth"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> but there hasn't been a lot of new work in the field over most of the intervening decades.  However, now there seems to be a renewed interest in Literate Programming.  Why? you might ask.</textual></para><para class="po-block e35 e35"><textual class="po-textual">Integrating programming code and its documentation isn't just about having them in the same document, as was done in Knuth's WEB: it's about eliminating duplication of information coded in both programming and documentation forms. In contrast, and most commonly, programmers are continuing with the traditional model of completely separating code and its documentation.  The difficulty with this approach is that it duplicates a lot of information: information coded in a programming language and also written up in its documentation, as text or in tables.  The result is costly in three ways:</textual><itemizedlist class="po-table e36 e36"><listitem class="po-container e37 e37"><para class="po-block e38 e38"><textual class="po-textual">Doing so increases the amount of work required by the programmers and the documenters (who may be the same or different folk) to initially create and to later update the code and the documentation.</textual></para></listitem><listitem class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">Organizing multiple copies of information can itself increase the cost of developing, maintaining and managing programming code: there's more to do that way.</textual></para></listitem><listitem class="po-container e41 e41"><para class="po-block e42 e42"><textual class="po-textual">Most importantly, duplication increases the chances of error: rewriting a text description into code can result in an error, as can describing code using text.  Updating one can easily cause it to be out of step with the other, even when they were previously in step.</textual></para></listitem></itemizedlist></para><para class="po-block e43 e43"><textual class="po-textual">There's been a number of approaches taken to deal with these difficulties:</textual><itemizedlist class="po-table e44 e44"><listitem class="po-container e45 e45"><para class="po-block e46 e46"><textual class="po-textual">All production programming languages support integrating comments with code.  Comments are most commonly used to help the reader understand the details of why coding is done in a particular way.  Comments are also used to document how a program is to be used, but they don't make for good reading for the users, and force the user to read the code.</textual></para></listitem><listitem class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Many ways have been looked at for adding markup to program languages' comments, both </textual><xref class="po-milestone e49 e49" linkend="xml"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and non-XML (often wiki-like) markup.  This certainly improves things.  It means that the user documentation can be extracted from the programming code and repurposed for the user: a big help.</textual></para><para class="po-block e50 e50"><textual class="po-textual">Marked-up comments still have a problem, however: a lot of information needs to be duplicated, so that there's a "human" version of the information and a "computer" version of it too.  For example, the information in function/method headers needs to be available to and understood by both the user and the computer.</textual></para></listitem><listitem class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Taking things one more step further, there have been a few approaches to adding markup to a programming language's code itself, so that it can be used within the documentation without duplication.  This is where the future lies, what I'll be talking about here, and is something still in development.</textual></para></listitem></itemizedlist></para><para class="po-block e53 e53"><textual class="po-textual">There are a number of good papers at this conference already covering different aspects of this problem:</textual><itemizedlist class="po-table e54 e54"><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">"Code Up: Marking up Programming Languages and the winding road to an XML Syntax"</textual><footnote class="po-popup e57 e57"><para class="po-block e58 e58"><textual class="po-textual">David Lee, MarkLogic, "Code Up: Marking up Programming Languages and the winding road to an XML Syntax", to be presented at Balisage 2012, Wednesday 2:00pm.</textual></para></footnote><textual class="po-textual"> describes and analyzes various approaches, from simple commenting to a program that's all XML.</textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">"On XML Languages"</textual><footnote class="po-popup e61 e61"><para class="po-block e62 e62"><textual class="po-textual">Norman Walsh, MarkLogic, "On XML Languages", to be presented at Balisage 2012, Wednesday 2:45pm.</textual></para></footnote><textual class="po-textual"> describes both XML and "compact" (non-XML) syntaxes for existing W3C scripting languages, discussing the advantages and disadvantages of each approach.</textual></para></listitem><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">"Encoding Transparency: Literate Programming and Test Generation for Scientific Function Libraries"</textual><footnote class="po-popup e65 e65"><para class="po-block e66 e66"><textual class="po-textual">Mark Flood, Matthew McCormick and Nathan Palmer, Office of Financial Research, Department of the Treasury, "Encoding Transparency: Literate Programming and Test Generation for Scientific Function Libraries", to be presented at Balisage 2012, Wednesday 4:00pm.</textual></para></footnote><textual class="po-textual"> describes an XML-based approach to duplicating what was achieved with Donald Knuth's Literate Programming tools (his WEB targeting </textual><xref class="po-milestone e67 e67" linkend="tex"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).</textual></para></listitem></itemizedlist></para><para class="po-block e68 e68"><textual class="po-textual">This paper adds to the discussion in two ways:</textual><itemizedlist class="po-table e69 e69"><listitem class="po-container e70 e70"><para class="po-block e71 e71"><textual class="po-textual">It presents an existing system, integrating programming code and its documentation in a practical way.</textual></para></listitem><listitem class="po-container e72 e72"><para class="po-block e73 e73"><textual class="po-textual">It discusses further issues that have to be dealt with when designing languages and building tools for such a system.</textual></para></listitem></itemizedlist></para></section><section class="po-hcontainer e74 e74"><title class="po-block e75 e75"><textual class="po-textual">A Blast From The Past: A Case Study</textual></title><para class="po-block e76 e76"><textual class="po-textual">Back in the days when </textual><xref class="po-milestone e77 e77" linkend="sgml"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> was still new (when XML hadn't shown up yet), and when the </textual><xref class="po-milestone e78 e78" linkend="c"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> was still a practical language of choice for cross-platform tool development (when C was about the only language that ran uniformly on all major platforms, and when there were a much larger variety of machine architectures than there are in our now Intel-dominated world), I implemented one of the still-existing SGML parsers.  Almost uniquely, I think, the SGML parser is itself an SGML document.  (It helped a lot that it was the second SGML parser developed by the company, so that the first one could be used to initially process the second one.  Once the second SGML parser was well developed, it took over and was used to help processed itself.)</textual></para><para class="po-block e79 e79"><textual class="po-textual">The following examples are taken from the code of the SGML parser used in Stilo International's </textual><xref class="po-milestone e80 e80" linkend="omnimark"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> programming language.  This code has been in use for over twenty years, so it serves as a good example of "real world" markup-based literate programming.  The markup language used to markup the SGML parser's code is quite complex, but you'll get most of it's ideas from the following examples.</textual></para><para class="po-block e81 e81"><textual class="po-textual">In practice, the following program-oriented markup elements are included in otherwise common paragraph-level markup.</textual></para><para class="po-block e82 e82"><textual class="po-textual">Here's the header of the module processing SGML declarations (other than ENITY declarations)</textual><footnote class="po-popup e83 e83" xml:id="stilo"><para class="po-block e84 e84"><textual class="po-textual">Please note that the copyright information isn't just an example.  This code is copyright and extracted from the original code of the product (with some abbreviations to make it easier to present).  Stilo International has kindly allowed me to use snippets of it as examples in a public forum.</textual></para></footnote><textual class="po-textual">:</textual><programlisting class="po-block e85 e85" xml:space="preserve"><textual class="po-textual">
&lt;!-- xkdecl.doc: 

   Copyright (C) Stilo International plc, 1991 - 2011
   All Rights Reserved

   PROPRIETARY AND CONFIDENTIAL

  --&gt;
&lt;chapter&gt;Declarations
&lt;revinfo&gt;$Id: xkdecl.doc,v 1.83 2001/10/19 15:11:08 kernel Exp $
&lt;system&gt;kernel:XK
&lt;module defined&gt;decl &lt;!-- Declarations;--&gt;;
basic; mem; syn; lex; var; ent; mod; con; attr; edec; err; fsm1
&lt;cinclude&gt;xktypes.h
</textual></programlisting></para><para class="po-block e86 e86"><textual class="po-textual">It contains:</textual><itemizedlist class="po-table e87 e87"><listitem class="po-container e88 e88"><para class="po-block e89 e89"><textual class="po-textual">Importantly, copyright and distribution information.</textual><xref class="po-milestone e90 e90" linkend="stilo"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></para></listitem><listitem class="po-container e91 e91"><para class="po-block e92 e92"><textual class="po-textual">A chapter heading, both as a lead comment in the code and as a chapter start and title in the user's and programmer's documentation.</textual></para></listitem><listitem class="po-container e93 e93"><para class="po-block e94 e94"><textual class="po-textual">Revision information for the revision control system used at the time.  (For a stable piece of software such as this, it doesn't get updated often, as you can see.)</textual></para></listitem><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">Information about the system name, the used module name, what other modules are used, and what C include files are needed.</textual></para></listitem></itemizedlist></para><para class="po-block e97 e97"><textual class="po-textual">Data structures are documented rather than coded:</textual><programlisting class="po-block e98 e98" xml:space="preserve"><textual class="po-textual">
&lt;struct external&gt;document type definition
# The data structure which describes a document type definition (a "compiled"
  DTD) and which points to all the data structures for the objects declared
  for the document type definition. #
&lt;comment&gt;
The following fields provide information about specific features of
a document type.
&lt;/comment&gt;
=  document element: 'element definition'*
   # Pointer to the definition for the document element. #
=  default general entity: 'entity definition'*
   # Pointer to the default general entity. #
...
&lt;/struct&gt;
</textual></programlisting></para><para class="po-block e99 e99"><textual class="po-textual">Documentation of a structure as a whole as well as of each field is required.  The markup used for the fields of a structure is exactly the same as for an ordered list of labeled textual items: no distinction is made between the markup for documentation and for code.</textual></para><para class="po-block e100 e100"><textual class="po-textual">Structures, functions and other constructs have attributes specified with them that are meaningful either to the target code, the programmer's documentation, the user's documentation or two or more of these things.</textual></para><para class="po-block e101 e101"><textual class="po-textual">Global names are marked up (surrounded by apostrophes in code and by "at" signs in text), and are chosen to be appropriate for documentation.  The processing software replaces these names with the kinds of names required by the target language, together with appropriate prefixing.  This approach makes the code more portable between systems.</textual></para><para class="po-block e102 e102"><textual class="po-textual">Functions/methods have their interface information marked up as documentation:</textual><programlisting class="po-block e103 e103" xml:space="preserve"><textual class="po-textual">
&lt;function external&gt;initialize document type: 'boolean'
# Prepare for parsing a document instance. #
&lt;inout setself&gt;parsing_state: 'parsing state'*
&lt;in&gt;base_element: 'element definition'*
&lt;comment&gt;
This procedure prepares ~parsing_state~ to parse a document instance using the
current document type definition in ~parsing_state~.  Three options are
available for selecting what is to be parsed, depending on the value of
~base_element~, as follows:
&lt;ol&gt;
=  If ~base_element~ is the base document element of the document type (i.e.
the one named following the keyword DOCTYPE in the DTD), then the following
input text is parsed with that element as the document element (see
ISO 8879-1986, definition 4.99).
=  If ~base_element~ is any other element in the DTD, then that other element
is treated as if it were the document element for the purposes of parsing the
following input text.  This allows parts of documents to be parsed, such as a
single chapter.
=  If ~base_element~ is "null" (@element definition.null@), then the following
text may consist of any sequence of elements defined in the DTD.
&lt;/ol&gt;
   In the first two cases, @initialize document type@ sets the number of opened
elements to zero (0).
...
&lt;code&gt;
   &lt;return/'initialize parsing state generally'
                (parsing_state,
                 ('document type definition'*) 'document type definition.null',
                 base_element,
                 ('document syntax'*) 'document syntax.null',
                 ('document syntax'*) 'document syntax.null',
                 ('parsing state setup result'*) 0)/
&lt;/function&gt;
</textual></programlisting></para><para class="po-block e104 e104"><textual class="po-textual">Function arguments are documented both by text and by the markup of the argument.  Code in the body of a function is the one place where program code is used in preference to markup, for a number of reasons:</textual><itemizedlist class="po-table e105 e105"><listitem class="po-container e106 e106"><para class="po-block e107 e107"><textual class="po-textual">Dense code is generally easier to read in a more compact form.</textual></para></listitem><listitem class="po-container e108 e108"><para class="po-block e109 e109"><textual class="po-textual">The code is only used in two (potential) targets: the produced C code that was intended to be compiled, and in the annotated code documentation.</textual></para></listitem></itemizedlist></para><para class="po-block e110 e110"><textual class="po-textual">That said, there are exceptions to using a non-SGML form for code:</textual><itemizedlist class="po-table e111 e111"><listitem class="po-container e112 e112"><para class="po-block e113 e113"><textual class="po-textual">Constructs that impact a function's interface, such as "return" (but not things like "if") are marked up.</textual><footnote class="po-popup e114 e114"><para class="po-block e115 e115"><textual class="po-textual">I forget exactly why returns were marked up.  Oh well.</textual></para></footnote></para></listitem><listitem class="po-container e116 e116"><para class="po-block e117 e117"><textual class="po-textual">The big issue in choosing verbose markup or compact markup is in the trade-off of readability and utility.  This trade-off can be subjective -- different people with come to different conclusions, depending largely on what markup and other notations they are familiar with.</textual></para></listitem><listitem class="po-container e118 e118"><para class="po-block e119 e119"><textual class="po-textual">References to names in the software's interface, either of interest to the user or of global interest to the software's developers, are marked up, so that they can be easily found if needed.  One use of marked up marked-up names is an index of all uses of every name can be listed.</textual></para></listitem></itemizedlist></para><para class="po-block e120 e120"><textual class="po-textual">Using markup also means that things that are better coded as tables than as code, but which need to be run as code, can be included.  This was done in the SGML parser, by coding the syntactic parsing logic as a finite state machine (FSM).  For example, here's the logic for parsing an SGML end tag (in a somewhat abbreviated form):</textual><programlisting class="po-block e121 e121" xml:space="preserve"><textual class="po-textual">
   From Clause 7.5, End-tag:

&lt;fsm&gt;end-tag (TAG):
&amp;more;
=  name {end-tag}: +generic identifier specification
=  tagc {back over lexeme; check end-tag shorttag}: +checked shorttag
=  * {impossible}
#  checked shorttag
   {empty end-tag}: +generic identifier specification
#  generic identifier specification (TAG):
&amp;s;
=  tagc {end of end-tag: other prolog; end of tag}: content
=  stago no rhs, etago no rhs
   {back over lexeme; report missing end tag tagc missing;
    end of end-tag: other prolog; end of tag}: content
=  * {backup needed; 'unrecognized item'}: +unrecognized
#  unrecognized
   {end of end-tag: other prolog; end of tag}: content
&lt;/fsm&gt;
</textual></programlisting></para><para class="po-block e122 e122"><textual class="po-textual">Each entry has four parts: the thing or things being recognized, the lexical context in effect (i.e. what tokens are recognized, identified by a keyword such as "TAG"), the action to be taken when recognizing that thing (in curly braces), and what state in the state machine to go to next.  In particular:</textual><itemizedlist class="po-table e123 e123"><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">"#" introduces a sub-state and "+" prefixes a local reference to the next state.  Next states with no "+" prefix are major states, like "end-tag".</textual></para></listitem><listitem class="po-container e126 e126"><para class="po-block e127 e127"><textual class="po-textual">Substates need not recognize anything, but just do something, like "checked shorttag".</textual></para></listitem><listitem class="po-container e128 e128"><para class="po-block e129 e129"><textual class="po-textual">Groups of common actions are coded as entity references ("&amp;more;" and "&amp;s;").</textual></para></listitem></itemizedlist></para><para class="po-block e130 e130"><textual class="po-textual">Note that the above example is very heavily marked up: all of ( ) { } + = # ' and ; are compact markup (a.k.a. SHORTREFs).</textual></para><para class="po-block e131 e131"><textual class="po-textual">Actions in the FSM are marked up specially:</textual><programlisting class="po-block e132 e132" xml:space="preserve"><textual class="po-textual">
&lt;action value&gt;end tag
# Process an end tag containing an element name and signal the
change of context to the application. #
&lt;comment&gt;
The current lexical item is the name of the element.
@parsing state.selected element@ is to be made the definition of the element.
to the previous state after closing one element, or go to the alternate
state after having reported an error.
&lt;/comment&gt;
&lt;local&gt;element: 'element definition'*
&lt;local&gt;opened_element: 'opened element'*
&lt;code&gt;
   if (parsing_state-&gt;'parsing state.opened element count' &gt; 0)
      opened_element = parsing_state-&gt;'parsing state.opened element stack';
   else
      opened_element = 'opened element.null';
   if (!'look up element' (parsing_state,
                          parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item start',
                          ('integer')
                          (parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item end' -
                           parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item start'),
                          addr(element)))
   {
      parsing_state-&gt;'parsing state.selected element' =
                     'element definition.null';
      'report error' (parsing_state,
                      'exception code.undefined element in end tag');
      &lt;return//
   }
   parsing_state-&gt;'parsing state.selected element' = element;
   'create opened element' (parsing_state);
   'initiate closing current element' (parsing_state, opened_element);
&lt;/action&gt;
</textual></programlisting></para><para class="po-block e133 e133"><textual class="po-textual">Actions can be compiled as functions, with calls to them included in the FSM code, or they can be marked as a "macro", and included in-line.  The "value" attribute indicates that the action (potentially) returns a value to the invoking application.  This illustrates the use of markup not just for documentation purposes, but to make the coding simpler.</textual></para><para class="po-block e134 e134"><textual class="po-textual">The FSM markup language made it easy to create program code, and was easy to work with.  It greatly shortened the time of creating a high-performance SGML parser.</textual></para><para class="po-block e135 e135"><textual class="po-textual">Using SGML to help create an SGML parser had nothing, of course, to do with the fact that it was an SGML parser that was being developed using this technique.  However it did help to speed up development of the product in an otherwise inappropriate programming language: C.  One could also argue that it took someone with expertise in implementing and using SGML to perform both tasks.</textual></para><para class="po-block e136 e136"><textual class="po-textual">It's unclear whether this use of literate programming was a success or not:</textual><itemizedlist class="po-table e137 e137"><listitem class="po-container e138 e138"><para class="po-block e139 e139"><textual class="po-textual">It's use helped greatly in the project in which it was used.</textual></para></listitem><listitem class="po-container e140 e140"><para class="po-block e141 e141"><textual class="po-textual">It wasn't reused in later projects.</textual></para></listitem></itemizedlist></para><para class="po-block e142 e142"><textual class="po-textual">So an argument could be made both for success and for failure.</textual></para></section><section class="po-hcontainer e143 e143"><title class="po-block e144 e144"><textual class="po-textual">An Aside On Short References</textual></title><para class="po-block e145 e145"><textual class="po-textual">The work described in this paper makes extensive use of short references and illustrates how they can be useful.</textual></para><para class="po-block e146 e146"><textual class="po-textual">Another paper being presented at this conference, </textual><footnote class="po-popup e147 e147" xml:id="shortrefs"><para class="po-block e148 e148"><textual class="po-textual">Mario Blazevic, Stilo International, "Extending XML with SHORTREFs specified in RELAX NG", to be presented at Balisage 2012, Wednesday 4:45pm.</textual></para></footnote><textual class="po-textual"> describes a simplified mechanism for introducing the advantages of </textual><xref class="po-milestone e149 e149" linkend="wiki"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and SGML short references into XML.  As that paper correctly points out, it's not easy to get SGML short references right.  The difficulty is not so much compact markup its self -- it's in the mechanism for defining it, in the tool support for such markup, and in the quality of the documentation of such markup.  (If anything, it's in the later that the use of SGML short references failed most notably.)</textual></para><para class="po-block e150 e150"><textual class="po-textual">XML was designed and made different from SGML on the assumption that markup support tools, such as XML editors and XML exporting support in word processors, had or would develop to the point where users were no longer entering XML markup "by hand", but would use semi-automated tools for doing so.  This is true for a large class of users.  But there is also a large number of users entering XML tags using non-XML-specific editors: one major category of such being in programming language environments, where those languages have syntaxes in addition to that of XML.  To be effective user-helpful tools need to support multiple syntaxes, not just that of the programming language or languages used, or just XML, but all of them.</textual></para><para class="po-block e151 e151"><textual class="po-textual">One difficulty with using compact markup is that it's best used sparingly.  That is, only a small number of compact markup forms should be used in any particular context.  Successful Wiki Markup languages are a testament to this principle. Too many different compact forms results in confusion.  The classical paper on the subject is Miller's </textual><xref class="po-milestone e152 e152" linkend="mn7"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, which says that the limit on the number of usable forms (per context) is about 7 (plus or minus 2).</textual></para><para class="po-block e153 e153"><textual class="po-textual">At this stage in the development of markup languages, it doesn't seem to be a particularly controversial statement to say that the best use of fully-tagged and compact markup is in some combination of the two -- with the balance chosen based on the needs of a particular application.  One size does not fit all.  For an example, consider the mixture of fully-tagged XML and compact </textual><xref class="po-milestone e154 e154" linkend="xpath"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> that appear in most </textual><xref class="po-milestone e155 e155" linkend="xslt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> programs.</textual></para><para class="po-block e156 e156"><textual class="po-textual">There are a number of ways in which the advantages of compact markup can be realized in an XML context, including:</textual><itemizedlist class="po-table e157 e157"><listitem class="po-container e158 e158"><para class="po-block e159 e159"><textual class="po-textual">A general facility could be added to XML structure descriptors (DTD, schema, RELAX-NG, etc), maybe some up-dated form of short references as suggested in another paper here</textual><xref class="po-milestone e160 e160" linkend="shortrefs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for markup language developers to develop their own compact markup.</textual></para></listitem><listitem class="po-container e161 e161"><para class="po-block e162 e162"><textual class="po-textual">A similar facility could be created as a separate process, complementary to existing XML structure descriptors, that could be used with any of them, that for example, adds further element structure to a preexisting parsed XML tree based on discovered compact markup.</textual></para></listitem><listitem class="po-container e163 e163"><para class="po-block e164 e164"><textual class="po-textual">Some special-purpose compact markup could be supported as a separate process.  This approach would be appropriate if there were a limited number of applications of compact markup -- only for literate programming applications, for example -- and no need for a general approach.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e165 e165"><textual class="po-textual">The Literate Programming work described in this paper wouldn't have really been possible without the use of some form of compact markup to complement the primary markup (SGML or XML).  The level of detail would make full XML markup, for example, difficult to read, especially for programmers, whose primary interest is the programming code.</textual></para></section><section class="po-hcontainer e166 e166"><title class="po-block e167 e167"><textual class="po-textual">Another Aside, On The Kinds Of Documentation</textual></title><para class="po-block e168 e168"><textual class="po-textual">The SGML/C project described above supported four kinds of documentation that could be targeted by marked-up code and documentation:</textual><itemizedlist class="po-table e169 e169"><listitem class="po-container e170 e170"><para class="po-block e171 e171"><textual class="po-textual">User documentation: information for the end user of a software system.</textual></para></listitem><listitem class="po-container e172 e172"><para class="po-block e173 e173"><textual class="po-textual">Design documentation: information for helping maintain a software system, outlining the structure of the software and how it works</textual></para></listitem><listitem class="po-container e174 e174"><para class="po-block e175 e175"><textual class="po-textual">Fully annotated code: for use by those actually working with the code, detailing what, how and why is actually done.</textual></para><para class="po-block e176 e176"><textual class="po-textual">These three categories of documentation are incremental: generally speaking, design documentation includes everything the user is told, and annotated code includes all the user and design information.</textual></para></listitem><listitem class="po-container e177 e177"><para class="po-block e178 e178"><textual class="po-textual">Comments: There is some documentation that falls outside of any of the above categories: comments detailing the how and why of specific code snippets (rather than the more general techniques that apply to whole methods or other segments of code).  These comments are inseparable from the code they annotate, and seem to be best entered as language-specific comments rather than as marked-up documentation.  Unlike the above categories of documentation, these kinds of comments need no special handling.</textual></para></listitem></itemizedlist><textual class="po-textual">and of course, there's the code itself: what the programming language's compiler needs to be given.  In practice there can be more than one kind of code:</textual><itemizedlist class="po-table e179 e179"><listitem class="po-container e180 e180"><para class="po-block e181 e181"><textual class="po-textual">The "production" code, that appears in the final product.  There can be multiple products, or multiple versions of a product, originating in one set of code.</textual></para></listitem><listitem class="po-container e182 e182"><para class="po-block e183 e183"><textual class="po-textual">In addition, code can exist as part of the software development process, with lots of extra checks and reports.</textual></para></listitem></itemizedlist><textual class="po-textual">Markup can effectively distinguish between different versions and kinds of code.</textual></para><para class="po-block e184 e184"><textual class="po-textual">So there's at least four kinds of things created from marked-up code: user, design and annotated code documentation, and the compiler's code.</textual></para></section><section class="po-hcontainer e185 e185"><title class="po-block e186 e186"><textual class="po-textual">A Literate Programming Markup Language As A New Language</textual></title><para class="po-block e187 e187"><textual class="po-textual">Adding comments to program code doesn't change the programming language used in any way.  It remains the same programming language plus comments.  But once major programming language constructs, such as data structure declarations and function headings, are replaced by documentation-friendly markup, we find ourselves looking at different programming language.</textual></para><para class="po-block e188 e188"><textual class="po-textual">At what point changing the syntax of a programming language makes it a different language depends largely on one's point of view.  From the point of view of the programming language designer, syntax is a minor issue: functionality is their focus.  From the point of view of the language user syntax is just about everything: it's important how to code an "if" statement, even though it's semantics is more-or-less the same in every programming language.  As a consequence, any useful definition of what constitutes a programming language, and the extent to which two are the same, has got to take syntax into account.</textual></para><para class="po-block e189 e189"><textual class="po-textual">A major impediment to acceptance of a literate programming language is the fact that it is a different language.  It's not the programming language that a programmer knows, and switching over is not a small job.  And I'm afraid to say that I've found computer programmers in general very conservative in what languages they are willing to work with: they generally stick with what they know.  A major selling job is needed to convince programmers to switch.</textual></para><para class="po-block e190 e190"><textual class="po-textual">It being a different language than what programmers were used to seems to be a large part of the reason that the SGML/C-based programming language described in this paper failed.  It may well be for other reasons: lack of promotion of the language, or a well-established base of other software that management and the programmers didn't want to change.  These things have to be taken into consideration when developing a new language, to ensure its better acceptance.</textual></para></section><section class="po-hcontainer e191 e191"><title class="po-block e192 e192"><textual class="po-textual">Conclusions And Observations</textual></title><para class="po-block e193 e193"><textual class="po-textual">Literate Programming is something that clearly needs more work:</textual><itemizedlist class="po-table e194 e194"><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">More use of Literate Programming needs to be undertaken so that useful ideas can be developed.  If nobody does it, it's not going to happen.</textual></para></listitem><listitem class="po-container e197 e197"><para class="po-block e198 e198"><textual class="po-textual">Markup conventions for Literate Programming need to be developed, either with respect to a particular programming language, or which apply to a variety of programming languages.  There is not going to be general acceptance of Literate Programming if every language or, worse yet, every system has its own set of conventions.</textual></para><para class="po-block e199 e199"><textual class="po-textual">As noted earlier, the trade-offs between full and compact markup are somewhat subjective.  As a consequence, these conventions will need to be arbitrary.  And that has to be accepted.</textual></para></listitem><listitem class="po-container e200 e200"><para class="po-block e201 e201"><textual class="po-textual">Literate Programming tools need to be integrated into software development systems.  At present, Literate Programming is usually implemented as a preprocessor.  But this doesn't fit well with most visual software development systems, or with the expectations of most programmers.</textual></para></listitem><listitem class="po-container e202 e202"><para class="po-block e203 e203"><textual class="po-textual">The use of compact markup in XML documents needs to be researched further.  Whether XML itself needs to be extended to support compact, whether that can best be done outside of XML, or whether it's unwise to try either needs to be reexamined.</textual></para></listitem></itemizedlist></para><para class="po-block e204 e204"><textual class="po-textual">Markup-based Literate Programming gives us the opportunity to bring the advantages of markup in general, and XML in particular, to a wider community.  More than any new programming language feature -- which language designers are always on the lookout for -- better and more reliable documentation could make a difference to how computer programmers work.  But it's not a small task: it's as big as developing a whole new programming langauge.</textual></para></section><bibliography class="po-hcontainer e205 e205"><title class="po-block e206 e206"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e207 e207" xml:id="c" xreflabel="C programming language"><textual class="po-textual">Home page of ISO/IEC JTC1/SC22/WG14 - C </textual><link class="po-inline e208 e208" xlink:actuate="onRequest" xlink:href="http://www.open-std.org/jtc1/sc22/wg14" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.open-std.org/jtc1/sc22/wg14</textual></link></bibliomixed><bibliomixed class="po-block e209 e209" xml:id="knuth" xreflabel="Knuth's WEB System"><textual class="po-textual">Donald E. Knuth, Literate Programming </textual><link class="po-inline e210 e210" xlink:actuate="onRequest" xlink:href="http://www.literateprogramming.com/knuthweb.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.literateprogramming.com/knuthweb.pdf</textual></link></bibliomixed><bibliomixed class="po-block e211 e211" xml:id="lp" xreflabel="Literate Programming"><textual class="po-textual">Literate Programming Web Site </textual><link class="po-inline e212 e212" xlink:actuate="onRequest" xlink:href="http://www.literateprogramming.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.literateprogramming.com</textual></link></bibliomixed><bibliomixed class="po-block e213 e213" xml:id="mn7" xreflabel="The Magical Number Seven"><textual class="po-textual">George A. Miller, Harvard University, "The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information" </textual><link class="po-inline e214 e214" xlink:actuate="onRequest" xlink:href="http://www.psych.utoronto.ca/users/peterson/psy430s2001/Miller%20GA%20Magical%20Seven%20Psych%20Review%201955.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.psych.utoronto.ca/users/peterson/psy430s2001/Miller GA Magical Seven Psych Review 1955.pdf</textual></link></bibliomixed><bibliomixed class="po-block e215 e215" xml:id="omnimark" xreflabel="OmniMark"><textual class="po-textual">OmniMark Developer Resources </textual><link class="po-inline e216 e216" xlink:actuate="onRequest" xlink:href="http://developers.omnimark.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://developers.omnimark.com</textual></link></bibliomixed><bibliomixed class="po-block e217 e217" xml:id="sgml" xreflabel="SGML"><textual class="po-textual">Standard Generalized Markup Language (SGML) </textual><emphasis class="po-inline e218 e218" role="ital"><textual class="po-textual">International Organization for Standardization</textual></emphasis><textual class="po-textual"> ISO 8879:1986</textual></bibliomixed><bibliomixed class="po-block e219 e219" xml:id="tex" xreflabel="TeX"><textual class="po-textual">TeX Users Group </textual><link class="po-inline e220 e220" xlink:actuate="onRequest" xlink:href="http://www.tug.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tug.org</textual></link></bibliomixed><bibliomixed class="po-block e221 e221" xml:id="wiki" xreflabel="Wiki Markup"><textual class="po-textual">Wikipedia Wiki Markup Help page </textual><link class="po-inline e222 e222" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Help:Wiki_markup" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Help:Wiki_markup</textual></link></bibliomixed><bibliomixed class="po-block e223 e223" xml:id="xml" xreflabel="XML"><textual class="po-textual">Extensible Markup Language (XML) 1.1 (Second Edition) </textual><link class="po-inline e224 e224" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml11" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml11</textual></link></bibliomixed><bibliomixed class="po-block e225 e225" xml:id="xpath" xreflabel="XPath"><textual class="po-textual">XML Path Language (XPath) 3.0 </textual><link class="po-inline e226 e226" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-30</textual></link></bibliomixed><bibliomixed class="po-block e227 e227" xml:id="xslt" xreflabel="XSLT"><textual class="po-textual">XSL Transformations (XSLT) </textual><link class="po-inline e228 e228" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt</textual></link></bibliomixed></bibliography></article></classedDocument>