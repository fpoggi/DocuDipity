<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">XDML - an extensible markup language and processor for XDM</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2011</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 2 - 5, 2011</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">
        XDML is a set of rules how XDM values can be built which are more 
        useful entities as compared to ordinary XDM values. The key idea is to insert
        into the XDM values control information which guides the interpretation and
        processing of the data. In particular, it structures the XDM value into
        named parts and associates these parts with metadata. The control
        information is evaluated by an XDML processor, which reports and processes
        the data accordingly. The processing of a part is organized as the execution
        of operations which the control data bind to the part, but whose actual
        invocation depends on API calls of the XDML user. The bindings are 
        represented by request messages which encode the actual input to operations 
        selected from an extensible library of available "XDML operations".
        The operation bindings of a part can be regarded as a specific interface 
        dynamically attached to the data of the part. The net result
        of this approach is to enable the creation of self-describing XDM values: they encode
        the way how they are presented to applications, as well as how they
        should or might be processed. This means that the
        XDM producer - e.g. XQuery programs - can emit "rich" data whose downstream 
        processing is significantly simplified. 
      </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Hans-Jürgen</textual></firstname><othername class="po-field e11 e11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></othername><surname class="po-field e12 e12"><textual class="po-textual">Rennau</textual></surname></personname><personblurb class="po-container e13 e13"><para class="po-block e14 e14"><textual class="po-textual">Hans-Jürgen Rennau works as a software developer for bits GmbH (Büro für Informations-Technologie und Software). He takes a keen interest in the integration of object-oriented and “item-oriented” (XML) components of behavior and components of information. Hans-Jürgen's background as a biologist partly accounts for his belief that the naturalness of a thought is important to its potential. A natural integration of two natural approaches — OO and XML — is what he strives for in theory and practice.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Senior programmer</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">bits - Büro für Informations-Technologie und Software GmbH</textual></orgname></affiliation><email class="po-field e18 e18"><textual class="po-textual">hrennau@yahoo.de</textual></email></author><author class="po-record e19 e19"><personname class="po-record e20 e20"><firstname class="po-field e21 e21"><textual class="po-textual">David</textual></firstname><othername class="po-field e22 e22"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></othername><surname class="po-field e23 e23"><textual class="po-textual">Lee</textual></surname></personname><personblurb class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">David Lee has over 25 years experience in the software industry responsible for many major projects in small and large companies including Sun Microsystems, IBM, Centura Software (formerly Gupta), Premenos, Epiphany (formerly RightPoint), WebGain, Nexstra, Epocrates. As senior principal software engineer at Epocrates, Inc., Mr Lee is responsible for managing data integration, storage, retrieval, and processing of clinical knowledge databases for the leading clinical information provider.</textual></para><para class="po-block e26 e26"><textual class="po-textual">Key career contributions include Real-time AIX OS extensions for optimizing transmission of real-time streaming video (IBM), secure encrypted EDI over internet email (Premenos), porting the Centura Team Desktop system to Solaris (Gupta, Centura), optimizations of large Enterprise CRM systems (Epiphany), author of xmlsh (http://www.xmlsh.org) an open source scripting language for XML.</textual></para></personblurb><affiliation class="po-record e27 e27"><jobtitle class="po-field e28 e28"><textual class="po-textual">Senior Principal Software Engineer</textual></jobtitle><orgname class="po-block e29 e29"><textual class="po-textual">Epocrates, Inc.</textual></orgname></affiliation><email class="po-field e30 e30"><textual class="po-textual">dlee@epocrates.com </textual></email></author><legalnotice class="po-container e31 e31"><para class="po-block e32 e32"><textual class="po-textual">Copyright © 2011 by the authors. Used with permission.</textual></para></legalnotice><keywordset class="po-table e33 e33" role="author"><keyword class="po-field e34 e34"><textual class="po-textual">XDML</textual></keyword><keyword class="po-field e35 e35"><textual class="po-textual">XDM</textual></keyword><keyword class="po-field e36 e36"><textual class="po-textual">XProc</textual></keyword><keyword class="po-field e37 e37"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e38 e38"><textual class="po-textual">XSLT</textual></keyword></keywordset></info><section class="po-hcontainer e39 e39" xml:id="introduction"><title class="po-block e40 e40"><textual class="po-textual">Introduction</textual></title><para class="po-block e41 e41"><textual class="po-textual">
      XDM [</textual><xref class="po-milestone e42 e42" linkend="W3C-XDM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is the data model of the major XML processing languages – XPath, XQuery 
      and XSLT. The model is marked by a bold simplicity: (a) every value is a sequence of items, 
      (b) an item is either an XML node or an atomic value, (c) there are seven kinds of XML 
      nodes and  (d) a few dozens atomic types. This means that the size and complexity of an 
      XDM value is virtually unlimited, and at the same time that any value can be decomposed 
      into a linear sequence of building blocks, the items. "XDM item" is an abstraction enabling 
      us to regard a single byte and a huge XML document as just two instances of the same building block.
    </textual></para><para class="po-block e43 e43"><textual class="po-textual">
      One can look at the XDM from three different perspectives. The first one regards XDM as a 
      component of those processing languages, concerning only writers of XPath expressions, 
      XQuery scripts or XSLT stylesheets. We suspect that the majority of software developers 
      and architects would subscribe to this view.
    </textual></para><para class="po-block e44 e44"><textual class="po-textual">
      The second perspective takes into account that input and output of those languages is 
      also XDM and accepts the XDM as a player in the game of process integration. This 
      perspective pays attention to the issue of translating information back and forth 
      between XDM values and other data models, for example the data models of general 
      purpose programming languages. It should also take an interest in the 
      serialization of XDM values.
    </textual></para><para class="po-block e45 e45"><textual class="po-textual">
      A third perspective makes a step from looking at the XDM as either a local affair 
      of specialized languages or a challenge for data mapping. This new perspective regards 
      the XDM as the foundation for building a new kind of resource, offering some particular 
      advantages in comparison to other resource types – e.g. XML documents, relational tables 
      or CSV files. At the same time it gives a boost to XQuery, as XQuery 
      is the XDM producer par excellence. Increased importance of XDM means increased importance 
      of XQuery.
    </textual></para><para class="po-block e46 e46"><textual class="po-textual">
      Ironically, the key step toward a new appreciation of the XDM is awareness of its 
      fundamental limitation: there is no structure – only a flat sequence of items; there 
      is no meta information – only items and nothing else. An XDM value has something in 
      common with a string – no limitation of size and complexity, but unless a creative 
      step is taken there is no general way how to impose and detect a structure (above the level
      of its building blocks, that is). 
      Concerning strings, the creative step was the invention of markup: divide the sequence 
      of atoms (characters) into sections of primary information and those of meta information, 
      the latter also known as markup. One might consider doing something equivalent with XDM 
      values, where the atoms are XDM items, rather than characters. We want to explore the 
      potential of such an approach. Based on prior experimental work, we propose 
      a simple markup language and an infrastructure evaluating it.
      A prototypic reference implementation is a work in 
      progress, and our main intent is to open a discussion.
    </textual></para></section><section class="po-hcontainer e47 e47" xml:id="why-ask-for-xdm"><title class="po-block e48 e48"><textual class="po-textual">Why ask for XDM (if we have XML)?</textual></title><para class="po-block e49 e49"><textual class="po-textual">
      Let us assume a consumer’s perspective. Scenario: some processing 
      yields a result. This might be an XML document, a sequence of XML documents, 
      or an XDM value. The last alternative is clearly the most general one, as 
      any sequence of XML documents is an XDM value. But do we really need this 
      alternative, if we consider the expressiveness of XML?
    </textual></para><para class="po-block e50 e50"><textual class="po-textual">
      From a theoretical point of view, the answer is "no": whatever you can encode as an XDM value you 
      can translate 1:1 into an equivalent representation consisting of a single 
      XML document. For example, the following rules would suffice: (a) 
      the XDM items are represented by children of the document element; (b) 
      a dedicated type attribute on these children encodes the item type. 
      Clearly - XDM values cannot express more than a 
      single XML document, if some simple conventions are accepted. 
      We turn to the practical side and consider the </textual><emphasis class="po-inline e51 e51" role="ital"><textual class="po-textual">
      usage</textual></emphasis><textual class="po-textual"> of the results. 
      Can XDM under certain circumstances provide more convenient access to the 
      units we need, or can it deliver units which are a closer fit to
      what is actually needed?
    </textual></para><para class="po-block e52 e52"><textual class="po-textual">
       </textual><emphasis class="po-inline e53 e53" role="ital"><emphasis class="po-inline e54 e54" role="bold"><textual class="po-textual">Atomic values</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e55 e55"><textual class="po-textual">
      A striking difference between XML and XDM is that the latter supports 
      atomic values. This is a concrete advantage: if the desired result 
      is one or several atomic values, then XDM can explicitly deliver 
      them as such, whereas in the case of an XML result they must be 
      extracted. Extraction requires knowledge about the result document
      structure and involves non-trivial instruments like 
      an XPath or DOM API. A further drawback of the XML variant is 
      computational overhead. Conclusion: in cases where the result 
      consists wholly of atomic values, XDM is probably the more 
      suitable format.
    </textual></para><para class="po-block e56 e56"><textual class="po-textual">
       </textual><emphasis class="po-inline e57 e57" role="ital"><emphasis class="po-inline e58 e58" role="bold"><textual class="po-textual">Collection-like data</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e59 e59"><textual class="po-textual">
      The second difference between XML documents and XDM values is that documents are 
      logical </textual><emphasis class="po-inline e60 e60" role="ital"><textual class="po-textual">trees</textual></emphasis><textual class="po-textual"> within which everything is 
      related to everything; whereas an XDM 
      value is a </textual><emphasis class="po-inline e61 e61" role="ital"><textual class="po-textual">collection</textual></emphasis><textual class="po-textual"> of independent entities. 
      What if the result is just that, 
      conceptually, a collection? Then the main concern is fast and convenient access 
      to the individual parts, as well as the possibility to process them – e.g. 
      update them – in safe isolation. Typical examples for collection-like results are:
      </textual><itemizedlist class="po-table e62 e62"><listitem class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">a heterogeneous result, the parts of which are used in different ways</textual></para></listitem><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">a large result, only selected parts of which are used</textual></para></listitem></itemizedlist><textual class="po-textual">
      So the need for differential or selective processing calls for a collection-like 
      result. Arrays and maps come to mind, supporting index or name based access to 
      self-contained units. As we have seen, it is easy to mimic 
      collections with XML documents. This amounts to an "XML-as-a-container" approach. 
      Under many circumstances, this may be a perfect solution. But there are issues 
      that may become important:
      </textual><itemizedlist class="po-table e67 e67"><listitem class="po-container e68 e68"><para class="po-block e69 e69"><textual class="po-textual">the access to parts is XPath-based, rather than name- or index-based</textual></para></listitem><listitem class="po-container e70 e70"><para class="po-block e71 e71"><textual class="po-textual">the whole result tree must be constructed in memory (unless streaming processing is used)</textual></para></listitem><listitem class="po-container e72 e72"><para class="po-block e73 e73"><textual class="po-textual">local modification of the result means updating a large document</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e74 e74"><textual class="po-textual">
      XPath-based access is inconvenient, compared to name- or index-based access. It may 
      also be less efficient. The need to construct the whole result tree is a real drawback 
      </textual><emphasis class="po-inline e75 e75"><textual class="po-textual">if</textual></emphasis><textual class="po-textual"> such a construction is not required for other reasons 
      anyway. This must not be the case. If the result is available in serialized form, 
      then it makes a big difference if the whole result must be turned into an 
      in-memory tree, or if small, independent parts can be located and selectively 
      expanded. And the required parsing may be extremely fast if the parser is 
      able to locate the desired parts without parsing the details of the preceding parts.
    </textual></para><para class="po-block e76 e76"><textual class="po-textual">
      Is XDM a good alternative? Not or not yet. The lack of structure and metadata turn 
      XDM into an awkward format: it resembles a Java array of type </textual><code class="po-atom e77 e77"><textual class="po-textual">Object[]</textual></code><textual class="po-textual">. 
      And there 
      is not yet a serialization format available, let alone a parser to read such a 
      format. If XDM is to excel as a collection-like format, these problems – no 
      structure, no metadata, no serialization – would have to be solved.
    </textual></para><para class="po-block e78 e78"><textual class="po-textual">
       </textual><emphasis class="po-inline e79 e79" role="ital"><emphasis class="po-inline e80 e80" role="bold"><textual class="po-textual">Updatable result</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e81 e81"><textual class="po-textual">
      In pipelined processing, it is a common requirement to receive the result of a 
      preceding step, modify it locally and pass it on to the next step. If the result 
      is a collection of self-contained parts, such local updating is easier in several 
      aspects, compared to the updating of a monolithic document. XDM looks promising 
      for such purposes, but the difficulty of selective access – no structure, no 
      metadata – reduces the attractiveness.
    </textual></para><para class="po-block e82 e82"><textual class="po-textual">
       </textual><emphasis class="po-inline e83 e83" role="ital"><emphasis class="po-inline e84 e84" role="bold"><textual class="po-textual">Continuous result</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e85 e85"><textual class="po-textual">
      Some resources grow continuously by appending more data. Log data are the classical 
      example. Such data, as any other data, may be desired to be XML, so as to enable 
      XML processing. But continuous resources must not be an XML document, as it is impossible to 
      append data to a document, they must be inserted, which is much more difficult. 
      In this case, XDM (a lossless serialization provided) is an obvious solution, 
      as you can append items to an XDM value without difficulty.
    </textual></para><para class="po-block e86 e86"><textual class="po-textual">
       </textual><emphasis class="po-inline e87 e87" role="ital"><emphasis class="po-inline e88 e88" role="bold"><textual class="po-textual">Result as an XDM provider</textual></emphasis></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e89 e89"><textual class="po-textual">
      XDM is the input format for XPath, XQuery and XSLT. In pipelined processing, one 
      step might produce a result which provides XDM input for another step – either 
      the value as a whole is used, or one or more subsequences of it. In this scenario, 
      an XDM result is convenient and natural. Dependent on the type of the required 
      input XDM , an XDM result may be a better alternative than an XML result.
    </textual></para><para class="po-block e90 e90"><textual class="po-textual">
      We draw a conclusion: 
      XML documents should not be the only option for encoding the result of XML 
      processing. No native representation of atomic values, the tight coupling implied 
      by overall tree structure and the inability for plain appending must not be ignored. 
      XDM is an interesting alternative, as it is a superset of XML and 
      addresses those issues. But XDM is, as we said, an awkward format due to lack 
      of structure and metadata. Thus we came to explore the possibility of 
      </textual><emphasis class="po-inline e91 e91" role="ital"><textual class="po-textual">augmenting</textual></emphasis><textual class="po-textual"> XDM: add to it control information 
      which imparts structure and enriches the data with metadata. The goal is to 
      combine XDM’s built-in advantages – support for atomic values, collection-like 
      nature, being appendable and being a natural XDM provider – with structure and 
      metadata enabling convenient and guided access to the contents, as well as 
      simplified processing. 
    </textual></para></section><section class="po-hcontainer e92 e92" xml:id="xdm-structure"><title class="po-block e93 e93"><textual class="po-textual">XDM structure</textual></title><section class="po-hcontainer e94 e94" xml:id="partitioning-an-xdm-value"><title class="po-block e95 e95"><textual class="po-textual">Partitioning an XDM value</textual></title><para class="po-block e96 e96"><textual class="po-textual">
      Consider the situation that an XDM value should convey two code lists, each one 
      represented by a sequence of string items. XDM offers no way to tell where one 
      list ends and the other begins. Similar example: the XDM value is a sequence of 
      XML documents which represent the log data gathered during one hour - how to 
      identify the subsequence corresponding to one day of operation?
      A quick and simple solution is to insert into the XDM 
      value additional items which delimit subsequences. These items can be regarded 
      as </textual><emphasis class="po-inline e97 e97" role="ital"><textual class="po-textual">control items</textual></emphasis><textual class="po-textual">, to be distinguished from the 
      original data items. The subsequences are parts of the XDM value which have been 
      turned into new units of information. In order to give names to these parts,
      we add a "name" attribute to the respective control item. Example:
    </textual></para><para class="po-block e98 e98"><textual class="po-textual">
      </textual><programlisting class="po-block e99 e99" xml:space="preserve"><textual class="po-textual">
&lt;xm:part xmlns:xm=”http://www.xdml.org/ns” name=”alpha-codes”/&gt;,
a001,
a005,
a012,

&lt;xm:part xmlns:xm=”http://www.xdml.org/ns” name=”beta-codes”/&gt;,
b002,
b003
</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e100 e100"><textual class="po-textual">
      And if the uniqueness of part names is not guaranteed, an optional "partID"
      attribute may accompany the mandatory "name" attribute.
    </textual></para></section><section class="po-hcontainer e101 e101" xml:id="Imposing-tree-structure"><title class="po-block e102 e102"><textual class="po-textual">Imposing tree structure</textual></title><para class="po-block e103 e103"><textual class="po-textual">
      The shown use of control items defines parts of an XDM value in an intuitive way: 
      the contents of a part is simply all items following the part definition and 
      preceding the next part definition, or all following items, if this was the last
      part definition. But we might also allow "complex parts" - parts containing
      parts, to be distinguished from simple parts which contain only data items. To
      encode this structural model, we choose a simple rule: the contents of a complex part 
      ends before an item explicitly "closing" the part, whereas the contents of a 
      simple part is delimited implicitly: it ends before the next control
      item defining a new part (simple or complex) or closing the surrounding complex 
      part. Note that these parts - simple or complex - are defined in a "streaming" 
      fashion - contents are not children, but a subsequence of items delimited by 
      an item recognized as start point and another item explicitly or implicitly 
      meaning an end point (or the end of the XDM value, as a special case). 
    </textual></para><para class="po-block e104 e104"><textual class="po-textual">
      In order to keep things simple, we constrain the definition of complex parts: 
      they must not contain data items outside of contained parts. In other words: 
      parts must not be mixed, their content is either a sequence of data items, 
      or a sequence of parts which may be simple or complex. An example using
      complex parts:
    </textual></para><para class="po-block e105 e105"><textual class="po-textual">
      </textual><note class="po-container e106 e106"><title class="po-block e107 e107"><textual class="po-textual">Leaving out namespace declarations</textual></title><para class="po-block e108 e108"><textual class="po-textual">
          For brevity, all further examples will leave out the namespace declaration  xmlns:xm=”http://www.xdml.org/ns".
        </textual></para></note><textual class="po-textual">
      </textual><programlisting class="po-block e109 e109" xml:space="preserve"><textual class="po-textual">
&lt;xm:complexPart name="code-lists"/&gt;,
&lt;xm:part name="alpha-codes"/&gt;,
a001,
a005,
a012,
&lt;xm:part name="beta-codes"/&gt;,
b002,
b003,
&lt;xm:complexPartEnd/&gt;,

&lt;xm:complexPart name="logs"/&gt;,
&lt;xm:part name="log0800" /&gt;,
&lt;log&gt;...&lt;/log&gt;,
&lt;xm:part name="log0900" /&gt;,
&lt;log&gt;...&lt;/log&gt;,
&lt;xm:complexPartEnd/&gt; 
</textual></programlisting><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e110 e110" xml:id="concept-information-units"><title class="po-block e111 e111"><textual class="po-textual">Concept: Information units</textual></title><para class="po-block e112 e112"><textual class="po-textual">
       We have seen how the insertion of control items can partition an XDM value 
       into parts. To denote the concept of such parts we introduce the term 
       </textual><emphasis class="po-inline e113 e113" role="ital"><textual class="po-textual">information unit</textual></emphasis><textual class="po-textual">. An information unit
       is encoded by a sequence of XDM items. According to whether whose items
       represent nested units, two kinds of information units
       are distinguished. A
       </textual><emphasis class="po-inline e114 e114" role="ital"><textual class="po-textual">simple</textual></emphasis><textual class="po-textual"> information unit contains only data 
       items, but not any nested information units. A </textual><emphasis class="po-inline e115 e115" role="ital"><textual class="po-textual">
       complex</textual></emphasis><textual class="po-textual"> information unit, on the other hand, contains other 
       information units, but no data items outside of nested units.
     </textual></para><para class="po-block e116 e116"><textual class="po-textual">
       An information unit has the following properties:
       </textual><itemizedlist class="po-table e117 e117"><listitem class="po-container e118 e118"><para class="po-block e119 e119"><textual class="po-textual">a name</textual></para></listitem><listitem class="po-container e120 e120"><para class="po-block e121 e121"><textual class="po-textual">a part ID (optional)</textual></para></listitem><listitem class="po-container e122 e122"><para class="po-block e123 e123"><textual class="po-textual">metadata (optional)</textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">value</textual></para></listitem></itemizedlist><textual class="po-textual">
       Name and part ID we constrain to be a QName and NCName, respectively; 
       metadata are introduced in the next section. The value is 
       </textual><itemizedlist class="po-table e126 e126"><listitem class="po-container e127 e127"><para class="po-block e128 e128"><textual class="po-textual">a sequence of data items - in the case of a simple unit</textual></para></listitem><listitem class="po-container e129 e129"><para class="po-block e130 e130"><textual class="po-textual">an unordered collection of information units - in the case of a complex unit</textual></para></listitem></itemizedlist><textual class="po-textual">
     </textual></para><para class="po-block e131 e131"><textual class="po-textual">
       Note that this definition renders the sequence of nested information units irrelevant, as these
       units are associated with names. This corresponds to the modeling practice of XML 
       attributes or JSON members.
     </textual></para></section></section><section class="po-hcontainer e132 e132" xml:id="xdm-metadata"><title class="po-block e133 e133"><textual class="po-textual">XDM metadata</textual></title><section class="po-hcontainer e134 e134" xml:id="adding-metadata"><title class="po-block e135 e135"><textual class="po-textual">Why and how add metadata?</textual></title><para class="po-block e136 e136"><textual class="po-textual">
      We saw that control items may structure XDM values 
      into information units, which are groups of items or of other information units. 
      These units are entities 
      which do not exist in XDM values without control items. Often they will
      serve as units of processing, and it is reasonable to
      expect that different units may be subjected to different processing.
      Such considerations suggest the usefulness of metadata.
    </textual></para><para class="po-block e137 e137"><textual class="po-textual">
      In fact, it is very simple to associate the units with as many metadata 
      as one would like. Every unit is preceded by a control item which amounts to
      a convenient container where to place those metadata, either as attributes 
      or as child elements. Come to think of it, the control item can be regarded 
      as a full-scale XML document which is still hardly constrained in its 
      contents: only the name of the root element and the use of a "name" and a
      "partID" attribute are specified, so far. This document is dedicated to defining
      a unit, and it is ready to be filled with metadata describing the unit.
    </textual></para><para class="po-block e138 e138"><textual class="po-textual">
      Returning to the example given above, the units containing a single document of 
      log data may be associated with metadata "startTime" and "devices". 
      To accommodate such data, we can use attributes and child elements of the markup 
      item, like so:
    </textual></para><para class="po-block e139 e139"><textual class="po-textual">
      </textual><programlisting class="po-block e140 e140" xml:space="preserve"><textual class="po-textual">
&lt;xm:complexPart name="logs"/&gt;,

&lt;xm:part name="log0800" xmlns:e=”e.com” e:startTime="2010-12-30T08:00:00" xmlns:e="http://example.com"&gt;
   &lt;e:devices&gt;…&lt;/e:devices&gt;
&lt;/xm:part&gt;,
&lt;log&gt;...&lt;/log&gt;, 

&lt;xm:part name="log0900" xmlns:e=”e.com” e:startTime="2010-12-30T09:00:00" xmlns:e="http://example.com"&gt; 
   &lt;e:devices&gt;…&lt;/e:devices&gt;
&lt;/xm:part&gt;,
&lt;log&gt;...&lt;/log&gt;,

&lt;xm:complexPartEnd/&gt;
</textual></programlisting><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e141 e141" xml:id="a-component-model-of-metadata"><title class="po-block e142 e142"><textual class="po-textual">A model of metadata</textual></title><para class="po-block e143 e143"><textual class="po-textual">
        We have arrived at a very simple method how to impose structure on XDM 
        values, and we have found a slot into which one might throw any amount of 
        metadata pertaining to the emerging units. Now 
        we face two alternatives.
        We might stop here and regard the semantics of metadata as the 
        realm of proprietary extensions of our simple, general model, in the 
        same way as XML Schema allows annotation attributes. We might, for example, 
        say that any additional attributes and child elements of control items are 
        meta information, to be evaluated in a proprietary way. 
      </textual></para><para class="po-block e144 e144"><textual class="po-textual">
        But we can also take a different path and attempt to arrive at a generic 
        model of XDM metadata and its processing by a responsive infrastructure. 
        This approach does not remove the option of proprietary extensions, but factors 
        them out and constrains them in a way which allows a generic "XDM parser" to 
        report them in a structured way.
        The basic principle of such a model is to distinguish metadata meant to
        control a specific processing from other metadata. The latter might be 
        called "descriptive metadata" 
        and is available for variable uses. The former – "control metadata" – has
        a defined impact on a defined processing.
      </textual></para><para class="po-block e145 e145"><textual class="po-textual">
        Why should one associate data with information which controls their 
        processing? We note an interesting analogy. A key concept of object orientation
        is to associate data sets with behavior. This is similar to what we
        try to do. The behavior of objects is implemented by methods; the
        "behavior" of information units resides in control metadata which define a processing.
        Control metadata is behavior encoded as data, as opposed to methods which 
        are behavior encoded as code. To get a more practical motivation, imagine 
        writing an XQuery program and regretting the limitations of XQuery. For 
        example, one cannot call XSLT to accomplish some finalization, 
        one cannot trigger actions with side effects (like the execution of the SQL 
        just composed), and one cannot create a map object which the calling application 
        would really like to receive. In this situation there is a way out: let the query 
        code rely on a postprocessing of the query result which is </textual><emphasis class="po-inline e146 e146" role="ital"><textual class="po-textual">
        defined</textual></emphasis><textual class="po-textual"> by the query and 
        </textual><emphasis class="po-inline e147 e147" role="ital"><textual class="po-textual">executed</textual></emphasis><textual class="po-textual"> by infrastructure. Our model of 
        XDM metadata amounts to a framework for this approach.
      </textual></para><para class="po-block e148 e148"><textual class="po-textual">
        Obviously, control metadata and the responsive infrastructure must be modeled
        as a coherent whole. We assume that control metadata can be further grouped
        into a set of metadata components, and that a general processing model
        yet to be defined determines how actual processing depends on those
        components. But at this point of our 
        argument we want to separate the general idea from our elaboration of it, 
        as we want to protect the value of the idea from the possible weaknesses of our attempts 
        to refine it. For the time being, we remain abstract. We assume a standard
        infrastructure governed by a set of standard metadata components.
      </textual></para></section></section><section class="po-hcontainer e149 e149" xml:id="xdml-the-concept"><title class="po-block e150 e150"><textual class="po-textual">XDML - the concept</textual></title><para class="po-block e151 e151"><textual class="po-textual">
        By now we have collected a set of ideas which can be assembled into 
        a comprehensive concept how XDM is turned into a 
        </textual><emphasis class="po-inline e152 e152" role="ital"><textual class="po-textual">language</textual></emphasis><textual class="po-textual"> designed to encode 
        information content as well as information processing. 
        XDM is turned into a language by defining 
        and constraining the way how control items can be used within an XDM value. 
        To denote this language we use the acronym "XDML" (short for: 
        "XDM markup language"). An XDML value is then an XDM value which uses control 
        items in a way consistent with the rules of the language. 
      </textual></para><para class="po-block e153 e153"><textual class="po-textual">
        We distinguish between the </textual><emphasis class="po-inline e154 e154" role="ital"><textual class="po-textual">concept</textual></emphasis><textual class="po-textual"> of an 
        XDML language and a concrete specification of the language. While we 
        offer a first proposal for such a specification, we attempt to factor 
        out basic principles. These principles should be simple and 
        intuitive to a degree which a concrete elaboration cannot attain.
        </textual><note class="po-container e155 e155"><title class="po-block e156 e156"><textual class="po-textual">Informal style</textual></title><para class="po-block e157 e157"><textual class="po-textual">
            For the sake of readability, we do not embark 
            on any formal definition. Rather, we want to convey the definition in a 
            natural style which concentrates on ideas and intent at the expense of formal 
            exactness and completeness.
          </textual></para></note><textual class="po-textual">
      </textual></para><section class="po-hcontainer e158 e158" xml:id="goals"><title class="po-block e159 e159"><textual class="po-textual">Goals</textual></title><para class="po-block e160 e160"><textual class="po-textual">
          XDML is a set of rules how XDM values can be designed in order to become more 
          useful entities as compared to ordinary XDM values. The key idea is to insert
          into the XDM values control information which guides the interpretation and
          processing of the data. An XDM value thus augmented is called an XDML value.
          Its usefulness is provided by an XDML processor, which
          is a generic program evaluating the control information.
          XDML addresses the 
          following major goals:
          </textual><itemizedlist class="po-table e161 e161"><listitem class="po-container e162 e162"><para class="po-block e163 e163"><textual class="po-textual">to structure XDM values into nestable parts</textual></para></listitem><listitem class="po-container e164 e164"><para class="po-block e165 e165"><textual class="po-textual">to enable name-based access to XDM parts</textual></para></listitem><listitem class="po-container e166 e166"><para class="po-block e167 e167"><textual class="po-textual">to associate XDM parts with metadata</textual></para></listitem><listitem class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual">to process XDM parts as guided by their metadata</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e170 e170" xml:id="structure-model"><title class="po-block e171 e171"><textual class="po-textual">Structure model</textual></title><para class="po-block e172 e172"><textual class="po-textual">
          XDML structures XDM values by </textual><emphasis class="po-inline e173 e173" role="ital"><textual class="po-textual">grouping</textual></emphasis><textual class="po-textual"> 
          the XDM items. The resulting groups are units of usage in a broad sense: conceptual units of 
          information, units of data retrieval and units of data processing. 
          Item groups are called </textual><emphasis class="po-inline e174 e174" role="ital"><textual class="po-textual">information units</textual></emphasis><textual class="po-textual">. 
          The grouping approach distinguishes:
          </textual><itemizedlist class="po-table e175 e175"><listitem class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual">simple information units – do not contain other units</textual></para></listitem><listitem class="po-container e178 e178"><para class="po-block e179 e179"><textual class="po-textual">complex information units – contain other units</textual></para></listitem></itemizedlist><textual class="po-textual">
          and introduces the following constraints:
          </textual><itemizedlist class="po-table e180 e180"><listitem class="po-container e181 e181"><para class="po-block e182 e182"><textual class="po-textual">complex units do not contain data 
              items which are not contained by nested units</textual></para></listitem><listitem class="po-container e183 e183"><para class="po-block e184 e184"><textual class="po-textual">the information content of a complex unit is regarded as unordered 
              collection of units</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e185 e185" xml:id="metadata-model"><title class="po-block e186 e186"><textual class="po-textual">Metadata model</textual></title><para class="po-block e187 e187"><textual class="po-textual">
          Information units can be associated with metadata. XDML uses a simple metadata model which
          </textual><itemizedlist class="po-table e188 e188"><listitem class="po-container e189 e189"><para class="po-block e190 e190"><textual class="po-textual">distinguishes between descriptive data and control data</textual></para></listitem><listitem class="po-container e191 e191"><para class="po-block e192 e192"><textual class="po-textual">distributes control data into distinct sets, called metadata components</textual></para></listitem><listitem class="po-container e193 e193"><para class="po-block e194 e194"><textual class="po-textual">defines how metadata components control the processing</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e195 e195" xml:id="processing-model"><title class="po-block e196 e196"><textual class="po-textual">Processing model</textual></title><para class="po-block e197 e197"><textual class="po-textual">
          XDML values are submitted to an XDML processor
          which evaluates the control information and is responsible for reporting
          and processing the data
          accordingly. The processor is viewed as the sum of two components:
          </textual><itemizedlist class="po-table e198 e198"><listitem class="po-container e199 e199"><para class="po-block e200 e200"><textual class="po-textual">an XDML parser</textual></para></listitem><listitem class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">XDML engine</textual></para></listitem></itemizedlist><textual class="po-textual">
          An XDML parser delivers the information encoded as 
          XDML value in a structured way. The engine enables other kinds of
          processing. A concrete specification of XDML must define a
          processing model governing the engine and its control by
          metadata and user actions (API calls).
        </textual></para></section><section class="po-hcontainer e203 e203" xml:id="encoding-principles"><title class="po-block e204 e204"><textual class="po-textual">Encoding principles</textual></title><para class="po-block e205 e205"><textual class="po-textual">
          XDML defines the syntax and semantics of control information embedded in
          XDM values. We propose four general encoding principles:
          </textual><itemizedlist class="po-table e206 e206"><listitem class="po-container e207 e207"><para class="po-block e208 e208"><textual class="po-textual">control information is encoded by control items, to be 
              distinguished from data items</textual></para></listitem><listitem class="po-container e209 e209"><para class="po-block e210 e210"><textual class="po-textual">a control item is an XDM item which is an element information
              item in a particular namespace</textual></para></listitem><listitem class="po-container e211 e211"><para class="po-block e212 e212"><textual class="po-textual">each information unit is associated with a control item defining
                the unit in terms of metadata</textual></para></listitem><listitem class="po-container e213 e213"><para class="po-block e214 e214"><textual class="po-textual">metadata components are not mixed - each component is encoded 
                by a distinct (possibly empty) set of elements</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><para class="po-block e215 e215"><textual class="po-textual">
          A concrete specification of XDML must elaborate these principles into a
          concrete encoding model. This model must define the names and structure
          of control items, and it must define the mapping of control 
          items onto content items ("where does the unit begin and end?").
        </textual></para></section></section><section class="po-hcontainer e216 e216" xml:id="xdml-concrete-proposal"><title class="po-block e217 e217"><textual class="po-textual">XDML - concrete proposal</textual></title><para class="po-block e218 e218"><textual class="po-textual">
        The step from XDML as a concept to a concrete specification requires:
        </textual><itemizedlist class="po-table e219 e219"><listitem class="po-container e220 e220"><para class="po-block e221 e221"><textual class="po-textual">A concrete encoding model</textual></para></listitem><listitem class="po-container e222 e222"><para class="po-block e223 e223"><textual class="po-textual">Specification of an XDML parser</textual></para></listitem><listitem class="po-container e224 e224"><para class="po-block e225 e225"><textual class="po-textual">Specification of a processing model</textual></para></listitem></itemizedlist><textual class="po-textual">      
      </textual></para><para class="po-block e226 e226"><textual class="po-textual">
        </textual><note class="po-container e227 e227"><title class="po-block e228 e228"><textual class="po-textual">On language binding</textual></title><para class="po-block e229 e229"><textual class="po-textual">
            The XDML user communicates with the XDML processor via an API. 
            A processor implementation is therefore 
            bound to a programming language, whereas the concept of an XDML processor
            is language neutral. Our ongoing implementation work uses Java, 
            and API code snippets in this paper use Java as well. This representation 
            is chosen for convenience sake and does not mandate Java in 
            preference to other languages.
          </textual></para></note><textual class="po-textual">
      </textual></para><para class="po-block e230 e230"><textual class="po-textual">      
        </textual><emphasis class="po-inline e231 e231" role="ital"><emphasis class="po-inline e232 e232" role="bold"><textual class="po-textual">Encoding model</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e233 e233"><textual class="po-textual">
        We adopt the rules applied in our illustrative examples:
        </textual><itemizedlist class="po-table e234 e234"><listitem class="po-container e235 e235"><para class="po-block e236 e236"><textual class="po-textual">Control items contain elements in the XDML namespace: 
              http://www.xdml.org/ns</textual></para></listitem><listitem class="po-container e237 e237"><para class="po-block e238 e238"><textual class="po-textual">Simple information units are preceded by an </textual><code class="po-atom e239 e239"><textual class="po-textual">&lt;xm:part&gt;</textual></code><textual class="po-textual"> item</textual></para></listitem><listitem class="po-container e240 e240"><para class="po-block e241 e241"><textual class="po-textual">Complex information units are delimited by </textual><code class="po-atom e242 e242"><textual class="po-textual">&lt;xm:complexPart&gt;</textual></code><textual class="po-textual"> and 
            </textual><code class="po-atom e243 e243"><textual class="po-textual">&lt;xm:complexPartEnd&gt;</textual></code><textual class="po-textual"> items</textual></para></listitem><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">Name and partID of an information unit are given by the 
            "name" and "partID" attribute of an </textual><code class="po-atom e246 e246"><textual class="po-textual">&lt;xm:part&gt;</textual></code><textual class="po-textual"> or 
            </textual><code class="po-atom e247 e247"><textual class="po-textual">&lt;xm:complexPart&gt;</textual></code><textual class="po-textual"> item</textual></para></listitem><listitem class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual">Descriptive metadata are encoded as attributes or child 
            elements of an </textual><code class="po-atom e250 e250"><textual class="po-textual">&lt;xm:part&gt;</textual></code><textual class="po-textual"> or 
            </textual><code class="po-atom e251 e251"><textual class="po-textual">&lt;xm:complexPart&gt;</textual></code><textual class="po-textual"> item; they 
            must be in a namespace but must not be in the XDML namespace</textual></para></listitem></itemizedlist><textual class="po-textual">
        We extend the model of </textual><code class="po-atom e252 e252"><textual class="po-textual">&lt;xm:part&gt;</textual></code><textual class="po-textual"> items by three further
        standard attributes. Attribute "private", if containing the value "true",
        indicates that the unit is used to assist in the processing of other units
        and should be ignored by the XDML user. Two other attributes convey type information and
        thus facilitate the translation of XDM values into the data model of the processor
        language:
        </textual><itemizedlist class="po-table e253 e253"><listitem class="po-container e254 e254"><para class="po-block e255 e255"><textual class="po-textual">"type" - represents the data type of the information unit</textual></para></listitem><listitem class="po-container e256 e256"><para class="po-block e257 e257"><textual class="po-textual">
              "finalType" - represents the data type of the information unit 
              after </textual><emphasis class="po-inline e258 e258" role="ital"><textual class="po-textual">finalization</textual></emphasis><textual class="po-textual">
            </textual></para></listitem></itemizedlist><textual class="po-textual">
        Finalization is a processing which is part of the proposed
        processing model and which may change the data type of the unit (see 
        </textual><xref class="po-milestone e259 e259" linkend="execution-context-finalize"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for
        details). The following example shows two information units containing 
        a sequence of nodes and a string, respectively, as indicated by the type attributes:
      </textual><programlisting class="po-block e260 e260" xml:space="preserve"><textual class="po-textual">
&lt;xm:part name="logs" type="nodes"/&gt;,
&lt;log&gt;...&lt;/log&gt;,
&lt;log&gt;...&lt;/log&gt;,
&lt;log&gt;...&lt;/log&gt;,

&lt;xm:part name="query_getSummary" type="string" private="true"/&gt;,
xquery version="1.0"
...
</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e261 e261"><textual class="po-textual">      
        </textual><emphasis class="po-inline e262 e262" role="ital"><emphasis class="po-inline e263 e263" role="bold"><textual class="po-textual">XDML parser</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e264 e264"><textual class="po-textual">
        The parser has to report data in accordance to a data model which in turn
        depends on the processing model. Therefore the parser will be dealt with later,
        after explaining the 
        processing model and in the context of describing the various APIs of the XDML processor. 
      </textual></para><para class="po-block e265 e265"><textual class="po-textual">      
        </textual><emphasis class="po-inline e266 e266" role="ital"><emphasis class="po-inline e267 e267" role="bold"><textual class="po-textual">Processing model</textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e268 e268"><textual class="po-textual">
        The processing model is based on three concepts which the following 
        sections will explain in detail:
        </textual><itemizedlist class="po-table e269 e269"><listitem class="po-container e270 e270"><para class="po-block e271 e271"><textual class="po-textual">Operation - any processing can be decomposed into distinct operations</textual></para></listitem><listitem class="po-container e272 e272"><para class="po-block e273 e273"><textual class="po-textual">Method - unit of processing composed of one or more operations</textual></para></listitem><listitem class="po-container e274 e274"><para class="po-block e275 e275"><textual class="po-textual">Execution context - it specifies when to invoke a method and what to do with
            the return value</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><section class="po-hcontainer e276 e276" xml:id="xdml-operations"><title class="po-block e277 e277"><textual class="po-textual">XDML operations</textual></title><para class="po-block e278 e278"><textual class="po-textual">
        Data processing provided by the XDML processor is modeled as the execution of discrete operations, 
        collectively called XDML operations. XDML operations thus serve as basic unit of data processing: 
        an operation is either executed as a whole or not at all; and any processing can be decomposed 
        into the execution of one or more operations. An operation is supplied with input information, 
        it may produce output information and it may have side-effects. Output information is the return 
        value of the operation. Input information comprises a data context and a request message. 
      </textual></para><para class="po-block e279 e279"><textual class="po-textual">
        The </textual><emphasis class="po-inline e280 e280" role="ital"><textual class="po-textual">data context</textual></emphasis><textual class="po-textual"> can be regarded as the main input, 
        comparable to the context item of XQuery, the context node of XSLT or the 
        primary input port of XProc. The data context of an XDML operation is (usually) the value 
        of an information unit (as represented by the implementation language of the XDML 
        processor). Therefore one might say that an XDML operation is applied to an information 
        unit, or that an information unit is processed by an XDML operation. 
      </textual></para><para class="po-block e281 e281"><textual class="po-textual">
        The </textual><emphasis class="po-inline e282 e282" role="ital"><textual class="po-textual">request message</textual></emphasis><textual class="po-textual"> consists of named parameters, 
        comparable to the external variables of XQuery and the global parameters of XSLT.  
        In the case of XProc, the corresponding input sources would be non-primary input ports, 
        options and parameters. 
      </textual></para><para class="po-block e283 e283"><textual class="po-textual">
        The </textual><emphasis class="po-inline e284 e284" role="ital"><textual class="po-textual">return value</textual></emphasis><textual class="po-textual"> of an operation may be an 
        instance of any type supported by the implementation language of the XDML 
        processor. Note that this value may or may not have a default mapping to 
        an XDM value. In other words: operations may produce a result which is not 
        related to the XDM model, e.g. an object of a custom class.
      </textual></para><para class="po-block e285 e285"><textual class="po-textual">
        The XDML provider defines the processing of an information unit by 
        associating it with methods. A method is a processing defined
        as the sequential execution of one or several operations. It is
        therefore encoded as one or more request messages and 
        the choice of a so-called 
        execution context. The context determines when to invoke the method and 
        what to do with the return value. Method definition is described in 
        </textual><xref class="po-milestone e286 e286" linkend="method-definitions"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. 
        The current section describes XDML operations in general terms, independently of 
        their use in a particular execution context. Main aspects are the data model 
        of input and output, the encoding of input by request messages, the standard 
        library of XDML operations and the extensibility by user-defined operations.
      </textual></para><section class="po-hcontainer e287 e287" xml:id="data-model-of-input-and-output"><title class="po-block e288 e288"><textual class="po-textual">Data model of input and output</textual></title><para class="po-block e289 e289"><textual class="po-textual">
          An XDML operation consumes input information, which comprises:
          </textual><itemizedlist class="po-table e290 e290"><listitem class="po-container e291 e291"><para class="po-block e292 e292"><textual class="po-textual">data context</textual></para></listitem><listitem class="po-container e293 e293"><para class="po-block e294 e294"><textual class="po-textual">request message</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><para class="po-block e295 e295"><textual class="po-textual">
          The </textual><emphasis class="po-inline e296 e296" role="ital"><textual class="po-textual">data context</textual></emphasis><textual class="po-textual"> of an XDML operation 
          is (usually) the value of an information unit. The present version of XDML 
          constrains XDML operations to process simple information units only. 
          The data context is therefore usually an XDM value, or more precisely: the 
          implementation language’s representation of an XDM value. But there are
          two exceptions to the rules. First, the data context may also be the
          return value of another XDML operation (preceding it within a method, see
          </textual><xref class="po-milestone e297 e297" linkend="methods"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Second, the value of a simple information
          unit may be an instance of a data type without default mapping to XDM 
          (resulting
          from unit translation, see </textual><xref class="po-milestone e298 e298" linkend="execution-context-translate"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
        </textual></para><para class="po-block e299 e299"><textual class="po-textual">
          The </textual><emphasis class="po-inline e300 e300" role="ital"><textual class="po-textual">request message</textual></emphasis><textual class="po-textual"> is modeled as follows:
          </textual><itemizedlist class="po-table e301 e301"><listitem class="po-container e302 e302"><para class="po-block e303 e303"><textual class="po-textual">
                the message comprises two parameter sets: statically known 
                parameters and dynamic parameters
              </textual></para></listitem><listitem class="po-container e304 e304"><para class="po-block e305 e305"><textual class="po-textual">each set contains zero or more named parameters</textual></para></listitem><listitem class="po-container e306 e306"><para class="po-block e307 e307"><textual class="po-textual">a parameter name is a QName</textual></para></listitem><listitem class="po-container e308 e308"><para class="po-block e309 e309"><textual class="po-textual">
                a parameter value has one of these types: string, node, or a 
                sequence of nodes
              </textual></para></listitem></itemizedlist><textual class="po-textual">
          The model is easily recognized when looking at the API representation of a request 
          message:
          </textual><programlisting class="po-block e310 e310" xml:space="preserve"><textual class="po-textual">
interface OperationRequest {
   QName   operationName();
   String  resultType();

   String  getStringParam(QName name);
   Node    getNodeParam(QName name);
   Node[]  getNodesParam(QName name);

   String  getDynamicStringParam(QName name);
   Node    getDynamicNodeParam(QName name);
   Node[]  getDynamicNodesParam(QName name);

   QName[] getParamNames();
   QName[] getDynamicParamNames();
}
</textual></programlisting><textual class="po-textual">
          Note that this model follows the approach taken by the XProc 
          language rather closely: the set of statically known parameters 
          corresponds to the non-primary input ports and options of XProc 
          steps, while the set of dynamic parameters corresponds to XProc’s 
          parameter port. Dynamic parameters are required, for example, to 
          enable operations which execute arbitrary stylesheets: 
          the names of stylesheet parameters cannot be anticipated and may 
          collide with the names of statically known parameters.
        </textual></para><para class="po-block e311 e311"><textual class="po-textual">
          Output information is the </textual><emphasis class="po-inline e312 e312" role="ital"><textual class="po-textual">return value</textual></emphasis><textual class="po-textual">
          of the operation. An operation may or may not produce a return value. 
          The return value can be an instance of any data type supported 
          by the implementation language: it is not constrained to have a default 
          mapping to an XDM value. It may, for example, be an object of a custom class.
        </textual></para></section><section class="po-hcontainer e313 e313" xml:id="request-messages"><title class="po-block e314 e314"><textual class="po-textual">Request messages</textual></title><para class="po-block e315 e315"><textual class="po-textual">
          The XDML provider encodes the input information of an operation by an
          element information item representing a request message. This message 
          is implicitly accompanied by a data context, which is either the value 
          of the surrounding information unit or the return value of a
          preceding operation.
        </textual></para><para class="po-block e316 e316"><textual class="po-textual">
          The request message has the following parts:
          </textual><itemizedlist class="po-table e317 e317"><listitem class="po-container e318 e318"><para class="po-block e319 e319"><textual class="po-textual">the root element representing the message as a whole</textual></para></listitem><listitem class="po-container e320 e320"><para class="po-block e321 e321"><textual class="po-textual">attributes encoding statically known parameters of type “string”</textual></para></listitem><listitem class="po-container e322 e322"><para class="po-block e323 e323"><textual class="po-textual">
                child elements encoding statically known parameters of type “node” 
                or “node sequence”
              </textual></para></listitem><listitem class="po-container e324 e324"><para class="po-block e325 e325"><textual class="po-textual">
                an optional child element </textual><code class="po-atom e326 e326"><textual class="po-textual">&lt;xm:params&gt;</textual></code><textual class="po-textual"> 
                representing the dynamic parameters
              </textual></para></listitem><listitem class="po-container e327 e327"><para class="po-block e328 e328"><textual class="po-textual">
                the attributes of </textual><code class="po-atom e329 e329"><textual class="po-textual">&lt;xm:params&gt;</textual></code><textual class="po-textual"> encoding dynamic 
                parameters of type “string”
              </textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">
                child elements of </textual><code class="po-atom e332 e332"><textual class="po-textual">&lt;xm:params&gt;</textual></code><textual class="po-textual"> encoding dynamic parameters 
                of type “node” or “node sequence”
              </textual></para></listitem></itemizedlist><textual class="po-textual">
          The name of the root element equals the operation name, and the names of 
          attributes and elements representing parameters correspond to the parameter 
          names. Consider this example:
          </textual><programlisting class="po-block e333 e333" xml:space="preserve"><textual class="po-textual">
&lt;submitToXSLT serialize=”true”&gt;
   &lt;stylesheet&gt;
      &lt;xsl:transform …&gt;…&lt;/xsl:transform&gt;
   &lt;/stylesheet&gt;
   &lt;xm:params verbosity=”1”&gt;
      &lt;weatherData&gt;&lt;weather&gt;…&lt;/weather&gt;&lt;/weatherData&gt;
   &lt;/xm:params&gt;
&lt;/submitToXSLT&gt;
</textual></programlisting><textual class="po-textual">
          The operation "submitToXSLT" is invoked with two statically 
          known parameters (“serialize” and “stylesheet”) and two dynamic 
          parameters (“verbosity” and “weatherData”). In both 
          parameter groups there is a string parameter as well as a node parameter. 
          The operation executes the stylesheet supplied as parameter “stylesheet” 
          and passes to it two stylesheet parameters, one with name “verbosity” and 
          type </textual><code class="po-atom e334 e334"><textual class="po-textual">xs:string</textual></code><textual class="po-textual">, the other with name “weatherData”  and 
          type </textual><code class="po-atom e335 e335"><textual class="po-textual">node()</textual></code><textual class="po-textual">. The 
          operation also passes to the stylesheet the value of the 
          surrounding information unit as context node.
        </textual></para></section><section class="po-hcontainer e336 e336" xml:id="special-parameter-values"><title class="po-block e337 e337"><textual class="po-textual">Special parameter values</textual></title><para class="po-block e338 e338"><textual class="po-textual">
          A request message may reference
          </textual><itemizedlist class="po-table e339 e339"><listitem class="po-container e340 e340"><para class="po-block e341 e341"><textual class="po-textual">values supplied by the XDML user</textual></para></listitem><listitem class="po-container e342 e342"><para class="po-block e343 e343"><textual class="po-textual">values provided by other information units</textual></para></listitem></itemizedlist><textual class="po-textual">
        </textual></para><section class="po-hcontainer e344 e344" xml:id="parameter-values-supplied-by-the-xdml-user"><title class="po-block e345 e345"><textual class="po-textual">Parameter values supplied by the XDML user</textual></title><para class="po-block e346 e346"><textual class="po-textual">
            A request message may reference values supplied by the XDML user. Values 
            can be supplied as the execution of XDML operations is always triggered 
            by an API call of the XDML user (see 
            </textual><xref class="po-milestone e347 e347" linkend="xdml-user-perspective"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). A reference to a 
            supplied value is encoded by the expression
          </textual></para><para class="po-block e348 e348"><textual class="po-textual">
            $arg{argName}
          </textual></para><para class="po-block e349 e349"><textual class="po-textual">
            which is resolved to the value of an invocation argument with name 
            “argName”. For example, the following request message binds two 
            dynamic parameters, “verbosity” and “weatherData” to values supplied 
            by the XDML user:
            </textual><programlisting class="po-block e350 e350" xml:space="preserve"><textual class="po-textual">
&lt;submitToXSLT serialize=”true”&gt;
   &lt;stylesheet&gt;
      &lt;xsl:transform …&gt;…&lt;/xsl:transform&gt;
   &lt;/stylesheet&gt;
   &lt;xm:params verbosity=”$arg{v}”&gt;
      &lt;weatherData&gt;$arg{weatherData}&lt;/weatherData&gt;
   &lt;/xm:params&gt;
&lt;/submitToXSLT&gt;
</textual></programlisting><textual class="po-textual">
            Note that the parameter name used by the request message and the 
            argument name expected from the XDML user need not be the same: 
            in the example, the request parameter “verbosity” is bound to 
            invocation argument “v”. The XDML provider’s choice of referenced 
            argument names (in the example – “v” and “weatherData”) defines 
            the “signature” of the operation from the XDML user’s perspective.
          </textual></para></section><section class="po-hcontainer e351 e351" xml:id="parameter-values-provided-by-other-information-units"><title class="po-block e352 e352"><textual class="po-textual">Parameter values provided by other information units</textual></title><para class="po-block e353 e353"><textual class="po-textual">
            A request parameter may reference the value of another information 
            unit. Such references are encoded by the expression
          </textual></para><para class="po-block e354 e354"><textual class="po-textual">
            $part{partId}
          </textual></para><para class="po-block e355 e355"><textual class="po-textual">
            which is resolved to the value of the information unit with part ID
            “partId”. In the following example, parameter “stylesheet” is set 
            to the value of an information unit with the part ID “toHTML”:
            </textual><programlisting class="po-block e356 e356" xml:space="preserve"><textual class="po-textual">
&lt;submitToXSLT serialize=”true”&gt;
   &lt;stylesheet&gt;$part{toHTML}&lt;/stylesheet&gt;
   …
&lt;/submitToXSLT&gt;
</textual></programlisting><textual class="po-textual">
          </textual></para></section></section><section class="po-hcontainer e357 e357" xml:id="library-of-standard-operations"><title class="po-block e358 e358"><textual class="po-textual">Library of standard operations</textual></title><para class="po-block e359 e359"><textual class="po-textual">
          The XDML processor offers a library of available XDML operations. 
          The library comprises 
          </textual><itemizedlist class="po-table e360 e360"><listitem class="po-container e361 e361"><para class="po-block e362 e362"><textual class="po-textual">standard operations which are built-in</textual></para></listitem><listitem class="po-container e363 e363"><para class="po-block e364 e364"><textual class="po-textual">proprietary operations which have been registered at runtime</textual></para></listitem></itemizedlist><textual class="po-textual">
          See </textual><xref class="po-milestone e365 e365" linkend="extensibility"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for details about the registration facility. Some examples of 
          standard operations are:
        </textual></para><para class="po-block e366 e366"><textual class="po-textual">
          </textual><table class="po-container e367 e367"><caption class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual">
                </textual><emphasis class="po-inline e370 e370" role="bold"><emphasis class="po-inline e371 e371" role="ital"><textual class="po-textual">Some standard XDML operations.</textual></emphasis></emphasis><textual class="po-textual">
              </textual></para></caption><col align="left" class="po-meta e372 e372" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e373 e373" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e374 e374"><tr class="po-table e375 e375" valign="top"><th align="left" class="po-field e376 e376" valign="top"><textual class="po-textual">Operation name</textual></th><th align="left" class="po-field e377 e377" valign="top"><textual class="po-textual">Description</textual></th></tr></thead><tbody class="po-table e378 e378"><tr class="po-table e379 e379" valign="top"><td class="po-block e380 e380"><textual class="po-textual">createMapFromStrings</textual></td><td class="po-block e381 e381"><textual class="po-textual">
                  Creates a map object, using as input a sequence of strings read from the data context.
                </textual></td></tr><tr class="po-table e382 e382" valign="top"><td class="po-block e383 e383"><textual class="po-textual">createPropertiesFromStrings</textual></td><td class="po-block e384 e384"><textual class="po-textual">
                  Creates a </textual><code class="po-atom e385 e385"><textual class="po-textual">Properties</textual></code><textual class="po-textual"> object, using as input a sequence of strings read from the data context.
                </textual></td></tr><tr class="po-table e386 e386" valign="top"><td class="po-block e387 e387"><textual class="po-textual">execAsSQL</textual></td><td class="po-block e388 e388"><textual class="po-textual">
                  Regards the data context as a sequence of SQL expressions and executes them.
                </textual></td></tr><tr class="po-table e389 e389" valign="top"><td class="po-block e390 e390"><textual class="po-textual">execAsPerl</textual></td><td class="po-block e391 e391"><textual class="po-textual">
                  Regards the data context as a Perl script and executes it.
                </textual></td></tr><tr class="po-table e392 e392" valign="top"><td class="po-block e393 e393"><textual class="po-textual">execAsXQuery</textual></td><td class="po-block e394 e394"><textual class="po-textual">
                  Regards the data context as an XQuery program and executes it.
                </textual></td></tr><tr class="po-table e395 e395" valign="top"><td class="po-block e396 e396"><textual class="po-textual">execAsXSLT</textual></td><td class="po-block e397 e397"><textual class="po-textual">
                  Regards the data context as an XSLT stylesheet and executes it.
                </textual></td></tr><tr class="po-table e398 e398" valign="top"><td class="po-block e399 e399"><textual class="po-textual">execAsXProc</textual></td><td class="po-block e400 e400"><textual class="po-textual">
                  Regards the data context as an XProc pipeline and executes it.
                </textual></td></tr><tr class="po-table e401 e401" valign="top"><td class="po-block e402 e402"><textual class="po-textual">readDocument</textual></td><td class="po-block e403 e403"><textual class="po-textual">Reads a document into a node object, reading the document URI from the data context.</textual></td></tr><tr class="po-table e404 e404" valign="top"><td class="po-block e405 e405"><textual class="po-textual">readTextFile</textual></td><td class="po-block e406 e406"><textual class="po-textual">Reads a text file into a string, reading the file URI from the data context.</textual></td></tr><tr class="po-table e407 e407" valign="top"><td class="po-block e408 e408"><textual class="po-textual">sendFTP</textual></td><td class="po-block e409 e409"><textual class="po-textual">Sends the data context per ftp.</textual></td></tr><tr class="po-table e410 e410" valign="top"><td class="po-block e411 e411"><textual class="po-textual">sendSOAP</textual></td><td class="po-block e412 e412"><textual class="po-textual">Regards the data context as the payload of a SOAP request, sends it
                  and returns the payload of the response.</textual></td></tr><tr class="po-table e413 e413" valign="top"><td class="po-block e414 e414"><textual class="po-textual">submitToXQuery</textual></td><td class="po-block e415 e415"><textual class="po-textual">
                  Executes an XQuery program and passes the data context to it
                  as context item.
                </textual></td></tr><tr class="po-table e416 e416" valign="top"><td class="po-block e417 e417"><textual class="po-textual">submitToXSLT</textual></td><td class="po-block e418 e418"><textual class="po-textual">
                  Executes an XSLT stylesheet and passes the data context to it
                  as context node.
                </textual></td></tr><tr class="po-table e419 e419" valign="top"><td class="po-block e420 e420"><textual class="po-textual">submitToXProc</textual></td><td class="po-block e421 e421"><textual class="po-textual">
                  Executes an XProc  pipeline and passes the data context to it
                  as primary input.
                </textual></td></tr><tr class="po-table e422 e422" valign="top"><td class="po-block e423 e423"><textual class="po-textual">validate</textual></td><td class="po-block e424 e424"><textual class="po-textual">Validates the data context with an XML Schema.</textual></td></tr><tr class="po-table e425 e425" valign="top"><td class="po-block e426 e426"><textual class="po-textual">writeDocument</textual></td><td class="po-block e427 e427"><textual class="po-textual">Stores the data context as an XML document.</textual></td></tr><tr class="po-table e428 e428" valign="top"><td class="po-block e429 e429"><textual class="po-textual">writeTextFile</textual></td><td class="po-block e430 e430"><textual class="po-textual">Stores the data context as a text file.</textual></td></tr></tbody></table><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e431 e431" xml:id="extensibility"><title class="po-block e432 e432"><textual class="po-textual">Extensibility</textual></title><para class="po-block e433 e433"><textual class="po-textual">
          The XMDL processor offers a generic mechanism for extending the library 
          of XDML operations at runtime. This is achieved by an interface for 
          registering proprietary operations:
          </textual><programlisting class="po-block e434 e434" xml:space="preserve"><textual class="po-textual">
interface XDMLRegistry {
   void registerXDMLOperations(XDMLOperations impls);
}
</textual></programlisting><textual class="po-textual">
          On registration, an implementation must be supplied as an implementation 
          of the interface </textual><code class="po-atom e435 e435"><textual class="po-textual">XDMLOperations</textual></code><textual class="po-textual">. It represents the 
          invocation of an operation as a method with a generic signature: 
          </textual><programlisting class="po-block e436 e436" xml:space="preserve"><textual class="po-textual">
interface XDMLOperations {
   QName[] getOperationNames();
   void    execute(OperationRequest requestMsg,
                   DataUnit         dataContext,
                   DataUnit         returnValue) 
                      throws XDMLException;
}
</textual></programlisting><textual class="po-textual">
          Implementing proprietary operations is a straightforward task:
          interfaces </textual><code class="po-atom e437 e437"><textual class="po-textual">OperationRequest</textual></code><textual class="po-textual"> and </textual><code class="po-atom e438 e438"><textual class="po-textual">DataUnit</textual></code><textual class="po-textual">
          provide access to
          operation name, request parameters and data context, respectively.
          The return value is inserted into an instance of interface </textual><code class="po-atom e439 e439"><textual class="po-textual">DataUnit</textual></code><textual class="po-textual"> 
          which is either supplied from without or instantiated within the
          implementation.
        </textual></para></section></section><section class="po-hcontainer e440 e440" xml:id="methods"><title class="po-block e441 e441"><textual class="po-textual">Methods</textual></title><para class="po-block e442 e442"><textual class="po-textual">
        In most cases, a desired processing can be provided by a single operation, in
        other words: the unit of intended processing matches the basic unit of
        implemented functionality. Sometimes, however, a processing may
        require two or more operations to be executed. As a generalization, our 
        processing model defines the unit of intended processing as a sequence 
        of one or more operations. This unit we call a </textual><emphasis class="po-inline e443 e443" role="ital"><textual class="po-textual">method</textual></emphasis><textual class="po-textual">. 
        Assuming sequential execution of the operations,
        one may wish for flexibility concerning the data context: shall the second
        operation use, like the first one, the value of the information unit, or
        shall it use the return value of the preceding operation? This flexibility
        is easy to implement, and it is easy to encode:
        </textual><itemizedlist class="po-table e444 e444"><listitem class="po-container e445 e445"><para class="po-block e446 e446"><textual class="po-textual">
              represent the method by a sequence of request messages
            </textual></para></listitem><listitem class="po-container e447 e447"><para class="po-block e448 e448"><textual class="po-textual">
              add to request messages an optional attribute indicating any non-default use of the data context
            </textual></para></listitem></itemizedlist><textual class="po-textual">
        We introduce an attribute "dataContext" which may be attached to a request message in order
        to encode where the actual data context is found. Rules:
        </textual><itemizedlist class="po-table e449 e449"><listitem class="po-container e450 e450"><para class="po-block e451 e451"><textual class="po-textual">
              attribute missing =&gt; first operation uses the value of the information unit, 
              later operations use the return value of the preceding operation
            </textual></para></listitem><listitem class="po-container e452 e452"><para class="po-block e453 e453"><textual class="po-textual">
              attribute value is "." =&gt; use the value of the information unit
            </textual></para></listitem><listitem class="po-container e454 e454"><para class="po-block e455 e455"><textual class="po-textual">
              attribute value is an NCName =&gt; use the return value of the preceding operation with that operation ID (attribute "opID")
            </textual></para></listitem></itemizedlist><textual class="po-textual">
        Note that the value of the information unit is always the data context for the method "as a whole" (for
        its first operation), but not necessarily for each of its operations. Every method is therefore
        bound to a particular information unit, as in object oriented programs every instance method
        is bound to a particular object.
      </textual></para><para class="po-block e456 e456"><textual class="po-textual">
        The return value of a method is the return value of its last (or only) operation,
        unless another operation has been marked with a special 
        attribute ("methodReturnValue") to yield the return value.
      </textual></para></section><section class="po-hcontainer e457 e457" xml:id="execution-context"><title class="po-block e458 e458"><textual class="po-textual">Execution context</textual></title><para class="po-block e459 e459"><textual class="po-textual">
        When defining a method, the control data provide 
        </textual><itemizedlist class="po-table e460 e460"><listitem class="po-container e461 e461"><para class="po-block e462 e462"><textual class="po-textual">one or more request messages</textual></para></listitem><listitem class="po-container e463 e463"><para class="po-block e464 e464"><textual class="po-textual">the execution context</textual></para></listitem></itemizedlist><textual class="po-textual">
        The execution context specifies (a) when to execute the method and 
        (b) what to do with the return value (if any). Note the necessity of 
        specifying such an execution context, as the method will be invoked 
        after the XDML value is delivered to the XDML user.
      </textual></para><para class="po-block e465 e465"><textual class="po-textual">
        We distinguish four types of execution context, which, taken together, 
        define the processing model of XDML. Future versions of XDML may add 
        further execution contexts. Each context may be viewed as the intent 
        with which the XDML provider defines the method. He may want to 
        </textual><itemizedlist class="po-table e466 e466"><listitem class="po-container e467 e467"><para class="po-block e468 e468"><textual class="po-textual">finalize the value of the information unit</textual></para></listitem><listitem class="po-container e469 e469"><para class="po-block e470 e470"><textual class="po-textual">execute actions</textual></para></listitem><listitem class="po-container e471 e471"><para class="po-block e472 e472"><textual class="po-textual">enable evaluations</textual></para></listitem><listitem class="po-container e473 e473"><para class="po-block e474 e474"><textual class="po-textual">define non-standard representations</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><section class="po-hcontainer e475 e475" xml:id="execution-context-finalize"><title class="po-block e476 e476"><textual class="po-textual">Execution context "finalize"</textual></title><para class="po-block e477 e477"><textual class="po-textual">
          Sometimes the XDML provider may want to supply intermediary data and 
          leave the finalization to postprocessing. There are three main reasons 
          for this pattern: (a) the finalization requires some processing resource 
          not available to the XDML provider, but available to an XDML operation; 
          (b) the finalization is deferred as it may turn out to be unnecessary; 
          (c) the finalization requires parameter values to be supplied by the 
          XDML user at invocation time.
        </textual></para><para class="po-block e478 e478"><textual class="po-textual">
          For example, the data which an information unit should ultimately 
          supply may be obtained by submitting intermediary data to an XSLT 
          stylesheet. However, if the XDML provider is an XQuery program, it 
          cannot execute the XSLT processing. In this case, the XDML provider 
          may provide the intermediate data and bind the information unit to 
          the stylesheet execution. The execution context “finalize” ensures 
          that the finalization takes place as soon as the XDML user confirms 
          that finalizations are to be executed. The confirmation may be global 
          or restricted to a particular information unit. The code
          </textual><programlisting class="po-block e479 e479" xml:space="preserve"><textual class="po-textual">
XDMLProcessor xp = XDMLProcessorFactory.newXDMLProcessor();
XQSequence xdm = ...;
XDML xdml = xp.newXDML(xdm);
xdml.finalize();
</textual></programlisting><textual class="po-textual">
          loads an XDML value and triggers any finalizations, whereas
          </textual><programlisting class="po-block e480 e480" xml:space="preserve"><textual class="po-textual">
…
xdml.finalize(“conferenceProgram”);
</textual></programlisting><textual class="po-textual">
          triggers the finalization of information unit "conferenceProgram" 
          only. In general, finalization is achieved by executing a method
          (one or more operations) defined for that purpose and replacing the value 
          of the unit by the return value of the method.
        </textual></para><para class="po-block e481 e481"><textual class="po-textual">
          To give a second example, the intermediary submitted to finalization 
          may be the payload of a SOAP request. The finalization may then be 
          achieved by operation “sendSOAP”, which wraps the unit data in a 
          SOAP envelope, sends the request, receives the response and returns 
          its payload. Using this operation in the execution context “finalize” 
          will ensure that the information unit supplies the response payload,
          rather than the request payload.
        </textual></para></section><section class="po-hcontainer e482 e482" xml:id="execution-context-execute"><title class="po-block e483 e483"><textual class="po-textual">Execution context "execute"</textual></title><para class="po-block e484 e484"><textual class="po-textual">
          To create data may be less than what the XDML provider wants to do: 
          his intent may be to execute actions related to the data. In some 
          cases, the data are only a means to an end which is such an action: 
          the data may represent, for example, a sequence of SQL statements, and the 
          action consist of their execution. In other cases, the data may be valuable as 
          such, but additional action is mandatory – for example, storage in 
          a file or in a database. In both situations, overall processing may 
          be simplified if the XDML provider may define the actions to be 
          executed, specifying all details, rather than rely on the XDML user 
          to know which actions to trigger and which details to specify.
        </textual></para><para class="po-block e485 e485"><textual class="po-textual">
          The execution context “execute” takes care of this scenario. The 
          XDML user does not have to know which operations are executed. 
          He has to confirm, however, that any defined actions shall indeed 
          be executed. His responsibility is restricted to giving or refusing 
          “green light” to the actions defined by the XDML provider. The 
          confirmation may be global:
          </textual><programlisting class="po-block e486 e486" xml:space="preserve"><textual class="po-textual">
…
xdml.execute();
</textual></programlisting><textual class="po-textual">
          or restricted to a particular information unit:
          </textual><programlisting class="po-block e487 e487" xml:space="preserve"><textual class="po-textual">
…
xdml.execute(“cleanupScript”);
</textual></programlisting><textual class="po-textual">
          The XDML user does not receive a return value. Therefore, the 
          operations commanded by the XDM provider are always actions, 
          rather than evaluations: operations motivated by their side 
          effects, not by the production of a result value.
        </textual></para></section><section class="po-hcontainer e488 e488" xml:id="execution-context-enable"><title class="po-block e489 e489"><textual class="po-textual">Execution context "enable"</textual></title><para class="po-block e490 e490"><textual class="po-textual">
          A different intent of the XDML provider might be to make 
          certain evaluations or actions available, but leave it to the XDML 
          user if the processing is actually performed. An example 
          might be an evaluation which extracts some values from an
          XML document, which might or might not be desired. The 
          execution context “enable” supports such intent: the evaluation 
          is only executed if the XDML user demands it explicitly, 
          identifying it by a name which the XDML provider has assigned 
          to it. In this example code:
          </textual><programlisting class="po-block e491 e491" xml:space="preserve"><textual class="po-textual">
String[] locations = (String[]) xdml.invoke(“waterReport”, “getLocations”);
</textual></programlisting><textual class="po-textual">
          the XDML user invokes an evaluation which is labeled "getLocations" 
          and bound to information unit "waterReport". 
          The name identifies a method (one or more operations) defined
          for this unit and associated with the execution context "enable". 
          The method has 
          a signature, as implied by the use of $arg{argName} 
          references in the operation requests. The following
          method definitions create two XDML methods, one without parameters
          and the other with a string parameter "location". The methods
          are implemented by one and two operations, respectively:
          </textual><programlisting class="po-block e492 e492" xml:space="preserve"><textual class="po-textual">
&lt;xm:part name="waterReport" type="node"&gt;
   &lt;xm:interface&gt;
      &lt;xm:method name="getLocations" returnType="strings"&gt;
         &lt;submitToXQuery&gt;
            &lt;query&gt;distinct-values(//location/@name)&lt;/query&gt;
         &lt;/submitToXQuery&gt;
      &lt;/xm:method&gt;
      &lt;xm:method name="getResultTable" returnType="map_string_to_string"&gt;
         &lt;submitToXQuery&gt;
            &lt;query&gt;
               declare variable $location external; 
               //location[@name eq $location]//substance/(@name, @quantity)
            &lt;/query&gt;
            &lt;xm:params location="$arg{location}"/&gt;
         &lt;/submitToXQuery&gt;         
         &lt;createMapFromStrings/&gt;
      &lt;/xm:method&gt;
    &lt;/xm:interface&gt;
&lt;/xm:part&gt;
</textual></programlisting><textual class="po-textual">
         These method definitions impart to the information unit
         an interface of possible method invocations, which might be represented 
         in pseudo-code like so:
          </textual><programlisting class="po-block e493 e493" xml:space="preserve"><textual class="po-textual">
   informationUnitInterface {
      String[] getLocations();
      Map&lt;String,String&gt; getResultTable(String location)
   }
</textual></programlisting><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e494 e494" xml:id="execution-context-translate"><title class="po-block e495 e495"><textual class="po-textual">Execution context "translate"</textual></title><para class="po-block e496 e496"><textual class="po-textual">
          The XDML provider might desire the XDML parser to deliver data 
          which are not a standard representation of XDM data. For example, 
          he might intend to deliver a map object, whereas the information 
          unit contains an XML fragment encoding the map entries. To achieve 
          this, the metadata specify the transformation of the unit data 
          into the desired representation. Conceptually, this may be viewed 
          as executing a method which produces the non-standard 
          representation and replaces the value of the unit with this 
          representation – which is essentially the same processing as provided 
          by a method in context “finalize”. We prefer, however, to 
          distinguish finalization in the sense described above from the 
          translation of the unit data into a specific data type. Such
          translation we regard as processing associated with an
          execution context "translate". Contrary 
          to the handling of finalization, the XDML user does not confirm 
          translation - translation is built into the XDML parser which 
          always delivers values in accordance to a defined translation. For example, this code:
          </textual><programlisting class="po-block e497 e497" xml:space="preserve"><textual class="po-textual">
Map&lt;String,String&gt; map = xdml.getPart("foo").getMapString2String()
</textual></programlisting><textual class="po-textual">
          retrieves the unit data as a map, rather than as an XML element 
          which is the XDM source format consumed by the XDML processor. 
          The XDML user can only retrieve the unit data as a map.
        </textual></para></section></section><section class="po-hcontainer e498 e498" xml:id="method-definitions"><title class="po-block e499 e499"><textual class="po-textual">Method definitions</textual></title><para class="po-block e500 e500"><textual class="po-textual">
        The processing of an information unit is organized as the execution of
        methods. A method consists of one or several operations. The definition of a method
        consists of the request message(s) launching its operation(s). 
        The definitions are associated with an execution context, where
        execution contexts and method definitions are related as follows:
      </textual></para><para class="po-block e501 e501"><textual class="po-textual">
        </textual><table class="po-container e502 e502"><caption class="po-container e503 e503"><para class="po-block e504 e504"><textual class="po-textual">
              </textual><emphasis class="po-inline e505 e505" role="bold"><emphasis class="po-inline e506 e506" role="ital"><textual class="po-textual">Execution contexts and method definitions.</textual></emphasis></emphasis><textual class="po-textual">
            </textual></para></caption><col align="left" class="po-meta e507 e507" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e508 e508" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e509 e509"><tr class="po-table e510 e510" valign="top"><th align="left" class="po-field e511 e511" valign="top"><textual class="po-textual">Execution context</textual></th><th align="left" class="po-field e512 e512" valign="top"><textual class="po-textual">Content</textual></th></tr></thead><tbody class="po-table e513 e513"><tr class="po-table e514 e514" valign="top"><td class="po-block e515 e515"><textual class="po-textual">finalize</textual></td><td class="po-block e516 e516"><textual class="po-textual">
                a single anonymous method (or empty)
              </textual></td></tr><tr class="po-table e517 e517" valign="top"><td class="po-block e518 e518"><textual class="po-textual">execute</textual></td><td class="po-block e519 e519"><textual class="po-textual">
                a single anonymous method (or empty)
              </textual></td></tr><tr class="po-table e520 e520" valign="top"><td class="po-block e521 e521"><textual class="po-textual">enable</textual></td><td class="po-block e522 e522"><textual class="po-textual">
                a set of named methods (possibly empty)
              </textual></td></tr><tr class="po-table e523 e523" valign="top"><td class="po-block e524 e524"><textual class="po-textual">translate</textual></td><td class="po-block e525 e525"><textual class="po-textual">
                a single operation per target language (possibly none)
              </textual></td></tr></tbody></table><textual class="po-textual">
      </textual></para><para class="po-block e526 e526"><textual class="po-textual">
        The encoding of method definitions reflects these relationships:
      </textual></para><para class="po-block e527 e527"><textual class="po-textual">
        </textual><table class="po-container e528 e528"><caption class="po-container e529 e529"><para class="po-block e530 e530"><textual class="po-textual">
              </textual><emphasis class="po-inline e531 e531" role="bold"><emphasis class="po-inline e532 e532" role="ital"><textual class="po-textual">Execution contexts and their encoding.</textual></emphasis></emphasis><textual class="po-textual">
            </textual></para></caption><col align="left" class="po-meta e533 e533" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e534 e534" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e535 e535"><tr class="po-table e536 e536" valign="top"><th align="left" class="po-field e537 e537" valign="top"><textual class="po-textual">Execution context</textual></th><th align="left" class="po-field e538 e538" valign="top"><textual class="po-textual">Encoding</textual></th></tr></thead><tbody class="po-table e539 e539"><tr class="po-table e540 e540" valign="top"><td class="po-block e541 e541"><textual class="po-textual">finalize</textual></td><td class="po-block e542 e542"><textual class="po-textual">
                optional </textual><code class="po-atom e543 e543"><textual class="po-textual">&lt;xm:finalize&gt;</textual></code><textual class="po-textual"> element, child elements are request messages
              </textual></td></tr><tr class="po-table e544 e544" valign="top"><td class="po-block e545 e545"><textual class="po-textual">execute</textual></td><td class="po-block e546 e546"><textual class="po-textual">
                optional </textual><code class="po-atom e547 e547"><textual class="po-textual">&lt;xm:execute&gt;</textual></code><textual class="po-textual"> element, child elements are request messages
              </textual></td></tr><tr class="po-table e548 e548" valign="top"><td class="po-block e549 e549"><textual class="po-textual">enable</textual></td><td class="po-block e550 e550"><textual class="po-textual">
                optional </textual><code class="po-atom e551 e551"><textual class="po-textual">&lt;xm:interface&gt;</textual></code><textual class="po-textual"> element, child elements are </textual><code class="po-atom e552 e552"><textual class="po-textual">&lt;xm:method&gt;</textual></code><textual class="po-textual">
                elements representing named methods, whose child elements are request messages
              </textual></td></tr><tr class="po-table e553 e553" valign="top"><td class="po-block e554 e554"><textual class="po-textual">translate</textual></td><td class="po-block e555 e555"><textual class="po-textual">
                zero or more </textual><code class="po-atom e556 e556"><textual class="po-textual">&lt;xm:translate&gt;</textual></code><textual class="po-textual"> elements, each one representing a target language
                and encoding the data type and translation parameters as attributes
              </textual></td></tr></tbody></table><textual class="po-textual">
        The following listing presents a schematic example:
        </textual><programlisting class="po-block e557 e557" xml:space="preserve"><textual class="po-textual">
&lt;xm:part name="foo" type="bar"&gt;
   &lt;xm:finalize&gt;
      &lt;op1&gt;...&lt;/op1&gt;
      &lt;op2&gt;...&lt;/op2&gt;
   &lt;/xm:finalize&gt;
   &lt;xm:execute&gt;
      &lt;op3&gt;...&lt;/op3&gt;
      &lt;op4&gt;...&lt;/op4&gt;
   &lt;/xm:execute&gt;
   &lt;xm:interface&gt;
      &lt;xm:method name="m1" returnType="t1"&gt;
         &lt;op5&gt;...&lt;/op5&gt;
         &lt;op6&gt;...&lt;/op6&gt;
      &lt;/xm:method&gt;
      &lt;xm:method name="m2" returnType="t2"&gt;
         &lt;op7&gt;...&lt;/op7&gt;
         &lt;op8&gt;...&lt;/op8&gt;
      &lt;/xm:method&gt;
   &lt;/xm:interface&gt;
   &lt;xm:translate target="java" type="t3" att1="..." att2="..."/&gt;
&lt;/xm:part&gt;
</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e558 e558"><textual class="po-textual">
        And here comes a realistic example using three execution contexts, “finalize”, "execute" and "enable".
        It shows an information unit which is finalized into a Perl script to be executed in context "execute"
        and besides offering a little interface of methods to be invoked explicitly ("writeLog", "save"):
        </textual><programlisting class="po-block e559 e559" xml:space="preserve"><textual class="po-textual">
&lt;xm:part name="cleanupScript" type="node" finalType="string"&gt;
   &lt;xm:finalize&gt;
      &lt;execAsXSLT serialize="true"/&gt;
   &lt;/xm:finalize&gt;
   &lt;xm:execute&gt;
      &lt;execAsPerl&gt;
         &lt;xm:params options="-m cleanup"/&gt;        
      &lt;/execAsPerl&gt;
   &lt;/xm:execute&gt;
   &lt;xm:interface&gt;
      &lt;xm:method name="writeLog"&gt;
         &lt;execAsPerl&gt;
            &lt;xm:params options="-m writeLog -f $arg{fileName}"/&gt;
         &lt;/execAsPerl&gt;
      &lt;/xm:method&gt;
      &lt;xm:method name="save"&gt;
         &lt;execAsPerl&gt;
            &lt;xm:params options="-m save"/&gt;
         &lt;/execAsPerl&gt;
      &lt;/xm:method&gt;
   &lt;/xm:interface&gt;
&lt;/xm:part&gt;
</textual></programlisting><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e560 e560" xml:id="xdml-user-perspective"><title class="po-block e561 e561"><textual class="po-textual">XDML user perspective</textual></title><para class="po-block e562 e562"><textual class="po-textual">
        An XDML value is a set of information units which may be 
        retrieved and – depending on the method definitions – processed 
        in a simplified way. An XDML value is represented by an object 
        whose interfaces provide for retrieval 
        (interface </textual><code class="po-atom e563 e563"><textual class="po-textual">XMDLParser</textual></code><textual class="po-textual">) and processing 
        (</textual><code class="po-atom e564 e564"><textual class="po-textual">XDMLProcessing</textual></code><textual class="po-textual">).
        The following sections give a brief overview of these and further
        interfaces which taken together amount to the user perspective 
        of XDML.
      </textual></para><section class="po-hcontainer e565 e565" xml:id="obtaining-an-xdml-processor"><title class="po-block e566 e566"><textual class="po-textual">Obtaining and extending the XDML processor</textual></title><para class="po-block e567 e567"><textual class="po-textual">
          The instantiation of XDML values requires an instance
          of the XDML processor. 
          The processor object represents the engine responsible for
          executing XDML operations. It implements interface
          </textual><code class="po-atom e568 e568"><textual class="po-textual">XDMLRegistry</textual></code><textual class="po-textual"> which enables the XDML user
          to register proprietary operations:
          </textual><programlisting class="po-block e569 e569" xml:space="preserve"><textual class="po-textual">
XDMLProcessor xp = XDMLProcessorFactory.newXDMLProcessor();
xp.registerXDMLOperations(new WaterOperations());
xp.registerXDMLOperations(new WeatherOperations());
</textual></programlisting><textual class="po-textual">
          Now we are ready to begin working with XDML values.
        </textual></para></section><section class="po-hcontainer e570 e570" xml:id="obtaining-an-xdml-value"><title class="po-block e571 e571"><textual class="po-textual">Obtaining an XDML value</textual></title><para class="po-block e572 e572"><textual class="po-textual">
          An XDML value is represented by an instance of class
          </textual><code class="po-atom e573 e573"><textual class="po-textual">XDML</textual></code><textual class="po-textual">. The XDML processor offers a
          generic method for instantiating XDML values:
          </textual><programlisting class="po-block e574 e574" xml:space="preserve"><textual class="po-textual">
void newXDML(Object dataSource) throws XDMLException;
</textual></programlisting><textual class="po-textual">
          Note that the signature does not constrain the data type of the data source.
          Which type(s) are supported depends on the actual implementation of the 
          processor. Our prototypic implementation expects an
          </textual><code class="po-atom e575 e575"><textual class="po-textual">XQSequence</textual></code><textual class="po-textual"> object, which is the XQJ representation
          [</textual><xref class="po-milestone e576 e576" linkend="JSR-XQJ"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] of an XDM value. Typical code snippet:
          </textual><programlisting class="po-block e577 e577" xml:space="preserve"><textual class="po-textual">
XQSequence xdm = …;            // procure XDM value
XDML xdml = xp.newXDML(xdm);   // create XDML value
</textual></programlisting><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e578 e578" xml:id="parsing-an-xdml-value"><title class="po-block e579 e579"><textual class="po-textual">Parsing an XDML value</textual></title><para class="po-block e580 e580"><textual class="po-textual">
          Class </textual><code class="po-atom e581 e581"><textual class="po-textual">XDML</textual></code><textual class="po-textual"> implements a parser API which 
          supports iteration over the units as well as 
          random access:
          </textual><programlisting class="po-block e582 e582" xml:space="preserve"><textual class="po-textual">
interface XDMLParser {
   InformationUnit next();
   boolean hasNext();
   void rewind();

   InformationUnit getPart(QName partName);
   InformationUnit getPart(QName[] partNames);  // access nested part
   InformationUnit getPartByID(String partID);

   …   
}
</textual></programlisting><textual class="po-textual">
          If the information unit is complex, it is represented by an
          </textual><code class="po-atom e583 e583"><textual class="po-textual">XDML</textual></code><textual class="po-textual"> object delivered by the </textual><code class="po-atom e584 e584"><textual class="po-textual">InformationUnit</textual></code><textual class="po-textual">
          object:
          </textual><programlisting class="po-block e585 e585" xml:space="preserve"><textual class="po-textual">
class InformationUnit implements DataUnit, MetadataUnit {
   XDML getComplexValue();
   boolean isValueComplex();
   ...
</textual></programlisting><textual class="po-textual">           
          Class </textual><code class="po-atom e586 e586"><textual class="po-textual">InformationUnit</textual></code><textual class="po-textual"> implements two interfaces for accessing
          the data value (interface </textual><code class="po-atom e587 e587"><textual class="po-textual">DataUnit</textual></code><textual class="po-textual">) and metadata
          (</textual><code class="po-atom e588 e588"><textual class="po-textual">MetadataUnit</textual></code><textual class="po-textual">) of a simple unit. 
          The </textual><emphasis class="po-inline e589 e589" role="ital"><textual class="po-textual">data value</textual></emphasis><textual class="po-textual"> is always retrieved 
          as a single object (which may 
          be an array object) – never by iterating over the items of the 
          value. There are many possible types and for each 
          one there is a specific retrieval method. The range of data types 
          includes several types which have no default mapping to an XDM
          value, as the interface must also handle values which result
          from a value translation (via </textual><code class="po-atom e590 e590"><textual class="po-textual">&lt;xm:translate&gt;</textual></code><textual class="po-textual"> metadata)
          or which are the return value of an XDML operation -
          e.g. several map types:
          </textual><programlisting class="po-block e591 e591" xml:space="preserve"><textual class="po-textual">
interface DataUnit {
   // *** read value
   Node         getNode();
   Node[]       getNodes();
   int          getInteger();
   int[]        getIntegers();
   String       getString();
   String[]     getStrings();
   Duration     getDuration();
   Duration[]   getDurations();   
   …
   Object       getObject();    // allows for a DataUnit to contain ANY type

   // *** write value
   void         setNode(Node value);
   void         setNodes(Node[] value);
   ...
   void         setObject(Object value, String typeName);
}
</textual></programlisting><textual class="po-textual">
          The retrieval of </textual><emphasis class="po-inline e592 e592" role="ital"><textual class="po-textual">metadata</textual></emphasis><textual class="po-textual"> is different 
          dependent on the metadata component. Descriptive metadata and translation 
          metadata are delivered as a metadata set:
          </textual><programlisting class="po-block e593 e593" xml:space="preserve"><textual class="po-textual">
interface MetadataUnit {
   MetadataSet getDescriptiveMetadata(String topic);
   MetadataSet getTranslationMetadata(String targetLanguage);
   String[] getDescriptiveTopics();
   String[] getTranslationTargetLanguages();
   ...
}
</textual></programlisting><textual class="po-textual">
          A metadata set is a set of named properties; similar to the 
          parameters of request messages, property names are QNames 
          and values are either a string, or a node, or a sequence of nodes:
          </textual><programlisting class="po-block e594 e594" xml:space="preserve"><textual class="po-textual">
interface MetadataSet {
   QName[] getPropertyNames();
   String  getStringProperty(QName name);
   Node    getNodeProperty(QName name);
   Node[]  getNodesProperty(QName name);
   …
}
</textual></programlisting><textual class="po-textual">
          Other metadata – that is, metadata components corresponding to 
          execution contexts (other than “translate”) – are delivered as 
          </textual><emphasis class="po-inline e595 e595" role="ital"><textual class="po-textual">methods</textual></emphasis><textual class="po-textual"> or a map of named methods:
          </textual><programlisting class="po-block e596 e596" xml:space="preserve"><textual class="po-textual">
interface MetadataUnit {
   …
   Method getFinalizationMethod();
   Method getExecutionMethod();
   Map&lt;QName, Method&gt; getInterfaceMethods();
}
</textual></programlisting><textual class="po-textual">
          A </textual><code class="po-atom e597 e597"><textual class="po-textual">Method</textual></code><textual class="po-textual"> is a sequence of operation requests:
          </textual><programlisting class="po-block e598 e598" xml:space="preserve"><textual class="po-textual">
interface Method {
   int              getOperationCount();
   OperationRequest getOperationRequest(int index);
   Integer          getDataContext(int index);
      // data context is the return value of a preceding operation (&gt;0), or the unit value (0), or null
}
</textual></programlisting><textual class="po-textual">

          See </textual><xref class="po-milestone e599 e599" linkend="data-model-of-input-and-output"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for details 
          about interface OperationRequest.
        </textual></para></section><section class="po-hcontainer e600 e600" xml:id="processing-an-xdml-value"><title class="po-block e601 e601"><textual class="po-textual">Processing an XDML value</textual></title><para class="po-block e602 e602"><textual class="po-textual">
          Any processing happens in response to an API call of the XDML user (</textual><code class="po-atom e603 e603"><textual class="po-textual">finalize</textual></code><textual class="po-textual">, </textual><code class="po-atom e604 e604"><textual class="po-textual">execute</textual></code><textual class="po-textual">,
          </textual><code class="po-atom e605 e605"><textual class="po-textual">invoke</textual></code><textual class="po-textual">). Here comes the processing interface implemented by class </textual><code class="po-atom e606 e606"><textual class="po-textual">XDML</textual></code><textual class="po-textual">:
          </textual><programlisting class="po-block e607 e607" xml:space="preserve"><textual class="po-textual">
interface XDMLProcessing {
   void finalize();
   void finalize(Arguments args);
   void finalize(QName part);
   void finalize(QName part, Arguments args);

   void execute();
   void execute(Arguments args);
   void execute(QName part);
   void execute(QName part, Arguments args);

   Object invoke(QName part, QName methodName);
   Object invoke(QName part, QName methodName, Arguments args);

   boolean isFinalized();
   boolean isFinalized(QName part);
   boolean isExecuted();
   boolean isExecuted(QName part);
}
</textual></programlisting><textual class="po-textual">
          If arguments are passed to the processing, they will be used in the respective request messages
          for resolving argument references of the syntax </textual><code class="po-atom e608 e608"><textual class="po-textual">$arg(argName)</textual></code><textual class="po-textual"> (see
          </textual><xref class="po-milestone e609 e609" linkend="parameter-values-supplied-by-the-xdml-user"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). Setting arguments is straightforward:
          </textual><programlisting class="po-block e610 e610" xml:space="preserve"><textual class="po-textual">
Document weatherData = ...;
String location = "NY";

Arguments args = xdml.newArguments();
args.set(new QName("location"), location);
args.set(new QName("weatherData"), weatherData); 
</textual></programlisting><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e611 e611" xml:id="example"><title class="po-block e612 e612"><textual class="po-textual">Example</textual></title><para class="po-block e613 e613"><textual class="po-textual">
          An example handles the following scenario. Two datasets – one representing 
          hydrological measurements, the other meteorological data – are the input 
          for an evaluation yielding an XML report. Some value extraction, as
          well as HTML and CVS representations of 
          the report should be available on demand. Before creating the report, the 
          input datasets must be procured: weather data are obtained from a SOAP 
          service, water data are downloaded from a relational database. The 
          following code snippet demonstrates XDML user code:
        </textual><programlisting class="po-block e614 e614" xml:space="preserve"><textual class="po-textual">
// *** obtain XDML value
XDMLProcessor xp = XDMLProcessorFactory.newXDMLProcessor();
XQSequence xdm = …;   // procure source data (e.g. exec XQuery) 
XDML xdml = xp.newXDML(xdm);

// *** use XDML value
xdml.finalize();
Map&lt;String,String&gt; results = (Map&lt;String,String&gt;) xdml.invoke("report", "getResultTable");
String html = (String) xdml.invoke("report", "getHTML");
String[] cvs = (String[])  xdml.invoke("report", "getCVS");
</textual></programlisting><textual class="po-textual">
          Although the processing requires the use of various technologies 
          (XQuery, XSLT, SOAP, SQL), the client code is very simple and 
          unawares of the complexity involved:
          </textual><itemizedlist class="po-table e615 e615"><listitem class="po-container e616 e616"><para class="po-block e617 e617"><textual class="po-textual">
                Calling </textual><code class="po-atom e618 e618"><textual class="po-textual">finalize</textual></code><textual class="po-textual"> accomplishes ...
                </textual><itemizedlist class="po-table e619 e619"><listitem class="po-container e620 e620"><para class="po-block e621 e621"><textual class="po-textual">retrieval of a dataset via SOAP</textual></para></listitem><listitem class="po-container e622 e622"><para class="po-block e623 e623"><textual class="po-textual">retrieval of a dataset via SQL</textual></para></listitem><listitem class="po-container e624 e624"><para class="po-block e625 e625"><textual class="po-textual">execution of an XQuery script producing the XML report</textual></para></listitem></itemizedlist><textual class="po-textual">
              </textual></para></listitem><listitem class="po-container e626 e626"><para class="po-block e627 e627"><textual class="po-textual">
                Calling </textual><code class="po-atom e628 e628"><textual class="po-textual">invoke(..., "getResultTable")</textual></code><textual class="po-textual"> creates a value extraction
              </textual></para></listitem><listitem class="po-container e629 e629"><para class="po-block e630 e630"><textual class="po-textual">
                Calling </textual><code class="po-atom e631 e631"><textual class="po-textual">invoke(..., "getHtml")</textual></code><textual class="po-textual"> creates an HTML representation
              </textual></para></listitem><listitem class="po-container e632 e632"><para class="po-block e633 e633"><textual class="po-textual">
                Calling </textual><code class="po-atom e634 e634"><textual class="po-textual">invoke(..., "getCVS")</textual></code><textual class="po-textual"> creates a CVS representation
              </textual></para></listitem></itemizedlist><textual class="po-textual">
          The following table summarizes the structure of the XDML value enabling 
          this simplicity:
          </textual><table class="po-container e635 e635"><caption class="po-container e636 e636"><para class="po-block e637 e637"><textual class="po-textual">
                </textual><emphasis class="po-inline e638 e638" role="bold"><emphasis class="po-inline e639 e639" role="ital"><textual class="po-textual">Example: information units providing simplified processing.</textual></emphasis></emphasis><textual class="po-textual">
              </textual></para></caption><col align="left" class="po-meta e640 e640" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e641 e641" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e642 e642"><tr class="po-table e643 e643" valign="top"><th align="left" class="po-field e644 e644" valign="top"><textual class="po-textual">Unit name</textual></th><th align="left" class="po-field e645 e645" valign="top"><textual class="po-textual">Semantics</textual></th><th align="left" class="po-field e646 e646" valign="top"><textual class="po-textual">(Initial) unit value</textual></th><th align="left" class="po-field e647 e647" valign="top"><textual class="po-textual">Context : used operations</textual></th></tr></thead><tbody class="po-table e648 e648"><tr class="po-table e649 e649" valign="top"><td class="po-block e650 e650"><textual class="po-textual">toHTML</textual></td><td class="po-block e651 e651"><textual class="po-textual">tool for transforming the report to HTML</textual></td><td class="po-block e652 e652"><textual class="po-textual">an XSLT stylesheet</textual></td><td class="po-block e653 e653"><textual class="po-textual">-</textual></td></tr><tr class="po-table e654 e654" valign="top"><td class="po-block e655 e655"><textual class="po-textual">toCVS</textual></td><td class="po-block e656 e656"><textual class="po-textual">tool for transforming the report to CVS</textual></td><td class="po-block e657 e657"><textual class="po-textual">an XQuery program</textual></td><td class="po-block e658 e658"><textual class="po-textual">-</textual></td></tr><tr class="po-table e659 e659" valign="top"><td class="po-block e660 e660"><textual class="po-textual">weatherData</textual></td><td class="po-block e661 e661"><textual class="po-textual">weather data</textual></td><td class="po-block e662 e662"><textual class="po-textual">payload of a SOAP request</textual></td><td class="po-block e663 e663"><textual class="po-textual">finalize:sendSOAP</textual></td></tr><tr class="po-table e664 e664" valign="top"><td class="po-block e665 e665"><textual class="po-textual">waterData</textual></td><td class="po-block e666 e666"><textual class="po-textual">water data</textual></td><td class="po-block e667 e667"><textual class="po-textual">text of a SQL SELECT statement</textual></td><td class="po-block e668 e668"><textual class="po-textual">finalize:execAsSQL</textual></td></tr><tr class="po-table e669 e669" valign="top"><td class="po-block e670 e670"><textual class="po-textual">report</textual></td><td class="po-block e671 e671"><textual class="po-textual">
                  an XML report with an interface
                </textual></td><td class="po-block e672 e672"><textual class="po-textual">an XQuery program</textual></td><td class="po-block e673 e673"><textual class="po-textual">
                  </textual><para class="po-block e674 e674"><textual class="po-textual">finalize:execAsXQuery</textual></para><textual class="po-textual">
                  </textual><para class="po-block e675 e675"><textual class="po-textual">invoke:createMapFromStrings</textual></para><textual class="po-textual">
                  </textual><para class="po-block e676 e676"><textual class="po-textual">invoke:submitToXQuery</textual></para><textual class="po-textual">
                  </textual><para class="po-block e677 e677"><textual class="po-textual">invoke:submitToXSLT</textual></para><textual class="po-textual">
                </textual></td></tr></tbody></table><textual class="po-textual">
        </textual></para><para class="po-block e678 e678"><textual class="po-textual">
          An abbreviated representation of the XDM value follows:
        </textual><programlisting class="po-block e679 e679" xml:space="preserve"><textual class="po-textual">
&lt;xm:part name="toHTML" partID="toHTML" type="node" private="true"/&gt;,
&lt;xsl:transform…&gt;…&lt;/xsl:transform&gt;
,

&lt;xm:part name="toCVS" partID="toCVS" type="string" private="true"&gt;,
xquery 1.0 …
…
,

&lt;xm:part name="weatherData" partID="we" type="node" finalType="node"&gt;
   &lt;xm:finalize&gt;
      &lt;sendSOAP href="…" /&gt;
   &lt;/xm:finalize&gt;
&lt;/xm:part&gt;,
&lt;getWeatherData&gt;…&lt;/getWeatherData&gt;
,

&lt;xm:part name="waterData" partID="wa" type="string" finalType="node"&gt;
   &lt;xm:finalize&gt;
      &lt;execAsSQL driver="…" host="…" db="…" user="…" password="…" format="xml"/&gt;
   &lt;/xm:finalize&gt;
&lt;/xm:part&gt;,
SELECT …
,

&lt;xm:part name="report" type="string" finalType="node"&gt;
   &lt;xm:finalize requiredParts="we wa"&gt;
      &lt;execAsXQuery resultType="node"&gt;
         &lt;xm:params&gt;
            &lt;weatherData&gt;$part{we}&lt;/weatherData&gt;
            &lt;waterData&gt;$part{wa}&lt;/waterData&gt;
         &lt;/xm:params&gt;
      &lt;/execAsXQuery&gt;
   &lt;/xm:finalize&gt;

   &lt;xm:interface&gt;
      &lt;xm:method name="getResultTable" returnType="map_string_to_string"&gt;
         &lt;submitToXQuery resultType="strings"&gt;
            &lt;query&gt;...&lt;/query&gt;
         &lt;/submitToXQuery&gt;
         &lt;createMapFromStrings/&gt;
      &lt;/xm:method&gt;
      &lt;xm:method name="toHTML" returnType="string"&gt;
         &lt;submitToXSLT serialize="true"&gt;
            &lt;stylesheet&gt;$part{toHTML}&lt;/stylesheet&gt;
         &lt;/submitToXSLT&gt;
      &lt;/xm:method&gt;
      &lt;xm:method name="toCVS" returnType="strings"&gt;
         &lt;submitToXQuery resultType="strings"&gt;
            &lt;query&gt;$part{toCVS}&lt;/query&gt;
         &lt;/submitToXQuery&gt;
      &lt;/xm:method&gt;
   &lt;/xm:interface&gt;
&lt;/xm:part&gt;,
xquery 1.0
declare variable $weatherData as node() external;
declare variable $waterData as node() external;
&lt;waterReport&gt;{
   …
}&lt;/waterReport&gt;
</textual></programlisting><textual class="po-textual">
        </textual></para></section></section><section class="po-hcontainer e680 e680" xml:id="generalization-xdml-as-an-information-model"><title class="po-block e681 e681"><textual class="po-textual">Generalization: XDML as an information model</textual></title><para class="po-block e682 e682"><textual class="po-textual">
        The concept of XDML can be generalized by distinguishing the 
        encoding of XDML values from their information model.
      </textual></para><section class="po-hcontainer e683 e683" xml:id="encoding-xdml-with-map-items"><title class="po-block e684 e684"><textual class="po-textual">Encoding XDML with map items</textual></title><para class="po-block e685 e685"><textual class="po-textual">
          This paper describes a technique how to create XDML values by 
          augmenting an XDM value with control items. The use of control 
          items amounts to encoding an information model which is based 
          on the concept of information units. It is important to note 
          that the XDML API does not reflect this encoding. Therefore 
          XDML user code does not depend on how the XDML value is encoded. 
          It is possible that a future version of XDML supports additional 
          encodings which do not rely on control items. 
        </textual></para><para class="po-block e686 e686"><textual class="po-textual">
          In this context, recent work of W3C working groups on the XDM model 
          promises an interesting alternative. The current working draft of the 
          XDM specification version 3.0 [</textual><xref class="po-milestone e687 e687" linkend="W3C-XDM-3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] 
          introduces as new item type a “map item” 
          which uses atomic values as keys and sequences of XDM items as values. 
          It is easy to encode XDML values as defined in this paper using map 
          items instead of inserting control items between data items. 
          The change amounts to shifting control items and data items
          from their linear arrangement into a couple of map items,
          one receiving the control items and the other receiving the data items.
          This is shown in two steps. First assume 
          an XDML value which does not contain any metadata – which only structures 
          the overall XDM value into named units. The information content can be 
          represented by an XDM value obeying the following rules:
          </textual><itemizedlist class="po-table e688 e688"><listitem class="po-container e689 e689"><para class="po-block e690 e690"><textual class="po-textual">
                the value consists of a single map item which uses QNames as keys
              </textual></para></listitem><listitem class="po-container e691 e691"><para class="po-block e692 e692"><textual class="po-textual">
                the map values are XDM values which either do not contain map items 
                or consist of a single map item
              </textual></para></listitem><listitem class="po-container e693 e693"><para class="po-block e694 e694"><textual class="po-textual">
                any nested maps are constrained in the same way as the top-level map: 
                keys are QNames, values are XDM values which either do not contain 
                map items or consist of a single map item
              </textual></para></listitem></itemizedlist><textual class="po-textual">
          In order to reestablish our full XDML model which associates information 
          units with metadata, the above rules are modified by replacing each map item 
          with a sequence of two map items, the first one representing the
          data of the information units, the second one representing the
          associated metadata and the map keys encoding the names of the units.
          The metadata of a unit can again be represented by a single 
          </textual><code class="po-atom e695 e695"><textual class="po-textual">&lt;xm:part&gt;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e696 e696"><textual class="po-textual">&lt;xm:complexPart&gt;</textual></code><textual class="po-textual">
          element item. The net result is a lossless encoding of 
          the XDML information model using map items rather than inserting control items
          between data items.
        </textual></para><para class="po-block e697 e697"><textual class="po-textual">
          The relationship between the XDML data model and the new map items can 
          be further elucidated by regarding XDML values as 
          </textual><emphasis class="po-inline e698 e698" role="ital"><textual class="po-textual">dual maps</textual></emphasis><textual class="po-textual">: the keys are 
          associated with two entities, one representing the data, the other representing 
          associated metadata.
        </textual></para></section><section class="po-hcontainer e699 e699" xml:id="encoding-xdm-as-xml"><title class="po-block e700 e700"><textual class="po-textual">Encoding XDM as XML</textual></title><para class="po-block e701 e701"><textual class="po-textual">
          The XDML data model is based on the XDM model: the XDML value as a 
          whole is an XDM value, and the value of any (simple) information unit 
          is a sequence of XDM items, in other words – an XDM value. This 
          dependence on XDM does not preclude the option to encode the underlying 
          XDM value as a single XML document. This possibility is important, as 
          XSLT and XProc do not export XDM values, but export XML documents. A 
          generic XML encoding of XDM values can be easily defined. It might, for 
          example, represent each XDM item by a child node of a root element 
          representing the XDM value as a whole. The following listing provides an 
          illustrative example:
          </textual><programlisting class="po-block e702 e702" xml:space="preserve"><textual class="po-textual">
&lt;x:xdm xmlns:x="http://www.xdml.org/ns/xdm"&gt;
   &lt;x:item type="document"&gt;
      &lt;foo/&gt;
   &lt;/x:item&gt;
   &lt;x:item type="element"&gt;
      &lt;bar/&gt;
   &lt;/x:item&gt;
   &lt;x:item type="attribute" name="a" value="v"/&gt;
   &lt;x:item type="processing-instruction" value="foo a=x b=y"/&gt;
   &lt;x:item type="xs:string"&gt;hello&lt;/x:item&gt;
   &lt;x:item type="xs:integer"&gt;123&lt;/x:item&gt;
&lt;/x:xdm&gt;
</textual></programlisting><textual class="po-textual">
          Therefore, the factory method constructing an 
          XDML value might easily be extended 
          to load the XDML value from an XML document conforming to
	  an agreed upon “XDM schema”. 
        </textual></para></section></section></section><section class="po-hcontainer e703 e703" xml:id="discussion"><title class="po-block e704 e704"><textual class="po-textual">Discussion</textual></title><para class="po-block e705 e705"><textual class="po-textual">
        The languages XQuery and XSLT enable a very efficient and elegant processing 
        of XML resources. Their integration into programs written in general purpose
        languages - like Java - is therefore highly desirable. The potential
        contribution is 
        however limited by three major issues. First, XQuery and XSLT are designed
        to create information, rather than execute actions with side effects.
        Second, these languages are rather closed systems, 
        without a concept of embedding other technologies and domain-specific
        functionality. Third,
        the information delivered (XML and/or atomic values) is pure information without 
        behaviour, rather than objects associating information with
        specific behaviour, which means that downstream usage of the information
        may be a relatively complex and challenging task. These limitations of effect -
        "no actions, closed functionality, no behaviour" - is at odds with the 
        enormous power of the means which the X-languages offer. 
      </textual></para><para class="po-block e706 e706"><textual class="po-textual">
        XProc [</textual><xref class="po-milestone e707 e707" linkend="W3C-XPROC"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] addresses the first two limitations: it integrates
        the major XML technologies (XSLT, XQuery, XML Schema, ...) into a single
        script language, provides openness
        to other technologies (HTTP, system commands, ...) and enables to
        combine side-effect free processing with actions in a well-controlled
        way (based on distinct steps). XProc is a powerful approach
        to accomplish complex XML processing.
      </textual></para><para class="po-block e708 e708"><textual class="po-textual">
        XDML has a different emphasis: it concentrates on integrating
        XML technology into general purpose languages. 
        XDML strives to broaden the
        scope of what the X-developer can achieve as a
        contributor to a non-XML environment - rather than as the author
        of a standalone processing. He is enabled to
        define a complex postprocessing and its control by API client actions.
        This creates a novel
        possibility of leveraging XML technology to generate
        information associated with behaviour: 
        </textual><emphasis class="po-inline e709 e709" role="ital"><textual class="po-textual">information with an interface</textual></emphasis><textual class="po-textual">. 
        The usefulness of the behaviour hinges critically upon the functional
        wealth offered by the available XDML operations. Therefore we believe
        that the easy extensibility of the XDML processor by proprietary,
        domain specific XDML operations may be of key importance for
        the value which XDML has to offer.
      </textual></para></section><bibliography class="po-hcontainer e710 e710"><title class="po-block e711 e711"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e712 e712" xml:id="RENNAU2010" xreflabel="Rennau 2010"><textual class="po-textual">Hans-Juergen Rennau. 
      Java Integration of XQuery - an Information-Unit Oriented Approach.
      Presented at Balisage: The Markup Conference 2010, Montréal, Canada, August 3 - 6, 
      2010. In Proceedings of Balisage: The Markup Conference 2010. Balisage 
      Series on Markup Technologies, vol. 5 (2010). doi:10.4242/BalisageVol5.Rennau01.
      </textual><link class="po-inline e713 e713" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol5/html/Rennau01/BalisageVol5-Rennau01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e714 e714" xml:id="JSR-XQJ" xreflabel="XQJ Spec"><textual class="po-textual">Jim Melton et al, eds. 
      JSR 225: XQuery API for JavaTM (XQJ) 1.0 Specfication.
      </textual><link class="po-inline e715 e715" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jcp.org/en/jsr/detail?id=225</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e716 e716" xml:id="W3C-XDM" xreflabel="W3C XDM"><textual class="po-textual">Mary Fernandez et al, eds. 
      XQuery 1.0 and XPath 2.0 Data Model (XDM) W3C Recommendation 23 January 2007.
      </textual><link class="po-inline e717 e717" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e718 e718" xml:id="W3C-XDM-3.0" xreflabel="W3C XDM 3.0"><textual class="po-textual">Norman Walsh et al, eds. 
      XQuery and XPath Data Model 3.0 W3C Working Draft 14 June 2011.
      </textual><link class="po-inline e719 e719" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e720 e720" xml:id="W3C-XPROC" xreflabel="W3C XPROC"><textual class="po-textual">Norman Walsh et al, eds. 
      XProc: An XML Pipeline Language W3C Recommendation 11 May 2010.
      </textual><link class="po-inline e721 e721" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xproc/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>