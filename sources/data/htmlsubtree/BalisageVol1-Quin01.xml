<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TextRetrievalforXMLEncodedCorpora:ALexicalApproachANCHOR" name="TextRetrievalforXMLEncodedCorpora:ALexicalApproachTOC">Text Retrieval for XML-Encoded Corpora: A Lexical Approach</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ABriefDescriptionoftheFullTextFacilityANCHOR" name="ABriefDescriptionoftheFullTextFacilityTOC">A Brief Description of the Full Text Facility</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PrimarycharacteristicsANCHOR" name="PrimarycharacteristicsTOC">Primary characteristics</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ABriefDescriptionoflqtextANCHOR" name="ABriefDescriptionoflqtextTOC">A Brief Description of lq-text</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CommonalitiesBetweenTheApproachesANCHOR" name="CommonalitiesBetweenTheApproachesTOC">Commonalities Between The Approaches</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#LqtextandXML:ObjectivesANCHOR" name="LqtextandXML:ObjectivesTOC">Lq-text and XML: Objectives</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#LqtextArchitectureinDetailANCHOR" name="LqtextArchitectureinDetailTOC">Lq-text Architecture in Detail</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThelqtextlqkwicprogramANCHOR" name="ThelqtextlqkwicprogramTOC">The lq-text lqkwic program</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExtendinglqkwicANCHOR" name="ExtendinglqkwicTOC">Extending lqkwic</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AsampleprogramANCHOR" name="AsampleprogramTOC">A sample program</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#UnicodeANCHOR" name="UnicodeTOC">Unicode</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ComparingwithXQuery10orXSLT2+FullTextANCHOR" name="ComparingwithXQuery10orXSLT2+FullTextTOC">Comparing with XQuery 1.0 or XSLT 2 + Full Text</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AdvantagesofFullTextANCHOR" name="AdvantagesofFullTextTOC">Advantages of Full-Text</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AdvantagesofalexicalapproachANCHOR" name="AdvantagesofalexicalapproachTOC">Advantages of a lexical approach</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#JEXE:JustEnoughXMLEh?ANCHOR" name="JEXE:JustEnoughXMLEh?TOC">JEXE: Just Enough XML, Eh?</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FutureWorkANCHOR" name="FutureWorkTOC">Future Work</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">ancestor::e</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Brewer's Dictionary of Phrase and Fable</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Computational Linguistics</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">database</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">first</div>
         <div class="singletermTERMS">Full Text</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">g.q</div>
         <div class="singletermTERMS">glue</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">index</div>
         <div class="singletermTERMS">Information Retrieval</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">key word in context</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">lqkwic</div>
         <div class="singletermTERMS">lqaddfile</div>
         <div class="singletermTERMS">lqunindexfile</div>
         <div class="singletermTERMS">lqphrase</div>
         <div class="singletermTERMS">lqquery</div>
         <div class="singletermTERMS">lqrank</div>
         <div class="singletermTERMS">lqsort</div>
         <div class="singletermTERMS">lqshow</div>
         <div class="singletermTERMS">lqsed</div>
         <div class="singletermTERMS">liam@w3.org</div>
         <div class="singletermTERMS">Liam</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">Natural Language Processing</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">on his face</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">print phrases one per line</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">Quin</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">R. E.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">stemming</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML.parent.Tag.e</div>
         <div class="singletermTERMS">xargs</div>
         <div class="singletermTERMS">xmllint</div>
         <div class="singletermTERMS">xmlns</div>
         <div class="singletermTERMS">XML Activity lead</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TextRetrievalforXMLEncodedCorpora:ALexicalApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973">
      <div class="title e1">Text Retrieval for XML-Encoded Corpora: A Lexical Approach</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2008</div>
            <div class="confdates e5">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">This paper describes some modifications done to an open source
               text retrieval package to make it XML-aware, and contrasts this lexical
               approach, in which XML documents are primarily treated as sequences of
               characters rather than trees, with the W3C XPath 1.0 and XQuery 2.0
               Full-Text facility.
            </div>
            <div class="para e8">Specific usage scenarios are taken into consideration, including
               World Wide Web publication and the searching and analysis of text
               corpora for research purposes.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Liam</div>
               <div class="othername e12">R. E.</div>
               <div class="surname e13">Quin</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">Mr Quin has been involved with declarative, descriptive markup
                  since the early 1980s. He wrote his open-source text retrieval system
                  and first distributed it in the late 1980s.
               </div>
               <div class="para e16">He has worked at the World Wide Web Consortium since 2001, where
                  he is XML Activity Lead, or, informally, Mrs XML.
               </div>
            </div>
            <div class="affiliation e17">
               <div class="jobtitle e18">XML Activity lead</div>
               <div class="orgname e19">W3C</div>
            </div>
            <div class="email e20">liam@w3.org</div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright © 2008 Liam R E Quin. Used by permission.</div>
         </div>
         <div class="keywordset e23" role="author">
            <div class="keyword e24">XML</div>
            <div class="keyword e25">Full Text</div>
            <div class="keyword e26">Information Retrieval</div>
            <div class="keyword e27">Natural Language Processing</div>
            <div class="keyword e28">Computational Linguistics</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e29">
         <div class="title e30">Introduction</div>
         <div class="para e31">The W3C XML Query Working Group has published a specification for
            performing full-text queries over instances of the XPath and XQuery Data
            Model using an extension of the XQuery syntax. This is a text retrieval
            facility that operates on an abstract representation of XML trees, rather
            than on text files that happen to contain markup. Elements and their
            attributes are reified into hierarchies of nodes, text leaps into the
            lacunæ and swims between them, and not a pointy bracket in sight.
         </div>
         <div class="para e32">This paper compares the XQuery Full Text Facility with a more
            traditional open source text retrieval system, lq-text, and also explores
            the work done to make lq-text become more suitable to the processing needs
            of people who work with XML.
         </div>
         <div class="para e33">Disadvantage and advantages of the two approaches are
            discussed.
         </div>
      </div><a name="ABriefDescriptionoftheFullTextFacilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e34">
         <div class="title e35">A Brief Description of the Full Text Facility</div>
         <div class="para e36">Although this paper is primarily concerned with a lexical approach,
            an understanding of the XPath 2 and XQuery approach is useful, and will be
            taken as a baseline for comparison.
         </div>
         <div class="para e37">Informally, a full text search is a search to find all documents in
            a collection, or all elements of some specific type (for example)
            containing one or more specific words. For example, one might want to find
            all occurrences of the phrase “warm socks” in a multi-gigabyte corpus of
            text. The underlying assumption of full text is that the implementation
            uses an index that has been constructed separately in advance, although
            this is not necessarily true.
         </div><a name="PrimarycharacteristicsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e38">
            <div class="title e39">Primary characteristics</div>
            <div class="para e40">XQuery 1.0 and XPath 2.0 Full-Text 1.0 [
               <div class="xref e41" linkend="FullText-2007"></div>] extends XPath 2.0 (and XQuery 1.0 in turn,
               which itself extends XPath 2.0) to add support for explicit syntax for
               full text searches.
            </div>
            <div class="para e42">XPath 2.0 is node-based, matching text nodes which are contained
               by element nodes in a collection of XML document trees. The result is a
               Boolean value (when used in an XPath predicate) together with an
               optional numerical score or ranking.
            </div>
            <div class="para e43">The Full-Text facility includes a large number of possible
               modifiers, many of which are optional features and may or may or be
               available in any given implementation. These include (for example) both
               query expansion through a thesaurus and also query narrowing using a
               different sort of thesaurus. One can search for two tokens (words, for
               English) within a certain number of tokens, sentences or even
               paragraphs. The optional features are marked as being “at risk” in W3C
               parlance, meaning that unimplemented (or unimplementable) features will
               be dropped from the draft specification before it is published as a W3C
               Recommendation.
            </div>
         </div>
      </div><a name="ABriefDescriptionoflqtextANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e44">
         <div class="title e45">A Brief Description of lq-text</div>
         <div class="para e46">Lq-text is an open source text retrieval package that was first
            released in 1989. It has had sporadic development since then. Its main
            claims to fame are high precision, good performance (particularly when the
            data does not fit into available virtual memory), flexible concordance
            generation and an open, extensible, multi-process architecture.
         </div>
         <div class="para e47">Lq-text operates on text files. It makes an index to the files; this
            index stores the location of each occurrence of each natural-language word
            in all of the files. The resulting index is stored efficiently, and
            generally takes between a quarter and three quarters of the storage size
            of the original documents. The index is an adjunct; lq-text also refers to
            the original files, although these can be compressed to save space if
            needed. The package is designed to work best with many small files rather
            than a few large ones.
         </div>
         <div class="para e48">When lq-text indexes files, it can run a format-specific filter on
            each file before indexing it. The list of filters is currently built in to
            the software (but since it is open source, you can in fact change it if
            you wish).
         </div>
         <div class="para e49">A suite of separate Unix programs operate on the index for
            retrieval; some of these will be described in this paper. They are used in
            conjunction with each other, using a documented text-based format to
            communicate.
         </div>
         <div class="para e50">It is this open architecture that can be exploited to enable
            XML-specific searches, and that is the primary work described in this
            paper.
         </div>
      </div><a name="CommonalitiesBetweenTheApproachesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e51">
         <div class="title e52">Commonalities Between The Approaches</div>
         <div class="para e53">An underlying assumption is that some sort of indexing will have
            been performed before queries are run; this is of course for all full-text
            systems, and although in some cases the constructed indexes do not persist
            between invocations of the query software, usually the indexes are kept
            and re-used.
         </div>
         <div class="para e54">Although the Full-Text facility operates on trees and lq-text
            operates on flat text files, in practice both systems are matching
            sequence of tokens against an index, and returning matches based on text
            content.
         </div>
         <div class="para e55">The XQuery Update Facility allows queries to update documents, and,
            as a result, implementations must be able to re-index documents
            efficiently. Lq-text can also re-index documents, most efficiently when
            both the original and the new version are available.
         </div>
      </div><a name="LqtextandXML:ObjectivesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e56">
         <div class="title e57">Lq-text and XML: Objectives</div>
         <div class="para e58">The author wanted to experiment to understand what work would be
            needed to make lq-text be useful for people working with XML documents.
            Some goals of this work included:
         </div>
         <div class="itemizedlist e59">
            <div class="listitem e60">
               <div class="para e61">Make minimal changes to the architecture and index and match
                  format, because of limited programming resources;
               </div>
            </div>
            <div class="listitem e62">
               <div class="para e63">Retain a small index and efficient retrieval;</div>
            </div>
            <div class="listitem e64">
               <div class="para e65">Solve common use cases rather than providing extensive and
                  general mechanisms.
               </div>
            </div>
         </div>
         <div class="para e66">Although lq-text was not (at the start of the work) XML-aware, it
            has the ability to run a format-specific filter program when indexing any
            given document. There was already an SGML filter, but all it did was
            ensure that element and attribute names were not indexed. This filter was
            re-used for XML, modified to allow indexing of elements and attributes.
            But at that point the work had only begun.
         </div>
         <div class="para e67">The following use cases were determined sufficient for
            experiments:
         </div>
         <div class="itemizedlist e68">
            <div class="listitem e69">
               <div class="para e70">Identify all documents containing two or more phrases in the
                  same element, for any given element;
               </div>
            </div>
            <div class="listitem e71">
               <div class="para e72">Refine the search to an element with a specific attribute set to
                  a given value;
               </div>
            </div>
            <div class="listitem e73">
               <div class="para e74">Highlight the matches of the search in context;</div>
            </div>
            <div class="listitem e75">
               <div class="para e76">For a given match, print the parent element and its content, or
                  the contents of the parent tag, or a given attribute value, or the
                  name of the parent element... possibly constrained to any named
                  ancestor element not just the parent.
               </div>
            </div>
         </div>
         <div class="para e77">This of course is much less than one might want in a full XML-aware
            text retrieval system. On the other hand, the XPath-based approach taken
            by the Full-Text facility does not support highlighting of matches or
            generation of concordances, and the author felt this to be essential
            functionality, both for research and for industrial or commercial
            use.
         </div>
         <div class="para e78">The approach taken was to extend 
            <div class="emphasis e79" role="ital">lqkwic</div>, the concordance program, so the paper will
            describe the lq-text architecture and then 
            <div class="emphasis e80" role="ital">lqkwic</div>, and then explain the extensions that were
            added. After that, an example program will be shown that uses 
            <div class="emphasis e81" role="ital">lqkwic</div> to solve one of the use cases given above.
            At that point we will be able to compare an XQuery or XSLT 2
            solution.
         </div>
         <div class="para e82">Support for a subset of XML (“just enough XML, Eh?”) was
            implemented; this subset will also be described, as it may be of interest
            for other people considering adding XML support to older software.
         </div>
      </div><a name="LqtextArchitectureinDetailANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e83">
         <div class="title e84">Lq-text Architecture in Detail</div>
         <div class="para e85">Before explaining how lq-text was extended, it is necessary to give
            at least an abbreviated account of how lq-text works.
         </div>
         <div class="para e86">Lq-text builds and maintains a separate index for each set of
            documents, which it calls a 
            <div class="emphasis e87" role="ital">database</div>.
            When building the index, lq-text applies simple 
            <div class="emphasis e88" role="ital">stemming</div>, by reducing words to a root. Currently,
            only plural and possessive forms are recognised and recorded, and other
            forms are indexed separately. This code is specific to the English
            language, and may be removed in a future version, with stemming instead
            being done by term expansion at query time.
         </div>
         <div class="para e89">Lq-text comprises a suite of separate programs, and each program
            always uses a single database. For the sake of simplicity in this paper we
            will assume that only a single lq-text database is in use at any time,
            unless otherwise stated.
         </div>
         <div class="para e90">Some of the programs included with lq-text are listed for reference
            in the table. Only a few of them will be discussed further in this paper,
            but the table may give the reader a clearer sense of the software.
         </div>
         <div class="table e91">
            <div class="caption e92">
               <div class="para e93">Lq-text Programs</div>
            </div>
            <div class="metaBox e94"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e167').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e167" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">align='right'
                     </span><span class="metaAttribute">class='e94'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="metaBox e95"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e168').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e168" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">class='e95'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="thead e96">
               <div class="tr e97" valign="top">
                  <div class="th e98">Program</div>
                  <div class="th e99">Purpose</div>
               </div>
            </div>
            <div class="tbody e100">
               <div class="tr e101" valign="top">
                  <div class="td e102">
                     <div class="emphasis e103" role="ital">lqaddfile</div>
                  </div>
                  <div class="td e104">Used to add documents to the index, and to manipulate the
                     index.
                  </div>
               </div>
               <div class="tr e105" valign="top">
                  <div class="td e106">
                     <div class="emphasis e107" role="ital">lqunindexfile</div>
                  </div>
                  <div class="td e108">removes a file from the index.</div>
               </div>
               <div class="tr e109" valign="top">
                  <div class="td e110">
                     <div class="emphasis e111" role="ital">lqphrase</div>
                  </div>
                  <div class="td e112">matches one or more exact phrases</div>
               </div>
               <div class="tr e113" valign="top">
                  <div class="td e114">
                     <div class="emphasis e115" role="ital">lqquery</div>
                  </div>
                  <div class="td e116">matches words or phrases, but supports wildcard expansion</div>
               </div>
               <div class="tr e117" valign="top">
                  <div class="td e118">
                     <div class="emphasis e119" role="ital">lqrank</div>
                  </div>
                  <div class="td e120">reorders results based on the number of documents matched
                     (quorum ranking)
                  </div>
               </div>
               <div class="tr e121" valign="top">
                  <div class="td e122">
                     <div class="emphasis e123" role="ital">lqsort</div>
                  </div>
                  <div class="td e124">sorts matches by various criteria e.g. by the word before the
                     match
                  </div>
               </div>
               <div class="tr e125" valign="top">
                  <div class="td e126">
                     <div class="emphasis e127" role="ital">lqshow</div>
                  </div>
                  <div class="td e128">text-terminal (curses) program to show matched text</div>
               </div>
               <div class="tr e129" valign="top">
                  <div class="td e130">
                     <div class="emphasis e131" role="ital">lqsed</div>
                  </div>
                  <div class="td e132">process documents, highlighting matches by insertion</div>
               </div>
               <div class="tr e133" valign="top">
                  <div class="td e134">
                     <div class="emphasis e135" role="ital">lqkwic</div>
                  </div>
                  <div class="td e136">the main keyword in context concordance program</div>
               </div>
            </div>
         </div>
         <div class="para e137">Once an index is built (for example with lqaddfile), it can be used.
            A sample search might be as follows:
         </div>
         <div class="programlisting e138" xml:space="preserve">$ lqquery "on his face" | lqkwic</div>
         <div class="para e139">For one small corpus (Brewer's Dictionary of Phrase and Fable, with
            about 17,000 files) the results are as follows:
         </div>
         <div class="programlisting e140" xml:space="preserve">==== Document 1: xml/1251.xml: Balafré ====
            1:t which left a frightful scar 
            <div class="emphasis e141" role="bold">on his face</div> (1550–1588).  So Ludovic Lesly, an
            ==== Document 2: xml/3720.xml: Cloud ====
            2: He [Antony] has a cloud 
            <div class="emphasis e142" role="bold">on his face</div>.
            ==== Document 3: xml/6070.xml F ====
            3: F is written 
            <div class="emphasis e143" role="bold">on his face</div>. “Rogue” is written on his face
            4: face. “Rogue” is written 
            <div class="emphasis e144" role="bold">on his face</div>. The letter F used to be branded n
            ==== Document 4: xml/8745.xml Ill Omens ====
            5: he happened to trip and fall 
            <div class="emphasis e145" role="bold">on his face</div>. This would have been considered a
            6: shore at Bulverhythe he fell 
            <div class="emphasis e146" role="bold">on his face</div>, and a great cry went forth that i
         </div>
         <div class="para e147">Here, the matched text is shown with a few words of context on
            either side, giving rise to the term 
            <div class="emphasis e148" role="ital">key word in
               context
            </div>, KWIC, 
            <div class="emphasis e149" role="ital">index</div>.
         </div>
         <div class="para e150">Two lq-text programs, 
            <div class="emphasis e151" role="ital">lqquery</div> and
            
            <div class="emphasis e152" role="ital">lqkwic</div>, were combined in the search,
            using a Unix pipe; that is, both programs were run concurrently, with the
            output of one being fed as the input to the other. This is a usual way of
            working with lq-text, and although it sometimes requires some thought, it
            does mean that lq-text exploits multi-processor systems well, and also
            works well with Unix and Linux, which were designed to run pipelines of
            small programs very efficiently.
         </div>
         <div class="para e153">This description begs the question, exactly what output is passed
            from 
            <div class="emphasis e154" role="ital">lqquery</div> to 
            <div class="emphasis e155" role="ital">lqkwic</div> in the example? The answer to this question
            exposes the underlying index architecture, and can be seen by running just
            the first program without the second:
         </div>
         <div class="programlisting e156" xml:space="preserve">$ lqquery "on his face"
            3 0 41 2792 1251.xml
            3 0 55 11703 3720.xml
            3 0 15 14314 6070.xml
            3 0 21 14314 6070.xml
            3 0 75 17285 8745.xml
            3 1 8 17285 8745.xml
         </div>
         <div class="para e157">The format, as can be determined by inspection, is a sequence of
            lines of text, and, in each line, a number of space-separated fields. Each
            line represents a single match, and just as there were six results before,
            there are six matches here. The fields are, from left to right, the number
            of words matched, the block in the file, the word in the block, the file
            number and (optionally) the filename.
         </div>
         <div class="para e158">The lq-text index does not store exact locations for matches.
            Instead, the location to the nearest block number, and the word within the
            block, are stored. Blocks are by default 128 bytes in size. The result of
            this is that a match location within a file is usually represented by a
            pair of fairly small integers, but that finding the actual intended words
            to highlight requires accessing the file and counting words. This is a
            trade-off: a lq-text index is often much smaller than the indexed files,
            because the average English word is about 5 characters long (depending
            somewhat on the corpus), and it only takes 2 bytes in most cases to store
            the information about a match.
         </div>
         <div class="para e159">Lines in the match list starting with a 
            <div class="code e160">#</div> are
            considered to be comments, and lines of the form
            
            <div class="code e161">{&nbsp;variable&nbsp;=&nbsp;value&nbsp;}</div> are used by
            
            <div class="emphasis e162" role="ital">lqkwic</div> to set values that can be used
            later, as we shall see.
         </div>
         <div class="para e163">Lq-text programs generally both accept this match format as input
            and produce it as output, so that they can be combined. In particular, the
            
            <div class="emphasis e164" role="ital">lqkwic</div> program can both read and produce
            this format, as we shall see in the next section.
         </div>
      </div><a name="ThelqtextlqkwicprogramANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e165">
         <div class="title e166">The lq-text lqkwic program</div>
         <div class="para e167">The lqkwic program takes lq-text matches as input, and prints them
            using a user-supplied format, or a built-in format. Matches are grouped by
            file, and another format is used to print the start of each group of
            documents, and yet another can be supplied to be used at the end of each
            group.
         </div>
         <div class="para e168">The format takes the form of a string with embedded variables that
            are interpolated each time the format is used. An example may clarify the
            format:
         </div>
         <div class="programlisting e169" xml:space="preserve">$ lqquery "on his fa*" |
            lqkwic -S '' -A '' -s '${MatchNumber} ${MatchedText}\n'
            1 on his father
            2 on his face
            3 on his favourite
            4 on his face
            5 on his father
            6 on his face
            7 on his face
            8 on his father
            9 on his favourite
            10 on his face
            11 on his face
         </div>
         <div class="para e170">Here, the formats for the start and end of each group of matches
            have been set to the empty string with 
            <div class="code e171">-S ''</div> and 
            <div class="code e172">-A
               ''
            </div> respectively. The per-match format is set to a string in which
            for each match the match number is printed, followed by a space, followed
            by the matched text and (indicated by 
            <div class="code e173">\n</div> in the grand Unix
            tradition) a newline. The single quotes are used to surround the strings
            to prevent the Unix shell from seeing the dollar signs and treating them
            as references to shell variables.
         </div>
         <div class="para e174">Although the MatchedText variable is obviously useful for testing,
            one would normally use it in conjunction with other variables, such as
            TextBefore and TextAfter. The purpose of this section is not to document
            lqkwic, but to give the reader an understanding of the sorts of things one
            can print, since lqkwic has uses that are far removed from concordance
            generation, and since we will shortly be taking advantage of such
            uses.
         </div>
         <div class="para e175">The following table shows some of the variables available. In many
            cases, lqkwic must read the actual matched documents (or at least part of
            them), in order to evaluate the variables.
         </div>
         <div class="table e176">
            <div class="caption e177">
               <div class="para e178">The lqkwic formatting variables</div>
            </div>
            <div class="metaBox e179"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e332').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e332" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">align='right'
                     </span><span class="metaAttribute">class='e179'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="metaBox e180"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e333').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e333" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">class='e180'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="thead e181">
               <div class="tr e182" valign="top">
                  <div class="th e183">Variable</div>
                  <div class="th e184">Description</div>
               </div>
            </div>
            <div class="tbody e185">
               <div class="tr e186" valign="top">
                  <div class="td e187">DocName</div>
                  <div class="td e188">the name of the current document, as stored in the database</div>
               </div>
               <div class="tr e189" valign="top">
                  <div class="td e190">FileName</div>
                  <div class="td e191">the absolute path corresponding to ${DocName}</div>
               </div>
               <div class="tr e192" valign="top">
                  <div class="td e193">DocTitle</div>
                  <div class="td e194">the title of the document</div>
               </div>
               <div class="tr e195" valign="top">
                  <div class="td e196">FID</div>
                  <div class="td e197">the File Identifier Number of the document (an integer)</div>
               </div>
               <div class="tr e198" valign="top">
                  <div class="td e199">FileNumber</div>
                  <div class="td e200">starts at 1, increases for each new document in the output</div>
               </div>
               <div class="tr e201">
                  <div class="td e202"></div>
                  <div class="td e203"></div>
               </div>
               <div class="tr e204" valign="top">
                  <div class="td e205">BlockInFile, WordInBlock</div>
                  <div class="td e206">these determine the location of the match</div>
               </div>
               <div class="tr e207" valign="top">
                  <div class="td e208">NumberOfWordsInPhrase</div>
                  <div class="td e209">the length in words of the phrase matched</div>
               </div>
               <div class="tr e210" valign="top">
                  <div class="td e211">TextBefore</div>
                  <div class="td e212">the text in the document immediately before the match</div>
               </div>
               <div class="tr e213" valign="top">
                  <div class="td e214">MatchedText</div>
                  <div class="td e215">the document text that exactly matches the phrase</div>
               </div>
               <div class="tr e216" valign="top">
                  <div class="td e217">TextAfter</div>
                  <div class="td e218">the text in the document immediately after the match</div>
               </div>
               <div class="tr e219">
                  <div class="td e220"></div>
                  <div class="td e221"></div>
               </div>
               <div class="tr e222" valign="top">
                  <div class="td e223">MatchNumber</div>
                  <div class="td e224">starts at 1 and increases for each match</div>
               </div>
               <div class="tr e225" valign="top">
                  <div class="td e226">MatchWithinFile</div>
                  <div class="td e227">like MatchNumber but reset for each new document</div>
               </div>
               <div class="tr e228" valign="top">
                  <div class="td e229">StartByte</div>
                  <div class="td e230">the byte offset in the file at which the match begins</div>
               </div>
               <div class="tr e231" valign="top">
                  <div class="td e232">EndByte</div>
                  <div class="td e233">the byte offset in the file at which the match ends</div>
               </div>
               <div class="tr e234" valign="top">
                  <div class="td e235">MatchLength</div>
                  <div class="td e236">length in bytes of ${MatchedText} (EndByte - StartByte)</div>
               </div>
            </div>
         </div>
         <div class="para e237">There are also constructs for formatting variables, for padding them
            to a given width (measured in Unicode characters, not bytes), and for
            filtering them through routines that delete punctuation, convert
            punctuation to spaces, perform case conversion and so forth.
         </div>
      </div><a name="ExtendinglqkwicANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e238">
         <div class="title e239">Extending lqkwic</div>
         <div class="para e240">The following XML-specific variables were added as an experiment to
            try to understand how viable the approach would be:
         </div>
         <div class="table e241">
            <div class="caption e242">
               <div class="para e243">XML-specific Variables</div>
            </div>
            <div class="metaBox e244"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e436').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e436" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">align='right'
                     </span><span class="metaAttribute">class='e244'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="metaBox e245"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e437').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e437" class="metaSource" style="display:none;">                
                  &lt;col<span class="metaAttribute">class='e245'
                     </span><span class="metaAttribute">span='1'
                     </span><span class="metaAttribute">valign='top'
                     </span>
                  &gt;
                  
               </div>
            </div>
            <div class="thead e246">
               <div class="tr e247" valign="top">
                  <div class="th e248">Variable</div>
                  <div class="th e249">Description</div>
               </div>
            </div>
            <div class="tbody e250">
               <div class="tr e251" valign="top">
                  <div class="td e252">XML.Parent.Tag</div>
                  <div class="td e253">The content of the containing element's tag, between the
                     	  angle brackets
                  </div>
               </div>
               <div class="tr e254" valign="top">
                  <div class="td e255">XML.ContentBefore</div>
                  <div class="td e256">Content up to the &gt; of the start tag of the immediately enclosing parent element (including
                     any tags and content that open and close entirely between the match and the parent
                     tag)
                  </div>
               </div>
               <div class="tr e257" valign="top">
                  <div class="td e258">XML.Parent.Name</div>
                  <div class="td e259">the name of the parent element</div>
               </div>
               <div class="tr e260" valign="top">
                  <div class="td e261">XML.Parent.EndTag</div>
                  <div class="td e262">the content of the parent element's end tag</div>
               </div>
               <div class="tr e263" valign="top">
                  <div class="td e264">XML.ContentAfter</div>
                  <div class="td e265">content up to the &lt; of the parent's end tag</div>
               </div>
            </div>
         </div>
         <div class="para e266">It is not clear that this is sufficient to answer our use case of
            finding multiple phrases in the same XML element. To do that, we would
            need a way to identify parent elements and compare them.
         </div>
         <div class="para e267">One could use the File number and the byte offset of the matched
            text (
            <div class="code e268">${StartByte}</div>), but this is not sufficient, because
            there may be close and open tags between matches of two phrases.
         </div>
         <div class="para e269">One approach to finding phrases with a common containing element
            named (of type) E would be to find all of the start and end tags for E,
            and then use the file, block and word within block numbers to perform
            range algebra.
         </div>
         <div class="para e270">But it would be more efficient if this were not needed. In a corpus
            of many files, it is likely that the element E will occur in many files,
            perhaps many times, and searching for them all will be too slow.
         </div>
         <div class="para e271">If lqkwic could print the location of the parent tag, a much simpler
            faster algorithm would be possible.
         </div>
         <div class="para e272">The notation 
            <div class="code e273">-&gt;startbyte</div> or
            
            <div class="code e274">-&gt;endbyte</div> was added; after any XML variable name, it
            generates the corresponding byte offset in the matched file.
         </div>
         <div class="para e275">In addition, the notation 
            <div class="code e276">XML.parent.Tag.e</div> was added,
            to be similar to the XPath notation 
            <div class="code e277">ancestor::e</div>; it is
            possible that a future version of 
            <div class="emphasis e278" role="ital">lqkwic</div>
            will use the XPath notation, as long as there is no danger that users will
            be confused into thinking that lq-text is using a node-based model
            internally.
         </div>
         <div class="para e279">The search for a parent tag is implemented by reading the matched
            document at the block containing the match, and for some distance
            beforehand. lqkwic then searches backwards from the match to find an open
            tag which has no corresponding close tag in the intervening distance. It
            is worth noting that this sort of approach is not generally possible with
            SGML, where empty elements have no end tag. The syntactic innovation of
            XML was to require empty tags to have a trailing slash, as in &lt;p/&gt;
            or &lt;p id="p301" /&gt;, and this enables the software to skip empty
            elements reliably. Start and end tags can be skipped more easily of
            course, although the algorithm used for backwards parsing does rely on
            attributes not containing unquoted &lt; or &gt; signs.
         </div>
         <div class="para e280">Unfortunately, backwards parsing suffers from a major drawback: the
            search for the parent tag will fail if it is too far away. Although lqkwic
            could in theory read arbitrarily back in the file, this could mean that
            presenting matches in a dictionary would be very expensive, with every
            match processed necessitating a search back to the start of a large
            document.
         </div>
         <div class="para e281">In practice, an in-memory cache may be sufficient to achieve
            reasonable performance in most cases. Another possibility might be to
            store parent pointers in the index. For now, lq-text is primarily intended
            for working with many thousands of small files; use XSLT to split large
            files before indexing them.
         </div>
      </div><a name="AsampleprogramANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e282">
         <div class="title e283">A sample program</div>
         <div class="para e284">We are now in a position to find all elements E that contain all of
            a set of phrases P0 ... Pn, as follows:
         </div>
         <div class="para e285">First, match the phrases, and, for each match, use a format of the
            form 
            <div class="code e286">${xml.contentbefore.E-&gt;endbyte}</div> to find the end byte
            of the start tag of the parent element of type E; that is, the location
            just after the 
            <div class="code e287">&gt;</div> at the end of the start tag. If two
            matches have the same value for the start tag, and are in the same file,
            then they share the same XML ancestor E.
         </div>
         <div class="para e288">We can match the phrases with a single invocation of 
            <div class="emphasis e289" role="ital">lqrank</div> except for one difficulty: there is no way
            to determine, for a given match, to which phrase it corresponds, so we
            cannot determine whether an element contains all of the phrases.
         </div>
         <div class="para e290">The 
            <div class="emphasis e291" role="ital">lqrank</div> program has the ability
            (when instructed with the 
            <div class="code e292">-g</div> option) to output a line,
            
            <div class="code e293">{&nbsp;q&nbsp;=&nbsp;N&nbsp;}</div> where N is an integer, to
            identify to which result set the following matches correspond. This is
            available to 
            <div class="emphasis e294" role="ital">lqkwic</div> formats as the
            variable 
            <div class="code e295">g.q</div> (the 
            <div class="code e296">g</div> stands for 
            <div class="emphasis e297" role="ital">glue</div>, the unpublished and unfinished lq-text
            integration language).
         </div>
         <div class="para e298">Using this, it becomes a relatively simple matter in a language such
            as Perl, Python or even the Unix shell, to run
         </div>
         <div class="programlisting e299" xml:space="preserve">
            <div class="emphasis e300" role="ital">print phrases one per line</div> |
            lqrank -r all -g -F - |
            lqkwic -s '${FID} ${g.q}
            ${xml.contentbefore.E-&gt;endbyte} ${Match}\n'
         </div>
         <div class="para e301">Each match is in this way prefixed by the numeric identifier of the
            document in the index (FID), the phrase number and the byte offset of the
            end of the nearest ancestor E element's end tag. The
            
            <div class="code e302">-F&nbsp;-</div> option makes 
            <div class="emphasis e303" role="ital">lqrank</div> read the list of phrases to match from its
            input, rather than expecting them as command-line arguments; one could
            also use the Unix 
            <div class="emphasis e304" role="ital">xargs</div> program for this
            purpose.
         </div>
         <div class="para e305">Next we must group the matches by file identifier and startbyte, and
            if every different phrase occurred at least once, we print all the matches
            for that file identifier and startbyte.
         </div>
         <div class="para e306">The result can then be fed to 
            <div class="emphasis e307" role="ital">lqkwic</div> to generate a concordance, or perhaps to
            fetch information about the parent element, or both.
         </div>
         <div class="para e308">The program outlined here (and given in full in the appendix, in the
            Perl programming language) is intended as an example of the sort of
            flexibility that might be achieved as lq-text becomes more XML
            aware.
         </div>
      </div><a name="UnicodeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e309">
         <div class="title e310">Unicode</div>
         <div class="para e311">In 1988, the use of 8-bit character sets was pretty usual; lq-text
            is at least 8-bit clean for data, so that conversion to UTF-8 seemed a
            simple matter, and also has some locale awareness. There were two tricky
            parts to the process of adding UTF-8 support. The first was to ensure that
            characters, rather than bytes, were counted when formatting, and of course
            that a UTF-8 octet sequence was never split part-way through.
         </div>
         <div class="para e312">The second difficulty was much harder: making sure that combining
            characters are never split from their corresponding base character. This
            last is not yet complete, but initial work using the GNOME glibc library
            is promising. This is the main issue preventing lq-text from being
            shipped, at present, and may have been completed by the time this paper is
            presented in August 2008.
         </div>
         <div class="para e313">Software cannot tell by inspecting a singly byte (or octet, as
            standards people say, in case 9-bit systems should reoccur) whether that
            octet forms part of a longer UTF-8 sequence. One needs to scan backwards
            to check, because the 
            <div class="emphasis e314" role="ital">first</div> octet is the
            one that indicates the number of octets to follow in the sequence that
            constitutes a single character. This is of course easy to deal with as
            long as one can scan backwards a little. For diacritical marks and other
            combining characters, however, one must consult a database. The author
            could not help but wish that a single bit in the character representation
            could have been reserved for this purpose, but that would have prevented
            Unicode from being backwards-compatible with ISO 8859-1, a goal at the
            time Unicode was designed. A future version of lq-text may use its own
            database, with only the character properties that lq-text needs, perhaps
            created automatically at the same time as each database so as to take
            locale information into account.
         </div>
      </div><a name="ComparingwithXQuery10orXSLT2+FullTextANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e315">
         <div class="title e316">Comparing with XQuery 1.0 or XSLT 2 + Full Text</div>
         <div class="para e317">The published draft of Full-Text does not support concordance
            generation, although some implementations in practice (such as MarkLogic)
            do appear to offer the necessary functionality through product-specific
            extensions. The author of this paper considers match highlighting to be
            essential functionality in practice. A future version of Full-Text may
            well include it.
         </div>
         <div class="para e318">Let us then assume, as we must, that we are using an XQuery or XSLT
            implementation that supports in some way identifying match locations, and
            hence allows highlighting.
         </div><a name="AdvantagesofFullTextANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e319">
            <div class="title e320">Advantages of Full-Text</div>
            <div class="orderedlist e321">
               <div class="listitem e322">
                  <div class="para e323">With Full-Text, XPath predicates and axes are available, so
                     that one can easily find ancestors, parents, position in the element
                     tree, and so forth. The lexical approach is very limited in this
                     regard.
                  </div>
               </div>
               <div class="listitem e324">
                  <div class="para e325">Full-Text is (or probably will soon be) a standard, and one
                     can easily move between implementations. The necessity of using
                     vendor extensions for highlighting reduces this somewhat, but of
                     course there is only one implementation of lq-text, albeit with
                     source code freely available.
                  </div>
               </div>
               <div class="listitem e326">
                  <div class="para e327">An XPath implementation with Full-Text might have indexes for
                     element location that enable higher performance, for example by
                     using one CPU to find elements and another to resolve the text
                     search. Although this sort of optimisation is largely at the
                     research level today, it is likely to find its way into products,
                     both closed and open source, in the near future. Lq-text uses
                     multiple programs, which can run on separate CPUs of course (and
                     will do so without any action from the user on a multi-CPU system)
                     but there are no plans for finer-grained parallelism.
                  </div>
               </div>
               <div class="listitem e328">
                  <div class="para e329">The Full-Text facility is designed to work with Unicode and
                     XML-based language support, giving a high degree of
                     internationalisation. Although the author is adding Unicode support
                     to lq-text (which previously, because it predated Unicode, used
                     8-bit character sets and a locale-based mechanism), it is not yet
                     complete and pervasive.
                  </div>
               </div>
               <div class="listitem e330">
                  <div class="para e331">Since lq-text is not tree-based, it does not currently have
                     any means to respect xml:lang, nor does it have any understanding of
                     namespaces. Prefixed elements and attribute names are not currently
                     handled. A solution involving the XML indexing filter is being
                     considered for both of these issues, but its effectiveness is as yet
                     unknown.
                  </div>
               </div>
               <div class="listitem e332">
                  <div class="para e333">The Full_text XPath extension is already in wider use than
                     lq-text; training, support, books and forums are available for it,
                     but not for lq-text.
                  </div>
               </div>
            </div>
         </div><a name="AdvantagesofalexicalapproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e334">
            <div class="title e335">Advantages of a lexical approach</div>
            <div class="orderedlist e336">
               <div class="listitem e337">
                  <div class="para e338">Open access to the match list supports flexibility and
                     extensibility. The use of separate programs also allows intermediate
                     results to be cached or stored and compared easily. By contrast,
                     XQuery (where Full-Text is most likely to be found) is a large
                     monolithic language. Open Source XQuery implementations are mostly
                     in Java, which does not lend itself to good performance if a JVM
                     must be started for each query, for example outside a servlet
                     environment. None the less it should be mentioned that the fastest
                     	  readily available indexed XQuery implementation in the
                     	  author's experience is in Java, and once
                     the JVM is started, is very fast.
                  </div>
               </div>
               <div class="listitem e339">
                  <div class="para e340">Because the data is not forced into the shape of a tree, it is
                     possible to experiment, for example with overlapping markup. The
                     generation of results by 
                     <div class="emphasis e341" role="ital">lqkwic</div> can
                     include a span from start element to corresponding end element,
                     	  regardless of other start or end tags.  Although XQuery
                     	  and XPath 2.0 Full-Text allows for matching as if tags were
                     	  absent, it does not give good control over which tags are to
                     	  be treated as word boundaries and which not.  But this is
                     	  a difficult thing to do at query-time in any case, and
                     neither system today has a complete answer for this.
                  </div>
               </div>
               <div class="listitem e342">
                  <div class="para e343">Lq-text can be used to generate non-XML results, for example a
                     bitmap image representing a graph of word occurrence. XQuery and
                     XSLT are limited to text and XML, although one can certainly write
                     out SVG with them.
                  </div>
                  <div class="figure e344">
                     <div class="title e345">Occurrences of four-digit numbers</div>
                     <div class="mediaobject e346">
                        <div class="imageobject e347">
                           <div class="metaBox e348"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e640').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e640" class="metaSource" style="display:none;">                
                                 &lt;imagedata<span class="metaAttribute">class='e348'
                                    </span><span class="metaAttribute">fileref='../../../vol1/graphics/Quin01/Quin01-001.png'
                                    </span><span class="metaAttribute">format='png'
                                    </span>
                                 &gt;
                                 
                              </div>
                           </div>
                        </div>
                     </div>
                     <div class="para e349">A graph showing four-digit numbers along the x-axis, from
                        1500 to 1890 (presumably most of which represent years), and on
                        the y-axis the number of times that number occurs in the corpus
                        (17,000 entries from 
                        <div class="emphasis e350" role="ital">Brewer's Dictionary of
                           Phrase and Fable
                        </div>).
                     </div>
                  </div>
               </div>
               <div class="listitem e351">
                  <div class="para e352">Experiments with Salton-style similarity functions,
                     clustering, and other Information Retrieval techniques might
                     eventually find their way back from work like this and into a future
                     Full-Text specification. See, for example 
                     <div class="xref e353" linkend="Salton-1989"></div> or 
                     <div class="xref e354" linkend="Konchady2006"></div> for
                     descriptions of some applicable information retrieval
                     techniques.
                  </div>
               </div>
               <div class="listitem e355">
                  <div class="para e356">Lq-text lies more in the world of traditional Unix text
                     processing than in the world of relational databases. If one is
                     primarily interested in finding content in a database, Full-Text is
                     a clear winner. If one is more interested in exploring or searching
                     text, perhaps lq-text has something to offer.
                  </div>
               </div>
            </div>
         </div><a name="JEXE:JustEnoughXMLEh?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e357">
            <div class="title e358">JEXE: Just Enough XML, Eh?</div>
            <div class="para e359">Some XML features were harder to see how to support than others.
               The author has no intent to support all of XML at this time, but just
               enough to be useful. This is regardless of how the XML is parsed. The
               following features are not supported, and are unlikely to be
               supported:
            </div>
            <div class="orderedlist e360">
               <div class="listitem e361">
                  <div class="para e362">CDATA sections; you can use entities instead. This is because
                     the retrieval software does not scan the document from the start
                     each time, but from the middle, and cannot determine whether markup
                     is part of a marked section.
                  </div>
               </div>
               <div class="listitem e363">
                  <div class="para e364">External general entities (and XInclude); it is more useful
                     for people working with XML as files to know the file than the
                     document; if you want to resolve included entities, use a
                     pre-processor such as 
                     <div class="emphasis e365" role="ital">xmllint</div>
                     before indexing.
                  </div>
               </div>
               <div class="listitem e366">
                  <div class="para e367">Arbitrary namespace support; the limit on namespaces is that
                     all 
                     <div class="emphasis e368" role="ital">xmlns</div> declarations must come
                     before any regular attributes. In other words, the order of
                     attributes (or pseudo-attributes) is significant. This may change in
                     the future; it is because of a limitation in the indexer to do with
                     the amount of available look-ahead.
                  </div>
               </div>
               <div class="listitem e369">
                  <div class="para e370">General entities; although support is planned for entities,
                     the plan is to read the replacement text from a per-database
                     configuration file. This is already done by lqkwic, but should also
                     be done by the indexer. This means that per-document entities are
                     not supported. External entities are not supported: the unit of
                     retrieval is the file, not the document.
                  </div>
               </div>
               <div class="listitem e371">
                  <div class="para e372">The internal subset; currently lq-text can skip over an
                     internal subset correctly in most cases (it is possible to construct
                     an internal subset that will confuse it, I suspect, although this is
                     always detected and a warning issued), but it is not parsed.
                  </div>
               </div>
               <div class="listitem e373">
                  <div class="para e374">Fixed and defaulted attribute values; without reading a DTD or
                     internal subset, there are no default values. This could be thought
                     of as a minimization feature of SGML that was overlooked during the
                     design of XML.
                  </div>
               </div>
               <div class="listitem e375">
                  <div class="para e376">XML Notations; if the DTD were to be read, it might be
                     possible to associate a URI or a MIME content type with a different
                     tokenisation system, but the document author cannot know what MIME
                     type will be used if a file is served on the Web; the DTD is not
                     authoritative, and currently lq-text does not use HTTP to fetch
                     things, but only works with local files. If lq-text used HTTP,
                     behaviour would be based on the content type header for downloaded
                     entities, not on any notation value in the DTD. For a local file,
                     the notation value could be treated as a list of plausible content
                     types, perhaps, but in practice content sniffing is more likely to
                     work.
                  </div>
               </div>
            </div>
            <div class="para e377">The result of this is that a JEXE document consists of an XML
               declaration (the encoding, if given, must be in UTF-8, however), an
               optional doctype declaration to point at an external DTD to be ignored,
               and then one (or more) simple element trees. Elements may have
               attributes, and may also declare namespaces. Namespace prefixes may be
               “normalised” based on a per-database configuration file, with elements
               in a default namespace that is associated with a URI given an explicit
               prefix [This feature is not implemented at the time of writing]. Numeric
               character references are expanded on indexing. Entity references are
               replaced by their per-database string values on retrieval; the plan is
               to index entity references both with their entity name and with their
               expanded value.
            </div>
            <div class="para e378">The resulting XML can be parsed “from the middle out” for the
               purposes of retrieval.
            </div>
            <div class="para e379">Although there is only support for a subset of XML, enough of the
               syntax is understood that you can index any XML document. However, some
               features, such as CDATA sections, permit the construction of documents
               that will confuse retrieval, even though the actual CDATA sections will
               be correctly parsed. A possible work-around is to process documents with
               XSLT before indexing them, creating surrogate documents.
            </div>
         </div><a name="FutureWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e380">
            <div class="title e381">Future Work</div>
            <div class="para e382">The work has shown that adding some simple XML support to lq-text
               is possible, but leaves a lot to be desired. For people already using
               lq-text, the support described in this paper is useful, but it is
               unlikely to persuade many people to try the package for the first
               time.
            </div>
            <div class="para e383">Adding more support for “just enough XML” will make the package
               more interesting. In the short term, extending the Unicode support is
               necessary before a release, as is more thorough testing and (as always)
               more documentation. After that, changes in the indexer to add support
               for (just enough) namespaces, general text entities and numeric
               character references have been sketched out.
            </div>
            <div class="para e384">There are no plans to use a full XML parser right now; although
               the author had originally intended to do so, the difficulty in tracking
               exact byte positions in the input delayed the work, and at this point
               although it is now possible, it has become a matter of human
               resources.
            </div>
            <div class="para e385">It is possible that the work here would be enough to enable
               lq-text to be used by an implementor of XQuery, and the author would
               like to do experiments in that area.
            </div>
            <div class="para e386">Searching a corpus of documents with disparate markup can be
               difficult with either approach, because one tends to write patterns that
               depend on the markup retrieved. One approach is to try to map queries at
               runtime; this can be a difficult problem of matching incompatible
               hierarchies of elements; see 
               <div class="xref e387" linkend="Euzenat-2007"></div> on various
               approaches to the problem of matching ontologies. A more pragmatic
               approach is to re-write documents before indexing them, perhaps with
               XSLT. This approach works with both approaches to text retrieval, but
               can be tedious. An intermediate approach might be to define some XPath
               expressions, or to use a W3C XML Schema to impost some specific types,
               to identify sections, titles, paragraphs, and to mark which elements are
               considered to break apart words, phrases and paragraphs. The index could
               then include this information alongside the element structure. More
               experiments in this area are planned.
            </div>
         </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e388">
            <div class="title e389">Conclusions</div>
            <div class="para e390">The author's original goal in adding XML support to lq-text was to
               use lq-text to help optimise an XQuery implementation. After
               experimenting with an XQuery implementation that supported Full-Text,
               the author decided instead to focus on enhancing lq-text to see if the
               results would be useful. It turns out that they are indeed useful, and
               development is continuing.
            </div>
            <div class="para e391">It must be admitted, however, that any advantage of lq-text over
               sophisticated XQuery implementations is likely to diminish over
               time.
            </div>
            <div class="para e392">The subset of XML supported (and with planned support), “just
               enough XML, Eh?” (JEXE), may be worth documenting separately.
            </div>
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e393">
         <div class="title e394">Bibliography</div>
         <div class="bibliomixed e395" xml:id="Adolphs-2006" xreflabel="Adolphs, 2006">Adolphs,
            Svenja, “Introducing Electronic Text Analysis” (Routledge, 2006). A very
            clear and impressively slender introduction to the application of
            information retrieval, and especially the keyword-in-context list, to
            literary and linguistic research.
         </div>
         <div class="bibliomixed e396" xml:id="Baeza-Yates-1999" xreflabel="Baeza-Yates and Marais, 1999">Baeza-Yates, Ricardo, and Marais, H., “Modern
            Information Retrieval” (ACM Press, 1999). Describes information retrieval
            mostly from the perspective of a researcher in text retrieval rather than
            a programmer or a user, and assumes more background knowledge,
            particularly in mathematics, than Manu Konchady’s book, so may be best
            read second.
         </div>
         <div class="bibliomixed e397" xml:id="Euzenat-2007" xreflabel="Euzenat and Shvaiko, 2007">Euzenat, Jérôme and Shvaiko, Pavel, “Ontology
            Matching” (Springer, 2007); a surprisingly clear introduction to problems
            such as relating two or more different classification schemes (such as XML
            schemas) over the same subject matter, although the presentation uses a
            mathematical notation, and some background in formal logic may be
            helpful.
         </div>
         <div class="bibliomixed e398" xml:id="Konchady2006" xreflabel="Konchady2006">Konchady,
            Manu, “Text Mining Application Programming” (Charles River Media, Boston
            USA, 2006). A useful programmer-level introduction to topics relating to
            implementing and using text retrieval, part-of-speech tagging, clustering
            and other topics, together with just enough mathematics, but not specific
            to any particular language. Includes CD-ROM with code samples in Perl,
            however.
         </div>
         <div class="bibliomixed e399" xml:id="Salton-1989" xreflabel="Salton, 1989">Salton, Gerald,
            “Automatic Text Processing” (Addison-Wesley, 1989). Perhaps a little
            dated, but the late Dr. Salton was extremely influential in the field. His
            earlier, 1983, book formed the basis for a single chapter of this work,
            but the 1983 book is harder to find today.
         </div>
         <div class="bibliomixed e400" xml:id="FullText-2007" xreflabel="W3C Full-Text, 2007">Sihem
            Amer-Yahia, Chavdar Botev, Stephen Buxton, Pat Case, Jochen Doerre, Mary
            Holstege, Jim Melton, Michael Rys and Jayavel Shanmugasundaram (Editors),
            “XQuery 1.0 and XPath 2.0 Full-Text 1.0” [online]. [cited 18th April
            2008].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e401" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-full-text-10/</div>.
         </div>
      </div>
   </div>
</div>