<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#InpursuitofstreamablestylesheetfunctionsinXSLT30ANCHOR" name="InpursuitofstreamablestylesheetfunctionsinXSLT30TOC">In pursuit of streamable stylesheet functions in XSLT 3.0</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#NotesANCHOR" name="NotesTOC">Notes</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DisclaimerANCHOR" name="DisclaimerTOC">Disclaimer</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreamingterminologyANCHOR" name="StreamingterminologyTOC">Streaming terminology</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcaseforstreamablefunctionsANCHOR" name="AcaseforstreamablefunctionsTOC">A case for streamable functions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Stylesheetfunctionsinstreamingscenariosbeforetheywereallowedtobe%0AstreamableANCHOR" name="Stylesheetfunctionsinstreamingscenariosbeforetheywereallowedtobe%0AstreamableTOC">Stylesheet functions in streaming scenarios before they were allowed to be
                  streamable</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThechallengeofstreamablestylesheetfunctionsANCHOR" name="ThechallengeofstreamablestylesheetfunctionsTOC">The challenge of streamable stylesheet functions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Approach1:analyzingstylesheetfunctionsstaticallyontheirownANCHOR" name="Approach1:analyzingstylesheetfunctionsstaticallyontheirownTOC">Approach 1: analyzing stylesheet functions statically on their own</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Approach2:analyzingstylesheetfunctionsfromthefunctioncallANCHOR" name="Approach2:analyzingstylesheetfunctionsfromthefunctioncallTOC">Approach 2: analyzing stylesheet functions from the function call</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Approach3:analyzingstylesheetfunctionsbasedonstaticpostureassessmentsANCHOR" name="Approach3:analyzingstylesheetfunctionsbasedonstaticpostureassessmentsTOC">Approach 3: analyzing stylesheet functions based on static posture assessments</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#InpursuitofflexiblerulesforguaranteedstreamablestylesheetfunctionsANCHOR" name="InpursuitofflexiblerulesforguaranteedstreamablestylesheetfunctionsTOC">In pursuit of flexible rules for guaranteed streamable stylesheet functions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MultipleargumentsthatcantakenodesANCHOR" name="MultipleargumentsthatcantakenodesTOC">Multiple arguments that can take nodes</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RecursivestreamablefunctionsANCHOR" name="RecursivestreamablefunctionsTOC">Recursive streamable functions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DirectrecursionANCHOR" name="DirectrecursionTOC">Direct recursion</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IndirectrecursionANCHOR" name="IndirectrecursionTOC">Indirect recursion</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IndeterminaterecursionANCHOR" name="IndeterminaterecursionTOC">Indeterminate recursion</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DynamicrecursionANCHOR" name="DynamicrecursionTOC">Dynamic recursion</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AnalyzableandnonanalyzablefunctionsANCHOR" name="AnalyzableandnonanalyzablefunctionsTOC">Analyzable and non-analyzable functions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#NonfinalstreamablefunctionsinpackagesANCHOR" name="NonfinalstreamablefunctionsinpackagesTOC">Non-final streamable functions in packages</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Animprovement:typedeterminedpostureANCHOR" name="Animprovement:typedeterminedpostureTOC">An improvement: type-determined posture</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MiscelleneousANCHOR" name="MiscelleneousTOC">Miscelleneous</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InlinefunctionsandstreamabilityANCHOR" name="InlinefunctionsandstreamabilityTOC">Inline functions and streamability</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PartialfunctionapplicationandstreamabilityANCHOR" name="PartialfunctionapplicationandstreamabilityTOC">Partial function application and streamability</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#NamedfunctionreferencesandstreamabilityANCHOR" name="NamedfunctionreferencesandstreamabilityTOC">Named function references and streamability</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DynamicfunctioncallsandstreamabilityANCHOR" name="DynamicfunctioncallsandstreamabilityTOC">Dynamic function calls and streamability</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreamabilityofstylesheetfunctionsaccordingtothespecificationANCHOR" name="StreamabilityofstylesheetfunctionsaccordingtothespecificationTOC">Streamability of stylesheet functions according to the specification</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheattributeonANCHOR" name="TheattributeonTOC">The  attribute on </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StatusofcurrentprocessorswithrespecttostreamablestylesheetfunctionsANCHOR" name="StatusofcurrentprocessorswithrespecttostreamablestylesheetfunctionsTOC">Status of current processors with respect to streamable stylesheet functions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">author/@name</div>
         <div class="singletermTERMS">ancestor::foo/bar</div>
         <div class="singletermTERMS">ancestor-or-self::para/@xml:lang</div>
         <div class="singletermTERMS">author[f:hasname(.)]</div>
         <div class="singletermTERMS">as="attribute()"</div>
         <div class="singletermTERMS">argument-posture</div>
         <div class="singletermTERMS">as</div>
         <div class="singletermTERMS">as="xs:integer"</div>
         <div class="singletermTERMS">ArgCount</div>
         <div class="singletermTERMS">Abrasoft</div>
         <div class="singletermTERMS">Abrasoft Consulting</div>
         <div class="singletermTERMS">Advantages of push-style XSLT over pull-style</div>
         <div class="singletermTERMS">Absorption:</div>
         <div class="singletermTERMS">absorption</div>
         <div class="singletermTERMS">Approach 2</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">abstract</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
         <div class="singletermTERMS">abel[-at-]exselt.net</div>
         <div class="singletermTERMS">Abel</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bar</div>
         <div class="singletermTERMS">Bug 25679</div>
         <div class="singletermTERMS">Bug 25185</div>
         <div class="singletermTERMS">Bugzilla - Public W3C Bug / Issue tracking system</div>
         <div class="singletermTERMS">base-uri</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
         <div class="singletermTERMS">Braaksma</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">count#0</div>
         <div class="singletermTERMS">count</div>
         <div class="singletermTERMS">Comment#1</div>
         <div class="singletermTERMS">Climbing:</div>
         <div class="singletermTERMS">Crawling:</div>
         <div class="singletermTERMS">Consuming:</div>
         <div class="singletermTERMS">consuming</div>
         <div class="singletermTERMS">climbing</div>
         <div class="singletermTERMS">crawling</div>
         <div class="singletermTERMS">context posture</div>
         <div class="singletermTERMS">Candidate Recommendation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">does</div>
         <div class="singletermTERMS">Direct recursion:</div>
         <div class="singletermTERMS">Dynamic recursion:</div>
         <div class="singletermTERMS">Direct-transitional</div>
         <div class="singletermTERMS">direct-transitional</div>
         <div class="singletermTERMS">dynamic</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Exselt</div>
         <div class="singletermTERMS">Exselt, a streaming XSLT 3.0 processor</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">fn:currentDateTime</div>
         <div class="singletermTERMS">fn:copy-of</div>
         <div class="singletermTERMS">fn:zero-or-one</div>
         <div class="singletermTERMS">fn:outermost</div>
         <div class="singletermTERMS">foo/descendant-or-self::bar</div>
         <div class="singletermTERMS">following::node()</div>
         <div class="singletermTERMS">fn:has-children(.)</div>
         <div class="singletermTERMS">fn:count(foo)</div>
         <div class="singletermTERMS">foo[bar]</div>
         <div class="singletermTERMS">fn:reverse(index)</div>
         <div class="singletermTERMS">fn:data</div>
         <div class="singletermTERMS">fn:string</div>
         <div class="singletermTERMS">fn:remove</div>
         <div class="singletermTERMS">fn:subsequence</div>
         <div class="singletermTERMS">fn:fold-left</div>
         <div class="singletermTERMS">fn:key</div>
         <div class="singletermTERMS">fn:innermost</div>
         <div class="singletermTERMS">f:square</div>
         <div class="singletermTERMS">fn:snapshot</div>
         <div class="singletermTERMS">false()</div>
         <div class="singletermTERMS">f:hasname(.)</div>
         <div class="singletermTERMS">f:thirdchild</div>
         <div class="singletermTERMS">f:equals(foo, bar)</div>
         <div class="singletermTERMS">foo</div>
         <div class="singletermTERMS">f:recur($n)</div>
         <div class="singletermTERMS">f:recur</div>
         <div class="singletermTERMS">f:climbstr(a/b)</div>
         <div class="singletermTERMS">f:recur(y)</div>
         <div class="singletermTERMS">f:filterattr</div>
         <div class="singletermTERMS">f:take-ancestor</div>
         <div class="singletermTERMS">f:filter-attr</div>
         <div class="singletermTERMS">f:indeter</div>
         <div class="singletermTERMS">fn:count</div>
         <div class="singletermTERMS">fn:name</div>
         <div class="singletermTERMS">FunctionName#ArgCount</div>
         <div class="singletermTERMS">Free-ranging:</div>
         <div class="singletermTERMS">free-ranging</div>
         <div class="singletermTERMS">final</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">grounded climbing striding crawling roaming</div>
         <div class="singletermTERMS">Guaranteed streamable:</div>
         <div class="singletermTERMS">Grounded:</div>
         <div class="singletermTERMS">grounded</div>
         <div class="singletermTERMS">guaranteed streamable</div>
         <div class="singletermTERMS">grounding</div>
         <div class="singletermTERMS">General Streamability Rules</div>
         <div class="singletermTERMS">guarantee</div>
         <div class="singletermTERMS">general streamability rules</div>
         <div class="singletermTERMS">Guaranteed-streamability</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">https://www.w3.org/Bugs/Public/</div>
         <div class="singletermTERMS">higher-order operand</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">if(./name()) then ...</div>
         <div class="singletermTERMS">if(a) then b else c</div>
         <div class="singletermTERMS">index-of(?, ?, "http://my-collation")</div>
         <div class="singletermTERMS">invited expert</div>
         <div class="singletermTERMS">Inspection:</div>
         <div class="singletermTERMS">Indirect recursion:</div>
         <div class="singletermTERMS">Indeterminate recursion:</div>
         <div class="singletermTERMS">in the context of the initial function call</div>
         <div class="singletermTERMS">inspection</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Last Call Working Draft</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">my:for-each</div>
         <div class="singletermTERMS">my:for-each(head//section)</div>
         <div class="singletermTERMS">my:for-each2(child::book)</div>
         <div class="singletermTERMS">my:for-each2(listing//book)</div>
         <div class="singletermTERMS">my:for-each(title/ancestor::book)</div>
         <div class="singletermTERMS">my:for-each2(*/books/book)</div>
         <div class="singletermTERMS">my:for-each2(*/books//book)</div>
         <div class="singletermTERMS">my:for-each1</div>
         <div class="singletermTERMS">my:for-each2</div>
         <div class="singletermTERMS">my:filter#3</div>
         <div class="singletermTERMS">my:filter</div>
         <div class="singletermTERMS">Motionless:</div>
         <div class="singletermTERMS">motionless</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">number</div>
         <div class="singletermTERMS">no</div>
         <div class="singletermTERMS">Navigation:</div>
         <div class="singletermTERMS">navigation</div>
         <div class="singletermTERMS">non-analyzable</div>
         <div class="singletermTERMS">not guaranteed streamable</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">Option 1:</div>
         <div class="singletermTERMS">Option 2:</div>
         <div class="singletermTERMS">Option 2</div>
         <div class="singletermTERMS">Owner/creator</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">parent::foo</div>
         <div class="singletermTERMS">preceding-sibling::price</div>
         <div class="singletermTERMS">parent::author/book</div>
         <div class="singletermTERMS">Public XSLT Bug 25185</div>
         <div class="singletermTERMS">Posture:</div>
         <div class="singletermTERMS">predicate patterns</div>
         <div class="singletermTERMS">packages</div>
         <div class="singletermTERMS">package</div>
         <div class="singletermTERMS">public</div>
         <div class="singletermTERMS">private</div>
         <div class="singletermTERMS">Packages</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">question 16631213 at StackOverflow</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Rescuing XSLT from Niche Status.</div>
         <div class="singletermTERMS">Roaming:</div>
         <div class="singletermTERMS">roaming</div>
         <div class="singletermTERMS">recursion point</div>
         <div class="singletermTERMS">Recursive-functions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">streamable</div>
         <div class="singletermTERMS">Saxon</div>
         <div class="singletermTERMS">Streaming XSLT design patterns</div>
         <div class="singletermTERMS">Striding:</div>
         <div class="singletermTERMS">Sweep:</div>
         <div class="singletermTERMS">safe bet</div>
         <div class="singletermTERMS">striding</div>
         <div class="singletermTERMS">same posture in, same posture out</div>
         <div class="singletermTERMS">static guaranteed streamability</div>
         <div class="singletermTERMS">Streaming</div>
         <div class="singletermTERMS">Streamable-stylesheet-functions</div>
         <div class="singletermTERMS">Stylesheet-functions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">true()</div>
         <div class="singletermTERMS">Ten rules of thumb of streaming</div>
         <div class="singletermTERMS">Transmission:</div>
         <div class="singletermTERMS">The XSLT way of doing things</div>
         <div class="singletermTERMS">transitional</div>
         <div class="singletermTERMS">template references</div>
         <div class="singletermTERMS">the Novatchev technique</div>
         <div class="singletermTERMS">type-determined usage</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">Undermyhat.org</div>
         <div class="singletermTERMS">Usage:</div>
         <div class="singletermTERMS">User-defined-functions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">visibility</div>
         <div class="singletermTERMS">virtual methods</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:copy-of</div>
         <div class="singletermTERMS">x/y</div>
         <div class="singletermTERMS">xsl:sort</div>
         <div class="singletermTERMS">xsl:value-of/@select</div>
         <div class="singletermTERMS">xsl:apply-templates/@select</div>
         <div class="singletermTERMS">xsl:sequence/@select</div>
         <div class="singletermTERMS">xsl:call-template</div>
         <div class="singletermTERMS">xs:string</div>
         <div class="singletermTERMS">xs:integer</div>
         <div class="singletermTERMS">xsl:apply-templates</div>
         <div class="singletermTERMS">xsl:for-each</div>
         <div class="singletermTERMS">xsl:for-each-group</div>
         <div class="singletermTERMS">xsl:param</div>
         <div class="singletermTERMS">xsl:sequence</div>
         <div class="singletermTERMS">xsl:value-of</div>
         <div class="singletermTERMS">xsl:template</div>
         <div class="singletermTERMS">xsl:use-package</div>
         <div class="singletermTERMS">xsl:override</div>
         <div class="singletermTERMS">xsl:original()</div>
         <div class="singletermTERMS">xsl:function</div>
         <div class="singletermTERMS">xsl:variable</div>
         <div class="singletermTERMS">xsl:accumulator</div>
         <div class="singletermTERMS">xsl:mode</div>
         <div class="singletermTERMS">XSL Mailing List at Mulberry Tech's</div>
         <div class="singletermTERMS">XSL Bug 25679</div>
         <div class="singletermTERMS">XSLT 2.0 and XPath 2.0 Programmer's Reference</div>
         <div class="singletermTERMS">XSLT 1.0 Pocket Reference (Pocket Reference)</div>
         <div class="singletermTERMS">XQuery and XPath Data Model 3.0 Recommendation</div>
         <div class="singletermTERMS">XML Path Language (XPath) 3.0 Recommendation</div>
         <div class="singletermTERMS">XProc: An XML Pipeline Language</div>
         <div class="singletermTERMS">XML</div>
         <div class="singletermTERMS">XSLT 3.0</div>
         <div class="singletermTERMS">XPath 3.0</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">yes</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="InpursuitofstreamablestylesheetfunctionsinXSLT30ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">In pursuit of streamable stylesheet functions in XSLT 3.0</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2014</div>
            <div class="confdates e5">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">With the XSLT Working Draft being in Last Call since December 2013 and the XSL
               Working Group working hard to get the latest bugs fixed, it is only a matter of time
               that the XSLT 3.0 Draft becomes a Candidate Recommendation, locked for changes and
               suitable for implementors to adopt.
            </div>
            <div class="para e8">One of the bugs the Working Group received was about the inability to create
               stylesheet functions that take streamable nodes as an argument. The group considered
               the omission and decided to ask me to write up a proposal. We discussed several
               iterations of the proposal until recently it was adopted and added to the internal
               Working Draft. 
            </div>
            <div class="para e9">This paper investigates the ways in which stylesheet functions can be made
               streamable and why it is such a complex to task to make them so. It summarizes the
               rules that have been adopted so far according to the public bug entry and shows the
               possibilities it gives for stylesheet and package authors. While the impact on the
               specification is minimal, the impact for authors of packages and stylesheet authors
               in general is potentially big and opens up a whole world of new possibilities in
               streaming.
            </div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Abel</div>
               <div class="surname e13">Braaksma</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">Abel Braaksma is an invited expert of the XSL and XQuery Working Group and is
                  creator and owner of 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e16" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple">Exselt</div>, a
                  streaming XSLT 3.0 processor. Next to his XSL work for the Working Group he runs
                  a consultancy and outsourcing firm 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e17" xlink:actuate="onRequest" xlink:href="http://abrasoft.net" xlink:show="new" xlink:type="simple">Abrasoft</div>, specializing in data aggregation and XML in .NET
                  environments. He has over 15 years experience in XML and related technologies.
                  You can contact him about Exselt or XML, XSLT and C# / F# related inquiries. His
                  personal thoughts on technological challenges and XSLT in particular are
                  collected on his blog 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e18" xlink:actuate="onRequest" xlink:href="http://undermyhat.org" xlink:show="new" xlink:type="simple">http://undermyhat.org</div>.
               </div>
            </div>
            <div class="email e19">abel[-at-]exselt.net</div>
            <div class="affiliation e20">
               <div class="jobtitle e21">Owner/creator</div>
               <div class="orgname e22">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e23" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple">Exselt, a streaming XSLT 3.0 processor</div>
               </div>
            </div>
            <div class="affiliation e24">
               <div class="orgname e25">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e26" xlink:actuate="onRequest" xlink:href="http://abrasoft.net" xlink:show="new" xlink:type="simple">Abrasoft Consulting</div>
               </div>
            </div>
            <div class="affiliation e27">
               <div class="orgname e28">Blog: 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e29" xlink:actuate="onRequest" xlink:href="http://undermyhat.org" xlink:show="new" xlink:type="simple">Undermyhat.org</div>
               </div>
            </div>
         </div>
         <div class="legalnotice e30">
            <div class="para e31">Copyright © 2014 by the author. Used with permission.</div>
         </div>
         <div class="keywordset e32" role="author">
            <div class="keyword e33">XML</div>
            <div class="keyword e34">XSLT 3.0</div>
            <div class="keyword e35">XPath 3.0</div>
            <div class="keyword e36">Streaming</div>
            <div class="keyword e37">Streamable-stylesheet-functions</div>
            <div class="keyword e38">Guaranteed-streamability</div>
            <div class="keyword e39">Stylesheet-functions</div>
            <div class="keyword e40">User-defined-functions</div>
            <div class="keyword e41">Packages</div>
            <div class="keyword e42">Recursive-functions</div>
         </div>
      </div><a name="NotesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e43" xml:id="notes">
         <div class="title e44">Notes</div>
         <div class="note e45" xreflabel="Updates">
            <div class="para e46">This paper discusses very recent changes to the XSLT 3.0 specification that are
               still under discussion in the related BugZilla bug entries. When the specification
               is updated, rules laid out in this paper need updating as well. I will publish those
               updates at 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e47" xlink:actuate="onRequest" xlink:href="http://exselt.net/papers" xlink:show="new" xlink:type="simple">http://exselt.net/papers</div>
               in DocBook and PDF formats.
            </div>
         </div>
         <div class="note e48" xreflabel="Prerequisites">
            <div class="para e49">To read and understand this paper, a basic understanding of XSLT 3.0 and streaming
               is desirable. For an introduction on streaming, you can refer to two earlier papers
               in this series, 
               <div class="xref e50" linkend="Braaksma14a"></div>, about the 
               <div class="emphasis e51" role="ital">Ten
                  rules of thumb of streaming
               </div> and 
               <div class="xref e52" linkend="Braaksma14b"></div>, about
               
               <div class="emphasis e53" role="ital">Streaming XSLT design patterns</div>.
            </div>
         </div>
      </div><a name="DisclaimerANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e54" xml:id="disclaimer">
         <div class="title e55">Disclaimer</div>
         <div class="para e56">This paper relies on information that can be found in the public 
            <div class="xref e57" linkend="XsltLastCall"></div> at the time of this writing, and in some of the public XSLT
            3.0 BugZilla bugs (see 
            <div class="xref e58" linkend="W3cBugzilla"></div>). While I am an 
            <div class="emphasis e59" role="ital">invited expert</div> for the XSL Working Group, I do not speak at
            there behalf, and any thoughts I lay out in this paper are my own and are not
            necessarily the thoughts of the XSL Working Group.
         </div>
         <div class="para e60">Changes to the Last Call Working Draft will be discussed through the same BugZilla
            and
            will ultimately result in the publication of a new version of the specification in
            
            <div class="xref e61" linkend="Xslt30Latest"></div>. Where this paper refers to XPath, XPath functions and
            operators or the XDM, it uses 
            <div class="xref e62" linkend="XPathRec"></div>, 
            <div class="xref e63" linkend="FuncOpRec"></div>
            and 
            <div class="xref e64" linkend="XdmRec"></div>.
         </div>
         <div class="para e65">Since the XSLT 3.0 specification is not final yet, it is possible that syntax or
            semantics of constructs used in this paper change in the future or are dropped in
            their
            entirety. Large parts of this paper rely on discussions and conclusions of functionality
            reported in the public section of BugZilla. Where the text of this paper deviates
            from
            the public Working Draft and where these changes are publicly available through
            BugZilla, I will state so by using footnotes.
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e66">
         <div class="title e67">Introduction</div>
         <div class="para e68">Streamability analysis is a complex subject, yet the basics are, as is often the case,
            relatively trivial: just write your stylesheet in such a way that it only uses the
            child
            axis, plus an occasional escape to node properties such as attributes on the ancestor
            or
            self axes, and you have essentially written a streamable stylesheet.
         </div>
         <div class="para e69">But in practice, it is not so trivial. Rules in the specification are complex and
            even
            hard-core spec-readers have trouble following them. They are meant for implementors
            and
            not necessarily for programmers or users, which is why these rules have to take care
            of
            every possible corner case and yet make sure that for general use, the rules work
            with
            the least possible surprises.
         </div>
         <div class="para e70">This paper tries to fill in the gap between spec-prose and tutorial. While there
            currently are no tutorials on the subject of streamable stylesheet functions, this
            paper
            aims to explain the basics and several rather advanced concepts such as recursive
            streamable functions, in a way that it becomes understandable for a larger
            public.
         </div>
         <div class="para e71">A streamable stylesheet function is a function that can take a streamed node from
            a
            streaming input document, while still passing the tests for being guaranteed streamable.
            Being able to write streamable stylesheet functions is import for package designers,
            so
            that they can create functions that work alike for streaming and non-streaming
            scenarios.
         </div>
         <div class="para e72">This paper first introduces you to part of the terminology used in the specification
            and at several sections in this paper, see 
            <div class="xref e73" linkend="terminology"></div>. It then
            explains typical use-cases for streamable functions in 
            <div class="xref e74" linkend="case-for-functions"></div>, after which it explains the challenges we face when
            dealing with streamability analysis and streamable functions in 
            <div class="xref e75" linkend="challenge"></div>. 
         </div>
         <div class="para e76">Streamability of standard, non-recursive functions is explained in 
            <div class="xref e77" linkend="posture-sweep"></div> and 
            <div class="xref e78" linkend="multiple-arguments"></div>; and the rather
            complex subject of streamability for recursive functions is dealt with in depth in
            
            <div class="xref e79" linkend="recursion"></div> and its sub-sections. Futher sections deal with packages and
            function inheritance with respect to streamability (see 
            <div class="xref e80" linkend="packages"></div>) and
            a proposal for a general improvement to the analysis of the posture in 
            <div class="xref e81" linkend="terminology"></div>. And in 
            <div class="xref e82" linkend="miscelleneous"></div> several related
            subjects are covered on inline functions, partial function application, named function
            refverences and dynamic function calls. 
         </div>
         <div class="para e83">The current state of the specification is discussed in 
            <div class="xref e84" linkend="specification-status"></div> and the current state of processors with regard to
            streamability analysis of stylesheet functions in 
            <div class="xref e85" linkend="status-processors"></div>.
         </div>
      </div><a name="StreamingterminologyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e86" xml:id="terminology">
         <div class="title e87">Streaming terminology</div>
         <div class="para e88"> This section will briefly discussed terminology used throughout this paper. This
            overview does not try to be complete.
         </div>
         <div class="para e89">
            
            <div class="itemizedlist e90">
               <div class="listitem e91">
                  <div class="para e92">
                     <div class="emphasis e93" role="ital">Guaranteed streamable:</div> determines
                     whether a particular construct, instruction or declaration is streamable
                     according to the streamability rules in section 19 of the XSLT 3.0
                     specification. If it is, any processor that is conformant with the
                     streamability feature will be able to process your input using streaming,
                     that is, by reading the input in forward-only mode without keeping the whole
                     document in memory.
                  </div>
               </div>
               <div class="listitem e94">
                  <div class="para e95">
                     <div class="emphasis e96" role="ital">Posture:</div> the posture of a construct
                     determines the state of a streamed node in the output of that construct.
                     Often, this will be the same as the input posture. It is used in
                     streamability analysis to determine whether a construct returns streamed
                     nodes and in what way. Many constructs are capable of returning streamed
                     nodes, but if all rules are followed, the usages of these constructs are
                     limited in such a way that they can only return a subset that is compatible
                     with streaming. The different postures are:
                     <div class="itemizedlist e97">
                        <div class="listitem e98">
                           <div class="para e99">
                              <div class="emphasis e100" role="ital">Grounded:</div> the construct
                              does not return a reference to a streamed node. An expression or
                              instruction operating on a grounded posture is allowed to be
                              free-ranging. Examples: 
                              <div class="code e101">fn:currentDateTime</div>,
                              
                              <div class="code e102">fn:copy-of</div>, 
                              <div class="code e103">xsl:copy-of</div>, a
                              variable reference.
                           </div>
                        </div>
                        <div class="listitem e104">
                           <div class="para e105">
                              <div class="emphasis e106" role="ital">Climbing:</div> the construct can
                              return nodes that refer climb the tree through the ancestor or
                              attribute axis. Examples: 
                              <div class="code e107">parent::foo</div>,
                              
                              <div class="code e108">author/@name</div>, 
                              <div class="code e109">..</div>.
                           </div>
                        </div>
                        <div class="listitem e110">
                           <div class="para e111">
                              <div class="emphasis e112" role="ital">Striding:</div> the construct can
                              return non-overlapping nodes, typically only on the child axis.
                              Examples: any child-select expression, any match pattern,
                              
                              <div class="code e113">fn:zero-or-one</div>,
                              
                              <div class="code e114">fn:outermost</div>.
                           </div>
                        </div>
                        <div class="listitem e115">
                           <div class="para e116">
                              <div class="emphasis e117" role="ital">Crawling:</div> the construct can
                              return overlapping nodes on a downward axis. Examples:
                              
                              <div class="code e118">foo/descendant-or-self::bar</div>,
                              
                              <div class="code e119">./b//c</div>.
                           </div>
                        </div>
                        <div class="listitem e120">
                           <div class="para e121">
                              <div class="emphasis e122" role="ital">Roaming:</div> the construct can
                              return nodes that can be anywhere in the input tree. Examples:
                              
                              <div class="code e123">following::node()</div>,
                              
                              <div class="code e124">ancestor::foo/bar</div>,
                              
                              <div class="code e125">preceding-sibling::price</div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e126">
                  <div class="para e127">
                     <div class="emphasis e128" role="ital">Sweep:</div> the sweep of a construct
                     determines how the current read position of the input stream is changed as a
                     result of executing the construct. The different sweeps are:
                     <div class="itemizedlist e129">
                        <div class="listitem e130">
                           <div class="para e131">
                              <div class="emphasis e132" role="ital">Motionless:</div> the read
                              position does not change. This is true for expressions that only
                              operate on grounded nodes or data, and for expressions that
                              request a property of a node or the ancestor axis
                              <div class="popupBox e133">
                                 <div class="popupLabel" onmouseover="$('#d1e256').show('1000');" onmouseout="$('#d1e256').hide('1000');">[ footnote ]</div>
                                 <div id="d1e256" style="display: none;">
                                    <div class="footnote">
                                       <div class="para e134">The ancestor-or-self axis is available during
                                          streaming and requesting properties on nodes on that
                                          axis is allowed. However, it is not possible to navigate
                                          away from that axis, doing so would result in a
                                          free-ranging and roaming expression.
                                       </div>
                                    </div>
                                 </div>
                              </div>. Examples: 
                              <div class="code e135">fn:has-children(.)</div>,
                              
                              <div class="code e136">@name</div>, 
                              <div class="code e137">if(./name()) then ...</div>,
                              
                              <div class="code e138">ancestor-or-self::para/@xml:lang</div>, any constant
                              and any expression not operating on a streamed node.
                           </div>
                        </div>
                        <div class="listitem e139">
                           <div class="para e140">
                              <div class="emphasis e141" role="ital">Consuming:</div> the read
                              position changes in a forward-only direction. Any expression
                              that requires read-ahead is considered a consuming expression,
                              unless the current node is a childless node, such as text- and
                              comment nodes. Consuming constructs form the heart of
                              streamability analysis. Any construct may have at most one
                              consuming construct. Examples: 
                              <div class="code e142">fn:count(foo)</div>,
                              
                              <div class="code e143">x/y</div>, 
                              <div class="code e144">&lt;xsl:value-of select="name"
                                 /&gt;
                              </div>.
                           </div>
                        </div>
                        <div class="listitem e145">
                           <div class="para e146">
                              <div class="emphasis e147" role="ital">Free-ranging:</div> the construct
                              cannot be evaluated by using forward-only movement of the read
                              pointer of the input stream, for instance when evaluation of a
                              filter expression requires look-ahead. Typically, a free-ranging
                              construct is also roaming. Examples: 
                              <div class="code e148">foo[bar]</div>,
                              
                              <div class="code e149">parent::author/book</div>, any 
                              <div class="code e150">xsl:sort</div>
                              on streamed nodes, 
                              <div class="code e151">@* | foo</div>, 
                              <div class="code e152">if(a) then b
                                 else c
                              </div>, 
                              <div class="code e153">fn:reverse(index)</div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e154">
                  <div class="para e155">
                     <div class="emphasis e156" role="ital">Usage:</div> the usage determines what an
                     operand of a construct does when it receives a streamed node as argument.
                     The following usages are defined:
                     <div class="itemizedlist e157">
                        <div class="listitem e158">
                           <div class="para e159">
                              <div class="emphasis e160" role="ital">Inspection:</div> if the argument
                              is a streamed node, it will inspect the node, but not consume
                              the node, resulting in a motionless sweep (assuming no other
                              part of the expression or construct consumes the input). An
                              inspection operand is the only operand that can take a climbing,
                              motionless expression as its argument.
                           </div>
                        </div>
                        <div class="listitem e161">
                           <div class="para e162">
                              <div class="emphasis e163" role="ital">Absorption:</div> if the argument
                              is a streamed node, it will consume the node, resulting in a
                              consuming sweep. Examples are arguments of 
                              <div class="code e164">fn:data</div>,
                              
                              <div class="code e165">fn:string</div>, constructor functions,
                              
                              <div class="code e166">xsl:value-of/@select</div>,
                              
                              <div class="code e167">xsl:apply-templates/@select</div> and text value and
                              attribute value templates.
                           </div>
                        </div>
                        <div class="listitem e168">
                           <div class="para e169">
                              <div class="emphasis e170" role="ital">Transmission:</div> if the
                              argument is a streamed node, the result will also be a streamed
                              node. Depending on the function or construct, this can result in
                              any kind of sweep. Examples are arguments of
                              
                              <div class="code e171">fn:outermost</div>, 
                              <div class="code e172">fn:remove</div>,
                              
                              <div class="code e173">fn:subsequence</div>,
                              
                              <div class="code e174">xsl:sequence/@select</div>.
                           </div>
                        </div>
                        <div class="listitem e175">
                           <div class="para e176">
                              <div class="emphasis e177" role="ital">Navigation:</div> if the argument
                              is a streamed node, there is no guarantee that calling the
                              construct will be streamable. Typically, a navigational operand
                              will result in free-ranging and roaming streamability analysis
                              results. Examples are arguments of
                              
                              <div class="code e178">xsl:call-template</div> (the implicit context item,
                              making it impossible to use this instruction with streamed
                              nodes), first argument of 
                              <div class="code e179">fn:fold-left</div>, last
                              argument of 
                              <div class="code e180">fn:key</div>, 
                              <div class="code e181">fn:innermost</div>, any
                              untyped argument to a stylesheet function not specifically
                              marked streamable.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e182">The combination of posture, sweep and usage determines whether a certain construct
            is
            guaranteed streamable or not. Constructs can be nested, and constructs have operands.
            What exactly constitutes a construct and operands is outside the scope of this paper
            <div class="popupBox e183">
               <div class="popupLabel" onmouseover="$('#d1e375').show('1000');" onmouseout="$('#d1e375').hide('1000');">[ footnote ]</div>
               <div id="d1e375" style="display: none;">
                  <div class="footnote">
                     <div class="para e184">See section 19 of the XSL 3.0 specification.</div>
                  </div>
               </div>
            </div>, except for stylesheet functions, which will be explained in the following
            sections.
         </div>
      </div><a name="AcaseforstreamablefunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e185" xml:id="case-for-functions">
         <div class="title e186">A case for streamable functions</div>
         <div class="para e187">Functions are a nice machinery in XSLT 2.0 that have surplaced most of the
            
            <div class="code e188">xsl:call-template</div> scenarios from XSLT 1.0. The benefit of being able to
            create a function and call it directly inside an XPath expression or in a pattern
            filter
            has shown its use-cases. More often than not, functions tend to operate on atomic
            types,
            such as strings and integers, because the natural habitat for nodes processing is
            done
            declaratively by template matching. This is often called 
            <div class="emphasis e189" role="ital">The XSLT
               way of doing things
            </div>, see 
            <div class="xref e190" linkend="Welker08"></div>, 
            <div class="xref e191" linkend="Gerstbach06"></div> and 
            <div class="xref e192" linkend="Lenz05"></div>, and even today, this is still
            often advocated on the XSL Mailing List
            <div class="popupBox e193">
               <div class="popupLabel" onmouseover="$('#d1e397').show('1000');" onmouseout="$('#d1e397').hide('1000');">[ footnote ]</div>
               <div id="d1e397" style="display: none;">
                  <div class="footnote">
                     <div class="para e194">See 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e195" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/xsl/xsl-list/" xlink:show="new" xlink:type="simple">XSL Mailing List
                           at Mulberry Tech's
                        </div>.
                     </div>
                  </div>
               </div>
            </div> and on discussion fora such as StackOverflow
            <div class="popupBox e196">
               <div class="popupLabel" onmouseover="$('#d1e404').show('1000');" onmouseout="$('#d1e404').hide('1000');">[ footnote ]</div>
               <div id="d1e404" style="display: none;">
                  <div class="footnote">
                     <div class="para e197">See, for instance, 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e198" xlink:actuate="onRequest" xlink:href="http://stackoverflow.com/questions/2835567/xslt-templates-and-recursion" xlink:show="new" xlink:type="simple">StackOverflow question 2835567 on templates and recursion</div>.
                     </div>
                  </div>
               </div>
            </div> and Experts-Exchange.com. However, even advocates of using templates over
            (recursive) functions, such as Dimitre Novatchev, sometimes choose a function over
            a
            template based scenario because it is clearer or because it is simply a better tool
            for
            that particular job
            <div class="popupBox e199">
               <div class="popupLabel" onmouseover="$('#d1e411').show('1000');" onmouseout="$('#d1e411').hide('1000');">[ footnote ]</div>
               <div id="d1e411" style="display: none;">
                  <div class="footnote">
                     <div class="para e200">See, for instance, his answer in 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e201" xlink:actuate="onRequest" xlink:href="http://stackoverflow.com/questions/16631213/writing-a-recursive-function-xslt-xpath-for-computing-new-values" xlink:show="new" xlink:type="simple">question 16631213 at StackOverflow</div>, which uses recursion on element
                        nodes, it's an example where functions are arguably a better choice than
                        template matching.
                     </div>
                  </div>
               </div>
            </div>, or in the words of Jeni Tennison in 
            <div class="xref e202" linkend="Tennison01"></div>: 
            <div class="popupBox e203">
               <div class="popupLabel" onmouseover="$('#d1e420').show('1000');" onmouseout="$('#d1e420').hide('1000');">[ blockquote ]</div>
               <div id="d1e420" style="display: none;">
                  <div class="blockquote">
                     <div class="para e204">
                        <div class="emphasis e205" role="ital">“If the result follows the structure of the source, then
                           a push method is more natural — the source drives the process. If the result
                           has a substantially different structure from the source, then a pull method
                           is more natural — the result drives the process.”
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e206">It should be said: in XSLT 3.0, the natural way of doing things with nodes from an
            input tree is to use template declarations. This is no other than previous XSLT
            versions. Perhaps it is even stronger now that it is possible to apply templates on
            atomic values such as sequences of strings as well
            <div class="popupBox e207">
               <div class="popupLabel" onmouseover="$('#d1e426').show('1000');" onmouseout="$('#d1e426').hide('1000');">[ footnote ]</div>
               <div id="d1e426" style="display: none;">
                  <div class="footnote">
                     <div class="para e208">See section 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e209" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#dt-pattern" xlink:show="new" xlink:type="simple">5.6
                           Patterns
                        </div>, specifically the part on 
                        <div class="emphasis e210" role="ital">predicate
                           patterns
                        </div> in the XSLT 3.0 Working Draft.
                     </div>
                  </div>
               </div>
            </div>. But this does not help with complex patterns, which can only be replaced by
            functions. Also, it does not help in scenarios where reusing a result in an expression
            is important, which is where functions come into play: they can be used inside
            expressions and call-template nor apply-template can do that (unless wrapped inside
            a
            function, that is).
         </div>
         <div class="para e211">The current working draft, which is in Last Call, does not have a provision for
            streamable functions. That is, it is impossible in any which way to pass a streamed
            node
            to a function. Dimitre Novatchev's example from the StackOverflow question would
            therefore not be possible in a streaming scenario. Now that more and more people have
            gotten used to write functions, and with the advent of (precompiled) XSLT packages
            containing lots and lots of library functions, it seems unfair that they cannot continue
            doing so in streamable scenarios, nor does it seem fair that library vendors will
            not
            have any means to create library packages with functions that are
            streaming-aware.
         </div>
         <div class="para e212">The XSL Working Group has considered this and as the solution of 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e213" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple">Bug 25679</div>
            shows, the proposal was considered and adopted into the internal working draft. The
            following sections will explain my personal analysis on the situation and 
            <div class="xref e214" linkend="specification-status"></div> will summarize which parts of this analysis match
            the specification. Since the discussion on this bug report is not final yet, anything
            in
            that section is very preliminary and may change without prior notice.
         </div>
      </div><a name="Stylesheetfunctionsinstreamingscenariosbeforetheywereallowedtobe%0AstreamableANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e215" xml:id="stylesheet-functions">
         <div class="title e216">Stylesheet functions in streaming scenarios before they were allowed to be
            streamable
         </div>
         <div class="para e217">In the current XSL Transformations 3.0 Last Call Working Draft, calls on stylesheet
            functions are analysed based on the declared type of the arguments. If an argument
            is
            typed as an atomizing type, such as 
            <div class="code e218">xs:string</div> or 
            <div class="code e219">xs:integer</div>,
            the usage of that argument will be 
            <div class="emphasis e220" role="ital">absorption</div>, in other
            words, it will absorb a streamed node, which in most cases results in a 
            <div class="emphasis e221" role="ital">consuming</div> sweep. The result of such function calls is defined
            as 
            <div class="emphasis e222" role="ital">grounded</div>. If the argument is untyped or is a type
            that can take nodes, it is disallowed to pass a streamed node to the function call,
            because there is no way of knowing statically what will happen with that node inside
            the
            function. I call this the 
            <div class="emphasis e223" role="ital">safe bet</div>: disallowing
            streamed nodes as arguments makes streamability analysis easier. Example:
            <div class="figure e224" xml:id="f-square" xreflabel="Code listing: calculate square">
               <div class="programlisting e225" xml:space="preserve">&lt;xsl:function name="f:square"&gt;
                  &lt;xsl:param name="i" as="xs:integer" /&gt;
                  &lt;xsl:value-of select="$i * $i" /&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;xsl:template match="number"&gt;
                  &lt;xsl:sequence select="f:square(.)" /&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
         </div>
         <div class="para e226">In this example, the function 
            <div class="code e227">f:square</div> takes an argument 
            <div class="code e228">$i</div>
            that is of type 
            <div class="code e229">xs:integer</div>. Upon calling the function, the processor will
            have to atomize the value or node. To do so, it must process all its children, which
            is
            why such a usage is considered 
            <div class="emphasis e230" role="ital">consuming</div>. In this
            case, the element 
            <div class="code e231">number</div> will be atomized.
         </div>
         <div class="para e232">This is a typical way of writing functions and it works perfectly well with streaming.
            However, if you want the argument to be a node and get some properties of a node or
            process the node's children, it gets trickier, since passing a node to a function
            is
            disallowed with streaming. Consider the following:
         </div>
         <div class="para e233">
            
            <div class="figure e234" xml:id="f-hasname" xreflabel="Code listing: get attribute of ancestor">
               <div class="programlisting e235" xml:space="preserve">&lt;xsl:function name="f:hasname"&gt;
                  &lt;xsl:param name="n" as="item()" /&gt;
                  &lt;xsl:sequence select="
                  if($n/ancestor::node()[@name]) 
                  then true() 
                  else false()" /&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;xsl:template match="author[f:hasname(.)]"&gt;
                  &lt;xsl:text&gt;Has name attribute in ancestor!&lt;/xsl:text&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
            
         </div>
         <div class="para e236">In this example, the call to the function is not streamable. We pass on a node to
            the
            function and the rules in the current Working Draft state that it has usage 
            <div class="emphasis e237" role="ital">navigation</div>
            <div class="popupBox e238">
               <div class="popupLabel" onmouseover="$('#d1e501').show('1000');" onmouseout="$('#d1e501').hide('1000');">[ footnote ]</div>
               <div id="d1e501" style="display: none;">
                  <div class="footnote">
                     <div class="para e239">Before user-defined stylesheet functions were allowed to be streamable and
                        take on streamed nodes, the rules were as in the current Working Draft:
                        
                        <div class="quote e240">For a call to a stylesheet function, the general streamability rules
                           apply. There is one operand role for each argument in the function
                           signature, and its operand usage is the type-determined usage based on the
                           declared type of that argument.
                        </div>, see section 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e241" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-function-calls" xlink:show="new" xlink:type="simple">19.8.7.12 Streamability of Function Calls</div> in XSLT 3.0 Working Draft.
                        Please note that this and other references to the WD will change when the next
                        version of the specification comes out.
                     </div>
                  </div>
               </div>
            </div>, which has the effect that the whole expression, in this case the match
            pattern 
            <div class="code e242">author[f:hasname(.)]</div>, will be 
            <div class="emphasis e243" role="ital">roaming</div> and 
            <div class="emphasis e244" role="ital">free-ranging</div>, in other
            words, it is not 
            <div class="emphasis e245" role="ital">guaranteed streamable</div>.
         </div>
         <div class="para e246">It is possible to call the function in some situations, by using the
            
            <div class="code e247">fn:copy-of</div> or 
            <div class="code e248">fn:snapshot</div> functions. But that means that
            users of your function must have enough knowledge to know what atomizing or 
            <div class="emphasis e249" role="ital">grounding</div> function to use before passing on an argument. In
            this particular case, it would make little sense to use either of these functions,
            because a match pattern must be motionless, so it is not possible to use the function
            in
            a match pattern predicate expression. This is essentially true for any function that
            does not consume the input tree. With the current rules in place, even if a function
            does not consume the input tree, you still need to create a copy of the tree to call
            that function. Hardly efficient and in many cases impossible with streaming, because
            the
            input node may simply be too big to be copied.
         </div>
         <div class="para e250">Were you to use it in another context, you still have to choose between
            
            <div class="code e251">fn:copy-of</div> and 
            <div class="code e252">fn:snapshot</div>. This function would not work
            with 
            <div class="code e253">fn:copy-of</div>, because that function does not copy the ancestor axis. In
            other words, you must know the internals of the function to find out that you need
            to
            call it with a call to 
            <div class="code e254">fn:snapshot</div>. And even then, if the function requires
            information from the original document, such as the 
            <div class="emphasis e255" role="ital">base-uri</div> or other properties that are not copied with either of those
            functions, you are out of luck.
         </div>
         <div class="para e256">In essence, these rules disallow stylesheet authors to write a function that take
            nodes as arguments, and in the case of library package authors, they will not be able
            to
            write functions that take nodes that work the same way in a streaming scenario and
            a
            non-streaming one. They would have to educate library function users how to use their
            functions in a streaming scenario and many functions will never work in streaming
            scenarios because their usage would always be 
            <div class="emphasis e257" role="ital">consuming</div> even though the function body does not actually consume the
            input node. In other words, it makes writing functions for use in streamable stylesheets
            next to useless.
         </div>
      </div><a name="ThechallengeofstreamablestylesheetfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e258" xml:id="challenge">
         <div class="title e259">The challenge of streamable stylesheet functions</div>
         <div class="para e260">It is often trivial to see at a glance that a function is 
            <div class="emphasis e261" role="ital">motionless</div> and that it would not hurt using it on a streamed input node.
            Take, for instance, 
            <div class="xref e262" linkend="f-hasname"></div> from the previous section. It only uses
            the ancestor axis and tests whether one exists with an attribute 
            <div class="code e263">@name</div>.
            Since walking the ancestor axis is motionless (the processor is required to keep a
            stack
            of the ancestor nodes and their properties) and the attribute axis is too, any call
            on
            that function would be motionless with respect to its argument.
         </div>
         <div class="para e264">This shows us one thing: it is possible to write functions that can be statically
            analyzed to be 
            <div class="emphasis e265" role="ital">motionless</div>. But this function has
            special properties: the body of the function is 
            <div class="emphasis e266" role="ital">motionless</div> and the result of the function is 
            <div class="emphasis e267" role="ital">grounded</div>. That means, it can never return any nodes, it can either
            return 
            <div class="code e268">true()</div> or 
            <div class="code e269">false()</div>. But can we always statically
            determine that that is the case? Let us write a slightly different function, this
            time
            we return the attribute node, instead of testing for it:
         </div>
         <div class="para e270">
            
            <div class="figure e271" xreflabel="Code listing: return attribute node">
               <div class="programlisting e272" xml:space="preserve">&lt;xsl:function name="f:hasname"&gt;
                  &lt;xsl:param name="n" as="item()" /&gt;
                  &lt;xsl:sequence select="$n/ancestor::node()/@name" /&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;!-- guaranteed streamable: --&gt;
                  &lt;xsl:template match="author[f:hasname(.)]"&gt;
                  &lt;xsl:text&gt;Has name attribute in ancestor!&lt;/xsl:text&gt;
                  &lt;/xsl:template&gt;
                  
                  &lt;!-- potentially guaranteed streamable: --&gt;
                  &lt;xsl:template match="*"&gt;
                  &lt;xsl:apply-templates select="author/f:hasname(.)" /&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
            
         </div>
         <div class="para e273">The function still takes a node as its argument, but this time it returns a reference
            to an attribute of the ancestor axis of that node. The attribute axis has 
            <div class="emphasis e274" role="ital">climbing</div> posture, which is limited in that you cannot
            navigate downwards again from it. In the first usage of this function, in the predicate
            of the pattern, the input is the current node, but a predicate only has to be true
            (nodes are there) or false (no nodes). After that, there is no navigation away from
            the
            
            <div class="emphasis e275" role="ital">climbing</div> posture, so this could be considered
            streamable.
         </div>
         <div class="para e276">If we take a look at the second example, we see there an
            
            <div class="code e277">xsl:apply-templates</div>. By definition, assuming the rest of your
            stylesheet is guaranteed streamable, any apply-templates will be an atomizing construct:
            templates must be grounded and therefore, passing on nodes to a template will atomize
            those nodes. Just as we saw before, atomizing means that the node is consumed. In
            streamability terms this means it has usage 
            <div class="emphasis e278" role="ital">absorption</div>. But to consume a node, its children must be visited, which
            is a downward movement. The argument has a 
            <div class="emphasis e279" role="ital">climbing</div>
            posture because it ends with 
            <div class="code e280">f:hasname(.)</div>, which we know returns attribute
            nodes, which are 
            <div class="emphasis e281" role="ital">climbing</div>.
         </div>
         <div class="para e282">There is a caveat, however: if the 
            <div class="emphasis e283" role="ital">climbing</div>
            expression returns childless nodes, consuming such a node will not harm the streaming
            process: there are no children to consume. The 
            <div class="emphasis e284" role="ital">General
               Streamability Rules
            </div>
            <div class="popupBox e285">
               <div class="popupLabel" onmouseover="$('#d1e624').show('1000');" onmouseout="$('#d1e624').hide('1000');">[ footnote ]</div>
               <div id="d1e624" style="display: none;">
                  <div class="footnote">
                     <div class="para e286">See section 19.8.1. in XSL Transformations 3.0.</div>
                  </div>
               </div>
            </div> in the specification have a special provision for this: childless nodes with
            a 
            <div class="emphasis e287" role="ital">climbing</div> posture are allowed in an 
            <div class="emphasis e288" role="ital">absorption</div> context.
         </div>
         <div class="para e289">So it can be made streamable, right? Wrong! For a construct to be streamable it must
            be statically determinable to be so. Here, we have a function with an unspecified
            return
            type. If we had written 
            <div class="code e290">as="attribute()"</div>, the processor would be able to
            detemine that the returned nodes would always be childless and it could be used in
            an
            
            <div class="emphasis e291" role="ital">absorption</div> context.
         </div>
         <div class="para e292">But this is only one example. What happens when the stylesheet function returns a
            
            <div class="emphasis e293" role="ital">climbing</div> node and we pass it a 
            <div class="emphasis e294" role="ital">crawling</div> expression? What happens if the function returns
            
            <div class="emphasis e295" role="ital">crawling</div> (overlapping) nodes and the input is
            
            <div class="emphasis e296" role="ital">climbing</div>? And how about recursive functions, or
            within packages, with abstract or overriden functions?
         </div>
         <div class="para e297">Let us look at some possible approaches to tackle these issues.</div><a name="Approach1:analyzingstylesheetfunctionsstaticallyontheirownANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e298" xml:id="approach-1" xreflabel="">
            <div class="title e299">Approach 1: analyzing stylesheet functions statically on their own</div>
            <div class="para e300">Arguably the easiest approach from both the user's point of view and for
               implementors alike is to try to find a method to analyze the streamability of
               stylesheet functions statically, without taking into account any possible context
               the stylesheet function is called in.
            </div>
            <div class="para e301">Suppose you have a stylesheet function 
               <div class="code e302">my:for-each</div> which traverses
               all nodes in a node set and returns a certain aggregate result. By its definition,
               traversing the node set, it will consume the input tree, just like
               
               <div class="code e303">xsl:for-each</div> would. Writing such a function that it works equally
               well for different kinds of input postures is hard, perhaps even impossible. A
               function call like 
               <div class="code e304">my:for-each(head//section)</div> may have to traverse over
               overlapping nodes, the expression in the argument is a 
               <div class="emphasis e305" role="ital">crawling</div> expression and looping over a 
               <div class="emphasis e306" role="ital">crawling</div> node set is not allowed in streaming because certain
               buffering is required to cache the overlapping nodes. If the loop is not going to
               consume the individual nodes, this is alright
               <div class="popupBox e307">
                  <div class="popupLabel" onmouseover="$('#d1e681').show('1000');" onmouseout="$('#d1e681').hide('1000');">[ footnote ]</div>
                  <div id="d1e681" style="display: none;">
                     <div class="footnote">
                        <div class="para e308">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e309" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-xsl-for-each" xlink:show="new" xlink:type="simple">19.8.4.17 Streamability of 
                              <div class="code e310">xsl:for-each</div>
                           </div> in the XSLT
                           3.0 Working Draft, specifically the rule 
                           <div class="quote e311">The posture of the
                              instruction is the posture of the contained sequence constructor,
                              assessed with the context posture and context item type set to the
                              posture and type of the select expression.
                           </div>.
                        </div>
                     </div>
                  </div>
               </div>, but otherwise, it is not 
               <div class="emphasis e312" role="ital">guaranteed
                  streamable
               </div>.
            </div>
            <div class="para e313">For such a function to be statically analyzable without knowing what context it is
               used in, it is allowed to traverse the input tree, but it is not allowed to consume
               the individual nodes of the streamed input tree. A function that can potentially
               work with any input posture, albeit 
               <div class="emphasis e314" role="ital">climbing</div>,
               
               <div class="emphasis e315" role="ital">striding</div> or 
               <div class="emphasis e316" role="ital">crawling</div> might look like the following:
            </div>
            <div class="para e317">
               
               <div class="figure e318" xml:id="my-for-each1" xreflabel="Code listing: streamable my:for-each working with any argument posture">
                  <div class="programlisting e319" xml:space="preserve">&lt;xsl:function name="my:for-each1"&gt;
                     &lt;xsl:param name="$node-set" as="node()*" /&gt;
                     &lt;xsl:for-each select="$node-set"&gt;
                     &lt;xsl:sequence select="./@name" /&gt;
                     &lt;/xsl:for-each&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e320">This example loops over all the nodes, but does not consume the individual nodes,
               it only requests a property of those nodes using the attribute axis, which is
               motionless and its result is 
               <div class="emphasis e321" role="ital">climbing</div>. And a
               motionless expression on either a 
               <div class="emphasis e322" role="ital">climbing</div>,
               
               <div class="emphasis e323" role="ital">striding</div> or 
               <div class="emphasis e324" role="ital">crawling</div> context is always allowed
               <div class="popupBox e325">
                  <div class="popupLabel" onmouseover="$('#d1e727').show('1000');" onmouseout="$('#d1e727').hide('1000');">[ footnote ]</div>
                  <div id="d1e727" style="display: none;">
                     <div class="footnote">
                        <div class="para e326">That the attribute axis in any context results in a posture of 
                           <div class="emphasis e327" role="ital">climbing</div> and a sweep of 
                           <div class="emphasis e328" role="ital">motionless</div> follows from the rules in section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e329" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#general-streamability-rules" xlink:show="new" xlink:type="simple">19.8.1 General Rules for Streamability</div>, rule 2.e and the rules
                           on the axis steps itself, which can be found in 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e330" xlink:actuate="onRequest" xlink:href="http://http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple"> 19.8.7.7 Streamability of Axis Steps</div>.
                        </div>
                     </div>
                  </div>
               </div>. 
            </div>
            <div class="para e331">Even though this example is exemplary for showing the possibility of writing a
               function that can take any posture, it limits our possibilities greatly. Suppose we
               want to write an implementation of 
               <div class="code e332">my:for-each</div> that 
               <div class="emphasis e333" role="ital">does</div> consume the individual nodes in the streamed node
               set, for instance as in the following example:
            </div>
            <div class="para e334">
               
               <div class="figure e335" xml:id="my-for-each2" xreflabel="Code listing: streamable my:for-each failing with argument postures climbing and crawling">
                  <div class="programlisting e336" xml:space="preserve">&lt;xsl:function name="my:for-each2"&gt;
                     &lt;xsl:param name="$node-set" as="node()*" /&gt;
                     &lt;xsl:for-each select="$node-set"&gt;
                     &lt;xsl:value-of select="child::*[self::author | self::author-name]" /&gt;
                     &lt;/xsl:for-each&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e337">Whether or not this example would use the child axis within the
               
               <div class="code e338">xsl:for-each</div> or directly without the loop, for the streamability
               analysis this does not matter. The child axis, if applied on a 
               <div class="emphasis e339" role="ital">climbing</div> or 
               <div class="emphasis e340" role="ital">crawling</div> axis, is
               always 
               <div class="emphasis e341" role="ital">roaming</div> and has a sweep of 
               <div class="emphasis e342" role="ital">free-ranging</div>
               <div class="popupBox e343">
                  <div class="popupLabel" onmouseover="$('#d1e773').show('1000');" onmouseout="$('#d1e773').hide('1000');">[ footnote ]</div>
                  <div id="d1e773" style="display: none;">
                     <div class="footnote">
                        <div class="para e344">The rule that a child axis is not 
                           <div class="emphasis e345" role="ital">guaranteed
                              streamable
                           </div> if applied on an axis other than an axis with
                           
                           <div class="emphasis e346" role="ital">striding</div> posture follows from 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e347" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple">19.8.7.7 Streamability of Axis Steps</div> in the XSLT Working Draft,
                           in the table under item 6 in the list.
                        </div>
                     </div>
                  </div>
               </div>. This means that the expression 
               <div class="code e348">my:for-each2(child::book)</div>
               is allowed, but the expressions 
               <div class="code e349">my:for-each2(listing//book)</div> and
               
               <div class="code e350">my:for-each(title/ancestor::book)</div> are not, because the latter two
               have arguments with 
               <div class="emphasis e351" role="ital">crawling</div> and 
               <div class="emphasis e352" role="ital">climbing</div> postures respectively and can therefor not be
               consumed.
            </div>
            <div class="para e353">This leaves us with essentially two options for static analysis of streamable
               stylesheet functions, without having to take the function calls into account:
               <div class="itemizedlist e354">
                  <div class="listitem e355">
                     <div class="para e356">
                        <div class="emphasis e357" role="ital">Option 1:</div> force stylesheet authors to
                        only write functions that are capable of dealing with any input posture.
                        This means that the body of functions must be motionless, or if they are
                        not, they must use a 
                        <div class="emphasis e358" role="ital">higher-order
                           operand
                        </div>
                        <div class="popupBox e359">
                           <div class="popupLabel" onmouseover="$('#d1e812').show('1000');" onmouseout="$('#d1e812').hide('1000');">[ footnote ]</div>
                           <div id="d1e812" style="display: none;">
                              <div class="footnote">
                                 <div class="para e360">A 
                                    <div class="emphasis e361" role="ital">higher-order operand</div> is an
                                    operand that can change focus, such as 
                                    <div class="code e362">xsl:for-each</div>
                                    or 
                                    <div class="code e363">xsl:for-each-group</div>, see the 
                                    <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e364" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#dt-higher-order-operand" xlink:show="new" xlink:type="simple">definition of 
                                       <div class="emphasis e365" role="ital">higher-order
                                          operand
                                       </div>
                                    </div> in the XSLT 3.0 Working
                                    Draft.
                                 </div>
                              </div>
                           </div>
                        </div> such as the shown 
                        <div class="code e366">xsl:for-each</div> construct in the
                        example.
                     </div>
                  </div>
                  <div class="listitem e367">
                     <div class="para e368">
                        <div class="emphasis e369" role="ital">Option 2:</div> limit the allowed posture
                        to only one posture, so that caller and callee are guaranteed to have
                        the same input posture, always. Most likely candidate is the 
                        <div class="emphasis e370" role="ital">striding</div> posture, because it is the most
                        common posture when processing an input document. This would mean that
                        the argument that can take nodes always has its context posture set to
                        
                        <div class="emphasis e371" role="ital">striding</div> and that the only allowed
                        argument posture when calling the function must also be 
                        <div class="emphasis e372" role="ital">striding</div>.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e373">Both options have severe drawbacks, but they have the advantage of being very
               clear-cut and easy to communicate or explain. As it turns out, the current approach
               taken by the XSL Working Group, as explained in 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e374" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple">XSL Bug
                  25679
               </div>, takes the approach of 
               <div class="emphasis e375" role="ital">Option 2</div>:
               the result posture of a function must be 
               <div class="emphasis e376" role="ital">striding</div>
               or 
               <div class="emphasis e377" role="ital">grounded</div> and the argument to a function must
               also be 
               <div class="emphasis e378" role="ital">striding</div> or 
               <div class="emphasis e379" role="ital">grounded</div>. To accomplish this, the parameter that can take nodes,
               which can at most be one parameter, will have a context posture of 
               <div class="emphasis e380" role="ital">striding</div> and is by itself 
               <div class="emphasis e381" role="ital">motionless</div>.
            </div>
         </div><a name="Approach2:analyzingstylesheetfunctionsfromthefunctioncallANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e382">
            <div class="title e383">Approach 2: analyzing stylesheet functions from the function call</div>
            <div class="para e384">Radically different from the previous approach is to analyze the function's body
               only when we actually know what the context is of the argument that takes a streamed
               node. For this approach, we simply ignore analyzing the declaration of the function
               on itself.
            </div>
            <div class="para e385">If we take the example from 
               <div class="xref e386" linkend="my-for-each2"></div> and call it with a
               
               <div class="emphasis e387" role="ital">striding</div> argument, for instance
               
               <div class="code e388">my:for-each2(*/books/book)</div>, the processor, upon encountering such
               function call, takes the posture of the argument and sets the context posture of
               
               <div class="code e389">$node-set</div> to this posture, in this case: 
               <div class="emphasis e390" role="ital">striding</div>. With this posture, the processor can now analyze the
               function body and return a result of that analysis, not surprisingly the same as in
               the previous section: a 
               <div class="emphasis e391" role="ital">consuming</div> sweep and a
               
               <div class="emphasis e392" role="ital">grounded</div> result posture (because the function
               does not return any nodes, the result is 
               <div class="emphasis e393" role="ital">grounded</div>).
            </div>
            <div class="para e394">If user were to call the function with a 
               <div class="emphasis e395" role="ital">crawling</div>
               argument, say 
               <div class="code e396">my:for-each2(*/books//book)</div> (mark the extra slash), the
               parameter 
               <div class="code e397">$node-set</div> is set to a context posture of 
               <div class="emphasis e398" role="ital">crawling</div> and the resulting analysis of the whole function
               body will be 
               <div class="emphasis e399" role="ital">roaming</div> and 
               <div class="emphasis e400" role="ital">free-ranging</div>. Exactly as expected. And with a 
               <div class="emphasis e401" role="ital">climbing</div> argument, or even a 
               <div class="emphasis e402" role="ital">roaming</div> argument, the result would be the same.
            </div>
            <div class="para e403">Doing the same analysis for the first example, 
               <div class="xref e404" linkend="my-for-each1"></div>, the
               result would be different each time, showing the advantage of this approach:
            </div>
            <div class="para e405">
               
               <div class="table e406" border="1px" cellpadding="3" frame="border" rules="all" xml:id="table-for-each1-analysis" xreflabel="Table I: Posture and sweep of my:for-each1 function, depending on argument">
                  <div class="colgroup e407" span="1">
                     <div class="metaBox e408"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e941').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e941" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e408'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e409"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e942').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e942" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e409'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e410"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e943').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e943" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e410'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e411"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e944').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e944" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e411'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="thead e412">
                     <div class="tr e413">
                        <div class="th e414">Argument&nbsp;posture</div>
                        <div class="th e415">Function&nbsp;posture 
                           <div class="code e416">my:for-each1</div>
                        </div>
                        <div class="th e417">Resulting&nbsp;posture for function-call</div>
                        <div class="th e418">Resulting&nbsp;sweep for function call</div>
                     </div>
                  </div>
                  <div class="tbody e419">
                     <div class="tr e420">
                        <div class="td e421">Grounded</div>
                        <div class="td e422">Grounded</div>
                        <div class="td e423">Grounded</div>
                        <div class="td e424">Motionless</div>
                     </div>
                     <div class="tr e425">
                        <div class="td e426">Climbing</div>
                        <div class="td e427">Climbing</div>
                        <div class="td e428">Climbing</div>
                        <div class="td e429">Motionless</div>
                     </div>
                     <div class="tr e430">
                        <div class="td e431">Striding</div>
                        <div class="td e432">Climbing</div>
                        <div class="td e433">Climbing</div>
                        <div class="td e434">Motionless or consuming</div>
                     </div>
                     <div class="tr e435">
                        <div class="td e436">Crawling</div>
                        <div class="td e437">Climbing</div>
                        <div class="td e438">Climbing</div>
                        <div class="td e439">Motionless or consuming</div>
                     </div>
                     <div class="tr e440">
                        <div class="td e441">Roaming</div>
                        <div class="td e442">Roaming</div>
                        <div class="td e443">Roaming</div>
                        <div class="td e444">Free-ranging</div>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e445">The advantage is clear, by postponing analysis of the function body until it is
               called, the programmer has more flexibility in creating the function and the user
               will get an error if he uses the function with an invalid argument. This is also the
               disadvantage: without a clear rule how to call the function, the user may have
               trouble understanding why one argument works and the other does not. The previous
               table showed a function, 
               <div class="code e446">my:for-each1</div>, that works with any posture as
               argument input (except 
               <div class="emphasis e447" role="ital">roaming</div>, but that posture
               will always result in an unstreamable result, whether it is a user-defined function,
               a build-in function or any other construct). The following table shows the drawback
               of this approach, where only upon calling the function it becomes apparent that
               certain postures are disallowed:
            </div>
            <div class="para e448">
               
               <div class="table e449" border="1px" cellpadding="3" frame="border" rules="all" xml:id="table-for-each2-analysis" xreflabel="Table II: Posture and sweep of my:for-each2 function, depending on argument">
                  <div class="colgroup e450" span="1">
                     <div class="metaBox e451"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1016').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1016" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e451'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e452"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1017').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1017" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e452'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e453"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1018').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1018" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e453'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e454"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1019').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1019" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e454'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="thead e455">
                     <div class="tr e456">
                        <div class="th e457">Argument&nbsp;posture</div>
                        <div class="th e458">Function&nbsp;posture 
                           <div class="code e459">my:for-each2</div>
                        </div>
                        <div class="th e460">Resulting&nbsp;posture for function-call</div>
                        <div class="th e461">Resulting&nbsp;sweep for function call</div>
                     </div>
                  </div>
                  <div class="tbody e462">
                     <div class="tr e463">
                        <div class="td e464">Grounded</div>
                        <div class="td e465">Grounded</div>
                        <div class="td e466">Grounded</div>
                        <div class="td e467">Motionless</div>
                     </div>
                     <div class="tr e468">
                        <div class="td e469">Climbing</div>
                        <div class="td e470">Roaming</div>
                        <div class="td e471">Roaming</div>
                        <div class="td e472">Free-ranging</div>
                     </div>
                     <div class="tr e473">
                        <div class="td e474">Striding</div>
                        <div class="td e475">Striding</div>
                        <div class="td e476">Striding</div>
                        <div class="td e477">Consuming</div>
                     </div>
                     <div class="tr e478">
                        <div class="td e479">Crawling</div>
                        <div class="td e480">Roaming</div>
                        <div class="td e481">Roaming</div>
                        <div class="td e482">Free-ranging</div>
                     </div>
                     <div class="tr e483">
                        <div class="td e484">Roaming</div>
                        <div class="td e485">Roaming</div>
                        <div class="td e486">Roaming</div>
                        <div class="td e487">Free-ranging</div>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e488">As we can see, only one argument posture (bar 
               <div class="emphasis e489" role="ital">grounded</div>, which is always allowed), 
               <div class="emphasis e490" role="ital">striding</div>, is allowed with the function 
               <div class="code e491">my:for-each2</div>,
               and its sweep is 
               <div class="emphasis e492" role="ital">consuming</div>. This is similar to our
               expectations, as in the previous section, we already saw that this function only
               worked with a 
               <div class="emphasis e493" role="ital">striding</div> argument posture. But in the
               previous approach, for 
               <div class="emphasis e494" role="ital">Option 2</div>, we considered this
               the only allowed posture for function arguments to stylesheet functions, which made
               it pretty clear for end users. Here, the user does not know beforehand what the
               argument posture can be, in fact, he needs intricate knowledge of the function body
               to find out what posture is allowed.
            </div>
            <div class="para e495">While this approach allows more flexibility, it also introduces more room for
               error, at least at the static development stage. Of course, the documentation of a
               function could contain information of how it should be used, but who reads
               documentation anyway?
            </div>
            <div class="para e496">Another advantage, though, is the potential that many existing functions might
               "just work". In fact, quite some functions that can be found online are often short
               and meant for a certain given input. As it turns out, if you take, for instance, a
               look at the functions on 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e497" xlink:actuate="onRequest" xlink:href="http://www.xsltfunctions.com/" xlink:show="new" xlink:type="simple">www.xsltfunctions.com</div> that can take nodes as their arguments, quite some
               of them are streamable right out of the box if we would allow this approach.
            </div>
         </div><a name="Approach3:analyzingstylesheetfunctionsbasedonstaticpostureassessmentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e498">
            <div class="title e499">Approach 3: analyzing stylesheet functions based on static posture assessments</div>
            <div class="para e500">If we try to combine the previous two approaches into one, and try to achieve both
               static analysis of function bodies and clear information for the users of the
               functions, we achieve that by decorating the functions with an extra attribute that
               can take one or more postures. Let us call the attribute
               
               <div class="code e501">argument-posture</div> and add it to 
               <div class="code e502">xsl:param</div>, with at most
               one parameter allowed to have that attribute (the challenge of multiple arguments
               that can take nodes is discussed in 
               <div class="xref e503" linkend="multiple-arguments"></div>). The value
               for the attribute is set to be one or more of 
               <div class="code e504">grounded climbing striding
                  crawling roaming
               </div>. The postures 
               <div class="emphasis e505" role="ital">grounded</div>
               and 
               <div class="emphasis e506" role="ital">roaming</div> are redundant, because the former is
               always allowed and results in a 
               <div class="emphasis e507" role="ital">motionless</div> sweep
               and the latter is never allowed, resulting in a 
               <div class="emphasis e508" role="ital">free-ranging</div> sweep.
            </div>
            <div class="para e509">If we take the previous example, 
               <div class="code e510">my:for-each1</div> and rewrite it with
               this additional decorating attribute, it looks like this:
            </div>
            <div class="para e511">
               
               <div class="figure e512" xml:id="my-for-each1-decorated" xreflabel="Code listing: streamable my:for-each with decorated parameter">
                  <div class="programlisting e513" xml:space="preserve">&lt;xsl:function name="my:for-each1" as="attribute()*"&gt;
                     &lt;xsl:param name="$node-set"
                     as="node()*"
                     argument-posture="climbing striding crawling" /&gt;
                     
                     &lt;xsl:for-each select="$node-set"&gt;
                     &lt;xsl:sequence select="./@name" /&gt;
                     &lt;/xsl:for-each&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e514">This tells the processor that the programmer declares the function to be
               streamable with each and every one of these postures. The processor can then
               statically assess the function body with each posture one by one and report back
               whether or not this assessment is correct or not. In this case, it would compile
               successfully, because all postures yield correct results.
            </div>
            <div class="para e515">Still, you might argue, the different input postures do not necessarily mean that
               the sweeps are all the same. True, but the sweep is something that can never be
               statically determined for a declaration, as it is dependent on the context of the
               caller. For instance, if the function is called with a 
               <div class="emphasis e516" role="ital">motionless</div> but 
               <div class="emphasis e517" role="ital">striding</div> argument,
               the resulting sweep is also 
               <div class="emphasis e518" role="ital">motionless</div>, because the
               
               <div class="code e519">xsl:for-each</div> with a 
               <div class="emphasis e520" role="ital">motionless</div>
               argument and its body containing a 
               <div class="emphasis e521" role="ital">motionless</div>
               sequence constructor all together yield a 
               <div class="emphasis e522" role="ital">motionless</div> call to the function, even though it is striding. This is
               true, for instance, for the following call:
            </div>
            <div class="para e523">
               
               <div class="figure e524" xml:id="my-for-each-in-match-pattern" xreflabel="Code listing: calling function with motionless striding argument">
                  <div class="programlisting e525" xml:space="preserve">&lt;xsl:template match="books/book[my:for-each1(.) = 'Swift')]"&gt;
                     &lt;h1&gt;Books from Swift!&lt;/h1&gt;
                     &lt;xsl:apply-templates /&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e526">This example shows the power of the current rules in the XSL Working Draft. The
               existing rules allow a function call inside a predicate in a pattern. Because the
               context item expression, 
               <div class="code e527">(.)</div> is 
               <div class="emphasis e528" role="ital">motionless</div> and takes the context posture as its result posture,
               which in this case is 
               <div class="emphasis e529" role="ital">striding</div>, the result of
               calling the function with this argument is also 
               <div class="emphasis e530" role="ital">motionless</div> and has a result posture of 
               <div class="emphasis e531" role="ital">climbing</div> (which follows from our table above). Finally, the result
               must be atomized to be able to compare it to a string. For a 
               <div class="emphasis e532" role="ital">climbing</div> expression that returns an attribute, atomization is
               allowed and motionless.
            </div>
            <div class="para e533">As we can see, this third approach gives us more flexibility, but the drawback is
               that it requires programmers to understand what a posture is. One of the design
               goals of the streamability rules is that they can be applied without knowing all the
               internals, and bringing one of those internals, the posture of a construct, to the
               surface, may not be desirable.
            </div>
            <div class="para e534">In the next sections we dive deeper in the analysis of stylesheet functions and
               try to come up with a set of rules that works for different inputs, not only
               
               <div class="emphasis e535" role="ital">striding</div>, and that works also with recursion or
               non-final packaged functions, subjects that have not yet been touched in this
               section.
            </div>
         </div>
      </div><a name="InpursuitofflexiblerulesforguaranteedstreamablestylesheetfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e536" xml:id="posture-sweep">
         <div class="title e537">In pursuit of flexible rules for guaranteed streamable stylesheet functions</div>
         <div class="para e538">The previous section introduced three possible approaches. In the following sections
            we will research these approaches further. In fact, the focus will be on 
            <div class="emphasis e539" role="ital">Approach 2</div> above.
         </div>
         <div class="para e540">In the specification, under the rules on path expressions
            <div class="popupBox e541">
               <div class="popupLabel" onmouseover="$('#d1e1217').show('1000');" onmouseout="$('#d1e1217').hide('1000');">[ footnote ]</div>
               <div id="d1e1217" style="display: none;">
                  <div class="footnote">
                     <div class="para e542">See 19.8.7.6 Streamability of Axis Steps in XSL Transformations 3.0.</div>
                  </div>
               </div>
            </div> and axis steps
            <div class="popupBox e543">
               <div class="popupLabel" onmouseover="$('#d1e1221').show('1000');" onmouseout="$('#d1e1221').hide('1000');">[ footnote ]</div>
               <div id="d1e1221" style="display: none;">
                  <div class="footnote">
                     <div class="para e544">See 19.8.7.7 Streamability of Axis Steps in XSL Transformations 3.0.</div>
                  </div>
               </div>
            </div>, a table shows what happens if the output posture of one part of the path
            expression is the input posture of the other part of it. Stylesheet functions are
            not
            much difference. If we take the lessons learned in that section and we reproduce that
            table here and adjust it slightly for stylesheet functions, we can deduct that the
            following rules apply:
         </div>
         <div class="para e545">
            
            <div class="table e546" border="1px" cellpadding="3" frame="border" rules="all" xml:id="posture-sweep-table" xreflabel="Table III: Posture and sweep of stylesheet functions">
               <div class="colgroup e547" span="1">
                  <div class="metaBox e548"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1229').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1229" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e548'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='1.0*'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e549"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1230').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1230" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e549'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='1.0*'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e550"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1231').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1231" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e550'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='1.0*'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e551"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1232').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1232" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e551'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='1.0*'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="thead e552">
                  <div class="tr e553">
                     <div class="th e554">Argument&nbsp;posture</div>
                     <div class="th e555">Function&nbsp;posture</div>
                     <div class="th e556">Resulting&nbsp;posture</div>
                     <div class="th e557">Allowed&nbsp;sweep
                        <div class="superscript e558">a</div>
                     </div>
                  </div>
               </div>
               <div class="tfoot e559">
                  <div class="tr e560">
                     <div class="td e561" colspan="4">
                        <div class="para e562">
                           
                           <div class="superscript e563">a)
                              This is the highest allowed resulting sweep of the
                              function body resulting in the given result posture,
                              if the sweep is higher then the sweep of the
                              function body is effectively free-ranging.
                           </div>
                           
                        </div>
                        
                        <div class="para e564">
                           
                           <div class="superscript e565">b)
                              The term "direct-transitional" is not a posture, it
                              applies to constructs such as "$n/self::foo" or
                              "$n", where $n is the streamed
                              parameter. Such expressions are motionless and take the
                              posture of their input as their output posture.
                           </div>
                           
                        </div>
                        
                        <div class="para e566">
                           
                           <div class="superscript e567">c)
                              The current rules on streamability do not allow a
                              striding or crawling posture after a climbing or crawling 
                              posture, the result of such analysis is always roaming and 
                              free-ranging.
                           </div>
                           
                        </div>
                        
                     </div>
                  </div>
               </div>
               <div class="tbody e568">
                  <div class="tr e569">
                     <div class="td e570">Grounded</div>
                     <div class="td e571">Any</div>
                     <div class="td e572">Grounded</div>
                     <div class="td e573">Motionless</div>
                  </div>
                  <div class="tr e574">
                     <div class="td e575">Any</div>
                     <div class="td e576">Grounded</div>
                     <div class="td e577">Grounded</div>
                     <div class="td e578">Sweep of function body</div>
                  </div>
                  <div class="tr e579">
                     <div class="td e580">Any</div>
                     <div class="td e581">
                        <div class="emphasis e582" role="ital">Direct-transitional
                           <div class="superscript e583">b</div>
                        </div>
                     </div>
                     <div class="td e584">argument posture</div>
                     <div class="td e585">Motionless</div>
                  </div>
                  <div class="tr e586">
                     <div class="td e587">Climbing</div>
                     <div class="td e588">Climbing</div>
                     <div class="td e589">Climbing</div>
                     <div class="td e590">Motionless</div>
                  </div>
                  <div class="tr e591">
                     <div class="td e592">Climbing</div>
                     <div class="td e593">Striding
                        <div class="superscript e594">c</div>
                     </div>
                     <div class="td e595">Roaming</div>
                     <div class="td e596">Free-ranging</div>
                  </div>
                  <div class="tr e597">
                     <div class="td e598">Climbing</div>
                     <div class="td e599">Crawling
                        <div class="superscript e600">c</div>
                     </div>
                     <div class="td e601">Roaming</div>
                     <div class="td e602">Free-ranging</div>
                  </div>
                  <div class="tr e603">
                     <div class="td e604">Striding</div>
                     <div class="td e605">Climbing</div>
                     <div class="td e606">Climbing</div>
                     <div class="td e607">Motionless</div>
                  </div>
                  <div class="tr e608">
                     <div class="td e609">Striding</div>
                     <div class="td e610">Striding</div>
                     <div class="td e611">Striding</div>
                     <div class="td e612">Consuming</div>
                  </div>
                  <div class="tr e613">
                     <div class="td e614">Striding</div>
                     <div class="td e615">Crawling</div>
                     <div class="td e616">Crawling</div>
                     <div class="td e617">Consuming</div>
                  </div>
                  <div class="tr e618">
                     <div class="td e619">Crawling</div>
                     <div class="td e620">Climbing</div>
                     <div class="td e621">Climbing</div>
                     <div class="td e622">Motionless</div>
                  </div>
                  <div class="tr e623">
                     <div class="td e624">Crawling</div>
                     <div class="td e625">Striding
                        <div class="superscript e626">c</div>
                     </div>
                     <div class="td e627">Roaming</div>
                     <div class="td e628">Free-ranging</div>
                  </div>
                  <div class="tr e629">
                     <div class="td e630">Crawling</div>
                     <div class="td e631">Crawling
                        <div class="superscript e632">c</div>
                     </div>
                     <div class="td e633">Roaming</div>
                     <div class="td e634">Free-ranging</div>
                  </div>
                  <div class="tr e635">
                     <div class="td e636">Roaming</div>
                     <div class="td e637">any</div>
                     <div class="td e638">Roaming</div>
                     <div class="td e639">Free-ranging</div>
                  </div>
               </div>
            </div>
            
            
            
         </div>
         <div class="para e640">To determine the posture of a function body, it is easiest to consider the argument
            that can take nodes similar to the context item expression 
            <div class="code e641">"."</div>. This
            expression is motionless on itself, but if used with usage 
            <div class="emphasis e642" role="ital">absorption</div> it may become 
            <div class="emphasis e643" role="ital">consuming</div> 
            depending on the input posture of the expression or instruction it appears in, called
            the 
            <div class="emphasis e644" role="ital">context posture</div>. For functions that means, it takes the
            posture of the argument to that function, in other words, the 
            <div class="emphasis e645" role="ital">context posture</div> of the parameter that can take streamed nodes is the
            posture of the argument to the function. Example:
         </div>
         <div class="para e646">
            
            <div class="figure e647" xml:id="f-third-child" xreflabel="Code listing: striding streamable function that can take streamed nodes">
               <div class="programlisting e648" xml:space="preserve">&lt;xsl:function name="f:thirdchild" as="element()"&gt;
                  &lt;xsl:param name="n" as="node()" /&gt;
                  &lt;xsl:sequence select="$n/child::*[3]" /&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;!-- guaranteed streamable: --&gt;
                  &lt;xsl:template match="author"&gt;
                  &lt;xsl:apply-templates select="f:thirdchild(.)" /&gt;
                  &lt;/xsl:template&gt;
                  
                  &lt;!-- not guaranteed streamable: --&gt;
                  &lt;xsl:template match="author"&gt;
                  &lt;xsl:apply-templates select="f:thirdchild(.//book)" /&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
            
         </div>
         <div class="para e649">The body of the function 
            <div class="code e650">f:thirdchild</div> has a posture 
            <div class="emphasis e651" role="ital">striding</div> because of the child axis step. The usage of the
            function is 
            <div class="emphasis e652" role="ital">transitional</div>, which means it can return
            nodes. Using the table above, we can lookup the result posture and sweep of any call
            to
            the function. The first use in this example is in 
            <div class="code e653">xsl:apply-templates</div>,
            which we have seen before takes a usage of 
            <div class="emphasis e654" role="ital">absorption</div>, meaning that overlapping nodes are not allowed
            <div class="popupBox e655">
               <div class="popupLabel" onmouseover="$('#d1e1438').show('1000');" onmouseout="$('#d1e1438').hide('1000');">[ footnote ]</div>
               <div id="d1e1438" style="display: none;">
                  <div class="footnote">
                     <div class="para e656">A public bug entry 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e657" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25185" xlink:show="new" xlink:type="simple">Bug
                           25185
                        </div> tries to resolve this by allowing limited buffering of crawling
                        postures in a absorption contexts such as these, if that bug is accepted and
                        resolved, overlapping nodes as with crawling posture is allowed with usage
                        absorption, at least in the general case.
                     </div>
                  </div>
               </div>
            </div>. The operand here is a call to our function with the current node as
            argument. Inside any template, by definition the context posture, and thus the posture
            of the context item expression, is 
            <div class="emphasis e658" role="ital">striding</div>. The
            table then gives us for argument is 
            <div class="emphasis e659" role="ital">striding</div>,
            function body is 
            <div class="emphasis e660" role="ital">striding</div>, then result posture is
            also 
            <div class="emphasis e661" role="ital">striding</div> and the sweep is 
            <div class="emphasis e662" role="ital">consuming</div>. 
         </div>
         <div class="para e663">Looking at the second use of the function we see another
            
            <div class="code e664">xsl:apply-templates</div>, this time with a 
            <div class="emphasis e665" role="ital">crawling</div> path expression (the descendant axis is returns a crawling
            posture, it can have overlapping nodes) as argument to the function. From the table
            this
            gives us for argument is 
            <div class="emphasis e666" role="ital">crawling</div>, function body
            
            <div class="emphasis e667" role="ital">striding</div> the result posture of 
            <div class="emphasis e668" role="ital">roaming</div> and a sweep of 
            <div class="emphasis e669" role="ital">free-ranging</div>. Even without the table we can see from the argument that
            it returns overlapping nodes and that a processor will have to potentially look back
            and
            forward to find the third child of each overlapping node. If there is no overlap,
            this
            problem would not arise, but statically we do not know that, and the processor has
            to
            assume the worst.
         </div>
      </div><a name="MultipleargumentsthatcantakenodesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e670" xml:id="multiple-arguments">
         <div class="title e671">Multiple arguments that can take nodes</div>
         <div class="para e672">With streaming, it is not possible to have one construct take multiple downward select
            expressions, or more generally, multiple consuming expressions. Suppose we were to
            allow
            a function call to take multiple arguments that are streamed nodes, this rule would
            backfire. An function call such as 
            <div class="code e673">f:equals(foo, bar)</div> has two downward
            select expressions, 
            <div class="code e674">foo</div> and 
            <div class="code e675">bar</div>. Because there is no way the
            processor can know in what order these appear in the input document, it is possible
            that
            
            <div class="code e676">foo</div> appears before 
            <div class="code e677">bar</div>, or the other way around, which
            means that the processor may have to look back to find the other child. This is the
            general reason why multiple downward selects are not allowed in any single
            construct.
         </div>
         <div class="para e678">We could argue that one argument can be a 
            <div class="emphasis e679" role="ital">grounded</div>
            node and another a streamed node. But that does not help us much further, because
            it
            hits the same problems as with the non-streamable functions we showed earlier: how
            can
            we tell the user of the function to choose between 
            <div class="code e680">fn:snapshot</div> and
            
            <div class="code e681">fn:copy-of</div> and how can he determine what argument can take a streamed
            node and what argument cannot?
         </div>
         <div class="para e682">Another argument to allow multiple arguments that can take nodes is that one argument
            can be motionless in the function body and the other is not. Together they would be
            consuming, or if both are motionless, together they would be motionless. But this
            still
            does not deal with the fact that to get a node into the function, that node first
            needs
            to be consumed, unless it is the context node or an ancestor of the context node.
            These
            restrictions would be very limiting and also very hard to define in spec
            language.
         </div>
         <div class="para e683">The resolution is to keep things simple. Instead of allowing multiple arguments that
            take nodes, streamable functions can have a maximum of one parameter that can take
            nodes. The other arguments must either be non-node types, or absent.
         </div>
      </div><a name="RecursivestreamablefunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e684" xml:id="recursion">
         <div class="title e685">Recursive streamable functions</div>
         <div class="para e686">In 
            <div class="xref e687" linkend="posture-sweep-table"></div>
            in 
            <div class="xref e688" linkend="posture-sweep"></div> we have seen that it is
            possible to write functions with any kind of result posture. The result posture is
            then
            dependent on the argument passed to the function. This works for the trivial case
            where
            the function body is simple and can be analyzed. But what happens if we try to apply
            those rules with a function body that is recursive?
         </div>
         <div class="para e689">For this section I consider four kinds of recursion
            <div class="popupBox e690">
               <div class="popupLabel" onmouseover="$('#d1e1528').show('1000');" onmouseout="$('#d1e1528').hide('1000');">[ footnote ]</div>
               <div id="d1e1528" style="display: none;">
                  <div class="footnote">
                     <div class="para e691">The XSL Transformations 3.0 Working Draft does not use this terminology, but
                        it helps differentiate different situations for this discussion.
                     </div>
                  </div>
               </div>
            </div>:
            <div class="itemizedlist e692">
               <div class="listitem e693">
                  <div class="para e694">
                     <div class="emphasis e695" role="ital">Direct recursion:</div> function calls itself
                     inside the body of the function.
                  </div>
               </div>
               <div class="listitem e696">
                  <div class="para e697">
                     <div class="emphasis e698" role="ital">Indirect recursion:</div> function calls
                     itself indirectly through another function it calls.
                  </div>
               </div>
               <div class="listitem e699">
                  <div class="para e700">
                     <div class="emphasis e701" role="ital">Indeterminate recursion:</div> function
                     applies templates and a template at some level calls the function.
                  </div>
               </div>
               <div class="listitem e702">
                  <div class="para e703">
                     <div class="emphasis e704" role="ital">Dynamic recursion:</div> a dynamic function
                     call resolves, or can resolve to a function which is currently
                     executed.
                  </div>
               </div>
            </div>
         </div><a name="DirectrecursionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e705" xml:id="direct-recursion">
            <div class="title e706">Direct recursion</div>
            <div class="para e707">To understand the challenges when dealing with recursive functions it is enough to
               look at a most trivial example, which is clearly streamable and uses infinite direct
               recursion:
            </div>
            <div class="para e708">
               
               <div class="figure e709" xml:id="f-recur" xreflabel="Code listing: trivial direct recursion">
                  <div class="programlisting e710" xml:space="preserve">&lt;xsl:function name="f:recur"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:sequence select="f:recur($n)" /&gt;
                     &lt;/xsl:function&gt;
                     
                     &lt;xsl:template match="x"&gt;
                     &lt;xsl:apply-templates select="f:recur(y)" /&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               
               
            </div>
            <div class="para e711">This function does not have an exit-clause for the recursion and will run
               indefinitely, likely causing a stackoverflow error. But it is legal XSLT and it is
               streamable in the sense that it no movement occurs on the streamed argument.
            </div>
            <div class="para e712">If we analyze this function using 
               <div class="xref e713" linkend="posture-sweep-table"></div>, we run into a problem:
               <div class="itemizedlist e714">
                  <div class="listitem e715">
                     <div class="para e716">First we need to determine the posture of the argument to the
                        function, here it is 
                        <div class="emphasis e717" role="ital">striding</div>.
                     </div>
                  </div>
                  <div class="listitem e718">
                     <div class="para e719">This sets the posture of 
                        <div class="code e720">$n</div> to 
                        <div class="emphasis e721" role="ital">striding</div> as well. The next step is to determine the
                        posture and sweep of the function body.
                     </div>
                  </div>
                  <div class="listitem e722">
                     <div class="para e723">To determine that, we need to determine the posture and sweep of the
                        contained sequence constructor, which is a single
                        
                        <div class="code e724">xsl:sequence</div> with here one operand, the
                        select-expression.
                     </div>
                  </div>
                  <div class="listitem e725">
                     <div class="para e726">The posture and sweep of 
                        <div class="code e727">xsl:sequence</div> is equal to the
                        posture and sweep of its select expression
                        <div class="popupBox e728">
                           <div class="popupLabel" onmouseover="$('#d1e1598').show('1000');" onmouseout="$('#d1e1598').hide('1000');">[ footnote ]</div>
                           <div id="d1e1598" style="display: none;">
                              <div class="footnote">
                                 <div class="para e729">See 
                                    <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e730" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-xsl-sequence" xlink:show="new" xlink:type="simple">19.8.4.33 Streamability of 
                                       <div class="code e731">xsl:sequence</div> in XSL
                                       Transformations 3.0
                                    </div>.
                                 </div>
                              </div>
                           </div>
                        </div>, here 
                        <div class="code e732">f:recur($n)</div>.
                     </div>
                  </div>
                  <div class="listitem e733">
                     <div class="para e734">We know the posture of 
                        <div class="code e735">$n</div>, but to determine the posture
                        of the function call 
                        <div class="code e736">f:recur</div> we need to analyze the
                        function body again, which we already did, but without having a
                        conclusive sweep or posture yet. We've reached an eternal analysis loop,
                        the function is 
                        <div class="emphasis e737" role="ital">non-analyzable</div>.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e738">It is not trivial to resolve this dead end situation. One way forward could be to
               split the function body artificially into two operands and analyze each
               individually: one for the part without the recursion point
               <div class="popupBox e739">
                  <div class="popupLabel" onmouseover="$('#d1e1625').show('1000');" onmouseout="$('#d1e1625').hide('1000');">[ footnote ]</div>
                  <div id="d1e1625" style="display: none;">
                     <div class="footnote">
                        <div class="para e740">I use the term 
                           <div class="emphasis e741" role="ital">recursion point</div> for the
                           place in the code where the recursion is invoked, but this is not a term
                           that is used in the specification.
                        </div>
                     </div>
                  </div>
               </div>, setting the recursive function to the empty sequence 
               <div class="code e742">()</div>,
               and one for the argument to the recursion point. This will help somewhat, but feels
               wrong and is hard to proof right. What would happen if a function returns streamed
               nodes and gets a 
               <div class="emphasis e743" role="ital">climbing</div> input and the output is
               of a different posture?
            </div>
            <div class="para e744">Looking back at 
               <div class="xref e745" linkend="posture-sweep-table"></div> we can deduct that
               any function call with a 
               <div class="emphasis e746" role="ital">climbing</div> or 
               <div class="emphasis e747" role="ital">crawling</div> argument must yield a 
               <div class="emphasis e748" role="ital">climbing</div> or 
               <div class="emphasis e749" role="ital">crawling</div> result. The
               only argument that is allowed to return a different result posture is an input with
               a 
               <div class="emphasis e750" role="ital">striding</div> posture. This makes sense, because the
               natural process for streaming is to go through the input document depth-first, which
               is the 
               <div class="emphasis e751" role="ital">striding</div> posture and once you change
               direction upwards, you cannot go down again: it would make a construct roaming. To
               summarize, we can consider that:
               <div class="itemizedlist e752">
                  <div class="listitem e753">
                     <div class="para e754">A 
                        <div class="emphasis e755" role="ital">climbing</div> input argument must
                        remain climbing to be streamable, so if the input is climbing, the
                        recursive argument must also be climbing and the body cannot contain an
                        expression in another direction.
                     </div>
                  </div>
                  <div class="listitem e756">
                     <div class="para e757">A 
                        <div class="emphasis e758" role="ital">striding</div> input argument can
                        change to 
                        <div class="emphasis e759" role="ital">climbing</div> but not to
                        
                        <div class="emphasis e760" role="ital">crawling</div> in recursion, because
                        that would validate the next point. If it changes to 
                        <div class="emphasis e761" role="ital">climbing</div> the whole function body must be
                        motionless, because you cannot both climb and consume, and if it stays
                        
                        <div class="emphasis e762" role="ital">striding</div> the whole function body
                        must be 
                        <div class="emphasis e763" role="ital">striding</div> and can be either
                        motionless or consuming.
                     </div>
                  </div>
                  <div class="listitem e764">
                     <div class="para e765">A 
                        <div class="emphasis e766" role="ital">crawling</div> input argument can only
                        take motionless expressions, it cannot turn magically back into
                        
                        <div class="emphasis e767" role="ital">striding</div>
                        <div class="popupBox e768">
                           <div class="popupLabel" onmouseover="$('#d1e1698').show('1000');" onmouseout="$('#d1e1698').hide('1000');">[ footnote ]</div>
                           <div id="d1e1698" style="display: none;">
                              <div class="footnote">
                                 <div class="para e769">See the table under 
                                    <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e770" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple">19.8.7..7 Streamability of Axis Steps in XSL
                                       Transformations 3.0
                                    </div>.
                                 </div>
                              </div>
                           </div>
                        </div> nor is it allowed to have a 
                        <div class="emphasis e771" role="ital">crawling</div> expression operate on another 
                        <div class="emphasis e772" role="ital">crawling</div> expression.
                     </div>
                  </div>
                  <div class="listitem e773">
                     <div class="para e774">Anything 
                        <div class="emphasis e775" role="ital">roaming</div> will always stay
                        
                        <div class="emphasis e776" role="ital">roaming</div>.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e777">The following table shows what this means for different argument postures of calls
               to a function, what the recursive argument (the one at the recursion point) can be
               and the result posture of the recursive call is and what the posture of the function
               body must be (it must be the same) and what the sweep is of the recursive call. The
               last column stresses the maximum sweep of the function body with the given
               arguments. Note that all these analyses are 
               <div class="emphasis e778" role="ital">in the context
                  of the initial function call
               </div>, not the recursive call, which makes it
               possible to allow one function body to take different postures as input:
            </div>
            <div class="para e779">
               
               <div class="table e780" border="1px" cellpadding="3" frame="border" rules="all" xml:id="table-recursive-calls" xreflabel="Table IV: Posture and sweep of recursive stylesheet function calls">
                  <div class="colgroup e781" span="1">
                     <div class="metaBox e782"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1729').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1729" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e782'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e783"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1730').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1730" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e783'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e784"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1731').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1731" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e784'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e785"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1732').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1732" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e785'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e786"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1733').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1733" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e786'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">width='1.0*'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="thead e787">
                     <div class="tr e788">
                        <div class="th e789" align="left">Argument&nbsp;posture</div>
                        <div class="th e790" align="left">Recursive&nbsp;argument posture</div>
                        <div class="th e791" align="left">Recursive&nbsp;function body&nbsp;&amp;&nbsp;call&nbsp;posture
                           <div class="superscript e792">a</div>
                        </div>
                        <div class="th e793" align="left">Recursive&nbsp;function call sweep</div>
                        <div class="th e794" align="left">Maximum&nbsp;function body sweep</div>
                     </div>
                  </div>
                  <div class="tfoot e795">
                     <div class="tr e796">
                        <div class="td e797" colspan="5">
                           <div class="para e798">
                              
                              <div class="superscript e799">a)
                                 The function body must match the recursive call
                                 posture or be grounded, otherwise the posture is
                                 roaming.
                              </div>
                              
                           </div>
                           
                           <div class="para e800">
                              
                              <div class="superscript e801">b)
                                 In fact, if the argument is grounded, the recursive
                                 argument will also be grounded.
                              </div>
                              
                           </div>
                           
                           <div class="para e802">
                              
                              <div class="superscript e803">c)
                                 Because on a next iteration, the argument will be
                                 crawling, not striding anymore, it would be a crawling
                                 expr. on a crawling expr. which is not guaranteed
                                 streamable.
                              </div>
                              
                           </div>
                           
                        </div>
                     </div>
                  </div>
                  <div class="tbody e804">
                     <div class="tr e805">
                        <div class="td e806">Grounded</div>
                        <div class="td e807">Any (grounded)
                           <div class="superscript e808">b</div>
                        </div>
                        <div class="td e809">Grounded
                           <div class="superscript e810">b</div>
                        </div>
                        <div class="td e811">Motionless</div>
                        <div class="td e812">Motionless</div>
                     </div>
                     <div class="tr e813">
                        <div class="td e814">any</div>
                        <div class="td e815">
                           <div class="emphasis e816" role="ital">Direct-transitional</div>
                        </div>
                        <div class="td e817" align="left">Posture of argument</div>
                        <div class="td e818">Motionless</div>
                        <div class="td e819" align="left">Consuming</div>
                     </div>
                     <div class="tr e820">
                        <div class="td e821">Climbing</div>
                        <div class="td e822">Climbing</div>
                        <div class="td e823">Climbing</div>
                        <div class="td e824">Motionless</div>
                        <div class="td e825">Motionless</div>
                     </div>
                     <div class="tr e826">
                        <div class="td e827">Climbing</div>
                        <div class="td e828">Non-climbing</div>
                        <div class="td e829">Roaming</div>
                        <div class="td e830">Free-ranging</div>
                        <div class="td e831">n/a</div>
                     </div>
                     <div class="tr e832">
                        <div class="td e833">Striding</div>
                        <div class="td e834">Climbing</div>
                        <div class="td e835">Climbing</div>
                        <div class="td e836">Motionless</div>
                        <div class="td e837">Motionless</div>
                     </div>
                     <div class="tr e838">
                        <div class="td e839">Striding</div>
                        <div class="td e840">Striding</div>
                        <div class="td e841">Striding</div>
                        <div class="td e842">Consuming</div>
                        <div class="td e843">Consuming</div>
                     </div>
                     <div class="tr e844">
                        <div class="td e845">Striding</div>
                        <div class="td e846">Crawling</div>
                        <div class="td e847">Roaming
                           <div class="superscript e848">c</div>
                        </div>
                        <div class="td e849">Free-ranging
                           <div class="superscript e850">c</div>
                        </div>
                        <div class="td e851">n/a</div>
                     </div>
                     <div class="tr e852">
                        <div class="td e853">Crawling</div>
                        <div class="td e854">Climbing</div>
                        <div class="td e855">Climbing</div>
                        <div class="td e856">Motionless</div>
                        <div class="td e857">Motionless</div>
                     </div>
                     <div class="tr e858">
                        <div class="td e859">Crawling</div>
                        <div class="td e860">Non-climbing</div>
                        <div class="td e861">Roaming</div>
                        <div class="td e862">Free-ranging</div>
                        <div class="td e863">n/a</div>
                     </div>
                     <div class="tr e864">
                        <div class="td e865">Roaming</div>
                        <div class="td e866">any</div>
                        <div class="td e867">Roaming</div>
                        <div class="td e868">Free-ranging</div>
                        <div class="td e869">n/a</div>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e870">For this table to work in practice, we can allow at most one recursion point, or
               each recursion point must have the same posture 
               <div class="emphasis e871" role="ital">and</div> at most one can be consuming. Once you have found the posture
               and sweeps of the recursive function call, you can continue the analysis of the
               function body and then apply the previous 
               <div class="xref e872" linkend="posture-sweep-table"></div>.
            </div>
            <div class="para e873">The rules in this table are laid out in such a way that it is not possible to have
               a 
               <div class="emphasis e874" role="ital">climbing</div> expression as the argument to a
               recursive function at a recursion point and somewhere else in the same function body
               a consuming construct or a non-climbing result. This is necessary, because if we
               would allow the combination of a 
               <div class="emphasis e875" role="ital">climbing</div>
               recursion point and a 
               <div class="emphasis e876" role="ital">striding</div> function body,
               then on either the initial call (with a 
               <div class="emphasis e877" role="ital">climbing</div>
               argument) or the recursive call (if the initial call would have been 
               <div class="emphasis e878" role="ital">striding</div> for instance) would call the function with an
               incompatible 
               <div class="emphasis e879" role="ital">climbing</div> posture, which would then
               be consumed. And a 
               <div class="emphasis e880" role="ital">climbing</div> posture can never be
               consumed. More specifically, it prevents a function like the following to be
               considered streamable:
            </div>
            <div class="para e881">
               
               <div class="figure e882" xml:id="f-climbstri" xreflabel="Code listing: non-streamable climbing and consuming">
                  <div class="programlisting e883" xml:space="preserve">&lt;xsl:function name="f:climbstri"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:choose&gt;
                     &lt;xsl:when test="f:climbstri($n/ancestor::foo)/contains(., 'bar')"&gt;
                     &lt;xsl:text&gt;Found it&lt;/xsl:text&gt;
                     &lt;/xsl:when&gt;
                     &lt;xsl:otherwise&gt;
                     &lt;xsl:value-of select="$n" /&gt;
                     &lt;/xsl:otherwise&gt;
                     &lt;/xsl:choose&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e884">Glancing over the example might already give a hint as to why it cannot possibly
               be streamable: the 
               <div class="code e885">xsl:value-of</div> can consume a streamed node and that
               streamed node is likely to be at a climbing axis because of the climbing posture of
               the recursive argument. If we take the item in the table into account and consider
               calling this function with a striding argument, as with 
               <div class="code e886">f:climbstr(a/b)</div>
               then we find in the entry for 
               <div class="emphasis e887" role="ital">striding</div> and
               
               <div class="emphasis e888" role="ital">climbing</div> that the body of the function must
               at most be motionless. It is consuming, because of the 
               <div class="code e889">xsl:value-of</div> so
               the analysis fails and the function is 
               <div class="emphasis e890" role="ital">roaming</div>
               and 
               <div class="emphasis e891" role="ital">free-ranging</div>.
            </div>
            <div class="para e892">If we go back to our original example (see 
               <div class="xref e893" linkend="f-recur"></div>) and apply
               the rules of this table, we have one recursion point, 
               <div class="code e894">f:recur($n)</div>, the
               argument is 
               <div class="emphasis e895" role="ital">direct-transitional</div>, that is, it is
               motionless and takes the posture of its caller, in this case the caller of the
               function. According to the table above, we can use any posture as input, which will
               then become the result posture, and the sweep of the function body follows as
               
               <div class="emphasis e896" role="ital">motionless</div> and 
               <div class="emphasis e897" role="ital">grounded</div>. In our case, the call has a child-select expression in
               
               <div class="code e898">f:recur(y)</div>, which has posture 
               <div class="emphasis e899" role="ital">striding</div> and sweep 
               <div class="emphasis e900" role="ital">consuming</div>. The
               result posture and sweep of the whole template is then 
               <div class="emphasis e901" role="ital">grounded</div> and 
               <div class="emphasis e902" role="ital">consuming</div>.
            </div>
         </div><a name="IndirectrecursionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e903" xml:id="indirect-recursion">
            <div class="title e904">Indirect recursion</div>
            <div class="para e905">With indirect recursion there are extra layers of calls before the recursion takes
               place, as in A calls B calls C calls A again. The question that rises is whether the
               rules in 
               <div class="xref e906" linkend="direct-recursion"></div> also hold if a function calls itself
               indirectly. Indirect recursion is a type of recursion that can also be determined
               statically. Let us look at an example:
            </div>
            <div class="para e907">
               
               <div class="figure e908" xml:id="f-filterattr" xreflabel="Code listing: indirect recursion">
                  <div class="programlisting e909" xml:space="preserve">&lt;xsl:function name="f:filterattr"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:param name="filter" /&gt;
                     &lt;xsl:sequence select="$n/@*[name() = $filter]" /&gt;
                     &lt;!-- indirect recursion --&gt;
                     &lt;xsl:sequence select="f:take-ancestor($n, $filter)" /&gt;
                     &lt;/xsl:function&gt;
                     
                     &lt;xsl:function name="f:take-ancestor"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:param name="filter" /&gt;
                     &lt;xsl:sequence select="
                     if($n) 
                     (: indirect recursion :)
                     then f:filterattr($n/ancestor::element()[1], $filter) 
                     else ()" /&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e910">The example is a very verbose and clumsy way of getting all attributes of all
               ancestor-or-self nodes that have a certain name. For instance, with the
               following input and stylesheet, the output will be 
               <div class="code e911">3.14 1.64</div>:
            </div>
            <div class="para e912">
               
               <div class="figure e913" xml:id="f-input-doc" xreflabel="Code listing: input document">
                  <div class="programlisting e914" xml:space="preserve">&lt;foo version="1.64" name="john"&gt;
                     &lt;zed&gt;
                     &lt;bar version="3.14" id="1234"&gt;
                     &lt;/zed&gt;
                     &lt;/foo&gt;
                  </div>
               </div>
               
               <div class="figure e915" xml:id="f-stylesheet" xreflabel="Code listing: indirect recursive function call example">
                  <div class="programlisting e916" xml:space="preserve">&lt;xsl:mode on-no-match="shallow-skip" /&gt;
                     
                     &lt;xsl:template match="bar"&gt;
                     &lt;xsl:value-of select="f:filterattr(., 'version')" /&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e917">But whether it is clumsy or not is not the matter. It serves as a basic example of
               indirect recursion and the function is clearly streamable because it only traverses
               the ancestor and attribute axes, which are motionless. However, the question is, of
               course, whether this example is streamable by following the rules from 
               
               <div class="xref e918" linkend="table-recursive-calls"></div>.
            </div>
            <div class="para e919">If we try that a first time, we quickly find that it is not immediately obvious
               how to apply it, because the functions above are not directly recursive. Recall that
               we said in 
               <div class="xref e920" linkend="direct-recursion"></div> we wrote 
               <div class="quote e921"> we can allow at most
                  one recursion point, or each recursion point must have the same posture and at
                  most one can be consuming 
               </div>. There are two recursion points here, the one
               inside 
               <div class="code e922">f:filterattr</div> that calls 
               <div class="code e923">f:take-ancestor</div> and the one
               inside 
               <div class="code e924">f:take-ancestor</div> that calls 
               <div class="code e925">f:filterattr</div>. The
               posture of the first one takes the input posture of the argument, it is 
               <div class="emphasis e926" role="ital">Direct-transitional</div>, the second one traverses the
               ancestor axis, which gives it a 
               <div class="emphasis e927" role="ital">climbing</div> posture.
               Finally, the argument inside the template example in 
               <div class="xref e928" linkend="f-stylesheet"></div>
               has itself a posture of 
               <div class="emphasis e929" role="ital">striding</div>, because the
               context item expression takes the 
               <div class="emphasis e930" role="ital">context posture</div>
               which in the case of 
               <div class="code e931">xsl:template</div> is 
               <div class="emphasis e932" role="ital">striding</div>.
            </div>
            <div class="para e933">In short, if we start at the template, we start with posture 
               <div class="emphasis e934" role="ital">striding</div>, then 
               <div class="emphasis e935" role="ital">striding</div> again
               (because it is 
               <div class="emphasis e936" role="ital">direct-transitional</div>), then 
               <div class="emphasis e937" role="ital">climbing</div> and on the next recursive iteration this
               repeats, but now from 
               <div class="emphasis e938" role="ital">climbing</div> as input to
               
               <div class="code e939">f:filter-attr</div>, then 
               <div class="emphasis e940" role="ital">climbing</div> again
               (because 
               <div class="emphasis e941" role="ital">direct-transitional</div> takes over the posture
               of the argument) and so it continues climbing until all recursive iterations have
               finished.
            </div>
            <div class="para e942">This breaks the rule we set to ourselves: the posture changed from 
               <div class="emphasis e943" role="ital">striding</div> to 
               <div class="emphasis e944" role="ital">climbing</div>.
               Yet, we also established that the example functions were streamable. The conflict
               arises from the argument 
               <div class="code e945">$n</div> being 
               <div class="emphasis e946" role="ital">direct-transitional</div>, which works like a cameleon and changes the
               posture along the way. One resolution to this specific situation is to allow
               
               <div class="emphasis e947" role="ital">direct-transitional</div>, provided the rest of the
               body of the function is motionless, in which case it does no harm. Another, perhaps
               easier solution is to force the 
               <div class="emphasis e948" role="ital">same posture in, same posture
                  out
               </div> rule and rewrite the argument to this function as follows:
            </div>
            <div class="para e949">
               
               <div class="figure e950" xml:id="f-stylesheet-fixed" xreflabel="Code listing: fixed indirect recursive function call">
                  <div class="programlisting e951" xml:space="preserve">&lt;xsl:mode on-no-match="shallow-skip" /&gt;
                     
                     &lt;xsl:template match="bar"&gt;
                     &lt;xsl:value-of select="f:filterattr(./ancestor-or-self::*[1], 'version')" /&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e952">The change to using the ancestor-or-self axis also changes the initial posture to
               
               <div class="emphasis e953" role="ital">climbing</div>, which in turn changes the posture of
               
               <div class="code e954">$n</div> to be 
               <div class="emphasis e955" role="ital">climbing</div> as well, making
               all postures in all recursion points climbing.
            </div>
            <div class="para e956">While this relatively trivial example seemed to show an edge-case because it used
               a recursive argument posture of 
               <div class="emphasis e957" role="ital">direct-transitional</div>, it taught us two things: one, even a trivial
               example can quickly appear hard once we try to apply streamability rules on them and
               two, to keep things simple, it is best to stick a set of ground rules, even though
               that potentially means that we slightly limit certain use-cases.
            </div>
            <div class="para e958">In practice, indirect recursion is found pretty rarely in XSLT programming, even
               though XSLT is itself a functional language, it is much more common to use direct
               recursion. But if a scenario requires indirect recursion, it is possible, even with
               streaming.
            </div>
         </div><a name="IndeterminaterecursionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e959" xml:id="indeterminate-recursion">
            <div class="title e960">Indeterminate recursion</div>
            <div class="para e961">Another challenge comes from indeterminate recursion as in the following
               example:
            </div>
            <div class="para e962">
               
               <div class="figure e963" xml:id="f-indeter" xreflabel="Code listing: trivial indeterminate recursion">
                  <div class="programlisting e964" xml:space="preserve">&lt;xsl:function name="f:indeter"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:apply-templates select="$n" mode="streamable" /&gt;
                     &lt;/xsl:function&gt;
                     
                     &lt;xsl:template match="*" mode="streamable"&gt;
                     &lt;xsl:sequence select="f:indeter(.)" /&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e965">In this situation, the analysis of the function declaration and the template
               declaration can be done independently, without ever finding the recursion point.
               However, when this code is run, the recursion kicks in (assuming the argument is an
               element). There is, however, one big advantage to this type of recursion: the rules
               on
               templates define that the result of a template declaration must be 
               <div class="emphasis e966" role="ital">grounded</div>
               <div class="popupBox e967">
                  <div class="popupLabel" onmouseover="$('#d1e2145').show('1000');" onmouseout="$('#d1e2145').hide('1000');">[ footnote ]</div>
                  <div id="d1e2145" style="display: none;">
                     <div class="footnote">
                        <div class="para e968">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e969" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamable-templates" xlink:show="new" xlink:type="simple">6.6.3, Streamable Templates in XSL Transformations 3.0</div>, second
                           bullet-point: 
                           <div class="quote e970">The sequence constructor contained in the body of the
                              xsl:template element is grounded
                           </div>.
                        </div>
                     </div>
                  </div>
               </div>. Therefore, by definition, the result of any
               
               <div class="code e971">xsl:apply-templates</div> is also 
               <div class="emphasis e972" role="ital">grounded</div>, which gives the function body above a 
               <div class="emphasis e973" role="ital">grounded</div> posture as well. In turn, the call to 
               <div class="code e974">f:indeter</div>
               results in a 
               <div class="emphasis e975" role="ital">grounded</div> posture, which concludes the
               circle. In addition, any select-expression in 
               <div class="code e976">xsl:apply-templates</div> must be
               atomizable, which in streamability terms means that it cannot be 
               <div class="emphasis e977" role="ital">climbing</div> or 
               <div class="emphasis e978" role="ital">crawling</div>
               <div class="popupBox e979">
                  <div class="popupLabel" onmouseover="$('#d1e2179').show('1000');" onmouseout="$('#d1e2179').hide('1000');">[ footnote ]</div>
                  <div id="d1e2179" style="display: none;">
                     <div class="footnote">
                        <div class="para e980">One exception is allowed for selections that only select childless nodes, such
                           as attribute nodes. These are 
                           <div class="emphasis e981" role="ital">climbing</div> but do
                           not contain children and are henceforth allowed.
                        </div>
                     </div>
                  </div>
               </div>. This leads us to a temporary conclusion: if the arguments to a function are
               
               <div class="emphasis e982" role="ital">striding</div> they can be used in indeterminate
               recursive functions. If the arguments are not 
               <div class="emphasis e983" role="ital">striding</div>, the analysis fails and makes the call on the function
               
               <div class="emphasis e984" role="ital">roaming</div> and 
               <div class="emphasis e985" role="ital">free-ranging</div>.
            </div>
            <div class="para e986">Following 
               <div class="xref e987" linkend="posture-sweep-table"></div> and taking the same
               approach that the body of the function should be analyzed during the call to the
               function, we can conclude that it is impossible for a function body to apply
               templates on something else then a 
               <div class="emphasis e988" role="ital">striding</div>
               posture. The one exception that is allowed in the General Streamability Rules
               <div class="popupBox e989">
                  <div class="popupLabel" onmouseover="$('#d1e2206').show('1000');" onmouseout="$('#d1e2206').hide('1000');">[ footnote ]</div>
                  <div id="d1e2206" style="display: none;">
                     <div class="footnote">
                        <div class="para e990">See 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e991" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#general-streamability-rules" xlink:show="new" xlink:type="simple">Section 19.8.1 General Streamability Rules in XSL Transformations
                              3.0
                           </div>, item 1.b.iii.A.I.
                        </div>
                     </div>
                  </div>
               </div>is for a 
               <div class="emphasis e992" role="ital">climbing</div> posture of childless
               nodes, which only applies to the attribute axis. This means that we can consider the
               following example streamable as well, even though we pass a 
               <div class="emphasis e993" role="ital">climbing</div>, or even a 
               <div class="emphasis e994" role="ital">crawling</div>
               expression to the function:
            </div>
            <div class="para e995">
               
               <div class="figure e996" xml:id="f-apply-attribs" xreflabel="Code listing: climbing result accepting crawling posture">
                  <div class="programlisting e997" xml:space="preserve">&lt;xsl:function name="f:apply-attribs"&gt;
                     &lt;xsl:param name="n" /&gt;
                     &lt;xsl:apply-templates select="$n/@*" /&gt;
                     &lt;/xsl:function&gt;
                  </div>
               </div>
               
            </div>
            <div class="para e998">Whether or not that function will be called indeterminate-recursively or not is
               irrelevant, because on the second iteration, the selection will be empty, because
               attribute nodes do not have children.
            </div>
            <div class="para e999">In short: indeterminate recursion does not have influence on the streamability
               analysis, nor does it break it. The existing rules suffice.
            </div>
         </div><a name="DynamicrecursionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1000">
            <div class="title e1001">Dynamic recursion</div>
            <div class="para e1002">Dynamic recursion looks a bit like indeterminate recursion in the sense that
               whether or not recursion takes place cannot be determined statically. In XPath 3.0,
               it is possible to bind a variable to a function
               <div class="popupBox e1003">
                  <div class="popupLabel" onmouseover="$('#d1e2238').show('1000');" onmouseout="$('#d1e2238').hide('1000');">[ footnote ]</div>
                  <div id="d1e2238" style="display: none;">
                     <div class="footnote">
                        <div class="para e1004">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1005" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-eval-function-call" xlink:show="new" xlink:type="simple">3.1.5.1
                              Evaluating Static and Dynamic Function Calls
                           </div> in the XPath 3.0
                           Recommendation.
                        </div>
                     </div>
                  </div>
               </div>, this is commonly referred to as higher order functions. The concept is
               not new, already in 2001, Dimitre Novatchev showed in his paper
               
               <div class="xref e1006" linkend="Novatchev01"></div> that writing higher order functions is possible
               in XSLT 1.0 by means of what he calls 
               <div class="emphasis e1007" role="ital">template
                  references
               </div>
               <div class="popupBox e1008">
                  <div class="popupLabel" onmouseover="$('#d1e2249').show('1000');" onmouseout="$('#d1e2249').hide('1000');">[ footnote ]</div>
                  <div id="d1e2249" style="display: none;">
                     <div class="footnote">
                        <div class="para e1009">See page 4 of his paper 
                           <div class="xref e1010" linkend="Novatchev01"></div>.
                        </div>
                     </div>
                  </div>
               </div>, a concept also applied to the functional coding patterns in
               
               <div class="xref e1011" linkend="Mangano05"></div>, which was further popularized as 
               <div class="emphasis e1012" role="ital">the Novatchev technique</div> in 
               <div class="xref e1013" linkend="Kay08"></div>.
               It took until XSLT and XPath 3.0 that function items became first-class citizens,
               see my own paper 
               <div class="xref e1014" linkend="Braaksma13"></div> for an extended coverage of that subject
               for XSLT and 
               <div class="xref e1015" linkend="Grust13"></div> for a coverage for XQuery and
               databases.
            </div>
            <div class="para e1016">For the rest of this section, we will assume you have a basic understanding of
               higher order functions in XSLT and XPath. The closure of higher order functions
               cannot contain the context item, so for our analysis we should only worry about
               arguments that can be streamed nodes, just like with regular functions.
            </div>
            <div class="para e1017">The nature of a dynamic function call is that the function it refers to is only
               known at runtime, when the variable is bound to a function item. As a result, there
               is not much we can say of the posture and sweep of the function it refers to until
               it is actually invoked. Following the rules on streamability, the result of binding
               a variable to a function item is always grounded. This makes sense, because at the
               moment of binding, a function item is assigned to a variable and no streamed nodes
               are possibly involved in the result.
            </div>
            <div class="para e1018">Once a function item is evaluated, its arguments are known. Provided that the
               arguments themselves are not 
               <div class="emphasis e1019" role="ital">roaming</div> and
               
               <div class="emphasis e1020" role="ital">free-ranging</div>, the analysis will thenceforth
               look at the bound function. If this function is streamable, we can do the analysis
               from the previous sections as if it was a direct function call. The biggest
               difference lies in the fact that the analysis is done during execution. This means
               that an error for whether a call is not streamable will be a dynamic error.
            </div>
            <div class="para e1021">This is no different for dynamic recursion. If dynamic evaluation leads to a
               recursive call, the posture of the argument, the recursive call and the function
               body must be matched to 
               <div class="xref e1022" linkend="table-recursive-calls"></div>. If the result is
               
               <div class="emphasis e1023" role="ital">roaming</div> and 
               <div class="emphasis e1024" role="ital">free-ranging</div>, the recursive call is not guaranteed
               streamable.
            </div>
            <div class="para e1025">While it is theoretically possible to allow such dynamic streamability rules, the
               rules in the specification are meant to 
               <div class="emphasis e1026" role="ital">guarantee</div>
               streamability statically. As a result, any potential 
               <div class="emphasis e1027" role="ital">dynamic</div> streamability is prohibited. Processors may allow dynamic
               streamability as a vendor extension, but the specification will consider passing a
               node to a dynamic function call 
               <div class="emphasis e1028" role="ital">not guaranteed
                  streamable
               </div>, dynamic recursion, as suggested in this section, is
               therefor not possible with the current set of rules on 
               <div class="emphasis e1029" role="ital">static
                  guaranteed streamability
               </div>.
            </div>
         </div><a name="AnalyzableandnonanalyzablefunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1030" xml:id="analyzable">
            <div class="title e1031">Analyzable and non-analyzable functions</div>
            <div class="para e1032">Analyzable stylesheet functions are functions that can be analyzed by themselves,
               as we saw in 
               <div class="xref e1033" linkend="approach-1"></div>. Non-analyzable stylesheet functions are
               those that can only be analyzed from the function call, because the body of the
               function on itself cannot be analyzed without knowing what the argument is. Most of
               the previous sections was about non-analyzable function calls.
            </div>
            <div class="para e1034">Spec-wise, the term 
               <div class="emphasis e1035" role="ital">non-analyzable</div> refers to the
               set of functions that cannot be analyzed statically and are given very conservative
               assumptions on streamability. This is true for recursive stylesheet functions and
               non-final streamable functions (see 
               <div class="xref e1036" linkend="packages"></div>). The term 
               <div class="emphasis e1037" role="ital">non-analyzable</div> does not necessarily mean that the
               function is not analyzable, however, the general rule is that it requires a call,
               or
               knowledge of the context of a call to the function to find out whether or not the
               function is streamable. We have seen in the previous sections that it is possible
               to
               allow quite a variety of postures, even for non-analyzable functions, but in the
               specification such functions are limited to a posture of 
               <div class="emphasis e1038" role="ital">striding</div> and are always considered 
               <div class="emphasis e1039" role="ital">consuming</div> even if in fact they are not.
            </div>
         </div>
      </div><a name="NonfinalstreamablefunctionsinpackagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1040" xml:id="packages">
         <div class="title e1041">Non-final streamable functions in packages</div>
         <div class="para e1042">In XSLT 3.0, a new feature, 
            <div class="emphasis e1043" role="ital">packages</div> allows
            programmers to create a collection of modes, functions, named and matching templates,
            accumulators etc and pack them in a, potentially pre-compilable, 
            <div class="emphasis e1044" role="ital">package</div>, which can then be included in other packages or stylesheets
            with 
            <div class="code e1045">xsl:use-package</div>
            <div class="popupBox e1046">
               <div class="popupLabel" onmouseover="$('#d1e2339').show('1000');" onmouseout="$('#d1e2339').hide('1000');">[ footnote ]</div>
               <div id="d1e2339" style="display: none;">
                  <div class="footnote">
                     <div class="para e1047">See section 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1048" xlink:actuate="onRequest" xlink:href="https://www.w3.org/XML/Group/qtspecs/specifications/xslt-30/html/Overview.html#package-dependencies" xlink:show="new" xlink:type="simple">3.6.1 Dependencies between Packages</div> in XSLT 3.0 Working
                        Draft.
                     </div>
                  </div>
               </div>
            </div>. Components in that package can have a 
            <div class="emphasis e1049" role="ital">visibility</div> attribute that can be set to 
            <div class="emphasis e1050" role="ital">public</div>, 
            <div class="emphasis e1051" role="ital">private</div>, 
            <div class="emphasis e1052" role="ital">final</div> or 
            <div class="emphasis e1053" role="ital">abstract</div>. If the visibility is
            set to 
            <div class="emphasis e1054" role="ital">private</div> it can only be used in the local
            package, and if it is set to 
            <div class="emphasis e1055" role="ital">final</div> the declaration
            cannot be overridden, but can be used also in other packages. Visibility 
            <div class="emphasis e1056" role="ital">abstract</div> means there is no implementation yet, and it must be
            implemented by a using package (one that includes the package). And 
            <div class="emphasis e1057" role="ital">public</div>, the default, means that a declaration can be
            overridden by using 
            <div class="code e1058">xsl:override</div>, which will then take precedence over the
            original implementation. This can be considered similar to 
            <div class="emphasis e1059" role="ital">virtual
               methods
            </div> in object-oriented languages like C++ and C#.
         </div>
         <div class="para e1060">The result for determining whether a function can be 
            <div class="emphasis e1061" role="ital">guaranteed
               streamable
            </div> or not cannot be determined statically at the moment that a
            package is compiled, because it is possible that it will later be overridden and any
            calls to that function can be impacted if the implementation, and the streamability,
            changes.
         </div>
         <div class="para e1062">As briefly explained in the previous section, if a function is defined with visibility
            
            <div class="emphasis e1063" role="ital">abstract</div> or 
            <div class="emphasis e1064" role="ital">public</div>, in other words, if they are non-final and non-private, then they are
            considered 
            <div class="emphasis e1065" role="ital">non-analyzable</div> by the specification. This
            means that the processor cannot, and does not have to, try to analyze function calls
            too
            deeply: it only expects a 
            <div class="emphasis e1066" role="ital">striding</div> posture and it will
            not try to determine whether or not the function is consuming or motionless when you
            call the function: it assumes the worst and will consider the call 
            <div class="emphasis e1067" role="ital">consuming</div>.
         </div>
         <div class="para e1068">A proposal from me in the bug entry 
            <div class="popupBox e1069">
               <div class="popupLabel" onmouseover="$('#d1e2405').show('1000');" onmouseout="$('#d1e2405').hide('1000');">[ footnote ]</div>
               <div id="d1e2405" style="display: none;">
                  <div class="footnote">
                     <div class="para e1070">See 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1071" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple">Bug
                           25679
                        </div> in W3C's BugZilla, which discusses the implications of allowing
                        streamable stylesheet functions.
                     </div>
                  </div>
               </div>
            </div>awaits reaction from the working group. It shows a way that processors can
            use to statically detemine the posture of non-final streamable functions. However,
            if
            that proposal were excepted, it will pose limitations on overriding non-final streamable
            stylesheet functions. I think, however, that not being able to override a function,
            and
            not being able to write non-final functions, is too severe a limitation. Even if a
            function is non-final, if you override it to make it final, you will have to rewrite
            the
            whole function body, you cannot use 
            <div class="code e1072">xsl:original()</div>, because that would call
            into the non-final function again, which takes too much of conservative approach.
         </div>
         <div class="para e1073">An alternative approach is the approach taken for the recursive functions in the
            previous sections. For all analysis there, we always considered the function call
            itself
            to get the whole picture. For functions that are non-final, such an approach can also
            work. Because the processor only knows what function to call when it encounters the
            function call itself, it should include the body of that function at that moment into
            the analysis. This can be done statically, there is no need to first run the
            stylesheet.
         </div>
         <div class="para e1074">A potential problem, however, still arises if someone writes a package function that
            works correctly with a 
            <div class="emphasis e1075" role="ital">climbing</div> result posture, but
            cannot be used if that is changed into a function override with a 
            <div class="emphasis e1076" role="ital">striding</div> result posture. Even more, a 
            <div class="emphasis e1077" role="ital">motionless</div> function could be changed into a 
            <div class="emphasis e1078" role="ital">consuming</div> function, which will greatly impede existing calls to that
            function. One way to remedy that is to disallow overriding functions with a different
            result posture or with a different sweep. That means that any given call will need
            to be
            analyzed against the new function and the 
            <div class="code e1079">xsl:original()</div> function call, as
            if it still existed in scope, otherwise it will not be possible for the processor
            to
            determine whether there is a change in posture or sweep.
         </div>
         <div class="para e1080">Whether or not this turns out to be a feasible option in practice remains to be seen.
            After all, there is always a trade-off between usability of a feature and the complexity
            of the rules or the complexity for implementations. If the rules become too complex
            for
            anybody to understand, then there is littly chance it will be used in practice, and
            there will be little incentive for existing implementors to implement such feature,
            let
            alone write specification-tests for it.
         </div>
      </div><a name="Animprovement:typedeterminedpostureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1081" xml:id="type-determined">
         <div class="title e1082">An improvement: type-determined posture</div>
         <div class="para e1083">In the past few sections we have seen that analyzing a function that can return nodes
            can be quite hard and intricate. However, if you know what type your function will
            return, you can use the 
            <div class="code e1084">as</div>-attribute on the 
            <div class="code e1085">xsl:function</div>
            declaration. This will tell the processor that the result must be converted into the
            type defined in that attribute.
         </div>
         <div class="para e1086">In cases where the type is not a node, the processor can go much further with static
            analysis than in situations where the type is not known, because if the type is not
            known, the processor must assume the worst. Suppose you declare the function with
            
            <div class="code e1087">as="xs:integer"</div>, there is no way your function can return nodes. For
            recursion this is a big help, because the processor now knows the result of the
            recursion will not contain nodes. Whether or not there is overlap in the argument
            expression is now less relevant and the posture of any function call, even the recursive
            ones, will always be 
            <div class="emphasis e1088" role="ital">grounded</div>. This makes the
            requirement to match the argument with the result posture go away and simplifies both
            writing and analysis.
         </div>
         <div class="para e1089">Let us look at an example, adopted from an example by Michael Sperberg-McQueen:</div>
         <div class="para e1090">
            
            <div class="figure e1091" xml:id="f-fqgi" xreflabel="Code listing: type determined posture">
               <div class="programlisting e1092" xml:space="preserve">&lt;!-- mimicking what can also be written as
                  string-join(('', reverse(ancestor-or-self::*)/name()), '/') --&gt;
                  &lt;xsl:function name="f:fqgi" as="xs:string"&gt;
                  &lt;xsl:param name="n" as="node()"/&gt;
                  &lt;xsl:choose&gt;
                  &lt;xsl:when test="count($n/ancestor::*) = 0"&gt;
                  &lt;xsl:value-of select="'/' || name($n)"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;
                  &lt;xsl:value-of select="concat(
                  name($n), 
                  '/', 
                  f:fqgi($n/parent::*))"/&gt;
                  &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                  &lt;/xsl:function&gt;
               </div>
            </div>
            
         </div>
         <div class="para e1093">The example takes a node, processes its parents recursively and returns the names
            in
            reverse order (deepest first) separated by slashes. Because the function is declared
            to
            return a 
            <div class="emphasis e1094" role="ital">grounded</div> result, namely
            
            <div class="code e1095">xs:string</div>, there is no need to assume the function can return nodes,
            because it cannot. Through 
            <div class="xref e1096" linkend="table-recursive-calls"></div> we find
            that if the argument posture is 
            <div class="emphasis e1097" role="ital">striding</div> and the
            recursive argument posture is 
            <div class="emphasis e1098" role="ital">climbing</div>, as is the
            case here, the recursive function call is considered 
            <div class="emphasis e1099" role="ital">climbing</div> as well and the function body must then result in either a
            
            <div class="emphasis e1100" role="ital">climbing</div> or 
            <div class="emphasis e1101" role="ital">grounded</div> posture.
         </div>
         <div class="para e1102">In this case, the function call itself does not have to be set to be 
            <div class="emphasis e1103" role="ital">climbing</div>, because we know from the 
            <div class="code e1104">xs:string</div>
            result type that the result will always be 
            <div class="emphasis e1105" role="ital">grounded</div>.
            This simplifies the analysis in that we can now consider the function argument to
            be of
            either 
            <div class="emphasis e1106" role="ital">absorption</div> or 
            <div class="emphasis e1107" role="ital">inspection</div> usage. If the function body as a whole consumes the node
            referenced by 
            <div class="code e1108">$n</div> it will be 
            <div class="emphasis e1109" role="ital">absorption</div> and
            the analysis fails, because a climbing expression with 
            <div class="emphasis e1110" role="ital">absorption</div> usage is not allowed. Because the only other operands on the
            streamed argument are 
            <div class="code e1111">fn:count</div> and 
            <div class="code e1112">fn:name</div>, both having
            inspection operand usage and both being motionless, the result of the analysis as
            a
            whole is that the function is guaranteed streamable, does not consume the streamed
            argument which we can summarize as having usage 
            <div class="emphasis e1113" role="ital">inspection</div>, and while it is direct-recursive we know it can be called
            with any argument, albeit 
            <div class="emphasis e1114" role="ital">climbing</div>, 
            <div class="emphasis e1115" role="ital">striding</div> or 
            <div class="emphasis e1116" role="ital">crawling</div>.
         </div>
         <div class="para e1117">We could expand the type-determined analysis further by including whether or not the
            streamable argument has a cardinality of zero-or-one or has a cardinality of
            zero-or-more. In the case of zero-or-one there is no way that overlapping nodes can
            be
            passed on to the function, which can simplify analysis of a function call with a
            
            <div class="emphasis e1118" role="ital">crawling</div> argument, because it will fail dynamically
            if the 
            <div class="emphasis e1119" role="ital">crawling</div> argument returns more than one node.
            This special-case scenario has meanwhile been tackled and been generalized for any
            situation and cardinality
            <div class="popupBox e1120">
               <div class="popupLabel" onmouseover="$('#d1e2543').show('1000');" onmouseout="$('#d1e2543').hide('1000');">[ footnote ]</div>
               <div id="d1e2543" style="display: none;">
                  <div class="footnote">
                     <div class="para e1121">See the resolution to 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1122" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25185" xlink:show="new" xlink:type="simple">Public XSLT
                           Bug 25185
                        </div> on how crawling posture is now allowed in atomizing
                        contexts.
                     </div>
                  </div>
               </div>
            </div>, which can also by applied to stylesheet function call arguments.
         </div>
      </div><a name="MiscelleneousANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1123" xml:id="miscelleneous">
         <div class="title e1124">Miscelleneous</div><a name="InlinefunctionsandstreamabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1125" xml:id="inline-functions">
            <div class="title e1126">Inline functions and streamability</div>
            <div class="para e1127">Inline functions are a new XPath 3.0 capability
               <div class="popupBox e1128">
                  <div class="popupLabel" onmouseover="$('#d1e2558').show('1000');" onmouseout="$('#d1e2558').hide('1000');">[ footnote ]</div>
                  <div id="d1e2558" style="display: none;">
                     <div class="footnote">
                        <div class="para e1129">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1130" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-inline-func" xlink:show="new" xlink:type="simple">3.1.7 Inline Function Expressions</div> in the XPath 3.0
                           Recommendation.
                        </div>
                     </div>
                  </div>
               </div> that allows you to write an anonymous function inside an XPath
               expression. The definition of inline function expressions prohibits referencing the
               context item, which makes it not directly possible to refer to the context. However,
               the closure of an inline function contains all local variable bindings, which makes
               it possible to refer to a variable outside of the inline function, which itself
               could be bound to a streamed node. The streamability rules for
               
               <div class="code e1131">xsl:variable</div> and 
               <div class="code e1132">xsl:param</div> prohibit referencing a
               streamed node, but one exception is inside a streamable stylesheet function, where
               it is possible to have a parameter bound to a streamed node.
            </div>
            <div class="para e1133">There are two solutions possible. One is to come up with complex rules for inline
               functions referencing the streamed parameter, the other is to simply prohibit using
               a streamed parameter inside an inline function body. This in itself would not be
               consistent with the definition in XPath, which states that all local variable
               bindings are available in the dynamic context of the inline function, which leads
               us
               to a third option: simply disallow inline function expressions within the body of
               a
               streamable stylesheet function.
            </div>
            <div class="para e1134">This third option would be in line with the current streamability rules for inline
               function declarations
               <div class="popupBox e1135">
                  <div class="popupLabel" onmouseover="$('#d1e2575').show('1000');" onmouseout="$('#d1e2575').hide('1000');">[ footnote ]</div>
                  <div id="d1e2575" style="display: none;">
                     <div class="footnote">
                        <div class="para e1136">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1137" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-inline-functions" xlink:show="new" xlink:type="simple">19.8.7.14 Streamability of Inline Function Declarations</div> in the
                           XSLT 3.0 Working Draft.
                        </div>
                     </div>
                  </div>
               </div>, which states that they are, by definition, 
               <div class="emphasis e1138" role="ital">grounded</div> and 
               <div class="emphasis e1139" role="ital">motionless</div>, simply
               because it is not possible to pass a streamed node into the closure of the inline
               function body.
            </div>
         </div><a name="PartialfunctionapplicationandstreamabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1140" xml:id="partial-function-application">
            <div class="title e1141">Partial function application and streamability</div>
            <div class="para e1142">Partial function application is also a new XPath 3.0 capability by writing down a
               question mark as a placeholder for an argument
               <div class="popupBox e1143">
                  <div class="popupLabel" onmouseover="$('#d1e2593').show('1000');" onmouseout="$('#d1e2593').hide('1000');">[ footnote ]</div>
                  <div id="d1e2593" style="display: none;">
                     <div class="footnote">
                        <div class="para e1144">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1145" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#dt-partial-function-application" xlink:show="new" xlink:type="simple">3.1.5 Static Function Calls, definition for Partial Function
                              Application
                           </div> in the XPath 3.0 Recommendation.
                        </div>
                     </div>
                  </div>
               </div>, and apply the other arguments already. The result is a function item
               with less arguments than the original and some arguments already filled in. An
               example is the expression 
               <div class="code e1146">index-of(?, ?, "http://my-collation")</div>, which
               returns a function item that presets the collation argument to
               
               <div class="code e1147">http://my-collation</div>, resulting in a two-argument function that
               always uses the same collation.
            </div>
            <div class="para e1148">The current rules are under the rules on function calls
               <div class="popupBox e1149">
                  <div class="popupLabel" onmouseover="$('#d1e2608').show('1000');" onmouseout="$('#d1e2608').hide('1000');">[ footnote ]</div>
                  <div id="d1e2608" style="display: none;">
                     <div class="footnote">
                        <div class="para e1150">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1151" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-function-calls" xlink:show="new" xlink:type="simple">19.8.7.12 Streamability of Function Calls</div> in the XSLT 3.0
                           Working Draft.
                        </div>
                     </div>
                  </div>
               </div> state that, unless the function is focus-dependent, that the 
               <div class="emphasis e1152" role="ital">general streamability rules</div> apply, which means that it is
               treated as a normal function call, but the placeholder arguments are ignored.
            </div>
            <div class="para e1153">If we take into consideration that binding a streamed node to a variable and
               passing it around is prohibited, a similar rule should be applied to partial
               function application: if the function is a streamable stylesheet function, the
               argument that can take a streamed node, must be the placeholder, or a grounded node
               must be supplied, otherwise it would become a 
               <div class="emphasis e1154" role="ital">roaming</div> and 
               <div class="emphasis e1155" role="ital">free-ranging</div>
               expression. 
            </div>
            <div class="para e1156">In other words, partial function application works with user-defined streamable
               stylesheet functions, as long as you do not try to bind a streaming node from the
               current context to it. You should do that at a later stage, when you actually call
               the function.
            </div>
         </div><a name="NamedfunctionreferencesandstreamabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1157" xml:id="function-references">
            <div class="title e1158">Named function references and streamability</div>
            <div class="para e1159">Named function references are another XPath 3.0 feature
               <div class="popupBox e1160">
                  <div class="popupLabel" onmouseover="$('#d1e2633').show('1000');" onmouseout="$('#d1e2633').hide('1000');">[ footnote ]</div>
                  <div id="d1e2633" style="display: none;">
                     <div class="footnote">
                        <div class="para e1161">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1162" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-named-function-ref" xlink:show="new" xlink:type="simple"> 3.1.6
                              Named Function References
                           </div> in the XPath 3.0 Recommendation.
                        </div>
                     </div>
                  </div>
               </div>: you can create a function item of an existing function by using the
               syntax 
               <div class="code e1163">FunctionName#ArgCount</div>, where 
               <div class="code e1164">ArgCount</div> is a literal
               giving the arity of the function. For instance, 
               <div class="code e1165">count#0</div> will give a
               reference to the zero-argument function of 
               <div class="code e1166">count</div> and
               
               <div class="code e1167">my:filter#3</div> will give a reference to a three-argument function
               
               <div class="code e1168">my:filter</div>. 
            </div>
            <div class="para e1169">The function item returned by such an expression can be called as a normal
               function by applying parentheses and arguments, which in turn will call the function
               you referred to to begin with. In practice, this syntax is useful for binding
               variables to existing named functions.
            </div>
            <div class="para e1170">Creating a named function reference is an atomic action and does not involve
               references to nodes. As a result, a named function reference itself is always
               grounded. There is one exception, if you try to create a reference to a function
               that is focus-dependent. In such cases, just like in previous rules, the result is
               
               <div class="emphasis e1171" role="ital">roaming</div> and 
               <div class="emphasis e1172" role="ital">free-ranging</div>. This is in fact the current rule for streamability of
               named function references in the specification
               <div class="popupBox e1173">
                  <div class="popupLabel" onmouseover="$('#d1e2669').show('1000');" onmouseout="$('#d1e2669').hide('1000');">[ footnote ]</div>
                  <div id="d1e2669" style="display: none;">
                     <div class="footnote">
                        <div class="para e1174">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1175" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-named-function-ref" xlink:show="new" xlink:type="simple">19.8.7.13 Streamability of Named Function References</div> in the XSLT
                           3.0 Working Draft.
                        </div>
                     </div>
                  </div>
               </div>.
            </div>
            <div class="para e1176">Since stylesheet functions by definition cannot be focus-dependent, this exception
               does not apply to named function references that refer to a (streamable) stylesheet
               function.
            </div>
         </div><a name="DynamicfunctioncallsandstreamabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1177" xml:id="dynamic-function-calls">
            <div class="title e1178">Dynamic function calls and streamability</div>
            <div class="para e1179">A dynamic function call, also a new XPath 3.0 feature
               <div class="popupBox e1180">
                  <div class="popupLabel" onmouseover="$('#d1e2683').show('1000');" onmouseout="$('#d1e2683').hide('1000');">[ footnote ]</div>
                  <div id="d1e2683" style="display: none;">
                     <div class="footnote">
                        <div class="para e1181">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1182" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#id-dynamic-function-invocation" xlink:show="new" xlink:type="simple">3.2.2 Dynamic Function Call</div> in the XPath 3.0
                           Recommendation.
                        </div>
                     </div>
                  </div>
               </div>, is a call to a function item that is bound to a variable. Suppose you
               have 
               <div class="code e1183">&lt;xsl:variable name="fref" select=" 'name#1' " /&gt;</div>, which binds
               the one-argument version of the name-function to 
               <div class="code e1184">$fref</div>, then you can
               call that function by adding parentheses and arguments, the same way you would have
               done if the variable were the actual function:
               
               <div class="code e1185">$fref(child::*[1])</div>.
            </div>
            <div class="para e1186">Since it is not possible to know at runtime what function the variable is bound
               to, analysis can only take place once the function is actually called. The current
               rules
               <div class="popupBox e1187">
                  <div class="popupLabel" onmouseover="$('#d1e2701').show('1000');" onmouseout="$('#d1e2701').hide('1000');">[ footnote ]</div>
                  <div id="d1e2701" style="display: none;">
                     <div class="footnote">
                        <div class="para e1188">See section 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1189" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-dynamic-function-calls" xlink:show="new" xlink:type="simple">19.8.7.9 Streamability of Dynamic Function Calls</div> in the XSLT 3.0
                           Working Draft.
                        </div>
                     </div>
                  </div>
               </div> state that all arguments have operand usage 
               <div class="emphasis e1190" role="ital">navigation</div>, which means that you can only call a dynamic function
               when you actually create a 
               <div class="emphasis e1191" role="ital">grounded</div> copy of a
               streamed node. In case you wanted to apply it to a streamed node you are out of
               luck.
            </div>
            <div class="para e1192">The rules make an exception in case the signature of the function item is known,
               in which case 
               <div class="emphasis e1193" role="ital">type-determined usage</div>, as in part
               explained in 
               <div class="xref e1194" linkend="type-determined"></div>, can be used. That means that, if an
               argument is declared as a non-node type, the usage typically becomes 
               <div class="emphasis e1195" role="ital">absorption</div>.
            </div>
         </div>
      </div><a name="StreamabilityofstylesheetfunctionsaccordingtothespecificationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1196" xml:id="specification-status">
         <div class="title e1197">Streamability of stylesheet functions according to the specification</div>
         <div class="para e1198">The current approach taken by the rules in 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1199" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679" xlink:show="new" xlink:type="simple">Bug 25679</div> is a
            pessimistic one. For stylesheet functions to return nodes, they must be 
            <div class="emphasis e1200" role="ital">striding</div> and are allowed to be either 
            <div class="emphasis e1201" role="ital">motionless</div> or 
            <div class="emphasis e1202" role="ital">consuming</div>. As a further
            limitation, which actually follows from forcing the 
            <div class="emphasis e1203" role="ital">striding</div> posture on function bodies, is that the argument to the
            function must itself also be 
            <div class="emphasis e1204" role="ital">striding</div>. In fact, it is
            not possible, by the current definition, to have a streamed node with 
            <div class="emphasis e1205" role="ital">crawling</div> or 
            <div class="emphasis e1206" role="ital">climbing</div> posture
            act as an argument to a streamable stylesheet function.
         </div>
         <div class="para e1207">By limiting the result posture of the stylesheet function to one allowed posture,
            it
            is easier to write rules for both analyzable and non-analyzable stylesheet functions,
            see 
            <div class="xref e1208" linkend="analyzable"></div>. However, because the bug entry is quite fresh and the
            discussion is still ongoing, there is little conclusive I can tell about the rules
            that
            will eventually make it into the next public version of the specification
            <div class="popupBox e1209">
               <div class="popupLabel" onmouseover="$('#d1e2758').show('1000');" onmouseout="$('#d1e2758').hide('1000');">[ footnote ]</div>
               <div id="d1e2758" style="display: none;">
                  <div class="footnote">
                     <div class="para e1210">The next version will probably be a 
                        <div class="emphasis e1211" role="ital">Candidate
                           Recommendation
                        </div>, considering that the current status is 
                        <div class="emphasis e1212" role="ital">Last Call Working Draft</div>, meaning that the
                        specification is ready for implementors and only bugs found that come from
                        implementation issues will be fixed. No new features will be added.
                     </div>
                  </div>
               </div>
            </div>. For instance, in 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1213" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679#c1" xlink:show="new" xlink:type="simple">Comment#1</div>
            of the same public bug entry I have proposed some of the rules from 
            <div class="xref e1214" linkend="posture-sweep-table"></div>. Whether or not any or all of these suggestions will
            make it into the specification will remain to be seen.
         </div>
         <div class="para e1215">Even if the specification will only allow relatively pessimistic stylesheet functions,
            vendors are still allowed to use wider rules on streamability. In the case of functions,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1216" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple">Exselt</div> will allow any function that is streamable, as explained
            in the previous section, by using an optimistic operational mode at user option.
         </div><a name="TheattributeonANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1217">
            <div class="title e1218">The 
               <div class="code e1219">streamable</div> attribute on 
               <div class="code e1220">xsl:function</div>
            </div>
            <div class="para e1221">In none of the previous sections in this paper have I mentioned the
               
               <div class="code e1222">streamable</div> attribute on an 
               <div class="code e1223">xsl:function</div> declaration.
               Since most of the paper discussed streamability of a stylesheet function in the
               context of the function call, whether or not a function is streamable then depends
               on its implementation and there is no need for the processor to know beforehand what
               functions to analyze and what not.
            </div>
            <div class="para e1224">The streamability rules in the specification are made such that the processor must
               statically determine whether or not a function declaration is streamable or not.
               Since it is likely that any given stylesheet will have both streamable and
               non-streamable stylesheet functions, it is necessary to tell the processor which are
               and which are not streamable. For that, the 
               <div class="code e1225">xsl:function</div> declaration
               gets a new attribute, similar to the attribute of 
               <div class="code e1226">xsl:accumulator</div> and
               
               <div class="code e1227">xsl:mode</div>, which determines whether or not a function should be
               analyzed for streamability.
            </div>
            <div class="para e1228">The attribute takes a value of 
               <div class="code e1229">yes</div> or 
               <div class="code e1230">no</div>. If the value
               is 
               <div class="code e1231">yes</div>, then the function must be 
               <div class="emphasis e1232" role="ital">guaranteed
                  streamable
               </div> and the function can be called with a streamable node as
               an argument.
            </div>
            <div class="para e1233">I think that such an attribute is not necessary if we take the approach in this
               paper and analyze the entire function only upon the actual function call. If that
               function call is inside a streamable context and a streamable node is passed as an
               argument, the body of the function is analyzed with the context posture of the
               streamable argument set as the posture of the streamable parameter reference.
            </div>
         </div>
      </div><a name="StatusofcurrentprocessorswithrespecttostreamablestylesheetfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1234" xml:id="status-processors">
         <div class="title e1235">Status of current processors with respect to streamable stylesheet functions</div>
         <div class="para e1236">Since streamable stylesheet functions are a relative recent addition to the
            specification and lots of it is not yet publicly available, there are currently no
            processors available that fully support streamable stylesheet functions.
         </div>
         <div class="para e1237">At the time of this writing, of the two streaming processors that I know of, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1238" xlink:actuate="onRequest" xlink:href="http://exselt.net" xlink:show="new" xlink:type="simple">Exselt</div> and 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1239" xlink:actuate="onRequest" xlink:href="http://saxonica.com" xlink:show="new" xlink:type="simple">Saxon</div>, the former currently has a full streamability analysis for all
            constructs but a limited ability to analyze stylesheet functions for streamability.
            However, the available set of tests is still growing and the rules on streamability
            may
            change between now and the actual presentation of this paper, or even afterwards,
            since
            the specification is not final yet and work on streamable stylesheet functions may
            change the current rules. Apart from analyzing a function for streamability, Exselt
            chooses an optimistic streaming approach: if you write your stylesheet in a correct
            way
            with forward expressions only, your stylesheet will process streaming input in a
            streamable way.
         </div>
         <div class="para e1240">For Saxon, I do not know the actual current status on streamable stylesheet functions,
            but I do know that they plan to do it in the not-so-far future.
         </div>
         <div class="para e1241">If you are interested in streaming, or more specifically in streamable stylesheet
            functions, keep an eye out on the website of Exselt and Saxon as it is likely that
            in
            the near future, both processors will support this feature.
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1242" xml:id="conclusion">
         <div class="title e1243">Conclusion</div>
         <div class="para e1244">The previous sections have shown that writing streamable stylesheet functions is not
            that hard, as long as you do not require recursion, or want to write overridable
            non-final functions. But if you do require recursion, the simplest rule to remember
            is
            
            <div class="emphasis e1245" role="ital">same posture in, same posture out</div>. As long as you
            stick to that rule, and forget about the exceptional cases, you are in safe streaming
            waters.
         </div>
         <div class="para e1246">We have also seen that the current resolution in the specification taken to allow
            streamable stylesheet functions is far more limiting, allowing only a posture of
            
            <div class="emphasis e1247" role="ital">striding</div> for the input arguments and in the case of
            recursive functions or non-final functions, always concludes that a call to such a
            function is 
            <div class="emphasis e1248" role="ital">consuming</div>, even if it is not. This
            conservative approach has a valid reason, though: it tries to keep things simple and
            the
            rules understandable and implementable. But even with this limitations in mind, it
            gives
            stylesheet authors quite a wide range of possibilities to write streamable stylesheet
            functions.
         </div>
         <div class="para e1249">This paper has shown how a relative small change to the specification opens up the
            way
            for stylesheet and library package writers to write streamable stylesheet functions,
            which can be used in both streamable and non-streamable scenarios alike
            <div class="popupBox e1250">
               <div class="popupLabel" onmouseover="$('#d1e2856').show('1000');" onmouseout="$('#d1e2856').hide('1000');">[ footnote ]</div>
               <div id="d1e2856" style="display: none;">
                  <div class="footnote">
                     <div class="para e1251">Any streamable construct will work exactly the same in a non-streaming
                        scenario. Functions or modes written with streaming in mind can be used with
                        both streaming and non-streaming input without alterations.
                     </div>
                  </div>
               </div>
            </div>. This change was an important and vital one and has brought us very close to
            making the streamability rules as mature as they can be and ready for widespread use
            in
            stylesheets and packages. Hopefully this paper has given potential library writers
            a
            strong hint that they should take the extra step to write their library packages with
            streamability in mind to be useful for both the streaming and non-streaming
            markets.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e1252">
         <div class="title e1253">Bibliography</div>
         <div class="bibliomixed e1254" xml:id="Braaksma13" xreflabel="Braaksma 2013">
            Braaksma, Abel. 
            <div class="quote e1255">Efficient XML processing with XSLT 3.0 and higher order functions</div>: pp 23-40.
            Presented at 
            <div class="emphasis e1256" role="ital">XML Prague 2013, a conference on markup languages and data on the web</div>, Prague, Czechia, Feb 8-10, 2013. 
            In XML Prague Proceedings 2013.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1257" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2013/files/xmlprague-2013-proceedings.pdf" xlink:show="new" xlink:type="simple">http://archive.xmlprague.cz/2013/files/xmlprague-2013-proceedings.pdf</div>.
            Web.            
            
         </div>
         <div class="bibliomixed e1258" xml:id="Braaksma14a" xreflabel="Braaksma 2014a">
            Braaksma, Abel. 
            
            <div class="quote e1259">Streaming for the masses, an introduction to streaming with XSLT</div>: pp 29-80.
            Presented at 
            <div class="emphasis e1260" role="ital">XML Prague 2014, a conference on markup languages and data on the web</div>, Prague, Czechia, Feb 14-16, 2014. 
            In XML Prague Proceedings 2014.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1261" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf" xlink:show="new" xlink:type="simple">http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1262" xml:id="Braaksma14b" xreflabel="Braaksma 2014b">Braaksma, Abel. 
            
            <div class="quote e1263">Streaming Design Patterns or: How I Learned to Stop Worrying and Love the
               Stream
            </div>: pp 24-53.
            Presented at 
            <div class="emphasis e1264" role="ital">XML Prague 2014, a conference on markup languages and data on the web</div>, Prague, Czechia, Feb 14-16, 2014. 
            In XML Prague Proceedings 2014.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1265" xlink:actuate="onRequest" xlink:href="http://xmllondon.com/2014/xmllondon-2014-proceedings.pdf" xlink:show="new" xlink:type="simple">http://xmllondon.com/2014/xmllondon-2014-proceedings.pdf</div>.
            Web. doi:
            <div class="biblioid doi e1266">10.14337/xmllondon14.braaksma01</div>
            
         </div>
         <div class="bibliomixed e1267" xml:id="Grust13" xreflabel="Grust 2013">
            Grust, Torsten and Ulrich, Alexander.
            
            <div class="quote e1268">First-Class Functions for First-Order Database Engines</div>
            Presented at 
            <div class="emphasis e1269" role="ital">International Symposium on Database Programming Languages</div>.
            In Proceedings of the 14th International Symposium on Database Programming Languages
            (DBPL 2013), Trento, Italy.
            arXiv:1308.0158: 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1270" xlink:actuate="onRequest" xlink:href="http://arxiv.org/pdf/1308.0158v1" xlink:show="new" xlink:type="simple">http://arxiv.org/pdf/1308.0158v1</div>.
            
         </div>
         <div class="bibliomixed e1271" xml:id="FuncOpRec" xreflabel="XPath and XQuery F&amp;O 3.0">
            Kay, Michael.
            
            <div class="quote e1272">XPath and XQuery Functions and Operators 3.0 Recommendation</div>
            8 April 2014. W3 Consortium. W3C Recommendation.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1273" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-functions-30/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1274" xml:id="Gerstbach06" xreflabel="Gerstbach 2006">
            Gerstbach, Peter.
            
            <div class="quote e1275">Generating Structured Documents to Create Reports by Integrating Data from CMS/DMS
               and EAI Systems
            </div>: pp 27-28.
            Master thesis. At: Softwaretechnik und Interaktive Systeme der Technischen Universit¨at
            Wien. May 2006.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1276" xlink:actuate="onRequest" xlink:href="http://www.gerstbach.at/2006/thesis/" xlink:show="new" xlink:type="simple">http://www.gerstbach.at/2006/thesis/</div>. Web.
            
         </div>
         <div class="bibliomixed e1277" xml:id="Kay08" xreflabel="Kay 2008">
            Kay, Michael.
            
            <div class="quote e1278">XSLT 2.0 and XPath 2.0 Programmer's Reference</div>
            2nd edition, 5 May 2008: pp 251+. Published by O'Reilly Media. ISBN: 0470192747. Print.
            
         </div>
         <div class="bibliomixed e1279" xml:id="Lenz05" xreflabel="Lenz 2005">
            Lenz, Evan.
            
            <div class="quote e1280">XSLT 1.0 Pocket Reference (Pocket Reference)</div>.
            1st edition, 19 August 2005: pp 23-40. Published by O'Reilly Media. ISBN: 0596100086.
            
            Chapter 3 (pages 23-40) is available online: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1281" xlink:actuate="onRequest" xlink:href="http://lenzconsulting.com/how-xslt-works/" xlink:show="new" xlink:type="simple">http://lenzconsulting.com/how-xslt-works/</div>.
            Print.
            
         </div>
         <div class="bibliomixed e1282" xml:id="Mangano05" xreflabel="Mangano 2005">
            Mangano, San.
            
            <div class="quote e1283">XSLT Cookbook, 2nd Edition, Solutions and Examples for XML and XSLT Developers</div>
            2nd edition, 21 December 2005: pp 686-732. Published by O'Reilly Media. ISBN: 0596009747.
            Print.            
            
         </div>
         <div class="bibliomixed e1284" xml:id="Novatchev01" xreflabel="Novatchev 2001">
            Novatchev, Dimitre.
            
            <div class="quote e1285">The Functional Programming Language XSLT — A proof through examples</div>
            November 2001.
            Seen at: 
            <div class="emphasis e1286" role="ital">Sommer Semester 2010 course material University of Magdeburg 2010</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1287" xlink:actuate="onRequest" xlink:href="http://edu.cs.uni-magdeburg.de/EC/lehre/sommersemester-2010/funktionale-programmierung/uebungen/gruppe-2/aufgabenblatt-12/XSLTasFP.pdf" xlink:show="new" xlink:type="simple">http://edu.cs.uni-magdeburg.de/EC/lehre/sommersemester-2010/funktionale-programmierung/uebungen/gruppe-2/aufgabenblatt-12/XSLTasFP.pdf</div>.
            Online reference: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1288" xlink:actuate="onRequest" xlink:href="http://fxsl.sourceforge.net/articles/FuncProg/Functional%20Programming.html" xlink:show="new" xlink:type="simple">
               http://fxsl.sourceforge.net/articles/FuncProg/Functional%20Programming.html
            </div>. Print.
            
         </div>
         <div class="bibliomixed e1289" xml:id="Tennison01" xreflabel="Tennison 2001">
            Tennison, Jeni.
            
            <div class="quote e1290">Rescuing XSLT from Niche Status.</div>.
            17 February 2001.
            MulberryTech XSL Mailing List Archive. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1291" xlink:actuate="onRequest" xlink:href="http://www.biglist.com/lists/xsl-list/archives/200102/msg01143.html" xlink:show="new" xlink:type="simple">
               http://www.biglist.com/lists/xsl-list/archives/200102/msg01143.html
            </div>. Web.
            
         </div>
         <div class="bibliomixed e1292" xml:id="W3cBugzilla" xreflabel="W3C BugZilla">
            Various contributors.
            
            <div class="quote e1293">Bugzilla - Public W3C Bug / Issue tracking system</div>
            1997 - 2014. W3 Consortium.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1294" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/" xlink:show="new" xlink:type="simple">https://www.w3.org/Bugs/Public/</div>. 
            Web.
            
         </div>
         <div class="bibliomixed e1295" xml:id="Welker08" xreflabel="Welker 2008">
            Welker, Eddie.
            
            <div class="quote e1296">Advantages of push-style XSLT over pull-style</div>
            25 November 2008. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1297" xlink:actuate="onRequest" xlink:href="http://www.eddiewelker.com/2008/11/25/push-style-xslt-vs-pull-style/" xlink:show="new" xlink:type="simple">http://www.eddiewelker.com/2008/11/25/push-style-xslt-vs-pull-style/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1298" xml:id="XdmRec" xreflabel="XQuery and XPath Data Model 3.0">
            Walsh, Norman; Berglund, Anders; Snelson, John.
            
            <div class="quote e1299">XQuery and XPath Data Model 3.0 Recommendation</div>
            8 April 2014. W3 Consortium. W3C Recommendation.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1300" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel-30/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1301" xml:id="XPathRec" xreflabel="XPath 3.0">
            Robie, Jonathan; Chamberlin, Don; Dyck, Michael; Snelson, John.
            
            <div class="quote e1302">XML Path Language (XPath) 3.0 Recommendation</div>
            8 April 2014. W3 Consortium. W3C Recommendation.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1303" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-30/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1304" xml:id="XProc" xreflabel="XProc">
            Walsh, Norman; Milowski, Alex; Thompson, Henry S.
            
            <div class="quote e1305">XProc: An XML Pipeline Language</div>
            11 May 2010. W3 Consortium. W3C Recommendation.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1306" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xproc/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xproc/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1307" xml:id="Xslt30Latest" xreflabel="XSLT Latest Version">
            Kay, Michael.
            
            <div class="quote e1308">XSL Transformations (XSLT) Version 3.0, Latest Version</div>
            Undated. W3 Consortium. W3C Working Draft / Last Call Working Draft / Candidate Recommendation
            / Proposed Recommendation / Recommendation.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1309" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-30/</div>.
            Web.
            
         </div>
         <div class="bibliomixed e1310" xml:id="XsltLastCall" xreflabel="XSLT Last Call WD">
            Kay, Michael.
            
            <div class="quote e1311">XSL Transformations (XSLT) Version 3.0 W3C Last Call Working Draft</div>
            12 December 2013. W3 Consortium. Last Call Working Draft.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1312" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2013/WD-xslt-30-20130201/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2013/WD-xslt-30-20130201/</div>.
            Web.
            
         </div>
      </div>
   </div>
</div>