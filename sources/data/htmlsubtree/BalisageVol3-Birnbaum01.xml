<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#AnXMLuserstepsintoandescapesfromXPathquicksandANCHOR" name="AnXMLuserstepsintoandescapesfromXPathquicksandTOC">An XML user steps into, and escapes from, XPath quicksand</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThecorpusANCHOR" name="ThecorpusTOC">The corpus</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThetaskANCHOR" name="ThetaskTOC">The task</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheproblemANCHOR" name="TheproblemTOC">The problem</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AnXPathsolutionANCHOR" name="AnXPathsolutionTOC">An XPath solution</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ArangeindexsolutionANCHOR" name="ArangeindexsolutionTOC">A range index solution</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TimetestresultsANCHOR" name="TimetestresultsTOC">Time test results</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IsitXML?ANCHOR" name="IsitXML?TOC">Is it XML?</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AddendumANCHOR" name="AddendumTOC">Addendum</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#WorkscitedANCHOR" name="WorkscitedTOC">Works cited</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">attribute</div>
         <div class="singletermTERMS">Addendum</div>
         <div class="singletermTERMS">all</div>
         <div class="singletermTERMS">Alanus ab insulis</div>
         <div class="singletermTERMS">Anticlaudianus,</div>
         <div class="singletermTERMS">Acl.8.254:</div>
         <div class="singletermTERMS">Acl.9.283:</div>
         <div class="singletermTERMS">Acl.9.331:</div>
         <div class="singletermTERMS">Acl.9.384:</div>
         <div class="singletermTERMS">August 11 - 14, 2009</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2009</div>
         <div class="singletermTERMS">Birnbaum</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">child</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">descendant-or-self</div>
         <div class="singletermTERMS">djbpitt@pitt.edu</div>
         <div class="singletermTERMS">djbpitt@pitt.edu</div>
         <div class="singletermTERMS">David</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">eXist</div>
         <div class="singletermTERMS">eXist Lucene</div>
         <div class="singletermTERMS">entire</div>
         <div class="singletermTERMS">eXist</div>
         <div class="singletermTERMS">efficiency</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">following</div>
         <div class="singletermTERMS">following-sibling</div>
         <div class="singletermTERMS">following::word</div>
         <div class="singletermTERMS">for</div>
         <div class="singletermTERMS">for $j in (1 to 3) return $i/following::word[$j]</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">indexing</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">J.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">let</div>
         <div class="singletermTERMS">Lucene</div>
         <div class="singletermTERMS">Long axes:</div>
         <div class="singletermTERMS">Long axes</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">Markup Languages: Theory and Practice</div>
         <div class="singletermTERMS">Mean</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">optimization</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">pugna</div>
         <div class="singletermTERMS">preceding</div>
         <div class="singletermTERMS">parent</div>
         <div class="singletermTERMS">position()</div>
         <div class="singletermTERMS">pugna</div>
         <div class="singletermTERMS">pugna,</div>
         <div class="singletermTERMS">Pugna</div>
         <div class="singletermTERMS">Professor and Chair</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">reverse()</div>
         <div class="singletermTERMS">Ratio 1</div>
         <div class="singletermTERMS">Ratio 2</div>
         <div class="singletermTERMS">Ratio 3</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">sed</div>
         <div class="singletermTERMS">shanzer@illinois.edu</div>
         <div class="singletermTERMS">Sibling axes:</div>
         <div class="singletermTERMS">Sibling axes</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">Test no.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XPath</div>
         <div class="singletermTERMS">XQuery</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="AnXMLuserstepsintoandescapesfromXPathquicksandANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">An XML user steps into, and escapes from, XPath quicksand</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2009</div>
            <div class="confdates e5">August 11 - 14, 2009</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Until recently, the admirable and impressive 
               <div class="emphasis e8" role="ital">eXist</div> XML database sometimes failed to optimize queries with
               numerical predicates. For example, a search for 
               <div class="emphasis e9" role="ital">$i/following::word[1]</div> would retrieve 
               <div class="emphasis e10" role="ital">all</div>
               
               <div class="code e11">&lt;word&gt;</div> elements on the 
               <div class="code e12">following</div> axis and
               only then apply the predicate as a filter to return only the first of them. This was
               enormously inefficient when 
               <div class="code e13">$i</div> pointed to a node near the beginning of
               a very large document, with many thousands of following
               
               <div class="code e14">&lt;word&gt;</div> elements. As an end-user without the Java
               programming skills to write optimization code for 
               <div class="emphasis e15" role="ital">eXist</div>, the author describes two types of optimization in the more
               familiar XML, XPath, and XQuery, which reduced the number of nodes that needed to
               be
               accessed and thus improved response time substantially.
            </div>
            <div class="para e16">A subsequent optimization introduced by the 
               <div class="emphasis e17" role="ital">eXist</div>
               developers into the 
               <div class="emphasis e18" role="ital">eXist</div> code base is described in
               an addendum to this paper. Although this revision partially obviates the need for
               the work-arounds developed earlier, the analysis of the efficiency of various XPath
               approaches to a single problem continues to provide valuable general lessons about
               XPath.
            </div>
         </div>
         <div class="author e19">
            <div class="personname e20">
               <div class="firstname e21">David</div>
               <div class="othername e22">J.</div>
               <div class="surname e23">Birnbaum</div>
            </div>
            <div class="personblurb e24">
               <div class="para e25">David J. Birnbaum is Professor and Chair of the Department of Slavic Languages
                  and Literatures at the University of Pittsburgh. He has been involved in the
                  study of electronic text technology since the mid-1980s, has delivered
                  presentations at a variety of electronic text technology conferences, and has
                  served on the board of the Association for Computers and the Humanities, the
                  editorial board of 
                  <div class="emphasis e26" role="ital">Markup Languages: Theory and
                     Practice
                  </div>, and the Text Encoding Initiative Council. Much of his
                  electronic text work intersects with his research in medieval Slavic manuscript
                  studies, but he also often writes about issues in the philosophy of
                  markup.
               </div>
            </div>
            <div class="affiliation e27">
               <div class="jobtitle e28">Professor and Chair</div>
               <div class="orgname e29">Department of Slavic Languages and Literatures University of
                  Pittsburgh
               </div>
            </div>
            <div class="email e30">djbpitt@pitt.edu</div>
         </div>
         <div class="legalnotice e31">
            <div class="para e32">Copyright © 2009 by David J. Birnbaum. All rights reserved. Used by
               permission.
            </div>
         </div>
         <div class="keywordset e33" role="author">
            <div class="keyword e34">XPath</div>
            <div class="keyword e35">XQuery</div>
            <div class="keyword e36">eXist</div>
            <div class="keyword e37">optimization</div>
            <div class="keyword e38">efficiency</div>
            <div class="keyword e39">indexing</div>
         </div>
      </div><a name="ThecorpusANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e40">
         <div class="title e41">The corpus</div>
         <div class="para e42">Alain de Lille’s (
            <div class="emphasis e43" role="ital">Alanus ab insulis</div>)
            allegorical-philosophical epic, the 
            <div class="emphasis e44" role="ital">Anticlaudianus,</div> is
            a poem divided into nine books with a brief verse prologue and an equally brief prose
            pre-prologue. The text was published by Robert Bossuat in 1955 (
            <div class="emphasis e45" role="ital">Anticlaudianus / Alain de Lille: texte critique avec une introduction et des
               tables
            </div> publié par R. Bossuat [Paris : J. Vrin, 1955]), cleaned up in 2009
            by Danuta Shanzer (University of Illinois at Urbana-Champaign, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e46" xlink:actuate="onRequest" xlink:href="mailto:shanzer@illinois.edu" xlink:show="new" xlink:type="simple">shanzer@illinois.edu</div>) as a Dumbarton Oaks Medieval Library Latin Series Work
            In Progress, and converted to XML and published as a queriable concordance by David
            J.
            Birnbaum (University of Pittsburgh, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e47" xlink:actuate="onRequest" xlink:href="mailto:djbpitt@pitt.edu" xlink:show="new" xlink:type="simple">djbpitt@pitt.edu</div>). When this report was
            last edited in August 2009, the concordance was freely accessible at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e48" xlink:actuate="onRequest" xlink:href="http://clover.slavic.pitt.edu:8081/exist/acl/search.html" xlink:show="new" xlink:type="simple">http://clover.slavic.pitt.edu:8081/exist/acl/search.html</div>; it will eventually
            move to a different stable freely accessible address, which has not yet been determined,
            but which should be discoverable through search engines.
         </div>
         <div class="para e49">The corpus consists of a single XML file subdivided into
            
            <div class="code e50">&lt;book&gt;</div> elements (prose introduction, verse introduction,
            nine principal chapters). Each 
            <div class="code e51">&lt;book&gt;</div> is divided into
            
            <div class="code e52">&lt;line&gt;</div> elements (4344 
            <div class="code e53">&lt;line&gt;</div>
            elements in the nine principal 
            <div class="code e54">&lt;book&gt;</div> elements, for an
            average of 482.7 
            <div class="code e55">&lt;line&gt;</div> elements per
            
            <div class="code e56">&lt;book&gt;</div> element), and each
            
            <div class="code e57">&lt;line&gt;</div> is divided into 
            <div class="code e58">&lt;word&gt;</div>
            elements (27222 
            <div class="code e59">&lt;word&gt;</div> elements in the nine principal books,
            or approximately 6.27 
            <div class="code e60">&lt;word&gt;</div> elements per
            
            <div class="code e61">&lt;line&gt;</div> element; the 
            <div class="code e62">&lt;word&gt;</div>
            counts per 
            <div class="code e63">&lt;line&gt;</div> range from a low of 4 to a high of 10). For
            example, Book 2 begins:
         </div>
         <div class="programlisting e64" xml:space="preserve">&lt;book n="2"&gt;
            &lt;line&gt;
            &lt;word&gt;Regia&lt;/word&gt;
            &lt;word&gt;tota&lt;/word&gt;
            &lt;word&gt;silet;&lt;/word&gt;
            &lt;word&gt;expirat&lt;/word&gt;
            &lt;word&gt;murmur&lt;/word&gt;
            &lt;word&gt;in&lt;/word&gt;
            &lt;word&gt;altum,&lt;/word&gt;
            &lt;/line&gt;
            &lt;line&gt;
            &lt;word&gt;cum&lt;/word&gt;
            &lt;word&gt;visu&lt;/word&gt;
            &lt;word&gt;placidos&lt;/word&gt;
            &lt;word&gt;delegat&lt;/word&gt;
            &lt;word&gt;curia&lt;/word&gt;
            &lt;word&gt;vultus,&lt;/word&gt;
            &lt;/line&gt;
            &lt;!-- more lines --&gt;
            &lt;/book&gt;
         </div>
         <div class="para e65">Because scholars are likely to be interested more in the contents of the nine
            principal books than in the contents of the prose and verse introductions, the counts
            and calculations below omit the latter. They are, nonetheless, relevant in certain
            situations, such as when a query consults all 
            <div class="code e66">&lt;word&gt;</div> elements
            in the document, including those in the introductions. The prose introduction contains
            477 
            <div class="code e67">&lt;word&gt;</div> elements and the verse introduction 50.
         </div>
      </div><a name="ThetaskANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e68">
         <div class="title e69">The task</div>
         <div class="para e70">The goal of the electronic concordance project is to enable users to search for words
            and generate a keyword-in-context (KWIC) report on the fly. The system was originally
            implemented using the 
            <div class="emphasis e71" role="ital">eXist</div> XML database (
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e72" xlink:actuate="onRequest" xlink:href="http://www.exist-db.org" xlink:show="new" xlink:type="simple">http://www.exist-db.org</div>), version 1.3.0dev-rev:8710-20090308. Version 1.3 of
            
            <div class="emphasis e73" role="ital">eXist</div>, still in beta at the time this report was
            last revised, is the first to introduce a 
            <div class="emphasis e74" role="ital">Lucene</div>-based
            index, which is intended eventually to replace the original proprietary full-text
            index,
            and the present concordance is indexed and accessed using the 
            <div class="emphasis e75" role="ital">Lucene</div> index. When the user enters a query string and launches a search,
            the system retrieves all hits and returns them with several preceding and following
            words (three each by default, but the user can adjust this number). Line breaks in
            the
            original are rendered as slashes in the KWIC output (this part of the code has been
            omitted from most of this report in the interest of legibility, except when it is
            the
            object of optimization). For example, a search for 
            <div class="code e76">pugna</div> (Latin for
            ‘fight’), which occurs four times in the corpus, returns:
         </div>
         <div class="itemizedlist e77">
            <div class="listitem e78">
               <div class="para e79">
                  <div class="emphasis e80" role="bold">Acl.8.254: </div>Martis amore / succensi, 
                  <div class="emphasis e81" role="ital">pugna</div> cupiunt incidere vitam. / 
               </div>
            </div>
            <div class="listitem e82">
               <div class="para e83">
                  <div class="emphasis e84" role="bold">Acl.9.283: </div>Luxum / Sobrietas, sed 
                  <div class="emphasis e85" role="ital">pugna</div> favet Virtutibus, harum / 
               </div>
            </div>
            <div class="listitem e86">
               <div class="para e87">
                  <div class="emphasis e88" role="bold">Acl.9.331: </div>fraudesque recurrit. / degeneri
                  
                  <div class="emphasis e89" role="ital">pugna,</div> servili Marte, dolosa / 
               </div>
            </div>
            <div class="listitem e90">
               <div class="para e91">
                  <div class="emphasis e92" role="bold">Acl.9.384: </div>indignata sub umbras. / 
                  <div class="emphasis e93" role="ital">Pugna</div> cadit, cedit iuveni
               </div>
            </div>
         </div>
         <div class="para e94">The XPath 
            <div class="code e95">preceding</div> and 
            <div class="code e96">following</div> axes are ideally suited to
            this type of project, since they ignore the 
            <div class="code e97">&lt;line&gt;</div> element
            boundaries and treat adjacent 
            <div class="code e98">&lt;word&gt;</div> elements identically
            irrespective of whether they fall in the same 
            <div class="code e99">&lt;line&gt;</div> element
            as the target word or in preceding or following 
            <div class="code e100">&lt;line&gt;</div>
            elements. For example, the system can retrieve the three
            
            <div class="code e101">&lt;word&gt;</div> elements that precede the target
            
            <div class="code e102">&lt;word&gt;</div> element with the following XQuery (assume that
            
            <div class="code e103">$i</div> represents the target 
            <div class="code e104">&lt;word&gt;</div>
            element):
         </div>
         <div class="programlisting e105" xml:space="preserve">for $j in reverse(1 to 3) return $i/preceding::word[$j]</div>
         <div class="para e106">This query returns the third, second, and first 
            <div class="code e107">&lt;word&gt;</div>
            elements before the target 
            <div class="code e108">&lt;word&gt;</div> element, in the specified
            order. An analogous statement can retrieve the three 
            <div class="code e109">&lt;word&gt;</div>
            elements that follow the hit, thus providing the rest of the context. Because queries
            along the long (
            <div class="code e110">preceding</div> and 
            <div class="code e111">following</div>) axes make no
            distinction between preceding and following 
            <div class="code e112">&lt;word&gt;</div> elements
            within the same 
            <div class="code e113">&lt;line&gt;</div> element and those that require
            crossing a 
            <div class="code e114">&lt;line&gt;</div> element boundary, the resulting XQuery code
            is lucid and clean, making it extremely easy to read, write, and maintain.
         </div>
      </div><a name="TheproblemANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e115">
         <div class="title e116">The problem</div>
         <div class="para e117">The preceding strategy retrieves the correct results, and does so with elegant code,
            but initially it proved unusable in practice for reasons of efficiency, even with
            appropriately configured 
            <div class="emphasis e118" role="ital">eXist Lucene</div> and range indexes
            (“
            <div class="xref e119" linkend="Configuring"></div>,” “
            <div class="xref e120" linkend="Lucene"></div>,” “
            <div class="xref e121" linkend="Tuning"></div>”). Until a recent revision in the 
            <div class="emphasis e122" role="ital">eXist</div> code base (see the 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e123" linkend="Addendum" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">Addendum</div>,
            below), XPath expressions that addressed the long axes were inefficient because
            
            <div class="emphasis e124" role="ital">eXist</div> retrieved the 
            <div class="emphasis e125" role="ital">entire</div> set of nodes on the specified axis before looking at the
            predicate. For example, in the worst case a hit would fall at the beginning of the
            first
            
            <div class="code e126">&lt;line&gt;</div> in the first 
            <div class="code e127">&lt;book&gt;</div>
            element, which meant that in order to find the three immediately following
            
            <div class="code e128">&lt;word&gt;</div> elements by looking on the 
            <div class="code e129">following</div>
            axis 
            <div class="emphasis e130" role="ital">eXist</div> would first retrieve as many as 27221
            following 
            <div class="code e131">&lt;word&gt;</div> elements and only then apply a numerical
            predicate to filter the returned result. Since the context includes both preceding
            and
            following 
            <div class="code e132">&lt;word&gt;</div> elements (that is, it requires accessing the
            
            <div class="code e133">preceding</div> axis in the former case and the 
            <div class="code e134">following</div> axis
            in the latter), hits that have fewer preceding 
            <div class="code e135">&lt;word&gt;</div>
            elements have more following ones, and vice versa, which means that all hits require
            sets of retrievals that span the entire document. The overhead was not a significant
            problem with queries that retrieved a mere handful of hits, but those that retrieved
            as
            few as two hundred hits could take several minutes to return, and sometimes they failed
            to return entirely because they generated Java heap overflow errors (which could have
            been evaded by increasing the heap size, but that would not have provided a solution
            to
            the efficiency problem).
         </div>
         <div class="para e136">This problem is not a unique or inherent property of the long axes. Rather, it is
            a
            property of the number of nodes on which the predicate operates. For example, in a
            flattened tree (imagine transforming the document to one where all
            
            <div class="code e137">&lt;word&gt;</div> elements are directly under the root and line and
            book boundaries are encoded as empty milestone tags), a hit at the beginning of the
            document that queried the 
            <div class="code e138">following-sibling</div> axis, rather than the
            
            <div class="code e139">following</div> axis, would nonetheless retrieve tens of thousands of
            unwanted 
            <div class="code e140">&lt;word&gt;</div> elements before applying the predicates to
            select the mere three that were actually needed. For this reason, although the problem
            may initially appear to be an overlap issue in that in its original form it crosses
            the
            boundaries of 
            <div class="code e141">&lt;line&gt;</div> elements, the flattening thought
            experiment reveals that it is actually an optimization problem that is independent
            of
            both the specific axes involved and the depth of the nesting. If, for example, 
            <div class="emphasis e142" role="ital">eXist</div> were to look first at the predicate and then access
            only the necessary elements on the specified axis, instead of first retrieving all
            elements on that axis and only then consulting the predicate and discarding the unwanted
            ones (in the present case, all but one), processing would not be suffocated by
            unnecessary retrieval irrespective of whether the query needed to cross a
            
            <div class="code e143">&lt;line&gt;</div> element boundary.
         </div>
         <div class="para e144">As is discussed in the 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e145" linkend="Addendum" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">Addendum</div>, below, 
            <div class="emphasis e146" role="ital">eXist</div> has since implemented this type of optimization, but
            the problem nonetheless continues to merit consideration. Among other things, the
            issue
            was never about 
            <div class="emphasis e147" role="ital">eXist</div>, since were that the case, an
            obvious solution would have been to use an alternative platform that provided the
            necessary optimization. Instead, the problem provides an opportunity to reflect more
            generally on the nature of XPath expressions and the relationship between XPath and
            XML.
            For example, although the inefficiency described above is independent of the specific
            axis involved insofar as it could also have arisen with the sibling axes in a flattened
            tree, it nonetheless does depend on the XML structure, or, more precisely, on its
            indifference to the XML structure. What the long axes in the actual problem and the
            sibling axes in the flattened tree alternative have in common is that they operate
            independently of the tree structure. For example, the sibling axes in the original
            tree
            constrains the number of nodes involved because the tree is balanced in a way that
            ensures that no 
            <div class="code e148">&lt;word&gt;</div> element will have more than nine
            sibling 
            <div class="code e149">&lt;word&gt;</div> elements. What the long axes in that same tree
            and the sibling axes in the hypothetical flattened tree alternative have in common,
            on
            the other hand, is that all 
            <div class="code e150">&lt;word&gt;</div> elements are treated as
            though they are on the same level of the tree (in the former case because the long
            axes
            ignore the tree and in the latter case because the tree is flattened, and therefore
            irrelevant). This suggests that unless one can be certain that the software that will
            evaluate one’s XPath expressions will optimize one’s query, the designer should take
            into consideration the number of nodes that will be addressed by those
            expressions.
         </div>
      </div><a name="AnXPathsolutionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e151">
         <div class="title e152">An XPath solution</div>
         <div class="para e153">Since 
            <div class="emphasis e154" role="ital">eXist</div> was unable to optimize the queries in
            question, that duty fell on the user, who, in this case, first adopted a strategy
            that
            avoided the long axes, favoring instead the sibling axes at all levels
            (
            <div class="code e155">&lt;word&gt;</div> and 
            <div class="code e156">&lt;line&gt;</div>). This
            constrains searches for 
            <div class="code e157">&lt;word&gt;</div> elements within a
            
            <div class="code e158">&lt;line&gt;</div> element to an average of 2.64 (5.27 / 2) elements
            and searches for 
            <div class="code e159">&lt;line&gt;</div> elements within a
            
            <div class="code e160">&lt;book&gt;</div> element to 240.5 (481.7 / 2) elements, and in the
            worst case to 5.27 and 481.7, respectively. These numbers should be multiplied by
            six
            for a typical query, which retrieves three preceding and three following
            
            <div class="code e161">&lt;word&gt;</div> elements, but they still compare very favorably to
            queries along the long axes, which consult 13610.5 (27221 / 2)
            
            <div class="code e162">&lt;word&gt;</div> elements on average and 27221 in the worst case. A
            prose explanation of the strategy for retrieving the three
            
            <div class="code e163">&lt;word&gt;</div> elements following the target while using the
            
            <div class="code e164">following-sibling</div> axis exclusively instead of the
            
            <div class="code e165">following</div> axis is:
         </div>
         <div class="orderedlist e166">
            <div class="listitem e167">
               <div class="para e168">If there is a 
                  <div class="code e169">&lt;word&gt;</div> element in the appropriate
                  position on the 
                  <div class="code e170">following-sibling</div> axis (that is, in the same
                  
                  <div class="code e171">&lt;line&gt;</div> element), retrieve it.
               </div>
            </div>
            <div class="listitem e172">
               <div class="para e173">If not, navigate up to the 
                  <div class="code e174">parent</div> axis (a
                  
                  <div class="code e175">&lt;line&gt;</div> element), get its following-sibling
                  
                  <div class="code e176">&lt;line&gt;</div> element, and retrieve the appropriate
                  
                  <div class="code e177">&lt;word&gt;</div> child element from within that
                  
                  <div class="code e178">&lt;line&gt;</div>.
               </div>
            </div>
         </div>
         <div class="para e179">The following XQuery snippet retrieves the three 
            <div class="code e180">&lt;word&gt;</div>
            elements that follow the target. Assume that 
            <div class="code e181">$i</div> refers to the target (here
            and in subsequent examples):
         </div>
         <div class="programlisting e182" xml:space="preserve">if (count($i/following-sibling::word) ge 3)
            then for $j in (1 to 3) return $i/following-sibling::word[$j]
            else
            if (count($i/following-sibling::word) eq 2)
            then (for $j in (1 to 2) return $i/following-sibling::word[$j], 
            $i/parent::line/following-sibling::line/word[1])
            else
            if (count($i/following-sibling::word) eq 1)
            then ($i/following-sibling::word[1], for $j in (1 to 2) 
            return ($i/parent::line/following-sibling::line/word[$j]))
            else
            for $j in (1 to 3) return $i/parent::line/following-sibling::line/word[$j]
         </div>
         <div class="para e183">An analogous strategy can retrieve the three 
            <div class="code e184">&lt;word&gt;</div>
            elements that immediately precede the target.
         </div>
         <div class="para e185">It is possible to generalize this solution to allow the user to specify at run time
            the number of preceding or following 
            <div class="code e186">&lt;word&gt;</div> elements to
            provide as context along the following lines (assume that 
            <div class="code e187">$scope</div> specifies
            the number of words of context to provide after the target
            
            <div class="code e188">&lt;word&gt;</div>):
         </div>
         <div class="programlisting e189" xml:space="preserve">if (count($i/following-sibling::word) ge $scope) 
            then for $j in (1 to $scope) return $i/following-sibling::word[$j]
            else for $k in (0 to ($scope - 1)) return
            if (count($i/following-sibling::word) eq $k) 
            then (
            for $j in (1 to $k) return $i/following-sibling::word[$j],
            for $j in (1 to ($scope - $k)) return $i/parent::line/following-sibling::line/word[$j]
            )
            else ""
         </div>
         <div class="para e190">An analogous strategy can retrieve a user-specified number of
            
            <div class="code e191">&lt;word&gt;</div> elements that immediately precede the target. This
            generalization, however, is fragile because it looks only at the
            
            <div class="code e192">&lt;line&gt;</div> element that contains the target
            
            <div class="code e193">&lt;word&gt;</div> element plus the immediately preceding or
            following sibling 
            <div class="code e194">&lt;line&gt;</div> element. This means that, for
            example, if the user wants to include a context of five following
            
            <div class="code e195">&lt;word&gt;</div> elements, the code will fail when the target
            
            <div class="code e196">&lt;word&gt;</div> falls at the end of a
            
            <div class="code e197">&lt;line&gt;</div> and the following (sibling)
            
            <div class="code e198">&lt;line&gt;</div> contains only four
            
            <div class="code e199">&lt;word&gt;</div>elements. It might be possible to circumvent this
            limitation through a recursive approach, but by that point the code would become so
            convoluted as to be difficult to understand and impractical to maintain.
         </div>
      </div><a name="ArangeindexsolutionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e200">
         <div class="title e201">A range index solution</div>
         <div class="para e202">In addition to the new 
            <div class="emphasis e203" role="ital">Lucene</div>-based full-text index
            (and the original full-text index, which is still available), 
            <div class="emphasis e204" role="ital">eXist</div> also supports range indexes, which provide very fast access to
            element nodes on the 
            <div class="code e205">descendant-or-self</div> (
            <div class="code e206">//</div>) or
            
            <div class="code e207">child</div> (
            <div class="code e208">/</div>) axis and attribute notes on the
            
            <div class="code e209">attribute</div> (
            <div class="code e210">/@</div>) axis according to their typed data value.
            This suggests an alternative approach:
         </div>
         <div class="orderedlist e211">
            <div class="listitem e212">
               <div class="para e213">Before storing the XML source document, create an 
                  <div class="code e214">@offset</div>
                  attribute for each 
                  <div class="code e215">&lt;word&gt;</div> element and assign it a
                  unique sequential integer value. The first 
                  <div class="code e216">&lt;word&gt;</div>
                  element in the document has an 
                  <div class="code e217">@offset</div> value of 
                  <div class="code e218">1</div>, the
                  next has a value of 
                  <div class="code e219">2</div>, etc.
               </div>
            </div>
            <div class="listitem e220">
               <div class="para e221">Retrieve the target 
                  <div class="code e222">&lt;word&gt;</div> element by using the new
                  
                  <div class="emphasis e223" role="ital">Lucene</div> full-text index.
               </div>
            </div>
            <div class="listitem e224">
               <div class="para e225">Retrieve the adjacent context 
                  <div class="code e226">&lt;word&gt;</div> elements
                  according to their 
                  <div class="code e227">@offset</div> attribute values by counting backward or
                  forward from the 
                  <div class="code e228">@offset</div> value of the target
                  
                  <div class="code e229">&lt;word&gt;</div> element.
               </div>
            </div>
         </div>
         <div class="para e230">This approach is available only where the designer has control over the XML source
            and
            is able to incorporate a specific 
            <div class="code e231">@offset</div> attribute that is to be used only
            for navigation during retrieval. It has at least two weaknesses, one aesthetic and
            one
            technical:
         </div>
         <div class="itemizedlist e232">
            <div class="listitem e233">
               <div class="para e234">The aesthetic problem is that the ordinal position of each
                  
                  <div class="code e235">&lt;word&gt;</div> element within the document is an inherent
                  property of the document structure, and the user should not have to specify
                  through the insertion of character-based markup into the document a value that
                  is already encoded implicitly but consistently and unambiguously in the markup
                  structure.
               </div>
            </div>
            <div class="listitem e236">
               <div class="para e237">The technical problem is that the insertion or deletion of a word in the
                  document will break the numbering, requiring that the 
                  <div class="code e238">@offset</div>
                  values be calculated anew and rewritten. In the present case the document is
                  relatively stable (that is, more stable than, for example, an on-line commerce
                  site that writes new data for every transaction), but the editor may still
                  choose to modify her reading at some point as she reconsiders the available
                  evidence and perhaps discovers and needs to integrate the data from newly
                  discovered manuscript witnesses.
               </div>
            </div>
         </div>
         <div class="para e239"> In practice, neither of these weakness imposes a serious inconvenience in the context
            of the present project, and the opportunity to use the 
            <div class="emphasis e240" role="ital">eXist</div> range index feature provides a substantial improvement in response
            time over alternative strategies (see the time test data below).
         </div>
         <div class="para e241">With the modification to the XML source described above, the first two lines of Book
            2
            now look like:
         </div>
         <div class="programlisting e242" xml:space="preserve">&lt;book n="2"&gt;
            &lt;line&gt;
            &lt;word offset="3708"&gt;Regia&lt;/word&gt;
            &lt;word offset="3709"&gt;tota&lt;/word&gt;
            &lt;word offset="3710"&gt;silet;&lt;/word&gt;
            &lt;word offset="3711"&gt;expirat&lt;/word&gt;
            &lt;word offset="3712"&gt;murmur&lt;/word&gt;
            &lt;word offset="3713"&gt;in&lt;/word&gt;
            &lt;word offset="3714"&gt;altum,&lt;/word&gt;
            &lt;/line&gt;            
            &lt;line&gt;
            &lt;word offset="3715"&gt;cum&lt;/word&gt;
            &lt;word offset="3716"&gt;visu&lt;/word&gt;
            &lt;word offset="3717"&gt;placidos&lt;/word&gt;
            &lt;word offset="3718"&gt;delegat&lt;/word&gt;
            &lt;word offset="3719"&gt;curia&lt;/word&gt;
            &lt;word offset="3720"&gt;vultus,&lt;/word&gt;
            &lt;/line&gt;
            &lt;!-- more lines --&gt;
            &lt;/book&gt;
         </div>
         <div class="para e243">The following code will now use a properly-configured 
            <div class="emphasis e244" role="ital">eXist</div> range index to retrieve the three
            
            <div class="code e245">&lt;word&gt;</div> elements following the target
            
            <div class="code e246">&lt;word&gt;</div> element (assume 
            <div class="code e247">$i</div> is the target
            
            <div class="code e248">&lt;word&gt;</div> element):
         </div>
         <div class="programlisting e249" xml:space="preserve">let $offset := $i/@offset
            return
            for $j in (1 to 3) return doc("/db/acl/acl.xml")//word[@offset eq ($offset + $j)]
         </div>
         <div class="para e250">An analogous strategy can retrieve the three 
            <div class="code e251">&lt;word&gt;</div>
            elements that immediately precede the target. Furthermore, this solution is easily
            generalized to allow the user to specify the number of preceding or following context
            
            <div class="code e252">&lt;word&gt;</div> elements at run time (assume that
            
            <div class="code e253">$scope</div> specifies the number of words of context to provide after the
            target 
            <div class="code e254">&lt;word&gt;</div>):
         </div>
         <div class="programlisting e255" xml:space="preserve">let $offset := $i/@offset
            return
            for $j in (1 to $scope) return doc("/db/acl/acl.xml")//word[@offset eq ($offset +
            $j)]
         </div>
         <div class="para e256">The strategy of writing structural information about the XML (such as offset position)
            into attribute values of the XML source itself in the interest of improved execution
            time can also be applied to writing slashes to mark the ends of lines. The most natural
            XPath way to write a slash after the target 
            <div class="code e257">&lt;word&gt;</div> element
            when it ends a 
            <div class="code e258">&lt;line&gt;</div> element in the XML source is:
         </div>
         <div class="programlisting e259" xml:space="preserve">if (not($i/following-sibling::word)) then " / " else ""</div>
         <div class="para e260">A similar approach can be used to write slashes after the leading and trailing context
            
            <div class="code e261">&lt;word&gt;</div> elements when they end a
            
            <div class="code e262">&lt;line&gt;</div> element. This method is not maddeningly slow
            because the number of nodes on the sibling axes is typically small, but further
            improvement in processing speed is available by modifying the XML source to include
            the
            string 
            <div class="code e263">" / "</div> (without the quotation marks) as an attribute value associated
            with 
            <div class="code e264">&lt;word&gt;</div> elements that fall at the end of
            
            <div class="code e265">&lt;line&gt;</div> elements and then retrieving it when generating
            the report, instead of consulting the sibling axis. The first two lines of Book 2
            now
            look like:
         </div>
         <div class="programlisting e266" xml:space="preserve">&lt;book n="2"&gt;
            &lt;line&gt;
            &lt;word offset="3708"&gt;Regia&lt;/word&gt;
            &lt;word offset="3709"&gt;tota&lt;/word&gt;
            &lt;word offset="3710"&gt;silet;&lt;/word&gt;
            &lt;word offset="3711"&gt;expirat&lt;/word&gt;
            &lt;word offset="3712"&gt;murmur&lt;/word&gt;
            &lt;word offset="3713"&gt;in&lt;/word&gt;
            &lt;word last=" / " offset="3714"&gt;altum,&lt;/word&gt;
            &lt;/line&gt;            
            &lt;line&gt;
            &lt;word offset="3715"&gt;cum&lt;/word&gt;
            &lt;word offset="3716"&gt;visu&lt;/word&gt;
            &lt;word offset="3717"&gt;placidos&lt;/word&gt;
            &lt;word offset="3718"&gt;delegat&lt;/word&gt;
            &lt;word offset="3719"&gt;curia&lt;/word&gt;
            &lt;word last=" / " offset="3720"&gt;vultus,&lt;/word&gt;
            &lt;/line&gt;
            &lt;!-- more lines --&gt;
            &lt;/book&gt;
         </div>
         <div class="para e267">The XQuery code to write trailing context 
            <div class="code e268">&lt;word&gt;</div> elements
            is then:
         </div>
         <div class="programlisting e269" xml:space="preserve">let $offset := $i/@offset
            for $j in (1 to 3) return (
            " ", 
            data(doc("/db/acl/acl.xml")//word[@offset eq ($offset + $j)]),
            data(doc("/db/acl/acl.xml")//word[@offset eq ($offset + $j)]/@last)
            )
         </div>
         <div class="para e270">This approach writes a space after the target 
            <div class="code e271">&lt;word&gt;</div>
            element, followed by the appropriate trailing context 
            <div class="code e272">&lt;word&gt;</div>
            element, followed by the value of the 
            <div class="code e273">@last</div> attribute of that
            
            <div class="code e274">&lt;word&gt;</div> element. If there is a 
            <div class="code e275">@last</div>
            attribute, it has the value 
            <div class="code e276">" / "</div> (without the quotation marks), which is
            what we want to write. If the attribute is missing, that statement operates vacuously,
            producing no output.
         </div>
      </div><a name="TimetestresultsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e277">
         <div class="title e278">Time test results</div>
         <div class="para e279">To test the relative efficiency of the various coding strategies described above,
            the
            same query was executed ten times with each of four strategies. The query was a search
            for the word 
            <div class="code e280">sed</div> (Latin for ‘but’), which occurs 221 times in the corpus,
            and the XQuery scripts were all written to return it along with its location (book
            and
            line number) and with three context words on either side. The search strategies
            were:
         </div>
         <div class="itemizedlist e281">
            <div class="listitem e282">
               <div class="para e283">
                  <div class="emphasis e284" role="bold">Long axes:</div> Search for context words using the
                  
                  <div class="code e285">preceding</div> and 
                  <div class="code e286">following</div> axes. Place slashes at the
                  ends of lines by checking whether each output word has a following sibling
                  
                  <div class="code e287">&lt;word&gt;</div> element in the same
                  
                  <div class="code e288">&lt;line&gt;</div>.
               </div>
            </div>
            <div class="listitem e289">
               <div class="para e290">
                  <div class="emphasis e291" role="bold">Sibling axes:</div> Search for context words using
                  the sibling axes. If there are not enough context
                  
                  <div class="code e292">&lt;word&gt;</div> elements in the same
                  
                  <div class="code e293">&lt;line&gt;</div>, find the nearest sibling of the
                  
                  <div class="code e294">&lt;line&gt;</div> and navigate to the desired word element
                  along the 
                  <div class="code e295">child</div> axis. Place slashes as described above.
               </div>
            </div>
            <div class="listitem e296">
               <div class="para e297">
                  <div class="emphasis e298" role="bold">
                     <div class="code e299">@offset</div>:
                  </div> Modify the XML to add
                  an 
                  <div class="code e300">@offset</div> attribute to every 
                  <div class="code e301">&lt;word&gt;</div>
                  element and find the context words by counting down or up from the
                  
                  <div class="code e302">@offset</div> attribute value for the target
                  
                  <div class="code e303">&lt;word&gt;</div>. Place slashes as described above.
               </div>
            </div>
            <div class="listitem e304">
               <div class="para e305">
                  <div class="emphasis e306" role="bold">
                     <div class="code e307">@last</div>:
                  </div> Same as
                  
                  <div class="code e308">@offset</div>, except add a 
                  <div class="code e309">@last</div> attribute in the XML
                  to every 
                  <div class="code e310">&lt;word&gt;</div> element that is the last in its
                  parent 
                  <div class="code e311">&lt;line&gt;</div>, and place slashes at the ends of lines
                  by returning the value of that attribute.
               </div>
            </div>
         </div>
         <div class="para e312">The tests were conducted on a Gateway 3GHz Pentium D with 1MG of memory, running
            Microsoft Windows Vista with Service Pack 1.0. The Java version is 1.6.0_13 and the
            
            <div class="emphasis e313" role="ital">eXist</div> version is 1.3.0dev-rev:0000-20090528.
         </div>
         <div class="table e314" border="1" rules="all">
            <div class="tr e315" align="center">
               <div class="td e316">
                  
                  <div class="para e317">
                     
                     <div class="emphasis e318" role="ital">Test no.</div>
                     
                  </div>
                  
               </div>
               <div class="td e319">
                  
                  <div class="para e320">
                     
                     <div class="emphasis e321" role="ital">Long axes</div>
                     
                  </div>
                  
               </div>
               <div class="td e322">
                  
                  <div class="para e323">
                     
                     <div class="emphasis e324" role="ital">Sibling axes</div>
                     
                  </div>
                  
               </div>
               <div class="td e325">
                  
                  <div class="emphasis e326" role="ital">
                     
                     <div class="code e327">@offset</div>
                     
                  </div>
                  
               </div>
               <div class="td e328">
                  
                  <div class="emphasis e329" role="ital">
                     
                     <div class="code e330">@last</div>
                     
                  </div>
                  
               </div>
            </div>
            <div class="tr e331" align="right">
               <div class="td e332">
                  
                  <div class="emphasis e333" role="ital">1</div>
                  
               </div>
               <div class="td e334">447.750</div>
               <div class="td e335">38.477</div>
               <div class="td e336">34.345</div>
               <div class="td e337">24.413</div>
            </div>
            <div class="tr e338" align="right">
               <div class="td e339">
                  
                  <div class="emphasis e340" role="ital">2</div>
                  
               </div>
               <div class="td e341">440.265</div>
               <div class="td e342">38.390</div>
               <div class="td e343">34.446</div>
               <div class="td e344">24.416</div>
            </div>
            <div class="tr e345" align="right">
               <div class="td e346">
                  
                  <div class="emphasis e347" role="ital">3</div>
                  
               </div>
               <div class="td e348">559.141</div>
               <div class="td e349">38.710</div>
               <div class="td e350">34.438</div>
               <div class="td e351">24.445</div>
            </div>
            <div class="tr e352" align="right">
               <div class="td e353">
                  
                  <div class="emphasis e354" role="ital">4</div>
                  
               </div>
               <div class="td e355">905.472</div>
               <div class="td e356">38.484</div>
               <div class="td e357">35.409</div>
               <div class="td e358">24.384</div>
            </div>
            <div class="tr e359" align="right">
               <div class="td e360">
                  
                  <div class="emphasis e361" role="ital">5</div>
                  
               </div>
               <div class="td e362">702.915</div>
               <div class="td e363">38.590</div>
               <div class="td e364">34.562</div>
               <div class="td e365">24.447</div>
            </div>
            <div class="tr e366" align="right">
               <div class="td e367">
                  
                  <div class="emphasis e368" role="ital">6</div>
                  
               </div>
               <div class="td e369">530.739</div>
               <div class="td e370">38.341</div>
               <div class="td e371">34.798</div>
               <div class="td e372">24.424</div>
            </div>
            <div class="tr e373" align="right">
               <div class="td e374">
                  
                  <div class="emphasis e375" role="ital">7</div>
                  
               </div>
               <div class="td e376">851.608</div>
               <div class="td e377">38.714</div>
               <div class="td e378">34.145</div>
               <div class="td e379">24.415</div>
            </div>
            <div class="tr e380" align="right">
               <div class="td e381">
                  
                  <div class="emphasis e382" role="ital">8</div>
                  
               </div>
               <div class="td e383">473.601</div>
               <div class="td e384">38.496</div>
               <div class="td e385">34.410</div>
               <div class="td e386">24.395</div>
            </div>
            <div class="tr e387" align="right">
               <div class="td e388">
                  
                  <div class="emphasis e389" role="ital">9</div>
                  
               </div>
               <div class="td e390">670.772</div>
               <div class="td e391">39.521</div>
               <div class="td e392">34.423</div>
               <div class="td e393">24.463</div>
            </div>
            <div class="tr e394" align="right">
               <div class="td e395">
                  
                  <div class="emphasis e396" role="ital">10</div>
                  
               </div>
               <div class="td e397">473.601</div>
               <div class="td e398">38.317</div>
               <div class="td e399">34.429</div>
               <div class="td e400">24.469</div>
            </div>
            <div class="tr e401" align="right">
               <div class="td e402" align="left">
                  
                  <div class="emphasis e403" role="bital">Mean</div>
                  
               </div>
               <div class="td e404">631.150</div>
               <div class="td e405">38.604</div>
               <div class="td e406">34.541</div>
               <div class="td e407">24.427</div>
            </div>
            <div class="tr e408" align="right">
               <div class="td e409" align="left">
                  
                  <div class="emphasis e410" role="bital">Ratio 1</div>
                  
               </div>
               <div class="td e411">25.838</div>
               <div class="td e412">1.580</div>
               <div class="td e413">1.414</div>
               <div class="td e414">1.000</div>
            </div>
            <div class="tr e415" align="right">
               <div class="td e416" align="left">
                  
                  <div class="emphasis e417" role="bital">Ratio 2</div>
                  
               </div>
               <div class="td e418">18.273</div>
               <div class="td e419">1.118</div>
               <div class="td e420">1.000</div>
               <div class="td e421">&nbsp;</div>
            </div>
            <div class="tr e422" align="right">
               <div class="td e423" align="left">
                  
                  <div class="emphasis e424" role="bital">Ratio 3</div>
                  
               </div>
               <div class="td e425">16.349</div>
               <div class="td e426">1.000</div>
               <div class="td e427">&nbsp;</div>
               <div class="td e428">&nbsp;</div>
            </div>
         </div>
         <div class="para e429">Times are reported in seconds. The three ratio lines in the table set the time for
            one
            of the tests at a value of 
            <div class="code e430">1</div> and then calculate the amount of time the
            other implementations required in proportion to it.
         </div>
         <div class="para e431">The results show that querying along the long axes took more than 16 times as much
            time as querying along the sibling axes. Using the 
            <div class="code e432">@offset</div> attribute value
            instead of either the long axes or the sibling axes saved an additional 11% in time,
            and
            using the 
            <div class="code e433">@last</div> attribute value as well saved an additional 41% in time
            over that. All told, the implementation that relies on the long axes took more than
            25
            times as much time as the one with the greatest optimization.
         </div>
      </div><a name="IsitXML?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e434">
         <div class="title e435">Is it XML?</div>
         <div class="para e436">The XML version of the poem has an inherent hierarchy (the poem contains books, which
            contain lines, which contain words) and inherent order (the words occur in a particular
            order, as do the lines and books). Those inherent features are encoded naturally in
            the
            structure of the XML document because XML documents are obligatorily hierarchical
            (even
            though in some projects the hierarchy may be flat) and ordered (even though in some
            projects the user may ignore the order). The addition of 
            <div class="code e437">@offset</div> and
            
            <div class="code e438">@last</div> attributes and the adoption of a strategy that treats the
            document as flat and never looks at the hierarchy essentially transforms the approach
            from one that is based on natural properties of XML documents to one that is based
            on a
            flat-file database way of thinking. That is, we could map each
            
            <div class="code e439">&lt;word&gt;</div> element in the XML version to a record in a
            database table, the fields of which would be the textual representation of the word
            (a
            character string), the offset value (a unique positive integer), an indication of
            whether the word falls at the end of a line (a boolean value), and the book and line
            number (a string value, which is used in reporting). Records in a database do not
            have
            an inherent order, but once we rely on the value of the 
            <div class="code e440">@offset</div> attribute
            in the XML document, the 
            <div class="code e441">&lt;word&gt;</div> elements might as well be
            sprinkled through the document in any order, and the 
            <div class="code e442">&lt;line&gt;</div>
            and 
            <div class="code e443">&lt;book&gt;</div> elements play no role at all in the system. That
            is, except for the book and line number, the most highly optimized (and most efficient)
            implementation above adopts precisely a flat-file database approach, which raises
            the
            question of whether this project should have been undertaken in XML in the first
            place.
         </div>
         <div class="para e444">The answer to that rhetorical question is that of course it should have been
            undertaken in XML because the order and hierarchy are meaningful. They are inherent
            in
            the XML structure but must be written explicitly into a corresponding database
            implementation, which indicates that this is data that wants, as it were, to be regarded
            as an ordered and hierarchical XML document. The problem is not that the data is
            inherently tabular, and therefore inherently suited to a flat-file database solution,
            but that the XML tool available to manipulate the data was not sufficiently optimized
            for
            the type of retrieval required.
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e445">
         <div class="title e446">Conclusion</div>
         <div class="para e447">The best solution would be, of course, an optimization within 
            <div class="emphasis e448" role="ital">eXist</div> that would let users write concise and legible XQuery code (using
            the long axes), which would then be executed efficiently through optimization behind
            the
            scenes. This type of solution would remove the need for both more complex code (along
            the lines of the sibling-axes approach described above) and modifying the XML to write
            information into the document in character form when that information is already
            inherent in the document structure. Until such a solution became available, though,
            the
            strategies described above provided a substantial improvement over explicit use of
            the
            long axes, salvaging a project that would otherwise have been unusable for reasons
            of
            efficiency.
         </div>
      </div><a name="AddendumANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e449" xml:id="Addendum">
         <div class="title e450">Addendum</div>
         <div class="para e451">
            <div class="emphasis e452" role="ital">eXist</div> is an open-source project, which means that
            impatient users who require an optimization not already present in the code have the
            opportunity to implement that optimization themselves and contribute it to the project.
            Unfortunately, in the present case this particular impatient user lacked the Java
            programming skills to undertake the task. Fortunately, however, the 
            <div class="emphasis e453" role="ital">eXist</div> development team is very responsive to feature requests
            from users, and shortly after I wrote to the developers about the problem they released
            an upgrade that implemented precisely the modification described above (consult the
            predicate first and retrieve only the nodes that will be needed from the designated
            axis). Rerunning the original code that relied on the long axes on the same machine
            as
            the earlier tests but using 
            <div class="emphasis e454" role="ital">eXist</div> version
            1.3.0dev-rev9622-20090802, which includes this new optimization, yielded times of
            1.754,
            1.778, 1.765, 1.944, 1.944, 1.777, 18.949, 1.838, 1.763, and 1.798 seconds. The mean
            time for these tests was 3.531 seconds, and if we exclude the aberrant long time on
            the
            seventh trial (an artifact of a system process that woke up at an inconvenient moment?),
            the mean drops to 1.818 seconds. The 3.531-second figure is 14.455% of the best mean
            time (24.427 seconds) achieved with my XSLT-based optimizations and 0.559% of the
            mean
            time of the long-axes search (631.150 seconds) before the introduction of the 
            <div class="emphasis e455" role="ital">eXist</div>-internal optimization. The 1.818-second figure is
            7.443% of the best mean time (24.427 seconds) achieved with my XPath-based optimizations
            and 0.288% of the mean time of the long-axes search (631.150 seconds) before the
            introduction of the 
            <div class="emphasis e456" role="ital">eXist</div>-internal optimization.
         </div>
         <div class="para e457">The 
            <div class="emphasis e458" role="ital">eXist</div> optimization works by checking the static
            return type of the predicate expression to determine whether it is a positional
            predicate. (This paragraph reproduces more or less verbatim an explanation provided
            by
            the 
            <div class="emphasis e459" role="ital">eXist</div> developers.) If the answer is yes and there
            is no context dependency, the predicate will be evaluated in advance and the result
            will
            be used to limit the range of the context selection (e.g.,
            
            <div class="code e460">following::word</div>). For example, 
            <div class="code e461">$i/following::word[1]</div> would
            benefit from the optimization because the static return type of the predicate is a
            positional predicate and it entails no context dependency. On the other hand,
            
            <div class="code e462">$i/following::word[position() = 1]</div> would not be optimized because it
            introduces a context dependency insofar as 
            <div class="code e463">position()</div> returns the position
            of the current context item and cannot be evaluated without looking at the context.
            Furthermore, determining the static type is not always easy. In particular, the type
            information is passed along local variables declared in a 
            <div class="code e464">let</div> or
            
            <div class="code e465">for</div>, but it gets lost through function calls. My original query,
            
            <div class="code e466">for $j in (1 to 3) return $i/following::word[$j]</div>, works, but if
            
            <div class="code e467">$j</div> were a function parameter, it would not. Additionally, support for
            this optimization with particular XPath functions is being introduced only
            incrementally, to avoid breaking existing code. For example, the developers’ initial
            attempt at an optimization failed with the 
            <div class="code e468">reverse()</div> function that I used
            to retrieve the three preceding words in the correct order, although support for this
            function was added later to the optimization.
         </div>
         <div class="para e469">The unsurprising technical conclusion, then, is that, at least in the present case,
            optimization of the XPath code by the user to reduce the scope of a query can achieve
            substantial improvement, but much more impressive results are obtained by optimizing
            the
            Java code underlying the XPath interpreter. What this experiment also reveals, though,
            is that, at least in the present case, the user was not reduced to waiting helplessly
            for a resolution by the developers, and was able to achieve meaningful improvement
            in
            those areas that he did control, viz., the XML, XPath, and XQuery.
         </div>
         <div class="para e470">In his concluding statement at the Balisage 2009 pre-conference Symposium on
            Processing XML Efficiently, Michael Kay invoked David Wheeler’s advice that application
            developers optimize the code that users actually write, that is, that they find out
            what
            people are doing and make that go quickly. From an end-user perspective, though, the
            lesson can be reversed: Find out what goes quickly and use it.
         </div>
      </div><a name="WorkscitedANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e471">
         <div class="title e472">Works cited</div>
         <div class="bibliomixed e473" xml:id="Configuring" xreflabel="Configuring">“Configuring Database Indexes.”
            (Part of the 
            <div class="emphasis e474" role="ital">eXist</div> documentation.) 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e475" xlink:actuate="onRequest" xlink:href="http://www.exist-db.org/indexing.html" xlink:show="new" xlink:type="simple">http://www.exist-db.org/indexing.html</div>. Accessed 2009-05-31.
         </div>
         <div class="bibliomixed e476" xml:id="Lucene" xreflabel="Lucene">“Lucene-based Full Text Index” (Part of the
            
            <div class="emphasis e477" role="ital">eXist</div> documentation.) 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e478" xlink:actuate="onRequest" xlink:href="http://www.exist-db.org/lucene.html" xlink:show="new" xlink:type="simple">http://www.exist-db.org/lucene.html</div>. Accessed 2009-05-31.
         </div>
         <div class="bibliomixed e479" xml:id="Tuning" xreflabel="Tuning">“Tuning the Database.” (Part of the
            
            <div class="emphasis e480" role="ital">eXist</div> documentation.) 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e481" xlink:actuate="onRequest" xlink:href="http://exist.sourceforge.net/tuning.html" xlink:show="new" xlink:type="simple">http://exist.sourceforge.net/tuning.html</div>. Accessed 2009-05-31.
         </div>
      </div>
   </div>
</div>