<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#RELAXNGandDITA:AnAlmostPerfectMatchANCHOR" name="RELAXNGandDITA:AnAlmostPerfectMatchTOC">RELAX NG and DITA: An Almost Perfect Match</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DITAModularVocabularyRequirementsANCHOR" name="DITAModularVocabularyRequirementsTOC">DITA Modular Vocabulary Requirements</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ChallengesPosedbyDTDSyntaxANCHOR" name="ChallengesPosedbyDTDSyntaxTOC">Challenges Posed by DTD Syntax</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ChallengesPosedbyXMLSchemaANCHOR" name="ChallengesPosedbyXMLSchemaTOC">Challenges Posed by XML Schema</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XSDRedefineFacilityANCHOR" name="XSDRedefineFacilityTOC">XSD Redefine Facility</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DITA12GroupDesignandXSDANCHOR" name="DITA12GroupDesignandXSDTOC">DITA 1.2 Group Design and XSD</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WorkingAroundRedefineLimitations:IndirectioninSequenceGroupsANCHOR" name="WorkingAroundRedefineLimitations:IndirectioninSequenceGroupsTOC">Working Around Redefine Limitations: Indirection in Sequence Groups</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeclarationsforIntegratingDomainElementTypesinXSDDocumentTypeShellsANCHOR" name="DeclarationsforIntegratingDomainElementTypesinXSDDocumentTypeShellsTOC">Declarations for Integrating Domain Element Types in XSD Document Type Shells</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#HowRELAXNGAddressesDITARequirementsANCHOR" name="HowRELAXNGAddressesDITARequirementsTOC">How RELAX NG Addresses DITA Requirements</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RELAXNGisaGoodMatchtoDTDsANCHOR" name="RELAXNGisaGoodMatchtoDTDsTOC">RELAX NG is a Good Match to DTDs</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ModulesareSelfIntegratingANCHOR" name="ModulesareSelfIntegratingTOC">Modules are Self Integrating</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DTDandXSDGenerationANCHOR" name="DTDandXSDGenerationTOC">DTD and XSD Generation</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsandFutureWorkANCHOR" name="ConclusionsandFutureWorkTOC">Conclusions and Future Work</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
         <div class="singletermTERMS">Bina</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">combine="choice"</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Darwin Information Typing Architecture</div>
         <div class="singletermTERMS">DITA</div>
         <div class="singletermTERMS">document grammar</div>
         <div class="singletermTERMS">DTD</div>
         <div class="singletermTERMS">Darwin Information Typing Architecture (DITA)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Extensible Markup Language</div>
         <div class="singletermTERMS">ekimber@contrext.com</div>
         <div class="singletermTERMS">Eliot</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">george@oxygenxml.com</div>
         <div class="singletermTERMS">George</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Kimber</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">Owner</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">RELAX NG</div>
         <div class="singletermTERMS">RELAX NG DTD Compatibility</div>
         <div class="singletermTERMS">RELAX NG</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">tagname</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">vocabulary architecture</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML Schema Part 1: Structures Second Edition</div>
         <div class="singletermTERMS">XSD</div>
         <div class="singletermTERMS">XML schema document</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="RELAXNGandDITA:AnAlmostPerfectMatchANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">RELAX NG and DITA: An Almost Perfect Match</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2014</div>
            <div class="confdates e5">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">The DITA vocabulary architecture defines a formal and controlled mechanism for configuring
               and extending the base DITA vocabulary. The architecture is independent of any XML
               document grammar facility in that DITA only requires that document instances exhibit
               specific attributes that serve to declare the document's effective document type (set
               of vocabulary and constraint modules) and each element's relationship to its base
               element types (specialization hierarchy). However, practical authoring and management
               of DITA documents requires the use of some form of document grammar, e.g. a DTD, XML
               schema, etc. While the DITA standard defines specific coding patterns for implementing
               DITA vocabulary and constraint modules and for integrating those modules into document
               type shells, DITA users find both the DTD and XSD implementation details difficult
               and challenging due to the syntax and semantics of both grammar facilities. Through
               DITA version 1.2, the DITA standard recognized only DTDs and XSDs as conforming DITA
               grammar languages and the DITA Technical Committee provided both DTD and XSD versions
               of the DITA modules and document type shells. One the authors (George Bina) discovered
               that RELAX NG provided significant advantages over both DTD and XSD grammars, significantly
               simplifying both the task of integrating modules into working document types and defining
               vocabulary and constraint modules. Specific features of RELAX NG make it the best
               match to DITA's vocabulary architecture of any current XML document grammar facility.
               This paper discusses the general requirements defined by the DITA vocabulary architecture,
               the challenges presented by the DTD and XSD grammar facilities, and how RELAX NG addresses
               all those requirements. We also present some suggestions for improvements in RELAX
               NG that would remove the few places where RELAX NG is not optimal for DITA's requirements.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="surname e10">Kimber</div>
               <div class="firstname e11">Eliot</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Eliot has been doing generalized markup longer than most humans have been
                  alive. Eliot's most recent professional focus is on the application of the DITA
                  standard to the requirements of professional publishers. Eliot is a founding member
                  of the OASIS DITA Technical Committee and active contributor to the DITA standard.
                  Eliot maintains the DITA For Publishers open source project. When not wrangling
                  tags to his will, Eliot trains in Aikido and skateboards when he can. Eliot lives
                  in Austin, Texas.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Owner</div>
               <div class="orgname e16">Contrext, LLC</div>
            </div>
            <div class="email e17">ekimber@contrext.com</div>
         </div>
         <div class="author e18">
            <div class="personname e19">
               <div class="surname e20">Bina</div>
               <div class="firstname e21">George</div>
            </div>
            <div class="personblurb e22">
               <div class="para e23">George is founder of SyncroSoft, makers of the oXygenXML product.
                  George is a mathematician by training. George lives and works in Criova,
                  Romania. When not contributing to open-source projects, George enjoys
                  travel with his family and taking selfies of himself working in 
                  exotic locations.
               </div>
            </div>
            <div class="affiliation e24">
               <div class="orgname e25">SyncroSoft</div>
            </div>
            <div class="email e26">george@oxygenxml.com</div>
         </div>
         <div class="legalnotice e27">
            <div class="para e28">Copyright © 2014 George Bina and Eliot Kimber</div>
         </div>
         <div class="keywordset e29" role="author">
            <div class="keyword e30">DITA</div>
            <div class="keyword e31">document grammar</div>
            <div class="keyword e32">DTD</div>
            <div class="keyword e33">XSD</div>
            <div class="keyword e34">RELAX NG</div>
            <div class="keyword e35">XML schema document</div>
            <div class="keyword e36">vocabulary architecture</div>
            <div class="keyword e37">Darwin Information Typing Architecture (DITA)</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e38">
         <div class="title e39">Introduction</div>
         <div class="para e40">The 
            <div class="citation e41" linkend="dita-std">OASIS Darwin Information Typing Architecture standard</div> (DITA) defines a unique approach to the definition and management of XML document
            vocabularies. Rather than defining a monolithic set of element types and attributes
            that can then be modified or added to without constraint, DITA defines a formal architecture
            consisting of a set of invariant base vocabulary "modules" comprising the base standard
            DITA vocabulary. These modules are invariant in the sense that they are not intended
            to be modified directly but only through specific configuration and extension facilities
            as defined by the DITA standard. In particular, modules may not be modified in a way
            that makes them less constrained than the base definition. All copies of a given module
            version in time should be identical.
         </div>
         <div class="para e42">A given set of modules represents a unique "DITA document type". Two DITA documents
            that use the same modules have the same DITA document type. Note that this notion
            of "DITA document type" is independent of the use of any particular document grammar
            associated with the document: it is only necessary for a document to declare the set
            of modules it uses, which is done with the DITA-defined @domains attribute on the
            document root element. The value of the @domains attribute is simply a list of modules:
            
            <div class="code e43">&lt;topic domains="(topic topic) (topic hi-d) (topic pr-d)"&gt;</div>.
         </div>
         <div class="para e44">Likewise, each DITA element declares it's relationship to the base DITA vocabulary
            through the the DITA-defined @class attribute, which enumerates the element's ancestry
            as a sequence of module/tagname pairs: 
            <div class="code e45">&lt;steps class="- topic/ol task/steps "&gt;</div>. For the &lt;steps&gt; element, the @class value can be read as "the &lt;steps&gt; element, defined
            within the "task" topic type module, is a specialization of the &lt;ol&gt; element defined
            in the "topic" topic type module. That is, it reflects the type hierarchy "steps is-a
            ol".
         </div>
         <div class="para e46">Given a DITA document with the @domains and@class attributes present the document
            is fully processable by any DITA-aware processor. In practice, however, the @domains
            and @class values are defined as attribute default values in some governing grammar
            and omitted from document instances. Thus, while the DITA standard does not require
            the use of grammars with conforming DITA documents, practical considerations effectively
            require grammars to enable population of the @domains and @class values, general document
            validation, authoring support, and so on.
         </div>
         <div class="para e47">The DITA standard defines specific coding requirements for the grammar types recognized
            by the DITA standard. These coding requirements ensure consistency across all conforming
            DITA vocabularies and thus facilitate interchange of vocabulary modules.
         </div>
         <div class="para e48">DITA vocabulary implementation involves three component types:
            <div class="itemizedlist e49">
               <div class="listitem e50">
                  <div class="para e51">Vocabulary modules, which define element and attribute types. Vocabulary modules are
                     either "structural", defining new map or topic types, or "domain", defining element
                     types that may be used in any map or topic type as appropriate ("mix-in" elements).
                     Every DITA document is either a map or a topic and therefore uses at least a single
                     structural module. Vocabulary modules must be coded in such a way as to enable appropriate
                     extension and constraint through separate modules. That is, it must be possible to
                     modify the base content model and attribute list declarations as allowed by the DITA
                     architecture without directly modifying the vocabulary module files themselves.
                  </div>
               </div>
               <div class="listitem e52">
                  <div class="para e53">Constraint modules, which constrain content modules or attributes for elements. Constraints
                     are implemented by redefining or overriding base content model and attribute list
                     declarations.
                  </div>
               </div>
               <div class="listitem e54">
                  <div class="para e55">Document type shells, which "integrate" vocabulary and constraint modules to implement
                     specific DITA document types. Document type shells are logically just inclusion lists
                     of the vocabulary and constraint modules used by the document type. In particular,
                     the list of included modules should match the set of modules named by the document's
                     @domains attribute.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e56">The implementation challenge for DITA vocabulary, constraint, and document type shell
            authors is that neither DTD nor XSD are a particularly good match syntactically or
            semantically to DITA's requirements. DTDs require the use of parameter entities, which
            leads to convoluted and difficult-to-debug document type shells. XSD 1.0's limited
            and highly-constrained facilities for content model and group redefinition require
            various forms of indirection not inherent in the semantics of the DITA element types
            nor required in the DTD implementation of the equivalent vocabulary. The DITA user
            community, even highly-experienced practitioners, find implementing and maintaining
            both DTD and XSD vocabulary modules tedious and challenging. 
         </div>
         <div class="para e57">While the issues with DTD mostly stem from the difficulty in debugging parameter entities
            and the large opportunity for error in constructing parameter entity declarations
            and references, the issues with XSD go deeper, relating to XSD's class model and restrictions
            on how groups may be redefined through the XSD redefine facility. In addition, the
            XSD 1.0 redefine facility is ambiguously specified such that conforming XSD processors
            may use either of two incompatible interpretations of how redefine should work. However
            DITA's use of XSD depends on the interpretation as implemented by the Xerces Java
            and C XSD parsers, making the use of XSD for DITA problematic in the general case.
            While the XSD 1.1 override facility appears to address the issues with redefine, until
            XSD 1.1 is implemented widely it cannot be mandated by the DITA standard.
         </div>
         <div class="para e58">Finally, the DITA Technical Committee, along with any other provider of DITA vocabularies,
            constraints, and document type shells faces the practical problem of maintaining both
            DTD and XSD versions of their vocabulary, which is challenging at best. An ideal solution
            would allow generation of either or both of the DTD and XSD versions from a single
            source. Through DITA version 1.2 the Technical Committee considered this too difficult
            to attempt from either the DTD or XSD as the authoritative source.
         </div>
         <div class="para e59">RELAX NG offers solutions to all these challenges by providing an XML-based syntax
            for document grammars that is a close equivalent to DTD syntax (avoiding the verbosity
            and conceptual overhead of XSD) while making the creation of document type shells
            much simpler, reducing them to essentially a simple inclusion list of modules. Because
            RELAX NG patterns may unilaterally augment other patterns, RELAX NG vocabulary and
            constraint modules become "self integrating", such that in most cases no additional
            work is required beyond simply creating a reference to the module from the document
            type shell.
         </div>
         <div class="para e60">Likewise, the relative simplicity of RELAX NG syntax coupled with an XML format make
            it practical to generate both DTD and XSD versions of the vocabulary from the RELAX
            NG.
         </div>
      </div><a name="DITAModularVocabularyRequirementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e61">
         <div class="title e62">DITA Modular Vocabulary Requirements</div>
         <div class="para e63">A DITA vocabulary module defines either a set of element types or a single global
            attribute. The grammar definition for a module must satisfy the following requirements:
            <div class="orderedlist e64">
               <div class="listitem e65">
                  <div class="para e66">Provide the @domains attribute contribution for the module.</div>
               </div>
               <div class="listitem e67">
                  <div class="para e68">Define content models with appropriate parameterization so that the following types
                     of modifications may be made through the redefinition, extension, or override of those
                     parameters:
                     <div class="itemizedlist e69">
                        <div class="listitem e70">
                           <div class="para e71">Redefine the content model in its entirety</div>
                        </div>
                        <div class="listitem e72">
                           <div class="para e73">Allow additional element types where any given element type is allowed (integration
                              of domain-provided specializations of base element types).
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e74">
                  <div class="para e75">Define attribute lists with appropriate parameterization so that the following types
                     of modifications may be made through the redefinition, extension, or override of those
                     parameters:
                     <div class="itemizedlist e76">
                        <div class="listitem e77">
                           <div class="para e78">Redefine the attribute list in its entirety, for example, to omit specific attributes
                              or set specific default values for specific attributes.
                           </div>
                        </div>
                        <div class="listitem e79">
                           <div class="para e80">Extend the attribute list with global attributes defined in separate attribute domain
                              modules.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e81">
                  <div class="para e82">Provide common reusable content model fragments used to construct element-type-specific
                     content models
                  </div>
               </div>
            </div>
         </div>
         <div class="para e83">Constraint modules use the parameterization facilities defined in modules to constrain
            element types. Thus any grammar facility must provide a way to include separate modules
            that can redefine or override parameters provided by modules.
         </div>
         <div class="para e84">Document type shells include ("integrate") the vocabulary and constraint modules in
            order to define a working document type. The document type shell must set the value
            of the @domains attribute as specified on the root element of the DITA document the
            document type shell governs.
         </div>
      </div><a name="ChallengesPosedbyDTDSyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e85">
         <div class="title e86">Challenges Posed by DTD Syntax</div>
         <div class="para e87">As in all standard XML vocabularies intended for general use, the DITA DTDs make heavy
            use of parameter entities in order to enable configuration and constraint of vocabulary.
            The DITA DTD coding requirements specify the structure and naming rules for the parameter
            entities used to construct DITA element type and attribute list declarations.
         </div>
         <div class="para e88">The most important parameters are:
            <div class="itemizedlist e89">
               <div class="listitem e90">
                  <div class="para e91">Element type name parameter entities for use in content models. For each element type
                     defined in a vocabulary module there is a correponding parameter entity that expands
                     to the element type name. These parameter entities are used in content models, e.g.:
                     <div class="programlisting e92" xml:space="preserve">&lt;!ENTITY % ph         "ph"            &gt;
                        
                        
                        ...
                        
                        &lt;!ENTITY % basic.ph 
                        "%boolean; | 
                        %cite; | 
                        %keyword; | 
                        
                        <div class="emphasis e93" role="bold">%ph;</div> | 
                        %q; |
                        %term; | 
                        %tm; | 
                        %xref; | 
                        %state;
                        "
                        &gt;
                     </div>
                  </div>
               </div>
               <div class="listitem e94">
                  <div class="para e95">"Domain integration" parameter entities, which are defined in domain modules and are
                     used to override and extend the base values of element type name parameter entities
                     in order to allow any specialization of the base type wherever the base type is allowed:
                     <div class="programlisting e96" xml:space="preserve">&lt;!ENTITY % hi-d-ph      
                        "b | 
                        i | 
                        sup | 
                        sub |
                        tt | 
                        u 
                        "
                        &gt;
                     </div>
                  </div>
                  <div class="para e97">Each element domain module is represented by a pair of files, one named *.ent, the
                     other named *.mod. The domain integration parameter entity is defined in the .ent
                     file while the element-type-name parameter entities are defined in the .mod files.
                     This use of two files for each module leads to one common error in constructing DTD
                     document type shells: inclusion of the wrong file, leading to confusing and difficult-to-detect
                     or understand errors.
                  </div>
               </div>
               <div class="listitem e98">
                  <div class="para e99">Content model parameter entities, which define the content models for each element
                     type. These parameter entities are always named "
                     <div class="emphasis e100">tagname</div>.content". These parameter entities allow any element type to be constrained through
                     separate constraint modules that override the base definition of the element's content
                     model parameter entity, e.g.:
                     <div class="programlisting e101" xml:space="preserve">&lt;!ENTITY % body.content
                        "(%body.cnt; |
                        %bodydiv; | 
                        %example; | 
                        %section;)*"
                        &gt;
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e102">As for all XML DTDs that make heavy use of parameter entities, one practical challenge
            is working out what the effective value of any given parameter entity is, as few,
            if any, DTD editing tools provide convenient ways to visualize expanded content models
            or follow references back to declarations.
         </div>
         <div class="para e103">Another practical problem is determining which declaration of a given parameter entity
            is the effective one when there are multiple declarations in multiple files. Error
            messages resulting from incorrect declarations are usually not very helpful in finding
            the actual cause of the error as the errors tend to be about incorrect content models
            resulting from the failure to resolve a particular entity or an error in the declaration
            of a redefinition of an existing entity. All complex, heavily-parameterized document
            types suffer from this problem and DITA's are as complicated as any. If DITA has an
            advantage in this area it is only that its coding patterns are both consistent and
            mandated by the standard, making it slightly easier to detect typing errors.
         </div>
         <div class="para e104">DTD-syntax document type shells in DITA require multiple external parameter entity
            references, in specific orders, for each structural and domain module as well as declaration
            of the domain integration parameter entities, again in the right order, as well as
            inclusion of any constraint modules used in the shell.
         </div>
         <div class="para e105">The need for multiple external parameter entities for each module adds complexity
            and opportunities for error. For example, it is easy to accidentally include the wrong
            file, for example, including a .mod file instead of the required .ent file. This type
            of error can be hard to find because it doesn't necessarily make the resulting DTD
            invalid but may make it incorrect because the order of parameter entity declarations
            is not correct, causing subsequent redefinitions to have no effect.
         </div>
         <div class="para e106">Likewise, it is easy to make typos in the domain entity integration parameter entity
            declarations, for example, omitting a "|" separator or simply misspelling the name
            of a domain-defined parameter entity. Or simply forgetting to include a reference
            to domain's integration parameter entity. None of these errors is easy to check programmatically
            and none are reported in a way that makes the real error obvious. Even experienced
            DITA DTD authors can find it difficult to diagnose and resolve these types of errors.
         </div>
         <div class="para e107">While the DITA standard defines and documents the coding pattern for document type
            shells such that anyone should be able to simply follow the pattern in order to successfully
            create their own custom shell, in practice few people even attempt it and fewer succeed
            because of the inherent challenges of DTD syntax.
         </div>
      </div><a name="ChallengesPosedbyXMLSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e108">
         <div class="title e109">Challenges Posed by XML Schema</div>
         <div class="para e110">The XML Schema Document (XSD) facility presents several challenges for use with DITA
            vocabularies:
         </div>
         <div class="itemizedlist e111">
            <div class="listitem e112">
               <div class="para e113">The requirement to use the XSD redefine facility</div>
            </div>
            <div class="listitem e114">
               <div class="para e115">Limits on redefine and the resulting need for intermediate groups and, in some cases,
                  intermediate files
               </div>
            </div>
            <div class="listitem e116">
               <div class="para e117">Declarations for integrating domain-provided element types into base content models</div>
            </div>
            <div class="listitem e118">
               <div class="para e119">The verbosity of the markup generally stemming from the XSD class and element type
                  distinction, which does not correspond to DITA's class concept. 
               </div>
            </div>
         </div><a name="XSDRedefineFacilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e120">
            <div class="title e121">XSD Redefine Facility</div>
            <div class="para e122">The XSD redefine facility is defined ambiguously in the XSD recommendation such that
               conforming XSD processors may use either of two incompatible interpretations of redefinition,
               only one of which works for DITA. This means only some XSD processors can be used
               to validate XSD-based DITA documents. Fortunately, two of those processors are the
               Xerces Java and C-language XSD processors, making the required XSD processing available
               in all Java environments and many non-Java environments. In XSD 1.1 the Redefine facility
               is deprecated:
               <div class="popupBox e123">
                  <div class="popupLabel" onmouseover="$('#d1e210').show('1000');" onmouseout="$('#d1e210').hide('1000');">[ blockquote ]</div>
                  <div id="d1e210" style="display: none;">
                     <div class="blockquote">
                        <div class="para e124">4.2.4 Including modified component definitions (&lt;redefine&gt;)</div>
                        <div class="para e125">Note: The redefinition feature described in the remainder of this section is ·deprecated·
                           and may be removed from future versions of this specification. Schema authors are
                           encouraged to avoid its use in cases where interoperability or compatibility with
                           later versions of this specification are important.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e126">The primary issue appears to be with systems that cache schemas. If two documents
               use two different top-level schemas, each of which redefines the same base model from
               a third schema, it is possible that a system may cache the redefine as defined by
               the first top-level schema and use it when processing against the second top-level
               schema. Any system that does this will reliably fail with typical DITA documents where
               there is a mix of topic types, each of which necessarily provides different redefines
               for the same base models. It is not clear if any XSD processors actually have this
               caching behavior.
            </div>
            <div class="para e127">The XSD 1.1 override facility, which was driven in part by DITA requirements, appears
               to provide the override semantics DITA requires, but as XSD 1.1 is not universally
               implemented it is difficult to justify requiring the use of XSD 1.1. However, because
               the DITA XSDs are generated starting with DITA 1.3, it would be possible to generate
               XSDs that use override in place of redefine if the DITA community requires them. As
               of May 2014 it appears that the only XSD 1.1 implementations are Xerces-J and Saxon
               EE, which is not sufficient to support the full DITA community.
            </div>
            <div class="para e128">The challenge presented by the XSD Redefine facility is its "particle preservation"
               requirement, defined as follows:
               <div class="popupBox e129">
                  <div class="popupLabel" onmouseover="$('#d1e221').show('1000');" onmouseout="$('#d1e221').hide('1000');">[ blockquote ]</div>
                  <div id="d1e221" style="display: none;">
                     <div class="blockquote">
                        <div class="para e130">The definitions within the &lt;redefine&gt; element itself are restricted to be redefinitions
                           of components from the &lt;redefine&gt;d schema document, in terms of themselves. That is,
                           
                           <div class="itemizedlist e131">
                              <div class="listitem e132">
                                 <div class="para e133">Type definitions must use themselves as their base type definition; </div>
                              </div>
                              <div class="listitem e134">
                                 <div class="para e135">Attribute group definitions and model group definitions must be supersets or subsets
                                    of their original definitions, either by including exactly one reference to themselves
                                    or by containing only (possibly restricted) components which appear in a corresponding
                                    way in their &lt;redefine&gt;d selves.
                                    <div class="popupBox e136">
                                       <div class="popupLabel" onmouseover="$('#d1e231').show('1000');" onmouseout="$('#d1e231').hide('1000');">[ footnote ]</div>
                                       <div id="d1e231" style="display: none;">
                                          <div class="footnote">
                                             <div class="para e137">XML Schema Part 1: Structures Second Edition, clause 4.2.2 Including modified component
                                                definitions
                                             </div>
                                          </div>
                                       </div>
                                    </div>
                                 </div>
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e138">This means that any redefinition of a model must reflect each of the particles in
               the original model. For choice groups this is not a problem: any choice group is a
               valid restriction, including an empty group. But for sequence groups it is a serious
               problem, in that you cannot simply omit items from the sequence as part of the redefinition.
            </div>
            <div class="para e139">For example, given this base schema:
               <div class="programlisting e140" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  xmlns:s1="urn:example.com:schema-01"
                  targetNamespace="urn:example.com:schema-01"
                  &gt;
                  
                  &lt;xs:complexType name="root.type"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element ref="s1:A"/&gt;
                  &lt;xs:element ref="s1:B"/&gt;
                  &lt;xs:element ref="s1:C"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:complexType&gt;
                  
                  &lt;xs:element name="root" type="s1:root.type"&gt;
                  &lt;/xs:element&gt;
                  
                  &lt;xs:element name="A" &gt;    
                  &lt;/xs:element&gt;
                  &lt;xs:element name="B" &gt;    
                  &lt;/xs:element&gt;
                  &lt;xs:element name="C" &gt;    
                  &lt;/xs:element&gt;
                  
                  &lt;/xs:schema&gt;
               </div>
            </div>
            <div class="para e141">This redefinition is invalid:
               <div class="programlisting e142" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  xmlns:s1="urn:example.com:schema-01"
                  targetNamespace="urn:example.com:schema-01"
                  &gt;
                  
                  &lt;!-- Redefine of redefined schema 01 --&gt;
                  &lt;xs:redefine schemaLocation="redefined-schema-01.xsd"&gt;
                  &lt;xs:complexType name="root.type"&gt;
                  &lt;xs:complexContent&gt;
                  &lt;xs:restriction base="s1:root.type"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element ref="s1:A"/&gt;
                  &lt;xs:element ref="s1:C"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:restriction&gt;
                  &lt;/xs:complexContent&gt;
                  &lt;/xs:complexType&gt;
                  &lt;/xs:redefine&gt;
                  &lt;/xs:schema&gt;
               </div>
            </div>
            <div class="para e143">Because the "B" particle from the origin sequence is not accounted for in the redefined
               sequence.
            </div>
            <div class="para e144">Likewise, this attempt to make "B" disallowed is also invalid:
               <div class="programlisting e145" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  xmlns:s1="urn:example.com:schema-01"
                  targetNamespace="urn:example.com:schema-01"
                  &gt;
                  
                  &lt;!-- Redefine of redefined schema 01 --&gt;
                  &lt;xs:redefine schemaLocation="redefined-schema-01.xsd"&gt;
                  &lt;xs:complexType name="root.type"&gt;
                  &lt;xs:complexContent&gt;
                  &lt;xs:restriction base="s1:root.type"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element ref="s1:A"/&gt;
                  
                  <div class="emphasis e146">&lt;xs:element ref="s1:B" maxOccurs="0" minOccurs="0"/&gt;</div>
                  &lt;xs:element ref="s1:C"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:restriction&gt;
                  &lt;/xs:complexContent&gt;
                  &lt;/xs:complexType&gt;
                  &lt;/xs:redefine&gt;
                  &lt;/xs:schema&gt;
               </div>
            </div>
            <div class="para e147">In both cases, the Xerces J parser reports that there is not a complete functional
               mapping between the particles in the original model and the redefined model.
            </div>
            <div class="para e148">The solution is to refactor the sequence into a sequence of named groups. This allows
               the groups to be referenced from a redefinition, satisfying the requirement that a
               redefinition must include the thing being redefined:
               <div class="programlisting e149" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  
                  xmlns:s1="urn:example.com:schema-01" targetNamespace="urn:example.com:schema-01"&gt;
                  
                  &lt;xs:group name="A.grp"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:element ref="s1:A"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  &lt;xs:group name="B.grp"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:element ref="s1:B"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  &lt;xs:group name="C.grp"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:element ref="s1:C"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:complexType name="root.type"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:group ref="s1:A.grp"/&gt;
                  &lt;xs:group ref="s1:B.grp"/&gt;
                  &lt;xs:group ref="s1:C.grp"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:complexType&gt;
                  
                  &lt;xs:element name="root" type="s1:root.type"&gt; &lt;/xs:element&gt;
                  
                  &lt;xs:element name="A"&gt; &lt;/xs:element&gt;
                  &lt;xs:element name="B"&gt; &lt;/xs:element&gt;
                  &lt;xs:element name="C"&gt; &lt;/xs:element&gt;
                  
                  &lt;/xs:schema&gt;
               </div>
            </div>
            <div class="para e150">Note that the pattern of xs:sequence/xs:choice is required in order to control occurrence
               of the choice (e.g., to make the choice optional or repeatable).
            </div>
            <div class="para e151">The redefinition can then look like this:
               <div class="programlisting e152" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  xmlns:s1="urn:example.com:schema-01"
                  targetNamespace="urn:example.com:schema-01"
                  &gt;
                  
                  &lt;!-- Redefine of redefined schema 01 --&gt;
                  &lt;xs:redefine schemaLocation="redefined-schema-02.xsd"&gt;
                  &lt;xs:group name="B.grp"&gt;
                  &lt;xs:sequence&gt;         
                  &lt;xs:choice minOccurs="0" maxOccurs="0"&gt;
                  &lt;xs:group ref="s1:B.grp"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  &lt;/xs:redefine&gt;
                  &lt;/xs:schema&gt;
               </div>
            </div>
            <div class="para e153">In this case, making the "B" element effectively disallowed while maintaining the
               required particle-to-particle association.
            </div>
            <div class="para e154">This need for additional named groups for sequences within content models makes translating
               content models as normally formulated in DTD or RELAX NG grammars into XSD tedious
               at best and challenging at worst. It is not clear if there is a general algorithm
               for translating arbitrary content models with sequences into the necessary XSD groups
               in order to then enable arbitrary constraint via redefinition. In the case of the
               DITA XSDs, at least through DITA 1.2, this type of group refactoring has been done
               only as needed to support constraints defined by the DITA Technical Committee. This
               means that there are many element types that cannot be constrained using the XSD modules
               as provided by the DITA Technical Committee. This issue is explored in more detail
               below.
            </div>
         </div><a name="DITA12GroupDesignandXSDANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e155">
            <div class="title e156">DITA 1.2 Group Design and XSD</div>
            <div class="para e157">In DITA every base element type may be extended through the creation of "domain" element
               specializations such that anywhere the base element type is allowed the domain-defined
               specializations are also allowed.
            </div>
            <div class="para e158">This is implemented in all grammar languages by defining the base content models using
               references to some type of parameter that initially resolves to just the base element
               type but that may be redefined to expand to the base type and its domain-provided
               specializations. Document type shells may also omit the base type or any specialized
               type, effectively imposing a constraint on the base element type as part of the domain
               integration. For example, given a domain that specializes the general inline element
               type &lt;ph&gt;, you might allow only the specialized types and omit &lt;ph&gt;. The naming pattern
               used in all grammar languages  gives the parameter the same name as the element type,
               e.g., "%ph" in DTDs, &lt;define name="ph"&gt; in RELAX NG, and &lt;xs:group name="ph"&gt; in XSD.
               
            </div>
            <div class="para e159">For XSD this pattern means that there is one element-type-specific group for each
               element type defined in each vocabulary module. The base definition of each group
               simply allows the corresponding element:
               <div class="programlisting e160" xml:space="preserve">&lt;xs:group name="author"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:element ref="author"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
               </div>
            </div>
            <div class="para e161">For example, a domain could extend the &lt;author&gt; element by defining two specializations
               of &lt;author&gt;, say &lt;editor&gt; and &lt;primary-author&gt;. Within document type shell XSD documents
               that integrate this domain the "author" group is redefined like so:
               <div class="programlisting e162" xml:space="preserve">  &lt;xs:redefine schemaLocation="urn:oasis:names:tc:dita:xsd:metaDeclGrp.xsd"&gt;
                  &lt;xs:group name="author"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="author"/&gt;
                  &lt;xs:group ref="jrnlmeta-d-author" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group&gt;
                  &lt;/xs:redefine&gt;
               </div>
            </div>
            <div class="para e163">The group "jrnlmeta-d-author" is defined like so:
               <div class="programlisting e164" xml:space="preserve">  &lt;xs:group name="jrnlmeta-d-author"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:element ref="editor" /&gt;
                  &lt;xs:element ref="primary-author" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group&gt;
               </div>
            </div>
            <div class="para e165">This redefinition satisfies the particle preservation requirement of the redefine
               feature because the original particle "author" is maintained with additional new particles
               added within a choice group. 
            </div>
            <div class="para e166">Note that each element-type-specific group must itself require its contained choice
               group. If this were not the case it would be impossible to define content models that
               required elements. Thus the element-type-specific groups themselves cannot be used
               to work around the redefinition particle preservation requirement.
            </div>
         </div><a name="WorkingAroundRedefineLimitations:IndirectioninSequenceGroupsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e167">
            <div class="title e168">Working Around Redefine Limitations: Indirection in Sequence Groups</div>
            <div class="para e169">XSD redefinition is applied at the group level such that every particle in the original
               group must be represented in the redefined group. When the group defines a sequence
               it is not possible to redefine the sequence in order to omit tokens.
            </div>
            <div class="para e170">For example, the DITA &lt;prolog&gt; element uses this sequence group as its abstract content
               model:
            </div>
            <div class="programlisting e171" xml:space="preserve"> (author*, 
               source?, 
               publisher?,
               copyright*, 
               critdates?,
               permissions?, 
               metadata*, 
               resourceid*,
               (data.elements.incl | 
               foreign.unknown.incl)*)
            </div>
            <div class="para e172">Each element is optional. Per the rule for DITA constraints you can omit any optional
               element. This means that any restriction of the content model that omits one or more
               particles is a conforming constraint. 
            </div>
            <div class="para e173">If the XSD implementation of the content model is defined as a single group the resulting
               group is will not allow constraints that omit optional types:
               <div class="programlisting e174" xml:space="preserve">&lt;xs:sequence&gt;
                  &lt;xs:group ref="author" minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;xs:group ref="source" minOccurs="0"/&gt;
                  &lt;xs:group ref="publisher" minOccurs="0"/&gt;
                  &lt;xs:group ref="copyright" minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;xs:group ref="critdates" minOccurs="0"/&gt;
                  &lt;xs:group ref="permissions" minOccurs="0"/&gt;
                  &lt;xs:group ref="metadata" minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;xs:group ref="resourceid" minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
                  &lt;xs:group ref="data.elements.incl"/&gt;
                  &lt;xs:group ref="foreign.unknown.incl"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
               </div>
            </div>
            <div class="para e175">The general solution is to add another layer of grouping such that for each contiguous
               sequence of omittable elements there is a group whose content is an emptiable choice
               or sequence.
            </div>
            <div class="para e176">For example, the base content model for the DITA &lt;taskbody&gt; element is:
               <div class="programlisting e177" xml:space="preserve">((prereq | 
                  context |
                  section)*,
                  (steps | 
                  steps-unordered |
                  steps-informal)?, 
                  result?, 
                  example*, 
                  postreq*)      
               </div>
            </div>
            <div class="para e178">The DITA standard defines a constraint on this content model, the "strict task" constraint,
               which omits the &lt;section&gt; and &lt;steps-informal&gt; elements. 
            </div>
            <div class="para e179">If the XSD implementation of this content model were simply the equivalent sequence
               group, it would not be constrainable because the particle preservation rule does not
               allow omission of the &lt;section&gt; or &lt;steps-informal&gt; groups.
            </div>
            <div class="para e180">One solution is to insert three groups: one for the elements before &lt;steps&gt;, one for
               the &lt;steps&gt; optional choice group, and one for the elements after &lt;steps&gt;:
               <div class="programlisting e181" xml:space="preserve">  &lt;xs:group name="taskbody.content"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:group ref="taskPreStep"/&gt;
                  &lt;xs:group ref="taskStep"/&gt;
                  &lt;xs:group ref="taskPostStep"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="taskPreStep"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
                  &lt;xs:group ref="context" minOccurs="0"/&gt;
                  &lt;xs:group ref="prereq"  minOccurs="0"/&gt;
                  &lt;xs:group ref="section" minOccurs="0"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="taskPostStep"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:group ref="result"  minOccurs="0"/&gt;
                  &lt;xs:group ref="example"  minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;xs:group ref="postreq"  minOccurs="0" maxOccurs="unbounded"/&gt;  
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="taskStep"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:choice minOccurs="0" maxOccurs="1"&gt;
                  &lt;xs:group ref="steps" /&gt;
                  &lt;xs:group ref="steps-unordered" /&gt;
                  &lt;xs:group ref="steps-informal" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:group&gt;
               </div>
            </div>
            <div class="para e182">This extra level of grouping enables the constraint for &lt;taskbody&gt;. However, no other
               sequence group content model in the DITA 1.2 XSD schemas provides a comparable set
               of emptiable groups, meaning that more than 150 element types in the DITA 1.2 base
               vocabulary are not constrainable without first modifying the OASIS-provided XSDs,
               which violates the basic DITA principle that all copies of a given vocabulary module
               are identical.
            </div>
            <div class="para e183">This presents an implementation challenge for the XSD generation process: is there
               a general algorithm that will generate constrainable model groups that allow any valid
               constraint (in particular, allowing removal of optional elements?
            </div>
         </div><a name="DeclarationsforIntegratingDomainElementTypesinXSDDocumentTypeShellsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e184">
            <div class="title e185">Declarations for Integrating Domain Element Types in XSD Document Type Shells</div>
            <div class="para e186">Domain-provided specialized element types are integrated through redefinitions specified
               in document type shells. The markup itself is not particularly complicated, but it
               must be specified in every document type shell that integrates a given domain.  Domain-provided
               elements types are "mix-in" elements, meaning that the domain-provided elements must
               be allowed wherever the element they specialize is allowed. Conceptually this is equivalent
               to an XSD substitution group. However, it appears that XSD substitution groups do
               not work reliably for this and thus are not used by the DITA XSDs.
            </div>
            <div class="para e187">Because the integration of each domain requires explicit redefinition in the XSD document
               type shell, XSD domains are not self integrating.
            </div>
            <div class="para e188">The names of the groups to be referenced in the redefined groups are determined by
               the short name of each integrated domain. The DITA XSD coding requirements specify
               that the domain integration groups must be named such that, given the domain short
               name, you can reliably construct the domain integration group name.
            </div>
            <div class="para e189">A typical document type shell is the OASIS-provided concept topic type shell:
               <div class="programlisting e190" xml:space="preserve">  &lt;xs:redefine schemaLocation="urn:oasis:names:tc:dita:xsd:commonElementGrp.xsd:1.2"&gt;
                  &lt;xs:group name="keyword"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="keyword"/&gt;
                  &lt;xs:group ref="pr-d-keyword" /&gt;
                  &lt;xs:group ref="ui-d-keyword" /&gt;
                  &lt;xs:group ref="sw-d-keyword" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="ph"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="ph"/&gt;
                  &lt;xs:group ref="pr-d-ph" /&gt;
                  &lt;xs:group ref="ui-d-ph" /&gt;
                  &lt;xs:group ref="hi-d-ph" /&gt;
                  &lt;xs:group ref="sw-d-ph" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="pre"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="pre"/&gt;
                  &lt;xs:group ref="pr-d-pre" /&gt;
                  &lt;xs:group ref="ui-d-pre" /&gt;
                  &lt;xs:group ref="sw-d-pre" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group&gt;
                  
                  &lt;xs:group name="dl"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="dl"/&gt;
                  &lt;xs:group ref="pr-d-dl"/&gt;
                  &lt;/xs:choice &gt;
                  &lt;/xs:group &gt;
                  
                  &lt;xs:group name="fig"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="fig"/&gt;
                  &lt;xs:group ref="pr-d-fig"/&gt;
                  &lt;xs:group ref="ut-d-fig" /&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group &gt;
                  
                  &lt;xs:group name="index-base"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="index-base"/&gt;
                  &lt;xs:group ref="indexing-d-index-base"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group &gt;
                  
                  &lt;xs:group name="note"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="note"/&gt;
                  &lt;xs:group ref="hazard-d-note"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group &gt;
                  
                  &lt;xs:group name="term"&gt;
                  &lt;xs:choice&gt;
                  &lt;xs:group ref="term"/&gt;
                  &lt;xs:group ref="abbrev-d-term"/&gt;
                  &lt;/xs:choice&gt;
                  &lt;/xs:group &gt;
                  
                  &lt;/xs:redefine&gt;
               </div>
            </div>
         </div>
      </div><a name="HowRELAXNGAddressesDITARequirementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e191">
         <div class="title e192">How RELAX NG Addresses DITA Requirements</div>
         <div class="para e193">RELAX NG provides an almost ideal match of syntax and semantics to DITA vocabulary
            architecture requirements:
         </div>
         <div class="itemizedlist e194">
            <div class="listitem e195">
               <div class="para e196">The RELAX NG pattern approach is a good match to DTD semantics and thus to DITA semantics.</div>
            </div>
            <div class="listitem e197">
               <div class="para e198">The ability to extend patterns unilaterally makes modules self-integrating, reducing
                  the complexity of document type shells.
               </div>
            </div>
            <div class="listitem e199">
               <div class="para e200">RELAX NG's XML syntax plus semantic match to DTDs makes generating conforming DITA
                  DTDs practical.
               </div>
            </div>
            <div class="listitem e201">
               <div class="para e202">RELAX NG's XML syntax makes generating XSDs practical, if challenging due to requirements
                  for XSDs.
               </div>
            </div>
         </div>
         <div class="para e203">The use of RELAX NG for DITA does require two things not in the base RELAX NG standard:
            <div class="itemizedlist e204">
               <div class="listitem e205">
                  <div class="para e206">Attribute default values. These are provided for by the companion RELAX NG DTD Compatibility
                     standard. One of us (Bina) implemented support for attribute defaults as an enhancement
                     to the open-source JING library, making RELAX NGs directly usable for DITA document
                     processing in any Java processing environment. 
                  </div>
               </div>
               <div class="listitem e207">
                  <div class="para e208">DITA-specific metadata for vocabulary and constraint modules and document type shells.
                     DITA-specific metadata is required in order to enable generation of DTD and XSD versions
                     of the RELAX NG document type shells and modules, such as the public IDs to use for
                     specific generated modules, the module types, and module short names, as well as DITA-specific
                     properties for individual element types, such as a long name and the initial DITA
                     versions for patterns and pattern components.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e209">The one tedious aspect of RELAX NG that adds complexity to the DITA document type
            shells is the need to have special declarations in the shell for elements that define
            @id attributes of type "ID". 
         </div>
         <div class="para e210">In DITA most elements define the @id attribute as NMTOKEN rather than as an XML ID.
            However, some element types, in particular, &lt;topic&gt; and all specializations of &lt;topic&gt;,
            use XML IDs. RELAX NG's rules for "any" patterns do not allow two different element
            types to have different datatypes for the same attribute. DITA document type shells
            must work around this by redefining the "any" patterns to explicitly exclude those
            element types or foreign namespaces that define @id attributes as type ID. However,
            for most shells this redefinition is the same except for the tagnames of the topic
            types defined or included in the shell. 
         </div>
         <div class="para e211">The only other component of document type shells that must be set manually is the
            value of the @domains attribute for the root topic or map element defined by the shell
            as RELAX NG provides no way to dynamically construct the pattern for attribute defaults.
            However, each vocabulary and constraint module declares its @domains contribution
            in DITA-specific metadata. The DITA Technical Committee provides a simple XQuery script
            that updates the value of the @domains attribute to reflect the modules actually included,
            removing the need to manually set and maintain the @domains value.
         </div><a name="RELAXNGisaGoodMatchtoDTDsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e212">
            <div class="title e213">RELAX NG is a Good Match to DTDs</div>
            <div class="para e214">The RELAX NG pattern approach, as opposed to the XSD type/element approach, provides
               a close semantic and syntactic match to XML DTDs, making it relatively easy for DTD
               authors to transition to RELAX NG as their grammar language. There is an almost one-to-one
               correspondence between DTD syntactic constructs and RELAX NG grammar components. This
               makes it relatively easy to translate existing DTD-syntax vocabulary modules into
               the equivalent RELAX NG grammars. It also allows the DITA-defined RELAX NG coding
               requirements to be as close to the DTD coding requirements as possible, maximizing
               the applicability of existing DTD coding knowledge to DITA RELAX NG grammars.
            </div>
            <div class="para e215">The RELAX NG compact syntax is also syntactically similar to DTD syntax. The compact
               syntax is less convenient for DITA vocabularies because DITA grammars do require use
               of non-RELAX NG elements and attributes but it is still usable as RELAX NG provides
               ways of encoding foreign elements and attributes in the compact syntax. The DITA Technical
               Committee generates RELAX NG compact syntax versions of all the TC-defined DITA vocabulary.
            </div>
         </div><a name="ModulesareSelfIntegratingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e216">
            <div class="title e217">Modules are Self Integrating</div>
            <div class="para e218">The most dramatic advantage of RELAX NG over both DTD and XSD is the ability for one
               pattern to unilaterally extend another pattern. This allows DITA domain modules to
               automatically extend the patterns for the base elements those domains specialize.
               
            </div>
            <div class="para e219">As for DTDs and XSDs, each element type is represented by a pattern whose name is
               the same as the element type:
               <div class="programlisting e220" xml:space="preserve">  &lt;define name="ph"&gt;
                  &lt;ref name="ph.element"/&gt;
                  &lt;/define&gt;
               </div>
            </div>
            <div class="para e221">The domain specialization of a given element simply extends the element-type pattern
               to add the specializations provided by the domain:
               <div class="programlisting e222" xml:space="preserve">    &lt;define name="hi-d-ph"&gt;
                  &lt;choice&gt;
                  &lt;ref name="b.element"/&gt;
                  &lt;ref name="i.element"/&gt;
                  &lt;ref name="line-through.element" dita:since="1.3"/&gt;
                  &lt;ref name="overline.element" dita:since="1.3"/&gt;
                  &lt;ref name="sup.element"/&gt;
                  &lt;ref name="sub.element"/&gt;
                  &lt;ref name="tt.element"/&gt;
                  &lt;ref name="u.element"/&gt;
                  &lt;/choice&gt;
                  &lt;/define&gt;
                  
                  &lt;define name="ph" combine="choice"&gt;
                  &lt;ref name="hi-d-ph"/&gt;
                  &lt;/define&gt;
               </div>
            </div>
            <div class="para e223">The 
               <div class="code e224">combine="choice"</div> on the domain-specific definition of the "ph" pattern in this example makes the effective
               value of the "ph" pattern the base tokens plus all the tokens defined in the "hi-d-ph"
               pattern. This corresponds directly to the domain integration parameter entities in
               DTDs and domain integration redefines in XSDs, but requires no additional work in
               document type shells.
            </div>
            <div class="para e225">The document type shell can then be a simple set of module inclusions. This eliminates
               almost all of the complexity and opportunity for error of DTD and XSD document type
               shells. In short, it makes creating DITA document type shells about as easy as it
               could possibly be.
            </div>
         </div><a name="DTDandXSDGenerationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e226">
            <div class="title e227">DTD and XSD Generation</div>
            <div class="para e228">While RELAX NG has many advantages for DITA vocabulary authors the DITA community
               still requires DTDs and, to a lesser extent, XSDs. Almost all DITA-aware tools are
               DTD-aware and a few are XSD-only. Few support use of RELAX NG today. Thus the DITA
               Technical Committee must continue to provide DTD and XSD versions of all TC-defined
               vocabulary. In addition, these DTDs and XSDs must themselves conform to the DITA coding
               requirements for DTDs.
            </div>
            <div class="para e229">One of us (Kimber) has implemented XSLT-based transforms to generate conforming DTD,
               XSD, and RELAX NG compact syntax modules and shells from the RELAX NG XML syntax modules.
               These transforms allow the DITA Technical Committee to make the RELAX NG vocabulary
               the authoritative master from which all other forms are generated, significantly reducing
               the cost of maintaining multiple grammar formats for the DITA vocabulary.
            </div>
         </div>
      </div><a name="ConclusionsandFutureWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e230">
         <div class="title e231">Conclusions and Future Work</div>
         <div class="para e232">As an alternative to DTDs, RELAX NG has proven to be superior to XSD in almost every
            way. It is provides a good semantic and syntactic match to DTDs. It's rules for extending
            and overriding patterns work well for DITA's specialization and constraint features.
            It's XML syntax makes implementing generation of other formats practical using normal
            XML tools (XSLT, XQuery). The ability to unilaterally extend patterns makes RELAX
            NG document type shells about as easy as it can be. Even if used only as a source
            for then generating the DTDs and XSDs used with DITA processing tools, RELAX NG offers
            significant benefits to DITA document type shell and module authors.
         </div>
         <div class="para e233">Through this experience we have identified potential improvements to RELAX NG that
            would make its use even simpler:
            <div class="itemizedlist e234">
               <div class="listitem e235">
                  <div class="para e236">Relax the constraints on attribute types within "any" patterns.</div>
               </div>
               <div class="listitem e237">
                  <div class="para e238">Provide a mechanism for dynamically constructing attribute value defaults</div>
               </div>
            </div>
         </div>
         <div class="para e239">With these two refinements, DITA modules would be complete self-integrating, making
            DITA document type shells truly just inclusion lists of modules.
         </div>
         <div class="para e240">The question of generation of constrainable XSD content models remain open. More thought
            and experimentation is required but at the time of writing it is not clear that a
            general algorithm for translating sequence groups to the necessary XSD groups is either
            possible or desirable. In addition, it is not clear that there is sufficient use of
            XSDs within the DITA community with non-TC-provided constraints to justify the effort
            of trying to generate constrainable XSDs. One piece of evidence that this is the case
            is the fact that the issue with the general lack of constrainability was not discovered
            until we started implementing the XSD generation process, meaning that no DITA user
            reported any issue with XSD constraints between the time DITA 1.1 was released and
            now. Either nobody tried to implement constraints of sequence groups using XSDs in
            that time or anyone who did simply modified their TC-provided XSD files locally and
            never reported the issue to the DITA Technical Committee or to the DITA community
            at large.
         </div>
         <div class="para e241">At the time of writing the decision of the DITA Technical Committee is to generate
            the DITA 1.3 XSDs using the same content model patterns as for DITA 1.2, treating
            those content models that require constraint (e.g., taskbody) as special cases within
            the XSD generation transform. Because the XSDs are generated the Technical Committee
            can add additional special cases as required, replace the use of Redefine with Override,
            or improve the general model generation algorithm.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e242">
         <div class="title e243">Bibliography</div>
         <div class="bibliomixed e244" xml:id="dita-std">
            <div class="emphasis e245">Darwin Information Typing Architecture</div>, OASIS Open. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e246" xlink:actuate="onRequest" xlink:href="http://docs.oasis-open.org/dita/v1.2/os/spec" xlink:show="new" xlink:type="simple">http://docs.oasis-open.org/dita/v1.2/os/spechttp://docs.oasis-open.org/dita/v1.2/os/spec</div>
         </div>
         <div class="bibliomixed e247" xml:id="xml-std">
            <div class="emphasis e248">Extensible Markup Language</div>, W3C. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e249" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml11/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml11/</div>
         </div>
         <div class="bibliomixed e250" xml:id="relaxng-std">
            <div class="emphasis e251">RELAX NG</div>, OASIS Open. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e252" xlink:actuate="onRequest" xlink:href="http://relaxng.org/spec-20011203.html" xlink:show="new" xlink:type="simple">http://relaxng.org/spec-20011203.html</div>
         </div>
         <div class="bibliomixed e253" xml:id="rng-dtd-compat-std">
            <div class="emphasis e254">RELAX NG DTD Compatibility</div>, OASIS Open. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e255" xlink:actuate="onRequest" xlink:href="http://relaxng.org/compatibility-20011203.html" xlink:show="new" xlink:type="simple"></div>
         </div>
         <div class="bibliomixed e256" xml:id="xsd-std1.1">
            <div class="emphasis e257">XML Schema Part 1: Structures Second Edition</div>, W3C. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e258" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</div>
         </div>
         <div class="bibliomixed e259">
            <div class="emphasis e260">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures</div>, W3C. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e261" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-1" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema11-1</div>
         </div>
      </div>
   </div>
</div>