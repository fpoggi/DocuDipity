<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#FreedomtoConstrainANCHOR" name="FreedomtoConstrainTOC">Freedom to Constrain</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#UseCaseANCHOR" name="UseCaseTOC">Use Case</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BackgroundANCHOR" name="BackgroundTOC">Background</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OpenvsClosedvsExtensibleSchemasANCHOR" name="OpenvsClosedvsExtensibleSchemasTOC">Open vs Closed vs Extensible Schemas</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#LiterateEncodingANCHOR" name="LiterateEncodingTOC">Literate Encoding</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntheClosedSchema(RELAXNGfile)ANCHOR" name="IntheClosedSchema(RELAXNGfile)TOC">In the Closed Schema (RELAX NG file)</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#howANCHOR" name="howTOC">how</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#advantagesANCHOR" name="advantagesTOC">advantages</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#disadvantagesANCHOR" name="disadvantagesTOC">disadvantages</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntheOpenSchema(ISOSchematron)ANCHOR" name="IntheOpenSchema(ISOSchematron)TOC">In the Open Schema (ISO Schematron)</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntheMetaschema(ODDfile)ANCHOR" name="IntheMetaschema(ODDfile)TOC">In the Metaschema (ODD file)</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#howANCHOR" name="howTOC">how</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#advantagesANCHOR" name="advantagesTOC">advantages</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#disadvantagesANCHOR" name="disadvantagesTOC">disadvantages</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntheMetadata()ANCHOR" name="IntheMetadata()TOC">In the Metadata ()</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#how%E2%80%94pointingANCHOR" name="how%E2%80%94pointingTOC">how — pointing</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#advantagesANCHOR" name="advantagesTOC">advantages</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#disadvantagesANCHOR" name="disadvantagesTOC">disadvantages</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#how%E2%80%94coreferenceANCHOR" name="how%E2%80%94coreferenceTOC">how — co-reference</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntheMetadata(separatefile)ANCHOR" name="IntheMetadata(separatefile)TOC">In the Metadata (separate file)</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#<codeGrp&gt;toSchematronANCHOR" name="<codeGrp&gt;toSchematronTOC">&lt;codeGrp&gt; to Schematron</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">attributes=</div>
         <div class="singletermTERMS">attrVal=</div>
         <div class="singletermTERMS">attribute=</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
         <div class="singletermTERMS">attribute</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bar=</div>
         <div class="singletermTERMS">bill=</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
         <div class="singletermTERMS">Bauman</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">constrain your data early and often</div>
         <div class="singletermTERMS">Computers and the Humanities</div>
         <div class="singletermTERMS">constraint</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">elementTypes=</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">how</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Literate Programming</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">material=</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">ODD</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">person</div>
         <div class="singletermTERMS">place</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">ship</div>
         <div class="singletermTERMS">sword</div>
         <div class="singletermTERMS">Syd’s rule</div>
         <div class="singletermTERMS">Syd_Bauman@Brown.edu</div>
         <div class="singletermTERMS">Syd</div>
         <div class="singletermTERMS">Senior Programmer/Analyst</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">type=</div>
         <div class="singletermTERMS">tangle</div>
         <div class="singletermTERMS">this</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">TEI</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xml:id=</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="FreedomtoConstrainANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="Bal2008Baum1020">
      <div class="title e1">Freedom to Constrain</div>
      <div class="subtitle e2">where does attribute constraint come from, mommy?</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2008</div>
            <div class="confdates e6">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">Where should attribute constraints live? In an external schema? In the document’s
               own
               metadata? In a separate file? Several possibilities are examined, raising lots of
               questions
               and offering a few answers.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Syd</div>
               <div class="surname e12">Bauman</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Syd Bauman is the technical person at the Brown University Women Writers Project,
                  where he has worked since 1990, designing and maintaining a significantly extended
                  TEI-conformant schema for encoding early printed books. He has served as the North
                  American Editor of the Text Encoding Initiative Guidelines, has an AB from Brown
                  University in political science, and has worked as an Emergency Medical Technician
                  since
                  1983.
               </div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Senior Programmer/Analyst</div>
               <div class="orgname e17">Brown University Women Writers Project</div>
            </div>
            <div class="email e18">Syd_Bauman@Brown.edu</div>
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e19" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.stg.brown.edu/staff/syd.html</div>
         </div>
         <div class="legalnotice e20">
            <div class="para e21">Copyright © 2008 Syd Bauman. Some rights reserved.</div>
         </div>
         <div class="keywordset e22" role="author">
            <div class="keyword e23">XML</div>
            <div class="keyword e24">attribute</div>
            <div class="keyword e25">TEI</div>
            <div class="keyword e26">ODD</div>
            <div class="keyword e27">constraint</div>
         </div>
      </div>
      <div class="para e28">It is clear that constraining document structure is a very
         important part of document production. We test whether or not our
         XML documents are properly constrained through the process of
         validation. 
         <div class="quote e29">The … purpose of validation is to subject a
            document … to a test, to determine whether it conforms to a given
            set of external criteria. … Our need to test is simply explained and
            understood (so much so that it rarely needs to be explicated): if
            there exists a point in a process where it is less expensive to
            discover and correct problems than it is to save the work of testing
            and fix at later points, it is profitable to introduce a
            test.
         </div>
         <div class="popupBox e30">
            <div class="popupLabel" onmouseover="$('#d1e51').show('1000');" onmouseout="$('#d1e51').hide('1000');">[ footnote ]</div>
            <div id="d1e51" style="display: none;">
               <div class="footnote">
                  <div class="para e31">Piez, Wendell, “Beyond the ‘descriptive
                     vs. procedural’ distinction”, presented at Extreme Markup Languages
                     2001, Montréal, Canada. 
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e32" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/extreme/proceedings/html/2001/Piez01/EML2001Piez01.html" xlink:show="new" xlink:type="simple">http://www.idealliance.org/papers/extreme/proceedings/html/2001/Piez01/EML2001Piez01.html</div>.
                     
                  </div>
               </div>
            </div>
         </div>
         
      </div>
      <div class="para e33">Michael Sperberg-McQueen may have summed this importance up
         best when he advised 
         <div class="quote e34">constrain your data early and
            often
         </div>, which he often did.
         <div class="popupBox e35">
            <div class="popupLabel" onmouseover="$('#d1e63').show('1000');" onmouseout="$('#d1e63').hide('1000');">[ footnote ]</div>
            <div id="d1e63" style="display: none;">
               <div class="footnote">
                  <div class="para e36">Sperberg-McQueen,
                     C. Michael. Oral conversation, and multiple oral presentations
                     throughout the 1990s. See, e.g., 
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e37" xlink:actuate="onRequest" xlink:href="http://www.w3.org/People/cmsmcq/2001/darmstadt.html" xlink:show="new" xlink:type="simple">http://www.w3.org/People/cmsmcq/2001/darmstadt.html</div>.
                  </div>
               </div>
            </div>
         </div>
         (It helped that he lived in Chicago at the time.)
      </div>
      <div class="para e38">So it is obvious that constraints need to be expressed in a
         formal language of some sort. Many such general-purpose formal
         languages are available, including closed schema languages like DTDs
         and RELAX NG, and open schema languages like Schematron and CLiX.
         Furthermore at least one literate encoding language exists in which
         such constraints along with documentation about them can be
         expressed. This language is called ODD (for “one document does it
         all”) — constraints expressed in other languages (DTDs, RELAX NG, or
         XML Schema; in theory others as well) can be derived from a set of
         constraints expressed in ODD.
         <div class="popupBox e39">
            <div class="popupLabel" onmouseover="$('#d1e72').show('1000');" onmouseout="$('#d1e72').hide('1000');">[ footnote ]</div>
            <div id="d1e72" style="display: none;">
               <div class="footnote">
                  <div class="para e40">Burnard, Lou and Syd Bauman, eds. “4.3.2 Floating Texts.”
                     
                     <div class="emphasis e41">TEI P5: Guidelines for Electronic Text Encoding and
                        Interchange
                     </div>. Version 1.1.0. 2008-07-04. TEI Consortium.
                     
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e42" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/html/DS.html#DSFLT " xlink:show="new" xlink:type="simple">http://www.tei-c.org/release/doc/tei-p5-doc/html/DS.html#DSFLT
                        
                     </div>  2008-08-30
                  </div>
               </div>
            </div>
         </div>
         <div class="popupBox e43">
            <div class="popupLabel" onmouseover="$('#d1e81').show('1000');" onmouseout="$('#d1e81').hide('1000');">[ footnote ]</div>
            <div id="d1e81" style="display: none;">
               <div class="footnote">
                  <div class="para e44">Burnard, Lou and Syd Bauman, eds. “23.4 Implementation of an ODD System.”
                     
                     <div class="emphasis e45">TEI P5: Guidelines for Electronic Text Encoding and
                        Interchange
                     </div>. Version 1.1.0. 2008-07-04. TEI Consortium.
                     
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e46" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html#IM " xlink:show="new" xlink:type="simple">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/USE.html#IM
                        
                     </div>  2008-08-30
                  </div>
               </div>
            </div>
         </div>
         <div class="popupBox e47">
            <div class="popupLabel" onmouseover="$('#d1e90').show('1000');" onmouseout="$('#d1e90').hide('1000');">[ footnote ]</div>
            <div id="d1e90" style="display: none;">
               <div class="footnote">
                  <div class="para e48">Sperberg-McQueen, C. Michael and Lou Burnard. “The Design of
                     the TEI Encoding Scheme.” 
                     <div class="emphasis e49">Computers and the
                        Humanities
                     </div> 1995. 29 (1) p. 17–39. doi:10.1007/BF01830314
                  </div>
               </div>
            </div>
         </div>
         <div class="popupBox e50">
            <div class="popupLabel" onmouseover="$('#d1e96').show('1000');" onmouseout="$('#d1e96').hide('1000');">[ footnote ]</div>
            <div id="d1e96" style="display: none;">
               <div class="footnote">
                  <div class="para e51">Burnard, Lou, Sebastian Rahtz. “RelaxNG
                     with Son of ODD”, presented at Extreme Markup Languages 2004,
                     Montréal, Canada. 
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e52" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/Extreme/Proceedings/html/2004/Burnard01/EML2004Burnard01.pdf" xlink:show="new" xlink:type="simple">http://www.mulberrytech.com/Extreme/Proceedings/html/2004/Burnard01/EML2004Burnard01.pdf</div>.
                     
                  </div>
               </div>
            </div>
         </div>
         Furthermore there are systems of constraint based on special-purpose
         languages, rather than general-purpose languages. The feature system
         declaration created by the Text Encoding Initiative (TEI) and now
         being incorporated into ISO 24610-2 is an example — a set of XML
         elements (the feature system declaration) that can be used to
         constrain the expression of another set of XML elements (the feature
         structure itself).
         <div class="popupBox e53">
            <div class="popupLabel" onmouseover="$('#d1e103').show('1000');" onmouseout="$('#d1e103').hide('1000');">[ footnote ]</div>
            <div id="d1e103" style="display: none;">
               <div class="footnote">
                  <div class="para e54">Burnard, Lou and Syd Bauman, eds. “18 Feature Structures”
                     
                     <div class="emphasis e55">TEI P5: Guidelines for Electronic Text Encoding and
                        Interchange
                     </div>. Version 1.1.0. 2008-07-04. TEI Consortium.
                     
                     <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e56" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/FS.html   " xlink:show="new" xlink:type="simple">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/FS.html</div>
                     2008-08-30
                  </div>
               </div>
            </div>
         </div>
      </div>
      <div class="para e57">So the choice of 
         <div class="emphasis e58">how</div> to express a
         particular constraint is not always obvious. But a related question
         is perhaps just as important: 
         <div class="emphasis e59">where</div> should
         these constraints be expressed? What are the consequences of
         expressing them in different places?
      </div>
      <div class="para e60">This paper will attempt to shed light on these general
         questions by taking an in-depth look at the possible locations for
         the expression of one particular kind of constraint, and the
         consequences of those different locations. The constraint discussed
         will be that of limiting the value an attribute may take to one of
         an enumerated list of possible values. For simplicity the presumed
         setting for this constraint will be in a TEI document, but the
         principles should be equally applicable to any other encoding
         language that separates the document from its metadata, including
         DocBook or XHTML. The locations considered will be
         
         <div class="itemizedlist e61">
            <div class="listitem e62">
               <div class="para e63">the “normal” way, in the formal closed schema (RELAX NG
                  will be used as the example)
               </div>
            </div>
            <div class="listitem e64">
               <div class="para e65">in a formal open schema (ISO Schematron will be used as the example)</div>
            </div>
            <div class="listitem e66">
               <div class="para e67">in the metadata element (i.e.
                  
                  <div class="code e68">&lt;teiHeader&gt;</div>)
               </div>
            </div>
            <div class="listitem e69">
               <div class="para e70">in a separate metadata file</div>
            </div>
            <div class="listitem e71">
               <div class="para e72">in the metaschema file (i.e. the ODD file)</div>
            </div>
            <div class="listitem e73">
               <div class="para e74">no formal constraint</div>
            </div>
         </div>
         Each of the latter methods will be compared to and contrasted with
         the first.
      </div><a name="UseCaseANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e75" xml:id="uc">
         <div class="title e76">Use Case</div>
         <div class="para e77">There are lots of reasons to wish to constrain markup
            constructs, in particular attribute values. One case worth
            considering is the markup project which has tens or hundreds of
            occurrences of a particular attribute in each of tens or hundreds
            of files, where the list of possible values for the attribute is
            different for each file.
         </div>
         <div class="para e78">Imagine, e.g., an epigraphy project transcribing thousands
            of inscriptions on various objects. Imagine further that the
            inscriptions are divided among 27 separate files, organized by
            some criteria other than the kind of object that bears the
            inscription (e.g. date the object was discovered, current museum in
            which it is held, whatever). That which the text bearing object is
            made of is recorded in a TEI manuscript description on the
            
            <div class="code e79">material=</div> attribute of the
            
            <div class="code e80">&lt;supportDesc&gt;</div> element. Possible values might
            include 
            <div class="code e81">"bronze"</div>, 
            <div class="code e82">"marble"</div>,
            
            <div class="code e83">"limestone"</div>, 
            <div class="code e84">"plaster"</div>,
            
            <div class="code e85">"wood"</div>, etc.
         </div>
         <div class="para e86">Such a typical humanities computing project is likely to have:
            
            <div class="itemizedlist e87">
               <div class="listitem e88">
                  <div class="para e89">a subject matter expert</div>
               </div>
               <div class="listitem e90">
                  <div class="para e91">an XML expert</div>
               </div>
               <div class="listitem e92">
                  <div class="para e93">encoders — getting the extant text into
                     XML-encoded digital form may be accomplished in a variety of
                     ways:
                     
                     <div class="itemizedlist e94">
                        <div class="listitem e95">
                           <div class="para e96">typed from source</div>
                        </div>
                        <div class="listitem e97">
                           <div class="para e98">post-OCR editing</div>
                        </div>
                        <div class="listitem e99">
                           <div class="para e100">via an external vendor</div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e101">
                  <div class="para e102">proofreaders, managers, web designers, research assistants, etc.</div>
               </div>
            </div>
            
         </div>
      </div><a name="BackgroundANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e103">
         <div class="title e104">Background</div><a name="OpenvsClosedvsExtensibleSchemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e105">
            <div class="title e106">Open vs Closed vs Extensible Schemas</div>
            <div class="para e107">Formal schema languages can generally be categorized into
               one of two types: open or closed. A closed schema language like
               RELAX NG specifies a complete document grammar. Only those
               documents that meet all of the constraints of the grammar are
               considered valid; all others are rejected as invalid.
            </div>
            <div class="para e108">An open schema language, like Schematron, specifies
               particular rules. Documents that violate the specified rules are
               rejected as invalid; all others are accepted as valid.
            </div>
            <div class="para e109">One can think of closed schema languages as a white list
               spam filter, and closed schema languages as a black list spam
               filter. Using a white list (closed schema language) only e-mail
               from the addresses specified get through, all others are
               rejected as spam. Using a black list (open schema language) any
               e-mail that is on the list of problematic addresses is rejected
               as spam, all others are allowed through.
            </div>
            <div class="para e110">Of course the situation is not as simple as that. One can
               specify some open constructs in many closed schema languages,
               and one can write sufficiently tight rules in most open
               languages that they behave like a closed language.
            </div>
            <div class="para e111">For example, validation against the following complete
               RELAX NG grammar will permit any XML document as long as it has
               a 
               <div class="code e112">&lt;foo&gt;</div> element with a 
               <div class="code e113">bar=</div>
               attribute as the first child of the root element.
               
               <div class="programlisting e114" xml:space="preserve">start = element * { any_attribute*, foo, any_element* }
                  any_attribute = attribute * { text }
                  any_element = element * { any* }
                  any = ( any_attribute | any_element | text )
                  any_sans_bar = ( attribute * - ( bar ) { text } | any_element | text )
                  foo = element foo { attribute bar { text }, any_sans_bar* }
               </div>
               
            </div>
            <div class="para e115">Conversely, validation against the following Schematron
               rule will permit only those documents that have one
               
               <div class="code e116">&lt;platypus&gt;</div> element with a 
               <div class="code e117">bill=</div>
               attribute that has the value 
               <div class="code e118">"duck"</div> as the only
               child of the root 
               <div class="code e119">&lt;enigma&gt;</div> element.
               
               <div class="programlisting e120" xml:space="preserve">  &lt;pattern&gt;
                  &lt;rule context="/*"&gt;
                  &lt;assert test="name(.)='enigma'"&gt;Root element must be "enigma"&lt;/assert&gt;
                  &lt;report test="@*"&gt;Root "enigma" element can not have attributes&lt;/report&gt;
                  &lt;assert test="count(child::*)=1"&gt;"enigma" can only have one child 
                  ("platypus")&lt;/assert&gt;
                  &lt;assert test="count(child::platypus)=1"&gt;"enigma" can only have one 
                  "platypus" child&lt;/assert&gt;
                  &lt;report test="child::text()[not(normalize-space(.)='')]"&gt;"enigma" is 
                  not allowed to have text, just "platypus"&lt;/report&gt;
                  &lt;/rule&gt;
                  &lt;rule context="/enigma/platypus"&gt;
                  &lt;assert test="@*[name(.)='bill']"&gt;"platypus" must have a bill= 
                  attribute&lt;/assert&gt;
                  &lt;report test="@*[not(name(.)='bill')]"&gt;"platypus" must not have any 
                  attributes other than bill=&lt;/report&gt;
                  &lt;report test="child::*"&gt;"platypus" must be empty (i.e., can not have 
                  child elements)&lt;/report&gt;
                  &lt;assert test="string-length( normalize-space(.) ) = 0"&gt;"platypus" 
                  must be empty (i.e., can not contain text)&lt;/assert&gt;
                  &lt;/rule&gt;
                  &lt;rule context="/enigma/platypus/@bill"&gt;
                  &lt;assert test="normalize-space(.)='duck'"&gt;The value of bill= of 
                  "platypus" must be 'duck'&lt;/assert&gt;
                  &lt;/rule&gt;
                  &lt;/pattern&gt;
               </div>
               
            </div>
            <div class="para e121">These reverse uses of open and closed schema languages may
               be thought of as analogous to black-list or white-list spam
               filters that permit wildcards.
            </div>
            <div class="para e122">Neither of the above examples are particularly good ways
               of performing the desired validation, but they serve as
               proofs-of-concept that when we refer to a schema language as
               “open” or “closed”, we may be referring to its default, and not
               its only, behavior.
            </div>
            <div class="para e123">There is one further twist worth mentioning. Some modular
               XML document systems, including DocBook and TEI, permit a user
               of the system to generate (closed) schemas that contain not only
               the element and attribute declarations native to the system, but
               also additional declarations for constructs added by the
               user.
            </div>
         </div><a name="LiterateEncodingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e124">
            <div class="title e125">Literate Encoding</div>
            <div class="para e126">Literate programming is a style of programming intended to
               make computer documentation better by, among other things,
               placing the documentation and source code in the same computer
               file. The TEI has applied this concept to the schemas used to
               validate documents to help ascertain whether or not they conform
               to the TEI Guidelines. The source code from which the schemas
               are generated and the prose documentation that make up the bulk
               of the TEI Guidelines are stored in one computer
               document.
            </div>
            <div class="para e127">In order to facilitate this, and in order to help make it
               easy to extract formal schemas in any of a variety of popular
               languages, the formal constraints are (for the most part)
               expressed in the TEI language, rather than any particular schema
               language.
            </div>
            <div class="para e128">Thus the TEI Guidelines proper (some 32 chapters of prose
               documentation), formal schemas expressed in RELAX NG, the XML
               DTD language, or the W3C Schema language, and reference
               documentation for those schemas, are all extracted from the same
               single document. We say that this “one document does” it all,
               and thus it is referred to as an ODD document.
            </div>
         </div>
      </div><a name="IntheClosedSchema(RELAXNGfile)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e129">
         <div class="title e130">In the Closed Schema (RELAX NG file)</div><a name="howANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e131">
            <div class="title e132">how</div>
            <div class="para e133">Many are probably quite familiar with the mechanism for
               constraining an enumerated attribute in a formal closed schema
               language. E.g., in RELAX NG (compact syntax), the possible
               values of the 
               <div class="code e134">type=</div> attribute (in this case, of the
               
               <div class="code e135">&lt;name&gt;</div> element) could be constrained with a
               construct like
               
               <div class="programlisting e136" xml:space="preserve">attribute type { "person" | "place" | "ship" | "sword" }</div>
               A variety of readily available off-the-shelf software will test
               whether or not a document is valid with respect to a RELAX NG
               schema.
            </div>
         </div><a name="advantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e137">
            <div class="title e138">advantages</div>
            <div class="para e139">This method is extremely common for a reason: it makes a
               lot of sense. In many, many cases XML document structure is
               already governed by an external closed schema. These external
               schemas, at least when written in one of the three major
               languages (DTD, RELAX NG, W3C XML Schema) are generally easy to
               read and process. They describe the constraint in a standard
               formal language that has wide software support, including open
               source validators.
            </div>
            <div class="para e140">These languages typically provide the capability to
               specify a variety of structural and content constraints on XML
               documents. In particular, they provide the capability needed
               here: to constrain the set of possible values of the
               
               <div class="code e141">type=</div> attribute to one of a list of possibilities.
               
               <div class="popupBox e142">
                  <div class="popupLabel" onmouseover="$('#d1e284').show('1000');" onmouseout="$('#d1e284').hide('1000');">[ footnote ]</div>
                  <div id="d1e284" style="display: none;">
                     <div class="footnote">
                        <div class="para e143">DTDs impose greater restrictions on what the
                           members of that list can be than the others: each possible value
                           must be an XML Name.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="disadvantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e144">
            <div class="title e145">disadvantages</div>
            <div class="para e146">In many cases, the person or persons who write and
               maintain the external schema is not the same as the person or
               persons who create the XML instances (or the programs that write
               the XML instances) that conform to it. In these cases, those who
               create the instances often do not have either the necessary
               knowledge (e.g., knowing the schema language) or capability
               (e.g., having read-write access to the schema) to make changes
               to it.
            </div>
            <div class="para e147">Furthermore in many cases (whether the instance creator is
               the same as the schema maintainer or not), a single external
               schema governs the validity of dozens or even tens of thousands
               of XML instances. But the desired constraints on a particular
               attribute may be different in different instances. Typically in
               these cases the schema limits the attribute to one of a set
               that is the union of all possible values in all governed
               documents. Here adding the additional constraint of 
               <div class="quote e148">only
                  these values in 
                  <div class="emphasis e149">this</div> document
               </div>
               requires making a separate schema that is like the original in
               all respects except for the declaration of the
               
               <div class="code e150">type=</div> attribute of 
               <div class="code e151">&lt;name&gt;</div>.
            </div>
         </div>
      </div><a name="IntheOpenSchema(ISOSchematron)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e152">
         <div class="title e153">In the Open Schema (ISO Schematron)</div>
         <div class="para e154">Many are probably quite familiar with the mechanism for
            constraining an enumerated attribute in a formal open schema
            language. E.g., in Schematron (DSDL part 4), the possible values
            of the 
            <div class="code e155">type=</div> attribute of the TEI
            
            <div class="code e156">&lt;name&gt;</div> element could be constrained with a
            construct like
            
            <div class="programlisting e157" xml:space="preserve">&lt;pattern&gt;
               &lt;rule context="tei:name/@type"&gt;
               &lt;assert test="normalize-space(.)='person'
               or normalize-space(.)='place'
               or normalize-space(.)='ship'
               or normalize-space(.)='sword'"&gt;
               Names can only be of people, places, ships, or swords
               &lt;/assert&gt;
               &lt;/rule&gt;
               &lt;/pattern&gt;
            </div>
            
         </div>
         <div class="para e158">While the use of open vs closed schemas have a lot of
            advantages and disadvantages to the schema designer, with respect
            to this particular question, the advantages and disadvantages are
            primarily the same: while the constraint can be expressed in a
            formal, widely supported language, and can be tested with readily
            available tools, it is still in a separate file that may support
            many documents, that may not be accessible, and that uses a
            language that may be foreign to those who would like to change it.
         </div>
         <div class="para e159">There is one additional disadvantage of Schematron in
            particular with respect to RELAX NG: it is harder to annotate the
            Schematron schema than the RELAX NG schema. RELAX NG deliberately
            permits elements from other namespaces to be mixed in with the
            RELAX NG specifications, and defines where annotations relating to
            particular structures should go. Furthermore, because the four
            tokens against which we are trying to validate are expressed as
            four separate elements (in the XML syntax), there is a place to
            annotate each separately (the 
            <div class="code e160">&lt;a:documentation&gt;</div>
            element follows the 
            <div class="code e161">&lt;rng:value&gt;</div> element to which it
            refers). Schematron also has a built-in documentation feature (a
            
            <div class="code e162">&lt;p&gt;</div> element), but because all four tokens are
            tucked into a single XPath expression, it is a bit harder to
            discuss them individually. This is partially confounded because
            
            <div class="code e163">&lt;p&gt;</div> is not permitted in 
            <div class="code e164">&lt;rule&gt;</div>,
            
            <div class="code e165">&lt;assert&gt;</div>, or 
            <div class="code e166">&lt;report&gt;</div>, making it
            difficult to put the documentation close to the code. This is
            partially alleviated because elements from foreign namespaces are
            permitted in those spaces, and inside 
            <div class="code e167">&lt;p&gt;</div>. Thus
            something like the following construct could be used to provide
            documentation of such a constraint.
            
            <div class="programlisting e168" xml:space="preserve">&lt;pattern&gt;
               &lt;p class="annotation"&gt;The various values for &lt;tei:att&gt;type&lt;/tei:att&gt; of 
               &lt;tei:gi&gt;name&lt;/tei:gi&gt; came about as follows: &lt;tei:list type="gloss"&gt;
               &lt;tei:label&gt;
               &lt;tei:val&gt;person&lt;/tei:val&gt;
               &lt;/tei:label&gt;
               &lt;tei:item&gt;Added 2007-04-17 when we removed &lt;tei:gi&gt;persName&lt;/tei:gi&gt;&lt;/tei:item&gt;
               &lt;tei:label&gt;
               &lt;tei:val&gt;place&lt;/tei:val&gt;
               &lt;/tei:label&gt;
               &lt;tei:item&gt;Added 2007-04-17 when we removed &lt;tei:gi&gt;placeName&lt;/tei:gi&gt;&lt;/tei:item&gt;
               &lt;tei:label&gt;
               &lt;tei:val&gt;ship&lt;/tei:val&gt;
               &lt;/tei:label&gt;
               &lt;tei:item&gt;Added 2007-04-17 in order to accommodate the various ship names&lt;/tei:item&gt;
               &lt;tei:label&gt;
               &lt;tei:val&gt;ship&lt;/tei:val&gt;
               &lt;/tei:label&gt;
               &lt;tei:item&gt;Added 2007-10-02 when we found a reference to "Excalibur" that the
               professor needed to annotate&lt;/tei:item&gt;
               &lt;/tei:list&gt;
               &lt;/p&gt;
               &lt;rule context="tei:name/@type"&gt;
               &lt;tei:note&gt;&lt;tei:att&gt;type&lt;/tei:att&gt; of &lt;tei:gi&gt;rs&lt;/tei:gi&gt; is matched elsewhere.&lt;/tei:note&gt;
               &lt;assert test=".='person' or .='place' or .='ship' or .='sword'"&gt; Names may only be
               
               of people, places, ships, or swords &lt;/assert&gt;
               &lt;/rule&gt;
               &lt;/pattern&gt;
            </div>
            
         </div>
      </div><a name="IntheMetaschema(ODDfile)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e169">
         <div class="title e170">In the Metaschema (ODD file)</div><a name="howANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e171">
            <div class="title e172">how</div>
            <div class="para e173">The same constraint might be expressed, at a slightly
               higher level of abstraction and combined with some
               documentation, using the ODD literate encoding language:
               
               <div class="programlisting e174" xml:space="preserve">
                  &lt;attDef ident="
                  <div class="emphasis e175" role="bold">type</div>"&gt;
                  &lt;valList type="closed"&gt;
                  &lt;valItem ident="
                  <div class="emphasis e176" role="bold">person</div>"&gt;
                  &lt;desc&gt;The name refers to a person&lt;/desc&gt;
                  &lt;/valItem&gt;
                  &lt;valItem ident="
                  <div class="emphasis e177" role="bold">place</div>"&gt;
                  &lt;desc&gt;The name refers to a political or man-made region, for example
                  a city, country, hamlet, town, or neighborhood. For geographical
                  places such as rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/desc&gt;
                  &lt;/valItem&gt;
                  &lt;valItem ident="
                  <div class="emphasis e178" role="bold">ship</div>"&gt;
                  &lt;desc&gt;The name refers to a ship, whether sea-worthy, interplanetary,
                  or interstellar&lt;/desc&gt;
                  &lt;/valItem&gt;
                  &lt;valItem ident="
                  <div class="emphasis e179" role="bold">sword</div>"&gt;
                  &lt;desc&gt;The name refers to a sword&lt;/desc&gt;
                  &lt;/valItem&gt;
                  &lt;/valList&gt;
                  &lt;/attDef&gt;
               </div>
               There exists software that will 
               <div class="quote e180">tangle</div> ODD
               specifications like the above into formal declarations in one of
               several schema languages, including RELAX NG. Then any of the
               same variety of readily available off-the-shelf software could
               be used to test validity.
            </div>
            <div class="para e181">Furthermore, there exists software that will
               
               <div class="quote e182">weave</div> the same specification above into easily
               readable hyperlinked documentation.
            </div>
         </div><a name="advantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e183">
            <div class="title e184">advantages</div>
            <div class="para e185">The advantages of literate programming are well
               understood, and include more easily readable and understandable
               source code, and that documentation (because it is right next to
               the source code) is more likely to match the program and be
               updated when the source code changes.
               <div class="popupBox e186">
                  <div class="popupLabel" onmouseover="$('#d1e392').show('1000');" onmouseout="$('#d1e392').hide('1000');">[ footnote ]</div>
                  <div id="d1e392" style="display: none;">
                     <div class="footnote">
                        <div class="para e187">Knuth,
                           Donald. 
                           <div class="emphasis e188">Literate Programming</div>, ISBN
                           0-9370-7380-6.
                        </div>
                     </div>
                  </div>
               </div> These advantages apply here as well.
               In addition, at least for those familiar with TEI, there is the
               advantage that the language used to describe the constraints is
               a TEI language, so schema designers are likely to be familiar
               with at least the documentation paradigm for the specialized
               schema-description elements, if not the elements themselves; in
               addition, they are likely familiar with the generic TEI elements
               (like 
               <div class="code e189">&lt;desc&gt;</div>, above) that are used in addition
               to the specialized elements.
            </div>
         </div><a name="disadvantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e190">
            <div class="title e191">disadvantages</div>
            <div class="para e192">The disadvantages of the external schema (whether open or
               closed) are present here as well. Furthermore, an extra
               processing step is required to generate (i.e.
               
               <div class="quote e193">tangle</div>) a schema that itself can be used to
               validate instances using off-the-shelf software. In addition, at
               least for those who are not intimately familiar with TEI, there
               is the disadvantage that the language used to describe the
               constraints is primarily a TEI language, so schema designers may
               not be familiar with the specialized schema-description
               elements.
            </div>
         </div>
      </div><a name="IntheMetadata()ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e194">
         <div class="title e195">In the Metadata (
            <div class="code e196">&lt;teiHeader&gt;</div>)
         </div><a name="how%E2%80%94pointingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e197" xml:id="pointing">
            <div class="title e198">how — pointing</div>
            <div class="para e199">It should be quite feasible to develop a mechanism for
               expressing the list of possible values of an attribute in the
               same document in a rather abstract way. For
               example:
               <div class="programlisting e200" xml:space="preserve">&lt;codeGrp elementTypes="name rs" attributes="type"&gt;
                  &lt;codeDef xml:id="person"&gt;The name or string refers to a
                  person&lt;/codeDef&gt;
                  &lt;codeDef xml:id="place"&gt;The name or string refers to a
                  political or man-made region, for example a city, country,
                  hamlet, town, or neighborhood. For geographical places such as
                  rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/codeDef&gt;
                  &lt;codeDef xml:id="ship"&gt;The name or string refers to a ship,
                  whether sea-worthy, interplanetary, or
                  interstellar&lt;/codeDef&gt;
                  &lt;codeDef xml:id="sword"&gt;The name or string refers to a
                  sword, &lt;foreign xml:lang="fr"&gt;main-gauche&lt;/foreign&gt;, switchblade,
                  or other edged weapon&lt;/codeDef&gt;
                  &lt;/codeGrp&gt;
               </div>
               Given this encoding in the 
               <div class="code e201">&lt;teiHeader&gt;</div>, the
               
               <div class="code e202">&lt;name&gt;</div> element could have 
               <div class="code e203">type=</div>
               values of 
               <div class="code e204">"#person"</div>, 
               <div class="code e205">"#place"</div>, etc.
               Software could be developed to validate that the value of
               
               <div class="code e206">type=</div> of 
               <div class="code e207">&lt;name&gt;</div> is a URI that
               points to an element whose parent 
               <div class="code e208">&lt;codeGrp&gt;</div> has
               
               <div class="code e209">"name"</div> in its 
               <div class="code e210">elementTypes=</div> list and
               
               <div class="code e211">"type"</div> in its 
               <div class="code e212">attributes=</div> list. (I
               believe that Schematron code could probably be used for this
               test, but have not yet demonstrated this.) Note that the check
               does not specify the element type of the child of
               
               <div class="code e213">&lt;codeGrp&gt;</div>. This gives the flexibility to have
               special-purpose 
               <div class="code e214">&lt;codeDef&gt;</div>-like elements that
               might provide structured information about the value. E.g., one
               can well imagine the TEI’s 
               <div class="code e215">&lt;handNote&gt;</div> element being
               used in this way.
            </div>
         </div><a name="advantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e216">
            <div class="title e217">advantages</div>
            <div class="para e218">This mechanism has significant potential advantages,
               particularly in cases where one schema is used for many files
               which may have different attribute constraint requirements. For
               most users it is much easier to change something in the same
               file they are working on, rather then needing to make changes to
               an external schema, particularly an external schema that may be
               in a language the user does not know or in a file to which the
               user does not have write access, and particularly changes that
               might inadvertently invalidate other existing instances. Thus
               the encoder, as opposed to the schema-designer, can add, remove,
               or change a value quite easily.
            </div>
            <div class="para e219">Another advantage is that the information about to what
               values the attribute is constrained, and what those values mean,
               is an integral part of the document. This means that this
               information will survive in the situation where a document
               instance is sent along without its schema or documentation.
               Furthermore the list of values in different files at a given
               project could be slightly different.
            </div>
            <div class="para e220">Moreover, the particular system shown here has the
               advantage that it uses a mechanism most users are already
               familiar with: 
               <div class="code e221">xml:id=</div> and relative URIs (i.e.,
               bare name fragment identifiers). It is worth noting, though,
               that there is no requirement that the URIs be bare name
               fragment identifiers, which permits this system to quickly and
               easily be changed to that which is discussed in 
               <div class="xref e222" linkend="separate"></div>.
            </div>
         </div><a name="disadvantagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e223">
            <div class="title e224">disadvantages</div>
            <div class="para e225">This system has obvious inefficiencies when multiple,
               perhaps thousands, of document instances share the same
               constraints — the same information is repeated in each
               file.
            </div>
            <div class="para e226">Another significant disadvantage of this method is that we
               are using a non-standard language for constraint and
               documentation. The question, then, is whether or not this system
               is demonstrably significantly better than what can be obtained
               using standard languages.
               <div class="popupBox e227">
                  <div class="popupLabel" onmouseover="$('#d1e492').show('1000');" onmouseout="$('#d1e492').hide('1000');">[ footnote ]</div>
                  <div id="d1e492" style="display: none;">
                     <div class="footnote">
                        <div class="para e228">What some call
                           
                           <div class="emphasis e229">Syd’s rule</div>, and I have begun to call my
                           
                           <div class="emphasis e230">wheel re-invention prevention convention</div>:
                           
                           <div class="quote e231">unless your method is significantly and demonstrably
                              superior to the standard, you should be using the
                              standard.
                           </div>.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e232">Lastly the fact that this system uses the URI pointing
               mechanism produces a disadvantages, one of which is
               severely problematic:
               
               <div class="itemizedlist e233">
                  <div class="listitem e234">
                     <div class="para e235">of minor annoyance is that the user needs to
                        encode a hash-mark (
                        <div class="quote e236">
                           <div class="code e237">#</div>
                        </div>, U+0023) at
                        the beginning of each value;
                     </div>
                  </div>
                  <div class="listitem e238">
                     <div class="para e239">the fact that values are restricted to XML
                        Names could be a problem in some situations;
                     </div>
                  </div>
                  <div class="listitem e240">
                     <div class="para e241">but far more problematic, because
                        
                        <div class="code e242">xml:id=</div> needs to be unique within the document,
                        any given possible attribute value can only occur on one
                        attribute (although that attribute could be on multiple
                        elements) — furthermore, no other element elsewhere in
                        the document can use the same string as one of these attribute
                        values as its identifier.
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="how%E2%80%94coreferenceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e243">
            <div class="title e244">how — co-reference</div>
            <div class="para e245">Those last disadvantages that are the result of using
               
               <div class="code e246">xml:id=</div> and URIs could be circumvented by matching
               the attribute values, rather than using a true pointer (e.g.
               ID/IDREF or URI). In the 
               <div class="code e247">&lt;teiHeader&gt;</div> the enumeration
               of the possible attribute values would look almost the same, but
               would use a different attribute for storing the actual
               value.
            </div>
            <div class="programlisting e248" xml:space="preserve">&lt;codeGrp elementTypes="name rs" attributes="type"&gt;
               &lt;codeDef attrVal="person"&gt;The name or string refers to a
               person&lt;/codeDef&gt;
               &lt;codeDef attrVal="place"&gt;The name or string refers to a
               political or man-made region, for example a city, country,
               hamlet, town, or neighborhood. For geographical places such as
               rivers or valleys, use &lt;gi&gt;geogName&lt;/gi&gt;&lt;/codeDef&gt;
               &lt;codeDef attrVal="ship"&gt;The name or string refers to a ship,
               whether sea-worthy, interplanetary, or
               interstellar&lt;/codeDef&gt;
               &lt;codeDef attrVal="sword"&gt;The name or string refers to a
               sword, &lt;foreign xml:lang="fr"&gt;main-gauche&lt;/foreign&gt;, switchblade,
               or other edged weapon&lt;/codeDef&gt;
               &lt;/codeGrp&gt;
            </div>
            <div class="para e249">Software could be developed to validate that the value of
               
               <div class="code e250">type=</div> of 
               <div class="code e251">&lt;name&gt;</div> is a string that
               matches the 
               <div class="code e252">attrVal=</div> attribute of an element whose
               parent 
               <div class="code e253">&lt;codeGrp&gt;</div> has 
               <div class="code e254">"name"</div> in its
               
               <div class="code e255">elementTypes=</div> list and 
               <div class="code e256">"type"</div> in its
               
               <div class="code e257">attribute=</div> list. (I believe that Schematron code
               could probably be used for this test, but have not yet
               demonstrated this. Certainly XSLT 1.0 can transform this into
               simple Schematron; this I have demonstrated, see 
               <div class="xref e258" linkend="codeGrp2Schematron"></div>.) Note that the check does not
               specify the element type of the child of
               
               <div class="code e259">&lt;codeGrp&gt;</div>. This gives the flexibility to have
               special-purpose 
               <div class="code e260">&lt;codeDef&gt;</div>-like elements that
               might provide structured information about the value. E.g., one
               can well imagine the TEI’s 
               <div class="code e261">&lt;handNote&gt;</div> element
               being used in this way.
            </div>
            <div class="para e262">This system avoids the disadvantages of using
               
               <div class="code e263">xml:id=</div>, and yet has several advantages over
               external schema files. E.g., encoders can quickly and easily add
               values to closed lists, in a manner that does not run the the
               risk that they might break the rest of the schema. I find the
               case of the encoder who wishes to quickly and easily express
               stricter constraints on her attribute values in a given file
               than those that come with the generic external schema very
               compelling.
            </div>
         </div>
      </div><a name="IntheMetadata(separatefile)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e264" xml:id="separate">
         <div class="title e265">In the Metadata (separate file)</div>
         <div class="para e266">In the method described in 
            <div class="xref e267" linkend="pointing"></div>
            the values of the 
            <div class="code e268">type=</div> attribute of
            
            <div class="code e269">&lt;name&gt;</div> are URIs. Because of this, it would be
            feasible to store the 
            <div class="code e270">&lt;codeGrp&gt;</div> element with
            
            <div class="code e271">xml:id=</div> attributes in a project-wide
            “attribute_definitions.xml” file. While this has the advantage
            of flexibility and reusability, it presents the sizable
            disadvantage that the attribute values would now depend on
            details of system features external to the document. E.g., the
            ability to validate 
            <div class="code e272">&lt;name
               type="../attribute_definitions.xml#sword"&gt;
            </div> breaks if the
            current file is moved to a sub-directory.
         </div>
         <div class="para e273">Furthermore, if the 
            <div class="code e274">&lt;codeGrp&gt;</div> is stored in a
            separate file, the maintenance issues are almost the same as those
            for a separate closed schema (e.g., a RELAX NG grammar), open
            schema (e.g., a Schematron schema), or metaschema (e.g., a TEI
            ODD): those who have reason to change the constraints expressed
            may not have the write-permissions necessary to do so, and if they
            do may be at risk for invalidating files other than the one being
            worked on.
         </div>
         <div class="para e275">So in some cases (in particular, the scenario sketched out
            in 
            <div class="xref e276" linkend="uc"></div>) it makes lots of sense to leave the
            formal constraints for some aspects of a document in the metadata
            section of that document itself, e.g. in the
            
            <div class="code e277">&lt;teiHeader&gt;</div>. But having convinced ourselves there
            is a need to be able to express constraints in a different
            
            <div class="emphasis e278">place</div> than is usual, why require a separate
            formal construct to express the constraint? Why not include RELAX
            NG, Schematron, or ODD markup constructs in the
            
            <div class="code e279">&lt;teiHeader&gt;</div> directly?
            <div class="popupBox e280">
               <div class="popupLabel" onmouseover="$('#d1e624').show('1000');" onmouseout="$('#d1e624').hide('1000');">[ footnote ]</div>
               <div id="d1e624" style="display: none;">
                  <div class="footnote">
                     <div class="para e281">Indeed, James
                        Cummings and I have suggested this on more than one occasion. See,
                        e.g., 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e282" xlink:actuate="onRequest" xlink:href="http://lists.village.virginia.edu/pipermail/tei-council/2005/005627.html" xlink:show="new" xlink:type="simple">http://lists.village.virginia.edu/pipermail/tei-council/2005/005627.html</div>.
                     </div>
                  </div>
               </div>
            </div>
            This is worthy of consideration, but is outside the scope of the
            current paper.
         </div>
      </div><a name="<codeGrp&gt;toSchematronANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e283" xml:id="codeGrp2Schematron">
         <div class="title e284">&lt;codeGrp&gt; to Schematron</div>
         <div class="para e285">The following XSLT 1.0 stylesheet is a proof-of-concept
            demonstration for transforming the 
            <div class="code e286">&lt;codeGrp&gt;</div>
            elements discussed above into Schematron that could be used to
            validate that an XML instance used only the mentioned possible
            values of the attribute specified.
         </div>
         <div class="programlisting e287" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
            &lt;!-- Tranform my mythical &lt;codeGrp&gt; elements into a Schematron schema --&gt;
            &lt;!-- Copyleft 2008 Syd Bauman --&gt;
            &lt;!-- Last updated: 2008-08-31 --&gt;
            &lt;xsl:stylesheet version="1.0"
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
            xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
            
            &lt;xsl:template match="/"&gt;
            &lt;!-- only mess with &lt;codeGrp&gt; elements; if there are none, we do nothing --&gt;
            &lt;!-- Note that we presume each &lt;codeGrp&gt; has both elementTypes= and  --&gt;
            &lt;!-- attriubtes= specified and that their values are lists of one or more --&gt;
            &lt;!-- XML Names. No error-checking for this here, schema validation should --&gt;
            &lt;!-- have already flagged any that don't have both required attributes or --&gt;
            &lt;!-- have inappropriate values. --&gt;
            &lt;xsl:if test="//codeGrp"&gt;
            &lt;!-- if there is one (or more) we write out a Schematron schema --&gt;
            &lt;sch:schema&gt;
            &lt;sch:ns uri="http://www.tei-c.org/ns/1.0" prefix="tei"/&gt;
            &lt;!-- and process each &lt;codeGrp&gt; into it --&gt;
            &lt;xsl:apply-templates select="//codeGrp"/&gt;
            &lt;/sch:schema&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:template&gt;
            
            &lt;!-- Each &lt;codeGrp&gt; becomes a Schematron &lt;pattern&gt; --&gt;
            &lt;xsl:template match="codeGrp"&gt;
            &lt;sch:pattern&gt;
            &lt;!-- append a blank to the GI list for easier parsing later --&gt;
            &lt;xsl:variable name="elementTypes" select="concat(normalize-space(@elementTypes),'
            ')"/&gt;
            &lt;!-- append a blank to the attribute name list for easier parsing later --&gt;
            &lt;xsl:variable name="attributes" select="concat(normalize-space(@attributes),' ')"/&gt;
            &lt;!-- Each GI/attribute pair becomes a Schematron &lt;rule&gt; --&gt;
            &lt;!-- A little more detail: each paired combination of --&gt;
            &lt;!-- 1. a GI listed on my elementTypes= attribute, and --&gt;
            &lt;!-- 2. an attribute name listed on my attributes= attribte --&gt;
            &lt;!-- becomes a &lt;rule&gt;. We do this by processing each GI in  --&gt;
            &lt;!-- a recursive template, which in turn calls another recursive --&gt;
            &lt;!-- template for the list of attributes. --&gt;
            &lt;xsl:call-template name="elementTypes"&gt;
            &lt;xsl:with-param name="gis" select="$elementTypes"/&gt;
            &lt;xsl:with-param name="attrs" select="$attributes"/&gt;
            &lt;/xsl:call-template&gt;
            &lt;/sch:pattern&gt;
            &lt;/xsl:template&gt;
            
            &lt;!-- Each GI listed on the elementTypes= attribute gets processed separately --&gt;
            &lt;xsl:template name="elementTypes"&gt;
            &lt;xsl:param name="gis"/&gt;
            &lt;xsl:param name="attrs"/&gt;
            &lt;!-- Taking advantage of that ending blank, parse off the 1st GI --&gt;
            &lt;xsl:variable name="this_gi" select="substring-before($gis,' ')"/&gt;
            &lt;xsl:variable name="rest" select="substring-after($gis,' ')"/&gt;
            &lt;!-- call attributes template to do the work for this particular GI --&gt;
            &lt;xsl:call-template name="attributes"&gt;
            &lt;xsl:with-param name="gi" select="$this_gi"/&gt;
            &lt;xsl:with-param name="attrs" select="$attrs"/&gt;
            &lt;/xsl:call-template&gt;
            &lt;!-- and do the same thing (via recursion) for the rest of the GIs, if any --&gt;
            &lt;xsl:if test="string-length($rest) &gt; 1"&gt;
            &lt;xsl:call-template name="elementTypes"&gt;
            &lt;xsl:with-param name="gis" select="$rest"/&gt;
            &lt;xsl:with-param name="attrs" select="$attrs"/&gt;
            &lt;/xsl:call-template&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:template&gt;
            
            &lt;!-- Each attibute name on the attributes= attribute gets processed in combination
            --&gt;
            &lt;!-- with the current GI --&gt;
            &lt;xsl:template name="attributes"&gt;
            &lt;xsl:param name="gi"/&gt;
            &lt;xsl:param name="attrs"/&gt;
            &lt;!-- Taking advantage of that ending blank, parse off the 1st attribute --&gt;
            &lt;xsl:variable name="this_attr" select="substring-before($attrs,' ')"/&gt;
            &lt;xsl:variable name="rest" select="substring-after($attrs,' ')"/&gt;
            &lt;!-- make a rule out of it --&gt;
            &lt;xsl:element name="sch:rule"&gt;
            &lt;xsl:attribute name="context"&gt;
            &lt;!-- There must be a better way to do this ... --&gt;
            &lt;xsl:text&gt;tei:&lt;/xsl:text&gt;
            &lt;xsl:value-of select="$gi"/&gt;
            &lt;xsl:text&gt;/@&lt;/xsl:text&gt;
            &lt;xsl:value-of select="$this_attr"/&gt;
            &lt;/xsl:attribute&gt;
            &lt;xsl:variable name="numVals" select="count(child::*/@attrVal)"/&gt;
            &lt;!-- if I have no children with attrVal= specified, then don't --&gt;
            &lt;!-- generate any assertions (luckily an emtpy &lt;rule&gt; is valid --&gt;
            &lt;!-- in Schematron). --&gt;
            &lt;xsl:if test="$numVals &gt; 0"&gt;
            &lt;xsl:element name="sch:assert"&gt;
            &lt;!-- Probably would be better to generate this test (i.e., the expression --&gt;
            &lt;!-- that is the value of this output test= attribute) only once per attrVal=, --&gt;
            &lt;!-- rather once for each attrVal= for each GI/attr combination. --&gt;
            &lt;xsl:attribute name="test"&gt;
            &lt;xsl:for-each select="child::*/@attrVal"&gt;
            &lt;xsl:text&gt;.='&lt;/xsl:text&gt;
            &lt;xsl:value-of select="."/&gt;
            &lt;xsl:text&gt;'&lt;/xsl:text&gt;
            &lt;xsl:if test="$numVals &gt; 1  and  position() != last()"&gt;
            &lt;xsl:text&gt; or &lt;/xsl:text&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:for-each&gt;
            &lt;/xsl:attribute&gt;
            &lt;/xsl:element&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:element&gt;
            &lt;!-- and do the same thing (via recursion) for the rest of the attributes, if any
            --&gt;
            &lt;xsl:if test="string-length($rest) &gt; 1"&gt;
            &lt;xsl:call-template name="attributes"&gt;
            &lt;xsl:with-param name="gi" select="$gi"/&gt;
            &lt;xsl:with-param name="attrs" select="$rest"/&gt;
            &lt;/xsl:call-template&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:template&gt;
            
            &lt;/xsl:stylesheet&gt;
         </div>
      </div>
   </div>
</div>