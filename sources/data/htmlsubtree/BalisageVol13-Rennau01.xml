<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#XQuerytopictoolsconceptuserinterfacedevelopmentframeworkANCHOR" name="XQuerytopictoolsconceptuserinterfacedevelopmentframeworkTOC">XQuery topic tools - concept, user interface, development framework</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XQueryforcommandlinetoolsANCHOR" name="XQueryforcommandlinetoolsTOC">XQuery for command line tools</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Concept:topictoolANCHOR" name="Concept:topictoolTOC">Concept: topic tool</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#GoalsANCHOR" name="GoalsTOC">Goals</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Topictools:userperspectiveANCHOR" name="Topictools:userperspectiveTOC"> Topic tools: user perspective </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ToolinvocationmodelANCHOR" name="ToolinvocationmodelTOC">Tool invocation model</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ToolschemeANCHOR" name="ToolschemeTOC">Tool scheme</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ObjectparametertypesANCHOR" name="ObjectparametertypesTOC">Object parameter types</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Namefilter()ANCHOR" name="Namefilter()TOC">Name filter ()</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Namefiltermap()ANCHOR" name="Namefiltermap()TOC">Name filter map ()</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Pathfilter()ANCHOR" name="Pathfilter()TOC">Path filter ()</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DirectoryFilterDescriptors(%0A)ANCHOR" name="DirectoryFilterDescriptors(%0A)TOC">Directory Filter Descriptors (,
                        )</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Documentcatalog()ANCHOR" name="Documentcatalog()TOC">Document catalog ()</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ToolspecificobjectparametertypesANCHOR" name="ToolspecificobjectparametertypesTOC">Tool specific object parameter types</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StoringandreusinginvocationANCHOR" name="StoringandreusinginvocationTOC">Storing and reusing invocation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SummaryANCHOR" name="SummaryTOC">Summary</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Topictools:developerperspectiveANCHOR" name="Topictools:developerperspectiveTOC">Topic tools: developer perspective</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OverviewANCHOR" name="OverviewTOC">Overview</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WorkflowANCHOR" name="WorkflowTOC">Workflow</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WritingXQuerycodeANCHOR" name="WritingXQuerycodeTOC">Writing XQuery code</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WritingannotationsANCHOR" name="WritingannotationsTOC">Writing annotations</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AdvancedusageextendingtheframeworkANCHOR" name="AdvancedusageextendingtheframeworkTOC">Advanced usage - extending the framework</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SummaryANCHOR" name="SummaryTOC">Summary</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#GettingstartedwithtopictoolsANCHOR" name="GettingstartedwithtopictoolsTOC">Getting started with topic tools</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ToolinstantiationANCHOR" name="ToolinstantiationTOC">Tool instantiation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExploringtheinitialtoolversionANCHOR" name="ExploringtheinitialtoolversionTOC">Exploring the initial tool version</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AddingprototypesANCHOR" name="AddingprototypesTOC">Adding prototypes</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FirstoperationfirstimplementationANCHOR" name="FirstoperationfirstimplementationTOC">First operation, first implementation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FirstrefinementaddingaparameterANCHOR" name="FirstrefinementaddingaparameterTOC">First refinement - adding a parameter</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AddinganamefilterANCHOR" name="AddinganamefilterTOC">Adding a name filter</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SecondoperationfirstimplementationANCHOR" name="SecondoperationfirstimplementationTOC">Second operation, first implementation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AddingapathfilterANCHOR" name="AddingapathfilterTOC">Adding a path filter</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ThirdoperationfirstimplementationANCHOR" name="ThirdoperationfirstimplementationTOC">Third operation, first implementation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AddinganamefiltermapANCHOR" name="AddinganamefiltermapTOC">Adding a name filter map</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DiscussionANCHOR" name="DiscussionTOC">Discussion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThemoduleasgeneratedbyANCHOR" name="ThemoduleasgeneratedbyTOC">The  module as generated by </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThemoduleaftereditingitinthetutorialANCHOR" name="ThemoduleaftereditingitinthetutorialTOC">The  module after editing it in the tutorial</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">add</div>
         <div class="singletermTERMS">annotations</div>
         <div class="singletermTERMS">Annotation editing</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">BaseX</div>
         <div class="singletermTERMS">build</div>
         <div class="singletermTERMS">blacklisted</div>
         <div class="singletermTERMS">build</div>
         <div class="singletermTERMS">built-in operations</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">collection()</div>
         <div class="singletermTERMS">csvDFD</div>
         <div class="singletermTERMS">cardinality</div>
         <div class="singletermTERMS">Command line tools</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">doc()</div>
         <div class="singletermTERMS">default</div>
         <div class="singletermTERMS">docDFD</div>
         <div class="singletermTERMS">docCAT</div>
         <div class="singletermTERMS">dcat</div>
         <div class="singletermTERMS">doctypes</div>
         <div class="singletermTERMS">doct*</div>
         <div class="singletermTERMS">docURI</div>
         <div class="singletermTERMS">dfd</div>
         <div class="singletermTERMS">dir</div>
         <div class="singletermTERMS">Document Filter Descriptors</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">element(z:errors)?</div>
         <div class="singletermTERMS">extensions</div>
         <div class="singletermTERMS">Examples of name filter values and their meaning.</div>
         <div class="singletermTERMS">evolve</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">facet</div>
         <div class="singletermTERMS">function signature</div>
         <div class="singletermTERMS">functional abstraction</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">Guaranteed availability</div>
         <div class="singletermTERMS">Guaranteed validity</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">help operation</div>
         <div class="singletermTERMS">hides</div>
         <div class="singletermTERMS">hrennau@yahoo.de</div>
         <div class="singletermTERMS">Hans-Jürgen</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">input information</div>
         <div class="singletermTERMS">item()</div>
         <div class="singletermTERMS">items</div>
         <div class="singletermTERMS">items.mod.xq</div>
         <div class="singletermTERMS">if</div>
         <div class="singletermTERMS">input data</div>
         <div class="singletermTERMS">is</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">mode</div>
         <div class="singletermTERMS">mod</div>
         <div class="singletermTERMS">message interface</div>
         <div class="singletermTERMS">model of function input information</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">nameFilter</div>
         <div class="singletermTERMS">nameFilterMap</div>
         <div class="singletermTERMS">nameFilterMap(xs:integer)</div>
         <div class="singletermTERMS">niem-submissions</div>
         <div class="singletermTERMS">names</div>
         <div class="singletermTERMS">new</div>
         <div class="singletermTERMS">node()</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">ops</div>
         <div class="singletermTERMS">otdsv</div>
         <div class="singletermTERMS">object parameter types</div>
         <div class="singletermTERMS">operation provider function</div>
         <div class="singletermTERMS">Object parameters</div>
         <div class="singletermTERMS">operation interface</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">pathFilter</div>
         <div class="singletermTERMS">paths</div>
         <div class="singletermTERMS">Prototyping</div>
         <div class="singletermTERMS">potentially growing set of input information</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">request</div>
         <div class="singletermTERMS">request message</div>
         <div class="singletermTERMS">richer parameter model</div>
         <div class="singletermTERMS">RESTful web services</div>
         <div class="singletermTERMS">RESTXQ</div>
         <div class="singletermTERMS">Rennau</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">scheme</div>
         <div class="singletermTERMS">storeq</div>
         <div class="singletermTERMS">scope</div>
         <div class="singletermTERMS">single string</div>
         <div class="singletermTERMS">stable function signature</div>
         <div class="singletermTERMS">Senior Java developer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">ttools</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">travelScenario</div>
         <div class="singletermTERMS">txtDFD</div>
         <div class="singletermTERMS">textDFD</div>
         <div class="singletermTERMS">types</div>
         <div class="singletermTERMS">tt:matchesNameFilter</div>
         <div class="singletermTERMS">tt:getParam</div>
         <div class="singletermTERMS">the XML expression language</div>
         <div class="singletermTERMS">topic tool</div>
         <div class="singletermTERMS">topic tools</div>
         <div class="singletermTERMS">tool scheme</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">tool-specific</div>
         <div class="singletermTERMS">Tool instantiation</div>
         <div class="singletermTERMS">Tool building</div>
         <div class="singletermTERMS">Tool testing.</div>
         <div class="singletermTERMS">tool specific</div>
         <div class="singletermTERMS">the</div>
         <div class="singletermTERMS">two</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">unified</div>
         <div class="singletermTERMS">utility functions</div>
         <div class="singletermTERMS">use</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">values</div>
         <div class="singletermTERMS">valid</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xclear</div>
         <div class="singletermTERMS">xs:ID</div>
         <div class="singletermTERMS">xs:NOTATION</div>
         <div class="singletermTERMS">xs:date</div>
         <div class="singletermTERMS">xs:dateTime</div>
         <div class="singletermTERMS">xs:time</div>
         <div class="singletermTERMS">xs:string</div>
         <div class="singletermTERMS">xclear.xq</div>
         <div class="singletermTERMS">xs:appInfo</div>
         <div class="singletermTERMS">XQuery code writing</div>
         <div class="singletermTERMS">XQuery</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="XQuerytopictoolsconceptuserinterfacedevelopmentframeworkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">XQuery topic tools - concept, user interface, development framework</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2014</div>
            <div class="confdates e5">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">
               
               <div class="emphasis e8" role="ital"> This paper defines the concept of topic tools, which are
                  command line tools providing a single point of access to a range of
                  functionality. Topic tools conform to a generic model of invocation syntax and
                  basic tool behaviour, concerning user assistence, error diagnostics and
                  invocation reuse. The paper proposes a comprehensive model of the
                  user-perspective - syntax and behaviour - and it introduces a simple development
                  framework making the creation of XQuery topic tools simple and fast. The support
                  offered by the framework includes code generation and the use of a message
                  interface which cleanly isolates the application code from user input and gives
                  it access to validated and augmented information, rather than the raw data of
                  user input. Key properties of framework-based topic tools are early
                  availability, extensibility, user convenience, behavioural consistency and
                  reliability based on very thorough and fully automated input validation.
                  
               </div>
               
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Hans-Jürgen</div>
               <div class="othername e12"></div>
               <div class="surname e13">Rennau</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15"></div>
            </div>
            <div class="affiliation e16">
               <div class="jobtitle e17">Senior Java developer</div>
               <div class="orgname e18">Traveltainment GmbH</div>
            </div>
            <div class="email e19">hrennau@yahoo.de</div>
         </div>
         <div class="legalnotice e20">
            <div class="para e21">Copyright © 2014 by the author. Used with permission.</div>
         </div>
         <div class="keywordset e22" role="author">
            <div class="keyword e23">XQuery</div>
            <div class="keyword e24">XML</div>
            <div class="keyword e25">Command line tools</div>
            <div class="keyword e26">RESTful web services</div>
            <div class="keyword e27">RESTXQ</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e28">
         <div class="title e29">Introduction</div>
         <div class="para e30"> XQuery ([
            <div class="xref e31" linkend="w3c-xquery"></div>]) is a W3C defined language for processing XML
            and other information resources. The name is a misnomer, as XQuery is a general
            information processing language, rather than a query language. XQuery certainly offers
            excellent support for querying XML data, but this support should be viewed as a
            prominent feature of the language, not as its scope. 
         </div>
         <div class="para e32"> XQuery has an amazing conceptual simplicity. It is an expression language –
            everything is an expression, a query is an expression tree. An expression is a shape
            which has a value, and the value of an XQuery expression is a sequence of items, where
            each item is either a node, an atomic value, or a function. Nodes are the foundation
            of
            a generic model of navigation, as they are interconnected by node properties, and
            these
            connections can be used as “roads” along which to move – the XPath axes (e.g. child,
            descendant, parent and ancestor). The XPath functions 
            <div class="code e33">doc()</div> and
            
            <div class="code e34">collection()</div> enable URI based access to local and remote XML resources,
            and as these are modelled as node trees, and as node trees can be traversed using
            those
            axes, XQuery programs operate in a logical space of information which is homogeneously
            structured (everything is a node) and which exposes any grain of content of any
            accessible XML resource (accessible via 
            <div class="code e35">doc()</div> or
            
            <div class="code e36">collection()</div>), making it individually addressable. Powerful operations are
            available not only for addressing, but also for aggregating, transforming and evaluating
            those ubiquitous units of content. These capabilities, combined with utmost conceptual
            simplicity (expressions, values, full stop) might induce us to refer to XQuery not
            as a
            query language, but simply as 
            <div class="emphasis e37" role="ital"> the XML expression language
               
            </div> – call it XMLe. And perhaps we should regard XML syntax, the XML data model
            and XMLe as integral parts of a single, unified information architecture which
            constitutes the deeper meaning of the three letters XML ( XML = XMLs + XMLm + XMLe).
            
         </div>
         <div class="para e38">XQuery is currently a niche language. Only a tiny fraction of developers has a solid
            understanding of its capabilities, let alone the skills to use them. It might even
            be
            the case that acknowledged experts of XML do not have a real understanding of XQuery
            and
            that their view of XML technology and the scope of its usefulness is profoundly affected
            by this lack of understanding and experience. 
         </div>
         <div class="para e39">Comparing the high capabilities of XQuery and its low adoption by developers, one
            may
            conclude that the industry is wasting a significant potential. To put it differently:
            the potential of XQuery is still locked. Any approaches designed to unlock the potential
            – facilitating the use of XQuery somehow and in some realm - might deserve special
            interest, as the possible gains are high. One such approach is RESTXQ ([
            <div class="xref e40" linkend="retter"></div>]), which simplifies the XQuery-based implementation of web
            services. This paper introduces another approach, 
            <div class="code e41">ttools</div>, a framework
            supporting the development of XQuery-based command line tools which are powerful,
            versatile and designed for continuous extensibility. The approach is based on the
            concept of a 
            <div class="emphasis e42" role="ital">topic tool</div>. A topic tool is a program
            providing a single command line interface to a range of functionality – the available
            (and continuously growing) functionality related to a “topic”. This paper defines
            the
            concept, proposes a generic model of the user perspective and introduces a development
            framework enabling the fast and easy development of topic tools. It should be noted
            right at the start that the framework is extremely lightweight – 100% XQuery
            implemented, so that neither the use nor the development of topic tools requires any
            components apart from an XQuery processor. 
         </div>
      </div><a name="XQueryforcommandlinetoolsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e43">
         <div class="title e44">XQuery for command line tools</div>
         <div class="para e45">XQuery is well-suited for the rapid development of divers and powerful command line
            tools, enabling the evaluation of distributed information sources. Key reasons for
            this
            potential is the navigational power of XPath and the uniformity of a data model which
            allows seamless integration of navigation and construction. But this very efficiency
            of
            XQuery can seduce the developer to create - at an amazing speed - an amazingly
            unsatisfactory situation: a heap of command line tools inconsistently named, and using
            input parameters with inconsistent names and semantics. Each of these tools, inspected
            in isolation, might be very useful, and yet the sum is difficult to use and to maintain.
            The longer this undisciplined development continues, the greater the loss of efficiency
            on both sides – the developer’s and the user’s. Many tools are at length abandoned
            (by
            users and by the developer), as it becomes too difficult to remember what exactly
            is
            available and how to use it, precisely. Wheels are frequently reinvented, and yet,
            often
            no wheel can be found when it is really needed. The big bonus of efficiency offered
            by
            XQuery is lost.
         </div>
         <div class="para e46">In similar situations a key problem is the lack of any structure integrating the
            individual tools into a conceptual whole. Compare this to the realm of web services.
            Their functionality is structured into named services which are in turn structured
            into
            named operations. Each service provides a scope for conventions concerning names,
            structures and semantics. But now imagine there were only operations without containing
            services – instead of web services we would deal with “web operations”. We would get
            into trouble. We would be threatened by the same predicament which is created by an
            uncoordinated growth of command line tools. 
         </div>
         <div class="para e47">A possible conclusion is that we should create command line tools which can be
            compared to web services. Service-like tools would act as containers for a set of
            related operations, providing a single point of access and the scope for a consistent
            vocabulary and patterns of tool behaviour. But this ambition is at cross purposes
            with a
            tool developer's desire to be agile and responsive. We want to add new functionality
            quickly and frequently. We want to be ready to augment the flexibility of existing
            functionality - adding further control parameters - as soon as the need is detected.
            XQuery is a scripting language, which encourages rapid and agile development. Committed
            to rapid development, we are reluctant to invest effort into structural integration.
            
         </div>
         <div class="para e48"> The development of rich, service-like command line tools is very costly and
            challenging if starting from scratch – without purpose-designed development tools.
            This
            paper introduces a framework which changes the situation radically, enabling the
            instantiation of a service-like tool within seconds, the writing of a deliverable
            first
            version within an afternoon, and the continuous extension and refinement which always
            remains simple and straightforward, because extension can be accomplished without
            increasing the overall complexity. The second key benefit of framework based development
            is the high quality of the emerging tool, which is largely due to a rich input
            validation model, as well as the consistency of “look-and-feel” (invocation syntax
            and
            basic behaviour) across all tools built using the framework. 
         </div>
         <div class="para e49"> The framework is based on a generic concept of service-like tools, called 
            <div class="emphasis e50" role="ital">topic tools</div>. We start with the concept, proceed to the
            user-perspective (tool usage) and then inspect the developer-perspective – how to
            write
            topic tools. 
         </div>
      </div><a name="Concept:topictoolANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e51">
         <div class="title e52">Concept: topic tool</div>
         <div class="para e53">For the purposes of this discussion, the term "topic tool" denotes a particular class
            of programs. A 
            <div class="emphasis e54" role="bold">topic tool</div> is a program offering a
            single command line interface to multiple functionality, typically related to a single
            topic. The command line interface reflects a 
            <div class="emphasis e55" role="ital">unified</div>
            invocation model: the invocation of all topic tools has the same structure and is
            evaluated in accordance with the same syntactic conventions. There are also behavioural
            rules to which any topic tool adheres, for example concerning usage hints, user input
            validation, user input error reporting and the possibility to use stored invocations.
            Uniformity and user convenience are further encouraged by the standardization of rich
            parameter types for specifying input resources, name filters, path filters and other
            entities expressing complex details of the user's intent. 
         </div>
      </div><a name="GoalsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e56">
         <div class="title e57">Goals</div>
         <div class="para e58">This paper describes a work with the following goals.</div>
         <div class="orderedlist e59">
            <div class="listitem e60">
               <div class="para e61">To define a generic model of a topic tool command line interface</div>
            </div>
            <div class="listitem e62">
               <div class="para e63">To define generic features of topic tool behaviour</div>
            </div>
            <div class="listitem e64">
               <div class="para e65">To provide a development framework for the implementation of topic tools,
                  emphasizing
               </div>
               <div class="itemizedlist e66">
                  <div class="listitem e67">
                     <div class="para e68">The speed of development (code generation, application code supported
                        by infrastructure code)
                     </div>
                  </div>
                  <div class="listitem e69">
                     <div class="para e70">The ease of development (reduction of complexity)</div>
                  </div>
                  <div class="listitem e71">
                     <div class="para e72">Tool quality (robustness, predictability, validation and
                        diagnostics)
                     </div>
                  </div>
                  <div class="listitem e73">
                     <div class="para e74">Tool extensibility (low effort to add operations and to extend
                        existing operations)
                     </div>
                  </div>
                  <div class="listitem e75">
                     <div class="para e76">Framework extensibility (possibility to define new parameter
                        types)
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="Topictools:userperspectiveANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e77">
         <div class="title e78"> Topic tools: user perspective </div>
         <div class="para e79"> The interface of topic tools reflects a unified invocation model: the invocation
            of
            all topic tools has the same structure, is evaluated in accordance with the same
            syntactic rules and can rely on the same set of behavioural features concerning error
            reporting, usage assistence and support for storing and reusing invocations. 
         </div><a name="ToolinvocationmodelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e80">
            <div class="title e81">Tool invocation model</div>
            <div class="para e82"> The invocation of a topic tool specifies a named operation and (optionally) the
               values of named parameters. The syntax used is the same for any topic tool.
               Technically speaking, a topic tool has a single parameter named “request”, which is
               a structured string identifying the operation and supplying parameter values.
               Operation name and parameters are separated by a question mark, and parameters are
               separated by a comma. This is the general pattern:
               
               <div class="programlisting e83" xml:space="preserve">   operationName ? param1=value1, param2=value2</div>
               Literal commas within parameter values must be escaped using a backslash. Literal
               uses of the backslash character must also be escaped. If the parameter value has
               multiple items, these are supplied as a concatenated string. The item separator is
               either whitespace (one or more characters) or a semicolon, optionally surrounded by
               whitespace. Which item separator to use is prescribed by the topic tool for each
               parameter individually. If a parameter supports multiple items, literal uses of the
               item separator within parameter values must be escaped using a backslash. If no
               parameters are supplied, the request consists only of the operation name. Here come
               a few requests addressed to a topic tool called 
               <div class="code e84">xclear</div>, which offers
               various operations for analyzing XML document contents. The creation of this topic
               tool will be described in the tutorial proposed by a later section of this paper.
               
            </div>
            <div class="programlisting e85" xml:space="preserve">
               docs    ? doc=/logs/log01.xml /logs/log02.xml /logs/log03.xml                
               doctype ? docs=^/projects/xsd/xsd-fpml%*                
               names   ? docs=^/projects/xsd/niem-2.1%*
               names   ? docs=^/projects/xsd/niem-2.1%*, scope=elem, names=*augment*
            </div>
            <div class="para e86"> Which operations are available? Given an operation, which parameters are possible
               and which are mandatory, what is the minimum/maximum number of value items, and
               which character must be used as item separator? What are the parameter types, and
               what the default values, if any? The answers are stored in the 
               <div class="emphasis e87" role="ital">tool scheme</div>, which models any aspect of the tool interface. Every
               topic tool supports a 
               <div class="code e88">_help</div> operation providing usage assistence, which
               is based on the actual tool scheme. The 
               <div class="code e89">_help</div> operation of every topic
               tool supports the same set of parameters. The use of 
               <div class="code e90">_help</div> is
               facilitated by a syntactic shortcut: the operation name may be omitted (if
               parameters are specified) or replaced by a question mark (if no parameters are
               specified). Invocations #1 and #3, and invocations #2 and #4 are equivalent:
            </div>
            <div class="programlisting e91" xml:space="preserve">
               _help
               _help?ops=paths, default=true, type=true   
               ?
               ?ops=paths, default=true, type=true
            </div>
            <div class="para e92"> Called without parameters, 
               <div class="code e93">_help</div> displays a simple summary of the
               topic tool, consisting of operation names and the parameter names and cardinalities:
               
            </div>
            <div class="programlisting e94" xml:space="preserve">
               REQUEST:
               ?
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ====================================================
               _help        default, mode, ops?, type
               dcat         dfd+
               docs         dcat*, doc*, docs*
               doctypes     attNames, dcat*, doc*, docs*, elemNames
               names        dcat*, doc*, docs*, names?, scope
               paths        dcat*, doc*, docs*, paths?
               values       dcat*, doc*, docs*, nvalues?
               ====================================================
            </div>
            <div class="para e95"> To see the types and default values, set the parameters 
               <div class="code e96">type</div> and
               
               <div class="code e97">default</div> to "true". You can also restrict the report to particular
               operations by supplying a name filter as value of parameter 
               <div class="code e98">ops</div> (more
               about name filters later). 
            </div>
            <div class="programlisting e99" xml:space="preserve">
               REQUEST:
               ?type=true, default=true, ops=_h* do*
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ============================================================================
               _help        default=false....... : xs:boolean
               mode=overview....... : xs:string
               ops................. : nameFilter?
               type=false.......... : xs:boolean
               
               docs         dcat................ : docCAT* (sep=;)
               doc................. : docURI* (sep=WS)
               docs................ : docDFD* (sep=;)
               At least 1 of these parameters must be set: dcat, doc, docs
               
               doctypes     attNames=false...... : xs:boolean
               dcat................ : docCAT* (sep=;)
               doc................. : docURI* (sep=WS)
               docs................ : docDFD* (sep=;)
               elemNames=false..... : xs:boolean
               At least 1 of these parameters must be set: dcat, doc, docs
               ============================================================================
            </div>
            <div class="para e100"> Operation and parameter names can be abbreviated by leaving out trailing
               characters, as long as the used prefix unambiguously identifies the operation or
               parameter, respectively. Operation and parameter names are case sensitive from the
               developer perspective, but case insensitive from the user perspective; entered names
               are normalized to the case defined by the tool scheme. 
            </div>
            <div class="para e101"> Another syntactic shortcut applies to parameters of Boolean type. They can be
               specified by only supplying the name (equivalent to param=true), or the name
               preceded by a tilde (equivalent to param=false). Example: 
            </div>
            <div class="programlisting e102" xml:space="preserve">?ops=paths, ~default, type</div>
            <div class="para e103"> An XQuery based topic tool receives the invocation string as value of the single
               external variable, named 
               <div class="code e104">request</div>. Call syntax of course depends on the
               actual XQuery processor. Using 
               <div class="code e105">BaseX</div>, for example, calling a topic tool
               looks similar to this:
               
               <div class="programlisting e106" xml:space="preserve">
                  basex -b "request=names ? docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               </div>
               
            </div>
         </div><a name="ToolschemeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e107">
            <div class="title e108">Tool scheme</div>
            <div class="para e109"> A topic tool is defined by a 
               <div class="emphasis e110" role="bold">tool scheme</div> which
               models every aspect of the tool interface. The tool scheme supports both, the tool
               user and the tool developer in their work. The tool scheme is automatically
               constructed by collecting annotations contained by the tool sources, augmenting them
               and integrating them into a single XML document. The scheme specifies: 
            </div>
            <div class="itemizedlist e111">
               <div class="listitem e112">
                  <div class="para e113">operation names</div>
               </div>
               <div class="listitem e114">
                  <div class="para e115">for each operation all parameter names</div>
               </div>
               <div class="listitem e116">
                  <div class="para e117">for each parameter …</div>
                  <div class="itemizedlist e118">
                     <div class="listitem e119">
                        <div class="para e120">type</div>
                     </div>
                     <div class="listitem e121">
                        <div class="para e122">cardinality</div>
                     </div>
                     <div class="listitem e123">
                        <div class="para e124">item separator (if maximum number of occurrences greater 1)</div>
                     </div>
                     <div class="listitem e125">
                        <div class="para e126">(optional) default value</div>
                     </div>
                     <div class="listitem e127">
                        <div class="para e128">(optional) facets</div>
                     </div>
                     <div class="listitem e129">
                        <div class="para e130">(optional) normalizations</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e131">Every parameter has a 
               <div class="emphasis e132" role="ital">type</div> and a 
               <div class="emphasis e133" role="ital">cardinality</div>. The type can be a built-in schema type, a
               
               <div class="code e134">ttools</div>-defined type (a generic type defined by the topic tools
               framework described in this paper, available in any framework-based topic tool) or
               a
               tool-specific type. All built-in schema types are supported, excepting
               
               <div class="code e135">xs:ID</div> and 
               <div class="code e136">xs:NOTATION</div>.
            </div>
            <div class="para e137"> An example of a framework-defined type is 
               <div class="code e138">docDFD</div>, which represents a
               filter extracting XML documents from directories. ("DFD" denotes "directory filter
               descriptor".) An example of a tool-specific type is 
               <div class="code e139">travelScenario</div>.
               This type is defined by a topic tool for evaluating touristic data; parameter values
               are structured strings describing a travel in terms of travel dates and traveller
               birthdates. 
            </div>
            <div class="para e140">A 
               <div class="emphasis e141" role="ital">facet</div> constrains the parameter value beyond the
               constraints implied by the parameter type. A facet has a facet type and a string
               value. Each facet type defines a particular type of constraint applying to parameter
               item values. The following table lists the framework-defined facets, as of writing.
               Besides these generic facets, topic tools may also define tool-specific facets (see
               
               <div class="xref e142" linkend="dev-advanced-usage"></div>).
            </div>
            <div class="para e143">
               
               <div class="table e144">
                  <div class="caption e145">
                     <div class="para e146">
                        
                        <div class="emphasis e147" role="bold">
                           <div class="emphasis e148" role="ital"> Parameter facets defined by
                              the 
                              <div class="code e149">ttools</div> framework.
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="metaBox e150"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e294').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e294" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e150'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e151"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e295').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e295" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e151'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e152">
                     <div class="tr e153" valign="top">
                        <div class="th e154" align="left" valign="top">Facet</div>
                        <div class="th e155" align="left" valign="top">Meaning</div>
                     </div>
                  </div>
                  <div class="tbody e156">
                     <div class="tr e157" valign="top">
                        <div class="td e158">length</div>
                        <div class="td e159">string length</div>
                     </div>
                     <div class="tr e160" valign="top">
                        <div class="td e161">minLength</div>
                        <div class="td e162">minimum string length</div>
                     </div>
                     <div class="tr e163" valign="top">
                        <div class="td e164">maxLength</div>
                        <div class="td e165">maximum string length</div>
                     </div>
                     <div class="tr e166" valign="top">
                        <div class="td e167">minInclusive</div>
                        <div class="td e168">minimum value, inclusive</div>
                     </div>
                     <div class="tr e169" valign="top">
                        <div class="td e170">maxInclusive</div>
                        <div class="td e171">maximum value, inclusive</div>
                     </div>
                     <div class="tr e172" valign="top">
                        <div class="td e173">minExclusive</div>
                        <div class="td e174">minimum value, exclusive</div>
                     </div>
                     <div class="tr e175" valign="top">
                        <div class="td e176">maxExclusive</div>
                        <div class="td e177">maximum value, exclusive</div>
                     </div>
                     <div class="tr e178" valign="top">
                        <div class="td e179">pattern</div>
                        <div class="td e180">regular expression</div>
                     </div>
                     <div class="tr e181" valign="top">
                        <div class="td e182">values</div>
                        <div class="td e183">enumeration</div>
                     </div>
                     <div class="tr e184" valign="top">
                        <div class="td e185">filter</div>
                        <div class="td e186">a name filter</div>
                     </div>
                     <div class="tr e187" valign="top">
                        <div class="td e188">future</div>
                        <div class="td e189">in the future (applicable to 
                           <div class="code e190">xs:date</div>,
                           
                           <div class="code e191">xs:dateTime</div> and 
                           <div class="code e192">xs:time</div>)
                        </div>
                     </div>
                     <div class="tr e193" valign="top">
                        <div class="td e194">past</div>
                        <div class="td e195">in the past (applicable to 
                           <div class="code e196">xs:date</div>,
                           
                           <div class="code e197">xs:dateTime</div> and 
                           <div class="code e198">xs:time</div>)
                        </div>
                     </div>
                     <div class="tr e199" valign="top">
                        <div class="td e200">nonFuture</div>
                        <div class="td e201">not in the future (applicable to 
                           <div class="code e202">xs:date</div>,
                           
                           <div class="code e203">xs:dateTime</div> and 
                           <div class="code e204">xs:time</div>)
                        </div>
                     </div>
                     <div class="tr e205" valign="top">
                        <div class="td e206">nonPast</div>
                        <div class="td e207">not in the past (applicable to 
                           <div class="code e208">xs:date</div>,
                           
                           <div class="code e209">xs:dateTime</div> and 
                           <div class="code e210">xs:time</div>)
                        </div>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e211"> The 
               <div class="code e212">_help</div> operation provides usage assistence, which is based on the
               tool scheme. An XML representation of the complete tool scheme can be obtained by
               calling 
               <div class="code e213">_help</div> with parameter 
               <div class="code e214">mode</div> set to
               
               <div class="code e215">scheme</div>, for example:
               
               <div class="programlisting e216" xml:space="preserve">   basex -b "request=? mode=scheme" /projects/xclear/xclear.xq</div>
               
            </div>
         </div><a name="ObjectparametertypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e217">
            <div class="title e218">Object parameter types</div>
            <div class="para e219">The topic tools framework defines several parameter types providing high value to
               the tool user, as well as to the tool developer. The parameter values are not
               treated as strings, but as shortcut representations of structured information. The
               structures obtained from the parameter values are recognized by powerful functions,
               and the behaviour of these functions conveys to the parameter value a special
               meaning. For example, when the string 
            </div>
            <div class="programlisting e220" xml:space="preserve">   get* fetch* ~*IFF#c*</div>
            <div class="para e221">is used as argument for a parameter of type 
               <div class="code e222">xs:string</div>, it is this
               string what arrives in the tool application. When the string is used as argument for
               a parameter of type 
               <div class="code e223">nameFilter</div>, however, the application does not
               receive a string, but a complex XML element, which contains elements and attributes
               representing positive and negative string matching conditions, regular expressions
               and regex options. The element is the XML representation of a filter, selecting
               names starting with “get” or “fetch” (case-insensitively), but excluding names
               ending with “IFF” (case-sensitively). The filtering behaviour is provided by
               functions that "understand" the element structure and to which the filter element
               is
               passed as a parameter. These functions and the XML element are of course designed
               jointly, the element for defining behaviour, and the functions for implementing
               behaviour. Element and functions should therefore be viewed as a conceptual unit
               encapsulating data and functionality, irrespective of whether the functions are
               formally bound to the element, as would only be possible when using an
               object-oriented language. Parameter types matching this pattern - they are parsed
               into specific elements which can be handled by specific functions - are therefore
               collectively called 
               <div class="emphasis e224" role="bold">object parameter types</div>.
               Conceptually, the user supplies objects, rather than strings. The user benefits from
               the high expressiveness of such parameters – the possibility to convey much
               information in a very concise way. The developer benefits from the rich
               functionality immediately available to him. An additional advantage for the user is
               the stylistic consistency which object parameter types enforce. Dealing with
               different operations and even with different topic tools, the style of specifying,
               say, name-based filtering is always the same.
            </div><a name="Namefilter()ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e225">
               <div class="title e226">Name filter (
                  <div class="code e227">nameFilter</div>)
               </div>
               <div class="para e228">The type 
                  <div class="code e229">nameFilter</div> enables the definition of a filter on names
                  which is very simple for simple requirements, and at the same time expressive
                  enough to enable very fine-grained filtering. The filter text is a
                  whitespace-separated list of one or more filter items. A filter item is either a
                  positive filter (if not prefixed by the character ~) or a negative filter (if
                  prefixed by ~). The filter retains all candidates which match at least one
                  positive item (if there are any positive items) and does not match any of the
                  negative items. Each filter item consists of a filter term, which may be
                  accompanied by options. Any options are appended to the term, using character #
                  as separator. A filter term can use glob syntax (if not accompanied by option
                  
                  <div class="code e230">r</div>) or regex syntax (if accompanied by option 
                  <div class="code e231">r</div>).
                  By default, filter terms are matched case-insensitively, unless accompanied by
                  option 
                  <div class="code e232">c</div>. The following table show a few examples of
                  
                  <div class="code e233">nameFilter</div> values.
               </div>
               <div class="table e234">
                  <div class="caption e235">
                     <div class="para e236">
                        
                        <div class="emphasis e237" role="bold">
                           <div class="emphasis e238" role="ital"> Examples of name filter
                              values and their meaning.
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="metaBox e239"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e477').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e477" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e239'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e240"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e478').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e478" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e240'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e241">
                     <div class="tr e242" valign="top">
                        <div class="th e243" align="left" valign="top">Filter string</div>
                        <div class="th e244" align="left" valign="top">Matches (case-insensitively if not
                           otherwise stated)
                        </div>
                     </div>
                  </div>
                  <div class="tbody e245">
                     <div class="tr e246" valign="top">
                        <div class="td e247">Book</div>
                        <div class="td e248">the string "book"</div>
                     </div>
                     <div class="tr e249" valign="top">
                        <div class="td e250">Book*</div>
                        <div class="td e251">a string starting with "book"</div>
                     </div>
                     <div class="tr e252" valign="top">
                        <div class="td e253">~Book*</div>
                        <div class="td e254">any string not starting with "book"</div>
                     </div>
                     <div class="tr e255" valign="top">
                        <div class="td e256">Find*Response</div>
                        <div class="td e257">a string starting with "find" and ending with "response"</div>
                     </div>
                     <div class="tr e258" valign="top">
                        <div class="td e259">Find*Response#c</div>
                        <div class="td e260">a string starting with "Find" and ending with "Response,
                           case-sensitively
                        </div>
                     </div>
                     <div class="tr e261" valign="top">
                        <div class="td e262">Find(Scart|Booking)RQ#r</div>
                        <div class="td e263">a string matching the regular expression, using regex option
                           'i'
                        </div>
                     </div>
                     <div class="tr e264" valign="top">
                        <div class="td e265">Find(Scart|Booking)RQ#rc</div>
                        <div class="td e266">a string matching the regular expression, 
                           <div class="emphasis e267" role="ital">not
                              
                           </div>using regex option 'i'
                        </div>
                     </div>
                     <div class="tr e268" valign="top">
                        <div class="td e269">*RQ#c *RS#c</div>
                        <div class="td e270">a string ending with “RQ” or “RS”, case-sensitively</div>
                     </div>
                     <div class="tr e271" valign="top">
                        <div class="td e272">~*Help* ~Options*</div>
                        <div class="td e273">any string not containing "help" and not starting with
                           "options"
                        </div>
                     </div>
                     <div class="tr e274" valign="top">
                        <div class="td e275">*RQ#c *RS#c ~*Help* ~Options*</div>
                        <div class="td e276">a string ending with “RQ” or “RS”, case-sensitively, but excluding
                           any strings containing "help" or starting with "options"
                        </div>
                     </div>
                  </div>
               </div>
            </div><a name="Namefiltermap()ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e277">
               <div class="title e278">Name filter map (
                  <div class="code e279">nameFilterMap</div>)
               </div>
               <div class="para e280">A related type is 
                  <div class="code e281">nameFilterMap</div>, which is a mapping of name
                  filters to values. The values are themselves constrained by a type, which
                  defaults to 
                  <div class="code e282">xs:string</div>. For example, the type specification
                  
                  <div class="code e283">nameFilterMap(xs:integer)</div> denotes a name filter map using
                  integer values, and 
                  <div class="code e284">nameFilterMap</div> denotes a name filter map using
                  string values. The value text is a % concatenated list of one or more entries.
                  An entry specifies a mapping in the form "value : nameFilter", or the default
                  value. If the default value contains a literal colon, it must be escaped with a
                  backslash. For example, the following map 
               </div>
               <div class="programlisting e285" xml:space="preserve">   10 % 0 :  *id *timestamp* % 100 : status</div>
               <div class="para e286"> specifies a default value (10) as well as two values (0 and 100,
                  respectively) bound to different name filters. Such a map could be used, for
                  example, for specifying the number of data values to be reported, dependent on
                  the element names. Then no values would be reported for elements with a name
                  ending on “id” or containing “timestamp”, 100 values for "status" elements, and
                  10 values for any elements not matching any of the two name filters. 
               </div>
            </div><a name="Pathfilter()ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e287">
               <div class="title e288">Path filter (
                  <div class="code e289">pathFilter</div>)
               </div>
               <div class="para e290">Another derivative of name filters is the 
                  <div class="code e291">pathFilter</div> type. It
                  consists of a sequence of name filters, separated by single or double slashes,
                  and it can be used to filter name paths (e.g. XPath data paths or qualified file
                  names). Each name filter specifies a step, which is applied either to the
                  children of the previous step (if preceded by a single slash) or to its
                  descendants (if preceded by a double slash). If the first step is not preceded
                  by a slash, the filter behaves as if the first step were preceded by a double
                  slash: the first step may match any step in the path. Contrary, if the first
                  step is preceded by a slash, it must match the first step of the path. For
                  example, the following path filter: 
               </div>
               <div class="programlisting e292" xml:space="preserve">   2.0/*.xsd</div>
               <div class="para e293">matches any path with a last step matching 
                  <div class="code e294">*.xsd</div> and a second
                  last step matching 
                  <div class="code e295">2.0</div>. Path filters may be used, for example, in
                  order to select XML items according to their name and location within a
                  document, or to select files according to their name and location in the file
                  system.
               </div>
            </div><a name="DirectoryFilterDescriptors(%0A)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e296" xml:id="user-dfd">
               <div class="title e297">Directory Filter Descriptors (
                  <div class="code e298">docDFD</div>,
                  
                  <div class="code e299">txtDFD</div>)
               </div>
               <div class="para e300">A very important reuse of name and path filters is given by 
                  <div class="emphasis e301" role="bold">Document Filter Descriptors</div> (the types
                  
                  <div class="code e302">docDFD</div>, 
                  <div class="code e303">textDFD</div> and 
                  <div class="code e304">csvDFD</div>). They
                  serve to select files (XML, text or csv files) from directories. A filter
                  descriptor consists of two or three % separated fields. The first field is a
                  whitespace separated list of one or more directories in which to search for
                  files. If a directory name is preceded by character ^, the directory is searched
                  recursively, that is, the search includes all direct or indirect sub
                  directories. The second field specifies a name filter which is applied to file
                  names – only files with matching name may be selected. An optional third field
                  refines recursive search. It supplies a path filter, which constrains the (sub)
                  directories from which files can be selected. For example, the following
                  value
               </div>
               <div class="programlisting e305" xml:space="preserve">   ^/projects/niem-2.1 ^/projects/niem-2.0 /project/niem-submissions % *.xsd</div>
               <div class="para e306">selects all xsd files in or under one of the niem directories, or in the
                  directory 
                  <div class="code e307">niem-submissions</div>. Adding a path filter, like so:
               </div>
               <div class="programlisting e308" xml:space="preserve">   ^/projects/niem-2.1 ^/projects/niem-2.0 /project/niem-submissions % *.xsd % edxl*//*</div>
               <div class="para e309">would restrict recursive findings to files found in a directory located under
                  (but not in) a directory with a name starting with “edxl”. A parameter of type
                  
                  <div class="code e310">docDFD</div> only selects XML files, ignoring any non-XML files
                  matching the descriptor; the effective parameter value (the value delivered to
                  the application) is a sequence of document nodes. A parameter of type
                  
                  <div class="code e311">txtDFD</div> selects all files matching the descriptor, and the
                  effective parameter value is a sequence of strings, each string providing the
                  contents of one file. A parameter of type 
                  <div class="code e312">csvDFD</div>, finally, also
                  selects all files matching the desciptor, but treats them as csv files and
                  delivers to the application XML documents, each one representing the rows and
                  cells of one csv file.
               </div>
            </div><a name="Documentcatalog()ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e313" xml:id="user-dcat">
               <div class="title e314">Document catalog (
                  <div class="code e315">docCAT</div>)
               </div>
               <div class="para e316">A document catalog (dcat) is an XML document containing a collection of
                  references to other documents. The parameter type 
                  <div class="code e317">dcat</div> has the
                  following semantics: the user-supplied value is the document URI of a dcat; the
                  value delivered to the tool application is the collection of all documents
                  referenced by the dcat. A dcat can be created automatically by calling the
                  built-in operation 
                  <div class="code e318">dcat</div> and supplying to it a directory filter
                  descriptor.
               </div>
            </div><a name="ToolspecificobjectparametertypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e319">
               <div class="title e320">Tool specific object parameter types</div>
               <div class="para e321">The preceding sections introduced several object parameter types supported by
                  any topic tool conforming to the model described in this paper. Apart from
                  these, any topic tool may define 
                  <div class="emphasis e322" role="ital">tool-specific</div>
                  parameter types, including object parameter types. The 
                  <div class="code e323">_help</div>
                  operation supports a mode 
                  <div class="code e324">types</div> which explains all generic as well
                  as any tool-specific parameter types. See 
                  <div class="xref e325" linkend="dev-advanced-usage"></div>
                  for details about the implementation of tool-specific parameter types.
               </div>
               <div class="para e326">As an example, 
                  <div class="code e327">otdsv</div>, a topic tool for inspecting touristic data
                  conforming to the OTDS data model ([
                  <div class="xref e328" linkend="otds"></div>]), uses a
                  tool-specific parameter type 
                  <div class="code e329">travelScenario</div>. A parameter value
                  defines a trip in terms of booking date, start date and duration, as well as the
                  ages or birthdates of all travellers. The following parameter value:
               </div>
               <div class="programlisting e330" xml:space="preserve">   2014-04-02 2014-12-06 14 % 32 31 5 2</div>
               <div class="para e331">specifies a travel booked on 2014-04-02, starting on 2014-12-06 and lasting
                  for 14 days, made by four persons aged 32, 31, 5 and 2 years. The tool
                  implementation does not see the string, but a structured representation which is
                  understood by various functions related to travel scenarios.
               </div>
            </div>
         </div><a name="StoringandreusinginvocationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e332">
            <div class="title e333">Storing and reusing invocation</div>
            <div class="para e334">Complex functionality tends to involve a considerable number of invocation
               parameters, and object parameter types invite rather complex parameter values. A
               call with four or more parameters is a bit of a strain, and the more so if they
               involve object parameters. On the other hand, routine use of topic tools can be
               fairly repetitive, using often very similar calls which are only distinguished by
               a
               parameter or two, whereas several other parameters are set to the same values every
               time. In such situations in can be helpful to store invocations and reuse them
               either verbatim or partially overwriting or extending them on a call by call basis.
               Every topic tool supports the 
               <div class="code e335">storeq</div> feature: if called with two
               question marks (instead of a single question mark), the tool returns a simple XML
               representation of the invocation. After storing the invocation in a file, it can be
               referenced in future tool invocations, omitting the operation name and using the
               file name instead, preceded by the character @. An example follows.
            </div>
            <div class="para e336">Saving an invocation:</div>
            <div class="programlisting e337" xml:space="preserve">   basex –b 'request=priceItems??otds=/projects/otds/otds.xml, cond=occupancy personImpact
               
               dayImpact conditionalTags, scope=all, class=*, absolute' otdsv.xq &gt; piStd.tti
            </div>
            <div class="para e338">Reusing it unchanged:</div>
            <div class="programlisting e339" xml:space="preserve">   basex –b 'request=@piStd.tti' otdsv.xq</div>
            <div class="para e340">Reusing and partially overwriting and extending it:</div>
            <div class="programlisting e341" xml:space="preserve">   basex –b 'request=@piStd.tti?scope=absolute, summary' otdsv.xq</div>
         </div><a name="SummaryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e342">
            <div class="title e343">Summary</div>
            <div class="para e344">To summarize, the user of topic tools benefits from several features:</div>
            <div class="itemizedlist e345">
               <div class="listitem e346">
                  <div class="para e347">single point of access to a whole range of functionality (a
                     "topic")
                  </div>
               </div>
               <div class="listitem e348">
                  <div class="para e349">uniform invocation pattern for all operations and all topic tools</div>
               </div>
               <div class="listitem e350">
                  <div class="para e351">high expressiveness enabled by object type parameters</div>
               </div>
               <div class="listitem e352">
                  <div class="para e353">syntactical sugar (name completion, shortcut for Boolean values)</div>
               </div>
               <div class="listitem e354">
                  <div class="para e355">comprehensive help functionality</div>
               </div>
               <div class="listitem e356">
                  <div class="para e357">user-friendly input error diagnostics</div>
               </div>
               <div class="listitem e358">
                  <div class="para e359">invocation reuse</div>
               </div>
            </div>
            <div class="para e360">The next section explains how topic tools are developed. It introduces a very
               lightweight framework which enables the developer to create topic tools quickly, to
               extend them with minimum effort, and to achieve high quality.
            </div>
         </div>
      </div><a name="Topictools:developerperspectiveANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e361">
         <div class="title e362">Topic tools: developer perspective</div>
         <div class="para e363">A topic tool is expected to support a well-structured command-line interface, perform
            fine-grained input validation, report user input errors in a comprehensive way and
            offer
            rich help functionality. Furthermore, remembering the high complexity which a topic
            tool
            may easily attain (many operations and all in all very many parameters), one might
            expect that topic tools are hard to create, to maintain and to extend. 
         </div>
         <div class="para e364">Using the 
            <div class="code e365">ttools</div> framework, the contrary is the case: development is
            easy, fast and, hopefully, enjoyable. Adding a topic tool operation is by far easier
            and
            faster than implementing its functionality by a new, non-topic tool written from
            scratch. An added topic tool operation conforms to the behavioural expectations (smart
            syntax, validation, error reporting and help) from the first minute of its prototypic
            existence. Achievement of this behaviour might easily take weeks to attain (and months
            to un-bug) if implemented as part of the tool development, rather than being provided
            by
            the framework via code generation and libraries. A new topic tool is instantiated
            in a
            minute, and in typical settings a first useful and deliverable version is ready after
            a
            few hours of work. After the initial shot, the tool tends to grow quickly and
            organically, no matter if guided by a complex set of initial requirements, or in
            response to frequently emerging requirements, or both. In all cases, growth is
            facilitated by the fact that the current amount of functionality does not create a
            burden making the addition of new functionality more difficult. To add a second or
            a
            twenty second operation tends to require the same amount of work, or usually the
            addition of operations even becomes increasingly simple thanks to utilities which
            have
            been created along the way to the current state.
         </div>
         <div class="para e366"> This section explains how to write topic tools using the 
            <div class="code e367">ttools</div>
            framework. It starts with a high level overview of the support offered by
            
            <div class="code e368">ttools</div>. It summarizes the workflow of tool development, describes how
            XQuery programming is facilitated and how code writing is complemented by the writing
            of
            annotations. This overview will be followed by a brief tutorial intended to give you
            a
            hands-on impression of the process of developing a topic tool. The tutorial takes
            you
            through the steps of creating a new topic tool and filling it with a first set of
            functionality. The final part of this section on topic tool development will discuss
            advanced usage of 
            <div class="code e369">ttools</div>: it explains how to extend the infrastructure
            provided by 
            <div class="code e370">ttools</div>, defining new parameter types and new parameter facets. 
         </div><a name="OverviewANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e371">
            <div class="title e372">Overview</div>
            <div class="para e373">The development support offered by 
               <div class="code e374">ttools</div> has four main
               aspects:
            </div>
            <div class="itemizedlist e375">
               <div class="listitem e376">
                  <div class="para e377">Code generation</div>
               </div>
               <div class="listitem e378">
                  <div class="para e379">Pseudo objects</div>
               </div>
               <div class="listitem e380">
                  <div class="para e381">Utility functions</div>
               </div>
               <div class="listitem e382">
                  <div class="para e383">Built-in operations</div>
               </div>
            </div>
            <div class="para e384">The main module of a topic tool is generated. Code generation is based on
               
               <div class="emphasis e385" role="ital">annotations</div> scattered over XQuery library
               modules. Annotations are not formal annotations as defined by XQuery 3.0, but XML
               snippets placed in XQuery comments conforming to a syntax convention. Annotations
               typically define tool operations in terms of an operation name and the names, types
               and other properties of operation parameters. Annotations may also define new
               parameter types and new kinds of parameter facets. 
            </div>
            <div class="para e386"> Code generation is effected by an application 
               <div class="emphasis e387" role="ital">build</div>. The build is triggered by a command line call of
               
               <div class="code e388">ttools</div>, which is a topic tool for building topic tools. The build
               call provides a tool name and a tool directory. During an application build,
               
               <div class="code e389">ttools</div> investigates all library modules found in the application
               directory, and all annotations which they contain are used. The independent
               annotations scattered over the modules are integrated into a single model of tool
               functionality, called the 
               <div class="emphasis e390" role="ital">tool scheme</div>. A tool
               scheme defines tool functionality in terms of named operations and
               operation-specific sets of parameters. 
            </div>
            <div class="para e391">The tool scheme is translated into an XQuery main module implementing a command
               line interface which gives access to all operations. On invocation, the main module
               parses, evaluates and validates user input, creating a comprehensive error report,
               if errors occur. Otherwise the main module integrates user input into an XML
               
               <div class="emphasis e392" role="ital">request message</div> and invokes the 
               <div class="emphasis e393" role="ital">operation provider function</div>, the function which
               implements the operation. The provider function is hand-written by the tool
               developer. It has a standardized signature, receiving a single parameter which is
               the request message assembled by the main module, and producing an
               annotation-defined result type. The request message is an XML element intended to
               be
               used exclusively via a set of access functions designed for the purpose. These
               access functions can be regarded as the 
               <div class="emphasis e394" role="ital">message
                  interface
               </div>, functionality bound to its data content. The request
               message thus resembles a program object, which hides user 
               <div class="emphasis e395" role="ital">input data</div> behind an interface of accessors to 
               <div class="code e396">input
                  information
               </div>.
            </div>
            <div class="para e397">For example, if a parameter is typed as a document URI, the user data is a URI,
               but the accessor returns a document node. While the user supplies a multiple-valued
               parameter as a concatenated string, the accessor delivers the parameter as a
               sequence of typed items. Annotation-defined default values are delivered in a way
               indistinguishable from explicitly supplied parameters. The difference between input
               data and input information is especially relevant in the case of object parameters
               (e.g. name filters), where input data are strings from which “objects” are
               constructed: XML elements designed to provide functionality when passed to the
               appropriate functions (e.g. 
               <div class="code e398">tt:matchesNameFilter</div>). It is important to
               realize how the use of the request object and its accessor interface in general, and
               the use of object parameters in particular, may simplify the work of application
               writing significantly. 
            </div>
            <div class="para e399">
               <div class="code e400">ttools</div> based development profits from 
               <div class="emphasis e401" role="ital">utility
                  functions
               </div> in a dual way: (a) using “object functions”, as just
               described, which are functions designed for use with XML elements constructed by
               
               <div class="code e402">ttools</div> infrastructure; (b) general purpose functions, providing
               useful functionality not related to 
               <div class="code e403">ttools</div> specific structures.
               Examples of general purpose functions are a function for parsing CSV formatted text
               and a function for creating tabular text.
            </div>
            <div class="para e404">Every 
               <div class="code e405">ttools</div> based topic tool supports a range of 
               <div class="emphasis e406" role="ital">built-in operations</div>, implemented by modules which are
               automatically added to the tool directory during tool instantiation. A prominent
               role plays the generic 
               <div class="emphasis e407" role="ital">help operation</div>, which
               translates the tool scheme into usage information. Other built-in operations provide
               generic functionality which may add to the usefulness of the topic tool. As an
               example, built-in operation 
               <div class="code e408">doctypes</div> reports the document types (root
               element names and namespaces) encountered in a set of XML resources, which may be
               specified by any combination of document URIs, directory filter descriptors (see
               
               <div class="xref e409" linkend="user-dfd"></div>) and document catalogs. Using further parameters,
               additional information about the documents can be requested.
            </div>
         </div><a name="WorkflowANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e410">
            <div class="title e411">Workflow</div>
            <div class="para e412">The 
               <div class="code e413">ttools</div> based development of a topic tool can be schematically
               described as the following workflow.
            </div>
            <div class="orderedlist e414">
               <div class="listitem e415">
                  <div class="para e416">
                     <div class="emphasis e417" role="bold">Tool instantiation</div> – command line call
                     creating and initializing the new topic tool.
                  </div>
               </div>
               <div class="listitem e418">
                  <div class="para e419">
                     <div class="emphasis e420" role="bold">Prototyping</div> – command line call creating
                     the initial version of a new XQuery library module, intended to implement a
                     list of operations specified by a call parameter; the generated code
                     contains initial versions of annotations and function definitions; the
                     generated module is immediately callable after re-building the topic tool
                     (see below).
                  </div>
               </div>
               <div class="listitem e421">
                  <div class="para e422">
                     <div class="emphasis e423" role="bold">XQuery code writing </div> – developing the
                     functions which implement the operations, as well as auxiliary functions, as
                     appropriate.
                  </div>
               </div>
               <div class="listitem e424">
                  <div class="para e425">
                     <div class="emphasis e426" role="bold">Annotation editing </div> – adding the
                     definitions of new operations, or changing / extending the definitions of
                     existing operations.
                  </div>
               </div>
               <div class="listitem e427">
                  <div class="para e428">
                     <div class="emphasis e429" role="bold">Tool building </div> – command line call
                     re-building the tool, translating the current annotations into the command
                     line interface.
                  </div>
               </div>
               <div class="listitem e430">
                  <div class="para e431">
                     <div class="emphasis e432" role="bold">Tool testing.</div>
                  </div>
               </div>
            </div>
         </div><a name="WritingXQuerycodeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e433">
            <div class="title e434">Writing XQuery code</div>
            <div class="para e435">Coding is significantly simplified by the packaging of all input information into
               a single container (the request message) and its exposal via accessor functions
               (e.g. 
               <div class="code e436">tt:getParam</div>). Especially helpful are three facts:
            </div>
            <div class="itemizedlist e437">
               <div class="listitem e438">
                  <div class="para e439">
                     <div class="emphasis e440" role="ital">Guaranteed availability</div>. Any mandatory
                     operation parameter 
                     <div class="emphasis e441" role="ital">is</div> supplied. If it were
                     not, the function would not be called in the first place. Whether or not the
                     annotation declares a default value, concerns user convenience, but not the
                     developer: a mandatory value is present.
                  </div>
               </div>
               <div class="listitem e442">
                  <div class="para e443">
                     <div class="emphasis e444" role="ital">Guaranteed validity</div>. For any operation
                     parameter a 
                     <div class="emphasis e445" role="ital">valid</div> value is supplied.
                     Validity refers to the type specification including item type, cardinality
                     constraints and optional facets. The developer can simplify his work by
                     protecting himself from inappropriate values: he can add facets to the
                     parameter annotation, e.g. specifying enumerated values, a regular
                     expression, minimum or maximum values. The infrastructure will not call the
                     function unless user input satisfies all constraints.
                  </div>
               </div>
               <div class="listitem e446">
                  <div class="para e447">
                     <div class="emphasis e448" role="ital">Object parameters</div>. The definition of
                     particular parameter types prescribes the parsing of user-provided text
                     value, resulting in the construction of “objects”, which are XML elements
                     designed to be processed by functions. An example is the parsing of a name
                     filter string into a name filter element which can be passed to a
                     
                     <div class="code e449">tt:matchesNameFilter</div> function. The use of object parameters
                     can reduce the complexity of application development, as the request
                     accessors deliver the objects, not the source text.
                  </div>
               </div>
            </div>
            <div class="para e450">An interesting aspect concerns the information flow between XQuery functions. When
               the operation providing function delegates some tasks to other functions, these may
               have a function signature including a request message parameter. The request message
               passed on may be constructed from scratch, as the message interface includes
               functions enabling such a construction. But it may also be the original request, or
               a modified copy of it - the request interface includes functions for creating copies
               with parameters removed, overwritten or added. When the request passed on is not
               constructed from scratch, but received from the outside, whether or not subsequently
               modified before being passed on, it may carry information which the called function
               evaluates, but which the calling function need not be aware of. As an example,
               consider a function which operates on the results of some kind of search. Such a
               function may pass the original request on to the search function, trusting the
               request (which it received from the user and which has passed validation) to contain
               all information relevant to the search function. Now the search function may
               
               <div class="emphasis e451" role="ital">evolve</div>, incrementally extend its parameter
               usage and evaluate additional input parameters, without the calling function being
               aware of it – search control parameters do not concern it and are not inspected. As
               a result, the search function may evolve freely and independently of other functions
               operating on the search results, as the request message 
               <div class="emphasis e452" role="ital">hides</div> the changes of search related input. If today the search
               function begins to evaluate some additional input, the code of search result
               processing functions need not be changed. The only adaptation necessary concerns the
               annotations: in order to benefit from the extended search functionality, a search
               result processing operation should add the new, search related parameters to its own
               operation signature. But even this adaptation can as well be postponed, until the
               need is felt. 
            </div>
            <div class="para e453">Such an interaction of functions may be called message-based – as opposed to
               parameter list based. 
               <div class="code e454">ttools</div> provides a sophisticated set of message
               related functionality, including functions for transforming messages by extension,
               value overwriting and reduction. The primary use of this functionality is the
               dealing with the original request message, constructed by infrastructure from user
               input. However, beyond that, the availability of message related functionality
               encourages the practise of message-based interactions among functions. A recommended
               design pattern of topic tools can be summarized as follows: (a) identify pieces of
               core functionality, which have a 
               <div class="emphasis e455" role="ital">potentially growing set of
                  input information
               </div>; (b) provide such functionality with a
               message-based signature, rather than a parameter list based signature. This approach
               can considerably help in the process of evolving complex applications in a safe
               way.
            </div>
         </div><a name="WritingannotationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e456">
            <div class="title e457">Writing annotations</div>
            <div class="para e458">Writing code and editing the annotations are two activities performed in tandem.
               While writing the code of an operation, the developer switches over to the
               annotations whenever he decides to modify operation input, typically by adding a
               further control parameter. Then he resumes code writing, referring to the added
               parameters using request message accessors.
            </div>
            <div class="para e459">The annotation of an operation defines the operation in terms of its parameters.
               For every parameter, the following information is specified (the last two items
               optionally):
            </div>
            <div class="itemizedlist e460">
               <div class="listitem e461">
                  <div class="para e462">parameter name</div>
               </div>
               <div class="listitem e463">
                  <div class="para e464">parameter type, including cardinality (e.g. ?, *, {3}, {1,3})</div>
               </div>
               <div class="listitem e465">
                  <div class="para e466">facets (e.g. regular expression, value list, minimum/maximum
                     values)
                  </div>
               </div>
               <div class="listitem e467">
                  <div class="para e468">membership in parameter groups (for joint cardinality constraints, e.g.
                     when at least one of several parameters must be supplied)
                  </div>
               </div>
            </div>
            <div class="para e469">The editing of annotations takes effect immediately after re-building the topic
               tool. This is achieved by a command line call (invoking the 
               <div class="code e470">build</div>
               operation of 
               <div class="code e471">ttools</div>) and usually lasts less than a second.
            </div>
         </div><a name="AdvancedusageextendingtheframeworkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e472" xml:id="dev-advanced-usage">
            <div class="title e473">Advanced usage - extending the framework</div>
            <div class="para e474">Developing topic tools using the 
               <div class="code e475">ttools</div> framework gives access to the
               automated construction of object parameters and automated facet validation.
               
               <div class="code e476">ttools</div> ships with a range of built-in object parameter types and
               facet kinds.
            </div>
            <div class="para e477">A topic tool may extend the framework by defining 
               <div class="emphasis e478" role="ital">tool
                  specific
               </div> parameter types and facet kinds. This is very easily done.
               In order to define a tool specific object parameter type, one has to write a parsing
               function which constructs from an input string an element of the appropriate
               structure. The signature must take a single input parameter of type
               
               <div class="code e479">xs:string</div>, and the return value must be a single item of
               arbitrary type (
               <div class="code e480">item()</div>).
               Similarly, in order to define an additional facet kind, one must write a facet
               validation function which will validate a parameter value item against the new facet
               kind. The signature must take two input parameters, the first of type
               
               <div class="code e481">item()</div> receiving the value item to be checked, the second of type
               
               <div class="code e482">xs:string</div> receiving the facet value; the return value must be
               
               <div class="code e483">element(z:errors)?</div>. A library module containing type definitions
               and/or facet validation functions must contain an annotation of type
               
               <div class="code e484">extensions</div>, which binds the parsing functions to parameter types
               and the facet validation functions to facet kinds. The implementation of framework
               extensions may for example look as follows:
            </div>
            <div class="programlisting e485" xml:space="preserve">
               (:~ 
               : ttoolsExtensions.mod.xq - application specific extensions of the parameter parser
               and facet validator.
               :)
               
               (:~@extensions
               &lt;extensions&gt;
               &lt;type name="travelScenario" parser='parseTravelScenario'/&gt;
               &lt;facet name="blacklisted" validator='checkBlacklisted'/&gt;    
               &lt;/extensions&gt;    
               :)
               module namespace m="http://www.ttools.org/otdsv/xquery-functions";
               ...
               declare namespace z="http://www.ttools.org/structure";
               ...
               declare function m:parseTravelScenario($text as xs:string)    
               as item() {...}
               
               declare function m:checkBlacklisted($item as item(), $facetValue as xs:string)   
               
               as element(z:errors)? {...}
            </div>
            <div class="para e486">After dropping this library module into the tool directory, the annotations of
               operations may define parameters of type 
               <div class="code e487">travelScenario</div> and constrain
               parameters to conform to a 
               <div class="code e488">blacklisted</div> facet. The definition of
               additional object parameter types is typically accompanied by functions taking
               elements of the respective structure as input. These functions constitute the
               "interface" of the new object type and largely determine the value which the object
               type has for the tool application. 
            </div>
            <div class="para e489">It should be remembered that object construction and facet validation are
               performed automatically, so that the application never needs to call the functions
               which it provides for the definition of additional types and the evaluation of
               additional facet kinds.
            </div>
         </div><a name="SummaryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e490">
            <div class="title e491">Summary</div>
            <div class="para e492">The development of a topic tool is simplified by code generation. What remains to
               be done is the writing of functions which are exposed as operations. Code writing
               is
               accompanied by annotation editing, which provides the code with an environment of
               validated information. Frequent extension of this information – for example caused
               by stepwise refinement of functionality – is accomplished in a painless way.
               Whenever the need arises, just add a parameter to the operation annotation: from now
               on the parameter value is available to the operation code.
            </div>
            <div class="para e493">Code writing is greatly simplified by having all external input encapsulated in a
               single container – the request message – which is accessed via functions, completely
               isolating application code from the original forms of external input. Application
               code is thus embedded in an infrastructure which takes on the responsibility of
               input validation and input augmentation. In the case of so-called object parameter
               types, the embedding infrastructure transforms user input into entities
               corresponding to program objects. 
            </div>
            <div class="para e494">The message-related functionality provided by 
               <div class="code e495">ttools</div> also encourages
               the use of messages in function signatures in general, whether or not the function
               is exposed as a topic tool operation. Messages enable the "tunneling" of
               information, so that a calling function may be unawares of the information
               requirements of the called function. The use of message-controlled functions thus
               favours a robust integration of complex functionalities - like search and
               processings of search result - which is an important concern in general, and when
               developing topic tools in particular.
            </div>
         </div>
      </div><a name="GettingstartedwithtopictoolsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e496">
         <div class="title e497">Getting started with topic tools</div>
         <div class="para e498">This part of the paper proposes a short tutorial which may give you some hands-on
            impressions of the development of topic tools. We set out to create the first version
            of
            a command line tool which assists the user in the analysis of XML resources. We have
            already downloaded 
            <div class="code e499">ttools</div> (download URI will be added here), which is
            itself a topic tool supporting the development of topic tools. We have further installed
            BaseX ([
            <div class="xref e500" linkend="w3c-xquery"></div>]), an open source XQuery processor supporting
            XQuery 3.0.
         </div>
         <div class="para e501"> We decide to call the new tool 
            <div class="code e502">xclear</div>, and we plan to supply the first
            version with three operations: 
         </div>
         <div class="itemizedlist e503">
            <div class="listitem e504">
               <div class="para e505">
                  <div class="code e506">names</div> - reports names of elements and attributes
               </div>
            </div>
            <div class="listitem e507">
               <div class="para e508">
                  <div class="code e509">paths</div> - reports data paths of elements and attributes
               </div>
            </div>
            <div class="listitem e510">
               <div class="para e511">
                  <div class="code e512">values</div> - reports data content of elements and attributes
               </div>
            </div>
         </div>
         <div class="para e513"> In what follows, we assume that the 
            <div class="code e514">ttools</div> installation directory is
            
            <div class="code e515">/projects/ttools</div>, and that 
            <div class="code e516">xclear</div> shall be installed in
            directory 
            <div class="code e517">/projects/xclear</div>. 
         </div><a name="ToolinstantiationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e518">
            <div class="title e519">Tool instantiation</div>
            <div class="para e520">The very first step of tool development is tool instantiation. We call the
               
               <div class="code e521">ttools</div> operation 
               <div class="code e522">new</div>, specifying a 
               tool directory whose name is equal to the intended tool name:
            </div>
            <div class="programlisting e523" xml:space="preserve">
               basex -b "request=new?dir=/projects/xclear" /projects/ttools/ttools.xq
               
               ==&gt;
               ===============================================================
               
               Topic tool created:  xclear
               Tool directory:      /projects/xclear
               
               The tool can already be called. Example:
               basex -b "request=?" /projects/xclear/xclear.xq
               
               Use operation 'add' for adding module prototypes. Example:
               basex -b "request=add?dir=/projects/xclear, mod=fooMod, ops=fooOp barOp foobarOp"
               /projects/ttools/ttools.xq
               
               ===============================================================
            </div>
            <div class="para e524"> As a result, the tool directory 
               <div class="code e525">xclear</div> has been created and filled
               with various XQuery library modules, as well as a generated main module
               
               <div class="code e526">xclear.xq</div>, which can be called. 
            </div>
            <div class="programlisting e527" xml:space="preserve">
               01.07.2014  22:12             4.473 xclear.xq
               07.04.2014  23:47               599 _constants.mod.xq
               27.04.2014  12:50             8.656 _csvParser.mod.xq
               28.06.2014  13:11            11.855 _dcat.mod.xq
               28.06.2014  12:39             5.172 _docs.mod.xq
               01.07.2014  22:12             1.155 _extensions.mod.xq
               29.06.2014  08:52             8.333 _help.mod.xq
               15.04.2014  00:09            19.666 _nameFilter.mod.xq
               15.04.2014  00:13            14.944 _nameFilter_parser.mod.xq
               07.04.2014  22:29            20.893 _namespaceTools.mod.xq
               07.04.2014  22:29             1.744 _reportAssistent.mod.xq
               29.06.2014  09:38            55.935 _request.mod.xq
               28.06.2014  13:18            10.144 _request_getters.mod.xq
               12.04.2014  08:29             2.908 _request_parser.mod.xq
               28.06.2014  12:02             3.260 _request_setters.mod.xq
               27.04.2014  14:37             3.606 _stringTools.mod.xq
            </div>
         </div><a name="ExploringtheinitialtoolversionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e528">
            <div class="title e529">Exploring the initial tool version</div>
            <div class="para e530">A topic tool has a single parameter, 
               <div class="code e531"> request</div>. If supplied with the
               parameter value “?”, a topic tool is expected to give an overview of its operations.
               We give it a try:
            </div>
            <div class="programlisting e532" xml:space="preserve">
               basex -b "request=?" /projects/xclear/xclear.xq            
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ====================================================
               _help        default, mode, ops?, type
               dcat         dfd+
               docs         dcat*, doc*, docs*
               doctypes     attNames, dcat*, doc*, docs*, elemNames
               ====================================================
            </div>
            <div class="para e533"> Our freshly created tool has already four operations! Operation
               
               <div class="code e534">_help</div> is what is called when the request value starts with a
               question mark, rather than an operation name. The other three operations are
               built-in operations augmenting the functionality of any topic tool we build using
               
               <div class="code e535">ttools</div>. For example, operation 
               <div class="code e536">doctypes</div> provides basic
               information about a set of documents. In order to take a closer look at its
               parameters, we refine our 
               <div class="code e537">_help</div> request, specifying the Boolean
               parameters 
               <div class="code e538">type</div> and 
               <div class="code e539">default</div>, in order to learn the
               parameter types and see any default values. We narrow down the response to operation
               
               <div class="code e540">doctypes</div> by setting the optional parameter 
               <div class="code e541">ops</div> to the
               value 
               <div class="code e542">doct*</div>: 
            </div>
            <div class="programlisting e543" xml:space="preserve">
               basex -b "request=?default, type, ops=doct*" /projects/xclear/xclear.xq
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ==========================================================================
               doctypes     attNames=false...... : xs:boolean
               dcat................ : docCAT* (sep=WS)
               doc................. : docURI* (sep=WS)
               docs................ : docDFD* (sep=;)
               elemNames=false..... : xs:boolean
               At least 1 of these parameters must be set: dcat, doc, docs
               ==========================================================================
            </div>
            <div class="para e544">The parameter types 
               <div class="code e545">docURI</div>, 
               <div class="code e546">docDFD</div> and
               
               <div class="code e547">docCAT</div> are very important, because they are 
               <div class="emphasis e548" role="ital">the</div> parameter types used for supplying the tool with 
               XML documents. If an operation demands input which may consist of a set of documents,
               rather than necessarily a single document, it is a recommended pattern to use a
               triple of parameters of type 
               <div class="code e549">docURI</div>, 
               <div class="code e550">docDFD</div> and
               
               <div class="code e551">docCAT</div>, respectively, and (if appropriate) mark them as a group of
               which at least one parameter must be set. This gives the user great freedom how to
               supply input documents, as he can use any combination of three approaches:
            </div>
            <div class="itemizedlist e552">
               <div class="listitem e553">
                  <div class="para e554">
                     <div class="code e555">docURI</div> typed parameter: expects a document URI
                  </div>
               </div>
               <div class="listitem e556">
                  <div class="para e557">
                     <div class="code e558">docDFD</div> typed parameter: expects a directory filter
                     descriptor
                  </div>
               </div>
               <div class="listitem e559">
                  <div class="para e560">
                     <div class="code e561">docCAT</div> typed parameter: expects the document URI of a
                     document catalog ("dcat")
                  </div>
               </div>
            </div>
            <div class="para e562"> A dcat can be created calling operation 
               <div class="code e563">dcat</div> and supplying it with a
               document filter descriptor. If stored in a file, the dcat can later be supplied to
               any parameter of type 
               <div class="code e564">docCAT</div>. To get a feeling for our new tool, we
               invoke operation 
               <div class="code e565">doctypes</div>, supplying it with a directory filter
               descriptor. Suppose we are interested in the XML resources directly or indirectly
               contained by a directory 
               <div class="code e566">/projects/xsd/niem-2.1</div>. This is how we request
               a 
               <div class="code e567">doctypes</div> report: 
            </div>
            <div class="programlisting e568" xml:space="preserve">
               basex -b "request=doctypes?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:doctype name="schema@http://www.w3.org/2001/XMLSchema" count="123"&gt;
               &lt;doc href="file:///C:/projects/xsd/niem-2.1/ansi-nist/2.0/ansi-nist.xsd"/&gt;
               &lt;doc href="file:///C:/projects/xsd/niem-2.1/ansi_d20/2.0/ansi_d20.xsd"/&gt;
               &lt;doc href="file:///C:/projects/xsd/niem-2.1/apco/2.1/apco.xsd"/&gt;
               ...
               &lt;/z:doctype&gt;
            </div>
            <div class="para e569">We just used a directory filter descriptor as input to an operation. One may also
               first use it to create a dcat, and later use this dcat in order to supply an
               operation with all documents which the dcat references. To create a dcat, we call
               the built-in 
               <div class="code e570">dcat</div> operation, supplying the directory filter descriptor
               as value of parameter 
               <div class="code e571">dfd</div>:
            </div>
            <div class="programlisting e572" xml:space="preserve">
               basex -b "request=dcat?dfd=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;dcat dirs="^/projects/xsd/niem-2.1" files="" subDirs="" countFiles="123" t="2014-04-18T12:57:44+02:00"
               
               xml:base="file:///C:/projects/xclear/"&gt;
               &lt;doc href="file:/projects/xsd/niem-2.1/ansi-nist/2.0/ansi-nist.xsd"/&gt;
               &lt;doc href="file:/projects/xsd/niem-2.1/ansi_d20/2.0/ansi_d20.xsd"/&gt;
               &lt;doc href="file:/projects/xsd/niem-2.1/apco/2.1/apco.xsd"/&gt;
               ...
               &lt;/dcat&gt;
            </div>
            <div class="para e573">If we store the output in a file (say,
               
               <div class="code e574">/projects/dcats/dcat-niem-2.1.xml</div>), we can then supply the file
               name to any parameter of type 
               <div class="code e575">docCAT</div>, effectively passing to the tool
               all documents referenced by the catalog. For example, the following call of
               
               <div class="code e576">doctypes</div> yields the same result as the first one:
            </div>
            <div class="programlisting e577" xml:space="preserve">basex -b "request=doctypes?dcat=^/projects/dcats/dcat-niem-2.1.xml" /projects/xclear/xclear.xq</div>
            <div class="para e578"> By now we have some feeling how to 
               <div class="emphasis e579" role="ital">use</div> a topic
               tool, namely how to specify aggregate input in alternative ways. We are ready to
               fill our tool with new functionality. 
            </div>
         </div><a name="AddingprototypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e580">
            <div class="title e581">Adding prototypes</div>
            <div class="para e582">Our tool shall be helpful when we want to explore an XML document, or a set of
               documents. The first version shall have three operations: 
               <div class="code e583">names</div>,
               
               <div class="code e584">paths</div> and 
               <div class="code e585">values</div>. We decide to place their
               implementation in a single module, called 
               <div class="code e586">items</div>. A convenient way to
               create the module is to use the 
               <div class="code e587">add</div> operation of
               
               <div class="code e588">ttools</div>. We specify the topic tool (parameter 
               <div class="code e589">dir</div>), 
               the module name (parameter 
               <div class="code e590">mod</div>) and the
               operations (parameter 
               <div class="code e591">ops</div>): 
            </div>
            <div class="programlisting e592" xml:space="preserve">
               basex -b "request=add?dir=/projects/xclear, mod=items, ops=names paths values" /projects/ttools/ttools.xq
               
               ==&gt;
               ===============================================================
               XQuery module created: items.mod.xq
               Operations:            names paths values
               
               Directory:             /projects/xclear
               Topic tool:            xclear
               
               The new operations are available. Example:
               
               basex -b "request=names?doc=doc1.xml doc2.xml doc3.xml" /projects/xclear/xclear.xq
               
               To implement them, edit these functions: names paths values    
               ===============================================================
            </div>
            <div class="para e593"> We check that new operations have appeared in the
               tool interface: 
            </div>
            <div class="programlisting e594" xml:space="preserve">basex -b "request=?" /projects/xclear/xclear.xq
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ====================================================
               _help        default, mode, ops?, type
               dcat         dfd+
               docs         dcat*, doc*, docs*
               doctypes     attNames, dcat*, doc*, docs*, elemNames
               names        dcat*, doc*, docs*
               paths        dcat*, doc*, docs*
               values       dcat*, doc*, docs*
               ====================================================
            </div>
            <div class="para e595">Indeed, the tool now has three new operations - 
               <div class="code e596">names</div>,
               
               <div class="code e597">paths</div> and 
               <div class="code e598">values</div>. Their parameter sets are just a
               first proposal which we will extend or change. Now we inspect the generated module
               
               <div class="code e599">items.mod.xq</div>. A complete listing can be found in the appendix 
               <div class="xref e600" linkend="items-module-initial"></div>. Here we look at selected parts. The text
               begins with this:
            </div>
            <div class="programlisting e601" xml:space="preserve">
               (:
               : -------------------------------------------------------------------------
               :
               : items.mod.xq - Document me!
               :
               : -------------------------------------------------------------------------
               :)
               
               (:~@interface
               &lt;interface&gt;
               &lt;operations&gt;
               &lt;operation name="names" type="node()" func="names"&gt;     
               &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
               &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
               &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
               &lt;pgroup name="input" minOccurs="1"/&gt;         
               &lt;/operation&gt; 
               &lt;operation name="paths" type="node()" func="paths"&gt;     
               &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
               &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
               &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
               &lt;pgroup name="input" minOccurs="1"/&gt;         
               &lt;/operation&gt; 
               &lt;operation name="values" type="node()" func="values"&gt;     
               &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
               &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
               &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
               &lt;pgroup name="input" minOccurs="1"/&gt;         
               &lt;/operation&gt;
               &lt;/operations&gt;
               &lt;/interface&gt;    
               :)  
               
               module namespace f="http://www.ttools.org/xclear/xquery-functions";
               ...
            </div>
            <div class="para e602">The 
               <div class="code e603">build</div> operation of 
               <div class="code e604">ttools</div> searches all library
               modules in the tool directory for text enclosed between 
               <div class="code e605">(:~@interface</div>
               and the closing 
               <div class="code e606">:)</div>. This text is interpreted as XML annotation
               declaring operations which the containing library module contributes to the topic
               tool. Each operation is defined in terms of a name, a function implementing it
               (@func, defaulting to the operation name), a return type (@type, defaulting to
               
               <div class="code e607">node()</div>), parameters (&lt;param&gt;) and optional parameter groups
               (&lt;pgroup&gt;). Parameter groups can be used for expressing cardinality constraints
               referring to a group of parameters, rather than to a single parameter - for example
               "at least one (at most one / exactly one) of these parameters ( ... ) must be
               specified". 
            </div>
            <div class="para e608">Each parameter is defined in terms of a name (@name), a type (@type), (optionally)
               facets (@fct_xyz) and (optionally) membership in a parameter group (@pgroup). Facets
               constrain valid parameter values beyond the constraints implied by the type. The
               type consists of an item type, optionally followed by a cardinality constraint. The
               parameters as they were generated are of course only meant as a starting point, to
               be extended and/or changed. We note that the generated module conforms to the
               recommended practise to support three alternative ways of specifying input documents.
               
               It uses three parameters of types 
               <div class="code e609">docURI</div>, 
               <div class="code e610">docDFD</div> and
               
               <div class="code e611">docCAT</div> and joins them into a parameter group, constraining the user
               to provide at least one of these parameters. 
            </div>
            <div class="para e612">Now we inspect the generated functions implementing the operations. For
               example:
            </div>
            <div class="programlisting e613" xml:space="preserve">
               (:~
               : Document me!
               :
               : @param request the operation request
               : @return a report describing ...
               :) 
               declare function f:names($request as element())
               as element() {
               let $docs := tt:getParams($request, 'doc docs dcat')    
               return
               &lt;z:names countDocs="{count($docs)}"&gt;{
               ()
               }&lt;/z:names&gt;
               };
            </div>
            <div class="para e614">So the initial version just creates an element echoing the operation name and
               fills it with a @countDocs attribute displaying the number of input documents. Let’s
               try, using a directory 
               <div class="code e615">/projects/xsd/niem-2.1</div> as input:
            </div>
            <div class="programlisting e616" xml:space="preserve">
               basex -b "request=names?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"/&gt;
            </div>
         </div><a name="FirstoperationfirstimplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e617">
            <div class="title e618">First operation, first implementation</div>
            <div class="para e619">Now we know that we are “connected” – the tool can be supplied with input documents
               - and we
               are ready to add code. Here comes a first version of the 
               <div class="code e620">names</div>
               operation: 
            </div>
            <div class="programlisting e621" xml:space="preserve">
               declare function f:names($request as element())
               as element() {
               let $docs := tt:getParams($request, 'doc docs dcat') 
               let $atts := 
               for $n in distinct-values($docs//@*/local-name(.))
               order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
               let $elems := 
               for $n in distinct-values($docs//*/local-name(.))
               order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
               return
               &lt;z:names countDocs="{count($docs)}"&gt;{
               &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
               &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
               }&lt;/z:names&gt;
               };
            </div>
            <div class="para e622">We repeat our call of the 
               <div class="code e623">names</div>
               operation:
            </div>
            <div class="programlisting e624" xml:space="preserve">basex -b "request=names?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
               &lt;z:atts count="29"&gt;
               &lt;z:a n="abstract"/&gt;
               &lt;z:a n="attributeFormDefault"/&gt;
               &lt;z:a n="base"/&gt;
               ...
               &lt;/z:atts&gt;
               &lt;z:elems count="40"&gt;
               &lt;z:e n="annotation"/&gt;
               &lt;z:e n="any"/&gt;
               &lt;z:e n="anyAttribute"/&gt;
               ...
               &lt;/z:elems&gt;
               &lt;/z:names&gt;
            </div>
         </div><a name="FirstrefinementaddingaparameterANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e625">
            <div class="title e626">First refinement - adding a parameter</div>
            <div class="para e627">Now let us think about refinement. We want to give the user the possibility to
               determine the scope – only elements, only attributes, or both. To achieve this, we
               add to the annotation of operation 
               <div class="code e628">names</div> a new parameter: 
            </div>
            <div class="programlisting e629" xml:space="preserve">
               &lt;param name="scope" type="xs:string" fct_values="att, elem, all" default="all"/&gt;
            </div>
            <div class="para e630"> Note the default value and the 
               <div class="code e631">values</div> facet, constraining valid
               parameter values to the strings “att”, “elem” and “all”. The function is easy to
               adapt: (a) add a line for reading the parameter value and (b) wrap the output of
               attribute and element names in 
               <div class="code e632">if</div> expressions dependent on the
               parameter value. Here comes the new version:
            </div>
            <div class="programlisting e633" xml:space="preserve">
               declare function f:names($request as element())
               as element() {
               let $docs := tt:getParams($request, 'doc docs dcat')
               let $scope as xs:string := tt:getParams($request, 'scope')      (: READ PARAM :)
               let $atts :=    
               for $n in distinct-values($docs//@*/local-name(.))
               order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
               let $elems := 
               for $n in distinct-values($docs//*/local-name(.))
               order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
               return
               &lt;z:names countDocs="{count($docs)}"&gt;{
               if ($scope eq 'elem') then () else                      (: DEPENDENT ON PARAM :)
               &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
               if ($scope eq 'att') then () else                       (: DEPENDENT ON PARAM :)
               &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
               }&lt;/z:names&gt;
               };
            </div>
            <div class="para e634">Note the type of the parameter value in this line:</div>
            <div class="programlisting e635" xml:space="preserve">let $scope as xs:string := tt:getParams($request, 'scope')</div>
            <div class="para e636">We can confidently use the type without “?”, as the annotation implies a
               cardinality of exactly one item, and the framework will never call the function
               unless the user input is valid. We re-build and call 
               <div class="code e637">_help</div> in order to
               verify that our annotations have been compiled into code:
            </div>
            <div class="programlisting e638" xml:space="preserve">
               basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
               basex -b "request=?type, default, ops=names" /projects/xclear/xclear.xq
               
               ==&gt;
               TOOL: xclear
               
               OPERATIONS   PARAMS
               ============================================================================
               names        dcat................ : docCAT* (sep=WS)
               doc................. : docURI* (sep=WS)
               docs................ : docDFD* (sep=;)
               scope=all........... : xs:string; facets: values=att, elem, all
               At least 1 of these parameters must be set: dcat, doc, docs
               ============================================================================
            </div>
            <div class="para e639">We check that validation proceeds as it should, supplying an invalid
               
               <div class="code e640">scope</div> value:
            </div>
            <div class="programlisting e641" xml:space="preserve">
               basex -b "request=names?docs=^/projects/xsd/niem-2.1/*,scope=attributes" /projects/xclear/xclear.xq
               
               ==&gt;
               Invalid call
               ============
               
               INVALID_PARAMETER_FACET       Parameter 'scope': item value (attributes) not among
               the valid item 
               values (att, elem, all).
               
               -------------------------------------
            </div>
            <div class="para e642">Calling the tool correctly, we get the correct result:</div>
            <div class="programlisting e643" xml:space="preserve">
               basex -b "request=names?docs=^/projects/xsd/niem-2.1,scope=att" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
               &lt;z:atts count="29"&gt;
               &lt;z:a n="abstract"/&gt;
               &lt;z:a n="attributeFormDefault"/&gt;
               &lt;z:a n="base"/&gt;
               ...
               &lt;z:a n="use"/&gt;
               &lt;z:a n="value"/&gt;
               &lt;z:a n="version"/&gt;
               &lt;/z:atts&gt;
               &lt;/z:names&gt;
            </div>
         </div><a name="AddinganamefilterANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e644">
            <div class="title e645">Adding a name filter</div>
            <div class="para e646">We add one more refinement: the user may optionally specify a name filter, so that
               only items with a matching name are returned. It does not take more than a minute
               to
               achieve this. First we add an optional parameter 
               <div class="code e647">names</div> to the
               annotation, using the object parameter type 
               <div class="code e648">nameFilter</div>:
            </div>
            <div class="programlisting e649" xml:space="preserve">   &lt;param name="names" type="nameFilter?"/&gt;</div>
            <div class="para e650">The adaptation of the function is minimalistic. We read the parameter
               value:
            </div>
            <div class="programlisting e651" xml:space="preserve">   let $filter as element(nameFilter)? := tt:getParams($request, 'names')</div>
            <div class="para e652">and add a couple of predicates to the path expressions returning attributes and
               elements, respectively:
            </div>
            <div class="programlisting e653" xml:space="preserve">
               let $atts :=    
               for $n in distinct-values($docs//@*
               [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))    (:
               FILTER ! :)
               order by lower-case($n) return &lt;z:a n="{$n}"/&gt;    
               let $elems := 
               for $n in distinct-values($docs//*
               [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))    (:
               FILTER ! :)
               order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
            </div>
            <div class="para e654">Done! After a re-build, we can retrieve name-filtered item names:</div>
            <div class="programlisting e655" xml:space="preserve">
               basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
               basex -b "request=names?docs=^/projects/xsd/niem-2.1/*,scope=att, names=*min*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:names xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
               &lt;z:atts count="1"&gt;
               &lt;z:a n="minOccurs"/&gt;
               &lt;/z:atts&gt;
               &lt;/z:names&gt;
            </div>
         </div><a name="SecondoperationfirstimplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e656">
            <div class="title e657">Second operation, first implementation</div>
            <div class="para e658">Now we tackle the second operation, returning data paths. First we write a little
               function which returns for any XML attribute or element its data path:
            </div>
            <div class="programlisting e659" xml:space="preserve">
               declare function f:path($n as node())
               as xs:string {
               string-join(
               $n/ancestor-or-self::node()/concat(self::attribute()/'@', local-name(.)),    
               '/')        
               };
            </div>
            <div class="para e660">With this function in place, the operation is implemented very quickly:</div>
            <div class="programlisting e661" xml:space="preserve">
               declare function f:paths($request as element())
               as element() {
               let $docs := tt:getParams($request, 'doc docs dcat')   
               let $paths := 
               for $p in distinct-values($docs//(*, @*)/f:path(.))
               order by lower-case($p)
               return &lt;z:path p="{$p}"/&gt;
               return
               &lt;z:paths countDocs="{count($docs)}" countPaths="{count($paths)}"&gt;{
               $paths
               }&lt;/z:paths&gt;
               };
            </div>
            <div class="para e662">After a re-build, we can retrieve a path list:</div>
            <div class="programlisting e663" xml:space="preserve">
               basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
               basex -b "request=paths?docs=^/projects/xsd/niem-2.1/*" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:paths xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123" countPaths="653"&gt;
               &lt;z:path p="/schema"/&gt;
               &lt;z:path p="/schema/@attributeFormDefault"/&gt;
               &lt;z:path p="/schema/@elementFormDefault"/&gt;
               ...
               &lt;/z:paths&gt;
            </div>
         </div><a name="AddingapathfilterANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e664">
            <div class="title e665">Adding a path filter</div>
            <div class="para e666">Now we refine the operation by adding a path filter parameter. This enables the
               user to search for paths with a particular pattern, e.g. ending with a particular
               element or attribute, or all children or descendants of elements with a particular
               name. This is easily done. We extend the operation annotation by an optional filter
               parameter, using the object parameter type 
               <div class="code e667">pathFilter</div>:
            </div>
            <div class="programlisting e668" xml:space="preserve">
               &lt;param name="paths" type="pathFilter?"/&gt;
            </div>
            <div class="para e669">And we change the function code as follows. We read the parameter value:</div>
            <div class="programlisting e670" xml:space="preserve">
               let $filter as element(pathFilter)? := tt:getParams($request, 'paths')
            </div>
            <div class="para e671">and we introduce a predicate which filters the paths, rejecting any candidates not
               matching the path filter, if a path filter has been supplied:
            </div>
            <div class="programlisting e672" xml:space="preserve">
               distinct-values($docs//(*, @*)/f:path(.))[not($filter) or tt:matchesPathFilter(.,
               $filter)]
            </div>
            <div class="para e673"> After a re-build, we can, for example, learn all data paths pointing to elements
               and attributes under 
               <div class="code e674">xs:appInfo</div> elements:
            </div>
            <div class="programlisting e675" xml:space="preserve">
               basex -b "request=build?dir=/projects/xclear" /projects/ttools/ttools.xq
               basex -b "request=paths?docs=^/projects/xsd/niem-2.1/*, paths=appinfo//*" /projects/xclear/xclear.xq
               &gt; paths.xml
               
               ==&gt;
               &lt;z:paths xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123" countPaths="27"&gt;
               &lt;z:path p="/schema/annotation/appinfo/@source"/&gt;
               &lt;z:path p="/schema/annotation/appinfo/ConformantIndicator"/&gt;
               &lt;z:path p="/schema/annotation/appinfo/resource"/&gt;
               ... 
               &lt;/z:paths&gt;
            </div>
         </div><a name="ThirdoperationfirstimplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e676">
            <div class="title e677">Third operation, first implementation</div>
            <div class="para e678">This operation reports data values found in attributes and elements. For each
               attribute and element name, a sample of values is displayed. In the first version,
               the sample size is set to the value 10. The complete code looks like this:
            </div>
            <div class="programlisting e679" xml:space="preserve">
               declare function f:values($request as element())
               as element() {
               let $docs := tt:getParams($request, 'doc docs dcat')   
               
               let $limit := 10
               let $atts := $docs//@*
               let $elems := $docs//*[not(*)][text()]
               let $attNames := distinct-values($atts/local-name(.))    
               let $elemNames := distinct-values($elems/local-name(.))
               let $attValues :=
               for $name in $attNames
               let $values := distinct-values($atts[local-name(.) eq $name])
               let $show := for $v in $values[position() le $limit] 
               order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
               order by lower-case($name) return
               &lt;z:a n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:a&gt;
               
               let $elemValues :=
               for $name in $elemNames
               let $values := distinct-values($elems[local-name(.) eq $name])
               let $show := for $v in $values[position() le $limit] 
               order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
               order by lower-case($name) return
               &lt;z:e n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:e&gt;
               
               return
               &lt;z:values countDocs="{count($docs)}"&gt;{
               &lt;z:atts countAtts="{count($atts)}"&gt;{$attValues}&lt;/z:atts&gt;,
               &lt;z:elems countAtts="{count($elems)}"&gt;{$elemValues}&lt;/z:elems&gt;            
               }&lt;/z:values&gt;
               };
            </div>
            <div class="para e680">After a re-build we can request reports which yield for each attribute and element
               name a sample of values found in items with that name:
            </div>
            <div class="programlisting e681" xml:space="preserve">
               basex -b "request=build?name=xclear, dir=/projects/xclear" /projects/ttools/ttools.xq
               basex -b "request=values?docs=^/projects/xsd/niem-2.1" /projects/xclear/xclear.xq
               
               ==&gt;
               &lt;z:values xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
               &lt;z:atts countAtts="102132"&gt;
               &lt;z:a n="abstract" count="1/1"&gt;
               &lt;z:v v="true"/&gt;
               &lt;/z:a&gt;
               &lt;z:a n="attributeFormDefault" count="2/2"&gt;
               &lt;z:v v="qualified"/&gt;
               &lt;z:v v="unqualified"/&gt;      
               &lt;/z:a&gt;
               &lt;z:a n="base" count="10/816"&gt;
               &lt;z:v v="ansi-nist:ALSCodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:BTYCodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:COLCodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:CSICodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:CSNCodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:CSPCodeSimpleType"/&gt;
               &lt;z:v v="ansi-nist:NISTImageType"/&gt;
               &lt;z:v v="s:AugmentationType"/&gt;
               &lt;z:v v="s:ComplexObjectType"/&gt;
               &lt;z:v v="xsd:token"/&gt;
               &lt;/z:a&gt;    
               ...
               &lt;/z:values&gt;
            </div>
         </div><a name="AddinganamefiltermapANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e682">
            <div class="title e683">Adding a name filter map</div>
            <div class="para e684">Now we want to make the size of value samples dependent on the item name, so that
               the user may instruct the tool, for example, to return no values at all for some
               names, and different numbers for different name patterns. To achieve this, we extend
               the operation annotation, adding a parameter of type
               
               <div class="code e685">nameFilterMap(xs:integer)</div>:
            </div>
            <div class="programlisting e686" xml:space="preserve">
               &lt;param name="nvalues" type="nameFilterMap(xs:integer)?"/&gt;
            </div>
            <div class="para e687">Then we modify the function code as follows. We read the parameter value:</div>
            <div class="programlisting e688" xml:space="preserve">
               let $fmap as element(nameFilterMap)? := tt:getParams($request, 'nvalues')
            </div>
            <div class="para e689">and set the number of terms dependently on the item name:</div>
            <div class="programlisting e690" xml:space="preserve">
               let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)
            </div>
            <div class="para e691">That was it. The following call, for example:</div>
            <div class="programlisting e692" xml:space="preserve">
               basex -b "request=values?docs=^/projects/xsd/niem-2.1/*, nvalues=0 % 5:docum* block
               % 10:target* % 20:use" 
               /projects/xclear/xclear.xq
            </div>
            <div class="para e693">sets the value sample sizes to the following values:</div>
            <div class="itemizedlist e694">
               <div class="listitem e695">
                  <div class="para e696">0 : by default</div>
               </div>
               <div class="listitem e697">
                  <div class="para e698">5 : if the name starts with “docum” or equals ”block”</div>
               </div>
               <div class="listitem e699">
                  <div class="para e700">10: if the name starts with “target”</div>
               </div>
               <div class="listitem e701">
                  <div class="para e702">20: if the name equals “use”</div>
               </div>
            </div>
            <div class="para e703">The result looks accordingly:</div>
            <div class="programlisting e704" xml:space="preserve">
               &lt;z:values xmlns:z="http://www.ttools.org/xclear/structure" countDocs="123"&gt;
               &lt;z:atts countAtts="102132"&gt;
               &lt;z:a n="abstract" count="0/1"/&gt;
               &lt;z:a n="attributeFormDefault" count="0/2"/&gt;
               &lt;z:a n="base" count="0/816"/&gt;
               &lt;z:a n="block" count="2/2"&gt;
               &lt;z:v v="extension"/&gt;
               &lt;z:v v="restriction"/&gt;
               &lt;/z:a&gt;
               &lt;z:a n="default" count="0/12"/&gt;
               ...
               &lt;/z:values&gt;
            </div>
            <div class="para e705">See appendix for the full source code of this operation, as well as module
               
               <div class="code e706">items.mod.xq</div> as a whole, both its initial state as generated by
               
               <div class="code e707">ttools</div> (
               <div class="xref e708" linkend="items-module-initial"></div>), and the final
               state after our coding work (
               <div class="xref e709" linkend="items-module-edited"></div>).
            </div>
         </div>
      </div><a name="DiscussionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e710">
         <div class="title e711">Discussion</div>
         <div class="para e712">The present work is closely related to RESTXQ ([
            <div class="xref e713" linkend="retter"></div>]), and it is
            revealing to study similarities and differences. Both approaches reduce the writing
            of
            XQuery applications to the writing of XQuery functions, and in both cases infrastructure
            takes the responsibility to call the appropriate function. In both cases, infrastructure
            not only calls the function, but supplies it with information input which represents
            the
            information supplied by the triggering event. The approaches are, of course, concerned
            with different types of events – an HTTP request in the case of RESTXQ, a command
            line
            call in the case of topic tools. But both models are essentially models how to map
            an
            external event and its information content to (a) the selection of a function to be
            called, (b) input information accessible to the function called. 
         </div>
         <div class="para e714">Many differences between RESTXQ and topic tools are consequences of the different
            types of events with which they are concerned. For example, RESTXQ deals with HTTP
            header fields, path segments and URI parameters, as these are natural parts of an
            HTTP
            request. Topic tools, on the other hand, essentially deals with a 
            <div class="emphasis e715" role="ital">single string</div> - user input without any pre-given structure, so that
            topic tools has the freedom – and responsibility – to define a structural model into
            which the string is translated and which transforms the string into structured
            information. 
         </div>
         <div class="para e716">But there is one meaningful difference between RESTXQ and topic tools, and this is
            the
            
            <div class="emphasis e717" role="ital">model of function input information</div>. RESTXQ makes
            an apparently obvious choice: function input is defined by the 
            <div class="emphasis e718" role="ital">function signature</div>. Each logical input parameter is a function argument,
            and the model of function input is a sequence of parameters defined in terms of a
            name
            and an XQuery sequence type. 
         </div>
         <div class="para e719">Topic tools chooses a different input model: function input is an instance of the
            
            <div class="emphasis e720" role="ital">operation interface</div> as defined by the tool scheme,
            instantiated as a message element. The logical input parameters are hidden
            behind message accessor functions, and the model of input is a set of parameters
            defined in terms of the tool scheme meta model. 
         </div>
         <div class="para e721">This difference –</div>
         <div class="itemizedlist e722">
            <div class="listitem e723">
               <div class="para e724">“input model = function signature / input parameter = function argument” vs.</div>
            </div>
            <div class="listitem e725">
               <div class="para e726">“input model = operation interface / input parameter - supplied by message accessor”
                  
               </div>
            </div>
         </div>
         <div class="para e727">has three significant consequences. The latter approach offers a 
            <div class="emphasis e728" role="ital">richer parameter model</div>, it implies a 
            <div class="emphasis e729" role="ital">stable
               function signature
            </div> and it enables a 
            <div class="emphasis e730" role="ital">functional
               abstraction
            </div> of parameter values. We inspect these aspects in turn.
         </div>
         <div class="para e731">The operation interface consists of parameters defined in terms of a name, a sequence
            type and further properties implied by the tool scheme meta model. These further
            parameters are above all facets. Facets extend the built-in item types in the same
            way
            as user-defined XSD types extend the built-in simple types. It is a key feature
            of topic tools to enable fine-grained validation controlled by facets independently
            of
            imported schemas. More generally speaking, uncoupling the model of an operation
            parameter from the concept of a function parameter thus enables a 
            <div class="emphasis e732" role="ital">richer parameter model</div>, partially implemented by code (facet
            validation), rather than being restricted to native language support.
         </div>
         <div class="para e733"> The operation providing functions of topic tools have a uniform signature, accepting
            a single input parameter which is a message element. More important than the uniformity
            across different functions is the uniformity of a given function over time: topic
            tools
            imply a 
            <div class="emphasis e734" role="ital">stable function signature</div>. This facilitates
            agile development and the stepwise addition of features. Refinement of functionality
            typically entails the addition of further control parameters. If each input parameter
            is
            represented by a function argument, agile development means that the function signatures
            change often. Apart from that, operations offering rich functionality tend to have
            an
            ever growing list of parameters. If this implies an ever growing function signature,
            things become unwieldy. Who wants to handle functions with 10 or even 20 parameters?
            
         </div>
         <div class="para e735">Obtaining input parameters by calling a message function means a 
            <div class="emphasis e736" role="ital">functional abstraction</div>. This can be used in various ways. For example,
            it becomes possible to define a parameter as a huge document set without loading the
            complete set into memory: this can be avoided by using an accessor function which
            supports the retrieval of a subset. More generally speaking, the message interface
            enables lazy evaluation and modification of access details at access time.
         </div>
         <div class="para e737">On first sight, the use of object parameter types also seems to be a case of
            functional abstraction. But in fact it is not, as RESTXQ might, in principle, define
            the
            same mappings from strings to objects (elements) and support the use of such objects
            in
            the function signatures. The concept of object parameter types, however, creates a
            different aspect to be considered when evaluating RESTXQ and topic tools. The definition
            of object parameter types introduces a mapping of lexical entities to the logical
            parameters of operation input. So in fact we are dealing with 
            <div class="emphasis e738" role="ital">two</div> mappings: (a) from lexical input to logical input (aka operation
            parameters), and (b) from logical input to its representation in XQuery. Speaking
            about
            function arguments versus message object we dwelt on the differences concerning mapping
            (b). Remembering object parameter types, we take notice that topic tools puts also
            emphasis on mappings (a). It expresses them by the definition of object parameter
            types. 
         </div>
         <div class="para e739"> The tool scheme, however, is not concerned with these mappings. The mappings deal
            with lexical input, but the tool scheme is composed of logical parameters. For example,
            the tool scheme states that a certain parameter is a name filter; the tool scheme
            does
            not prescribe that it is constructed from a string with a certain syntax, this is
            only
            implied by the used typed, 
            <div class="code e740">nameFilter</div>. We arrive at a clear distinction
            between the tool scheme and the mappings used to supply it with actual values. The
            distinction opens an interesting vista: although this paper defined and viewed topic
            tools as a particular kind of command line tools, the core of the concept is not bound
            to the notion of a command line - it is bound to the logical model of an operation.
            There is an input source (for example – a command line) which is mapped to an instance
            of an operation interface. The type of input source may be exchanged for a different
            type, if we have access to an alternative mapping, translating this other type into
            the
            tool scheme. As the original mapping – as well as the hypothetical alternative mapping
            –
            is accomplished by infrastructure, the replacement would in no way affect the
            application code hand-written by the developer. For instance, the topic tools model
            might be employed as an alternative model for the development of RESTful web services.
            In order to accomplish this, it would suffice to add a sub model which maps HTTP
            requests to instances of an operation interface. This would be very easy, as the RESTXQ
            defined mappings could be reused, redirected from one target, function arguments,
            to
            another, logical operation parameters.
         </div>
      </div><a name="ThemoduleasgeneratedbyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e741" xml:id="items-module-initial">
         <div class="title e742">The 
            <div class="code e743">items</div> module as generated by 
            <div class="code e744">ttools</div>
         </div>
         <div class="para e745">The following listing shows the 
            <div class="code e746">items</div> module generated by
            
            <div class="code e747">ttools</div> in response to the following call:
         </div>
         <div class="programlisting e748" xml:space="preserve">
            basex -b "request=add?dir=/projects/xclear, mod=items, ops=names paths values" /projects/ttools/ttools.xq
         </div>
         <div class="programlisting e749" xml:space="preserve">
            (:
            : -------------------------------------------------------------------------
            :
            : items.mod.xq - Document me!
            :
            : -------------------------------------------------------------------------
            :)
            
            (:~@interface
            &lt;interface&gt;
            &lt;operations&gt;
            &lt;operation name="names" type="node()" func="names"&gt;     
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt; 
            &lt;operation name="paths" type="node()" func="paths"&gt;     
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt; 
            &lt;operation name="values" type="node()" func="values"&gt;     
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt;
            &lt;/operations&gt;
            &lt;/interface&gt;    
            :)  
            
            module namespace f="http://www.ttools.org/xclear/xquery-functions";
            import module namespace tt="http://www.ttools.org/xquery-functions" at 
            "_request.mod.xq",
            "_reportAssistent.mod.xq",
            "_nameFilter.mod.xq";
            
            declare namespace z="http://www.ttools.org/xclear/structure";
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:names($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')    
            return
            &lt;z:names countDocs="{count($docs)}"&gt;{
            ()
            }&lt;/z:names&gt;
            };        
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:paths($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')    
            return
            &lt;z:paths countDocs="{count($docs)}"&gt;{
            ()
            }&lt;/z:paths&gt;
            };        
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:values($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')    
            return
            &lt;z:values countDocs="{count($docs)}"&gt;{
            ()
            }&lt;/z:values&gt;
            };
         </div>
      </div><a name="ThemoduleaftereditingitinthetutorialANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e750" xml:id="items-module-edited">
         <div class="title e751">The 
            <div class="code e752">items</div> module after editing it in the tutorial
         </div>
         <div class="para e753">The following listing shows the 
            <div class="code e754">items</div> module as it looks after editing
            the generated prototype as guided by the tutorial. The listing is an example of a
            first
            version of a topic tool, as it can be developed within a couple of hours and yet be
            useful enough to be handed over to users.
         </div>
         <div class="programlisting e755" xml:space="preserve">
            (:
            : -------------------------------------------------------------------------
            :
            : items.mod.xq - a module for inspecting item names, paths and data values
            :
            : -------------------------------------------------------------------------
            :)
            
            (:~@interface
            &lt;interface&gt;
            &lt;operations&gt;   
            &lt;operation name="names" func="names" type="node()"&gt;  
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
            &lt;param name="scope" type="xs:string" fct_values="att, elem, all" default="all"/&gt; 
            
            &lt;param name="names" type="nameFilter?"/&gt;    
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt; 
            &lt;operation name="paths" func="paths" type="node()"&gt;     
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
            &lt;param name="paths" type="pathFilter?"/&gt;        
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt; 
            &lt;operation name="values" func="values" type="node()"&gt;     
            &lt;param name="doc" type="docURI*" sep="WS" pgroup="input"/&gt;
            &lt;param name="docs" type="docDFD*" sep=";" pgroup="input"/&gt;           
            &lt;param name="dcat" type="docCAT*" sep="WS" pgroup="input"/&gt;         
            &lt;param name="nvalues" type="nameFilterMap(xs:integer)?"/&gt;
            &lt;pgroup name="input" minOccurs="1"/&gt;         
            &lt;/operation&gt;
            &lt;/operations&gt;
            &lt;/interface&gt;    
            :)  
            
            module namespace f="http://www.ttools.org/xclear/xquery-functions";
            import module namespace tt="http://www.ttools.org/xquery-functions" at 
            "_request.mod.xq",
            "_reportAssistent.mod.xq",
            "_nameFilter.mod.xq";
            
            declare namespace z="http://www.ttools.org/xclear/structure";
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:names($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')
            let $scope as xs:string := tt:getParams($request, 'scope')
            let $filter as element(nameFilter)? := tt:getParams($request, 'names')    
            
            let $atts :=    
            for $n in distinct-values($docs//@*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))
            order by lower-case($n) return &lt;z:a n="{$n}"/&gt;
            let $elems := 
            for $n in distinct-values($docs//*
            [not($filter) or tt:matchesNameFilter(local-name(.), $filter)]/local-name(.))
            order by lower-case($n) return &lt;z:e n="{$n}"/&gt;
            let $infoAtts := $filter/@source/attribute nameFilter {.}
            return
            &lt;z:names countDocs="{count($docs)}"&gt;{
            $infoAtts,
            if ($scope eq 'elem') then () else
            &lt;z:atts count="{count($atts)}"&gt;{$atts}&lt;/z:atts&gt;,
            if ($scope eq 'att') then () else                
            &lt;z:elems count="{count($elems)}"&gt;{$elems}&lt;/z:elems&gt;           
            }&lt;/z:names&gt;
            };        
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:paths($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')
            let $filter as element(pathFilter)? := trace( tt:getParams($request, 'paths') , 'FILTER:
            ')
            let $paths := 
            for $p in distinct-values($docs//(*, @*)/f:path(.))[not($filter) or tt:matchesPathFilter(.,
            $filter)]
            order by lower-case($p)
            return &lt;z:path p="{$p}"/&gt;
            let $infoAtts := $filter/@source/attribute pathFilter {.}        
            return
            &lt;z:paths countDocs="{count($docs)}" countPaths="{count($paths)}"&gt;{
            $infoAtts,
            $paths
            }&lt;/z:paths&gt;
            };        
            
            (:~
            : Document me!
            :
            : @param request the operation request
            : @return a report describing ...
            :) 
            declare function f:values($request as element())
            as element() {
            let $docs := tt:getParams($request, 'doc docs dcat')   
            let $fmap as element(nameFilterMap)? := tt:getParams($request, 'nvalues')
            
            let $defaultLimit := 10
            let $atts := $docs//@*
            let $elems := $docs//*[not(*)][text()]
            let $attNames := distinct-values($atts/local-name(.))    
            let $elemNames := distinct-values($elems/local-name(.))
            let $attValues :=
            for $name in $attNames
            let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)
            let $values := distinct-values($atts[local-name(.) eq $name])
            let $show := for $v in $values[position() le $limit] 
            order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
            order by lower-case($name) return
            &lt;z:a n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:a&gt;
            
            let $elemValues :=
            for $name in $elemNames
            let $limit := tt:nameFilterMapValue($name, $fmap, $defaultLimit)        
            let $values := distinct-values($elems[local-name(.) eq $name])
            let $show := for $v in $values[position() le $limit] 
            order by lower-case($v) return &lt;z:v v="{$v}"/&gt;
            order by lower-case($name) return
            &lt;z:e n="{$name}" count="{concat(count($show), '/', count($values))}"&gt;{$show}&lt;/z:e&gt;
            
            return
            &lt;z:values countDocs="{count($docs)}"&gt;{
            &lt;z:atts countAtts="{count($atts)}"&gt;{$attValues}&lt;/z:atts&gt;,
            &lt;z:elems countAtts="{count($elems)}"&gt;{$elemValues}&lt;/z:elems&gt;            
            }&lt;/z:values&gt;
            };   
            
            declare function f:path($n as node())
            as xs:string {
            string-join($n/ancestor-or-self::node()/concat(self::attribute()/'@', local-name(.)),
            '/')        
            };
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e756">
         <div class="title e757">Bibliography</div>
         <div class="bibliomixed e758" xml:id="basex" xreflabel="1">BaseX GmbH, Germany. Homepage. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e759" xlink:actuate="onRequest" xlink:href="http://www.otds.de" xlink:show="new" xlink:type="simple"></div>
         </div>
         <div class="bibliomixed e760" xml:id="otds" xreflabel="2">OTDS e.V., Schicklerstrasse 5-7, 10179 Berlin,
            Germany. Homepage. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e761" xlink:actuate="onRequest" xlink:href="http://www.otds.de" xlink:show="new" xlink:type="simple"></div>
         </div>
         <div class="bibliomixed e762" xml:id="retter" xreflabel="3">Retter, Adam. RESTful XQuery. XML Prague 2012,
            Conference Proceedings, p. 91-124. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e763" xlink:actuate="onRequest" xlink:href="http://archive.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf" xlink:show="new" xlink:type="simple"></div>.
         </div>
         <div class="bibliomixed e764" xml:id="w3c-xquery" xreflabel="4">Robie, Jonathan et al, eds. XQuery 3.0: An
            XML Query Language (Second Edition). W3C Recommendation 8 April 2014. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e765" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple"></div>
         </div>
      </div>
   </div>
</div>