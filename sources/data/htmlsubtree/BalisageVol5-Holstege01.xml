<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#SchemaComponentPathsforSchemaAnalysisANCHOR" name="SchemaComponentPathsforSchemaAnalysisTOC">Schema Component Paths for Schema Analysis</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#SchemaComponentPathsANCHOR" name="SchemaComponentPathsTOC">Schema Component Paths</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ComparisonwithExtendedXPathsANCHOR" name="ComparisonwithExtendedXPathsTOC">Comparison with Extended XPaths</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AnalyzingSchemasANCHOR" name="AnalyzingSchemasTOC">Analyzing Schemas</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaSignaturesANCHOR" name="SchemaSignaturesTOC">Schema Signatures</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaDifferencesANCHOR" name="SchemaDifferencesTOC">Schema Differences</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaMetricsANCHOR" name="SchemaMetricsTOC">Schema Metrics</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ToolsANCHOR" name="ToolsTOC">Tools</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Analysis of XML schema usage</div>
         <div class="singletermTERMS">A Measure of Complexity</div>
         <div class="singletermTERMS">Analysis and Metrics of XML Schema</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">can</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">Holstege</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">mary.holstege@marklogic.com</div>
         <div class="singletermTERMS">Mary</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">Principal Engineer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML Schema Part 1: Structures Second Edition</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="SchemaComponentPathsforSchemaAnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">Schema Component Paths for Schema Analysis</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2010</div>
            <div class="confdates e5">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Schema component paths define an XPath-like syntax for describing
               and navigating W3C XML Schema component models.  Canonical schema component
               paths provide a unique, string-comparable designator for each component in
               schema. MHSCD is a driver than can generate canonical schema component paths or
               non-canonical schema component paths to a certain depth, or locate a component
               or set of components in a schema given a schema component path.  
               
            </div>
            <div class="para e8">Component paths can be applied to various schema analysis
               tasks. The set of canonical schema component paths provides a simple signature
               for a schema that is robust to differences in the physical organization of the
               schema document.  Comparing two such signatures gives a quick "what's changed
               between these two schema versions?" summary.  This signature can also be used
               for the calculation of basic schema complexity metrics, including basic counts
               of components of various types.
               
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Mary</div>
               <div class="surname e12">Holstege</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Mary Holstege is Principal Engineer at Mark Logic
                  Corporation.  She has worked as a software engineer in and around markup
                  technologies for over 20 years.  She is a member of the W3C XML Schema and XML
                  Query working groups, and an editor of the W3C XML Schema Component Designators
                  and the XML Query Full Text specifications.  Mary Holstege holds a Ph.D. from
                  Stanford University in Computer Science, for a thesis on document
                  representation.
               </div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Principal Engineer</div>
               <div class="orgname e17">Mark Logic Corporation</div>
            </div>
            <div class="email e18">mary.holstege@marklogic.com</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright Â© 2010 Mary Holstege</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e21">
         <div class="title e22">Introduction</div>
         <div class="para e23">XML Schemas have become artifacts that play
            a role in many software projects. Software is generated or driven from them.
            While there is a long history of work on software metrics and analysis, work 
            is only beginning on understanding the XML Schemas as software
            artifacts in their own right.
            
         </div>
         <div class="para e24">This paper introduces schema component paths, a specification under
            development by the W3C, and shows how they can be used to tame some of 
            the complexity of the XML Schema model itself, and provide the 
            basis of some XML Schema metrics and analysis tools.
            
         </div>
      </div><a name="SchemaComponentPathsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e25">
         <div class="title e26">Schema Component Paths</div>
         <div class="para e27">Schema component paths, or SCPs, define an
            XPath-like syntax for describing and navigating W3C XML Schema 
            <div class="citation e28" linkend="xsd"></div> component models. Certain schema component paths define the
            minimal path to each specific component in the component model: these are the
            canonical schema component paths.
            
         </div>
         <div class="para e29">The XML Schema component model is complex, with many
            asymmetries and special cases. A particular assembled schema consists
            of a rooted graph of components and property records typically assembled from
            one or more schema documents.  Property records are used to encapsulate
            certain compound properties, but are not themselves considered schema
            components. 
            Schema components and property records have properties, some of which are
            simple values, and some of which are other schema components and properties.
            For the purposes of schema component paths, component-valued
            properties define labelled arcs between schema components. Each labelled arc
            defined a different axis of traversal from one component to another. Some axes
            select more than one component. To distinguish the components that an axis
            selects, SCPs use name tests and positional predicates: the name test matches
            components by their name and namespace URI and positional predicates count
            components in order.  
            
         </div>
         <div class="para e30">Syntactically, a SCP resembles an XPath expression: the path consists
            of a sequence of steps separated by a slash ('/'), where each step consists of
            an axis name, a double-colon ('::') separator, a name test, and possibly a
            predicate surrounded by square brackets ('[' and ']').  In the case of SCPs the
            only predicate available is the numerical positional predicate: an integer.
            Again, as with XPath expressions, various axis abbreviations are available.
            Complete details are available in the specification 
            <div class="citation e31" linkend="scds"></div>.
            
         </div>
         <div class="figure e32" xml:id="fig_scp1">
            <div class="programlisting e33" xml:space="preserve">
               /schemaElement::p:outer/type::0/schemaAttribute::p:inner
               /type::p:second/model::sequence/schemaElement::p:duplicate[2]/type::*
               /p:outer/~0/@p:inner
               /~p:second/model::sequence/p:duplicate[2]/~*
               
            </div>
            <div class="caption e34">
               <div class="para e35">Some SCPs</div>
            </div>
         </div>
         <div class="para e36">Figure 
            <div class="xref e37" linkend="fig_scp1"></div> shows some SCPs.  
            The first SCP selects an
            attribute declaration named 'inner' for an
            element declaration named 'outer' whose type is a locally defined anonymous
            type.  The path starts at the root of the assembled schema ('/') and then
            traverses the schemaElement axis ('schemaElement::') with a name test
            ('p:outer'). The name test matches an element declaration whose local name is
            'outer' and whose namespace URI matches the namespace bound to the prefix
            'p'. The path continues through the type axis ('type::') with a name test
            ('0') that in this case matches a type definition with no name ('0' being the
            indicator for this case). 
            Finally the schemaAttribute axis is traversed to select the
            attribute declaration whose name matches 'p:inner'. 
            
         </div>
         <div class="para e38">The second SCP selects the type of the second element
            declaration named 'duplicate' in the sequence within the type definition named
            'second'. The path starts at the root of the assembled schema ('/'), traverses
            through the type axis and then the model axis ('model::').
            Here the test ('sequence') matches 
            a model group's kind (sequence vs. choice vs. all) and selects only sequence
            model groups. Then the schemaElement axis is traversed. The
            predicate on this axis ('[2]') selects the second element declaration with the
            name 'duplicate' in the namespace bound to 'p': this can only be the case if
            there are two local element declarations.  Finally, the type axis is traversed
            and a wildcard name test ('*') is applied, which will match the type
            definition, regardless of type.
            
         </div>
         <div class="para e39">
            The third and fourth SCPs are abbreviated versions of the first and
            second, using the tilde '~' abbreviation for the type axis, the use of
            the bare name as an abbreviation for the schemaElement axis, and the use of the
            at sign ('@') as an abbreviation for the schemaAttribute axis.
            
         </div>
         <div class="para e40">Table 
            <div class="xref e41" linkend="table_axes"></div> summarizes the schema component axes.  Not all axes apply to canonical paths, and
            some axes apply only against the XML Schema 1.1 
            <div class="citation e42" linkend="xsd11"></div> component model.
            
         </div>
         <div class="table e43" xml:id="table_axes">
            <div class="caption e44">
               <div class="para e45">Schema Component Path Axes</div>
            </div>
            <div class="tr e46">
               <div class="th e47">Axis</div>
               <div class="th e48">Meaning</div>
            </div>
            <div class="tr e49">
               <div class="th e50" colspan="2">Axes appearing in canonical paths</div>
            </div>
            <div class="tr e51">
               <div class="td e52">schemaAttribute</div>
               <div class="td e53">Attribute declaration</div>
            </div>
            <div class="tr e54">
               <div class="td e55">schemaElement</div>
               <div class="td e56">Element declaration</div>
            </div>
            <div class="tr e57">
               <div class="td e58">type</div>
               <div class="td e59">Type definition</div>
            </div>
            <div class="tr e60">
               <div class="td e61">attributeGroup</div>
               <div class="td e62">Named attribute group definition</div>
            </div>
            <div class="tr e63">
               <div class="td e64">group</div>
               <div class="td e65">Named model group definition</div>
            </div>
            <div class="tr e66">
               <div class="td e67">identityConstraint</div>
               <div class="td e68">Identity constraint definition</div>
            </div>
            <div class="tr e69">
               <div class="td e70">key</div>
               <div class="td e71">Referenced key in identity constraint definition</div>
            </div>
            <div class="tr e72">
               <div class="td e73">notation</div>
               <div class="td e74">Notation declaration</div>
            </div>
            <div class="tr e75">
               <div class="td e76">model</div>
               <div class="td e77">Model group</div>
            </div>
            <div class="tr e78">
               <div class="td e79">anyAttribute</div>
               <div class="td e80">Attribute wildcard</div>
            </div>
            <div class="tr e81">
               <div class="td e82">any</div>
               <div class="td e83">Wildcard</div>
            </div>
            <div class="tr e84">
               <div class="td e85">facet</div>
               <div class="td e86">Constraining or fundamental facet</div>
            </div>
            <div class="tr e87">
               <div class="td e88">annotation</div>
               <div class="td e89">Annotation</div>
            </div>
            <div class="tr e90">
               <div class="td e91">assertion</div>
               <div class="td e92">Assertion (1.1 component model only)</div>
            </div>
            <div class="tr e93">
               <div class="td e94">alternative</div>
               <div class="td e95">Type alternative (1.1 component model only)</div>
            </div>
            <div class="tr e96">
               <div class="th e97" colspan="2">Axes appearing in non-canonical paths</div>
            </div>
            <div class="tr e98">
               <div class="td e99">component</div>
               <div class="td e100">Any component</div>
            </div>
            <div class="tr e101">
               <div class="td e102">currentComponent</div>
               <div class="td e103">The current component</div>
            </div>
            <div class="tr e104">
               <div class="td e105">substitutionGroup</div>
               <div class="td e106">The substitution group head of an element declaration</div>
            </div>
            <div class="tr e107">
               <div class="td e108">baseType</div>
               <div class="td e109">The base type of a type definition</div>
            </div>
            <div class="tr e110">
               <div class="td e111">primitiveType</div>
               <div class="td e112">The primitive type of a simple type definition</div>
            </div>
            <div class="tr e113">
               <div class="td e114">itemType</div>
               <div class="td e115">The item type of a list simple type definition</div>
            </div>
            <div class="tr e116">
               <div class="td e117">memberType</div>
               <div class="td e118">A member type of a union simple type definition</div>
            </div>
            <div class="tr e119">
               <div class="td e120">particle</div>
               <div class="td e121">A particle in a model group</div>
            </div>
            <div class="tr e122">
               <div class="td e123">attributeUse</div>
               <div class="td e124">An attribute use (local attribute declaration)</div>
            </div>
            <div class="tr e125">
               <div class="td e126">scope</div>
               <div class="td e127">The complex type definition, attribute group definition, or model group definition
                  defining the scope of a local element or attribute declaration
               </div>
            </div>
            <div class="tr e128">
               <div class="td e129">context</div>
               <div class="td e130">The complex type definition, attribute declaration, or element declaration defining
                  the context of a local type definition
               </div>
            </div>
         </div>
         <div class="para e131">There is one privileged path to each component in the schema, the
            canonical schema component path. Intuitively, the canonical SCP of a component
            is the SCP that minimally describes that component and only that component.
            For example, the SCP for a global type definition is the SCP that traverses
            solely the type axis from the root; the SCP for a local type definition 
            is the SCP for the element declaration that governs the type definition,
            extended by traversing the type axis. Canonical paths restrict traversals to
            certain axes, sometimes based on complex constraints involving other components
            (particularly the base type component), and eliminating abbreviations and
            wildcarding wherever possible.  Every canonical SCP is the extension of an
            existing SCP with an allowable step, plus the canonical SCP for component that
            represents the whole schema, whose canonical SCP is a slash ('/'). 
            
         </div>
         <div class="para e132">The set of canonical paths can be generated for an assembled schema
            by traversing the component graph from the root, gathering up canonical SCPs,
            and extending them through allowable transitions.  Figure 
            
            <div class="xref e133" linkend="fig_canonical"></div> shows a small schema and its canonical SCPs,
            excluding the canonical SCPs for the built-in schema components that are
            present in every assembled schema. 
            
         </div>
         <div class="figure e134" xml:id="fig_canonical">
            <div class="programlisting e135" xml:space="preserve">
               
               &lt;xs:schema targetNamespace="http://www.w3.org/xmlschema-ref/example1"
               xmlns="http://www.w3.org/xmlschema-ref/example1"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               elementFormDefault="qualified"&gt;
               
               &lt;xs:complexType name="registered-query"&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:extension base="query"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element ref="id" minOccurs="0" maxOccurs="unbounded"/&gt;
               &lt;xs:element ref="option" minOccurs="0" maxOccurs="unbounded"/&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attribute name="weight" type="weight" use="optional"/&gt;
               &lt;/xs:extension&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;
               
               &lt;xs:element name="registered-query" type="registered-query"
               substitutionGroup="query"/&gt;
               
               &lt;xs:simpleType name="id"&gt;
               &lt;xs:restriction base="xs:unsignedLong"/&gt;
               &lt;/xs:simpleType&gt;
               
               &lt;xs:element name="id" type="id"/&gt;
               
               &lt;xs:element name="option" type="option"/&gt;
               
               &lt;xs:simpleType name="option"&gt;
               &lt;xs:restriction base="xs:string"&gt;
               &lt;xs:enumeration value="stemmed"/&gt;
               &lt;xs:enumeration value="unstemmed"/&gt;
               &lt;xs:enumeration value="wildcarded"/&gt;
               &lt;xs:enumeration value="unwildcarded"/&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;
               
               &lt;xs:complexType name="query"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;Any query.&lt;/xs:documentation&gt;
               &lt;xs:appinfo/&gt;
               &lt;/xs:annotation&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:restriction base="xs:anyType"&gt;
               &lt;xs:anyAttribute processContents="lax"/&gt; 
               &lt;/xs:restriction&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;
               
               &lt;xs:element name="query" type="query" abstract="true"/&gt;
               
               &lt;xs:simpleType name="weight"&gt;
               &lt;xs:restriction base="xs:double"&gt;
               &lt;xs:minInclusive value="0"/&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;
               &lt;/xs:schema&gt;
               
               
            </div>
            <div class="programlisting e136" xml:space="preserve">
               /
               /schemaElement::p:registered-query
               /schemaElement::p:option
               /schemaElement::p:id
               /schemaElement::p:query
               /type::p:registered-query
               /type::p:registered-query/model::sequence
               /type::p:registered-query/schemaAttribute::weight
               /type::p:option
               /type::p:option/facet::enumeration
               /type::p:id
               /type::p:weight
               /type::p:weight/facet::minInclusive
               /type::p:query
               /type::p:query/anyAttribute::*
               
            </div>
            <div class="caption e137">
               <div class="para e138">Schema and its canonical paths</div>
            </div>
         </div>
         <div class="para e139">The set of canonical SCPs for a schema give us a quick summary of
            basic facts of the schema.  In this case we can see that the schema has
            four top-level element declarations, five top-level
            type definitions, two constraining facets, one model group, and one local
            attribute declaration. The schema appears to be written in the Garden of Eden
            style, because there are no anonymous type definitions.
            
         </div>
         <div class="para e140">Note, however, that the canonical SCPs (and indeed, SCPs in general)
            do not currently include information about non-component properties of the 
            components, such as occurrence indicators or value constraints. Clearly such
            properties provide important information about a schema, and their absence
            is a serious limitation to using SCPs alone. The SCP specification does define
            an accessor syntax, but declines to define any specific accessors or their
            semantics.
            
         </div><a name="ComparisonwithExtendedXPathsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e141">
            <div class="title e142">Comparison with Extended XPaths</div>
            <div class="para e143">Coates and Dui 
               <div class="citation e144" linkend="xsddiff"></div> present the idea of 
               using "extended XPaths" for XML Schema differencing.  As with schema component
               paths, these extended XPaths use an XPath-like syntax to traverse the
               component model for an assembled schema. The paper presents how these
               paths can be used to compare schemas for changes.
               
            </div>
            <div class="para e145">A key difference between the extended XPaths and schema component 
               paths is simply that there is no specification of the rules for generation 
               and interpretation of the extended XPaths, while schema component paths are
               defined in a public formal specification.
               
            </div>
            <div class="para e146">Still, some differences are clear:</div>
            <div class="orderedlist e147">
               <div class="listitem e148">
                  <div class="para e149">Extended XPaths include information about non-component 
                     properties, such as occurrence indicators (minOccurs and maxOccurs), value 
                     constraints (default values), and facet values.  A predicate style of 
                     representation is used.
                  </div>
               </div>
               <div class="listitem e150">
                  <div class="para e151">Extended XPaths focus on paths for elements and 
                     attributes, with annotations for certain kinds of type
                     information.
                  </div>
               </div>
               <div class="listitem e152">
                  <div class="para e153">Schema component paths includes a definition of canonical
                     paths; these paths distinguish shared components from locally defined
                     ones.
                  </div>
               </div>
               <div class="listitem e154">
                  <div class="para e155">Schema component paths cover all component types, including named
                     model groups and attribute groups.
                  </div>
               </div>
            </div>
            <div class="para e156">There are strengths and weaknesses to both approaches.</div>
            <div class="itemizedlist e157">
               <div class="listitem e158">
                  <div class="para e159">Including 
                     non-component properties in the path means that metrics or differences that
                     depend on those properties can be calculated using the paths alone. For
                     example, a canonical path-based schema difference will report no change
                     in the schema if the default value for an attribute changes, or if one
                     schema requires 1 or more occurrences of an element instead of 0 or more.
                     Schema component paths are therefore insufficient to detect such
                     differences. The predicate style of representation makes these properties
                     manifest in the paths, which makes the information more immediately
                     accessible than relying on something else to use accessors to fetch the
                     values and compute information based on those values.
                     
                  </div>
               </div>
               <div class="listitem e160">
                  <div class="para e161">A central aim of complexity metrics is to measure reuse.
                     Distinguishing between paths that involve shared components, such as 
                     those inherited from base types or named groups, is therefore essential to
                     compute such metrics. Extended XPaths cannot be used to compute such metrics
                     because by design they elide such differences.
                     
                  </div>
               </div>
               <div class="listitem e162">
                  <div class="para e163">The design of extended XPaths captures differences that make a
                     difference to validation outcomes, but not other kinds of differences. If the
                     purpose of computing the difference between two schemas is to determine if some
                     inadvertent material change has been made to the set of documents that are
                     valid per the schema, this approach is preferable. One need not be
                     bothered to review changes that do not materially affect outcomes.
                     
                  </div>
               </div>
            </div>
            <div class="para e164">In the sections that follow we will look at how to apply SCPs to 
               perform various schema analysis tasks, with some comparison to extended
               XPaths.
               
            </div>
         </div>
      </div><a name="AnalyzingSchemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e165">
         <div class="title e166">Analyzing Schemas</div><a name="SchemaSignaturesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e167">
            <div class="title e168">Schema Signatures</div>
            <div class="para e169">The set of canonical SCPs for a given schema provides a useful 
               schema signature.  This signature can be identify schemas that are functionally
               the same, robustly in the face of differences in physical organization of the
               schema documents, ordering of declarations within those schema documents and
               the presence of extraneous information such as comments. Furthermore, the text
               format of a list of canonical SCPs is simple enough that it can be processed
               with simple tools, such as Unix command line tools, to analyze the schema and
               compare it with other schemas.
               
            </div>
            <div class="figure e170" xml:id="fig_sig">
               <div class="programlisting e171" xml:space="preserve"> 
                  canonicals example.xsd | sort -f/ -s -k2,2 
                  
               </div>
               <div class="caption e172">
                  <div class="para e173">Computing a schema signature</div>
               </div>
            </div>
            <div class="para e174">This schema signature procedure performs a stable sort on the
               second field only (which is to say, the first step after the root), so top level
               schema components will appear with their names in order by component type,
               while model groups will not be reshuffled. In the case of sequence model
               groups, it is important to preserve the order of the particles because a change
               in the ordering constitutes a significant difference. However, this means that
               ordering changes in choice or all groups will produce different signatures even
               though these changes do not materially affect the schema.
               Similarly the reordering of attributes would also produce a different signature.
               Alternatively, a global sort could be used, with the opposite weakness of
               giving equivalent signatures to two schemas that differ in the order of
               particles in a sequence model group.
               
            </div>
         </div><a name="SchemaDifferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e175">
            <div class="title e176">Schema Differences</div>
            <div class="para e177">Determining what has changed between two versions by looking at the
               schema documents themselves can be a daunting task. Simple file differencing
               can include lots of irrelevant detail, or can be stymied by a reorganization of
               the partitioning of the schema across multiple schema documents. A comparison
               of the two schema signatures is much easier to grasp and doesn't suffer from
               these problems.
               
            </div>
            <div class="figure e178" xml:id="fig_diff">
               <div class="programlisting e179" xml:space="preserve"> 
                  canonicals example_v1.xsd | sort -f/ -s -k2,2 &gt; 1.out
                  canonicals example_v2.xsd | sort -f/ -s -k2,2 &gt; 2.out
                  echo "*********** New in $xsd2"
                  diff -w 1.out 2.out | grep '&gt;' | sed 's/^&gt; //'
                  echo "*********** Removed from $xsd2"
                  diff -w 1.out 2.out | grep '&lt;' | sed 's/^&lt; //'
                  
               </div>
               <div class="caption e180">
                  <div class="para e181">Comparing schema versions</div>
               </div>
            </div>
            <div class="figure e182" xml:id="fig_cts_42">
               <div class="programlisting e183" xml:space="preserve"> 
                  *********** New in example_v2.xsd
                  /schemaElement::p:cluster
                  /schemaElement::p:clustering
                  /schemaElement::p:clustering/type::0
                  /schemaElement::p:clustering/type::0/model::choice
                  /schemaElement::p:complete
                  /schemaElement::p:max-terms
                  /schemaElement::p:min-weight
                  /schemaElement::p:options
                  /schemaElement::p:options/type::0
                  /schemaElement::p:options/type::0/model::choice
                  /schemaElement::p:score
                  /schemaElement::p:term/type::0/model::sequence
                  /schemaElement::p:term/type::0/schemaAttribute::fitness
                  /schemaElement::p:term/type::0/schemaAttribute::confidence
                  /schemaElement::p:use-db-config
                  /type::p:cluster
                  /type::p:cluster/schemaAttribute::id
                  /type::p:cluster/schemaAttribute::parent-id
                  /type::p:cluster/schemaAttribute::label
                  /type::p:cluster/schemaAttribute::count
                  /type::p:cluster/schemaAttribute::nodes
                  /type::p:nodes
                  /type::p:nodes/facet::finite
                  /type::p:score-kind
                  /type::p:score-kind/facet::enumeration
                  *********** Removed from example_v2.xsd
                  
               </div>
               <div class="caption e184">
                  <div class="para e185">A sample schema difference report</div>
               </div>
            </div>
            <div class="para e186">
               A schema difference based on a canonical schema component path signature
               will be sensitive to additions and deletions of elements and attributes, the
               introduction of new named types or groups, or a switch in compositor type.
               A change in base type will be seen as a second order effect: by what impact it
               has on the derived type. Such a schema difference will be insensitive to
               changes in occurrence or value constraints, or in facet values.  
               
            </div>
            <div class="para e187">A schema difference based on extended XPaths
               will also be sensitive to additions and deletions of elements and attributes
               and switches in compositor types. It will also pick up differences in
               occurrence and value constraints and in facet values. A change in base type
               will be directly visible, but the introduction of new types will be visible as
               a second order effect and only if the new type is actually used within the
               schema. The introduction or removal of named model group and attribute groups,
               or the switching of an element from being local to being global will be
               invisible.
            </div>
            <div class="para e188">From the point of view of knowing what the changes are that
               materially affect the set of valid documents, the extended XPath approach is
               clearly preferable. The lack of non-component properties on schema component
               paths is a serious weakness in this respect. Facet values and occurrence
               constraints have an obvious effect on validation and changes to them count as
               important changes. Augmenting the schema component path model to make such
               values manifest as predicates, as extended XPaths do, would be a good step 
               forward. On the other hand, from the point of view of knowing about
               substantive changes to the usability of the schema by other schemas or for
               non-validation purposes, the schema component path approach of enumerating
               canonical paths for all components makes sense. When an XML Schema is imported
               into an XQuery module, for example, all the types are present and available,
               even ones not used in any content model.  Augmenting extended XPaths to capture
               information about all components would be a positive step forward for that
               technique. 
               
            </div>
         </div><a name="SchemaMetricsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e189">
            <div class="title e190">Schema Metrics</div>
            <div class="para e191">Schema signatures can be used to calculate schema complexity
               metrics.  Compared to the large body of work on software metrics, little has
               been done on schema metrics.  Neither is there clear consensus of what the
               useful metrics should be.
               
            </div>
            <div class="para e192">
               A paper by Lammel, Kitsis, and Remy 
               <div class="citation e193" linkend="metrics1"></div> examines
               a number of counts and metrics
               and computes them against a corpus of actual schemas, as an attempt to
               characterize the usage patterns found in practice.  The paper begins with basic
               counts against the XML document, and then to XML Schema aware
               counts of the number of global element and attribute declarations, global
               complex and simple type definitions, and named model group and attribute group
               definitions. The paper argues against the simple sum of global element
               declarations and global complex type definitions as a metric of schema size on
               the grounds that this measure is sensitive to schema construction styles: a
               Russian Doll schema would always rank as small (one global element declaration)
               no matter how deeply nested its inner element declarations became.  The paper
               moves on to counts of local element declarations and type definitions, and
               proposes a simple size metric that is purely the count of all complex type
               definitions. 
               
            </div>
            <div class="para e194">
               The authors then attempt to apply define something akin to 
               McCabe 
               <div class="citation e195" linkend="mccabe"></div> complexity measures for XML Schemas.  The
               metric combines the number of branches in choice model groups, the number of
               non-default occurrence constraints (minOccurs or maxOccurs something other than
               1), the number of references to a substitution group head, the number of
               references to a global type definition, the number of nillable attributes, and
               the number of global element declarations.  
               
            </div>
            <div class="para e196">Additional metrics are defined for code-oriented and
               instance-oriented breadth and depth.  The depth metrics incorporate such
               features as the number of particles in content models or the number of
               "parties": the difference is that the code-oriented depth metric counts a
               reference to a named model group as 1, but the instance-oriented depth metric
               counts all the particles obtained by the reference.  The code-oriented depth
               metric counts the amount of nesting of element declarations in the schema. 
               
            </div>
            <div class="table e197" xml:id="tab_metrics1">
               <div class="caption e198">
                  <div class="para e199">Summary of metrics in 
                     <div class="citation e200" linkend="metrics1"></div>
                  </div>
               </div>
               <div class="tr e201">
                  <div class="td e202">File size kB or lines of code</div>
               </div>
               <div class="tr e203">
                  <div class="td e204">XML nodes: total</div>
               </div>
               <div class="tr e205">
                  <div class="td e206">XML annotation nodes: total</div>
               </div>
               <div class="tr e207">
                  <div class="td e208">Element declarations: #global, #local, total</div>
               </div>
               <div class="tr e209">
                  <div class="td e210">Complex type definitions: #global, #local, total</div>
               </div>
               <div class="tr e211">
                  <div class="td e212">Simple type definitions: #global, #local, total</div>
               </div>
               <div class="tr e213">
                  <div class="td e214">Named model group definitions: #global, total</div>
               </div>
               <div class="tr e215">
                  <div class="td e216">Attribute group definitions: #global, total</div>
               </div>
               <div class="tr e217">
                  <div class="td e218">Attribute declarations: #global, #local, total</div>
               </div>
               <div class="tr e219">
                  <div class="td e220">McCabe cyclomatic complexity for XML Schema</div>
               </div>
               <div class="tr e221">
                  <div class="td e222">Code-oriented breadth and depth</div>
               </div>
               <div class="tr e223">
                  <div class="td e224">Instance-oriented breadth and depth</div>
               </div>
            </div>
            <div class="para e225">
               A paper by McDowell, Schmidt, and Yue 
               <div class="citation e226" linkend="metrics2"></div> proposes
               various schema complexity and quality
               metrics: counts of complex type declarations (broken down by the type of the
               content model), simple type declarations, annotations, derived complex types,
               global type declarations, the average number of attributes per type
               declaration, the number of references to global types, the number of unbounded
               elements, the average range in bounds for bounded elements ("multiplicity"),
               the average number of restrictions per simple type, and the fan-in and fan-out
               of element declarations.
               
            </div>
            <div class="para e227">
               Overall complexity and quality indexes apply weighting factors to various
               measures to give an overall score.  The quality index combines the ratio of
               simple to complex type declarations, the percentage of annotations over total
               number of element declarations, the average restrictions per simple type
               declaration, percentage of derived complex type declarations of the total
               number of complex type declarations, the average bounded multiplicity size, 
               and the average number of attributes per type declaration.  The complexity
               index combines the number of unbounded elements, the element fanning, the
               number of complex type declarations, the number of simple type declarations,
               and the average number of attributes per complex type declaration.
               
            </div>
            <div class="table e228" xml:id="tab_metrics2">
               <div class="caption e229">
                  <div class="para e230">Summary of metrics in 
                     <div class="citation e231" linkend="metrics2"></div>
                  </div>
               </div>
               <div class="tr e232">
                  <div class="td e233">Annotation nodes: total</div>
               </div>
               <div class="tr e234">
                  <div class="td e235">Element declarations: #global, #local, #references</div>
               </div>
               <div class="tr e236">
                  <div class="td e237">Complex type definitions: #global, #local, total, #simple,
                     #mixed, #element-only, #derived
                  </div>
               </div>
               <div class="tr e238">
                  <div class="td e239">Simple type definitions: total, restrictions/total</div>
               </div>
               <div class="tr e240">
                  <div class="td e241">Attributes: average per complex type</div>
               </div>
               <div class="tr e242">
                  <div class="td e243">Elements: average bounded element multiplicity, fanning</div>
               </div>
               <div class="tr e244">
                  <div class="td e245">Quality index</div>
               </div>
               <div class="tr e246">
                  <div class="td e247">Complexity index</div>
               </div>
            </div>
            <div class="para e248">There is some overlap in these metrics, such as basic counts in the
               number of different kinds of components, but in the main these are two very
               different takes on what kind of information might be interesting or useful to
               measure.
               
            </div>
            <div class="para e249">Many of these metrics can be readily calculated from the schema
               signature.  For example the number of element declarations can be determined by
               counting the number of canonical SCPs containing 'schemaElement::' as the last
               step, the number of global element declarations is the number of canonical SCPs
               beginning with '/schemaElement::' but not containing two slashes, and the
               number of local element declarations is the number of canonical SCPs containing
               'schemaElement::' somewhere other than at the start.  
               
            </div>
            <div class="figure e250" xml:id="fig_calc">
               <div class="programlisting e251" xml:space="preserve">
                  # Total number of global element declarations
                  canonicals example.xsd | grep '^/schemaElement::[^/]*$' | wc -l
                  # Total number of local element declarations
                  canonicals example.xsd | grep '[^/].*/schemaElement::[^/]*$' | wc -l
                  # Total number of element declarations
                  canonicals example.xsd | grep 'schemaElement::[^/]*$' | wc -l
                  # Type definitions
                  canonicals example.xsd | grep 'type::[^/]*$' | wc -l
                  # Attribute declarations
                  canonicals example.xsd | grep 'schemaAttribute::[^/]*$' | wc -l
                  # Named model group definitions
                  canonicals example.xsd | grep 'group::[^/]*$' | wc -l
                  # Attribute group definitions
                  canonicals example.xsd | grep 'attributeGroup::[^/]*$' | wc -l
                  # Notation declarations
                  canonicals example.xsd | grep 'notation::[^/]*$' | wc -l
                  # Identity constraint definitions
                  canonicals example.xsd | grep 'identityConstraint::[^/]*$' | wc -l
                  # Total number of components
                  canonicals example.xsd | wc -l 
                  
               </div>
               <div class="caption e252">
                  <div class="para e253">Computing simple count metrics</div>
               </div>
            </div>
            <div class="para e254">Many of the metrics listed above to not lend themselves well to a
               simple schema-signature-based approach.
               Certain kinds of metrics do not lend then well to a SCP-based
               approach at all: certainly those that rely on the XML representation of
               the schema rather than the schema itself such as the number of XML nodes, for
               example. 
               
            </div>
            <div class="para e255">SCPs do not distinguish directly between simple and complex type
               definitions because they form a single symbol space in XML Schema: one can have
               both an element declaration and a type definition named 'example', but not both
               a simple and complex type definition with that name.  If there is a canonical
               SCP where a facet axis follows a type definition, we know that the type is a
               simple type; if there is a canonical SCP where a model axis or attribute axis
               follows a type definition, we know that the type is a complex type. Otherwise,
               we can't tell from the SCPs alone.  
               
            </div>
            <div class="para e256">Another class of metrics that are not readily
               computable from canonical SCPs are certain kinds of inbound counts: the number
               of uses of global element declarations, the number of uses of a substitution
               group head, and so forth.  Similarly, statistics that distinguish particles
               that derive from references to named model groups from the rest cannot be
               computed with canonical SCPs alone, as the schema component model records that
               information through through the scope property. In any case, if the content
               model has a reference to a global element declaration, this will not create a
               canonical SCP for that particle: the canonical SCP for the element declaration
               is the top-level one.
               
            </div>
            <div class="para e257">In addition, since non-component properties of schema components
               are not reflected in the SCPs, any statistic that depends on the value of such
               a property cannot be computed with SCPs alone.  The the unbounded element 
               multiplicity from 
               <div class="xref e258" linkend="metrics2"></div> and the cyclomatic complexity from
               
               <div class="xref e259" linkend="metrics1"></div>, which look at the minOccurs and maxOccurs, fall
               into this class.
               
            </div>
            <div class="para e260">Coates and Dui 
               <div class="citation e261" linkend="xsddiff"></div> did not look at 
               metrics in their paper, but surely many metrics can be calculated using their
               extended XPaths as well. Counts of components of various types would be
               difficult: the distinction between element and attribute declarations seems to
               be manifest only in the how the type predicates are represented, the
               apparent loss of information about named groups suggests that not only will
               named groups not be counted at all, but some over-counting of element and
               attribute declarations is likely. Similarly, types cannot be accurately
               counted. In general the extended XPath approach is not conducive to measuring
               component reuse, which is an important aspect of schemas to measure.
               On the other hand, extended XPaths provide information that can be
               used to compute metrics that depend on occurrence constraints.
               
            </div>
            <div class="para e262">At this point, the reader will be excused for thinking that things
               are looking grim for the use of SCPs for obtaining serious schema metrics.  All
               is not lost, however.  First, many of these statistics can be computed by using
               non-canonical SCPs to select a particular set of components, and counting
               against that set.  Where the metrics need the values of properties of
               particular components, the ability to select components using a non-canonical
               SCP needs to be augmented with an ability to inspect or query the properties.
               For example, the particle axis can be used to count number of particles in
               content models, the scope axis can be used to distinguish particles derived
               from named model groups from local ones, and the substitutionGroup axis can be
               used to count references to substitution group heads.
               Second, since it is far from clear which statistics to use to examine schema
               size, complexity, or quality, a more fruitful approach may be to see what
               statistics we 
               <div class="emphasis e263">can</div> compute from SCPs and see what they show
               us. Some metrics can be replaced by similar metrics that are more amenable to
               calculation via SCPs. For example, looking at the ratio of SCPs containing a
               type definition as an intermediate step against the number of SCPs representing
               a type definition (that is, whose final step is a type axis) gets at similar
               schema characteristics as element fanning.
               
            </div>
            <div class="para e264">The simplest measure obtainable from the schema signature is a
               simple count of how many canonical paths there are for a particular schema.
               A schema with a high level of reuse of global declarations and definitions will
               result in fewer canonical paths.  Suppose there are two schemas, one of which
               defines a global element declaration and uses it in two places, and one of
               which defines a local element declaration in each place.  The first schema will
               have one canonical SCP for the global element declaration, while the second
               will have a canonical SCP for each local element declaration. Each reuse of
               the global declaration leads to one less canonical SCP in the schema.
               If two schemas have a similar number of declarations, the one with fewer paths
               is the simpler.
               
            </div>
            <div class="para e265">An interesting extension of the path count can be obtained by
               generating SCPs along the canonical axes to a particular depth, but not
               worrying about the other whether the SCP is canonical or not.  For example, if
               a content model references a global element declaration, a SCP that extends the
               content model's SCP through the schemaElement axis would not be a canonical
               one (the canonical SCP is the one directly from the root to the global element
               declaration), but it would be a level 1 extension to a canonical SCP.
               A level 2 extension to a canonical SCP is the addition of one more step through
               a canonical axis to a level 1 extension to a canonical SCP, and so on.
               In some simple data-oriented schemas, the set of canonical SCPs is no different
               from the set of level 1 extensions. At the other extreme, schemas where
               content models for different elements recursively refer to each other can have
               a set of level 1 extensions substantially larger than the set of canonical
               SCPs. The growth in the number of paths as the level increases is a measure of
               the inter-relatedness of the components in the schema, and high growth can be
               the sign of a schema that has many dependencies and is therefore more complex.
               
            </div>
            <div class="para e266">Calculation of the total and average number of steps in the SCPs can
               also be computed readily. A higher average path length indicates less
               component reuse and more local definitions, more complex content
               models, or more additional constraints on simple type. In short: a more complex
               schema. Again, the growth of this measure for level N extensions gives some
               indication of the inter-relatedness of the components in the schema.
               
            </div>
            <div class="table e267" xml:id="fig_stats">
               <div class="caption e268">
                  <div class="para e269">Statistics for a selection of schemas</div>
               </div>
               <div class="tr e270">
                  <div class="th e271">Schema</div>
                  <div class="th e272">Elements</div>
                  <div class="th e273">Types</div>
                  <div class="th e274">Attributes</div>
                  <div class="th e275">E+T+A</div>
                  <div class="th e276">Paths</div>
                  <div class="th e277">Path length</div>
                  <div class="th e278">Level 10 paths</div>
                  <div class="th e279">Level 10 path length</div>
               </div>
               <div class="tr e280">
                  <div class="td e281">XSLT&nbsp;2.0</div>
                  <div class="td e282" align="right">52</div>
                  <div class="td e283" align="right">93</div>
                  <div class="td e284" align="right">185</div>
                  <div class="td e285" align="right">330</div>
                  <div class="td e286" align="right">481</div>
                  <div class="td e287" align="right">3.56</div>
                  <div class="td e288" align="right">1850</div>
                  <div class="td e289" align="right">6.54</div>
               </div>
               <div class="tr e290">
                  <div class="td e291">XHTML&nbsp;1.1</div>
                  <div class="td e292" align="right">97</div>
                  <div class="td e293" align="right">119</div>
                  <div class="td e294" align="right">230</div>
                  <div class="td e295" align="right">446</div>
                  <div class="td e296" align="right">1682</div>
                  <div class="td e297" align="right">3.81</div>
                  <div class="td e298" align="right">923374</div>
                  <div class="td e299" align="right">13.58</div>
               </div>
               <div class="tr e300">
                  <div class="td e301">XMLSpec</div>
                  <div class="td e302" align="right">178</div>
                  <div class="td e303" align="right">226</div>
                  <div class="td e304" align="right">139</div>
                  <div class="td e305" align="right">543</div>
                  <div class="td e306" align="right">1087</div>
                  <div class="td e307" align="right">3.22</div>
                  <div class="td e308" align="right">10889</div>
                  <div class="td e309" align="right">10.09</div>
               </div>
               <div class="tr e310">
                  <div class="td e311">SDocBook</div>
                  <div class="td e312" align="right">119</div>
                  <div class="td e313" align="right">282</div>
                  <div class="td e314" align="right">785</div>
                  <div class="td e315" align="right">1186</div>
                  <div class="td e316" align="right">1574</div>
                  <div class="td e317" align="right">3.19</div>
                  <div class="td e318" align="right">4183690</div>
                  <div class="td e319" align="right">12.41</div>
               </div>
               <div class="tr e320">
                  <div class="td e321">FpML&nbsp;4.4</div>
                  <div class="td e322" align="right">1972</div>
                  <div class="td e323" align="right">889</div>
                  <div class="td e324" align="right">262</div>
                  <div class="td e325" align="right">3123</div>
                  <div class="td e326" align="right">7313</div>
                  <div class="td e327" align="right">3.85</div>
                  <div class="td e328" align="right">73110</div>
                  <div class="td e329" align="right">9.59</div>
               </div>
               <div class="tr e330">
                  <div class="td e331">GML&nbsp;3.2</div>
                  <div class="td e332" align="right">1063</div>
                  <div class="td e333" align="right">1137</div>
                  <div class="td e334" align="right">1717</div>
                  <div class="td e335" align="right">3917</div>
                  <div class="td e336" align="right">6386</div>
                  <div class="td e337" align="right">3.22</div>
                  <div class="td e338" align="right">61249</div>
                  <div class="td e339" align="right">8.58</div>
               </div>
            </div>
            <div class="para e340">
               <div class="xref e341" linkend="fig_stats"></div> shows some metrics for an
               assortment of schemas. XMLSpec (the vocabulary
               used to write W3C specifications) and XHTML are relatively
               simple document-oriented vocabularies and measured as the sum of element
               declarations, attribute declarations, and type declarations they are of
               roughly comparable size.  Simplified DocBook, a somewhat more extensive 
               document-oriented vocabulary, is about twice as large by this measure.
               In terms of paths, however, DocBook is smaller than XHTML and about only about 
               one and a half times the size of XMLSpec.
               
            </div>
            <div class="para e342">GML and FpML are both highly structured data-oriented schemas. 
               Which is more complex?  FpML has more elements, but GML has a larger E+T+A 
               count.  FpML has more paths and a larger average path length. E+T+A speaks
               to what one needs to know about a schema to fully make use of it in a processing
               environment such as XSLT or XQuery, while the path count speaks to the 
               burden on a schema maintainer.
               
            </div>
            <div class="para e343">
               While the average path length for canonical SCPs does not vary
               greatly, the growth in average path length for level 10 paths is quite
               substantial.
               The differences in level 10 extensions is astonishing, however: simplified
               DocBook produces two orders of magnitudes more level 10 extensions than
               XMLSpec and one order of magnitude more than XHTML, 
               despite the fact that XMLSpec is larger in terms of the element/type/attribute 
               count and not drastically smaller in terms of the canonical
               SCP count and XHTML is larger in terms of the canonical SCP count. 
               It appears that the main reason for this is that XMLSpec and XHTML make use of 
               substitution groups and named model and attribute groups, while simplified 
               DocBook uses large choice groups instead.
               
            </div>
            <div class="table e344" xml:id="fig_reusable">
               <div class="caption e345">
                  <div class="para e346">Reusable components in a selection of schemas</div>
               </div>
               <div class="tr e347">
                  <div class="th e348"></div>
                  <div class="th e349" colspan="4">Global</div>
                  <div class="th e350" rowspan="2">E+T+A Global/Total</div>
                  <div class="th e351" colspan="2">Named Groups</div>
                  <div class="th e352" rowspan="2">Substitution Group Heads</div>
               </div>
               <div class="tr e353">
                  <div class="th e354">Schema</div>
                  <div class="th e355">Elements</div>
                  <div class="th e356">Types</div>
                  <div class="th e357">Attributes</div>
                  <div class="th e358">E+T+A</div>
                  <div class="th e359">Model</div>
                  <div class="th e360">Attribute</div>
               </div>
               <div class="tr e361">
                  <div class="td e362">XSLT&nbsp;2.0</div>
                  <div class="td e363" align="right">52</div>
                  <div class="td e364" align="right">28</div>
                  <div class="td e365" align="right">4</div>
                  <div class="td e366" align="right">84</div>
                  <div class="td e367" align="right">0.25</div>
                  <div class="td e368" align="right">2</div>
                  <div class="td e369" align="right">2</div>
                  <div class="td e370" align="right">3</div>
               </div>
               <div class="tr e371">
                  <div class="td e372">XHTML&nbsp;1.1</div>
                  <div class="td e373" align="right">97</div>
                  <div class="td e374" align="right">98</div>
                  <div class="td e375" align="right">1</div>
                  <div class="td e376" align="right">196</div>
                  <div class="td e377" align="right">0.44</div>
                  <div class="td e378" align="right">57</div>
                  <div class="td e379" align="right">141</div>
                  <div class="td e380" align="right">0</div>
               </div>
               <div class="tr e381">
                  <div class="td e382">XMLSpec</div>
                  <div class="td e383" align="right">178</div>
                  <div class="td e384" align="right">6</div>
                  <div class="td e385" align="right">14</div>
                  <div class="td e386" align="right">198</div>
                  <div class="td e387" align="right">0.36</div>
                  <div class="td e388" align="right">17</div>
                  <div class="td e389" align="right">168</div>
                  <div class="td e390" align="right">16</div>
               </div>
               <div class="tr e391">
                  <div class="td e392">SDocBook</div>
                  <div class="td e393" align="right">119</div>
                  <div class="td e394" align="right">119</div>
                  <div class="td e395" align="right">0</div>
                  <div class="td e396" align="right">238</div>
                  <div class="td e397" align="right">0.20</div>
                  <div class="td e398" align="right">0</div>
                  <div class="td e399" align="right">0</div>
                  <div class="td e400" align="right">0</div>
               </div>
               <div class="tr e401">
                  <div class="td e402">FpML&nbsp;4.4</div>
                  <div class="td e403" align="right">110</div>
                  <div class="td e404" align="right">888</div>
                  <div class="td e405" align="right">0</div>
                  <div class="td e406" align="right">998</div>
                  <div class="td e407" align="right">0.32</div>
                  <div class="td e408" align="right">69</div>
                  <div class="td e409" align="right">1</div>
                  <div class="td e410" align="right">11</div>
               </div>
               <div class="tr e411">
                  <div class="td e412">GML&nbsp;3.2</div>
                  <div class="td e413" align="right">631</div>
                  <div class="td e414" align="right">660</div>
                  <div class="td e415" align="right">14</div>
                  <div class="td e416" align="right">1305</div>
                  <div class="td e417" align="right">0.33</div>
                  <div class="td e418" align="right">7</div>
                  <div class="td e419" align="right">15</div>
                  <div class="td e420" align="right">114</div>
               </div>
            </div>
            <div class="para e421">As we can see in 
               <div class="xref e422" linkend="fig_reusable"></div>, 
               there is a wide range in the utilization of reusable 
               schema components. Global elements and types are broadly used, but global
               attributes are rare. Where attribute reuse is desired, it is accomplished (in
               these schemas at least), through named attribute groups. Substitution groups
               and named model groups seem to restrict both level 10 path counts and lengths.
               
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e423">
         <div class="title e424">Conclusion</div>
         <div class="para e425">Schema component paths provide a characterization of the structure of
            schemas that is insensitive to details of the XML representation and
            partitioning into multiple files.  They can be used as the basis to analyze and
            compare schemas, and to compute metrics of schema size and complexity. This
            paper attempts to sketch some of the possibilities in these areas. Fuller
            metrics and analysis could by obtained by following the lead of extended XPaths
            and including non-component accessors on the paths as well. 
            
         </div>
         <div class="para e426">These metrics calculated in this paper are suggestive and seem to
            capture interesting differences in schema designs, but a more systematic study 
            is warranted.
         </div>
      </div><a name="ToolsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e427">
         <div class="title e428">Tools</div>
         <div class="para e429">MHSCD 
            <div class="citation e430" linkend="mhscd"></div> is a set of Java tools for
            manipulating schema component paths. Both a SCP generator and a locator 
            API (which provides information about component properties) is included. 
            It was used to generate the examples of schema component paths in this paper 
            and is available under a Creative Commons Attribution license. 
            	
         </div>
         <div class="para e431">The schema component path specification 
            <div class="citation e432" linkend="scds"></div> is
            currently under development by the W3C (as of this writing at the Candidate
            Recommendation phase). Readers are invited to review and
            comment on that specification.
            	
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e433">
         <div class="title e434">References</div>
         <div class="bibliomixed e435" xml:id="xsddiff" xreflabel="Coates10">
            Anthony B. Coates and Daniel Dui.
            
            <div class="emphasis e436">"Full Impact" Schema Differencing</div>.
            Conference proceedings XML Prague 2010.
            
         </div>
         <div class="bibliomixed e437" xml:id="mhscd" xreflabel="MHSCD">
            Mary Holstege. MHSCD, available at 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e438" xlink:actuate="onRequest" xlink:href="http://www.mathling.com/xsd/scds.html" xlink:show="new" xlink:title="MHSCD" xlink:type="simple">http://www.mathling.com/xsd/scds.html</div>.
            
         </div>
         <div class="bibliomixed e439" xml:id="metrics1" xreflabel="Lammel05">
            Ralf Lammel, Stan Kitsis, and Dave Remy. 
            
            <div class="emphasis e440">Analysis of XML schema usage</div>.
            Conference Proceedings XML 2005.
            
         </div>
         <div class="bibliomixed e441" xml:id="mccabe" xreflabel="McCabe76">
            T.J. McCabe. 
            
            <div class="emphasis e442">A Measure of Complexity</div>.
            IEEE Transactions on Software Engineering, 2(4), pp. 308-320, 
            December 1976.
            
         </div>
         <div class="bibliomixed e443" xml:id="metrics2" xreflabel="McDowell04">
            Andrew McDowell, Chris Schmidt, and Kwon-Bun Yue.
            
            <div class="emphasis e444">Analysis and Metrics of XML Schema</div>.
            Proceedings of the 2004 International Conference on Software Engineering Research
            and Practice. Volume 2.
            
         </div>
         <div class="bibliomixed e445" xml:id="xsd11" xreflabel="XSD11">
            W3C: Shudi (Sandy) Gao é«æ®é, C. M. Sperberg-McQueen, and Henry S. Thompson, editors.
            
            
            <div class="emphasis e446">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures.</div>
            Last Call Working Draft. W3C, December 2009.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e447" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/</div>
            	
         </div>
         <div class="bibliomixed e448" xml:id="scds" xreflabel="SCD">
            W3C: Mary Holstege and Asir S. Vedamuthu, editors.
            
            <div class="emphasis e449">W3C XML Schema Definition Language (XSD): Component Designators.</div>
            Candidate Recommendation. W3C, January 2010.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e450" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/</div>
            
         </div>
         <div class="bibliomixed e451" xml:id="xsd" xreflabel="XSD10">
            W3C: Henry S. Thompson, Murray Maloney, David Beech, and Noah Mendelsohn, editors.
            
            <div class="emphasis e452">XML Schema Part 1: Structures Second Edition</div>.
            W3C, October 2004. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e453" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</div>
            
         </div>
      </div>
   </div>
</div>