<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#ExtendingXQuerywithpatternmatchingoverXMLHTMLandJSONanditsusagefordataminingANCHOR" name="ExtendingXQuerywithpatternmatchingoverXMLHTMLandJSONanditsusagefordataminingTOC">Extending XQuery with pattern matching over XML, HTML and JSON, and its usage for
               data mining </a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThepatternsyntaxANCHOR" name="ThepatternsyntaxTOC">The pattern syntax</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#BasicnodematchingANCHOR" name="BasicnodematchingTOC">Basic node matching</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SelectingdataANCHOR" name="SelectingdataTOC">Selecting data</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AdvancedpatternsANCHOR" name="AdvancedpatternsTOC">Advanced patterns</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OptionalelementsANCHOR" name="OptionalelementsTOC">Optional elements</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RepeatedelementsANCHOR" name="RepeatedelementsTOC">Repeated elements</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ConditionalsANCHOR" name="ConditionalsTOC">Conditionals</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AlternativeelementsANCHOR" name="AlternativeelementsTOC">Alternative elements</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DefaultoptionsANCHOR" name="DefaultoptionsTOC">Default options</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MatchingJSONiqANCHOR" name="MatchingJSONiqTOC">Matching JSONiq</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheintegrationinXQueryANCHOR" name="TheintegrationinXQueryTOC">The integration in XQuery</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AsfunctionwithoutsyntaxmodificationANCHOR" name="AsfunctionwithoutsyntaxmodificationTOC">As function, without syntax modification</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExtendingSwitchExpressionsANCHOR" name="ExtendingSwitchExpressionsTOC">Extending Switch-Expressions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExtendingFlowersANCHOR" name="ExtendingFlowersTOC">Extending Flowers</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtendingletANCHOR" name="ExtendingletTOC">Extending let</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtendingforANCHOR" name="ExtendingforTOC">Extending for</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#UsingpatternmatchingfordataminingANCHOR" name="UsingpatternmatchingfordataminingTOC">Using pattern matching for data mining</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#FutherworkANCHOR" name="FutherworkTOC">Futher work</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgmentANCHOR" name="AcknowledgmentTOC">Acknowledgment</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">attribute="{expression}"</div>
         <div class="singletermTERMS">attribute</div>
         <div class="singletermTERMS">An overview of the Scala programming language</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bar</div>
         <div class="singletermTERMS">below</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
         <div class="singletermTERMS">benito@benibela.de</div>
         <div class="singletermTERMS">Benito</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">contains</div>
         <div class="singletermTERMS">class</div>
         <div class="singletermTERMS">count</div>
         <div class="singletermTERMS">case</div>
         <div class="singletermTERMS">columns</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">different</div>
         <div class="singletermTERMS">Data mining</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">eq</div>
         <div class="singletermTERMS">ends-with</div>
         <div class="singletermTERMS">else</div>
         <div class="singletermTERMS">eval</div>
         <div class="singletermTERMS">exactly-one($value) ! expression ...</div>
         <div class="singletermTERMS">element</div>
         <div class="singletermTERMS">Exact matching</div>
         <div class="singletermTERMS">Exact prefix matching</div>
         <div class="singletermTERMS">Existence matching</div>
         <div class="singletermTERMS">Extensible Markup Language (XML) 1.0</div>
         <div class="singletermTERMS">Extending XQuery with a Pattern Matching Facility</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">foo</div>
         <div class="singletermTERMS">following</div>
         <div class="singletermTERMS">fn:starts-with($value, $pattern)</div>
         <div class="singletermTERMS">fn:matches</div>
         <div class="singletermTERMS">following-sibling::</div>
         <div class="singletermTERMS">false</div>
         <div class="singletermTERMS">foobar</div>
         <div class="singletermTERMS">function(){$result := .}</div>
         <div class="singletermTERMS">for . in $sequence return expression ...</div>
         <div class="singletermTERMS">for</div>
         <div class="singletermTERMS">foo ^= "bar"</div>
         <div class="singletermTERMS">following::</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">German VideLibri webpage</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">href="http://balisage.net/"</div>
         <div class="singletermTERMS">Header</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">if</div>
         <div class="singletermTERMS">InitialClause</div>
         <div class="singletermTERMS">in</div>
         <div class="singletermTERMS">i-1</div>
         <div class="singletermTERMS">Internet Tools</div>
         <div class="singletermTERMS">Intuitive</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">JSONiq syntax extension</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">list-contains</div>
         <div class="singletermTERMS">let $result :=</div>
         <div class="singletermTERMS">let . := $value return expression</div>
         <div class="singletermTERMS">let</div>
         <div class="singletermTERMS">loops</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">matches</div>
         <div class="singletermTERMS">min</div>
         <div class="singletermTERMS">max</div>
         <div class="singletermTERMS">match</div>
         <div class="singletermTERMS">MatchLetClause</div>
         <div class="singletermTERMS">MatchForClause</div>
         <div class="singletermTERMS">Minimal</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">null</div>
         <div class="singletermTERMS">n*m</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">optional</div>
         <div class="singletermTERMS">object</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">preceding</div>
         <div class="singletermTERMS">prioritized</div>
         <div class="singletermTERMS">pxp</div>
         <div class="singletermTERMS">pxp:match</div>
         <div class="singletermTERMS">PatternExpr</div>
         <div class="singletermTERMS">parent::</div>
         <div class="singletermTERMS">Pattern matching</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">root</div>
         <div class="singletermTERMS">return</div>
         <div class="singletermTERMS">Regular expression pattern matching for XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">switch</div>
         <div class="singletermTERMS">starts-with</div>
         <div class="singletermTERMS">source repository</div>
         <div class="singletermTERMS">String values</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">typeswitch</div>
         <div class="singletermTERMS">true</div>
         <div class="singletermTERMS">template</div>
         <div class="singletermTERMS">t:condition</div>
         <div class="singletermTERMS">t:optional = "true"</div>
         <div class="singletermTERMS">t:loop</div>
         <div class="singletermTERMS">test</div>
         <div class="singletermTERMS">t:test</div>
         <div class="singletermTERMS">t:</div>
         <div class="singletermTERMS">The y-data is 123</div>
         <div class="singletermTERMS">Title A</div>
         <div class="singletermTERMS">Title B</div>
         <div class="singletermTERMS">t:optional</div>
         <div class="singletermTERMS">tr</div>
         <div class="singletermTERMS">text node</div>
         <div class="singletermTERMS">The JSON Query Language</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">unrelated features</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">Validating</div>
         <div class="singletermTERMS">van der Zander</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xs:anyAtomicType</div>
         <div class="singletermTERMS">xs:integer(17)</div>
         <div class="singletermTERMS">xs:string("17")</div>
         <div class="singletermTERMS">Xidel</div>
         <div class="singletermTERMS">XQuery syntax extension</div>
         <div class="singletermTERMS">XML-QL: A Query Language for XML</div>
         <div class="singletermTERMS">XQuery 3.0: An XML Query Language</div>
         <div class="singletermTERMS">XQuery syntax extension</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="ExtendingXQuerywithpatternmatchingoverXMLHTMLandJSONanditsusagefordataminingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Extending XQuery with pattern matching over XML, HTML and JSON, and its usage for
         data mining 
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2014</div>
            <div class="confdates e5">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e6">
            <div class="para e7"> Pattern matching in a broad sense is a common feature of modern functional programming
               languages, answering the question, if one complex structured object has a form that
               is the same as another complex structured object, for some definition of “the same”.
               In XQuery path expressions, switch, and typeswitch statements are often described
               as performing pattern matching, but these are merely impoverished flavors of matching
               when compared to the real thing. 
               We describe a syntax for general pattern matching based on regular expressions for
               XML/HTML/JSONiq trees, how these patterns are matched against input data, and how
               this pattern matching can be integrated into the syntax and semantics of the XQuery
               language.  
               At the end we summarize real-world experience using it for large-scale data mining
               of library webcatalogs.  
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Benito</div>
               <div class="surname e11">van der Zander</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Benito van der Zander is a graduate student at the University of Lübeck, working on
                  the Ph.D. project "Algorithmics Of Causal Inference" investigating algorithms for
                  Pearl's causality framework. Before his enrollment in that graduate school, he has
                  developed the open-source XQuery engine 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e14" xlink:actuate="onRequest" xlink:href="http://xidel.sourceforge.net" xlink:show="new" xlink:type="simple">Xidel</div>. He received a computer science B.S. from the University of Düsseldorf, and a M.S.
                  from the RWTH Aachen.  
               </div>
            </div>
            <div class="affiliation e15">
               <div class="orgname e16">Institute for Theoretical Computer Science </div>
            </div>
            <div class="affiliation e17">
               <div class="orgname e18">Graduate School for Computing in Medicine and Life Sciences, University of Lübeck</div>
            </div>
            <div class="email e19">benito@benibela.de</div>
         </div>
         <div class="legalnotice e20">
            <div class="para e21">Copyright © 2014 Benito van der Zander</div>
         </div>
         <div class="keywordset e22" role="author">
            <div class="keyword e23">Pattern matching</div>
            <div class="keyword e24">XQuery syntax extension</div>
            <div class="keyword e25">JSONiq syntax extension</div>
            <div class="keyword e26">Data mining</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e27">
         <div class="title e28">Introduction</div>
         <div class="para e29">Modern XQuery is becoming a more and more functional programming language. Nowadays
            it has, for example,  filter and map operators, inline functions, higher order functions
            and sequence heads/tails. However, it still does not support any kind of pattern matching,
            although pattern matching is often considered one of the most remarkable features
            of functional programming. Some of them, like Haskell, even base their entire syntax
            on it.  In such languages a pattern matching algorithm takes an input value and one
            or more patterns, and searches the pattern that has the same internal structure as
            the input value, possibly extracting some data from the value.  
         </div>
         <div class="para e30">The most similar feature in XQuery is the 
            <div class="code e31">switch</div> expression that can be used for atomic values, which branches to a case clause of
            equal value. But, since it is limited to atomic values, it cannot be used for the
            majority of data used in XQuery, the XML infosets. 
         </div>
         <div class="para e32">XML Schemas could be used for matching these XML infosets in path or 
            <div class="code e33">typeswitch</div>-expressions. However, this matching cannot directly return data from the matched
            nodes and defining an XML Schema for schema-less input data (like HTML pages) can
            be cumbersome, since its definition requires an additional file and cannot occur within
            the XQuery itself. Also the definition of an XML Schema  is not implicit/intuitive
            like a pattern, but explicit by declaring every element and attribute by a special
            element, so it cannot really be considered pattern matching. 
         </div>
         <div class="para e34">Sometimes the standard path expressions are called "pattern matching", but this is
            not correct either, since a path expression is also a list of explicitly applied filtering
            expressions, not an implicitly defined pattern. 
         </div>
         <div class="para e35">In academics there are various different meanings  of the term "pattern matching",
            often it is used to denote any specific querying on XML trees, like in  [
            <div class="xref e36" linkend="rel2"></div>] or [
            <div class="xref e37" linkend="rel3"></div>]. Or in another direction, [
            <div class="xref e38" linkend="rel1"></div>] considers pattern matching as finding specially ordered subsequences in sequences,
            similarly to regular expressions on sequences of letters. None of this is pattern
            matching in our sense. We consider a pattern to be an exemplary part of an XML (HTML,
            JSON) document that is compared to an input document, detecting if the input document
            contains the pattern, and which parts of the input document were added. 
            
         </div>
         <div class="para e39">
            More specifically, but also figuratively, a pattern can be considered a tree with
            holes, and during matching we must test if the tree of an input document contains
            the pattern tree as subtree, and which nodes of the document are matched to/fall into
            the "holes".
            
              
         </div>
         <div class="para e40">
            To see examples of such patterns, we need to look outside of XQuery and the common
            XML research:
         </div>
         <div class="para e41">One of the first query languages using true XML pattern matching was XML-QL [
            <div class="xref e42" linkend="xmlql"></div>],   an early attempt to develop an XML query language which combines SQL with XML
            pattern matching. However it has never evolved beyond drafting state and appears to
            have been forgotten in favor of XQL the predecessor of XQuery. It is even unclear,
            if there has ever existed an implementation of XML-QL. Its pattern matching as such
            is more expressive than ours, but since it cannot use the matched values in a Turing-complete
            functional language, it is in total less powerful than our system. 
         </div>
         <div class="para e43">Another example is the language Scala [
            <div class="xref e44" linkend="scala"></div>], which tries to combine functional and object-oriented programming concepts. It
            can perform true pattern matching on all of its objects, and has XML literals as abbreviations
            for XML elements, so it can naturally  perform pattern matching on XML elements. However,
            it cannot do this on elements with attributes and is therefore of limited use. 
         </div>
         <div class="para e45">This paper brings these concepts to XQuery by describing a possible syntax for XML
            pattern matching, how these patterns can return selected data and how these patterns
            can be used in XQuery in a natural way. We conclude with our experiences of applying
            these patterns to HTML pages, and possible future work. We do not investigate theoretical
            implications or efficient ways to implement it, instead we want to develop an easy
            and powerful syntax that can be practically used.
            
         </div>
         <div class="para e46">The pattern matching described here is an idealized variant of the actual pattern matching in our implementation
            <div class="popupBox e47">
               <div class="popupLabel" onmouseover="$('#d1e113').show('1000');" onmouseout="$('#d1e113').hide('1000');">[ footnote ]</div>
               <div id="d1e113" style="display: none;">
                  <div class="footnote">
                     <div class="para e48">Available as standalone version under the name "
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e49" xlink:actuate="onRequest" xlink:href="http://xidel.sourceforge.net" xlink:show="new" xlink:type="simple">Xidel</div>" as command line tool and 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e50" xlink:actuate="onRequest" xlink:href="http://videlibri.sourceforge.net/cgi-bin/xidelcgi" xlink:show="new" xlink:type="simple">webservice</div>, and under the name "
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e51" xlink:actuate="onRequest" xlink:href="https://github.com/benibela/internettools" xlink:show="new" xlink:type="simple">Internet Tools</div>" as  GPL library for FreePascal.
                     </div>
                  </div>
               </div>
            </div>. On the one hand, some logical extensions explained here have not  yet been implemented,
            and on the other hand, our implementation has features we do not mention, because
            they are deprecated or would cause confusion.	
         </div>
         <div class="para e52">We assume the reader is familiar with the XML  [
            <div class="xref e53" linkend="xml"></div>], XQuery  [
            <div class="xref e54" linkend="xquery"></div>] and JSONiq  [
            <div class="xref e55" linkend="jsoniq"></div>] standards, so terms and definitions given there will not be repeated.
         </div>
      </div><a name="ThepatternsyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e56">
         <div class="title e57">The pattern syntax</div>
         <div class="para e58">Our goal is to develop a pattern syntax that fulfills the following three properties:</div>
         <div class="itemizedlist e59">
            <div class="listitem e60">
               <div class="para e61">
                  <div class="emphasis e62">Intuitive</div>:
               </div>
               <div class="para e63"> It should be obvious which data a pattern could match, even if you have never seen
                  a pattern before. We realize this, first, by requiring that  a (basic) pattern has
                  to match itself, if the pattern is given as input. Therefore the pattern is an illustrative
                  example for itself.  And, second, by basing most of the syntax on regular expressions which should be
                  familiar to any programmer.
               </div>
            </div>
            <div class="listitem e64">
               <div class="para e65">
                  <div class="emphasis e66">Validating</div>:
               </div>
               <div class="para e67">When matched against not-matching, unexpected input data the pattern should raise
                  an error, instead returning something arbitrary. (unlike a simple path expression
                  that returns an empty sequence on failure.  )
               </div>
            </div>
            <div class="listitem e68">
               <div class="para e69">
                  <div class="emphasis e70">Minimal</div>:
               </div>
               <div class="para e71"> There should be no pointless redundancy or data not relevant to the query within
                  a pattern. This means that all additional data in the input should be ignored during
                  matching, so we can exclude unimportant data from the pattern.
               </div>
            </div>
         </div>
         <div class="para e72">From the first and third property (and later given examples) it follows that it is
            also easy to create a pattern to match a given input, since the pattern can be created
            by copying the input data, completely removing all data that should not be queried
            for, replacing the remaining data with annotations and finally calling it a pattern.
            We hope that this is even easy for people who only have knowledge of XML/HTML and
            no real programming language, since they do not have to write anything new,  contrary
            to a path expression.
         </div>
         <div class="para e73">There is, however, a conflict between the second and third property, which cannot
            be resolved in general. By ignoring additional data a pattern might match a completely
            different input document successfully, which was not intended to be accepted as a
            match, but contains matching data somewhere within it. So for any actual pattern,
            it must be carefully decided what to include and exclude from the pattern. Nevertheless
            the third property is important, because the (HTML) documents we are processing contain
            far too much noise to include it all in the pattern. 
         </div><a name="BasicnodematchingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e74" xml:id="sec_basic">
            <div class="title e75">Basic node matching</div>
            <div class="para e76">Due to the intuitiveness goal the pattern itself has to be a well-formed XML document
               (resp. fragment). We can therefore define the basic "matching" as recursive relation
               between a node of the pattern and a node of the input as follows:
            </div>
            <div class="itemizedlist e77">
               <div class="listitem e78">
                  <div class="para e79">
                     A 
                     <div class="emphasis e80">text node</div> matches another text node, if they have matching string values.
                     
                  </div>
               </div>
               <div class="listitem e81">
                  <div class="para e82">
                     An 
                     <div class="emphasis e83">attribute</div> matches another attribute, if they have the same name and matching string values.
                     
                     
                  </div>
               </div>
               <div class="listitem e84">
                  <div class="para e85">
                     
                     An  
                     <div class="emphasis e86">element</div> 
                     <div class="code e87">E</div> matches another element 
                     <div class="code e88">F</div>, if they have the same name, every attribute of 
                     <div class="code e89">E</div> matches an attribute of 
                     <div class="code e90">F</div> and every child of 
                     <div class="code e91">E</div> matches a descendant of 
                     <div class="code e92">F</div> in order.  
                     
                  </div>
               </div>
            </div>
            <div class="para e93">An exact definition for "matching string values" is given below. The property "in
               order" of the last point means: if a child 
               <div class="code e94">C</div> of 
               <div class="code e95">E</div> matches a descendant 
               <div class="code e96">X</div> of 
               <div class="code e97">F</div> and another child 
               <div class="code e98">D</div> of 
               <div class="code e99">E</div> matches a descendant 
               <div class="code e100">Y</div> of 
               <div class="code e101">F</div>, 
               <div class="code e102">C</div> precedes 
               <div class="code e103">D</div> in the pattern if and only if 
               <div class="code e104">X</div> precedes 
               <div class="code e105">Y</div> in the document. 
            </div>
            <div class="para e106">
               Trivial examples are the pattern 
               <div class="code e107">&lt;foo/&gt;</div> matching an identical input document 
               <div class="code e108">&lt;foo/&gt;</div> or a text node pattern 
               <div class="code e109">foo</div> matching an identical text node 
               <div class="code e110">foo</div>.
               A more meaningful example is the pattern
               
               
               <div class="programlisting e111" xml:space="preserve">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</div>
               
               that matches 
               <div class="programlisting e112" xml:space="preserve">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</div> or (ignoring additional data) 
               <div class="programlisting e113" xml:space="preserve">&lt;element foo="bar" att="value"&gt;&lt;p&gt;cat&lt;call&gt;&lt;meow loudness="60 dB"/&gt;&lt;/call&gt;&lt;/p&gt;&lt;/element&gt;</div> but neither (missing attribute) 
               <div class="programlisting e114" xml:space="preserve">&lt;element&gt;cat&lt;meow/&gt;&lt;/element&gt;</div> nor (wrong name) 
               <div class="programlisting e115" xml:space="preserve">&lt;element foo="bar" xmlns="elsewhere"&gt;cat&lt;meow/&gt;&lt;/element&gt;</div> nor (wrong order of descendants) 
               <div class="programlisting e116" xml:space="preserve">&lt;element foo="bar"&gt;&lt;meow/&gt;cat&lt;/element&gt;</div>
               
               
            </div>
            <div class="para e117">
               We have not considered a syntax to match comment or processing-instruction nodes,
               since such nodes rarely contain data that should be returned by a query and    cannot
               contain a selector expression (see 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e118" linkend="sec_selection" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">below</div>) as a child to select this data. Also the most natural way to match a comment node
               would be to include an 
               <div class="code e119">&lt;!-- .. --&gt;</div> XML comment node in the pattern, which is problematic in our application, because
               we use standalone patterns outside of XQuery, where  we prefer to use XML comments
               as actual comments that are ignored by the matching process. There is also no syntax
               to match document nodes, since it is always possible to match the root node of the
               document instead. 
            </div>
            <div class="para e120">That a child in the pattern is allowed to match any descendant in the input, not only
               another child, follows the principle of ignoring additional data to keep the pattern
               minimal. 
            </div>
            <div class="para e121">Requiring that the descendants have to occur in the same order as the children, instead
               accepting any order, has a few benefits. First, it follows the idea of patterns as
               XML regular expressions, which also match their letters ordered. Second, XQuery itself
               is good at selecting unordered elements, but very difficult [
               <div class="xref e122" linkend="rel1"></div>] to use to select ordered elements
               <div class="popupBox e123">
                  <div class="popupLabel" onmouseover="$('#d1e310').show('1000');" onmouseout="$('#d1e310').hide('1000');">[ footnote ]</div>
                  <div id="d1e310" style="display: none;">
                     <div class="footnote">
                        <div class="para e124">Many people do not even understand how to use the 
                           <div class="code e125">following</div> or 
                           <div class="code e126">preceding</div> axes, which becomes evident after watching   XPath questions on stackoverflow for
                           a while.
                        </div>
                     </div>
                  </div>
               </div>, so the combination of XPath and patterns provides a simple and powerful solution
               for both cases. Third, the advanced pattern syntax contains natural, 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e127" linkend="para_unordered" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">unrelated features</div> that can directly be used for unordered matching. It is doubtful that unordered matching
               could be used for ordered matching in such a way. 
            </div>
            <div class="para e128">The conditions for text node matching could be relaxed to accept any node that has
               a matching string value, not just other text nodes. This might be useful, if the input
               data could sometimes contain markups like 
               <div class="code e129">&lt;em&gt;</div> within the text and sometimes not. However, we have not seen such a use case, and
               therefore have implemented the faster way to match text nodes only to text nodes.
            </div>
            <div class="para e130">
               
               <div class="emphasis e131">String values</div> can be matched using one of six different modes: 
               <div class="code e132">eq</div>, 
               <div class="code e133">matches</div>, 
               <div class="code e134">starts-with</div>, 
               <div class="code e135">ends-with</div>, 
               <div class="code e136">contains</div> and 
               <div class="code e137">list-contains</div>. 
               <div class="code e138">eq</div> checks for an exact match, like the 
               <div class="code e139">eq</div> operator. 
               <div class="code e140">list-contains</div> treats the string value as space separated list (e.g. like the class attribute of
               HTML elements) and matches, if the value of the pattern occurs in that list. The other
               modes match, if the call to the corresponding XQuery function, e.g. 
               <div class="code e141">fn:starts-with($value, $pattern)</div>, returns 
               <div class="code e142">true</div>.
               
               Additionally the matching can be case-sensitive or case-insensitive, in latter case,
               the values are first converted to lowercase resp. the 
               <div class="code e143">i</div> flag is passed to 
               <div class="code e144">fn:matches</div>.
               
            </div>
            <div class="para e145">
               Which  mode is chosen depends on the node whose string value is matched and the local
               settings. Due to legacy reasons, the default modes of our implementation are 
               <div class="code e146">starts-with</div> for text nodes, 
               <div class="code e147">list-contains</div> for 
               <div class="code e148">class</div>-attributes and 
               <div class="code e149">eq</div> for all other attributes
               <div class="popupBox e150">
                  <div class="popupLabel" onmouseover="$('#d1e388').show('1000');" onmouseout="$('#d1e388').hide('1000');">[ footnote ]</div>
                  <div id="d1e388" style="display: none;">
                     <div class="footnote">
                        <div class="para e151">However, in a new, not HTML-focused implementation 
                           <div class="code e152">matches</div> as default for everything might be a more reasonable choice.
                        </div>
                     </div>
                  </div>
               </div>. These modes can be changed within a pattern, similarly to the options described
               
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e153" linkend="tmeta" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">below</div>.
               
            </div>
            <div class="para e154">There is no difference between matching a pattern to an XML document and matching
               it against a HTML document, except that node names are compared case sensitive for
               XML and case insensitive for HTML. 
            </div>
         </div><a name="SelectingdataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e155" xml:id="sec_selection">
            <div class="title e156">Selecting data</div>
            <div class="para e157">So far we have only described how a pattern can be used to test if an input document
               has a certain structure. To become a real replacement for standard XPath selectors,
               we need a way to select specific data from the matches in the input document. In regular
               expressions such selecting can be done with capture groups, an idea  we need to transfer
               to the pattern syntax.  
               
               
            </div>
            <div class="para e158">For this we allow the  embedding of arbitrary XQuery expressions which will be evaluated
               in the context of partial matches and whose return values become the return values
               of the pattern matching. So in  case someone needs a query that does not just copy
               the matched data from the input document, but needs to perform certain calculations
               with the data, he can do it with all the power of XQuery. 
            </div>
            <div class="para e159">We have decided to allow the following ways to embed a query in the pattern:</div>
            <div class="para e160">
               
               
               <div class="itemizedlist e161">
                  <div class="listitem e162">
                     <div class="para e163">
                        <div class="code e164">{expression}</div>: A text node starting with 
                        <div class="code e165">{</div> and ending with 
                        <div class="code e166">}</div> is the shortest syntax to include an expression. The 
                        <div class="code e167">{}</div> parentheses are used, because they correspond to the expression in a standard XQuery
                        element constructor, and, more important, because every string starting with 
                        <div class="code e168">{</div> is an invalid regular expression. So there is never a collision between a regular
                        expression used to match text nodes and a selector expression.  
                     </div>
                  </div>
                  <div class="listitem e169">
                     <div class="para e170">
                        <div class="code e171">&lt;template:s&gt;expression&lt;/template:s&gt;</div>: A more standard syntax to include queries in an XML document. Although the 
                        <div class="code e172">{...}</div> syntax does not collide with regex text matching, it is sometimes problematic to
                        use. For example, if you want to have a text node for matching and a selector expression
                        in the same parent node. So we have added the 
                        <div class="code e173">&lt;s&gt;</div>-element in the namespace 
                        <div class="code e174">http://www.benibela.de/2011/templateparser</div> (at default bound to the namespace prefixes 
                        <div class="code e175">template</div>
                        <div class="popupBox e176">
                           <div class="popupLabel" onmouseover="$('#d1e463').show('1000');" onmouseout="$('#d1e463').hide('1000');">[ footnote ]</div>
                           <div id="d1e463" style="display: none;">
                              <div class="footnote">
                                 <div class="para e177">We usually refer to the patterns as "templates" in our implementation. However, "pattern"
                                    is a more appropriate term. 
                                 </div>
                              </div>
                           </div>
                        </div> and 
                        <div class="code e178">t</div>) that can also contain an expression.
                     </div>
                  </div>
                  <div class="listitem e179">
                     <div class="para e180">
                        <div class="code e181">&lt;t:s&gt;expression&lt;/t:s&gt;</div>:  This is actually identical to  
                        <div class="code e182">&lt;template:s&gt;expression&lt;/template:s&gt;</div> due to binding the same namespace to prefixes 
                        <div class="code e183">template</div> and 
                        <div class="code e184">t</div>, but faster to write being the shortest name a node  outside the default namespace
                        can have. 
                     </div>
                  </div>
                  <div class="listitem e185">
                     <div class="para e186">
                        <div class="code e187">attribute="{expression}"</div>: The 
                        <div class="code e188">{}</div> syntax can also be used in attributes. In that case the attribute is replaced by
                        a 
                        <div class="code e189">t:condition</div> attribute (see 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e190" linkend="tcondition" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">below</div>) just checking the existence of the old attribute, and a 
                        <div class="code e191">&lt;t:s&gt;@attribute / (expression) &lt;/t:s&gt;</div> child node is inserted instead. E.g. 
                        <div class="code e192">&lt;a href="{.}"/&gt;</div> to query for the url of a link target. 
                     </div>
                  </div>
               </div>
               
               
            </div>
            <div class="para e193">After the matching process each node of the pattern has been matched to a unique node
               of the input data. This node is then set as context item 
               <div class="code e194">.</div> when evaluating the query contained in the children of the pattern node and the result
               of these queries is returned as result of the pattern. 
            </div>
            <div class="para e195">With this definition we can for example already write 
               <div class="programlisting e196" xml:space="preserve">&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</div> as a  pattern query for the first  
               <div class="code e197">b</div>-element contained in an 
               <div class="code e198">a</div>-element
               <div class="popupBox e199">
                  <div class="popupLabel" onmouseover="$('#d1e522').show('1000');" onmouseout="$('#d1e522').hide('1000');">[ footnote ]</div>
                  <div id="d1e522" style="display: none;">
                     <div class="footnote">
                        <div class="para e200">The content of the b-element, i.es. a sequence of all its children, might be more
                           natural, but it cannot be assigned to the context item.
                        </div>
                     </div>
                  </div>
               </div>, e.g. it returns 
               <div class="code e201">&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;</div> on input 
               <div class="programlisting e202" xml:space="preserve">&lt;a&gt;&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;&lt;/a&gt;</div>. Using the longer syntax, we get example patterns
               
               <div class="programlisting e203" xml:space="preserve">&lt;a&gt;&lt;b&gt;&lt;t:s&gt;.&lt;/t:s&gt;&lt;/b&gt;&lt;/a&gt;</div> and 
               <div class="programlisting e204" xml:space="preserve">&lt;a&gt;&lt;b&gt;&lt;template:s&gt;.&lt;/template:s&gt;&lt;/b&gt;&lt;/a&gt;</div> that are matched in exactly the same way as the first example pattern.
            </div>
            <div class="para e205">An example for the attribute variant is 
               <div class="programlisting e206" xml:space="preserve">&lt;a href="{.}"/&gt;</div> which returns an attribute node 
               <div class="code e207">href="http://balisage.net/"</div> when matched against 
               <div class="programlisting e208" xml:space="preserve">&lt;html&gt;Some text&lt;p&gt;&lt;a href="http://balisage.net/"&gt;title&lt;/a&gt;&lt;/p&gt;&lt;/html&gt;</div>.
            </div>
            <div class="para e209">A combined example is the pattern 
               <div class="programlisting e210" xml:space="preserve">&lt;a href="{.}"&gt;{concat("=&gt; ", .)}&lt;/a&gt;</div> which would return an attribute node 
               <div class="code e211">href="http://balisage.net/"</div> as well as a string value 
               <div class="code e212">"=&gt; title"</div>.
            </div>
            <div class="para e213">Someone who is familiar with  XQuery's handling of sequences might now wonder what
               happens when a pattern has multiple selector expressions that all return a sequence.
               Does the pattern return multiple sequences? Is that even possible? Does it return
               a single sequence of all sequences flattened together?
            </div>
            <div class="para e214">We prefer former case, because it makes it possible to combine multiple patterns to
               a single one. However, multiple sequences cannot really be handled with standard XQuery
               data types, so we have decided to extend the XQuery syntax to create some kind of
               named return values. 
            </div>
            <div class="para e215">
               
               Thus we have added variable assignments 
               <div class="code e216">$variable := expression</div> which evaluate the expression on the right hand side and assign it to a global variable
               on the left hand side.  The priority of the 
               <div class="code e217">:=</div> operator is set to be lower than the priority of every existing operator. More formally,
               we have introduced these extensions to the XQuery EBNF:
               
               
               <div class="programlisting e218" xml:space="preserve">ExprSingle         ::= FLWORExpr | QuantifiedExpr | SwitchExpr | TypeswitchExpr |
                  IfExpr | TryCatchExpr | VarAssignmentExpr
                  VarAssignmentExpr  ::= (VarRef ":=" )* OrExpr
                  VarRef             ::= "$" VarName   
               </div>
               
               Now we can return multiple sequences by assigning these sequences to variables, e.g.
               
               <div class="code e219">{$var1 := (1,2,3), $var2 := (4,5,6)}</div>. 
            </div>
            <div class="para e220">This leaves the question, what happens, when there are multiple assignments to the
               same variable. We will later see that in 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e221" linkend="tloop" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">loops</div> every selector expression is evaluated multiple times, so the most reasonable way
               is to return two different variables with the same name. Although in most of the 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e222" linkend="integration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">XQuery syntax extension</div> this is not possible, we prefer to do it, where possible. So e.g. 
               <div class="code e223">{$x := (1,2), $x := (3,4)}</div> also returns two different sequences. This is easier to understand, when the variable
               assignments are not considered as creating actual variables, but as creating a name+value
               pair (like a  map with one element) and adding it to a sequence. Since the pairs are
               not sequences themselves, they are not flattened. 
            </div>
            <div class="para e224">
               However, always writing 
               <div class="code e225">{$var := expr}</div> would be  cumbersome, especially after seeing the 
               <div class="code e226">{.}</div> examples above. So we have added two abbreviations
               <div class="popupBox e227">
                  <div class="popupLabel" onmouseover="$('#d1e601').show('1000');" onmouseout="$('#d1e601').hide('1000');">[ footnote ]</div>
                  <div id="d1e601" style="display: none;">
                     <div class="footnote">
                        <div class="para e228">They also apply to 
                           <div class="code e229">&lt;t:s&gt;</div>-expressions, but in the following we will restrict ourselves to 
                           <div class="code e230">{..}</div> for breverity
                        </div>
                     </div>
                  </div>
               </div>:
               
               
               <div class="itemizedlist e231">
                  <div class="listitem e232">
                     <div class="para e233">
                        <div class="code e234">{expression}</div> not containing 
                        <div class="code e235">:=</div>: An expression without assignment is replaced by an assignment 
                        <div class="code e236">{$result := expression}</div> to a default variable 
                        <div class="code e237">$result</div>. The name of the default variable is configurable, and later we will even extend
                        it to assignments to the context item 
                        <div class="code e238">.</div> itself. 
                     </div>
                  </div>
                  <div class="listitem e239">
                     <div class="para e240">
                        <div class="code e241">{$variable}</div>: A selector expression containing exactly one variable is replaced by 
                        <div class="code e242">{$variable := .}</div>
                     </div>
                  </div>
               </div>
               
               With this definition, the meaning of 
               <div class="code e243">{.}</div> is implied and does not need to be defined explicitly, and the above example pattern
               
               <div class="code e244">&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</div> returns the 
               <div class="code e245">b</div>-element in the default variable (if the matching does not fail). Like the XQuery
               expression 
               <div class="code e246">let $result := exactly-one(((//a)[1]//b)[1]) return ...</div> (but we will omit the 
               <div class="code e247">let $result :=</div> prefix in the remaining of the paper for brevity). 
               
            </div>
            <div class="para e248">
               Another example is 
               <div class="programlisting e249" xml:space="preserve">&lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;/root&gt;</div> returning the first 
               <div class="code e250">a</div>-element in 
               <div class="code e251">$a</div> and a following 
               <div class="code e252">b</div>-element in 
               <div class="code e253">$b</div>. It is equivalent to the XQuery expression
               
               <div class="programlisting e254" xml:space="preserve">let $a := exactly-one(((//root)[1]//a)[1]),  
                  $b := exactly-one(($a/following::b)[1] intersect (//root)[1]//b)
                  return ...
               </div>
               This example also shows how awkward it is to simultaneously encode the order requirement
               (
               <div class="code e255">b</div> following 
               <div class="code e256">a</div>) as well as the descendant requirement (
               <div class="code e257">a</div> and 
               <div class="code e258">b</div> being descendants of 
               <div class="code e259">root</div>) in standard XQuery
               <div class="popupBox e260">
                  <div class="popupLabel" onmouseover="$('#d1e692').show('1000');" onmouseout="$('#d1e692').hide('1000');">[ footnote ]</div>
                  <div id="d1e692" style="display: none;">
                     <div class="footnote">
                        <div class="para e261">
                           <div class="code e262">following-sibling::</div> cannot be used, since it encodes a sibling not a descendant relationship.
                        </div>
                     </div>
                  </div>
               </div>.
               
            </div>
            <div class="para e263">So in the end the matching process either raises an matching error or returns a list
               of variable assignments 
               <div class="programlisting e264" xml:space="preserve">$var1 := value1
                  $var2 := value2
                  ... 
               </div>. We call this list "assignment stream", since it is similar to a  tuple stream of
               a flower expression except that it involves different variables.
            </div>
         </div><a name="AdvancedpatternsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e265" xml:id="sec_advanced">
            <div class="title e266">Advanced patterns</div>
            <div class="para e267">The previous sections have explained the basic matching of individual elements, in
               which each node of the pattern is matched to exactly one node in the input data. But
               in practical applications it is necessary to return data that does not have a 1-1
               relationship with the query itself. For this the patterns have various syntaxes which
               are explained in this section:
            </div><a name="OptionalelementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e268">
               <div class="title e269">Optional elements</div>
               <div class="para e270">An optional element is optional, i.e. if a match for the element exists in the input,
                  the element is matched as usual, otherwise it is ignored.
               </div>
               <div class="para e271">
                  There are two ways to mark an element as optional:
                  
                  
                  <div class="itemizedlist e272">
                     <div class="listitem e273">
                        <div class="para e274">
                           <div class="code e275">?</div>: The element is followed by a 
                           <div class="code e276">?</div>, e.g.: 
                           <div class="code e277">&lt;element/&gt;?</div>
                        </div>
                     </div>
                     <div class="listitem e278">
                        <div class="para e279">
                           <div class="code e280">t:optional = "true"</div>: It has an 
                           <div class="code e281">optional</div> attribute, e.g.: 
                           <div class="code e282">&lt;element t:optional="true"/&gt;</div> or 
                           <div class="code e283">&lt;element template:optional="true"/&gt;</div>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e284">
                  <div class="code e285">?</div> as marker does not conflict with text node matching, since regular expressions cannot
                  start with a question mark.
               </div>
               <div class="para e286">A naive implementation can match optional elements first as non-optional, and if that
                  fails with a matching error, skip the element in the pattern and match it again. 
                  
               </div>
            </div><a name="RepeatedelementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e287" xml:id="tloop">
               <div class="title e288">Repeated elements</div>
               <div class="para e289">With the patterns described so far, we can only apply a selector expression to a single
                  element of the input document and therefore only return a single value with a simple
                  selector like 
                  <div class="code e290">{.}</div> or 
                  <div class="code e291">{$var}</div>, although the input usually contains many elements, which all should be examined
                  by a query. In fact returning multiple elements is considered so important that it
                  easier to select all elements than only the first element with standard path expressions.
                  So the patterns need to be extended to be able to match multiple elements.
               </div>
               <div class="para e292">
                  For this we introduce a notation similar to regular expressions:
                  
                  
                  <div class="itemizedlist e293">
                     <div class="listitem e294">
                        <div class="para e295">
                           <div class="code e296">*</div>: The preceding element can be repeated arbitrary many times.  E.g.  
                           <div class="code e297">&lt;element/&gt;*</div>
                        </div>
                     </div>
                     <div class="listitem e298">
                        <div class="para e299">
                           <div class="code e300">+</div>: The preceding element can be repeated once or more times. E.g.  
                           <div class="code e301">&lt;element/&gt;+</div>
                        </div>
                     </div>
                     <div class="listitem e302">
                        <div class="para e303">
                           <div class="code e304">{min, max}</div>: The preceding element is repeated between min and max times. E.g. 
                           <div class="code e305">&lt;element/&gt;{1,3}</div>
                        </div>
                     </div>
                     <div class="listitem e306">
                        <div class="para e307">
                           <div class="code e308">{count}</div>: The preceding element is repeated exactly count times. E.g. 
                           <div class="code e309">&lt;element/&gt;{3}</div> is equivalent to 
                           <div class="code e310">&lt;element/&gt;&lt;element/&gt;&lt;element/&gt;</div>
                        </div>
                     </div>
                     <div class="listitem e311">
                        <div class="para e312">
                           <div class="code e313">&lt;t:loop [min=".."] [max=""]&gt; ... &lt;/t:loop&gt;</div>: The child elements are matched at least 
                           <div class="code e314">@min</div> and at most 
                           <div class="code e315">@max</div> times. A missing 
                           <div class="code e316">min</div> attribute is interpreted as 0, and a missing 
                           <div class="code e317">max</div> attribute as infinite. E.g. 
                           <div class="code e318">&lt;t:loop min="1"&gt;&lt;tr/&gt;&lt;/t:loop&gt; </div> 
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e319">Using these symbols is unproblematic like 
                  <div class="code e320">?</div> for optionality and 
                  <div class="code e321">{}</div> for selector expressions, since no regular expression can start with 
                  <div class="code e322">+</div> or 
                  <div class="code e323">*</div>.  
                  <div class="code e324">{count}</div> could be confused with a selector expression returning 
                  <div class="code e325">count</div>, however a selector returning a single number is pointless, so we can assume every
                  single number is not meant to be a selector. A single text node can contain a repetition
                  marker and a selector expression. 
               </div>
               <div class="para e326">The use of a minimal count can be demonstrated with the following example: each of
                  the patterns 
                  <div class="code e327">&lt;x&gt;{.}&lt;/x&gt;*</div> and 
                  <div class="code e328">&lt;x&gt;{.}&lt;/x&gt;+</div> applied to  
                  <div class="code e329">&lt;root&gt;&lt;x&gt;1&lt;/x&gt;&lt;x&gt;2&lt;/x&gt;&lt;x&gt;3&lt;/x&gt;&lt;/root&gt;</div> returns 
                  <div class="code e330">&lt;x&gt;1&lt;/x&gt;</div>, 
                  <div class="code e331">&lt;x&gt;2&lt;/x&gt;</div> and 
                  <div class="code e332">&lt;x&gt;3&lt;/x&gt;</div>.  However, if applied to 
                  <div class="code e333">&lt;root/&gt;</div>, former succeeds and returns nothing, while latter raises a matching error.
               </div>
               <div class="para e334">Unlike the minimal count a maximal count does not raise matching errors, instead all
                  elements after the first max elements are just ignored, following the principle of
                  ignoring additional data. 
               </div>
               <div class="para e335">Although 
                  <div class="code e336">&lt;x&gt;{.}&lt;/x&gt;*</div> seems to be the same as 
                  <div class="code e337">//x</div>, it is not. This becomes obvious, if we look at the expanded pattern 
                  <div class="code e338">&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;...</div>. All the x-elements in the pattern are siblings and not descendants of each other,
                  so the pattern will only match separated 
                  <div class="code e339">x</div>-elements which do not contain each other. An equivalent XQuery would therefore be
                  
                  <div class="code e340">let $temp := count(ancestor-or-self::x) return .//x[count(ancestor::x) eq $temp]</div> or shorter 
                  <div class="code e341">.//x except .//x//x </div> .
               </div>
               <div class="para e342">Considering a loop to be a sequence of repeated elements also explains, how selectors
                  are handled within the loop: Every selector is evaluated for every matched element
                  and the result is returned as another assignment to the result variable. 
               </div>
               <div class="para e343">For example 
                  <div class="programlisting e344" xml:space="preserve">&lt;a&gt;{$var}&lt;b/&gt;&lt;/a&gt;+</div> applied to 
                  <div class="programlisting e345" xml:space="preserve">&lt;root&gt; &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt; &lt;a&gt;2&lt;/a&gt; &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;</div> returns an assigment stream
                  
                  <div class="programlisting e346" xml:space="preserve">$var := &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt;
                     $var := &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;
                  </div>. The second 
                  <div class="code e347">&lt;a/&gt;</div> is skipped, because it does not a 
                  <div class="code e348">&lt;b/&gt;</div> child. 
               </div>
               <div class="para e349">
                  <div class="code e350">&lt;t:loop&gt;</div> is the most powerful variant of these five syntaxes, not only does it generalize
                  the other notations
                  <div class="popupBox e351">
                     <div class="popupLabel" onmouseover="$('#d1e909').show('1000');" onmouseout="$('#d1e909').hide('1000');">[ footnote ]</div>
                     <div id="d1e909" style="display: none;">
                        <div class="footnote">
                           <div class="para e352">In fact, our implementation converts everything to 
                              <div class="code e353">&lt;t:loop&gt;</div> before matching.
                           </div>
                        </div>
                     </div>
                  </div>, it is the only one that can repeat multiple elements e.g. to separate odd and even
                  rows: 
                  <div class="code e354"> &lt;t:loop&gt;&lt;tr&gt;{$odd}&lt;/tr&gt; &lt;tr&gt;{$even}&lt;/tr&gt; &lt;/t:loop&gt; </div>
               </div>
               <div class="para e355">A possible way to implement repeated elements is to modify the matching process of
                  the parent of the loop node to match all its children and children of 
                  <div class="code e356">t:loop</div>-elements against all possible nodes in the input document. The last match of the
                  non-loop children following the loop children is then a constraint for the maximum
                  number of matching loop children, because only nodes preceding  that last match can
                  be matched by children of the loop. 
               </div>
            </div><a name="ConditionalsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e357" xml:id="tcondition">
               <div class="title e358">Conditionals</div>
               <div class="para e359">In some cases it is necessary to check for arbitrary conditions that cannot be expressed
                  directly by a pattern, e.g. for conditions that are not local like two values depending
                  on each other. For this we use an attribute 
                  <div class="code e360">t:condition</div>, which stores an XQuery expression that an input element has to satisfy in order
                  to be accepted as valid match, similarly to the expression contained in a filter expression.
                  The context item 
                  <div class="code e361">.</div> is set to the node currently checked for a match.  
               </div>
               <div class="para e362">
                  For example the pattern 
                  <div class="code e363">&lt;e t:condition="exists(@a) and @b eq ."/&gt;</div> matches 
                  <div class="code e364">&lt;e a="" b="1"&gt;1&lt;/e&gt;</div>, but neither 
                  <div class="code e365">&lt;e  b="1"&gt;1&lt;/e&gt;</div> nor 
                  <div class="code e366">&lt;e a="" b="1"&gt;2&lt;/e&gt;</div>.
                  
               </div>
               <div class="para e367">Another use of conditionals is to skip parts of the pattern. E.g. if you have two
                  data sources which are similar, but not identical, you might want to use the same
                  pattern for both, ignoring the parts of the pattern which only apply to the other
                  data source. 
                  This can be accomplished with the 
                  <div class="code e368">&lt;t:if&gt;</div> element, whose children are only matched, if the XQuery expression given in the 
                  <div class="code e369">test</div> attribute of the 
                  <div class="code e370">&lt;t:if&gt;</div> element evaluates to true. The context item 
                  <div class="code e371">.</div> is the previously matched element.
               </div>
               <div class="para e372"> For example 
                  <div class="code e373">&lt;x&gt;&lt;y&gt;{$y}&lt;/y&gt;&lt;t:if test="$y eq 17"&gt;&lt;z&gt;{$z}&lt;/z&gt;&lt;/t:if&gt;&lt;/x&gt;</div> matched against 
                  <div class="code e374">&lt;x&gt;&lt;y&gt;1&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</div> returns 
                  <div class="code e375">$x := &lt;y&gt;1&lt;/y&gt;</div> and matched against 
                  <div class="code e376">&lt;x&gt;&lt;y&gt;17&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</div>, it returns 
                  <div class="code e377">$x := &lt;y&gt;17&lt;/y&gt;, $y := &lt;z&gt;2&lt;/z&gt;</div>.
               </div>
               <div class="para e378">Most languages support an 
                  <div class="code e379">else</div> statement to be used  with their 
                  <div class="code e380">if</div> statement, so we added a similar 
                  <div class="code e381">&lt;t:else/&gt;</div>-element to the pattern syntax. The children of a 
                  <div class="code e382">&lt;t:else/&gt;</div> element are only matched, if the children of the preceding 
                  <div class="code e383">&lt;t:if/&gt;</div> element were ignored. 
                  For example 
                  <div class="code e384">&lt;root&gt;&lt;t:if test="$check"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;/t:if&gt;&lt;t:else&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:else&gt;&lt;/root&gt;</div> matched against 
                  <div class="code e385">&lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;/root&gt;</div> returns 
                  <div class="code e386">&lt;a&gt;1&lt;/a&gt;</div>, if 
                  <div class="code e387">$check</div> is true, and 
                  <div class="code e388">&lt;b&gt;2&lt;/b&gt;</div> otherwise. 
               </div>
               <div class="para e389">If the 
                  <div class="code e390">&lt;t:if&gt;</div> element is used to give a condition for a single element, it is quite cumbersome
                  to surround just that element with 
                  <div class="code e391">&lt;t:if&gt;..&lt;/t:if&gt;</div>. Therefore we allow the 
                  <div class="code e392">t:test</div> attribute being used directly on elements, as abbreviation for a surrounding 
                  <div class="code e393">&lt;t:if&gt;</div>. E.g. 
                  <div class="code e394">&lt;a t:test="$check"/&gt;</div> is equivalent to 
                  <div class="code e395">&lt;t:if t:test="$check"&gt;&lt;a/&gt;&lt;/t:if&gt;</div> and  ignored if 
                  <div class="code e396">$check</div> is 
                  <div class="code e397">false</div>. 
               </div>
               <div class="para e398"> 
                  <div class="code e399">t:test</div> might be confused with 
                  <div class="code e400">t:condition</div> by someone just seeing a pattern without having read this paper. but they are very
                  different from each other. 
                  <div class="code e401">t:test</div> is a condition the element in the pattern (given the previous variables) has to satisfy,
                  is checked (at most once, outside t:loop) before a match for this element is searched
                  and only a positive return value can lead to a matching error. 
                  <div class="code e402">t:condition</div> is a condition the element in the input data has to satisfy, might be checked for
                  every element in the input data, and only a negative return value can lead to a matching
                  error. 
               </div>
            </div><a name="AlternativeelementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e403" xml:id="para_unordered">
               <div class="title e404">Alternative elements</div>
               <div class="para e405">Sometimes different  elements may occur in the input data and should be accepted as
                  matches, but it is not known a priori which one actually exists.
                  It would be possible to handle this with optional elements and conditions, but that
                  would be cumbersome. 
                  Instead the patterns  support a 
                  <div class="code e406">&lt;t:switch&gt;</div> element, which contains different alternative patterns, i.e. it matches an element
                  in the input successfully, if any of its children match that element successfully.
                  
               </div>
               <div class="para e407">For example 
                  <div class="code e408">&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</div> applied to either 
                  <div class="code e409">&lt;a&gt;1&lt;/a&gt;</div> or  
                  <div class="code e410">&lt;b&gt;1&lt;/b&gt;</div> will return the input node (with value 1). 
               </div>
               <div class="para e411">There occurs a strange effect, if all the children exist as elements in the input
                  data,  but in a different order, like 
                  <div class="code e412">&lt;root&gt;&lt;x&gt;&lt;b&gt;B&lt;/b&gt;&lt;/x&gt;&lt;a&gt;A&lt;/a&gt;&lt;/root&gt;</div> for the previous example. The 
                  <div class="code e413">&lt;t:switch/&gt;</div> element as described so far would return the b-element, because 
                  <div class="code e414">&lt;t:switch/&gt;</div> is first matched against 
                  <div class="code e415">&lt;root&gt;</div> and 
                  <div class="code e416">&lt;x&gt;</div>, which are not accepted by any of its children, and then against 
                  <div class="code e417">&lt;b&gt;</div>, which is matched by the second child. So   
                  <div class="code e418">&lt;t:switch&gt;</div> always chooses the first matching element in the input.
               </div>
               <div class="para e419">However, it has turned out that we usually want the element matching the earliest
                  child that has a match, when we combine multiple patterns into a single one. So we
                  have added an attribute 
                  <div class="code e420">prioritized</div>, which enables "prioritized" matching, i.e. performing the matching of the children
                  in order and accepting the first match of the earliest child. E.g. 
                  <div class="code e421">&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</div> would return the a-element when matched against the previous  example input document.
                  
               </div>
               <div class="para e422">Another interesting use of the 
                  <div class="code e423">&lt;t:switch&gt;</div> element is to perform unordered matching, when combined with a loop. For example
                  
                  <div class="code e424">&lt;t:loop&gt;&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;&lt;/t:loop&gt;</div> returns all  (not nested) 
                  <div class="code e425">&lt;a/&gt;</div> and 
                  <div class="code e426">&lt;b/&gt;</div> nodes of the input document. So applied to the example input above it returns 
                  <div class="code e427">&lt;b&gt;B&lt;/b&gt;</div> and 
                  <div class="code e428">&lt;a&gt;A&lt;/a&gt;</div>. (without the loop and switch, it would raise a matching error due to the different
                  order). This occurs automatically, without handling this case in an implementation,
                  since the switch-element is matched against every element in the input.  
               </div>
               <div class="para e429">A possible abbreviation for a 
                  <div class="code e430">&lt;t:switch&gt;</div> element could be the regex inspired 
                  <div class="code e431">(&lt;a&gt;{.}&lt;/a&gt;|&lt;b&gt;{.}&lt;/b&gt;)</div>. We have, however, not implemented this, because a regex is allowed to start with
                  a 
                  <div class="code e432">|</div> (matching an empty string), so it might not be clear, if a switch abbreviation or
                  a regex for text node matching is meant.
               </div>
            </div><a name="DefaultoptionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e433" xml:id="tmeta">
               <div class="title e434">Default options</div>
               <div class="para e435">The way string values are matched can be changed with the 
                  <div class="code e436">&lt;t:meta/&gt;</div>-element, which sets the comparison function and case-sensitiveness for text nodes
                  and attributes:
                  
                  <div class="programlisting e437" xml:space="preserve">&lt;t:meta [text-matching="eq|matches|starts-with|ends-with|contains|list-contains"]
                     
                     [text-case-sensitive="true|false"] 
                     [attribute-matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
                     [attribute-case-sensitive="true|false"] /&gt;
                  </div>      
                  
               </div>
               <div class="para e438">
                  For example 
                  <div class="code e439">&lt;t:meta text-case-sensitive="false"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</div> matches 
                  <div class="code e440">&lt;a&gt;foobar&lt;/a&gt;</div> and 
                  <div class="code e441">&lt;a&gt;FOOBAR&lt;/a&gt;</div>, while 
                  <div class="code e442">&lt;t:meta text-case-sensitive="true"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</div> matches only former input.
                  
               </div>
               <div class="para e443">For individual attributes the string value matching can be controlled with the 
                  <div class="code e444">&lt;t:meta-attribute/&gt;</div>-element:
                  
                  <div class="programlisting e445" xml:space="preserve">&lt;t:meta-attribute 
                     name="..."
                     [matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
                     [case-sensitive="true|false"] /&gt;
                  </div>      
                  
               </div>
               <div class="para e446">
                  For example 
                  <div class="code e447">&lt;t:meta-attribute name="x" case-sensitive="false"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</div> matches 
                  <div class="code e448">&lt;a x="y"/&gt;</div> and 
                  <div class="code e449">&lt;a x="Y"/&gt;</div>, while 
                  <div class="code e450">&lt;t:meta-attribute name="x" case-sensitive="true"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</div> matches only former input.
                  
               </div>
               <div class="para e451">A meta element changes the options for all its children, and, if it does not have
                  children, for all following elements due to legacy reasons.
               </div>
            </div>
         </div><a name="MatchingJSONiqANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e452">
            <div class="title e453">Matching JSONiq</div>
            <div class="para e454">After having specified a pattern syntax for XML data, it appears reasonable to extend
               it to other data storage formats, like JSON. Recently a JSON-query language called
               JSONiq [
               <div class="xref e455" linkend="jsoniq"></div>] was announced as extension to XQuery, which we have implemented and plan to extend
               with pattern matching. 
            </div>
            <div class="para e456">To perform pattern matching on JSONiq types, we need to define the matching process
               for all new types added by JSONiq: 
               <div class="code e457">null</div>, objects and arrays
               <div class="popupBox e458">
                  <div class="popupLabel" onmouseover="$('#d1e1203').show('1000');" onmouseout="$('#d1e1203').hide('1000');">[ footnote ]</div>
                  <div id="d1e1203" style="display: none;">
                     <div class="footnote">
                        <div class="para e459">This section is purely theoretical, we have never used JSONiq matching in any practical
                           application.
                        </div>
                     </div>
                  </div>
               </div>. As well as for the standard atomic XQuery types derived from 
               <div class="code e460">xs:anyAtomicType</div>, because the previous sections only defined the matching for nodes.
            </div>
            <div class="para e461">
               A small problem is that none of the JSONiq types support namespaces, so we cannot
               do advanced matching with a 
               <div class="code e462">t:</div> prefix, like in the XML case, not even to include selector expressions. However,
               the important JSONiq types, arrays and objects, can contain XML nodes, so we can wrap
               the selector expressions in 
               <div class="code e463">&lt;t:s/&gt;</div>-elements and include them like that in the JSONiq item. 
               
            </div>
            <div class="itemizedlist e464">
               <div class="listitem e465">
                  <div class="para e466">
                     Defining a natural matching for 
                     <div class="emphasis e467">atomic types and 
                        <div class="code e468">null</div>
                     </div> is easy: These values matches another value, if the 
                     <div class="code e469">eq</div>-operator returns true. Due to the definition of the equality of 
                     <div class="code e470">null</div> in JSONiq, it follows 
                     <div class="code e471">null</div> matches 
                     <div class="code e472">null</div> and nothing else.
                     
                  </div>
               </div>
               <div class="listitem e473">
                  <div class="para e474">
                     An 
                     <div class="emphasis e475">object</div> pattern matches a value, if that value is an object and the value of every property
                     of the pattern matches the value of the corresponding property of the value. 
                     
                  </div>
               </div>
               <div class="listitem e476">
                  <div class="para e477">      
                     
                     
                     For arrays there are three reasonable ways to define array matching: An array pattern
                     
                     <div class="code e478">$a</div> matches an  value 
                     <div class="code e479">$b</div>, if 
                     
                     <div class="itemizedlist e480">
                        <div class="listitem e481">
                           <div class="para e482"> 
                              <div class="emphasis e483">Exact matching</div>:  element 
                              <div class="code e484">$a[$i]</div> matches 
                              <div class="code e485">$b[$i]</div> for all 
                              <div class="code e486">$i in 1 to jn:size($a)</div>, and 
                              <div class="code e487">$a</div> and 
                              <div class="code e488">$b</div> have the same number of elements. 
                           </div>
                        </div>
                        <div class="listitem e489">
                           <div class="para e490">
                              <div class="emphasis e491">Exact prefix matching</div>: element 
                              <div class="code e492">$a[$i]</div> matches 
                              <div class="code e493">$b[$i]</div> for all 
                              <div class="code e494">$i in 1 to jn:size($a)</div>. I.e. after the exactly matched beginning of the array 
                              <div class="code e495">$b</div>  there might follow arbitrary other elements.
                           </div>
                        </div>
                        <div class="listitem e496">
                           <div class="para e497">
                              <div class="emphasis e498">Existence matching</div>: element 
                              <div class="code e499">$a[$i]</div> matches an 
                              <div class="code e500">$b[$j($i)]</div>, such that $j($i) &lt; $j($i+1),  for all 
                              <div class="code e501">$i in 1 to jn:size($a)</div>. I.e. every element of $a can be matched, but there might be arbitrary many elements
                              between each match.
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="para e502">Each way represents a different compromise between the goal 2 (validation) and goal
                     3 (minimality). We have decided to use the last way, giving priority to minimality
                     <div class="popupBox e503">
                        <div class="popupLabel" onmouseover="$('#d1e1314').show('1000');" onmouseout="$('#d1e1314').hide('1000');">[ footnote ]</div>
                        <div id="d1e1314" style="display: none;">
                           <div class="footnote">
                              <div class="para e504">Sequences could be handled similar to arrays, but we will not consider sequences here,
                                 since they do not occur as such in input data.
                              </div>
                           </div>
                        </div>
                     </div>.
                  </div>
               </div>
            </div>
            <div class="para e505">An example of a pattern according to above definitions is 
               
               <div class="programlisting e506" xml:space="preserve">{"a": [1,2,3], "b": null, "c": &lt;t:s&gt;{.}&lt;/t:s&gt;}</div>
               which matches 
               
               <div class="programlisting e507" xml:space="preserve">{"a": [1,2,3], "b": null, "c": "foobar"}</div>
               returning 
               <div class="code e508">foobar</div>
               or 
               
               <div class="programlisting e509" xml:space="preserve">{"a": [1,"u",2,"v",3], "b": null, "c": [7,8,9], "d": 17}</div>
               returning 
               <div class="code e510">[7,8,9]</div>.
               
            </div>
            <div class="para e511">
               But it matches neither 
               
               <div class="programlisting e512" xml:space="preserve">{"a": [1,2,3], "b": [4,5], "c": "xyz"}</div>
               nor 
               
               <div class="programlisting e513" xml:space="preserve">{"a": [1,2,3], "c": "foobar"}</div>
               
            </div>
            <div class="para e514">Since writing 
               <div class="code e515">&lt;t:s/&gt;</div> is extremely cumbersome in a JSONiq pattern, it might be beneficial to allow abbreviations
               like 
               <div class="code e516">{"c": .}</div>, 
               <div class="code e517">{"c": $result}</div> or 
               <div class="code e518">{"c": $result := .}</div> in an implementation, in which the 
               <div class="code e519">&lt;t:s&gt;</div> is omitted. This syntax is mostly unambiguous, however it cannot be evaluated and
               stored as JSONiq type. Therefore, such an implementation must be able to partially
               evaluate JSONiq types, keeping it in AST form or serializing the XQuery-AST back to
               a reparsable query wrapped in 
               <div class="code e520">&lt;t:s&gt;</div>. Another alternative might be to use inline functions instead 
               <div class="code e521">&lt;t:s&gt;</div>, e.g 
               <div class="code e522">function(){$result := .}</div> replacing 
               <div class="code e523">&lt;t:s&gt;$result := . &lt;/t:s&gt;</div>, in which case no serialization of XQuery expressions is needed. But we will not
               consider such  extensions in the remaining paper. 
            </div>
         </div>
      </div><a name="TheintegrationinXQueryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e524" xml:id="integration">
         <div class="title e525">The integration in XQuery</div><a name="AsfunctionwithoutsyntaxmodificationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e526">
            <div class="title e527">As function, without syntax modification</div>
            <div class="para e528">Since every pattern is a valid XML element (or JSONiq item), it  can be represented by valid values in the XQuery type schema, and it is possible
               to write a matching function that takes a pattern and input data as arguments and
               performs the matching in standard XQuery (or JSONiq). Such a function is useful to
               perform pattern matching in existing XQuery implementations without having to write
               a new implementation.
            </div>
            <div class="para e529"> To use the full power of selector expressions within a patten, the underlying implementation
               has to support some kind of 
               <div class="code e530">eval</div> function to evaluate an XQuery given as string. And of course, only the right-hand-side
               of 
               <div class="code e531">:=</div> assignment can be passed to the 
               <div class="code e532">eval</div>-function and the variable names have to be tracked separately. 
            </div>
            <div class="para e533">The type declaration of our matching function is:
               <div class="popupBox e534">
                  <div class="popupLabel" onmouseover="$('#d1e1399').show('1000');" onmouseout="$('#d1e1399').hide('1000');">[ footnote ]</div>
                  <div id="d1e1399" style="display: none;">
                     <div class="footnote">
                        <div class="para e535">The prefix 
                           <div class="code e536">pxp</div> can be considered an abbreviation of "Pascal XQuery Project", another name of our
                           XQuery implementation. Although the function 
                           <div class="code e537">pxp:match</div> exists in our implementation it is there not written in XQuery and depends on our
                           own special features. 
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="programlisting e538" xml:space="preserve">pxp:match($pattern as item(), data as item()*) as item()*</div>
            <div class="para e539">The first argument is the pattern that is matched against every item in the 
               <div class="code e540">$data</div> sequence, thereby creating multiple assignment streams which are concatenated. Since
               
               <div class="code e541">$pattern</div> is an ordinary value, the 
               <div class="code e542">{...}</div> selector expressions have to be encoded as 
               <div class="code e543">{{...}}</div>, if the pattern is created within the query by an element constructor.  
            </div>
            <div class="para e544">In theory, the function should return the final assignment stream, but an assignment
               stream is not a valid XDM instance. So we wrap the result in an XQuery map which maps
               variable names to a sequence of values and which can be read like a function call.
               For example the map 
               <div class="code e545">$map := {"foo": "bar", "x": ("y", "z")}</div> contains two keys which can be accessed with 
               <div class="code e546">$map("foo") = "bar"</div> and 
               <div class="code e547">$map("x") = ("y", "z")</div>. In modern XQuery such a map can be implemented as an anonymous function that returns
               a certain value if called with the corresponding key.  A theoretical alternative to
               a map is to wrap the data in an XML element, however, that would destroy information
               like the parents of the returned items
               <div class="popupBox e548">
                  <div class="popupLabel" onmouseover="$('#d1e1435').show('1000');" onmouseout="$('#d1e1435').hide('1000');">[ footnote ]</div>
                  <div id="d1e1435" style="display: none;">
                     <div class="footnote">
                        <div class="para e549">For the same reason we are talking about a "map" instead of a JSONiq "object". A standard
                           JSONiq object would contain copies of the XML elements and therefore  lose the parent
                           relationships as well.
                        </div>
                     </div>
                  </div>
               </div>.    
            </div>
            <div class="para e550">Since sequences cannot nest, assignments of sequences to variables are flattened in
               the returned sequence. e.g. the assignment stream 
               <div class="code e551">$a = (1, 2), $a = 3, $a = 4</div> becomes a single sequence in the map 
               <div class="code e552">{"a": (1,2,3,4)}</div>. If the only assigment is to the default variable, we do not wrap it in a map and
               return the value directly. 
            </div>
            <div class="para e553">For example
               
               
               <div class="programlisting e554" xml:space="preserve">pxp:match(&lt;root&gt;&lt;foo&gt;{{.}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</div>
               
               has internally the assigment stream
               
               
               <div class="programlisting e555" xml:space="preserve">. = &lt;foo&gt;1&lt;/foo&gt;
                  . = &lt;foo&gt;2&lt;/foo&gt;
                  
               </div>
               
               and returns 
               
               
               <div class="programlisting e556" xml:space="preserve">(&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;)</div>
            </div>
            <div class="para e557">Another example with variables is 
               <div class="programlisting e558" xml:space="preserve">pxp:match(&lt;root attrib="{{$attrib}}"&gt;&lt;foo&gt;{{$var}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root attrib="ABC"&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</div>
               which has the assigment stream
               
               <div class="programlisting e559" xml:space="preserve">$attrib = "ABC"
                  $var = &lt;foo&gt;1&lt;/foo&gt;
                  $var = &lt;foo&gt;2&lt;/foo&gt;
                  
               </div>
               and returns
               
               <div class="programlisting e560" xml:space="preserve">{"attrib": "ABC", "var": (&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;) }</div>
            </div>
         </div><a name="ExtendingSwitchExpressionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e561">
            <div class="title e562">Extending Switch-Expressions</div>
            <div class="para e563">The natural way to extend the 
               <div class="code e564">switch</div>-expression with pattern matching seems to allow patterns as operands of 
               <div class="code e565">case</div> clauses, like 
               <div class="code e566">case &lt;element&gt; ...the pattern... &lt;/element&gt; return ... </div>. However, this is already a valid XQuery syntax, denoting the atomization of the
               case operand to the string value 
               <div class="code e567">...the pattern...</div> and comparing that value to the input. So the 
               <div class="code e568">case</div>-clause cannot be used and we have to add a new keyword 
               <div class="code e569">match</div> that has a pattern as operand. The formal grammar of this new 
               <div class="code e570">switch</div>-expression is then: 
            </div>
            <div class="programlisting e571" xml:space="preserve">SwitchCaseClause    ::=  ("case" SwitchCaseOperand | "match" SwitchMatchOperand)+
               "return" ExprSingle
               SwitchMatchOperand  ::=  PatternExpr
            </div>
            <div class="para e572">A pattern given to 
               <div class="code e573">match</div> will not be evaluated, before the matching.  So writing 
               <div class="code e574">&lt;x&gt;{$y}&lt;/x&gt;</div> is sufficient for a pattern that assigns  
               <div class="code e575">&lt;x/&gt;</div> to 
               <div class="code e576">$y</div> and it does 
               <div class="emphasis e577">not</div> have to be encoded as 
               <div class="code e578">&lt;x&gt;{{$y}}&lt;/x&gt;</div>.  So the variables that could be created by the pattern are statically known, and
               can be added to the static context of the expression in the corresponding return clause.
               
            </div>
            <div class="para e579">We define 
               <div class="code e580">PatternExpr</div> to be either an XML pattern with optional loop marker (e.g. 
               <div class="code e581">+</div>) or a JSONiq constructor: 
            </div>
            <div class="programlisting e582" xml:space="preserve">LoopIndicator   := OccurrenceIndicator | "{" Digits "}" | "{" Digits "," Digits "}"
               
               PatternExpr     := DirectConstructor LoopIndicator? | ObjectConstructor | ArrayConstructor
               
            </div>
            <div class="para e583">This syntactical definition is broader than the semantically allowed values (e.g.
               function calls would not be allowed), so some expressions are rejected during evaluation.
               
            </div>
            <div class="para e584">
               The switch expression is then evaluated as follows:
            </div>
            <div class="para e585">
               All 
               <div class="code e586">case</div> and 
               <div class="code e587">match</div> clauses are processed in order.
               
               <div class="itemizedlist e588">
                  <div class="listitem e589">
                     <div class="para e590">If a 
                        <div class="code e591">case</div> clause is meet, it is "matched" like in standard XQuery.
                     </div>
                  </div>
                  <div class="listitem e592">
                     <div class="para e593">If a 
                        <div class="code e594">match</div> clause is meet, its pattern is matched against the input as described in the previous
                        sections.
                        
                        <div class="itemizedlist e595">
                           <div class="listitem e596">
                              <div class="para e597">If a matching error occurs, this clause is skipped (the error is not propagated upwards).
                                 
                              </div>
                           </div>
                           <div class="listitem e598">
                              <div class="para e599">If the matching succeeds, the value of the switch expression is the value of the current
                                 return expression.
                                 All variables that were created by the pattern are available in the evaluation of
                                 the return expression and, if a value was assigned to the default variable, it replaces
                                 the context item. 
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e600">So for example, either
               
               
               <div class="programlisting e601" xml:space="preserve">switch (&lt;y&gt;123&lt;/y&gt;) 
                  match &lt;x&gt;{$data}&lt;/x&gt; return "The x-data is " || $data
                  match &lt;y&gt;{$data}&lt;/y&gt; return "The y-data is " || $data
                  default return "foo"
               </div>
               
               or
               
               
               <div class="programlisting e602" xml:space="preserve">switch (&lt;y&gt;123&lt;/y&gt;) 
                  match &lt;x&gt;{.}&lt;/x&gt; return "The x-data is " || .
                  match &lt;y&gt;{.}&lt;/y&gt; return "The y-data is " || .
                  default return "foo"
               </div>      
               
               
               will return 
               <div class="code e603">The y-data is 123</div>.
            </div>
            <div class="para e604"> 
               If multiple values have been added to a single variable by the pattern, like in 
               <div class="code e605">&lt;x&gt;{$var}&lt;/x&gt;+</div> they are all flattened to a variable containing a sequence. However, if the assignment
               was to the context item, an exception is thrown, since 
               <div class="code e606">.</div> cannot be a sequence.
               
            </div>
            <div class="para e607">So we could use the following example to count all links on a webpage:
               
               <div class="programlisting e608" xml:space="preserve">switch ($inputdata) 
                  match &lt;a&gt;{$a}&lt;/a&gt;+ return "There are " || count($a) || " links on the webpage"
                  match &lt;html/&gt; return "There are no links on the webpage"
                  default return "Invalid input"
               </div>      
            </div>
         </div><a name="ExtendingFlowersANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e609">
            <div class="title e610">Extending Flowers</div>
            <div class="para e611">
               Before we can extend the flower expressions, we need to extend the tuple stream, so
               it behaves more like an assignment stream.
               In XQuery implementations this stream assigns certain values to certain variables.
               Since our patterns also allow assignments to a default variable with 
               <div class="code e612">{.}</div> which is then mapped to the context item 
               <div class="code e613">.</div>, the tuple stream has to be able to not only store normal variables, but also this
               default variable. We will write such assignments
               
               <div class="programlisting e614" xml:space="preserve">(. = 1)
                  (. = 2)
               </div>
               in this paper.
               
            </div>
            <div class="para e615">
               We then could write 
               <div class="code e616">for . in $sequence return expression ...</div> meaning the same as 
               <div class="code e617">$sequence ! expression ...</div> or 
               <div class="code e618">let . := $value return expression</div> meaning the same as 
               <div class="code e619">exactly-one($value) ! expression ...</div> in a query
               <div class="popupBox e620">
                  <div class="popupLabel" onmouseover="$('#d1e1618').show('1000');" onmouseout="$('#d1e1618').hide('1000');">[ footnote ]</div>
                  <div id="d1e1618" style="display: none;">
                     <div class="footnote">
                        <div class="para e621">Actually our current parser rejects these expressions, but they would be natural extensions.</div>
                     </div>
                  </div>
               </div>. 
               
            </div><a name="ExtendingletANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e622">
               <div class="title e623">Extending let</div>
               <div class="para e624">We extend the 
                  <div class="code e625">let</div>-expression by  allowing patterns to be used as binding variable, i.e. by adding a
                  
                  <div class="code e626">MatchLetClause</div> to the 
                  <div class="code e627">InitialClause</div>-EBNF defined as follows:
                  
                  <div class="programlisting e628" xml:space="preserve">MatchLetClause         ::=    	"let" PatternLetBinding ("," PatternLetBinding)*  
                     
                     LetBinding             ::=    	PatternExpr ":=" ExprSingle
                  </div>
               </div>
               <div class="para e629">During evaluation this pattern is matched against the right-hand-side of 
                  <div class="code e630">:=</div> and the resulting variables are added to the tuple stream, so they can be used just
                  like in the 
                  <div class="code e631">return</div> clause of an extended 
                  <div class="code e632">switch</div>-expression.
               </div>
               <div class="para e633">For example
                  
                  <div class="programlisting e634" xml:space="preserve">let &lt;a&gt;{.}&lt;/a&gt; := &lt;root&gt;&lt;a&gt;123&lt;/a&gt;&lt;/root&gt; return .</div>
                  will create a tuple stream
                  
                  <div class="programlisting e635" xml:space="preserve">(. = &lt;a&gt;123&lt;/a&gt;)
                     
                  </div>
                  and therefore return 
                  <div class="code e636">&lt;a&gt;123&lt;/a&gt;.</div>
               </div>
               <div class="para e637">As mentioned when extending the 
                  <div class="code e638">switch</div>-expression, multiple assignments will be flattened to a sequence. E.g. 
                  <div class="code e639">let &lt;a&gt;{$a}&lt;/a&gt;* := &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt;</div> creates the tuple stream 
                  <div class="code e640">($a = (&lt;a&gt;1&lt;/a&gt;, &lt;a&gt;2&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;))</div>.
               </div>
               <div class="para e641">The practical usage of such an expression is to validate that (schema-less) data has
                  a certain structure, without creating a new XML schema or using a lot of if-expressions.
                  E.g. 
                  <div class="code e642">let &lt;xml&gt;&lt;a&gt;{$a}/&lt;a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;c&gt;{$c}&lt;/c&gt;&lt;/xml&gt; := &lt;xml&gt;&lt;a&gt;{123}/&lt;a&gt;&lt;b&gt;{456}&lt;/b&gt;&lt;c&gt;{789}&lt;/c&gt;&lt;/xml&gt;
                     return ($a, $b, $c)
                  </div> queries the three elements and throws an exception, if they do not occur or have
                  a different order. 
               </div>
            </div><a name="ExtendingforANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e643">
               <div class="title e644">Extending for</div>
               <div class="para e645">Similar to the let-expression we extend the for-expression by allowing a pattern as
                  binding variable. Hence we add a new initial clause 
                  <div class="code e646">MatchForClause</div>:
                  
                  <div class="programlisting e647" xml:space="preserve">MatchForClause         ::=    	"for" PatternForBinding ("," PatternForBinding)*
                     PatternForBinding      ::=    	PatternExpr "in" ExprSingle
                  </div>
               </div>
               <div class="para e648">During evaluation, this pattern is matched against the right-hand-side of 
                  <div class="code e649">in</div> similar to the evaluation of the extended 
                  <div class="code e650">let</div>. However, this  time the resulting variables are not directly added to the tuple
                  stream. Instead each assignment within the pattern creates a new row in the stream,
                  in which only the currently assigned variable has a value. This also means that a
                  sequence assigned to a variable is not flattened. 
               </div>
               <div class="para e651">
                  For example
                  
                  <div class="programlisting e652" xml:space="preserve">for &lt;a&gt;{.}&lt;/a&gt;+ in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt; return .</div>
                  will create the tuple stream
                  
                  <div class="programlisting e653" xml:space="preserve">(. = &lt;a&gt;1&lt;/a&gt;)
                     (. = &lt;a&gt;2&lt;/a&gt;)
                     (. = &lt;a&gt;3&lt;/a&gt;)
                  </div>
                  and return every a-element.
                  
               </div>
               <div class="para e654">
                  And
                  
                  <div class="programlisting e655" xml:space="preserve">for  &lt;html&gt;&lt;h2&gt;Title A&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Title B&lt;/h2&gt;&lt;/html&gt; in $input-data return
                     .
                  </div>
                  will return all paragraphs between 
                  <div class="code e656">Title A</div> and 
                  <div class="code e657">Title B</div>, a natural appearing query that would be complicated to express with standard XPath.
                  
               </div>
               <div class="para e658">When multiple variables are used in the pattern, they all occur in the tuple stream,
                  but only one is non-empty. For example:
                  
                  <div class="programlisting e659" xml:space="preserve">for &lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;a&gt;{$a := (., .)}&lt;/a&gt;&lt;/root&gt; in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt;
                     return .
                  </div>
                  results in the tuple stream
                  
                  <div class="programlisting e660" xml:space="preserve">($a = &lt;a&gt;1&lt;/a&gt;,             $b = ()),
                     ($a = (),                   $b = &lt;b&gt;2&lt;/b&gt;)
                     ($a = (&lt;a&gt;3&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;), $b = ())
                     
                  </div>
                  
                  
               </div>
               <div class="para e661">Combinations of 
                  <div class="code e662">let</div> and 
                  <div class="code e663">for</div> as well as the intermediate clauses can be used as usually, since they change the
                  tuple stream in a certain way, independent of the source of that tuple stream.
               </div>
            </div>
         </div>
      </div><a name="UsingpatternmatchingfordataminingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e664">
         <div class="title e665">Using pattern matching for data mining</div>
         <div class="para e666">In this section we summarize our experiences and observed issues when applying the
            pattern matching to perform data mining from various webpages, which is, in fact,
            the purpose the patterns were designed for.  
         </div>
         <div class="para e667">The webpages in question are the 
              catalogs of over 175 different libraries which were using 14 different library systems
            with, in total, around 100 individual HTML pages. We have created a pattern for each
            of these 100 pages, ranging from querying  all the data on the page to querying a
            single link. With these patterns we mirror the entire functionality of the catalog,
            like searching for books, getting detailed bibliography data, ordering them for lending,
            showing the items lend by a patron, renewing loans...  A list of these libraries is
            available on the 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e668" xlink:actuate="onRequest" xlink:href="http://videlibri.sourceforge.net/#libraries" xlink:show="new" xlink:type="simple">German VideLibri webpage</div> and the patterns itself can be found in its 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e669" xlink:actuate="onRequest" xlink:href="http://sourceforge.net/p/videlibri/code/ci/trunks/tree/programs/internet/VideLibri/data/libraries/templates/" xlink:show="new" xlink:type="simple">source repository</div>.
            
         </div>
         <div class="para e670">
            	    We have observed the following positive aspects when applying the pattern matching:
            	    
            <div class="itemizedlist e671">
               <div class="listitem e672">
                  <div class="para e673">The patterns have vastly simplified the task of mining data from a new webpage. As
                     mentioned above a pattern "can be created by copying the input data, completely removing
                     all data that should not be queried for, replacing the remaining data with annotations
                     and finally calling it a pattern", so we can add a new webpage in a few minutes
                     <div class="popupBox e674">
                        <div class="popupLabel" onmouseover="$('#d1e1755').show('1000');" onmouseout="$('#d1e1755').hide('1000');">[ footnote ]</div>
                        <div id="d1e1755" style="display: none;">
                           <div class="footnote">
                              <div class="para e675">Outside the scope of this paper, we have simplified this creation process even further
                                 by developing a script that can create a pattern for a HTML file, by just selecting
                                 the relevant data with the mouse in Firefox.
                              </div>
                           </div>
                        </div>
                     </div> and an entire new library system in an hour (up to corner cases/bugs that only appear
                     after months of testing).
                  </div>
               </div>
               <div class="listitem e676">
                  <div class="para e677">A more concise point is that the pattern is useful for "grounding" an XQuery expression.
                     If we use path expressions to query data from the same element, we either have to
                     prefix each expression with 
                     <div class="code e678">//all/ancestors/of/that/element/</div> (pointless redundancy) or create a new variable 
                     <div class="code e679">$var := //all/ancestors/of/that/element/</div> and prefix 
                     <div class="code e680">$var</div>  instead (many variables to name and keep track of). With patterns we create just
                     one element 
                     <div class="code e681">&lt;all&gt;&lt;ancestors&gt;&lt;of&gt;&lt;that&gt;&lt;element&gt;{...}&lt;/element&gt;&lt;/that&gt;&lt;/of&gt;&lt;/ancestors&gt;&lt;/all&gt;</div> (or copy it from the webpage) and all expressions inside that element are relative
                     to it. This is especially helpful, if there are additional expressions with  partial
                     identical ancestors like,  
                     <div class="code e682">//all/ancestors/of/that/element/foo/bar</div> and 
                     <div class="code e683">//all/ancestors/of/x/y/z</div>. The patterns make it obvious how they are related to each other and in which order
                     they occur on the webpage, the path expression not so much. 
                  </div>
               </div>
               <div class="listitem e684">
                  <div class="para e685">It is very easy to query for elements surrounded by certain siblings like 
                     <div class="code e686">&lt;root&gt;&lt;pre-sibling/&gt;&lt;elements/&gt;+&lt;post-sibling/&gt;&lt;/root&gt;</div> or more specific 
                     <div class="code e687">&lt;root&gt;&lt;h2&gt;Header 1&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Header 2&lt;/h2&gt;&lt;/root&gt;</div>, which often occurs on webpages and is not easy in pure XPath.
                  </div>
               </div>
               <div class="listitem e688">
                  <div class="para e689">Many people prefer to CSS selectors instead XPath/XQuery expressions, because they
                     are better suited to process HTML, e.g. when querying for classes and ids, although
                     those selectors cannot process the selected data. Our patterns are as easy to use
                     as CSS selectors (especially due to special handling of 
                     <div class="code e690">class</div> attributes) and provide a way to process the data with all the power of XQuery. 
                  </div>
               </div>
               <div class="listitem e691">
                  <div class="para e692">As expected the patterns are much shorter than queries in a non pattern based system.
                     We do not know how many lines our implementation would have required without patterns,
                     but we can compare it to another, independently developed, open-source project (using
                     Java and CSS selectors) that attempts to mine data from some of these pages.  For these pages, our pattern based implementation consists of 1641 lines (mostly
                     copied from the original pages), while the other project had to use 3362 lines (assumed
                     to be written manually).
                  </div>
               </div>
               <div class="listitem e693">
                  <div class="para e694">The patterns are easy to unit test. For this we keep an archive of all ever mined
                     webpages and match the corresponding pattern to each of them, testing if they still
                     return the same assignment stream.  This would be difficult to do for a bunch of path
                     expressions, since these expressions are embedded within a query and do not return
                     an assignment stream, so for every tested pattern there would be several path expressions
                     to test. 
                  </div>
               </div>
            </div>
            	    
         </div>
         <div class="para e695"> We can conclude that the mining task would have been much more difficult and taken
            much more time without our patterns
            <div class="popupBox e696">
               <div class="popupLabel" onmouseover="$('#d1e1809').show('1000');" onmouseout="$('#d1e1809').hide('1000');">[ footnote ]</div>
               <div id="d1e1809" style="display: none;">
                  <div class="footnote">
                     <div class="para e697">Although possibly not as much time, as we have spend developing a complete XQuery
                        engine to integrate the patterns.
                     </div>
                  </div>
               </div>
            </div>. 
         </div>
      </div><a name="FutherworkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e698">
         <div class="title e699">Futher work</div>
         <div class="para e700">Nevertheless the practical application has shown that the pattern are still  neither
            as easy and intuitive to use nor as powerful as we hoped.  The following list describes a few observed issues together with possible extensions
            that might solve them:
         </div>
         <div class="itemizedlist e701">
            <div class="listitem e702">
               <div class="para e703">Within loops the validating-property works against its purpose, such that too strongly
                  validating patterns in loops lead to skipped elements.
                  For example, you can use the following pattern to read the 2nd column of all rows
                  of a table that have an image in the first column: 
                  <div class="programlisting e704" xml:space="preserve">&lt;tr&gt;&lt;td&gt;&lt;img/&gt;&lt;/td&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+</div> 
                  But if (unexpectedly) a row does not contain an image
                  
                  <div class="programlisting e705" xml:space="preserve">&lt;table&gt;
                     &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;img unavailable&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
                     &lt;/table&gt;
                  </div>
                  it is skipped, because the row does not match, which can be surprising to someone
                  expecting either a correct matching of all rows or a matching error. 
               </div>
               <div class="para e706">In this example the issue is easily solved by marking the image as optional, either
                  with a following 
                  <div class="code e707">?</div> or the 
                  <div class="code e708">t:optional</div> attribute. However, someone creating the pattern has to remember to do that, and
                  needs to know that there might be no image. But when patterns are created based on
                  various samples from a webpage, we often do not know which elements are optional and
                  not.
               </div>
               <div class="para e709">We have considered two possible extensions to the pattern syntax, which could solve
                  the issue of skipped rows by requiring that all rows participate in the matching:
                  
                  
                  <div class="itemizedlist e710">
                     <div class="listitem e711">
                        <div class="para e712">An option that all children of a certain element have to be matched, if one of them
                           has been matched. (a 
                           <div class="code e713">++</div> qualifier might fit well) 
                        </div>
                     </div>
                     <div class="listitem e714">
                        <div class="para e715">An option that disables the recursive matching, when searching the next match for
                           a loop child, and only tests the loop child itself  (and perhaps its n-th  descendants
                           for a fixed n), if it would match an element (as if the loop child had no children
                           itself). If this first test succeeds, the recursive matching is performed to evaluate
                           the contained selector expressions as before, but if that recursive matching fails
                           then, the entire matching is aborted with a matching error. E.g. with this option,
                           a pattern like 
                           <div class="code e716">&lt;tr&gt;...&lt;/tr&gt;+</div> would first ignore the 
                           <div class="code e717">...</div> and just search the next 
                           <div class="code e718">tr</div>-element. Afterward the 
                           <div class="code e719">...</div> would be matched against that element as usual, propagating exceptions. 
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="listitem e720">
               <div class="para e721">There is no syntax to match or loop over table 
                  <div class="emphasis e722">columns</div>, instead rows. Although you can read the i-th column by prepending 
                  <div class="code e723">&lt;td/&gt;{i-1}</div> to skip the previous 
                  <div class="code e724">i-1</div> columns, it is quite difficult to create a pattern that matches the i-th column on
                  one page and the j-th column on another, or that handles different column orders on
                  different pages
                  <div class="popupBox e725">
                     <div class="popupLabel" onmouseover="$('#d1e1877').show('1000');" onmouseout="$('#d1e1877').hide('1000');">[ footnote ]</div>
                     <div id="d1e1877" style="display: none;">
                        <div class="footnote">
                           <div class="para e726">Former case can be solved with optional columns, later only with both cases being
                              included in the pattern as switchable subpatterns.
                           </div>
                        </div>
                     </div>
                  </div>. This issue stems from the hierarchical structure of SGML and is problematic in every
                  query language.
               </div>
               <div class="para e727">To solve it, a pattern syntax not based on a tree structure is required. Maybe it
                  is possible to add an option that connects the order of children of different elements
                  in the pattern. Then the first row of the pattern could match the header, unordered,
                  and the following rows were linked to the header row, such that the children are processed
                  in the same order the header elements were assigned to their matches. 
               </div>
            </div>
            <div class="listitem e728">
               <div class="para e729">Some pages use a table layout with many nested tables. In these cases the table, tr,
                  td-elements of a pattern that are supposed to match a single table might all match
                  
                  <div class="emphasis e730">different</div> tables. For example 
                  <div class="programlisting e731" xml:space="preserve">&lt;table&gt;
                     &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+
                     &lt;/table&gt;
                  </div> appears to be a good pattern to match all rows below a header row in a certain table.
                   However, if table layouts are used like in 
                  
                  <div class="programlisting e732" xml:space="preserve">&lt;table&gt;
                     &lt;tr&gt;&lt;td&gt;&lt;table&gt;
                     &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;
                     &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;bar&lt;/td&gt;&lt;/tr&gt;
                     &lt;/table&gt;
                  </div> the table-element matches the outer table (because it still contains a descendant
                  
                  <div class="code e733">Header</div> text node), and the pattern selects all rows of that table, i.e. the last td-element
                  containing 
                  <div class="code e734">bar</div>. And 
                  <div class="emphasis e735">not</div> the td-element containing 
                  <div class="code e736">foo</div>.
                  
               </div>
               <div class="para e737">A solution would be to add an option to only match direct children of certain elements,
                  instead all descendants. Perhaps even enable it at default for tables, although this
                  will cause new issues with table rows never being children of the table, but of a
                  tbody-element. 
               </div>
            </div>
            <div class="listitem e738">
               <div class="para e739">Despite our goal of minimality there is a lot of unnecessary redundancy in the pattern
                  syntax. For example a frequently used pattern to read properties of a book is
                  
                  <div class="programlisting e740" xml:space="preserve">&lt;table&gt;
                     &lt;tr&gt;&lt;td&gt;Author:&lt;/td&gt;   &lt;td&gt;{$book.author}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;Title:&lt;/td&gt;    &lt;td&gt;{$book.title}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;Publisher:&lt;/td&gt;&lt;td&gt;{$book.publisher}&lt;/td&gt;&lt;/tr&gt;
                     &lt;tr&gt;&lt;td&gt;Year:&lt;/td&gt;     &lt;td&gt;{$book.year}&lt;/td&gt;&lt;/tr&gt;
                     &lt;/table&gt;
                  </div> which contains many duplicated td and tr-elements. This is not a problem during the
                  creation of the pattern, but if it needs to adapted to changes (e.g. to read divs
                  instead tds or have the value in the third column) each tag has to updated, which
                  is pointless work.
               </div>
               <div class="para e741"> So perhaps some kind of "meta-pattern" needs be developed that can create a pattern
                  programmatically within the pattern itself, like a macro in C++ or a function with
                  access to the AST.   
               </div>
            </div>
            <div class="listitem e742">
               <div class="para e743">The validation property was not as useful as expected to find errors. We assumed that
                  an element throwing a matching error tells us, which element in the pattern was wrong/changed
                  and should be adapted. But although this works in patterns like 
                  <div class="code e744">&lt;a&gt;&lt;b&gt;&lt;c&gt;{.}&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</div>, where we can get a matching error for a, b or c and know which element is missing
                  in the input, in patterns containing multiple alternatives like  
                  <div class="code e745">&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}/b&gt;</div> we get a matching error for the t:switch expression and cannot distinguish if the
                  input was supposed to match a or b.
               </div>
               <div class="para e746">Therefore the error reporting has to somehow consider all possible pattern branches and report the error for the
                  most likely one.
               </div>
            </div>
            <div class="listitem e747">
               <div class="para e748">
                  Currently every pattern is represented by a valid XML file, which is useful for automatic
                  parsing/processing and familiarity.
                  However, the pattern syntax can be greatly simplified by allowing non-valid XML patterns.
                  The first possible extension in this direction is to allow regular expressions as
                  element and attribute names. A simple pattern like
                  
                  <div class="programlisting e749" xml:space="preserve">&lt;a|b|c foo|bar="123" x.z="17" /&gt;</div>
                  could then replace this more complex, but equivalent pattern:
                  
                  <div class="programlisting e750" xml:space="preserve">&lt;t:switch&gt;
                     &lt;a foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;a bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;b foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;b bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;c foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;c bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
                     &lt;/t:switch&gt;
                  </div>
                  
               </div>
               <div class="para e751">      
                  The second extension is to allow other attribute value separators than the 
                  <div class="code e752">=</div> sign which would specify the matching mode used for the string value. 
                  
                  E.g. the symbols 
                  <div class="code e753">==</div>, 
                  <div class="code e754">~=</div>, 
                  <div class="code e755">^=</div>, 
                  <div class="code e756">$=</div>, 
                  <div class="code e757">*=</div> or 
                  <div class="code e758">|=</div> could be used to specify the resp. matching mode
                  
                  <div class="code e759">eq</div>, 
                  <div class="code e760">matches</div>, 
                  <div class="code e761">starts-with</div>, 
                  <div class="code e762">ends-with</div>, 
                  <div class="code e763">contains</div> or 
                  <div class="code e764">list-contains</div>.
                  
                  For example 
                  <div class="code e765">foo ^= "bar"</div> would match a foo attribute starting with "bar".
                  
                  
               </div>
               <div class="para e766">      
                  The third is to allow omitted end tags. Currently half of the pattern consists of
                  redunant end tags, which is not very useful. If we allow the old SGML syntax with
                  closing short tags 
                  <div class="code e767">&lt;/&gt;</div> or null end tags 
                  <div class="code e768">&lt;element/ ... /</div> in the pattern, it could be much shorter. Since we already match the patterns  against
                  HTML as well, there is no point in keeping a pure XML syntax.
                  
               </div>
            </div>
            <div class="listitem e769">
               <div class="para e770">
                  The patterns as defined so far only match against the string values of the nodes.
                  It might be useful to combine them with XML schemas to match on typed values, distinguishing
                  e.g. 
                  <div class="code e771">xs:integer(17)</div> and 
                  <div class="code e772">xs:string("17")</div>.
                  
               </div>
            </div>
            <div class="listitem e773">
               <div class="para e774">
                  Our current implementation performs naive backtracking, following exactly the recursive
                  definition of the matching process, which is well suited for the fast testing of experimental
                  syntaxes. It is, however, not very performant. It is therefore worthwhile to research
                  more efficient ways to implement patterns. One faster way would be to use dynamic
                  programming, using a 
                  <div class="code e775">n*m</div> table tracking which pattern element can be matched to which input element. Another
                  way might be to model the matching as NFA like a regular expression.  A third way
                  would be an automated conversion of a pattern to normal path expressions. Such an
                  approach could benefit from the existing research on query optimization, but might
                  miss specific optimizations applicable only to the patterns. Especially problematic
                  from an optimization POV is that variables created in a selector expression could
                  be later used in a condition affecting the matching. It might be a good idea to implement
                  the special case where such usage does not occur separately. 
                  
               </div>
            </div>
            <div class="listitem e776">
               <div class="para e777">
                  The basic node patterns do not have a syntax for back (like 
                  <div class="code e778">parent::</div>) or forward (like 
                  <div class="code e779">following::</div>) references. Therefore they seem to present a  natural way to write queries with
                  streaming parsers that read one element at the time and do not store preceding or
                  following nodes.   
                  It is worthwhile to investigate how well and efficient they can be combined with such
                  a streaming XML parser. 
                  
               </div>
            </div>
            <div class="listitem e780">
               <div class="para e781">
                  Once further extensions have been researched, it might be a good idea to convince
                  the W3C to add patterns to the next XQuery standard.
                  
               </div>
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e782">
         <div class="title e783">Conclusion</div>
         <div class="para e784">We have presented a true pattern matching on XML and HTML nodes with a syntax based
            on regular expressions and XQuery, which provides an intuitive way to write  queries
            for XML and HTML data. It was then successfully extended to matching on arbitrary
            JSONiq data, albeit with a less intuitive syntax.  
         </div>
         <div class="para e785">It was then shown that it can be integrated naturally in XQuery 
            <div class="code e786">switch</div>, 
            <div class="code e787">let</div> and 
            <div class="code e788">for</div> expressions, allowing one to use patterns in XQuery and XQuery expressions in patterns.
            
         </div>
         <div class="para e789">We conclude with the experiences of many years of pattern matching usage that such
            a matching is very useful to run queries on schema-less data like HTML pages, although
            there are still open issues and possible further syntax extensions that need to be
            researched. 
         </div>
      </div><a name="AcknowledgmentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e790">
         <div class="title e791">Acknowledgment</div>
         <div class="para e792">This paper was supported by the Graduate School for Computing in Medicine and Life
            Sciences funded by Germany’s Excellence Initiative [DFG GSC 235/1].
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e793">
         <div class="title e794">Bibliography</div>
         <div class="bibliomixed e795" xml:id="xmlql" xreflabel="XMLQL">Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and Dan Suciu. 
            <div class="emphasis e796" role="ital"> XML-QL: A Query Language for XML</div>. 1998. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e797" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/1998/NOTE-xml-ql-19980819</div>
         </div>
         <div class="bibliomixed e798" xml:id="xml" xreflabel="XML">W3C 
            <div class="emphasis e799" role="ital">Extensible Markup Language (XML) 1.0</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e800" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"> http://www.w3.org/TR/xml/</div>
         </div>
         <div class="bibliomixed e801" xml:id="xquery" xreflabel="XQuery">W3C 
            <div class="emphasis e802" role="ital">XQuery 3.0: An XML Query Language</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e803" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery-30/</div>
         </div>
         <div class="bibliomixed e804" xml:id="jsoniq" xreflabel="JSONiq">Jonathan Robie, Ghislain Fourny, Matthias Brantner, Daniela Florescu, Till Westmann,
            and Markos Zaharioudakis. 
            <div class="emphasis e805" role="ital">The JSON Query Language</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e806" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.jsoniq.org/docs/JSONiqExtensionToXQuery/html-single/index.html</div>
         </div>
         <div class="bibliomixed e807" xml:id="scala" xreflabel="Scala">Odersky, M., Altherr, P., Cremet, V., Emir, B., Maneth, S., Micheloud, S., ... &amp; Zenger,
            M. 
            <div class="emphasis e808" role="ital">An overview of the Scala programming language</div>. 2004.
         </div>
         <div class="bibliomixed e809" xml:id="rel1" xreflabel="Fischer2010">Peter Fischer,  Aayush Garg and Kyumars Sheykh Esmaili.   
            <div class="emphasis e810" role="ital">Extending XQuery with a Pattern Matching Facility</div>, in Database and XML Technologies, Lecture Notes in Computer Science. 2003. 
         </div>
         <div class="bibliomixed e811" xml:id="rel2" xreflabel="Hosoya2003">Haruo Hosoya, and Benjamin C. Pierce.  
            <div class="emphasis e812" role="ital">Regular expression pattern matching for XML</div>, in Journal of Functional Programming. 2003. 
         </div>
         <div class="bibliomixed e813" xml:id="rel3" xreflabel="Yao2004">J. T. Yao, and Ming Zhang. 
            <div class="emphasis e814" role="ital">A fast tree pattern matching algorithm for XML query</div>, IEEE. 2004. 
         </div>
      </div>
   </div>
</div>