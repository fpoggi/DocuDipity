<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TheXMLinfospaceANCHOR" name="TheXMLinfospaceTOC">The XML info space</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExperimentsandobservationsANCHOR" name="ExperimentsandobservationsTOC">Experiments and observations</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExperimentsANCHOR" name="ExperimentsTOC">Experiments</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ObservationsANCHOR" name="ObservationsTOC">Observations</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheXMLinfospaceANCHOR" name="TheXMLinfospaceTOC">The XML info space</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ThedefinitionANCHOR" name="ThedefinitionTOC">The definition</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ThelimitationsANCHOR" name="ThelimitationsTOC"> The limitations</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheboundariesANCHOR" name="TheboundariesTOC"> The boundaries</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AddressingthelimitationsoftheinfospaceANCHOR" name="AddressingthelimitationsoftheinfospaceTOC"> Addressing the limitations of the info space </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XLinkperXPathANCHOR" name="XLinkperXPathTOC">XLink per XPath</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XLinkversusdatadrivennavigationANCHOR" name="XLinkversusdatadrivennavigationTOC">XLink versus data-driven navigation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PropertyfacedcollectionsANCHOR" name="PropertyfacedcollectionsTOC">Property-faced collections</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExternalnodepropertiesANCHOR" name="ExternalnodepropertiesTOC">External node properties</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#PropertyfacedcollectionsANCHOR" name="PropertyfacedcollectionsTOC">Property-faced collections</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#FiltermodelANCHOR" name="FiltermodelTOC">Filter model</a></div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#ConceptANCHOR" name="ConceptTOC">Concept</a></div>
                  </div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#DatamodelANCHOR" name="DatamodelTOC">Data model</a></div>
                  </div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#SyntaxANCHOR" name="SyntaxTOC">Syntax</a></div>
                  </div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#SemanticsANCHOR" name="SemanticsTOC">Semantics</a></div>
                  </div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NewXPathfunctionsANCHOR" name="NewXPathfunctionsTOC">New XPath functions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExposurebyRESTfulwebservicesANCHOR" name="ExposurebyRESTfulwebservicesTOC">Exposure by REST-ful web services</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DeployedandexternalcollectionsANCHOR" name="DeployedandexternalcollectionsTOC">Deployed and external collections</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ImplementationandconfigurationANCHOR" name="ImplementationandconfigurationTOC">Implementation and configuration</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#CollectionfeaturesANCHOR" name="CollectionfeaturesTOC">Collection features</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PushingtheboundariesoftheinfospaceANCHOR" name="PushingtheboundariesoftheinfospaceTOC"> Pushing the boundaries of the info space </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ModelorientedresourcerepresentationANCHOR" name="ModelorientedresourcerepresentationTOC">Model oriented resource representation</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#IntroductoryexampleANCHOR" name="IntroductoryexampleTOC">Introductory example</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AgenericpatternofintegrationANCHOR" name="AgenericpatternofintegrationTOC">A generic pattern of integration</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#VocabularybasedintegrationANCHOR" name="VocabularybasedintegrationTOC">Vocabulary based integration</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#VocabularyassistedintegrationANCHOR" name="VocabularyassistedintegrationTOC">Vocabulary-assisted integration</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NativeintegrationANCHOR" name="NativeintegrationTOC">Native integration</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheextensionofXMLANCHOR" name="TheextensionofXMLTOC">The extension of XML</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtensionoftheXMLdatamodelANCHOR" name="ExtensionoftheXMLdatamodelTOC">Extension of the XML data model</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtensionoftheXMLsyntaxANCHOR" name="ExtensionoftheXMLsyntaxTOC">Extension of the XML syntax</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtensionoftheXPath/XQuerylanguageANCHOR" name="ExtensionoftheXPath/XQuerylanguageTOC">Extension of the XPath/XQuery language</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MarkupintegrationANCHOR" name="MarkupintegrationTOC">Markup integration</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#WrappingupANCHOR" name="WrappingupTOC">Wrapping up</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">arcrole</div>
         <div class="singletermTERMS">arclabel</div>
         <div class="singletermTERMS">and, or, not</div>
         <div class="singletermTERMS">and, or</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">addressed</div>
         <div class="singletermTERMS">API boundary</div>
         <div class="singletermTERMS">arc</div>
         <div class="singletermTERMS">Available extended links</div>
         <div class="singletermTERMS">additional</div>
         <div class="singletermTERMS">accessible without constructing the node</div>
         <div class="singletermTERMS">associated</div>
         <div class="singletermTERMS">available property-faced collections</div>
         <div class="singletermTERMS">a generic pattern of integration</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Boolean condition</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">countryCode</div>
         <div class="singletermTERMS">changeLog</div>
         <div class="singletermTERMS">cell</div>
         <div class="singletermTERMS">concepts</div>
         <div class="singletermTERMS">comparison constraint</div>
         <div class="singletermTERMS">collection features</div>
         <div class="singletermTERMS">Collection features.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">discover</div>
         <div class="singletermTERMS">data</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">every</div>
         <div class="singletermTERMS">extend the dynamic context</div>
         <div class="singletermTERMS">external node properties</div>
         <div class="singletermTERMS">Example of a p-faced collection.</div>
         <div class="singletermTERMS">Exposure as REST-ful web services</div>
         <div class="singletermTERMS">element contents</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">foo.xml</div>
         <div class="singletermTERMS">fn:doc</div>
         <div class="singletermTERMS">fn:collection</div>
         <div class="singletermTERMS">fn:xlink</div>
         <div class="singletermTERMS">file://countries/fr.xml</div>
         <div class="singletermTERMS">file://countries/de.xml</div>
         <div class="singletermTERMS">file://countries/it.xml</div>
         <div class="singletermTERMS">fn:nodes</div>
         <div class="singletermTERMS">filter</div>
         <div class="singletermTERMS">fn:matches</div>
         <div class="singletermTERMS">false</div>
         <div class="singletermTERMS">fn:httpDoc</div>
         <div class="singletermTERMS">features</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getWeatherResponse</div>
         <div class="singletermTERMS">generic operation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">hrennau@yahoo.de</div>
         <div class="singletermTERMS">Hans-Jürgen</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">info space</div>
         <div class="singletermTERMS">Implementation and configuration</div>
         <div class="singletermTERMS">is</div>
         <div class="singletermTERMS">information content</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">JSON&gt;</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">model</div>
         <div class="singletermTERMS">media type boundary</div>
         <div class="singletermTERMS">model oriented resource representation</div>
         <div class="singletermTERMS">maintain</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">nodes</div>
         <div class="singletermTERMS">node builder</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">navigational integration</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">or</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">p:term</div>
         <div class="singletermTERMS">p:filter</div>
         <div class="singletermTERMS">p:or</div>
         <div class="singletermTERMS">parallel operation</div>
         <div class="singletermTERMS">physical boundary</div>
         <div class="singletermTERMS">property face</div>
         <div class="singletermTERMS">p-face</div>
         <div class="singletermTERMS">p-faced collection</div>
         <div class="singletermTERMS">p-filter</div>
         <div class="singletermTERMS">p-filtered collection</div>
         <div class="singletermTERMS">p-filter engine</div>
         <div class="singletermTERMS">property condition</div>
         <div class="singletermTERMS">property-faced collection</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">role</div>
         <div class="singletermTERMS">R1(G)</div>
         <div class="singletermTERMS">R2(N)</div>
         <div class="singletermTERMS">row</div>
         <div class="singletermTERMS">resource boundaries</div>
         <div class="singletermTERMS">representations</div>
         <div class="singletermTERMS">Rennau</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">select</div>
         <div class="singletermTERMS">some</div>
         <div class="singletermTERMS">some, every</div>
         <div class="singletermTERMS">selecting a particular arc</div>
         <div class="singletermTERMS">Syntax</div>
         <div class="singletermTERMS">snapshot</div>
         <div class="singletermTERMS">semantic integration</div>
         <div class="singletermTERMS">Senior Java developer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">true</div>
         <div class="singletermTERMS">table</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">uri</div>
         <div class="singletermTERMS">udl:markup</div>
         <div class="singletermTERMS">udl:markup='...'</div>
         <div class="singletermTERMS">UDL</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">vertically unbounded</div>
         <div class="singletermTERMS">values</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xlink</div>
         <div class="singletermTERMS">xs:untypedAtomic</div>
         <div class="singletermTERMS">xs:double</div>
         <div class="singletermTERMS">xml:type</div>
         <div class="singletermTERMS">XML info space</div>
         <div class="singletermTERMS">XML</div>
         <div class="singletermTERMS">XPath</div>
         <div class="singletermTERMS">XQuery</div>
         <div class="singletermTERMS">XSLT</div>
         <div class="singletermTERMS">XDM</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TheXMLinfospaceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">The XML info space</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2013</div>
            <div class="confdates e5">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e6">
            <div class="para e7"> XML-related standards imply an architecture of distributed information which
               integrates all accessible XML resources into a coherent whole. Attempting to capture
               the key properties of this architecture, the concept of an info space is defined.
               The concept is used as a tool for deriving desirable extensions of the standards.
               The proposed extensions aim at a fuller realization of the potential offered by the
               architecture. Main aspects are better support for resource discovery and the
               integration of non-XML resources. If not adopted by standards, the extensions may
               also be emulated by application-level design patterns and product-specific features.
               Knowledge of them might therefore be of immediate interest to application developers
               and product designers. 
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Hans-Jürgen</div>
               <div class="othername e11"></div>
               <div class="surname e12">Rennau</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14"></div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Senior Java developer</div>
               <div class="orgname e17">Traveltainment GmbH</div>
            </div>
            <div class="email e18">hrennau@yahoo.de</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright © 2013 by the author.  Used with permission.</div>
         </div>
         <div class="keywordset e21" role="author">
            <div class="keyword e22">XML info space</div>
            <div class="keyword e23">property-faced collection</div>
            <div class="keyword e24">XML</div>
            <div class="keyword e25">XPath</div>
            <div class="keyword e26">XQuery</div>
            <div class="keyword e27">XSLT</div>
            <div class="keyword e28">JSON&gt;</div>
            <div class="keyword e29">XDM</div>
            <div class="keyword e30">UDL</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e31">
         <div class="title e32">Introduction</div>
         <div class="para e33"> The first version of a successful program is not the last one. But the more complex
            the program, the more care is required when making changes. When technologies and
            the
            underlying standards are concerned, any changes must certainly be based on a deep
            understanding of the status quo. But the nature of the required understanding is not
            obvious. 
         </div>
         <div class="para e34">In 1938, Albert Einstein and Leopold Infeld published a book about the evolution of
            physics [
            <div class="xref e35" linkend="einstein"></div>]. The focus was on the crucial role played by named
            
            <div class="emphasis e36" role="ital">concepts</div>, guiding and at times limiting our
            thoughts and understanding. A striking example involves the concepts of "force" and
            "field". At a point in time, the scientific understanding of forces was a sort of
            interaction between two bodies. Then the field was discovered as a new reality, existing
            independently of the presence and absence of bodies. Without this image of a field,
            understanding simply could not have passed beyond a certain point.
         </div>
         <div class="para e37"> In information technology, named concepts can play an important role in the
            development of industry standards. Fielding [
            <div class="xref e38" linkend="fielding"></div>] gave a detailed
            account how the abstractions of a "resource" and "resource representations" enabled
            a
            unified vision of the emerging internet and led to the definition of an architectural
            style (REST - Representational State Transfer) which provided guidance in the evaluation
            of proposed changes to the standards.
         </div>
         <div class="para e39"> How about XML – is it final or in need of a new version? Is there a direction to
            go?
            This paper proposes a novel abstraction to guide a better understanding of the
            technological reality already created, an abstraction intended to help in the evaluation
            of further steps. The reality implemented by XML technology is very versatile, and
            doubtless many conceptualizations are useful and important. Nevertheless, this paper
            suggests a new concept or image - the info space. The concept evokes a potential which
            is at the same time so large and so much limited by the current state of affairs that
            the perspective of a fuller realization may affect our sense of priorities. The
            remaining sections define the concept, explore the current limitations and suggest
            steps
            towards an increasing realization of its potential. 
         </div>
      </div><a name="ExperimentsandobservationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e40">
         <div class="title e41">Experiments and observations</div>
         <div class="para e42">To get started, we examine a few simple programming tasks and possible solutions using
            XPath. The experience will invite some observations, which we then attempt to translate
            into a concept characterizing the new situation which XML technology has created.
         </div><a name="ExperimentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e43" xml:id="experiments" xreflabel="Experiments">
            <div class="title e44">Experiments</div>
            <div class="para e45">Assume we have an XML file (
               <div class="code e46">foo.xml</div>) and want to retrieve all
               
               <div class="code e47">countryCode</div> elements, no matter where they occur in the document.
               The following XPath expression does just that:
               
               <div class="programlisting e48" xml:space="preserve">   doc("foo.xml")//countryCode</div> Now we want to
               detect all 
               <div class="code e49">countryCode</div> instances that do not contain a valid two-letter
               code according to ISO 3166. As a code dictionary in XML format is available in the
               internet
               <div class="popupBox e50">
                  <div class="popupLabel" onmouseover="$('#d1e91').show('1000');" onmouseout="$('#d1e91').hide('1000');">[ footnote ]</div>
                  <div id="d1e91" style="display: none;">
                     <div class="footnote" xml:id="uri-iata">
                        <div class="para e51">
                           http://www.iso.org/iso/home/standards/country_codes/country_names_and_code_elements_xml.htm
                           
                        </div>
                     </div>
                  </div>
               </div>
               we can solve the problem by adding a simple filter expression:
               
               <div class="programlisting e52" xml:space="preserve">   doc("foo.xml")//countryCode[not(. = doc("http://...")//code]</div>
               When the check should be applied to several files, we only have to replace the first
               step by an expression which yields several documents, rather than a single document:
               
               <div class="programlisting e53" xml:space="preserve">   (doc("foo.xml"), doc("foo2.xml"))
                  //countryCode[not(. = doc("http://...")//code]
               </div>
               As there may be many documents to be checked, we introduce a helper resource, an XML
               document listing all documents concerned. The list represents each document by a
               
               <div class="code e54">uri</div> element containing the document URI, which may be a file name
               or an HTTP address. In order to apply the check to all documents found in the
               document list, again we adapt the first step of our navigation:
               
               <div class="programlisting e55" xml:space="preserve">   doc("docs.xml")//uri/doc(.)
                  //countryCode[not(. = doc("http://...")//code]
               </div>
               The documents may be found in the file system, an intranet or the internet, and
               their number could be large. If a specific document list has to be created for our
               checking task, this might become inconvenient, too. So we introduce a general
               purpose inventory of document URIs which describes a whole domain of documents, only
               some of which have to be checked in this particular case. We create a
               tree-structured document list in which only the leaf elements are 
               <div class="code e56">uri</div>
               elements containing a document URI, whereas all inner nodes have the purpose of
               adding structure, implicitly creating groups of documents. All elements - inner
               nodes and 
               <div class="code e57">uri</div> elements - may have attributes supplying metadata
               pertaining to the document(s) referenced by the element itself or its descendants.
               Schematically, such an inventory might look like this: 
               <div class="programlisting e58" xml:space="preserve">   &lt;doctree&gt;
                  &lt;department name="d1"&gt;
                  &lt;project name="p1"&gt;
                  &lt;xsd&gt; 
                  &lt;uri app="a1"&gt;…&lt;/uri&gt; 
                  &lt;uri app="a2"&gt;…&lt;/uri&gt; 
                  &lt;/xsd&gt;
                  &lt;msg&gt;…	
                  &lt;uri srv="s1"&gt;…&lt;/uri&gt; 
                  &lt;uri srv="s2"&gt;…&lt;/uri&gt; 
                  &lt;/msg&gt;…
                  &lt;/project&gt;
                  &lt;/department&gt;
                  &lt;/doctree&gt;
               </div> Now we can combine the selection of documents and their checking
               into a single expression:
               
               <div class="programlisting e59" xml:space="preserve">   doc("doctree.xml")//project[@name="p1"]/msg/uri/doc(.)/
                  //countryCode[not(. = doc("http://...")//code]
               </div>
               A navigation across multiple resources - an inventory, all resources referenced by
               
               <div class="code e60">uri</div> elements which match certain conditions, and finally the code
               dictionary – is achieved by a single expression, without taking actions like opening
               a file and without shifting information from data sources into intermediate
               variables.
            </div>
            <div class="para e61"> The expression does not only yield the faulty codes; it resolves to the 
               <div class="emphasis e62" role="ital">nodes</div> containing them, which means information 
               <div class="emphasis e63" role="ital">and</div> its location. Assigning the nodes to an XQuery
               variable (
               <div class="code e64">$faultyCodes</div>), we can later resume navigation, using those
               nodes as starting points. If the documents contain somewhere a
               
               <div class="code e65">changeLog</div> element, we can collect the change logs of all faulty
               documents:
               
               <div class="programlisting e66" xml:space="preserve">   $faultyCodes/ancestor::document-node()//changeLog</div>
               
            </div>
         </div><a name="ObservationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e67">
            <div class="title e68">Observations</div>
            <div class="para e69">This little programming experience may give a feeling of handling information in a
               different way than when using a general purpose language like Java or Perl. What was
               different? 
            </div>
            <div class="para e70"> First, we did not "load" resources - we just 
               <div class="emphasis e71" role="ital">addressed</div> them using an expression which was equivalent to the
               complete information content. Compare this to Java code extracting data from a CSV
               file. The equivalence enables us to to use the expression as input to navigation:
               
               <div class="programlisting e72" xml:space="preserve">   doc("…")//countryCode</div>
               
            </div>
            <div class="para e73"> Second, navigation can be downward (e.g. "…//..") or upward (e.g.
               "ancestor::...") in a 
               <div class="emphasis e74" role="ital">vertically unbounded</div> way,
               moving from any current location in a single bout down to the very leaves under it
               and up to the very root above it. Compare this to the navigation in an object tree:
               a downward move can only be achieved recursively, one level per invocation, and
               upward navigation is impossible. 
            </div>
            <div class="para e75"> Third, 
               <div class="emphasis e76" role="ital">resource boundaries</div> do not impose a
               resistence to navigation: the effort to enter a different document is not greater
               than the effort to move within the same document. The following expression moves
               down to 
               <div class="code e77">uri</div> elements, crosses over into the referenced documents and
               continues its path down into that document:
               
               <div class="programlisting e78" xml:space="preserve">   //uri/doc(.)//countryCode</div>
               
            </div>
            <div class="para e79"> Fourth, navigation is a 
               <div class="emphasis e80" role="ital">parallel operation</div>,
               multiply rooted and cascading: the starting point may be one or many locations, and
               subsequent steps resume the movement at every location reached by the preceding
               step. This is different from navigation of an object tree, which is a movement from
               single item to single item.
            </div>
            <div class="para e81"> Fifth, navigation is a 
               <div class="emphasis e82" role="ital">generic operation</div>: the
               inventory, the resources to be checked and the code dictionary have different
               semantics, but they are navigated in the same way. Navigation of an object tree, on
               the other hand, must adapt each single step to object types.
            </div>
            <div class="para e83"> Summarizing the observations, one perceives a continuous space of information: we
               can enter and leave resources at will, and within them we can move up, down, forward
               and backward in a uniform and effortless way. The space is a sum total of
               information which integrates every single accessible XML document. Within this
               space, every item of information is visible and addressable. 
            </div>
         </div>
      </div><a name="TheXMLinfospaceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e84">
         <div class="title e85">The XML info space</div>
         <div class="para e86">This section proposes the notion of an 
            <div class="emphasis e87" role="bold">info space</div> as
            an architecture of distributed information which comprises two models, describing
            content and navigation. The definition of the space is guided by the reality introduced
            by XML technology but, being an abstraction, does in no way depend on XML as its
            implementation. Let us summarize some important properties:
         </div><a name="ThedefinitionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e88">
            <div class="title e89">The definition</div>
            <div class="itemizedlist e90">
               <div class="listitem e91">
                  <div class="para e92">Space content is decomposable into information items
                     <div class="itemizedlist e93">
                        <div class="listitem e94">
                           <div class="para e95">The space is an unstructured collection of resources</div>
                        </div>
                        <div class="listitem e96">
                           <div class="para e97">A resource is a structured collection of items</div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e98">
                  <div class="para e99">Inter-item relationships are well defined
                     <div class="itemizedlist e100">
                        <div class="listitem e101">
                           <div class="para e102">Items within a resource are related by axes</div>
                        </div>
                        <div class="listitem e103">
                           <div class="para e104">Items in different resources are related by URI+axes</div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e105">
                  <div class="para e106">Navigation is item-oriented
                     <div class="itemizedlist e107">
                        <div class="listitem e108">
                           <div class="para e109">Input, output, intermediaries are sets of items</div>
                        </div>
                        <div class="listitem e110">
                           <div class="para e111">Input, output, intermediaries can reside in multiple
                              resources
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e112">
                  <div class="para e113">Navigation is generic</div>
                  <div class="itemizedlist e114">
                     <div class="listitem e115">
                        <div class="para e116">The specification of a movement can be separated from the choice
                           of start items
                        </div>
                     </div>
                     <div class="listitem e117">
                        <div class="para e118">Any specification of a movement can be applied to any choice of
                           start items
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e119">
                  <div class="para e120">Information is well defined</div>
                  <div class="itemizedlist e121">
                     <div class="listitem e122">
                        <div class="para e123">Information is a sequence of items</div>
                     </div>
                     <div class="listitem e124">
                        <div class="para e125">An item is a component with properties</div>
                     </div>
                     <div class="listitem e126">
                        <div class="para e127">Semantics and value space of item properties are well
                           defined
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e128">
                  <div class="para e129">Information is expressible</div>
                  <div class="itemizedlist e130">
                     <div class="listitem e131">
                        <div class="para e132">Information is expressible as navigation leading to it</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e133">It is easy to see how all properties are implemented by current XML technology.
               The resources in question are XML documents [
               <div class="xref e134" linkend="w3c-xml"></div>], their
               itemized structure is defined by the node model part of the XDM [
               <div class="xref e135" linkend="w3c-xdm"></div>] (which is more suitable as a substrate for navigation than
               the info set model [
               <div class="xref e136" linkend="w3c-infoset"></div>]), intra-resource relationships
               are defined by XPath axes [
               <div class="xref e137" linkend="w3c-xpath"></div>] and inter-resource
               relationships by the URI standard [
               <div class="xref e138" linkend="uri"></div>]. The navigation model is
               provided by XPath [
               <div class="xref e139" linkend="w3c-xpath"></div>] and XQuery [
               <div class="xref e140" linkend="w3c-xquery"></div>] and the information model by the XDM in its entirety
               [
               <div class="xref e141" linkend="w3c-xdm"></div>].
            </div>
         </div><a name="ThelimitationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e142">
            <div class="title e143"> The limitations</div>
            <div class="para e144">The URIs of all accessible documents are an unstructured collection of strings.
               There is no built-in way how to navigate this collection, iterate over its members
               or in some other way discover URIs. Document access simply requires beforehand
               knowledge of a document URI. If relying on standard XPath functions only, even file
               directories cannot be inspected in order to discover the files it contains. To throw
               light on this limitation, think of a stock of information distributed over thousands
               of XML documents which are accessible either as local files or via HTTP address.
               While on the one hand it is a fascinating thought that anything within that pool of
               documents can be immediately 
               <div class="emphasis e145" role="ital">addressed</div>, it can
               become a serious problem how to 
               <div class="emphasis e146" role="ital">discover</div> the
               resources: to find out which URI to use. If we compared XML documents to relational
               table rows, the info space would resemble a relational database in which
               
               <div class="code e147">select</div> commands are constrained to specify a primary key. 
            </div>
         </div><a name="TheboundariesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e148">
            <div class="title e149"> The boundaries</div>
            <div class="para e150">Given a computing site - which part of the resources of the world are in the info
               space, and which are not? Any resource not accessible via network or file system is
               obviously not within the info space: this is the 
               <div class="emphasis e151" role="ital">physical
                  boundary
               </div>. But also when physical access is possible, the protocol
               requirements may not be supported by XPath functions providing document access
               (namely the 
               <div class="code e152">fn:doc</div> function), for example due to the need of supplying
               authorization information or an HTTP body: this is the 
               <div class="emphasis e153" role="ital">API
                  boundary
               </div>. Those resources which are accessible both physically and
               API-wise can be grouped into two categories: XML documents and other resources. The
               former are in the XML info space, the latter are not: the 
               <div class="emphasis e154" role="ital">media type boundary</div> excludes any non-XML resources.
            </div>
         </div>
      </div><a name="AddressingthelimitationsoftheinfospaceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e155">
         <div class="title e156"> Addressing the limitations of the info space </div>
         <div class="para e157"> XPath navigation has a strong part and a weak part. Within-resource movement is
            governed by a powerful model – the application of semantic filters (name test and
            predicates) to structural relationships (navigational axes). Between-resource movement,
            on the other hand, is mainly enabled by the 
            <div class="code e158">fn:doc</div> function, which resolves
            a URI to the corresponding document. This is a lookup requiring beforehand knowledge
            of
            the key – neither structural nor semantic conditions can be specified. Regarded as
            a
            means of navigation, the 
            <div class="code e159">fn:doc</div> function produces “manifold motion making
            little speed” (S. T. Coleridge, “The butterfly”), as it delivers only one result item
            per item of knowledge. The 
            <div class="code e160">fn:collection</div> function offers multiple items for
            the price of a single URI, but the collection is a pre-defined unit, which often will
            not match the actual requirements. 
         </div>
         <div class="para e161"> These limitations reflect the nature of the info space, which is an unstructured
            set
            of unrelated, indistinguishable trees. Or more precisely: trees that cannot be
            distinguished or related until an in-memory representation is constructed, as URIs
            are
            devoid of semantics. The info space does not relate resource URIs to a structure (like
            directories), does not define inter-resource relationships (like XLink links) and
            does
            not provide any way how to search for resources (as a database does). 
         </div>
         <div class="para e162"> Space structure, resource relationships and searchability may, however, be introduced
            on the grounds of 
            <div class="emphasis e163" role="ital">data</div> which create a second layer of
            information, built upon the first layer consisting of the resources themselves. Think
            of
            a linkbase defining relationships between documents, or a data set associating URIs
            with
            meta information. Data-based navigation aids can be introduced on the application
            level.
            But they might also be supported by standardization. The basic principle would be
            to
            
            <div class="emphasis e164" role="ital">extend the dynamic context</div> of XPath evaluation by
            novel components which expose those data to the navigational engine of XPath - enabling
            novel XPath functions, perhaps even novel navigational axes. 
         </div>
         <div class="para e165"> This section explores some possibilities how standards may be extended in order to
            enhance the possibilities of between-resource navigation. 
         </div><a name="XLinkperXPathANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e166">
            <div class="title e167">XLink per XPath</div>
            <div class="para e168"> XLink [
               <div class="xref e169" linkend="w3c-xlink"></div>] is a specification that defines XML syntax
               for describing links between resources. Although these resources are not necessarily
               nodes, we can for the sake of our discussion treat XLink as a language for defining
               node relationships. The basic unit of resource linkage is an 
               <div class="emphasis e170" role="ital">arc</div> which maps one set of resources (the starting resources) to
               another set of resources (the ending resources). The arc enables “traversal” from
               any one of the starting resources to any one of the ending resources. This concept
               of XLink traversal is similar, though not identical, to XPath navigation. Both rely
               on a unidirectional mapping from a start or context node to a set of result nodes.
               Consequently, the definition of XLink arcs might be viewed as the definition of
               potential navigation steps available to XPath. Let us investigate possibilities to
               translate XLink-defined arcs into XPath steps. 
            </div>
            <div class="para e171"> XLink defines containers, called extended links, which hold together a set of
               resource locators and associated arcs, which are mappings between subsets of the
               complete set. (For the sake of clarity, we ignore the possibility of using local
               resources instead of or together with resource locators.) The extended link can
               assign to each of its resources an optional label (NCName). The label is like a
               property attached to the resources which allows them to be identified and grouped
               into subsets of the complete set contained by the extended link. The start and the
               end of an arc is defined in terms of an optional label value: if a label value is
               set, the corresponding subset of resources comprises all resources which have this
               label; if no label value is set, the subset is equal to the complete set. Consider
               the following extended link containing four arcs: 
               <div class="programlisting e172" xml:space="preserve">
                  &lt;foo xlink:type='extended'&gt;
                  &lt;a1 xlink:type='arc' xlink:from='a' xlink:to='b'/&gt;
                  &lt;a2 xlink:type='arc' xlink:to='b'/&gt;
                  &lt;a3 xlink:type='arc' xlink:from='a'/&gt;
                  &lt;a4 xlink:type='arc' /&gt;
                  
                  &lt;res xlink:type='locator' xlink:href='…1' xlink:label='a'/&gt;
                  &lt;res xlink:type='locator' xlink:href='…2' xlink:label='b'/&gt;
                  &lt;res xlink:type='locator' xlink:href='…3' xlink:label='b'/&gt;
                  &lt;res xlink:type='locator' xlink:href='…4' xlink:label='b'/&gt;
                  &lt;res xlink:type='locator' xlink:href='…5' xlink:label='c'/&gt;
                  &lt;/foo&gt;
               </div>
               
            </div>
            <div class="para e173"> The arc &lt;a1&gt; leads from the single one resource associated with a label “a” to
               all three resources with a label “b”; &lt;a2&gt; leads from any one of the five
               resources to the three resources with a label “b”; &lt;a3&gt; leads from the resource
               with a label “a” to all five resources, including itself; and &lt;a4&gt; leads from any
               one of the five resources to all five resources, including itself. 
            </div>
            <div class="para e174"> An arc is an option for navigation. Given a node (N), a navigation step may be
               specified by 
               <div class="emphasis e175" role="ital">selecting a particular arc</div> (A). The
               destination is the collection of nodes which 
               <div class="itemizedlist e176">
                  <div class="listitem e177">
                     <div class="para e178">is empty if N is not among the starting resources of A</div>
                  </div>
                  <div class="listitem e179">
                     <div class="para e180">comprises the ending resources of A, otherwise</div>
                  </div>
               </div> Such navigation might be integrated into XPath if two changes are
               applied to the current standards: 
               <div class="itemizedlist e181">
                  <div class="listitem e182">
                     <div class="para e183">extend the static context of XPath by a component 
                        <div class="emphasis e184" role="bold">Available extended links</div>, comprising the
                        extended links which are “in scope”. (These extended links may be
                        imported as linkbase documents, analogously to the import of in-scope
                        schemas as schema documents.) 
                     </div>
                  </div>
                  <div class="listitem e185">
                     <div class="para e186"> define a new kind of navigation step which is based on the selection
                        of a particular arc 
                     </div>
                  </div>
               </div> The new kind of navigation step may be a combination of an
               
               <div class="code e187">xlink</div> axis with an “arc test” selecting arcs. The expression result
               could then be collected from the ending resources of the selected arcs. 
            </div>
            <div class="para e188"> How to specify the selection of arcs? The XLink standard defines extended links
               to have an optional 
               <div class="code e189">role</div> property and arcs to have an optional
               
               <div class="code e190">arcrole</div> property, where both properties have as value a URI.
               Therefore a selection of arcs might be specified by two URIs, a 
               <div class="code e191">role</div>
               selecting extended links and an 
               <div class="code e192">arcrole</div> selecting arcs within those
               links. If we now deviate from the XLink standard and assume that arcs have an
               additional property, an 
               <div class="code e193">“arclabel”</div> with an NCName as value, then arc
               selection might be specified by a single QName, as a QName consists of a URI plus
               an
               NCName. The “arc test” selecting an arc might now be specified by a QName, in
               analogy to the name test which is also specified by a QName, but selects elements
               or
               attributes . Consider the following expression:
               
               <div class="programlisting e194" xml:space="preserve">   xlink::x:y</div> Its value would be determined as
               follows. 
               <div class="orderedlist e195">
                  <div class="listitem e196">
                     <div class="para e197"> select from the 
                        <div class="emphasis e198" role="bold">Available extended
                           links
                        </div> those with a 
                        <div class="code e199">role</div> equal to the URI
                        bound to prefix “x” 
                     </div>
                  </div>
                  <div class="listitem e200">
                     <div class="para e201"> within the selected extended links select all arcs with an
                        
                        <div class="code e202">arclabel</div> equal to “y” 
                     </div>
                  </div>
                  <div class="listitem e203">
                     <div class="para e204"> filter the selected arcs, retaining only those whose set of starting
                        resources “matches” the context node (see below for details) 
                     </div>
                  </div>
                  <div class="listitem e205">
                     <div class="para e206"> obtain as the expression value the union of the ending resources of
                        all arcs retained by the previous step 
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e207"> A remaining issue is the definition of when a set of starting resources “matches”
               the context node. The proposal is to define matching as containment: the starting
               resources include a node which is either identical to or contains the context node.
               Consider this expression:
               
               <div class="programlisting e208" xml:space="preserve">
                  doc('foo.xml')//a/xlink::x:y
               </div>
               
            </div>
            <div class="para e209"> The selected arcs may include as starting resource either the document “foo.xml”,
               or the “a” element to which the 
               <div class="code e210">xlink</div> step is applied, or any ancestor
               of that “a” element. 
            </div>
            <div class="para e211"> As an alternative to using a new 
               <div class="code e212">xlink</div> axis, XLink navigation might
               be supported by a new standard function, 
               <div class="code e213">fn:xlink</div>. In this case, the
               set of extended links to be considered might alternatively be taken from the static
               context or from linkbase documents supplied as a parameter: 
               <div class="programlisting e214" xml:space="preserve">
                  fn:xlink($arcTest as xs:QName) as node()*
                  fn:xlink($arcTest as xs:QName, $linkbases as node()*) as node()*
               </div>
               
            </div>
         </div><a name="XLinkversusdatadrivennavigationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e215" xml:id="pfc-semantic-navigation">
            <div class="title e216">XLink versus data-driven navigation</div>
            <div class="para e217"> XLink defines resource relationships in terms of URI relationships - static
               mappings between single URIs and/or URI collections. The XLink model does not cover
               well a frequent requirement – data-driven navigation, which is guided by data and
               unawares of structural relationships between a current context and the destination.
               For example, assume a document D containing a country code, and further assume a
               collection of documents describing countries, one country per document: how can the
               evaluation of D take advantage of the country description matching the country code?
               
            </div>
            <div class="para e218"> Currently, the navigation model of XPath does not offer standardized support for
               such tasks. Working within the bounds of a single document, this is felt less
               acutely as expressions like 
               <div class="code e219">//country[@code eq 'FR']</div> have a sweeping
               nature which removes any structural assumptions apart from which document the
               information is located in. But when the target might be located in other documents,
               the lack of support may become an issue. Navigation between documents requires
               knowledge of a URI. In the general case this will be the target document URI, as
               support for named collections (the 
               <div class="code e220">fn:collection</div> function) is
               implementation-defined and hence not portable. Without such support we simply cannot
               “look into” other documents without first providing a document URI. 
            </div>
            <div class="para e221"> If the processor does support the 
               <div class="code e222">fn:collection</div> function, we can
               access documents without knowledge of individual document URIs. But collections are
               a problematic answer to the challenge of data-driven navigation. The collection is
               not yet the destination of our navigation, but a set of candidates from which to
               select the destination. In order to navigate into one country description, two
               hundred country descriptions have to be parsed (unless they are located in an XML
               database) and queried (unless we can resort to a database index). The greater the
               collection, the greater the overhead incurred by processing the collection in order
               to identify the one or few matching items. When there are a large number of
               candidates – e.g. accumulated log messages – the approach of constructing all
               candidate nodes and then filtering them can quickly become unfeasible. 
            </div>
            <div class="para e223"> The problem is deep-rooted. As navigational axes are bounded by the document
               border, conventional navigation cannot lead to the discovery of information in other
               documents, unless the URIs of those documents are either known beforehand or
               supplied by a document visited at an earlier navigation step. The next section
               develops a concept of data-driven navigation which is based on a filtering of
               collections which does not require the prior in-memory construction of its
               nodes.
            </div>
         </div><a name="PropertyfacedcollectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e224">
            <div class="title e225">Property-faced collections</div><a name="ExternalnodepropertiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e226">
               <div class="title e227">External node properties</div>
               <div class="para e228"> Every XML node has a set of properties defined by the XDM data model. An
                  element node, for example, has twelve properties, which include the name,
                  relationships to other nodes ([parent], [children], [attributes]), a type, a
                  typed value and a string value. Evaluation of these properties is what drives
                  XPath navigation, guiding it from a set of starting points to a set of
                  destination nodes. 
               </div>
               <div class="para e229"> In certain situations, however, the locating of nodes might be greatly
                  simplified if we manage to associate nodes with 
                  <div class="emphasis e230" role="ital">additional</div> properties which help us to identify the nodes of
                  interest. Such properties could represent metadata, or they could reflect the
                  contained data, for example echoing a value found at a particular data path
                  within the node, or providing a value derived from contained data, like a
                  minimum or maximum. As these additional properties are not XDM properties, their
                  values are not part of the node data. Hence we call them 
                  <div class="emphasis e231" role="bold">external node properties</div>. Their nature implies an interesting
                  possibility: they can provide information about a node which is 
                  <div class="emphasis e232" role="ital">accessible without constructing the node</div>. Access to
                  such information might enhance the navigational model of XPath in general, and
                  add support for data-driven navigation in particular. The following sections
                  describe an approach how to achieve this. 
               </div>
               <div class="para e233"> An external property has a name and a value. A set of external node
                  properties can be modelled as a map with which the node is associated. The map
                  entries have a key which represents the property name, and a value which
                  represents the property value. Such a map we call a 
                  <div class="emphasis e234" role="ital">property face</div> of the node, or 
                  <div class="emphasis e235" role="bold">p-face</div> for short. Striving to keep things simple, we constrain
                  external node properties to have an NCName and a value which is a sequence of
                  atomic items of type 
                  <div class="code e236">xs:untypedAtomic</div>. The value space of p-faces
                  is accordingly constrained. 
               </div>
            </div><a name="PropertyfacedcollectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e237">
               <div class="title e238">Property-faced collections</div>
               <div class="para e239"> A p-face is not part of the node data – it is merely 
                  <div class="emphasis e240" role="ital">associated</div> with them. This relationship can be compared to the
                  general relationship between the keys and values of a map: the keys are not part
                  of the values, but only associated with them in the context of the map. Such an
                  association is not global, but scoped to the map. 
               </div>
               <div class="para e241"> The association between a node and its p-face is provided by a node
                  collection which contains the node. We introduce the concept of a 
                  <div class="emphasis e242" role="bold">p-faced collection</div> (short for property-faced
                  collection), which is a conventional node collection plus a mapping associating
                  each node with a p-face. We do not constrain the individual p-faces to use the
                  same property names: the number and names of external properties can vary from
                  node to node. 
               </div>
               <div class="para e243"> The following table shows a simple example of a p-faced collection. In this
                  case, all collection members are associated with the same set of external
                  properties. The collection may therefore be represented by a table in which one
                  column identifies the node and the remaining columns represent external
                  properties. 
                  <div class="table e244">
                     <div class="caption e245">
                        <div class="para e246">
                           
                           <div class="emphasis e247" role="bold">
                              <div class="emphasis e248" role="ital"> Example of a p-faced
                                 collection. 
                              </div>
                           </div> The collection associates
                           each node with three external properties. Property value items are
                           separated by comma. 
                        </div>
                     </div>
                     <div class="metaBox e249"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e512').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e512" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e249'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e250"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e513').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e513" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e250'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="thead e251">
                        <div class="tr e252" valign="top">
                           <div class="th e253" align="left" valign="top">node URI</div>
                           <div class="th e254" align="left" valign="top">countryCode</div>
                           <div class="th e255" align="left" valign="top">neighbourCountries</div>
                           <div class="th e256" align="left" valign="top">rivers</div>
                        </div>
                     </div>
                     <div class="tbody e257">
                        <div class="tr e258" valign="top">
                           <div class="td e259">
                              <div class="code e260">file://countries/fr.xml</div>
                           </div>
                           <div class="td e261">fr</div>
                           <div class="td e262">at, be, ch, de, es, it, lu, mc</div>
                           <div class="td e263">Rhein, Loire, Maas, Rhone, Seine, Garonne, Mosel, Marne, …</div>
                        </div>
                        <div class="tr e264" valign="top">
                           <div class="td e265">
                              <div class="code e266">file://countries/de.xml</div>
                           </div>
                           <div class="td e267">de</div>
                           <div class="td e268">at, be, ch, cz, dk, fr, lu, nl, pl</div>
                           <div class="td e269">Donau, Elbe, Rhein, Oder, Weser, Main, Havel, Mosel, …</div>
                        </div>
                        <div class="tr e270" valign="top">
                           <div class="td e271">
                              <div class="code e272">file://countries/it.xml</div>
                           </div>
                           <div class="td e273">it</div>
                           <div class="td e274">at, ch, fr, sm, si, va</div>
                           <div class="td e275">Drava, Po, Adige, Tevere, Adda, Oglio, Tanaro, Ticino, ...</div>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e276"> A p-faced collection can be filtered by supplying a set of conditions to be
                  tested against the p-faces of its nodes. Such a set of conditions we call a
                  
                  <div class="emphasis e277" role="bold">p-filter</div>. The result of applying a p-filter
                  to a p-faced collection is a sub collection of the original collection, which we
                  call a 
                  <div class="emphasis e278" role="bold">p-filtered collection</div>. 
               </div>
               <div class="para e279"> A subsequent section will define the syntax and semantics of property filters
                  in detail. For the moment, assume that such a filter may be represented by a
                  string, and further assume that a p-faced collection is identified by a URI.
                  Concatenating the URI and the query string, we can then identify sub collections
                  by a single string, for example:
                  
                  <div class="programlisting e280" xml:space="preserve">
                     http://example.com/pcollections/countries?neighbourCountries=be
                  </div>
                  A new XPath function may provide the functionality of resolving such strings to
                  the node sequences they identify. If the model were adopted by the XPath
                  standard, such a function might be 
                  <div class="code e281">fn:nodes</div>, and one of its
                  signatures might be:
                  
                  <div class="programlisting e282" xml:space="preserve">
                     fn:nodes($uriQuery as xs:string) as node()*
                  </div>
                  The following snippet shows a simple XQuery program using this function: 
                  <div class="programlisting e283" xml:space="preserve">
                     declare variable $country external;
                     declare variable $countries := "http://example.com/pcollections/countries";
                     
                     &lt;neighbours cy="{$country}"&gt;{
                     fn:nodes(concat($countries, '?', $country))
                     }&lt;/neighbours&gt;
                  </div> A crucial aspect
                  of p-faced collections is the possibility to separate the evaluation of the
                  p-filter from the construction of the selected nodes. Filter evaluation does not
                  require looking “into” the candidate nodes, in fact it does not require the
                  construction of any nodes. Filter evaluation is an operation on a collection of
                  logical maps, the p-faces. The 
                  <div class="emphasis e284" role="bold">p-filter engine</div>
                  may treat the nodes as opaque strings, to be delivered as such. Resolving these
                  strings to the nodes they represent is the task of an independent component, the
                  
                  <div class="emphasis e285" role="bold">node builder</div>. The operations of p-filter
                  evaluation and node construction are distinct and independent. It follows that
                  the p-filter engine need not be based on XML technology. It is possible, for
                  example, to store the p-faced collection in a relational database table and use
                  as p-filter engine the relational database system. In this case, the p-filter
                  supplied to the 
                  <div class="code e286">fn:nodes</div> function would be translated into a SQL
                  query. It is also possible to store the p-faced collection in a NOSQL object
                  collection. The p-filter engine would then be the NOSQL data base system, and
                  the p-filter would be translated into a NOSQL query. Any p-filter engine can be
                  combined with the same node builder, as the mapping of a string to a node is in
                  no way influenced by the way how the string was obtained. 
               </div>
               <div class="para e287"> In summary, p-faced collections promise two distinct benefits. First, they
                  augment the navigational model of XPath with data-based access to information,
                  overcoming the current limitation that document access requires knowledge of the
                  document URI. Second, they offer the possibility to integrate non-XML
                  technologies into the implementation of XML data storage and XPath navigation,
                  which may enhance the scalability of XML based systems significantly. The
                  concept of p-faced collections must now provide 
                  <div class="itemizedlist e288">
                     <div class="listitem e289">
                        <div class="para e290">a model of p-filters in terms of data model, syntax and
                           semantics
                        </div>
                     </div>
                     <div class="listitem e291">
                        <div class="para e292">a proposal how to integrate p-faced collections into the XPath
                           language
                        </div>
                     </div>
                     <div class="listitem e293">
                        <div class="para e294">an outline how XPath processors may support the implementation of
                           p-faced collections using non-XML technologies 
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a name="FiltermodelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e295" xml:id="pfc-filter-model" xreflabel="Filter model">
               <div class="title e296">Filter model</div>
               <div class="para e297"> A p-filter defines a condition which can be applied to a p-face and yields a
                  Boolean result. As every node in a p-faced collection is associated with a
                  p-face, a p-filter can be used to specify sub collections. This section proposes
                  a generic model of a p-filter, which includes the data model, syntax and
                  semantics. 
               </div><a name="ConceptANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e298" xml:id="pfc-concept" xreflabel="Concept">
                  <div class="title e299">Concept</div>
                  <div class="para e300"> Attempting to strike a balance between simplicity and expressiveness, we
                     constrain a p-filter to consist only of atomic conditions and Boolean
                     conditions. An atomic condition submits the value of one particular property
                     to a particular test, and a Boolean condition is a Boolean operation
                     (
                     <div class="code e301">and, or, not</div>) applied to the results of atomic and/or
                     Boolean conditions. A p-filter can therefore be viewed as a logical tree
                     with leaves representing atomic conditions and inner nodes representing
                     Boolean conditions. 
                  </div>
                  <div class="para e302"> Atomic conditions are modelled as comparisons between a property value
                     and a test value. Like the property value, also the test value is a sequence
                     of atomic items. These items are specified as literal strings or string
                     patterns – they cannot be references to other property values. The
                     comparison is defined in terms of an operator (=, &lt;, &lt;=, …) and a
                     quantifier (
                     <div class="code e303">some</div> or 
                     <div class="code e304">every</div>) specifying if all
                     property value items or only at least one item must pass the test. 
                  </div>
                  <div class="para e305"> The information content of a p-filter is defined in terms of the XDM data
                     model, namely as an element information item constrained in particular ways.
                     The data model must be distinguished from the syntax model which defines
                     string representations of this information content. The semantics of a
                     p-filter consist of the rules how to evaluate a p-filter in the context of a
                     p-face to a Boolean result. 
                  </div>
                  <div class="para e306"> The generic p-filter model allows the use of a p-filter engine (for
                     example a particular relational database system) which does not support all
                     possibilities implied by the model. To this end, the model includes the
                     definition of 
                     <div class="emphasis e307" role="ital">features</div> with
                     implementation-defined values. This approach combines the precise
                     specification of a fairly rich functionality with conformance criteria based
                     on a subset of the functionality, and it provides for a standard way how to
                     express implementation-specific limitations. 
                  </div>
               </div><a name="DatamodelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e308" xml:id="pfc-data-model" xreflabel="Data model">
                  <div class="title e309">Data model</div>
                  <div class="para e310"> A p-filter is an element information item with the local name
                     
                     <div class="code e311">filter</div> and a namespace URI yet to be decided. (For the time
                     being we assume the URI
                     
                     <div class="code e312">http://www.w3.org/2013/xpath-structures</div>). In the following text
                     we use the prefix p to denote this URI. The filter element is either empty
                     or has element-only content. It can have any number of child elements. Each
                     child element represents either a property condition or a Boolean condition. 
                  </div>
                  <div class="para e313"> A 
                     <div class="emphasis e314" role="bold">property condition</div> specifies a
                     condition referring to a particular property. It is represented by an
                     element information item in no namespace and with a local name equal to the
                     property name. The condition can be structured into four logical components,
                     described by the following table. 
                  </div>
                  <div class="table e315">
                     <div class="caption e316">
                        <div class="para e317">
                           
                           <div class="emphasis e318" role="bold">
                              <div class="emphasis e319" role="ital"> The components of a
                                 property condition and their XML representation.
                                 
                              </div>
                           </div>
                           
                        </div>
                     </div>
                     <div class="metaBox e320"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e653').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e653" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e320'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e321"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e654').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e654" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e321'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="thead e322">
                        <div class="tr e323" valign="top">
                           <div class="th e324" align="left" valign="top">Condition component</div>
                           <div class="th e325" align="left" valign="top">XML representationn</div>
                           <div class="th e326" align="left" valign="top">Explanation</div>
                        </div>
                     </div>
                     <div class="tbody e327">
                        <div class="tr e328" valign="top">
                           <div class="td e329">Property name</div>
                           <div class="td e330">The local name of the element.</div>
                           <div class="td e331">Note that property names are constrained to be NCNames. If this
                              is changed, the property name will be represented by the value
                              of a @name attribute.
                           </div>
                        </div>
                        <div class="tr e332" valign="top">
                           <div class="td e333">Test value</div>
                           <div class="td e334">Either the single text child of the element, or the
                              
                              <div class="code e335">p:term</div> child elements.
                           </div>
                           <div class="td e336">If there is only one test value item, it is represented by the
                              text content of the element. If there are several items, use for
                              each item a 
                              <div class="code e337">p:term</div> child element with a single text
                              child. Note that test value items are literal – they cannot be
                              references to other property values. Also note that test value
                              items cannot be accompanied by type information.
                           </div>
                        </div>
                        <div class="tr e338" valign="top">
                           <div class="td e339">Operator</div>
                           <div class="td e340">Optional @op attribute; default value: =; valid values: =, !=,
                              &lt;, &lt;=, &gt;, &gt;=, ~, %, #=, #!=, #&lt;, #&lt;=, #&gt;, #&gt;= 
                           </div>
                           <div class="td e341">A leading # indicates a numeric comparison; ~ is a regex match
                              governed by the XPath regex rules; % is a regex or pattern match
                              with implementation-defined semantics.
                           </div>
                        </div>
                        <div class="tr e342" valign="top">
                           <div class="td e343">Quantifier</div>
                           <div class="td e344">Option @qua attribute; default value: 
                              <div class="code e345">some</div>; valid
                              values: 
                              <div class="code e346">some, every</div>
                              
                           </div>
                           <div class="td e347">If the value is 
                              <div class="code e348">every</div>, the condition requires every
                              item of the property value to meet the condition; otherwise,
                              only at least one item must meet the condition.
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="para e349"> An additional detail concerns the use of regex matching (@op equal ~). In
                     this case test value items containing a # are interpreted as follows: the
                     substring preceding the # is the pattern, the substring following it is a
                     set of match option flags (s, m, x, m, q) as they can be used in the third
                     parameter of standard function 
                     <div class="code e350">fn:matches</div>. 
                  </div>
                  <div class="para e351"> Some examples of property conditions: </div>
                  <div class="programlisting e352" xml:space="preserve">
                     &lt;time&gt;2013-01-01T00:00:00&lt;/time&gt;
                     &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
                     &lt;time op="&amp;lt;" qua="every"&gt;2013-01-01T00:00:00&lt;/time&gt;
                     &lt;keywords op="~"&gt;^semantic.*&lt;/keywords&gt;
                     &lt;keywords op="~"&gt;^semantic.*#i&lt;/keywords&gt;
                     &lt;keywords op="~"&gt;semantic%&lt;/keywords&gt;
                     &lt;codes&gt;
                     &lt;p:item&gt;DUS&lt;/p:item&gt;
                     &lt;p:item&gt;CGN&lt;/p:item&gt;
                     &lt;/codes
                  </div>
                  <div class="para e353"> A 
                     <div class="emphasis e354" role="bold">Boolean condition</div> specifies a Boolean
                     operation applied to the results of other conditions which are property
                     conditions and/or Boolean conditions. A Boolean condition is an element
                     information item with a local name equal to 
                     <div class="code e355">and, or</div> or
                     
                     <div class="code e356">not</div> and the same namespace URI as the 
                     <div class="code e357">p:filter</div>
                     element. Examples: 
                     <div class="programlisting e358" xml:space="preserve">
                        &lt;p:and&gt;
                        &lt;time op="&amp;gt;"&gt;2012-12-31T22:30:00&lt;/time&gt;
                        &lt;time op="&amp;lt;"&gt;2013-01-01T00:00:00&lt;/time&gt;
                        &lt;p:or&gt;
                        &lt;travelType op="~"&gt;^accommodation.*&lt;/travelType&gt;
                        &lt;supplier&gt;TUI&lt;/supplier&gt;
                        &lt;/p:or&gt;	
                        &lt;p:not&gt;
                        &lt;eventDate op="&amp;lt;" qua="every"&gt;2013-08-01&lt;/eventDate&gt;
                        &lt;/p:not&gt;
                        &lt;/p:and&gt;
                     </div>
                     
                  </div>
               </div><a name="SyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e359" xml:id="pfc-syntax" xreflabel="Syntax">
                  <div class="title e360">Syntax</div>
                  <div class="para e361"> Being defined as an element information item, a p-filter can be
                     serialized to a string like any other XML data. However, in certain
                     situations a more compact and intuitive syntax is desirable - for example
                     when passing a p-filter to a REST service as part of a URI. Therefore we
                     define a “query syntax” which represents a p-filter by a non-XML string. The
                     syntax represents a 
                     <div class="emphasis e362" role="ital">property condition</div> by
                     these patterns: 
                     <div class="programlisting e363" xml:space="preserve">
                        property-name operator testvalue
                        property-name operator (testvalueItem-1, testvalueItem-2, ...)
                     </div>and a 
                     <div class="emphasis e364" role="ital">Boolean condition</div> by these patterns: 
                     <div class="programlisting e365" xml:space="preserve">
                        condition and condition
                        condition or condition                        
                        not condition
                        not (condition1, condition2, ...)
                     </div>Parentheses can be used to change the
                     binding of operands to operator (by default: and &gt; or &gt; not). A non-default
                     quantifier (that is, 
                     <div class="code e366">every</div>) is encoded by a prefix character
                     preceding the operator string (e.g. $=). Example of a p-filter rendered in
                     query syntax:
                     <div class="programlisting e367" xml:space="preserve">
                        time &gt;= 2012… 
                        and time &lt;=2013…
                        and (travelType ~ ^accommodation.* or supplier=TUI) 
                        and not(eventData $&gt; 2013-01-01)
                     </div>Note that this is only a sketch of the
                     intended syntax – a detailed specification is left to future investigation.
                     In particular it must be decided if test values are quoted. 
                  </div>
               </div><a name="SemanticsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e368" xml:id="pfc-semantics" xreflabel="Semantics">
                  <div class="title e369">Semantics</div>
                  <div class="para e370"> A p-filter can be applied to a p-face in order to obtain a Boolean
                     result. The atomic operation of this evaluation is the checking of a single
                     property value item against a single test value item. Such a test is called
                     a 
                     <div class="emphasis e371" role="bold">comparison constraint</div>. Consequently, the
                     semantics of p-filter evaluation can be divided into general rules and rules
                     governing the evaluation of a comparison constraint. These are the general
                     rules: 
                     <div class="itemizedlist e372">
                        <div class="listitem e373">
                           <div class="para e374"> an empty p-filter evaluates to 
                              <div class="code e375">true</div>
                              
                           </div>
                        </div>
                        <div class="listitem e376">
                           <div class="para e377"> a non-empty p-filter evaluates to 
                              <div class="code e378">false</div> if at
                              least one child element evaluates to 
                              <div class="code e379">false</div>
                              
                           </div>
                        </div>
                        <div class="listitem e380">
                           <div class="para e381"> an 
                              <div class="code e382">and</div> condition evaluations to
                              
                              <div class="code e383">false</div> if at least one child element evaluates
                              to 
                              <div class="code e384">false</div>
                              
                           </div>
                        </div>
                        <div class="listitem e385">
                           <div class="para e386"> an 
                              <div class="code e387">or</div> condition evaluates to 
                              <div class="code e388">true</div>
                              if at least one child element evaluates to 
                              <div class="code e389">true</div>
                              
                           </div>
                        </div>
                        <div class="listitem e390">
                           <div class="para e391"> a 
                              <div class="code e392">not</div> condition evaluates to 
                              <div class="code e393">false</div>
                              if at least one child element evaluates to 
                              <div class="code e394">true</div>
                              
                           </div>
                        </div>
                        <div class="listitem e395">
                           <div class="para e396"> a property condition referencing a missing property evaluates
                              to 
                              <div class="code e397">false</div>
                              
                           </div>
                        </div>
                        <div class="listitem e398">
                           <div class="para e399"> a property condition with quantifier 
                              <div class="code e400">some</div>
                              evaluates to 
                              <div class="code e401">true</div> if at least one property value
                              item and at least one test value item meet the comparison
                              constraint 
                           </div>
                        </div>
                        <div class="listitem e402">
                           <div class="para e403"> a property condition with quantifier 
                              <div class="code e404">every</div>
                              evaluates to 
                              <div class="code e405">false</div> if for at least one property
                              value item there is no test value item with which it meets the
                              comparison constraint 
                           </div>
                        </div>
                     </div> A comparison constraint is specified in terms of an
                     operator. These are the evaluation rules: 
                     <div class="itemizedlist e406">
                        <div class="listitem e407">
                           <div class="para e408"> the operators =, !=, &lt;, &lt;= &gt;, &gt;= are evaluated by
                              applying to the operands the corresponding XPath operator;
                              operands are typed as 
                              <div class="code e409">xs:untypedAtomic</div>
                              
                           </div>
                        </div>
                        <div class="listitem e410">
                           <div class="para e411"> a comparison operator with a leading # is evaluated by
                              applying to the operands the corresponding XPath operator;
                              operands are converted to 
                              <div class="code e412">xs:double</div>
                              
                           </div>
                        </div>
                        <div class="listitem e413">
                           <div class="para e414"> the operand ~ is evaluated by evaluating the
                              
                              <div class="code e415">fn:matches</div> function, using the property value
                              item as first argument and the regex and options parts of the
                              test value item as second and third arguments. If the test value
                              item contains a # character, the regex and options parts are the
                              substrings before and after the character; otherwise, the regex
                              part is the complete item and the options part is the empty
                              string. 
                           </div>
                        </div>
                        <div class="listitem e416">
                           <div class="para e417"> the operator % has implementation-defined matching semantics
                              
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a name="NewXPathfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e418" xml:id="new-xpath-functions" xreflabel="New XPath functions">
               <div class="title e419">New XPath functions</div>
               <div class="para e420"> Given a p-faced collection, p-filters can be used to select a sub collection,
                  retaining only those nodes whose p-face passes the p-filter. This amounts to a
                  logical operation, mapping a collection URI and a p-filter to a sub collection.
                  New XPath functions can make this operation available. Assuming as a tentative
                  function name 
                  <div class="code e421">fn:nodes</div>, three variants may be useful: 
                  <div class="programlisting e422" xml:space="preserve">   fn:nodes($collectionUri as xs:string, p:filter as element(p:filter)) as node()*
                     fn:nodes($collectionUri as xs:string, p:filter as xs:string) as node()*
                     fn:nodes($filteredCollectionUri as xs:string) as node()*
                  </div>The second signature
                  expects the p-filter in query syntax (see 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e423" linkend="pfc-syntax" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">
                     
                     <div class="emphasis e424" role="under">Syntax</div>)
                  </div>. The third signature
                  expects a string composed of a collection URI and a p-filter in query syntax,
                  separated by a ? character, for example:
                  
                  <div class="programlisting e425" xml:space="preserve">   http://www.traveltainment.de/pfc/shoppingCart?booking-date=2013-08-01</div>Also
                  when concatenated with the collection URI, the p-filter in query syntax is not
                  URI-encoded. 
               </div>
               <div class="para e426"> The introduction of these functions should be accompanied by an extension of
                  the dynamic context of XPath evaluation: an additional component 
                  <div class="emphasis e427" role="bold">available property-faced collections</div> provides a
                  mapping of URIs to property-faced collections. A property-faced collection is
                  formally defined as a collection which is associated with a mapping of p-filter
                  instances to sub collections 
               </div>
            </div><a name="ExposurebyRESTfulwebservicesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e428" xml:id="pfc-rest" xreflabel="Exposure by REST-ful web services">
               <div class="title e429">Exposure by REST-ful web services</div>
               <div class="para e430"> A p-faced collection can be exposed as a REST-full web service, using as URI
                  the concatenation of collection URI and (URI-encoded) p-filter described in the
                  previous section. As a web service is expected to return a single document,
                  rather than a sequence of nodes, the selected sub collection may be wrapped by
                  an element and thus integrated into a single document. The proposed convention
                  is to use a 
                  <div class="code e431">&lt;p:collection&gt;</div> element with two attributes providing
                  the collection URI and the (not URI-encoded) p-filter. Example: 
                  <div class="programlisting e432" xml:space="preserve">   &lt;p:collection uri="http://www.traveltainment.de/pfc/offers" p-filter="destination=PMI"
                     xmlns="http://www.traveltainment.de/pfc/offers"
                     xmlns:p="http://www.w3.org/2013/xpath-structures"&gt; 
                     &lt;offer&gt;...&lt;/offer&gt;
                     &lt;offer&gt;...&lt;/offer&gt;
                     &lt;offer&gt;...&lt;/offer&gt;
                     &lt;/p:collection&gt;
                  </div>
                  
               </div>
            </div><a name="DeployedandexternalcollectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e433" xml:id="pfc-deployed-and-external-collections">
               <div class="title e434">Deployed and external collections</div>
               <div class="para e435"> An XPath processor may provide access to two different groups of p-faced
                  collections: 
                  <div class="itemizedlist e436">
                     <div class="listitem e437">
                        <div class="para e438">deployed collections</div>
                     </div>
                     <div class="listitem e439">
                        <div class="para e440">external collections</div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e441"> A deployed collection is accessed according to configuration data. This
                  might, for example, involve the translation of the p-filter into a SQL query,
                  its execution and the construction of nodes from result set data. See 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e442" linkend="pfc-implementation-and-configuration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">
                     
                     <div class="emphasis e443" role="under">Implementation and configuration</div>
                  </div>
                  for details about the deployment of p-faced collection. 
               </div>
               <div class="para e444"> An external collection is accessed by applying the 
                  <div class="code e445">fn:doc</div>
                  function to a URI which is a concatenation of collection URI and (URI-encoded)
                  p-filter in query syntax. The URI is expected to yield a document which
                  represents the selected nodes as child elements of the document element (see
                  
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e446" linkend="pfc-rest" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">
                     
                     <div class="emphasis e447" role="under">Exposure as REST-ful web
                        services
                     </div>)
                  </div>). The 
                  <div class="code e448">fn:nodes</div> function might operate
                  as follows: 
                  <div class="itemizedlist e449">
                     <div class="listitem e450">
                        <div class="para e451"> if the collection URI identifies a deployed collection – evaluate
                           the selection in accordance with the configuration data 
                        </div>
                     </div>
                     <div class="listitem e452">
                        <div class="para e453"> otherwise – construct a URI concatenating the collection URI and
                           the p-filter, resolve this URI to a document and deliver the child
                           nodes of the document element 
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a name="ImplementationandconfigurationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e454" xml:id="pfc-implementation-and-configuration">
               <div class="title e455">Implementation and configuration</div>
               <div class="para e456"> A crucial aspect of p-faced collections is that they may be implemented using
                  non-XML technologies, namely relational database tables and NOSQL object
                  collections. This follows from the fact that the node itself is represented by a
                  string and that it is not inspected during the filtering operation.
                  Consequently, the implementation of a p-faced collection is not dealing with any
                  tree structure. The implementation must provide for each node the representation
                  of a logical map in which one entry represents the node itself and the remaining
                  entries represent the names and values of properties. Configuration data include
                  the name of the entry representing the node and specify how the node (if
                  selected) is constructed from the string representing it. The string may be a
                  serialization of the node, or it may consist of locator information, either a
                  regular URI or a locator with implementation-defined semantics. 
               </div>
               <div class="para e457"> If the p-faced collection is “homogeneous” in the sense of every node having
                  the same external properties, a relational table is a straightforward choice. If
                  the nodes have different sets of properties, a NOSQL collection may be more
                  appropriate. An example for the latter case are log data, where each log entry
                  has some generic properties including an event type and further properties which
                  are event type-specific. An event of type “file-not-found” may have a property
                  “file-name”, whereas an event “container-delivered” may have properties
                  specifying a container-number and a location. 
               </div>
               <div class="para e458"> Configuration data are required in order to enable an XPath processor to
                  access the implementation of a p-faced collection: 
                  <div class="itemizedlist e459">
                     <div class="listitem e460">
                        <div class="para e461">the collection URI</div>
                     </div>
                     <div class="listitem e462">
                        <div class="para e463"> the implementation technology, implying the backend query
                           language to use 
                        </div>
                     </div>
                     <div class="listitem e464">
                        <div class="para e465"> connection data (e.g. database name and credentials and a
                           database table name, or the name of an object collection) 
                        </div>
                     </div>
                     <div class="listitem e466">
                        <div class="para e467"> the type of node representation (serialized node, or URI, or an
                           implementation-defined kind of locator) 
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a name="CollectionfeaturesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e468" xml:id="pfc-collection-features">
               <div class="title e469">Collection features</div>
               <div class="para e470"> The model of a p-filter includes details which may not be well supported by a
                  particular technology which on the whole seems well-suited to implement p-faced
                  collections. For example, the used technology may not support … 
                  <div class="itemizedlist e471">
                     <div class="listitem e472">
                        <div class="para e473">the regular expression dialect used by XPath</div>
                     </div>
                     <div class="listitem e474">
                        <div class="para e475">case-sensitive property names</div>
                     </div>
                     <div class="listitem e476">
                        <div class="para e477">case-sensitive property values</div>
                     </div>
                     <div class="listitem e478">
                        <div class="para e479">property values with multiple items</div>
                     </div>
                     <div class="listitem e480">
                        <div class="para e481"> searches requiring all property value items to meet a
                           condition
                        </div>
                     </div>
                  </div> Two perspectives must be distinguished: 
                  <div class="itemizedlist e482">
                     <div class="listitem e483">
                        <div class="para e484"> the collection provider – using a particular implementation
                           technology, his choices of property names and values may be limited
                           
                        </div>
                     </div>
                     <div class="listitem e485">
                        <div class="para e486"> the collection user – certain aspects of selection may not be
                           supported 
                        </div>
                     </div>
                  </div> Defining the integration of p-faced collections into XPath, only
                  the second perspective is relevant, as it impacts the semantics of XPath
                  expressions. The first perspective may affect the names and values of
                  properties, but not the syntax and semantics of XPath expressions. Such
                  limitations are hidden from the collection user by the actual use of property
                  names and values. For example, if the technology excludes multiple property
                  values, the collection simply does not use multiple-valued properties; or if the
                  technology does not support case-sensitive property names or values, the
                  collection arbitrarily defines all property names to be lower case (or upper
                  case). 
               </div>
               <div class="para e487"> The concept of 
                  <div class="emphasis e488" role="bold">collection features</div> is
                  introduced in order to enable a standardized representation of limitations, and
                  to enable a definition of conformance which can be achieved in spite of limited
                  support of the p-filter model. The following table presents a tentative set of
                  collection features.
                  <div class="table e489">
                     <div class="caption e490">
                        <div class="para e491">
                           
                           <div class="emphasis e492" role="bold">
                              <div class="emphasis e493" role="ital"> Collection features.
                                 
                              </div>
                           </div>
                           
                        </div>
                     </div>
                     <div class="metaBox e494"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1009').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1009" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e494'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e495"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1010').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1010" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e495'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="thead e496">
                        <div class="tr e497" valign="top">
                           <div class="th e498" align="left" valign="top">Collection feature</div>
                           <div class="th e499" align="left" valign="top">Description</div>
                           <div class="th e500" align="left" valign="top">Remark</div>
                        </div>
                     </div>
                     <div class="tbody e501">
                        <div class="tr e502" valign="top">
                           <div class="td e503">{operators}</div>
                           <div class="td e504">A list of supported operators. The list must contain the “=”
                              operator, all other operators are optional.
                           </div>
                           <div class="td e505">A p-filter must not use an operator not contained in
                              {operators}.
                           </div>
                        </div>
                        <div class="tr e506" valign="top">
                           <div class="td e507">{every-supported}</div>
                           <div class="td e508">If 
                              <div class="code e509">false</div>, a p-filter must not contain the
                              
                              <div class="code e510">every</div> quantifier.
                           </div>
                           <div class="td e511">Every implementation must support the 
                              <div class="code e512">some</div>
                              quantifier.
                           </div>
                        </div>
                        <div class="tr e513" valign="top">
                           <div class="td e514">{multiple-test-supported}</div>
                           <div class="td e515">If 
                              <div class="code e516">false</div>, a p-filter must not specify test values
                              with multiple items.
                           </div>
                           <div class="td e517">The use of multiple test values can be emulated using
                              
                              <div class="code e518">p:or</div>.
                           </div>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </div><a name="PushingtheboundariesoftheinfospaceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e519">
         <div class="title e520"> Pushing the boundaries of the info space </div>
         <div class="para e521">The boundaries of the info space distinguish resources that belong to the space from
            resources that do not belong to the space. A resource is excluded from the info space
            for one of these reasons: 
            <div class="itemizedlist e522">
               <div class="listitem e523">
                  <div class="para e524">Physical inaccessibility</div>
               </div>
               <div class="listitem e525">
                  <div class="para e526">API-based inaccessibility</div>
               </div>
               <div class="listitem e527">
                  <div class="para e528">Media type-based inaccessibility</div>
               </div>
            </div> Physical access is out of scope. API-based inaccessibility is a target
            for extensions of the XPath function library. Media type-based inaccessibility presently
            amounts to the simple rule: XML resources are within, non-XML resources are not within
            the space. This is the basic weakness of the info space seen as an information
            architecture, and it is arguably the greatest challenge for a well-guided evolution
            of
            XML. Accordingly, this paper concentrates on the media type boundary and limits itself
            to a couple of notes concerning the API-based boundary. 
         </div>
         <div class="para e529"> The API-based boundary can be shifted by the introduction of new standard functions
            for accessing XML documents which are presently not accessible using
            
            <div class="code e530">fn:doc</div>. These functions might address: 
            <div class="itemizedlist e531">
               <div class="listitem e532">
                  <div class="para e533">Documents requiring HTTP authorization</div>
               </div>
               <div class="listitem e534">
                  <div class="para e535">Documents requiring special HTTP header settings</div>
               </div>
               <div class="listitem e536">
                  <div class="para e537">Documents requiring the HTTP POST method</div>
               </div>
               <div class="listitem e538">
                  <div class="para e539">Documents within archives (e.g. zip)</div>
               </div>
            </div> Conceivable signatures would be (informally, for the sake of brevity):
            
            <div class="programlisting e540" xml:space="preserve">   httpDoc($uri, $username, $password, $headerFields, $body) as document-node() 
               zipDocs($uri, $directories, $namePatterns) as document-node()*
            </div>
            
         </div><a name="ModelorientedresourcerepresentationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e541">
            <div class="title e542">Model oriented resource representation</div>
            <div class="para e543"> The most critical limitation of the info space is its commitment to the XML media
               type. The most important extension of the space can be achieved by overcoming this
               limitation.
            </div>
            <div class="para e544"> An integration of non-XML resources into the info space is enabled by a
               consistent distinction between information and representation: between model and
               format. The basic principle of XML technology might be applied to non-XML resources:
               information 
               <div class="emphasis e545" role="ital">is</div> an instance of the data model. The
               info space can be extended by redefining non-XML formats to be 
               <div class="emphasis e546" role="ital">representations</div> of XDM node trees. 
            </div>
            <div class="para e547"> A format defined to represent node trees might be called a 
               <div class="emphasis e548" role="bold">model oriented resource representation</div>: a resource is viewed as a
               unit of information which is captured by a model instance, and this instance is
               represented by the format. The format instance is an expression, the model instance
               its value. 
            </div><a name="IntroductoryexampleANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e549">
               <div class="title e550">Introductory example</div>
               <div class="para e551"> Scenario: we want to check some country codes, we have access to a dictionary
                  of country codes and names, but this dictionary is represented by a CSV dataset. 
               </div>
               <div class="para e552"> Now let us assume there is a standardized XML vocabulary for table data,
                  comprising "table", "row" and "cell" elements. And we further assume the
                  existence of a new 
                  <div class="code e553">fn:doc</div> variant which delivers CSV data as an XML
                  node tree based on the table vocabulary. It enables us to select all invalid
                  country codes by a simple expression:
                  
                  <div class="programlisting e554" xml:space="preserve">   doc("foo.xml")//countryCode
                     [not(. = doc("countries.csv", "csv")//row/cell[1])]
                  </div>
                  
               </div>
               <div class="para e555"> This example demonstrates a seamless integration of data from XML and non-XML
                  resources: both participate in the info space. 
               </div>
            </div><a name="AgenericpatternofintegrationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e556" xml:id="generic-pattern-of-integration">
               <div class="title e557">A generic pattern of integration</div>
               <div class="para e558"> Let us assume that for a given data format F three sets of rules have been
                  defined: 
                  <div class="variablelist e559">
                     <div class="varlistentry e560">
                        <div class="term e561">R1</div>
                        <div class="listitem e562">
                           <div class="para e563">Rules how to map an instance of F to a node tree</div>
                        </div>
                     </div>
                     <div class="varlistentry e564">
                        <div class="term e565">R2</div>
                        <div class="listitem e566">
                           <div class="para e567">Rules how to map a node tree to an instance of F</div>
                        </div>
                     </div>
                     <div class="varlistentry e568">
                        <div class="term e569">R3</div>
                        <div class="listitem e570">
                           <div class="para e571">Rules how to decide whether a given node tree can or cannot be
                              mapped to an instance of F 
                           </div>
                        </div>
                     </div>
                  </div> And let us further assume that these rules satisfy two
                  conditions: 
                  <div class="variablelist e572">
                     <div class="varlistentry e573">
                        <div class="term e574">C1</div>
                        <div class="listitem e575">
                           <div class="para e576">For any format instance G: R1(G) satisfies R3</div>
                        </div>
                     </div>
                     <div class="varlistentry e577">
                        <div class="term e578">C2</div>
                        <div class="listitem e579">
                           <div class="para e580">For any R3-conformant node tree N: R1(R2(N)) is deep-equal to
                              N
                           </div>
                        </div>
                     </div>
                  </div> where 
                  <div class="code e581">R1(G)</div> denotes the result of applying R1 to a
                  format instance G and 
                  <div class="code e582">R2(N)</div> denotes the result of applying R2 to a
                  node tree N. 
               </div>
               <div class="para e583"> C1 and C2 imply a constraint concerning round-tripping which starts with a
                  format instance G: the result is a format instance G' which is not necessarily
                  equal G but which is "FORMAT-deep-equal": R1(G) is deep-equal R1(G'). This
                  amounts to defining the information content of a format instance G: it is the
                  node tree provided by R1. Relying on this definition of information content,
                  instances of F can be safely evaluated or modified by evaluating or modifying
                  the corresponding node tree. This is the foundation of an integration of format
                  F into the info space. 
               </div>
               <div class="para e584"> A normative definition of rule sets R1, R2 and R3 enables the standardized
                  integration of a non-XML format into the info space. This requires two
                  extensions of the XML standards. The first extension is an XPath function which
                  parses an instance of the format into a node tree, reflecting R1. The second
                  change extends the XML serialization model [
                  <div class="xref e585" linkend="w3c-serialization"></div>]
                  by the definition of a serialization to format F, reflecting R2 and R3. The
                  interface of serialization is accordingly extended by an additional value of the
                  serialization parameter 
                  <div class="code e586">model</div>. 
               </div>
               <div class="para e587"> A concrete proposal for the required XPath function is the introduction of a
                  second variant of 
                  <div class="code e588">fn:doc</div> which has an additional parameter
                  specifying the source data format:
                  
                  <div class="programlisting e589" xml:space="preserve">   fn:doc($uri as xs:string, $mediaType as xs:string) as document-node()</div>
                  Assuming that rule sets have been standardized for the formats HTML, JSON, CSV,
                  SQL and CSS, access to non-XML resources might look like this:
                  
                  <div class="programlisting e590" xml:space="preserve">   fn:doc("http://example.com/foo.htm", "htm")
                     fn:doc("http://example.com/foo.jsn", "jsn")                        
                     fn:doc("http://example.com/foo.csv", "csv")
                     fn:doc("http://example.com/foo.sql", "sql")
                     fn:doc("http://example.com/foo.css", "css")
                  </div>
                  The following sections explore how the rule sets govering parsing and
                  serialization may be defined. 
               </div>
            </div><a name="VocabularybasedintegrationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e591">
               <div class="title e592">Vocabulary based integration</div>
               <div class="para e593"> Domain-specific languages (like SQL) and non-recursive generic formats (like
                  CSV) may be represented by a particular XML vocabulary. The formal definition of
                  such a vocabulary might comprise an XSD and a (possibly empty) set of additional
                  constraints expressible as XPath assertions. As a simple example, the vocabulary
                  for representing CSV data might be defined as a schema containing element
                  declarations with names like "table", "row" and "cell" as well as type
                  definitions constraining a 
                  <div class="code e594">table</div> element to have only
                  
                  <div class="code e595">row</div> children and 
                  <div class="code e596">row</div> elements to have only
                  
                  <div class="code e597">cell</div> children. An additional constraint might prescribe that
                  every 
                  <div class="code e598">row</div> element has the same number of cell children:
                  
                  <div class="programlisting e599" xml:space="preserve">   count(distinct-values(//row/count(cell))) eq 1</div>
                  As a second example, an SQL vocabulary might contain a specific element for each
                  SQL statement, with a content model designed to capture all information which
                  the SQL syntax may convey. 
               </div>
               <div class="para e600"> Wiki dialects are non-XML formats representing a node vocabulary (XHTML). The
                  motivation is of course not integration into the info space, but access to a
                  rendering processor. And here a format was added to an existing node vocabulary,
                  whereas integration adds a node vocabulary to an existing format. Nevertheless,
                  it is interesting to notice the popularity which a non-XML/HTML representation
                  of node trees can attain. Standardization work might take this phenomenon into
                  consideration. 
               </div>
            </div><a name="VocabularyassistedintegrationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e601">
               <div class="title e602">Vocabulary-assisted integration</div>
               <div class="para e603">Vocabulary-based integration is natural for formats which do not themselves
                  generate vocabularies as JSON does. Such a generative format might in principle
                  be mapped to a fixed XML vocabulary, by mapping the names supplied by the format
                  instance to XML 
                  <div class="emphasis e604" role="ital">data</div>, rather than to XML names.
                  However, if the format has a recursive structure – like JSON – the resulting XML
                  would look unnatural and be inconvenient to evaluate. Such a mapping would have
                  very limited practical value, and it would violate the concept of integration as
                  explained in 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e605" linkend="generic-pattern-of-integration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">
                     
                     <div class="emphasis e606" role="under">a generic pattern of integration</div>
                  </div>.
                  The concept is based on regarding non-XML formats as alternative representations
                  of node trees, as if the node trees were the original information and the format
                  were a means to capture this information. If the node tree looks unnatural, the
                  image presupposes the desire to convey information which is unnaturally
                  structured in the first place, which is absurd. 
               </div>
               <div class="para e607"> If JSON is redefined to be the representation of node trees, these node trees
                  should probably capture JSON names by node names. Several approaches of mapping
                  JSON to XML have done that as far as possible (e.g. [
                  <div class="xref e608" linkend="couthures"></div>], [
                  <div class="xref e609" linkend="basex-json"></div>], [
                  <div class="xref e610" linkend="hunter"></div>], [
                  <div class="xref e611" linkend="lee"></div>], [
                  <div class="xref e612" linkend="pemberton"></div>]) but they could not achieve
                  two goals: 
                  <div class="itemizedlist e613">
                     <div class="listitem e614">
                        <div class="para e615">Represent any JSON name by an equal node name</div>
                     </div>
                     <div class="listitem e616">
                        <div class="para e617">Renounce the use of XML nodes containing JSON-related control
                           information
                        </div>
                     </div>
                  </div> The first problem arises from the fact that XML names are
                  QNames. The second problem reflects a mismatch of data models: whereas JSON uses
                  two distinct content models, one a map and the other a sequence of anonymous
                  items, XML has a single content model which is sequence-and-name based. The XML
                  model can be used to emulate the JSON models, but it cannot express them
                  natively. Those mapping approaches might be classified as vocabulary-assisted:
                  the bulk of items is named after their JSON counterparts, but a small additional
                  vocabulary is used in order to specify relationships between the nodes and their
                  JSON counterparts. These additional items prevent an evaluation of the node tree
                  from ignoring representations and only seeing the node tree itself. 
               </div>
            </div><a name="NativeintegrationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e618">
               <div class="title e619">Native integration</div>
               <div class="para e620"> JSON is, like XML, recursively defined and generates vocabularies. The ideal
                  way to integrate it into the info space would be native integration: every JSON
                  instance should be the representation of a node tree which natively expresses
                  the JSON content, so that it can be serialized to JSON based on the node
                  properties only, without requiring the presence of additional nodes guiding the
                  serialization. Native integration of JSON is not possible due to differences of
                  the XML and JSON data models: the XML model is 
                  <div class="emphasis e621" role="ital">not</div> a superset of the JSON model. 
               </div>
            </div>
         </div><a name="TheextensionofXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e622">
            <div class="title e623">The extension of XML</div>
            <div class="para e624">JSON is a very popular generic markup language. If the XML data model is not a
               superset of the JSON model, it must be questioned if the XML data model is qualified
               to define the info space - an information architecture not tied to a particular
               markup language. The XML data model is very expressive and allows representing
               virtually any tree-structured data as long as each node cannot have more than one
               parent. But in three cases (at least) a given structure must be emulated, rather
               than be expressed natively. Calling the data to be represented a source tree
               composed of nodes, these are: 
               <div class="orderedlist e625">
                  <div class="listitem e626">
                     <div class="para e627">If a source node has a name which is not a valid QName, the XML node
                        has a different name.
                     </div>
                  </div>
                  <div class="listitem e628">
                     <div class="para e629"> If a source node is anonymous, the XML node must nevertheless have a
                        name. 
                     </div>
                  </div>
                  <div class="listitem e630">
                     <div class="para e631"> If a source node has unordered content, the XML node cannot avoid
                        adding the information of a particular order – the data model does not
                        allow “switching off” the meaningfulness of order. 
                     </div>
                  </div>
               </div> The emulation may deal with arbitrary names either by mapping the
               original name to an NCName or by shifting the source name into data (e.g. an
               attribute). Anonymous nodes can be represented by nodes with an arbitrary name. The
               insignificance of order can be conveyed by out-of-band information. As long as one
               can start and end with XML, these workarounds are not perceived as serious issues.
               Likewise, as long as an initial JSON representation can be permanently replaced by
               XML, there is also no problem as the emulation provides semantic equivalence. But
               if
               there is a need to 
               <div class="emphasis e632" role="ital">maintain</div> a relationship between
               node tree and JSON representation, one discovers that there is no way to natively
               express arbitrary JSON data by an XML node tree. 
            </div>
            <div class="para e633"> (2) and (3) amount to a mismatch between XML and the dominant content model used
               in programming languages: which is a choice between sequence-based (an "array" of
               anonymous items) and key-based content ("map", "hash", etc.: an unordered collection
               of keyed items). XML has one single content model which is a curious hybrid:
               sequence+name based, which means the content is always ordered (array-like), but
               each sequence item has a name, which is key-like but not a key, as it is not
               required to be unique among the siblings. 
            </div>
            <div class="para e634"> The fact that virtually any tree-structured information can be emulated in XML
               has encouraged the view that the content model is sufficient. The fact that the
               content model is not as generic as it seems on first sight – that it is incapable
               of
               expressing natively arrays, maps and string-based names – has not yet caught much
               attention. This might change if the concept of an info space gains momentum. The
               concept implies a certain shift of priorities, attaching importance to a native
               representation of non-XML resources by the XML data model. Such a representation is
               required for seamless navigation: navigation which sees the information content (the
               model instance) and is unaware of future or past representations. 
            </div><a name="ExtensionoftheXMLdatamodelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e635">
               <div class="title e636">Extension of the XML data model</div>
               <div class="para e637"> Rennau [
                  <div class="xref e638" linkend="rennau"></div>] proposed an extension of the XML data model
                  which claims to enable a native representation of JSON data. The proposal
                  introduces the same boolean choice of content organization as is used in common
                  programming language like Java: a choice between the sequence based model (which
                  is the only model in current XML) and an alternative model which is truly
                  map-based: the child elements are unordered, and every child element has a
                  string-typed key – which is a new node property, [key]. The choice between the
                  two content models is made by each complex element, and therefore it is modeled
                  as a second new node property, [model]. It has two values, "sequence" and "map",
                  and the relationship between the two new properties is constrained as follows:
                  (a) an element with a non-null [key] must have a parent element with [model]
                  equal "map"; (b) an element with a null [key] must not have a parent element
                  with [model] equal "map". In other words: "map" elements have unordered children
                  which must have keys, and "sequence" elements have ordered children which must
                  not have keys.
               </div>
               <div class="para e639"> Concerning the handling of anonymous items, Rennau proposed the introduction
                  of "unspecific standard names", but this is unsatisfactory, as it renounces the
                  goal of a genuinely native representation: the only natural representation of an
                  anonymous item is an anonymous item. Therefore we should modify the XML data
                  model by allowing anonymous elements. A JSON array would thus be an elegant
                  representation of an element node with [model] equal "sequence" and anonymous
                  child elements. 
               </div>
               <div class="para e640"> In summary, the following extensions of the XML data model should be
                  considered, as they promise to overcome the limitations which disqualify the
                  model as foundation of the info space: (a) addition of two new node properties,
                  [model] and [key]; (b) modification of the property [node-name], introducing the
                  possibility of a null value. 
               </div>
            </div><a name="ExtensionoftheXMLsyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e641" xml:id="extension-xml-syntax">
               <div class="title e642">Extension of the XML syntax</div>
               <div class="para e643"> Introducing new node properties implies the necessity to define the
                  representation of these properties in XML syntax. Rennau proposed the use of
                  "pseudo attributes" which look like attributes but do not represent attribute
                  nodes, as they represent node properties: 
                  <div class="itemizedlist e644">
                     <div class="listitem e645">
                        <div class="para e646">udl:model - indicates the value of the [model] property</div>
                     </div>
                     <div class="listitem e647">
                        <div class="para e648">udl:key - indicates the value of the [key] property</div>
                     </div>
                  </div> where the prefix "udl" stands for "unified document language".
                  As a consequence, however, the XML representation of a JSON instance tends to be
                  cluttered with pseudo-attributes, which is perhaps a less important disadvantage
                  as it may seem, as the processing of JSON-supplied data is as elegant as the
                  processing of XML-supplied data (see below, 
                  <div class="emphasis e649" role="under">
                     <div class="xref e650" linkend="xml-extension-xpath"></div>
                  </div>) and the very info space
                  architecture encourages the use of JSON notation whereever it seems more
                  attractive than XML notation (see below, 
                  <div class="emphasis e651" role="under">
                     <div class="xref e652" linkend="markup-integration"></div>
                  </div>) . 
               </div>
               <div class="para e653"> However, a refusal to express the new node properties with the same
                  immediateness as the other properties is unsatisfactory. Pseudo-attributes are
                  an adequate representation of a node property when they can be expected to be
                  rare, as for example 
                  <div class="code e654">xml:type</div> attributes. However, knowing in
                  advance that the XML representation of JSON-supplied data will produce XML
                  documents which are studded with pseudo-attributes - rendering them hardly
                  readable - we are motivated to go a step further and truly extend the XML
                  syntax, introducing new syntax constructs. The goal is to ensure readable XML
                  representations also of such node trees as are constructed from JSON instances.
                  The following syntax extensions should therefore be considered: 
                  <div class="itemizedlist e655">
                     <div class="listitem e656">
                        <div class="para e657"> A special character preceding an element name indicates that its
                           [model] is "map", rather than "sequence". Example: &lt;~foo&gt; 
                        </div>
                     </div>
                     <div class="listitem e658">
                        <div class="para e659"> The key can be expressed within the element tag by the quoted key
                           value. Example: &lt;foo "2012"&gt; 
                        </div>
                     </div>
                     <div class="listitem e660">
                        <div class="para e661"> Anonymous elements which do not have a key use instead of an
                           element name a special character. Example: &lt;*&gt; 
                        </div>
                     </div>
                     <div class="listitem e662">
                        <div class="para e663"> Anonymous elements which do have a key are represented by
                           shifting the quoted key value to the beginning of the tag. Example:
                           &lt;"2012"&gt; 
                        </div>
                     </div>
                  </div> These rules would allow an acceptable representation of JSON
                  data in XML syntax. A special advantage is that a given information content –
                  e.g. a web service response – might then be served 
                  <div class="emphasis e664" role="ital">without
                     changes
                  </div> alternatively in JSON or XML. Example: 
                  <div class="programlisting e665" xml:space="preserve">   &lt;~getWeatherResponse&gt;
                     &lt;"temperature min"&gt;28&lt;/"temperature min"&gt;
                     &lt;"temperature max"&gt;32&lt;/"temperature max"&gt; 
                     &lt;/~getWeatherResponse&gt;
                     
                     {
                     "temperature min" : 28,
                     "temperature max" : 32
                     }
                  </div> To round these considerations off, a further detail of Rennau's proposal
                  which concerns the XML syntax should be retained: for elements which have a
                  parent element with [model] equal "map", the key defaults to the local name.
                  Therefore, a slight modification of the above example would look like this: 
                  <div class="programlisting e666" xml:space="preserve">   &lt;~getWeatherResponse&gt;
                     &lt;temperatureMin&gt;28&lt;/temperatureMin&gt;
                     &lt;temperatureMax&gt;32&lt;/temperatureMax&gt; 
                     &lt;/~getWeatherResponse&gt;
                  </div> In this variant the child elements are not any more
                  anonymous but have a local name equal to the key. 
               </div>
            </div><a name="ExtensionoftheXPath/XQuerylanguageANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e667" xml:id="xml-extension-xpath" xreflabel="Extension of the XPath/XQuery language">
               <div class="title e668">Extension of the XPath/XQuery language</div>
               <div class="para e669"> Integration of non-XML resources into the info space is driven by the desire
                  to make them accessible to navigation and evaluation. The extension of the data
                  model by a new [key] property must therefore be mirrored by an extension of the
                  XPath semantics. Rennau proposed the introduction of a third node test, the "key
                  test" which functions in analogy to the name test: selecting elements with a
                  given key, rather than elements with a given name. Being a node test, the key
                  test is combined with navigational axes in the same way as a name test. The
                  syntax of a key test is a special character (proposed: "#") followed by the key
                  value within quotes. Examples:
                  
                  <div class="programlisting e670" xml:space="preserve">   $response/#"temperature min"
                     $response//#"2012"                        
                     $item/ancestor-or-self::#"AC#A-2917"
                  </div>
                  Thanks to the key test, JSON-supplied data can be navigated with the same ease
                  as XML-supplied data, using key tests to select among object members and
                  conventional numerical predicates to select among array items:
                  
                  <div class="programlisting e671" xml:space="preserve">   $response//#"weather"/#"temperatures"/*[3]</div>
                  
               </div>
               <div class="para e672"> Whereas the key test provides for navigation, Rennau also proposed an
                  extension of XQuery which enables the construction of nodes using JSON syntax.
                  The extension is purely syntactical: an additional syntax which is a JSON-style
                  shorthand notation for the construction of nodes which, due to their properties,
                  correspond to JSON objects and arrays. For example, the following XQuery
                  constructor: 
                  <div class="programlisting e673" xml:space="preserve">   &lt;*&gt;
                     &lt;"temperature min"&gt;{$min}&lt;/"temperature min"&gt;                        
                     &lt;"temperature max"&gt;{$max}&lt;/"temperature max"&gt;
                     &lt;"temperatures"&gt;{for $v in $values return &lt;*&gt;{$v}&lt;/*&gt;}&lt;/"temperatures"&gt;
                     &lt;/*&gt;
                  </div> can equivalently be written using JSON syntax: 
                  <div class="programlisting e674" xml:space="preserve">   {
                     "temperature min" : $min,
                     "temperature max" : $max,
                     "temperatures" : [ $values ]
                     }
                  </div> The XQuery construction of JSON data using JSON syntax is as convenient as
                  the construction of XML data using XML syntax. Taken together, the proposed
                  extensions of XPath and XQuery ensure a complete integration of JSON into the
                  info space: 
                  <div class="itemizedlist e675">
                     <div class="listitem e676">
                        <div class="para e677"> JSON instances can be navigated as easily as any other node
                           trees. 
                        </div>
                     </div>
                     <div class="listitem e678">
                        <div class="para e679"> JSON instances can be constructed using JSON syntax. </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div><a name="MarkupintegrationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e680" xml:id="markup-integration" xreflabel="Markup integration">
            <div class="title e681">Markup integration</div>
            <div class="para e682"> Every syntax which is defined to be the representation of a node tree might be
               integrated into XML markup. Provided that any section using non-XML syntax 
               <div class="itemizedlist e683">
                  <div class="listitem e684">
                     <div class="para e685">identifies the syntax it uses</div>
                  </div>
                  <div class="listitem e686">
                     <div class="para e687">is clearly delimited</div>
                  </div>
                  <div class="listitem e688">
                     <div class="para e689">appears in a place where a sequence of elements might appear</div>
                  </div>
               </div> the document text is guaranteed to be parsable into a node tree in
               an unambiguous way. Rennau proposed a restricted use of this new possibility which
               allows to provide 
               <div class="emphasis e690" role="ital">element contents</div> in non-XML
               syntax. The proposal is to introduce a pseudo-attribute (
               <div class="code e691">udl:markup</div>)
               which identifies the syntax used to encode the element content. As a consequence,
               the following text would be a valid XML document: 
               <div class="programlisting e692" xml:space="preserve">   &lt;~getWeatherResponse udl:markup="json"&gt;
                  "temperature min" : 28,
                  "temperature max" : 32
                  "temperatures" : [28, 28, 30, 32, 31]
                  &lt;/~getWeatherResponse&gt;
               </div> Note that the 
               <div class="code e693">getWeatherResponse</div> element
               has three child elements, as the content of an element with
               
               <div class="code e694">udl:markup='...'</div> is defined to be the nodes resulting from parsing
               the text found between start tag and end tag according to the parsing rules for
               format '...'. 
            </div>
         </div>
      </div><a name="WrappingupANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e695">
         <div class="title e696">Wrapping up</div>
         <div class="para e697"> The info space is an information architecture consisting of distributed resources
            whose information content is defined to be a node tree, understood as an instance
            of the
            (slightly extended) XDM data model. The resources are identified by URIs and accessed
            by
            XPath functions (
            <div class="code e698">fn:doc</div>, 
            <div class="code e699">fn:httpDoc</div>, ...) which hide the
            actual data formats and expose the node structure. Taken together, the node structure
            of
            all accessible resources provides a uniform substrate for navigation and discovery.
            
         </div>
         <div class="para e700"> It should be noted that the concept of a "resource" as used in the info space model
            is different from the use in Fielding's REST model [
            <div class="xref e701" linkend="fielding"></div>]. The
            latter defines a resource as a conceptual unit whose mapping to concrete representations
            is a function of time. The resources of the info space are units of information which
            are 
            <div class="emphasis e702" role="ital">values</div>, precisely defined in terms of a node tree.
            As such, they are more closely related to Fielding's concept of a resource
            representation than to his concept of a resource. On the other hand, the insistence
            on a
            well-defined 
            <div class="emphasis e703" role="ital">information content</div> is in sharp contrast
            with Fielding's model, in which there is no place for such a thing. Resources of the
            info space are the accessible resource representations (in Fielding's sense) which
            can
            be resolved to a node tree. As such, the info space is a 
            <div class="emphasis e704" role="ital">snapshot</div> of all accessible resource representations (in Fielding's
            sense) which have a media type defined to represent a node tree, according to the
            standardizations endorsed by the W3C. 
         </div>
         <div class="para e705"> Fielding's REST model is aimed at an architecture for the internet, understood as
            a
            distributed hypermedia system. His view of resource navigation assumes a model of
            application behaviour in which the rendering of resource representations powers
            subsequent navigation by supplying embedded links. The info space model, on the other
            hand, is unconcerned with application behaviour and paints a picture in which nothing
            appears but information, aggregated into distinct resources and nevertheless coalesced
            into a single, homogeneous substrate of information. Embedded links are predefined
            point-to-point connections. The connectivity of the info space, however, relies on
            XPath
            navigation, which is like an ubiquitous field of possibility, potentially leading
            from
            anywhere to anywhere. Therefore the info space is not a net but more like a space:
            it
            integrates anything (any resource) appearing within it.
         </div>
         <div class="para e706"> The info space integrates information on a global scale, relying on a 
            uniform data model. The same can be said about RDF [
            <div class="xref e707" linkend="w3c-rdf"></div>]. 
            What is the relationship
            between the XML info space and RDF? RDF is about 
            
            <div class="emphasis e708" role="ital">semantic integration</div>,
            establishing the identities of real world resources described
            by the data. The RDF data model is designed to enable the
            assembling of distributed items into synthetic descriptions,
            which are organized by the identities of the described
            resources. 
         </div>
         <div class="para e709"> The XML info space, on the other hand, is about 
            
            <div class="emphasis e710" role="ital">navigational integration</div>, offering
            it as a possible foundation for semantic integration. The semantic integration
            is left to applications which are supposed to understand
            the trees they are dealing with as a coherent, structured unit - 
            rather than regarding them as a
            "mine" from which to undig self-contained items of information (triples).
            Such a dealing with 
            <div class="emphasis e711" role="ital">well-understood resources</div>
            is the typical task of conventional applications. They know
            what to do with, say, /a/b/c taken from one resource and with
            /x/y/z taken from another resource, and how they are related. 
            For such applications the benefit of simple and efficient 
            navigation is probably
            greater than the benefit of further aids how to find out those
            meanings and relationships. Therefore conventional
            applications 
            may profit from the navigational info space
            immensely and probably far less from the semantic space created by RDF.
            Nevertheless, there may be a wonderful synergy between the
            XML space and the RDF space yet to be explored.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e712">
         <div class="title e713">Bibliography</div>
         <div class="bibliomixed e714" xml:id="w3c-xpath" xreflabel="1">Berglund, Anders et al, eds. XML Path Language
            (XPath) 2.0 (Second Edition). W3C Recommendation 14 November 2010. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e715" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath20/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath20/</div>
         </div>
         <div class="bibliomixed e716" xml:id="w3c-xdm" xreflabel="2">Berglund, Anders et al, eds. XQuery 1.0 and
            XPath 2.0 Data Model (XDM) (Second Edition). W3C Recommendation 23 January 2007. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e717" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel/</div>
         </div>
         <div class="bibliomixed e718" xml:id="uri" xreflabel="3">Berners-Lee, Tim et al. Uniform Resource Identifier
            (URI): Generic Syntax. Network Working Group, Request for Comments: 3986. January
            2005.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e719" xlink:actuate="onRequest" xlink:href="http://tools.ietf.org/html/rfc3986" xlink:show="new" xlink:type="simple">http://tools.ietf.org/html/rfc3986</div>
         </div>
         <div class="bibliomixed e720" xml:id="w3c-xquery" xreflabel="4">Boag, Scott et al, eds. XQuery 1.0: An XML
            Query Language (Second Edition). W3C Recommendation 14 December 2010. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e721" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery/</div>
         </div>
         <div class="bibliomixed e722" xml:id="w3c-serialization" xreflabel="5">Boag, Scott et al, eds. XSLT 2.0 and
            XQuery 1.0 Serialization (Second Edition). W3C Recommendation 14 December 2010. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e723" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-xquery-serialization/</div>
         </div>
         <div class="bibliomixed e724" xml:id="w3c-xml" xreflabel="6">Bray, Tim et al, eds. Extensible Markup Language
            (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November 2008. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e725" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/REC-xml/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/REC-xml/</div>
         </div>
         <div class="bibliomixed e726" xml:id="couthures" xreflabel="7">Couthures, Alain. JSON for XForms - adding
            JSON support in XForms data instances. XML Prague 2011, Conference Proceedings, p.
            13-24. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e727" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</div>
            .
         </div>
         <div class="bibliomixed e728" xml:id="w3c-infoset" xreflabel="8">Cowan, John &amp; Tobin R., eds. XML
            Information Set (Second Edition). W3C Recommendation 4 February 2004. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e729" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-infoset/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml-infoset/</div>
         </div>
         <div class="bibliomixed e730" xml:id="w3c-xlink" xreflabel="9">DeRose, Steve et al, eds. XML Linking Language
            (XLink) Version 1.1. W3C Recommendation 6 May 2010. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e731" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xlink11/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xlink11/</div>
         </div>
         <div class="bibliomixed e732" xml:id="einstein" xreflabel="10">Einstein, Albert &amp; Infield, L. The
            evolution of physics. Edited by C.P. Snow. Cambridge University Press, ASIN: B000S52QZ4,
            1938 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e733" xlink:actuate="onRequest" xlink:href="http://archive.org/details/evolutionofphysi033254mbp" xlink:show="new" xlink:type="simple">http://archive.org/details/evolutionofphysi033254mbp</div>
            .
         </div>
         <div class="bibliomixed e734" xml:id="fielding" xreflabel="11">Fielding, Roy T. Architectural Styles and the
            Design of Network-based Software Architectures. Ph.D. Dissertation, University of
            California, Irvine, 2000. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e735" xlink:actuate="onRequest" xlink:href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" xlink:show="new" xlink:type="simple">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</div>
            .
         </div>
         <div class="bibliomixed e736" xml:id="basex-json" xreflabel="12">Gruen, Christian, et al. BaseX Documentation
            Version 7.3, section "JSON Module", p. 161-166. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e737" xlink:actuate="onRequest" xlink:href="http://docs.basex.org/wiki/Main_Page" xlink:show="new" xlink:type="simple">http://docs.basex.org/wiki/Main_Page</div>.
         </div>
         <div class="bibliomixed e738" xml:id="hunter" xreflabel="13">Hunter, Jason. A JSON facade on MarkLogic
            Server. XML Prague 2011, Conference Proceedings, p. 25-34. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e739" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e740" xml:id="lee" xreflabel="14">Lee, David A. JXON: an Architecture for Schema and
            Annotation Driven JSON/XML Bidirectional Transformations. Presented at Balisage: The
            Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. In Proceedings of
            Balisage: The Markup Conference 2011. Balisage Series on Markup Technologies, vol.
            7
            (2011). doi:
            <div class="biblioid doi e741">10.4242/BalisageVol7.Lee01</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e742" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</div>.
         </div>
         <div class="bibliomixed e743" xml:id="w3c-rdf" xreflabel="15">Manola, Frank &amp; Miller E., eds. RDF Primer. 
            W3C Recommendation 10 February 2004. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e744" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/rdf-primer/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/rdf-primer/</div>
         </div>
         <div class="bibliomixed e745" xml:id="pemberton" xreflabel="16">Pemberton, Steven. Treating JSON as a subset
            of XML. XML Prague 2012, Conference Proceedings, p. 81-90. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e746" xlink:actuate="onRequest" xlink:href="http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e747" xml:id="rennau" xreflabel="17">Rennau, Hans-Jürgen. "From XML to UDL: a unified
            document language, supporting multiple markup languages." Presented at Balisage: The
            Markup Conference 2012, Montréal, Canada, August 7 - 10, 2012. In Proceedings of
            Balisage: The Markup Conference 2012. Balisage Series on Markup Technologies, vol.
            8
            (2012). doi:
            <div class="biblioid doi e748">10.4242/BalisageVol8.Rennau01</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e749" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol8/html/Rennau01/BalisageVol8-Rennau01.html</div>.
         </div>
         <div class="bibliomixed e750" xml:id="xml-catalog" xreflabel="18">Walsh, Norman, ed. XML Catalogs. OASIS
            Standard V1.1, 7 October 2005. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e751" xlink:actuate="onRequest" xlink:href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html" xlink:show="new" xlink:type="simple">https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html</div>.
         </div>
         <div class="bibliomixed e752" xml:id="json" xreflabel="19">Web resource without source information:
            Introducing JSON. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e753" xlink:actuate="onRequest" xlink:href="http://json.org" xlink:show="new" xlink:type="simple">http://json.org</div>.
         </div>
      </div>
   </div>
</div>