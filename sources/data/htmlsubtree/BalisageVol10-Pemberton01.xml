<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#InvisibleXMLANCHOR" name="InvisibleXMLTOC">Invisible XML</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XMLand%0AAuthoringANCHOR" name="XMLand%0AAuthoringTOC">XML and
                  Authoring</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ParsingandParse%0AtreesANCHOR" name="ParsingandParse%0AtreesTOC">Parsing and Parse
                  trees</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheApproachANCHOR" name="TheApproachTOC">The Approach</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Syntax%0ADescriptionANCHOR" name="Syntax%0ADescriptionTOC">Syntax
                  Description</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TerminalsANCHOR" name="TerminalsTOC">Terminals</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExtensionsANCHOR" name="ExtensionsTOC">Extensions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Parsing%0AAlgorithmsANCHOR" name="Parsing%0AAlgorithmsTOC">Parsing
                  Algorithms</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DeliveryANCHOR" name="DeliveryTOC">Delivery</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Using%0AInvisibleXMLtodefineitselfANCHOR" name="Using%0AInvisibleXMLtodefineitselfTOC">Using
                  Invisible XML to define itself</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Alternative%0ARepresentationANCHOR" name="Alternative%0ARepresentationTOC">Alternative
                  Representation</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExtrasANCHOR" name="ExtrasTOC">Extras</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Restriction%0AontheXMLProducedANCHOR" name="Restriction%0AontheXMLProducedTOC">Restriction
                  on the XML Produced</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RoundtrippingANCHOR" name="RoundtrippingTOC">Roundtripping</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">alternative</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">definition</div>
         <div class="singletermTERMS">do</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">everything?</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">Invisible XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">must</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">name="color"</div>
         <div class="singletermTERMS">nothing</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">one-or-more</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">properties</div>
         <div class="singletermTERMS">property</div>
         <div class="singletermTERMS">particular</div>
         <div class="singletermTERMS">per se</div>
         <div class="singletermTERMS">Pemberton</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">rules</div>
         <div class="singletermTERMS">rule</div>
         <div class="singletermTERMS">real</div>
         <div class="singletermTERMS">refinement</div>
         <div class="singletermTERMS">Researcher</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">steven.pemberton@cwi.nl</div>
         <div class="singletermTERMS">Steven</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">use</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
         <div class="singletermTERMS">zero-or-more</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="InvisibleXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Invisible XML</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2013</div>
            <div class="confdates e5">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">What if you could see everything as XML? XML has many
               strengths for data exchange, strengths both inherent in the nature
               of XML markup and strengths that derive from the ubiquity of tools
               that can process XML. For authoring, however, other forms are
               preferred: no one writes CSS or Javascript in XML. It does not
               follow, however, that there is no value in representing such
               information in XML. 
               <div class="emphasis e8">Invisible XML</div> is a method
               for treating non-XML documents as if they were XML, enabling
               authors to write in a format they prefer while providing XML for
               processes that are more effective with XML content. There is really
               no reason why XML cannot be more ubiquitous than it is.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Steven</div>
               <div class="surname e12">Pemberton</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14"></div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Researcher</div>
               <div class="orgname e17">CWI, Amsterdam</div>
            </div>
            <div class="email e18">steven.pemberton@cwi.nl</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright Â© Steven Pemberton 2013, all rights reserved.</div>
         </div>
      </div><a name="XMLand%0AAuthoringANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e21" xml:id="XML_and_Authorin">
         <div class="title e22">XML and
            Authoring
         </div>
         <div class="para e23">XML is a popular format. It is widely and successfully used
            for document and data storage, exchange and presentation. A major
            advantage of using XML is the toolchain and pipeline available for
            generic XML processing. You can easily use new formats within the
            generic framework.
         </div>
         <div class="para e24">However, for authoring purposes XML is seldom preferred over
            a notation more directly suited to the purpose. Few would prefer to
            write their CSS rules as
         </div>
         <div class="programlisting e25" xml:space="preserve">
            &lt;rule&gt;&lt;simple-selector name="body"/&gt;&lt;block&gt;&lt;property name="color" value="blue"/&gt;&lt;/block&gt;&lt;/rule&gt;
            
         </div>
         <div class="para e26">to the more direct</div>
         <div class="programlisting e27" xml:space="preserve">
            body {color: blue}
            
         </div>
         <div class="para e28">and even less would prefer to write</div>
         <div class="programlisting e29" xml:space="preserve">
            &lt;statement&gt;&lt;if&gt;&lt;condition&gt;&lt;comparison name="&amp;lt;"&gt;&lt;var name="max"&gt;&lt;var name="a"&gt;&lt;/comparison&gt;&lt;/condition&gt;&lt;then&gt;&lt;statement&gt;&lt;assign&gt;&lt;var
            name="max"/&gt;&lt;expression&gt;&lt;var name="a"/&gt;&lt;/expression&gt;&lt;/assign&gt;&lt;/statement&gt;&lt;/then&gt;&lt;/if&gt;&lt;/statement&gt;
            
         </div>
         <div class="para e30">to the much more direct</div>
         <div class="programlisting e31" xml:space="preserve">
            if (max&lt;a) then max=a;
            
         </div>
         <div class="para e32">And, of course it should be noted that even RELAX NG has both
            an XML syntax and a 'compact' syntax 
            <div class="xref e33" linkend="RelaxNG"></div> 
            <div class="xref e34" linkend="RelaxNGCOMPACT"></div>.
         </div>
         <div class="para e35">In fact if we are to be brutally honest, even XML formats
            take short cuts for authoring ease. Take for instance an
            
            <div class="code e36">&lt;a&gt;</div> element in XHTML:
         </div>
         <div class="programlisting e37" xml:space="preserve">
            &lt;a href="http://www.w3.org/TR/1999/xhtml"&gt;XHTML&lt;/a&gt;
            
         </div>
         <div class="para e38">This does not surface the 
            <div class="emphasis e39">real</div> structure
            of the underlying data. If we were to be completely faithful to the
            principle of making all relevant structure explicit, we should
            really write something along the lines of
         </div>
         <div class="programlisting e40" xml:space="preserve">
            &lt;a&gt;&lt;href&gt;&lt;method type="href"/&gt;&lt;domain name="org"/&gt;&lt;site name="w3"/&gt;&lt;sub name="www"/&gt;&lt;path&gt;&lt;root&gt;&lt;sub
            name="TR"&gt;&lt;sub name="1999"&gt;&lt;sub name="xhtml"&lt;/sub&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/root&gt;&lt;/path&gt;&lt;/href&gt;&lt;text&gt;XHTML&lt;/text&gt;&lt;/a&gt;
            
         </div>
         <div class="para e41">You might argue about the details here, but this example is
            only to show that there are parts of XML documents that could be
            further structured, but that we choose not to, possibly for
            authoring ease, possibly for fear of being laughed out of
            town.
         </div>
         <div class="para e42">The reasons for this are obvious: despite the disadvantages
            of not being able to use the generic toolchain any more, or only to
            a lesser degree, the increased readability of the source, and its
            closer relation to the problem domain makes authoring so much
            easier.
         </div>
      </div><a name="ParsingandParse%0AtreesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e43" xml:id="Parsing_and_Parse_tree">
         <div class="title e44">Parsing and Parse
            trees
         </div>
         <div class="para e45">Part of the advantage of XML is that there is a single parser
            needed to be able to deal with any kind of document. This can be
            contrasted with for instance the situation for HTML, where you need
            a parser for the HTML, with separate parsers for CSS and Javascript
            at least, (and URLs), creating extra complexity and
            brittleness.
         </div>
         <div class="para e46">But looked at through a suitable pair of glasses, what is XML
            apart from a description of a parse tree for some format (with some
            special treatment for text nodes)? And frankly, what is so
            difficult about general-purpose parsing? It is a widely understood
            and easily solved problem. Is it not possible to combine the best
            of both worlds, and have authorable formats, that can still use the
            XML tool chain? Couldn't XML become the underlying format for
            
            <div class="emphasis e47">everything?</div>
         </div>
      </div><a name="TheApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e48" xml:id="The_Approac">
         <div class="title e49">The Approach</div>
         <div class="para e50">The approach presented here is to add one more step to the
            XML processing chain, an initial one. This step takes any textual
            document, and a (reference to) a suitable syntax description,
            parses the document using the syntax description, and produces as
            output a parse tree that can be treated as an XML document with no
            further parsing necessary (or alternatively, the document can be
            serialised out to XML).
         </div>
         <div class="para e51">In other words, the input document might be</div>
         <div class="programlisting e52" xml:space="preserve">
            body {color: blue}
            
         </div>
         <div class="para e53">but the result of the parse will be the same as if an XML
            parser had been presented with the XML document
         </div>
         <div class="programlisting e54" xml:space="preserve">
            &lt;css&gt;
            &lt;rule&gt;&lt;simple-selector name="body"/&gt;
            &lt;block&gt;&lt;property name="color" value="blue"/&gt;&lt;/block&gt;
            &lt;/rule&gt;
            &lt;/css&gt;
            
         </div>
         <div class="para e55">We call this method 
            <div class="emphasis e56">Invisible XML</div>, since
            the document is treated as XML, but it is not visibly an XML
            document.
         </div>
      </div><a name="Syntax%0ADescriptionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e57" xml:id="Syntax_Descriptio">
         <div class="title e58">Syntax
            Description
         </div>
         <div class="para e59">The requirement is to find a suitable way to describe the
            syntax of the input document so that the resultant parse-tree is of
            the form suitable for use in our XML chain. If we were to use BNF
            
            <div class="xref e60" linkend="BNF"></div>, arguably the most well-known syntax-description format, it
            might look like this (in what follows "..." is used for parts of
            the definition that have been elided and will be defined
            later):
         </div>
         <div class="programlisting e61" xml:space="preserve">
            &lt;css&gt; ::= &lt;rules&gt;
            &lt;rules&gt; ::= &lt;rule&gt; | &lt;rules&gt; &lt;rule&gt;
            &lt;rule&gt; ::= &lt;selector&gt; &lt;block&gt;
            &lt;block&gt; ::= "{" &lt;properties&gt; "}"
            &lt;properties&gt; ::= &lt;property&gt; | &lt;property&gt; ";" &lt;properties&gt;
            &lt;property&gt; ::= &lt;name&gt; ":" &lt;value&gt; | &lt;empty&gt;
            &lt;selector&gt; ::= &lt;name&gt;
            
         </div>
         <div class="para e62">etc, etc. But it is quickly apparent that this has some
            shortcomings. Firstly a surface problem that since we are using
            this for XML, we could quickly go crazy with the use of angle
            brackets for two different purposes. Although there is a certain
            charm to defining the 
            <div class="code e63">&lt;css&gt;</div> element with a
            syntax rule whose name is 
            <div class="code e64">&lt;css&gt;</div>, let us
            rather use a different format. Therefore we shall use a variant of
            VWG format  
            <div class="xref e65" linkend="VWG"></div>. This looks like:
         </div>
         <div class="programlisting e66" xml:space="preserve">
            css: rules.
            rules: rule; rules, rule.
            rule: selector, block.
            block: "{", properties, "}".
            properties:  property; property, ";", properties.
            property:  name, ":", value; empty.
            selector: name.
            name: ...
            value: ...
            empty: .
            
         </div>
         <div class="para e67">(We shall restrict ourselves to a simplified CSS grammar for
            the sake of this article).
         </div>
         <div class="para e68">Note that ";" signifies alternatives, and as is normal in
            syntax definitions, if one alternative is empty (or reduces to
            empty), the rule is optional.
         </div>
         <div class="para e69">If we parse the snippet of CSS above with this, and then
            represent the resulting parse tree in an XML style (so that each
            nonterminal is represented as an XML element), a second problem
            becomes apparent:
         </div>
         <div class="programlisting e70" xml:space="preserve">
            &lt;css&gt;
            &lt;rules&gt;
            &lt;rule&gt;
            &lt;selector&gt;body&lt;/selector&gt;
            &lt;block&gt;
            &lt;properties&gt;
            &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            &lt;/properties&gt;
            &lt;/block&gt;
            &lt;/rule&gt;
            &lt;/rules&gt;
            &lt;/css&gt;
            
         </div>
         <div class="para e71">namely that there are certain elements in the tree
            (
            <div class="code e72">rules</div>, 
            <div class="code e73">properties</div>) that we
            really aren't interested in. (You'll notice that some terminal
            symbols such as the brackets, colons and semicolons don't appear in
            the parse tree. This will be discussed later).
         </div>
         <div class="para e74">The problem becomes even more apparent with a CSS snippet
            like
         </div>
         <div class="programlisting e75" xml:space="preserve">
            body {color: blue; font-weight: bold}
            
         </div>
         <div class="para e76">since the content of the 
            <div class="code e77">&lt;block&gt;</div>
            element then becomes even more unwieldly:
         </div>
         <div class="programlisting e78" xml:space="preserve">
            &lt;properties&gt;
            &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            &lt;properties&gt;
            &lt;property&gt;
            &lt;name&gt;font-weight&lt;/name&gt;
            &lt;value&gt;bold&lt;/value&gt;
            &lt;/property&gt;
            &lt;/properties&gt;
            &lt;/properties&gt;
            
         </div>
         <div class="para e79">where we would prefer to see the much more direct</div>
         <div class="programlisting e80" xml:space="preserve">
            &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            &lt;property&gt;
            &lt;name&gt;font-weight&lt;/name&gt;
            &lt;value&gt;bold&lt;/value&gt;
            &lt;/property&gt;
            
         </div>
         <div class="para e81">The problem arises in this case because the syntax
            description method relies on recursion to deal with repetition. To
            that end, we shall introduce a specific notation for repetition.
            Zero or more repetitions:
         </div>
         <div class="programlisting e82" xml:space="preserve">
            (rule)*
            
         </div>
         <div class="para e83">and one or more repetitions:</div>
         <div class="programlisting e84" xml:space="preserve">
            (rule)+
            
         </div>
         <div class="para e85">In fact we shall extend these two postfix operators to also
            act as infix operators, to handle a commonly occurring case:
         </div>
         <div class="programlisting e86" xml:space="preserve">
            (property)*";"
            (property)+";"
            
         </div>
         <div class="para e87">which respectively mean "zero or more, separated by
            semicolon" and "one or more, separated by semicolon" (there is no
            reason to restrict the separator to a terminal as here; it may also
            be a nonterminal).
         </div>
         <div class="para e88">Now we can specify our syntax as:</div>
         <div class="programlisting e89" xml:space="preserve">
            css: (rule)*.
            rule: selector, block.
            block: "{", (property)*";", "}".
            property:  name, ":", value; .
            name: ...
            value: ...
            
         </div>
         <div class="para e90">and the parsetree will now look like this:</div>
         <div class="programlisting e91" xml:space="preserve">
            &lt;css&gt;
            &lt;rule&gt;
            &lt;selector&gt;body&lt;/selector&gt;
            &lt;block&gt;
            &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            &lt;property&gt;
            &lt;name&gt;font-weight&lt;/name&gt;
            &lt;value&gt;bold&lt;/value&gt;
            &lt;/property&gt;
            &lt;/block&gt;
            &lt;/rule&gt;
            &lt;/css&gt;
            
         </div>
         <div class="para e92">However, there is another reason why we might not want a
            syntax rule name to appear in the parse tree, and that is when we
            use a syntax rule as a 
            <div class="emphasis e93">refinement</div>, that is to
            say, when the syntax rule doesn't represent anything of semantic
            importance, but has been defined so that we can use it in several
            places without having to repeat it. For instance, suppose we wanted
            to define a series of properties in a separate rule:
         </div>
         <div class="programlisting e94" xml:space="preserve">
            properties: (property)*";".
            
         </div>
         <div class="para e95">and use it:</div>
         <div class="programlisting e96" xml:space="preserve">
            block: "{", properties, "}".
            
         </div>
         <div class="para e97">but not want 
            <div class="code e98">&lt;properties&gt;</div> to appear
            in the final parse tree. What we define is that the use of any rule
            name preceded by a minus sign is only being used for refinement. So
            that would give us:
         </div>
         <div class="programlisting e99" xml:space="preserve">
            properties: (property)*";".
            block: "{", -properties, "}".
            
         </div>
         <div class="para e100">and this would result in the same parse-tree as above. Note
            that this still allows a rule to be used in other places and appear
            in the parse tree if needed.
         </div>
         <div class="para e101">Also note that for simplicity we have ignored treating spaces
            in the syntax description, but that is also an example of something
            you would not want to have in the parse tree:
         </div>
         <div class="programlisting e102" xml:space="preserve">
            colon: -spaces, ":", -spaces.
            spaces: " "*.
            
         </div>
         <div class="para e103">Similarly, we can use it to make empty alternatives more
            explicit:
         </div>
         <div class="programlisting e104" xml:space="preserve">
            property:  name, ":", value; -empty.
            
         </div>
         <div class="programlisting e105" xml:space="preserve">
            empty: .
            
         </div>
      </div><a name="TerminalsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e106" xml:id="Terminal">
         <div class="title e107">Terminals</div>
         <div class="para e108">As alluded to above, in general, terminal symbols do not
            appear in the parse-tree, since most of them are only there to
            delimit structural elements in the source file. If you want them to
            show up, you can add an explicit rule for them:
         </div>
         <div class="programlisting e109" xml:space="preserve">
            colon: ":".
            
         </div>
         <div class="para e110">which will cause them to show up in the tree like
            this:
         </div>
         <div class="programlisting e111" xml:space="preserve">
            &lt;property&gt;
            &lt;name&gt;color&lt;/name&gt;
            &lt;colon/&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            
         </div>
         <div class="para e112">However, there are places where terminals have semantic
            meaning, and you 
            <div class="emphasis e113">do</div> want them to appear in the
            parse-tree, for instance in our example the names and values of the
            properties. To achieve this we mark terminals that are to be copied
            to the parse tree specially:
         </div>
         <div class="programlisting e114" xml:space="preserve">
            name: (+"a"; +"b"; ...etc...; +"9"; +"-")+.
            
         </div>
         <div class="para e115">In other words, normally terminals are discarded, but if they
            are preceded with a + they are copied to the parse-tree.
         </div>
      </div><a name="ExtensionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e116" xml:id="Extension">
         <div class="title e117">Extensions</div>
         <div class="para e118">Strictly speaking, this would be enough to allow you to parse
            a document, and output it as an equivalent XML document. However,
            there are possible extensions that give you a little more control
            over the result. The most obvious is allowing the specification of
            attributes. This is simply done by marking the use of rules with at
            signs:
         </div>
         <div class="programlisting e119" xml:space="preserve">
            css: (rule)*.
            rule: selector, block.
            block: "{", (property)*";", "}".
            property:  @name, ":", value.
            
         </div>
         <div class="para e120">A rule used like this may clearly not contain any structural
            elements (though it may contain terminals and refinements), since
            attributes are not structured, but this is an easy condition to
            check for. The parsetree will now look like this:
         </div>
         <div class="programlisting e121" xml:space="preserve">
            &lt;css&gt;
            &lt;rule&gt;
            &lt;selector&gt;body&lt;/selector&gt;
            &lt;block&gt;
            &lt;property name="color"&gt;
            &lt;value&gt;blue&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name="font-weight"&gt;
            &lt;value&gt;bold&lt;/value&gt;
            &lt;/property&gt;
            &lt;/block&gt;
            &lt;/rule&gt;
            &lt;/css&gt;
            
         </div>
         <div class="para e122">If we changed the rule for 
            <div class="code e123">property</div> to
            look like this:
         </div>
         <div class="programlisting e124" xml:space="preserve">
            property:  @name, ":", @value.
            
         </div>
         <div class="para e125">then the resultant parse-tree would look like</div>
         <div class="programlisting e126" xml:space="preserve">
            &lt;css&gt;
            &lt;rule&gt;
            &lt;selector&gt;body&lt;/selector&gt;
            &lt;block&gt;
            &lt;property name="color" value="blue"/&gt;
            &lt;property name="font-weight" value="bold"/&gt;
            &lt;/block&gt;
            &lt;/rule&gt;
            &lt;/css&gt;
            
         </div>
         <div class="para e127">Note that by marking the 
            <div class="emphasis e128">use</div> of a syntax
            rule in this way, and not the definition, it allows the syntax rule
            to be used for structural elements
            (
            <div class="code e129">&lt;name&gt;color&lt;/name&gt;</div>) as well as for
            attributes (
            <div class="code e130">name="color"</div>).
         </div>
      </div><a name="Parsing%0AAlgorithmsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e131" xml:id="Parsing_Algorithm">
         <div class="title e132">Parsing
            Algorithms
         </div>
         <div class="para e133">Although it would be possible to require the syntax to be
            restricted to some class of language, such as LL(1) or LR(1) 
            <div class="xref e134" linkend="LL1"></div>
            in order to make the parser faster, in practice it is easier for
            the author of the syntax if we make no such restriction, since it
            would require the author to understand the principles, and it would
            require the system to check that the syntax adhered to the
            requirement. In practise a parsing algorithm such as Earley's
            
            <div class="xref e135" linkend="Earley"></div> is fast enough, and will treat all context-free languages.
            The only remaining problem is if the syntax author describes an
            ambiguous language. To that end we just define that the parser
            outputs one of the parses, and leave it at that. For instance, if
            expression were defined as:
         </div>
         <div class="programlisting e136" xml:space="preserve">
            expr: i; expr, plus, expr.
            i: "i".
            plus: "+".
            
         </div>
         <div class="para e137">then a string such as</div>
         <div class="programlisting e138" xml:space="preserve">
            i+i+i
            
         </div>
         <div class="para e139">could be parsed as both</div>
         <div class="programlisting e140" xml:space="preserve">
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            &lt;plus/&gt;
            &lt;expr&gt;
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            &lt;plus/&gt;
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            &lt;/expr&gt;
            
         </div>
         <div class="para e141">and as</div>
         <div class="programlisting e142" xml:space="preserve">
            &lt;expr&gt;
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            &lt;plus/&gt;
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            &lt;/expr&gt;
            &lt;plus/&gt;
            &lt;expr&gt;&lt;i/&gt;&lt;/expr&gt;
            
         </div>
      </div><a name="DeliveryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e143" xml:id="Deliver">
         <div class="title e144">Delivery</div>
         <div class="para e145">To deliver a source document to be parsed by our system, we
            can use a media type 
            <div class="xref e146" linkend="MediaType"></div> that supplies a reference to the
            required syntax description. For instance:
         </div>
         <div class="programlisting e147" xml:space="preserve">
            application/xml-invisible; syntax=http://example.com/syntax/css
            
         </div>
         <div class="para e148">Clearly a system can cache well-known syntax
            descriptions.
         </div>
      </div><a name="Using%0AInvisibleXMLtodefineitselfANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e149" xml:id="Using_Invisible_XML_to_define_itsel">
         <div class="title e150">Using
            Invisible XML to define itself
         </div>
         <div class="para e151">It should go without saying that the syntax descriptions
            themselves are in Invisible XML (though in their case the syntax
            description 
            <div class="emphasis e152">must</div> be cached to prevent an
            infinite loop of processing.)
         </div>
         <div class="para e153">The definition might look like this:</div>
         <div class="programlisting e154" xml:space="preserve">
            ixml: (rule)+.
            rule: @name, -colon, -definition, -stop.
            definition: (alternative)*-semicolon.
            alternative: (-term)*-comma.
            term: -symbol; -repetition.
            repetition: one-or-more; zero-or-more.
            one-or-more: -open, -definition, -close, -plus, separator.
            zero-or-more: -open, -definition, -close, -star, separator.
            separator: -symbol; -empty.
            empty: .
            symbol: -terminal; nonterminal; refinement.
            terminal: explicit-terminal; implicit-terminal.
            explicit-terminal: -plus, @string.
            implicit-terminal: @string.
            nonterminal: @name.
            refinement: -minus, @name.
            attribute: -at, @name.
            
            string: -openquote, (-character)*, -closequote.
            name: (-letter)+.
            letter: +"a"; +"b"; ...
            character: ...
            
            colon: -S, ":", -S.
            stop: -S, ".", -S.
            semicolon: -S, ";", -S.
            comma:  -S, ",", -S.
            plus:  -S, "+", -S.
            minus:  -S, "-", -S.
            star:  -S, "*", -S.
            open:  -S, "(", -S.
            close:  -S, ")", -S.
            at:  -S, "@", -S.
            openquote: -S, """".
            closequote: """", -S.
            S: " "*.
            
         </div>
         <div class="para e155">This would then parse to the XML form:</div>
         <div class="programlisting e156" xml:space="preserve">
            &lt;ixml&gt;
            &lt;rule name="ixml"&gt;
            &lt;alternative&gt;
            &lt;one-or-more&gt;
            &lt;alternative&gt;
            &lt;nonterminal name="rule"/&gt;
            &lt;/alternative&gt;&lt;separator/&gt;
            &lt;/one-or-more&gt;
            &lt;/alternative&gt;
            &lt;/rule&gt;
            &lt;rule name="rule"&gt;
            &lt;alternative&gt;
            &lt;attribute name="name"/&gt;
            &lt;refinement name="definition"/&gt;
            &lt;/alternative
            &lt;/rule&gt;
            &lt;rule name="definition"&gt;
            &lt;alternative&gt;
            &lt;zero-or-more&gt;
            &lt;alternative&gt;
            &lt;nonterminal name="alternative"/&gt;
            &lt;/alternative&gt;
            &lt;separator&gt;&lt;refinement name="semicolon"/&gt;&lt;/separator&gt;
            &lt;/zero-or-more&gt;
            &lt;/alternative
            &lt;/rule&gt;
            ... etc ...
            &lt;rule name="separator"&gt;
            &lt;alternative&gt;&lt;refinement name="symbol"/&gt;&lt;/alternative&gt;
            &lt;alternative&gt;&lt;refinement name="empty"/&gt;&lt;/alternative&gt;
            &lt;/rule&gt;
            ... etc ...
            &lt;/ixml&gt;
            
         </div>
         <div class="para e157">Thanks to Earley's parsing algorithm, we can remove the
            
            <div class="code e158">&lt;alternative&gt;</div> elements when there is only
            one 
            <div class="code e159">alternative</div> in a 
            <div class="code e160">rule</div>, by
            redefining 
            <div class="code e161">definition</div>:
         </div>
         <div class="programlisting e162" xml:space="preserve">
            definition: -alternative; alternative, -semicolon, (alternative)+-semicolon.
            
         </div>
         <div class="para e163">Note how we have used the "-" character to prevent it being
            copied in the first case (when there is only one). You wouldn't be
            able to use such a rule as this if there were a requirement on the
            syntax to be LL(1) or LR(1), since the two parts of the rule start
            with the same symbols.
         </div>
         <div class="para e164">Similarly, we can get rid of empty
            
            <div class="code e165">&lt;separators/&gt;</div> thusly:
         </div>
         <div class="programlisting e166" xml:space="preserve">
            one-or-more: -open, -definition, -close, -plus; -open, -definition, -close, -plus,
            separator.
            zero-or-more: -open, -definition, -close, -star; -open, -definition, -close, -star,
            separator.
            separator: -symbol.
            
         </div>
         <div class="para e167">We can move the value of the separator into an attribute
            with:
         </div>
         <div class="programlisting e168" xml:space="preserve">
            separator: @explicit; @implicit; @nonterminal; @refinement.
            explicit: -plus, -string.
            implicit: -string.
            
         </div>
         <div class="para e169">This would then generate:</div>
         <div class="programlisting e170" xml:space="preserve">
            &lt;ixml&gt;
            &lt;rule name="ixml"&gt;
            &lt;one-or-more&gt;
            &lt;nonterminal name="rule"/&gt;
            &lt;/one-or-more&gt;
            &lt;/rule&gt;
            &lt;rule name="rule"&gt;
            &lt;attribute name="name"/&gt;
            &lt;refinement name="definition"/&gt;
            &lt;/rule&gt;
            &lt;rule name="definition"&gt;
            &lt;alternative&gt;
            &lt;refinement name="alternative"/&gt;
            &lt;/alternative&gt;
            &lt;alternative&gt;
            &lt;nonterminal name="alternative"/&gt;
            &lt;one-or-more&gt;
            &lt;nonterminal name="alternative"/&gt;
            &lt;separator refinement="semicolon"/&gt;
            &lt;/one-or-more&gt;
            &lt;/alternative&gt;
            &lt;/rule&gt;
            ... etc ...
            &lt;rule name="separator"&gt;
            &lt;alternative&gt;&lt;refinement name="symbol"/&gt;&lt;/alternative&gt;
            &lt;alternative&gt;&lt;refinement name="empty"/&gt;&lt;/alternative&gt;
            &lt;/rule&gt;
            ... etc ...
            &lt;/ixml&gt;
            
         </div>
         <div class="para e171">(An observant reader will have spotted that we have allowed
            attributes to be defined by attributes here -- for instance with
            
            <div class="code e172">@refinement</div> -- that is we treat an attribute
            within an attribute definition as if it were a refinement).
         </div>
         <div class="para e173">As yet another possibility, we can move the separator into an
            attribute of the 
            <div class="code e174">one-or-more</div> or
            
            <div class="code e175">zero-or-more</div> elements:
         </div>
         <div class="programlisting e176" xml:space="preserve">
            one-or-more: -open, -definition, -close, -plus; -open, -definition, -close, -plus,
            -separator.
            zero-or-more: -open, -definition, -close, -star; -open, -definition, -close, -star,
            -separator.
            separator: @explicit; @implicit; @nonterminal; @refinement.
            explicit: -plus, -string.
            implicit: -string.
            
         </div>
      </div><a name="Alternative%0ARepresentationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e177" xml:id="Alternative_Representatio">
         <div class="title e178">Alternative
            Representation
         </div>
         <div class="para e179">Although the syntax description so defined was developed
            iteratively based on the needs of the user, and is sufficient for
            its purpose, it is clear in the above example, that refinements
            occur far more frequently than true semantic rules. An alternative
            worth exploring would be to say that 
            <div class="emphasis e180">nothing</div>
            is copied to the syntax tree unless specifically marked. Let us use
            the "^" character to mark items that are copied to the tree. The
            result is clearly much more restful on the eyes:
         </div>
         <div class="programlisting e181" xml:space="preserve">
            ixml: (^rule)+.
            rule: @name, colon, definition, stop.
            definition: alternative; ^alternative, semicolon, (^alternative)+semicolon.
            alternative: (term)*comma.
            term: symbol; repetition.
            repetition: ^one-or-more; ^zero-or-more.
            one-or-more: open, definition, close, plus; open, definition, close, plus, ^separator.
            zero-or-more: open, definition, close, star; open, definition, close, star, ^separator.
            separator: terminal; @nonterminal; @refinement.
            symbol: terminal; ^nonterminal; ^refinement.
            terminal: ^explicit-terminal; ^implicit-terminal.
            explicit-terminal: up, @string.
            implicit-terminal: @string.
            nonterminal: up, @name.
            refinement: @name.
            attribute: at, @name.
            
            string: openquote, (character)*, closequote.
            name: (letter)+.
            letter: ^"a"; ^"b"; ...
            character: ...
            
            colon: S, ":", S.
            stop: S, ".", S.
            semicolon: S, ";", S.
            comma:  S, ",", S.
            plus:  S, "+", S.
            up:  S, "^", S.
            star:  S, "*", S.
            open:  S, "(", S.
            close:  S, ")", S.
            at:  S, "@", S.
            openquote: S, """".
            closequote: """", S.
            S: " "*.
            
         </div>
      </div><a name="ExtrasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e182" xml:id="Extra">
         <div class="title e183">Extras</div>
         <div class="para e184">There are obvious extra odds and ends that need adding, such
            as sets of characters, to make terminal specification easier, for
            instance:
         </div>
         <div class="programlisting e185" xml:space="preserve">
            letter: ^["a"-"z", "A"-"Z", "-"].
            S: [" ", "\t", "\n", ...]*.
            
         </div>
         <div class="para e186">but these are just details.</div>
      </div><a name="Restriction%0AontheXMLProducedANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e187" xml:id="Restriction_on_the_XML_Produce">
         <div class="title e188">Restriction
            on the XML Produced
         </div>
         <div class="para e189">It should be noted in passing that in the form presented
            here, 
            <div class="emphasis e190">Invisible XML</div> only works in one
            direction: you can turn any textual document into an equivalent XML
            document. However, it is not in general possible to turn a textual
            document into a 
            <div class="emphasis e191">particular</div> XML form without
            more work. For instance, you could turn Wiki markup into an XML
            document, but not into XHTML in particular.
         </div>
      </div><a name="RoundtrippingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e192" xml:id="Roundtrippin">
         <div class="title e193">Roundtripping</div>
         <div class="para e194">Returning the resultant XML document to its original format
            is just a process of presentation, nothing that a suitable bit of
            XSLT couldn't do, or even CSS in some simple cases. In fact it
            should be apparent that from the 
            <div class="emphasis e195">Invisible XML</div>
            syntax, it would be straightforward to automatically generate the
            required piece of XSLT directly.
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e196" xml:id="Conclusio">
         <div class="title e197">Conclusion</div>
         <div class="para e198">There is really no reason why XML can't be more ubiquitous
            than it is, and similarly there is no reason why XML documents have
            to be written in an explicit XML format 
            <div class="emphasis e199">per
               se
            </div>. Anything that can be parsed can be perceived as XML,
            since parsing is very easy, and parse-trees are really just XML
            documents in different clothing. 
            <div class="emphasis e200">Invisible XML</div>
            allows a multitude of document formats to be authored in their
            traditional form, but be processed as XML, with the concomitant
            advantages of the XML toolchain.
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e201">
         <div class="title e202">References</div>
         <div class="bibliomixed e203" xml:id="RelaxNG" xreflabel="RELAX NG">James Clark, Makoto MURATA (eds.), 2001, RELAX NG Specification,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e204" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://www.oasis-open.org/committees/relax-ng/spec.html</div>
         </div>
         <div class="bibliomixed e205" xml:id="RelaxNGCOMPACT" xreflabel="RELAX NG COMPACT">James Clark (ed.). 2002, RELAX NG Compact Syntax,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e206" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://www.oasis-open.org/committees/relax-ng/compact-20021121.html</div>
         </div>
         <div class="bibliomixed e207" xml:id="BNF" xreflabel="BNF">Backus-Naur Form,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e208" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/Backus-Naur_Form</div>
         </div>
         <div class="bibliomixed e209" xml:id="VWG" xreflabel="VWG">S. Pemberton, 1982, "Executable Semantic Definition of
            Programming Languages Using Two-level Grammars",
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e210" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.cwi.nl/~steven/vw.html</div>
         </div>
         <div class="bibliomixed e211" xml:id="LL1" xreflabel="LL1">Alfred Aho and Jeffrey D. Ullman, 1977, "Principles of
            Compiler Design", Addison-Wesley, ISBN 0-201-00022-9.
         </div>
         <div class="bibliomixed e212" xml:id="Earley" xreflabel="Earley">Earley, Jay (1970), "An efficient context-free
            parsing algorithm", Communications of the ACM 13 (2): 94-102,
            doi:
            <div class="biblioid doi e213">10.1145/362007.362035</div>
         </div>
         <div class="bibliomixed e214" xml:id="MediaType" xreflabel="Media type">N. Freed et al., 1996, "Multipurpose Internet
            Mail Extensions, (MIME) Part Two: Media Types",
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e215" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ietf.org/rfc/rfc2046.txt</div>
         </div>
      </div>
   </div>
</div>