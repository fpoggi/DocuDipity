<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TestAssertionsonsteroidsforXMLartifactsANCHOR" name="TestAssertionsonsteroidsforXMLartifactsTOC">Test Assertions on steroids for XML artifacts</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XMLTestAssertionsforXMLANCHOR" name="XMLTestAssertionsforXMLTOC">XML Test Assertions for XML</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TestAssertionModelANCHOR" name="TestAssertionModelTOC">Test Assertion Model</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheTestTargetanditsContextANCHOR" name="TheTestTargetanditsContextTOC">The Test Target and its Context</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ReportingTestOutcomesANCHOR" name="ReportingTestOutcomesTOC">Reporting Test Outcomes</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InheritanceandCompositionANCHOR" name="InheritanceandCompositionTOC">Inheritance and Composition</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ChainedTestAssertionsANCHOR" name="ChainedTestAssertionsTOC">Chained Test Assertions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExecutionSemanticsANCHOR" name="ExecutionSemanticsTOC">Execution Semantics</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ImplementationConsiderationsANCHOR" name="ImplementationConsiderationsTOC">Implementation Considerations</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OtherWorksinSemanticValidationofDocumentsANCHOR" name="OtherWorksinSemanticValidationofDocumentsTOC">Other Works in Semantic Validation of Documents</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchematronANCHOR" name="SchematronTOC">Schematron</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OWLANCHOR" name="OWLTOC">OWL</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XBRLANCHOR" name="XBRLTOC">XBRL</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 11 - 14, 2009</div>
         <div class="singletermTERMS">Associate Director</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2009</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Composition</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Document Testing</div>
         <div class="singletermTERMS">Durand</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">fail</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">Green</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">Inheritance</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">jdurand@us.fujitsu.com</div>
         <div class="singletermTERMS">Jacques</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Kulvatunyou</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">missingInput</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">notQualified</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">Prerequisite</div>
         <div class="singletermTERMS">Predicate</div>
         <div class="singletermTERMS">Prescription Level</div>
         <div class="singletermTERMS">pass</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Rutt</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">Source</div>
         <div class="singletermTERMS">stephen.green@documentengineeringservices.com</div>
         <div class="singletermTERMS">serm.kulvatunyou@oracle.com</div>
         <div class="singletermTERMS">Stephen</div>
         <div class="singletermTERMS">Serm</div>
         <div class="singletermTERMS">Senior architect, R and D dir.</div>
         <div class="singletermTERMS">Standard and Product Architect</div>
         <div class="singletermTERMS">Standards Manager</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">TA Id</div>
         <div class="singletermTERMS">Target</div>
         <div class="singletermTERMS">Test Assertions Guidelines;</div>
         <div class="singletermTERMS">tom@coastin.com</div>
         <div class="singletermTERMS">Tom</div>
         <div class="singletermTERMS">Test Assertion</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">undetermined</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TestAssertionsonsteroidsforXMLartifactsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="AHR-23632987-8973">
      <div class="title e1">Test Assertions on steroids for XML artifacts</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2009</div>
            <div class="confdates e5">August 11 - 14, 2009</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Testing of XML material – either XML-native business documents, or XML-formatted inputs
               from various sources – involves more than syntactic or semantic validation of a document.
               It often requires checking consistency with other documents, and verifying assumptions
               about the quality of these. Consequently - like for any complex system - the design
               and execution of test units have to be composed and ordered. This in turns requires
               a testing method and tool with more flexibility - in test expression and test usage
               - than provided by validation tools such as OWL reasoner or Schematron. A test method
               is presented that relies on a general test assertion model from OASIS. This test model
               (and its XML markup) is extended with XPath in order to make test assertions directly
               executable after XSLT translation, by a forward-chaining engine itself written in
               XSLT. Test assertions may refer to other test assertions either for chaining or for
               composing test results. The resulting test model and processing is contrasted with
               other approaches (XBRL test suite, OWL reasoner, Schematron). Results and learnings
               from a real test suite are presented, as well as a proposed implementation model based
               on generating the XSLT engine specific to a test suite, rather than using a generic
               engine. Observations are made about features in the latest versions of underlying
               technologies (XPath2.0, XSLT2.0) that were critical to this implementation.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Jacques</div>
               <div class="surname e11">Durand</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Jacques Durand is software architect at Fujitsu America, Inc. with a long-time involvement
                  in XML standard organizations, member of the OASIS Technical Advisory Board, contributor
                  to XML user consortiums such as RosettaNet, OAGI. He has extensive experience in XML-related
                  testing, is chair of the Test Assertions Guideline OASIS committee and of the Testing
                  and Monitoring of Internet Exchanges (TaMIE) committee. He has been leading testing
                  activities for years in the WS-Interoperability consortium and in the ebXML technical
                  committee. He earned a Ph.D. in rule-based systems and logic-programming from Nancy
                  Univ., France.
                  	
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Senior architect, R and D dir.</div>
               <div class="orgname e16">Fujitsu America, Inc.</div>
            </div>
            <div class="email e17">jdurand@us.fujitsu.com</div>
         </div>
         <div class="author e18">
            <div class="personname e19">
               <div class="firstname e20">Stephen</div>
               <div class="surname e21">Green</div>
            </div>
            <div class="personblurb e22">
               <div class="para e23">Stephen Green is an Associate Director of Document Engineering Services, an international
                  consortium of experts supporting universal business interoperability through the use
                  of open standards. His expertise is in finance, business documents and software development
                  for business and financial applications. He has specialized in legacy systems and
                  modern electronic business trends and their impact on small and medium sized enterprises.
                  Stephen has been active in the Organization for the Advancement of Structured Information
                  Standards (OASIS) for seven years, serving on as many technical committees.
                  	  He is currently editing the Test Assertions Guidelines of the OASIS technical committee
                  of that name. He previously led the first efforts to provide a small business subset
                  conformance profile for the OASIS Universal Business Language, version 1.0."
                  	
               </div>
            </div>
            <div class="affiliation e24">
               <div class="jobtitle e25">Associate Director</div>
               <div class="orgname e26">Document Engineering Services</div>
            </div>
            <div class="email e27">stephen.green@documentengineeringservices.com</div>
         </div>
         <div class="author e28">
            <div class="personname e29">
               <div class="firstname e30">Serm</div>
               <div class="surname e31">Kulvatunyou</div>
            </div>
            <div class="personblurb e32">
               <div class="para e33">Serm Kulvatunyou is currently a Standard and Product Architect at the Oracle's Application
                  Integration Architecture (AIA) division. Formerly, he was a guest researcher the at
                  the Manufacturing Systems Integration Division, National Institute of Standards and
                  Technology (NIST) from the Oak Ridge National Laboratory. At NIST, he has designed
                  and implemented semantics testing and frameworks for design of document model and
                  instance validation in the contenxt of an e-business testbed using XML and related
                  technologies.  He has been an active participants in several standard bodies such
                  as UN/CEFACT and OASIS. His current interests are in architecture and best practices
                  methodology to enterprise data model for reusable and interoperable Service-Oriented
                  Architecture. He received his Ph.D. in Industrial Engineering from the Pennsylvania
                  State University, University Park, in 2001.
                  	
               </div>
            </div>
            <div class="affiliation e34">
               <div class="jobtitle e35">Standard and Product Architect</div>
               <div class="orgname e36">Oracle</div>
            </div>
            <div class="email e37">serm.kulvatunyou@oracle.com</div>
         </div>
         <div class="author e38">
            <div class="personname e39">
               <div class="firstname e40">Tom</div>
               <div class="surname e41">Rutt</div>
            </div>
            <div class="personblurb e42">
               <div class="para e43">Tom Rutt is Standards Manager at Fujitsu America, Inc. with a long-time involvement
                  in XML standard organizations and participates in several Web Services standard committees.
                  He has extensive experience in XML-related testing, and has been involved in the WS-Interoperability
                  consortium for years, more recently designing and developing testing tools for profile
                  conformance. He is also member of the OMG Architecture Board.
                  	
               </div>
            </div>
            <div class="affiliation e44">
               <div class="jobtitle e45">Standards Manager</div>
               <div class="orgname e46">Fujitsu America, Inc.</div>
            </div>
            <div class="email e47">tom@coastin.com</div>
         </div>
         <div class="legalnotice e48">
            <div class="para e49">Copyright © Fujitsu America, Inc., Document Engineering Services, Oracle: Used by
               permission.
            </div>
         </div>
         <div class="keywordset e50" role="author">
            <div class="keyword e51">Document Testing</div>
            <div class="keyword e52">Test Assertion</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e53">
         <div class="title e54">Introduction</div>
         <div class="para e55">
            Testing of XML material – either XML-native business documents, or various XML-formatted
            inputs – often involves more than single document validation. The notion of validation
            may depend on a context involving other documents. Validation against a schema is
            just an an example of this. Behind XML document testing it is often a processor generating
            or editing this document, that is being tested. This is the case with XBRL test suites
            (for XBRL processors), with WS-I test suites (testing Web service instances) and also
            the ODF test suite (targeting document processors). As a consequence, the notion of
            validity depends on a context made of diverse other documents, that represent various
            inputs to these processors as well as traces that capture their behavior and relate
            all documents associated with the same test case. Roughly, two categories of documents
            can make up such context: (a) metadata documents, and (b) scenario documents.
            
         </div>
         <div class="itemizedlist e56">
            <div class="listitem e57">
               <div class="para e58">
                  	Metadata documents may involve various business rules, reference documents and templates,
                  contractual documents, configuration artifacts. XML schemas are just an example of
                  these, and they may be involved in quite diverse validation patterns [1] beyond conventional
                  schema-validation of instances.
                  
               </div>
            </div>
            <div class="listitem e59">
               <div class="para e60">Scenario documents reflect on operations over a system under test  - such as an XML
                  transcript of an electronic exchange with the system under test, a log converted into
                  XML, or the script a sequence of operations to be performed by a test driver. 
               </div>
            </div>
         </div>
         <div class="para e61">
            In such cases, testing is as much about verifying that each one of these XML artifacts
            is individually correct, as it is about verifying that some combinations of these
            are consistent (e.g. a Web service message must conform to its definition in WSDL,
            or the output of an ODF processor is consistent with the operation performed and the
            previous state of the document). In some cases it is not even a main document that
            is under test relative to some context, but rather a sequence of documents, e.g. a
            message choreography for a business transaction combining business payloads, message
            protocols and service interfaces that is tested for conformance [2]. The dependency
            between a document and its transactional context (exchange protocol) has also been
            analyzed in [3].
            
         </div>
         <div class="para e62">
            Such testing requirements are in fact closer to conventional system or software testing
            requirements than to document testing in a narrow sense - while also requiring same
            XML testing capabilities as known today for single documents. Because each type of
            artifact may have its own validation rules and test suites, tests must be grouped
            into modules, the execution of which is conditioned by the results of other test modules.
            Chaining of test cases becomes an important feature, across modules or within modules.
            
         </div>
         <div class="para e63">
            This diversity of these test requirements poses a challenge to a test environment:
            
            <div class="itemizedlist e64">
               <div class="listitem e65">
                  <div class="para e66">Rules and constraints (Schematron, OWL Reasoning, RuleML) are often limited in either
                     one of two ways: (a) their expressive power is often traded for ease of processing,
                     (b) their decision model (e.g. predicate logic) often enforces a Boolean outcome missing
                     the nuances expected in a test report.
                  </div>
               </div>
               <div class="listitem e67">
                  <div class="para e68">Test suites - and test engines – often exceed the scope of dedicated tools such as
                     Schematron (e.g. XBRL test suite). As a result they are architected and developed
                     in an ad-hoc manner, regardless of how well they leverage XML technologies.
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e69">
            This paper describes a more integrated XML testing paradigm which supports flexible
            composition of test cases (chaining, parameterization) and test suites (modules, reuse).
            The resulting implementation makes the best of XPath2.0 and XSLT2.0 to provide on
            one hand a test script model able to express predicates crossing over such diverse
            inputs and to handle a richer spectrum of outcomes, and on the other hand a test engine
            able to compose and chain test assertions in a way that was usually considered requiring
            specialized rule engines written in conventional programming languages or dedicated
            AI languages such as Prolog or LISP.
            
         </div>
      </div><a name="XMLTestAssertionsforXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e70">
         <div class="title e71">XML Test Assertions for XML</div>
         <div class="para e72">
            In this section the authors argue that the best approach for testing XML material
            – given the integrated aspect of such testing - is one that builds on conventional
            test methodologies, augmented with a proper integration of XML-processing techniques
            (here XPath2.0, XSLT2.0).
            
         </div><a name="TestAssertionModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e73">
            <div class="title e74">Test Assertion Model</div>
            <div class="para e75">
               	Test assertions (TA) is a familiar concept for QA engineers and test developers.
               A test assertion is a testable or measurable statement for evaluating the adherence
               of part of an implementation to a normative statement in a specification. Test assertions
               provide a link between the narrative of a specification (i.e. rules, schema, requirements,
               system definition) and the test suites that assess conformance of implementations.
               Test assertions have been mostly used in the domain of software engineering, and less
               often in more specialized domains such as XML artifacts, where ad-hoc solutions -
               and also very specialized tools - have flourished instead. Test assertions are usually
               declarative (logical) statements that are written as a blueprint for test cases, the
               latter being the actual executable tests.
               
            </div>
            <div class="para e76">
               	A major benefit in writing test assertions, is that they represent a "conformance
               contract" understandable by all parties involved - domain experts, test writers, end-users.
               An additional interest in the XML space - where all material under test is in XML
               format, is that test assertions can be directly scripted using such dialects as XPath
               or XQuery, thus becoming themselves executable test cases. A general-purpose model
               for test assertions has recently been developed in the OASIS Test Assertions Guidelines
               (TAG) OASIS committee [8]. In this model, a test assertion (TA) is a well-structured
               object defined as follows:
               
            </div>
            <div class="para e77">
               	
               <div class="itemizedlist e78">
                  <div class="listitem e79">
                     <div class="para e80">
                        <div class="emphasis e81" role="bold">TA Id</div>: the identifier of the Test Assertion.
                     </div>
                  </div>
                  <div class="listitem e82">
                     <div class="para e83">
                        <div class="emphasis e84" role="bold">Source</div>: the normative conformance requirement that this test assertion is addressing
                     </div>
                  </div>
                  <div class="listitem e85">
                     <div class="para e86">
                        <div class="emphasis e87" role="bold">Target</div>: a Test Assertion always targets instances of a specific artifact type, for example,
                        a line item fragment in a purchase order document, a SOAP Envelope, a WSDL port binding,
                        etc. The Target element identifies this artifact type. 
                     </div>
                  </div>
                  <div class="listitem e88">
                     <div class="para e89">
                        <div class="emphasis e90" role="bold">Prerequisite</div>: a pre-condition that must be satisfied over the Target instance in order for this
                        instance to qualify for evaluation under this TA. The Prerequisite may refer to other
                        test assertions. If the Prerequisite evaluates to “false”, then the outcome of the
                        TA for this Target will be “notQualified” in the test report.
                     </div>
                  </div>
                  <div class="listitem e91">
                     <div class="para e92">
                        <div class="emphasis e93" role="bold">Predicate</div>: a logical expression over the Target. The Predicate is only evaluated if the Target
                        instance is qualified, i.e. if the Prerequisite – if any – has already evaluated to
                        “true”. If the Predicate result is “true” then the Target instance fulfills the related
                        conformance requirement and violates it otherwise.
                     </div>
                  </div>
                  <div class="listitem e94">
                     <div class="para e95">
                        <div class="emphasis e96" role="bold">Prescription Level</div>: a keyword reflecting how imperative it is to fulfill the (Source) requirement: mandatory
                        / preferred / permitted.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e97">
               	The authors have profiled and extended this model so that test assertions become
               directly executable over XML artifacts, thus becoming "test cases" grouped in test
               suites.
               
            </div>
            <div class="para e98">
               	The profiling consists of the following:
               
               	
               <div class="orderedlist e99" numeration="arabic">
                  <div class="listitem e100">
                     <div class="para e101">Use XPath expressions to define Target, Prerequisite and Predicate.</div>
                  </div>
                  <div class="listitem e102">
                     <div class="para e103">Define how the instances of a particular target type are identified. This is defined
                        by another XPath expression that returns a unique ID, possibly resulting from aggregation
                        of several fields relevant to this target type. This ID will show in the test report,
                        but also used when chaining test assertions over a same target instance during test
                        execution.
                     </div>
                  </div>
                  <div class="listitem e104">
                     <div class="para e105">Add references (XPath) to a combination of artifacts that represent contextual documents,
                        over which Prerequisite and Predicate may operate.
                     </div>
                  </div>
                  <div class="listitem e106">
                     <div class="para e107">Add a new Reporting element that determines the outcome of the test assertion over
                        a target instance.
                     </div>
                  </div>
                  <div class="listitem e108">
                     <div class="para e109">Add secondary output mostly for human readers: error messages, diagnostic data.</div>
                  </div>
               </div>
               
            </div>
         </div><a name="TheTestTargetanditsContextANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e110">
            <div class="title e111">The Test Target and its Context</div>
            <div class="para e112">A test assertion will always focus on a “primary” target instance, but may need to
               access contextual material in order to test this target. This "side" material is identified
               in "variables" added to the TA. A simple example of this is schema-validation of a
               document. In the target scripting below, the test assertion will refer to the contextual
               document (a schema) while targeting a purchase order line item:
               	
               <div class="programlisting e113" xml:space="preserve">&lt;testAssertion id="1234" lg=”xpath20” &gt;
                  	  &lt;var name=”poschema” type="string"&gt;http://www.mysupplychain_xyz.com/2009/04/12/po.xsd&lt;/var&gt;
                  	  &lt;target&gt;//xyz:purchaseOrder/xyz:lineItem&lt;/target&gt;
                  	  &lt;predicate&gt;$target instance of schema-element($poschema, xyz:lineItem) &lt;/predicate&gt;
                  	  ...
                  	  &lt;/testAssertion&gt;
               </div>
               	The predicate validating a lineItem element will refer to this contextual document
               using the conventional variable notation ($). The predicate expressions will be pre-processed
               into executable XPath.
               	The above test assertion applies to every line item of any purchase order.
               	Variable expressions (&lt;var&gt;) may refer to any contextual material - either inside
               the same document or external. An XPath variable notations($) may then be used either
               to parameterize the location of a document, or to refer to the current value of the
               target expression:
               	
               <div class="programlisting e114" xml:space="preserve">&lt;testAssertion id="2345" lg=”xpath20”&gt;
                  	  &lt;var name=”herbooks” &gt;document($allbooks)/book[@author = $target/name]&lt;/var&gt;
                  	  &lt;var name=”herpublishers” &gt;document($allpublishers)
                  	  //directory/publisher[fn:index-of( fn:distinct-values(
                  	  ‘for $bk in $herbooks return $bk/@publisher’), @name) gt 0 ]&lt;/var&gt;
                  
                  	  &lt;target&gt;//whoswho/arts[@section='literature']/biographies/author&lt;/target&gt;
                  	  ...
                  	  &lt;/testAssertion&gt;
               </div>
               	In the above, "$allbooks" and "$allpublishers" are references to a documents that
               have been defined outside the test assertion. The variable "$herbooks" denotes the
               subset of books from this author. The variable "$herpublishers" is the subset of publishers
               this author has been dealing with. The target expression is matched against a third
               document, the main input.
               	A predicate for the above target may express a condition over the author (the target),
               her related list of books ($herbooks) and of publishers ($herpublishers).
               
            </div>
         </div><a name="ReportingTestOutcomesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e115">
            <div class="title e116">Reporting Test Outcomes</div>
            <div class="para e117">
               	The additional Reporting element added to the test assertion structure may override
               the default outcome which is:
               	
               <div class="itemizedlist e118">
                  <div class="listitem e119">
                     <div class="para e120">
                        <div class="emphasis e121" role="bold">notQualified</div> (if Prerequisite = “false”)
                     </div>
                  </div>
                  <div class="listitem e122">
                     <div class="para e123">
                        <div class="emphasis e124" role="bold">pass</div> (if Prerequisite = “true” and Predicate = “true”)
                     </div>
                  </div>
                  <div class="listitem e125">
                     <div class="para e126">
                        <div class="emphasis e127" role="bold">fail</div> (if Prerequisite = “true” and Predicate = “false”)
                     </div>
                  </div>
               </div>
               	Indeed, other possible outcomes are:
               	
               <div class="itemizedlist e128">
                  <div class="listitem e129">
                     <div class="para e130">
                        <div class="emphasis e131" role="bold">missingInput</div> (a contextual document or XML fragment is missing in order to pursue the evaluation)
                     </div>
                  </div>
                  <div class="listitem e132">
                     <div class="para e133">
                        <div class="emphasis e134" role="bold">warning</div> (the Predicate may not be indicative enough of either violation or fulfillment, but
                        has detected a situation calling for further attention.)
                     </div>
                  </div>
                  <div class="listitem e135">
                     <div class="para e136">
                        <div class="emphasis e137" role="bold">undetermined</div> (e.g. the Predicate is only designed to detect some kinds of violation, when “false”,
                        and has no particular conformance meaning when “true”)
                     </div>
                  </div>
               </div>
               	These outcomes are not only intended for a final test report. They can also be tested
               and influence the test suite execution if the test assertion that produces them is
               referred to in predicates and prerequisites of subsequent test assertions.
               
            </div>
         </div><a name="InheritanceandCompositionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e138">
            <div class="title e139">Inheritance and Composition</div>
            <div class="para e140">
               	An important benefit of clearly identifying target categories, is the ability to
               leverage inheritance and composition relationships between targets. Targets often
               belong to a class system, in the object-oriented sense (a target may be part of an
               other target, may be a subclass of another target, etc.). This leads to an enhanced
               test execution model that is able to leverage such relationships. In particular:
            </div>
            <div class="itemizedlist e141">
               <div class="listitem e142">
                  <div class="para e143">
                     <div class="emphasis e144" role="bold">Inheritance</div>: The test engine is able to determine that a test assertion will apply not only to
                     all instances of its Target class, but also to all instances of its Target sub-classes.
                     In other words, a target inherits the test assertions of its super-classes.
                     	
                  </div>
               </div>
               <div class="listitem e145">
                  <div class="para e146">
                     <div class="emphasis e147" role="bold">Composition</div>: The test engine is able to handle cases where the prerequisite expression of TA
                     t1 includes references to TA t2, and yet t1 and t2 do not have the same Target class
                     - not even in a sub-class relationship - but have a component relationship. For example,
                     t1 target - say a "binding definition" - is a part of t2 target - say a WSDL file.
                     Before verifying that the binding satisfies some rules (TA t1) one may want to verify
                     that the embedding WSDL file is schema-valid (TA t2). In such cases, the component
                     relationship can be defined once as an access expression from t1 to t2 on the ancestor
                     axis (XPath), reusable by any TA.
                     	
                  </div>
               </div>
            </div>
            <div class="para e148">
               	The authors are in favor of supporting two modes of representation for such a model:
               (1) "inline" relationship information can be embedded in each test assertion as needed.
               (2) a different mark-up separate from test assertions will hold target model information.
               While (2) is a more rational and scalable approach (avoid redundant information from
               on test assertion to the other, etc.), (1) is a convenient approach well suited for
               the test assertion development phase.
               	Examples of inline model information are shown below. The target element uses a qualification
               notation to indicate the super-class (message) of SOAPmessage target class. 
            </div>
            <div class="programlisting e149" xml:space="preserve">
               	&lt;target type="message:SOAPmessage" &gt; ... &lt;/target&gt;
               
            </div>
            <div class="para e150">The composition link between the main target of a test assertion - here a WSDL binding
               - and the related embedding target of a prerequisite reference - here the WSDL file
               itself - is indicated using an XPath expression relative to the selected target node
               ($target) as "argument" of the test assertion reference (tag:BP2703):
            </div>
            <div class="programlisting e151" xml:space="preserve">
               	&lt;testAssertion id="BP2403"&gt;
               	&lt;target type="binding" idscheme="..." &gt;//wsdl:definitions/wsdl:binding&lt;/target&gt;
               	&lt;prerequisite&gt; tag:BP2703($target/..) = 'pass' &lt;/prerequisite&gt;
               	...
               	&lt;/testAssertion&gt;
               
            </div>
            <div class="para e152">Another major attribute of a Target class, is the ID scheme itself an XPath expression
               that will return a unique ID string for each target instance, to appear in the test
               report.
               
            </div>
         </div><a name="ChainedTestAssertionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e153">
            <div class="title e154">Chained Test Assertions</div>
            <div class="para e155">
               	A powerful aspect of the otherwise simple TAG model, is that a test assertion (TA)
               may refer to other test assertions. It may do so in two ways:
               	
               <div class="orderedlist e156" numeration="loweralpha">
                  <div class="listitem e157">
                     <div class="para e158">by using TA references in the Prerequisite element. Such references are just parts
                        of the logical expression, e.g. (in a simplified notation) :
                        	      
                        <div class="programlisting e159" xml:space="preserve">Prerequisite of TA3: (TA1 = “pass”) and (TA2 = “pass”)</div>
                        	      means that it is expected that the target passed TA1 and TA2 before even being
                        tested for TA3. TA-referencing in a Prerequisite is commonly used when the test expression
                        (Predicate) in a TA can be greatly simplified by assuming that the target already
                        passed other test assertions, or simply when the test itself is irrelevant in case
                        some other (prerequisite) tests have failed.
                        	  
                     </div>
                  </div>
                  <div class="listitem e160">
                     <div class="para e161">by using TA references in the Predicate element. This allows for writing meta-level
                        test assertions that evaluate a composition of the results of other TAs. This is often
                        needed when defining various "conformance profiles" related to the same type of document
                        (e.g. a category of insurance claims, a purchase order of class 'urgent'). For example:
                        “to comply with conformance profile P, a document must “pass” the set of test assertions
                        {TA1, TA2, TA3} and at least must NOT “fail” the set of test assertions {TA4, TA5}.”
                        In such a case, a single TA will summarize the composition test to be made over the
                        results of all TAs involved in assessing the conformance profile P. The predicate
                        will be:
                        	      
                        <div class="programlisting e162" xml:space="preserve">Predicate of TA6: (TA1 = “pass”) and (TA2 = “pass”) and (TA3 = “pass”)
                           		and  not(TA4 = “fail”) and not(TA5 = “fail”)
                        </div>
                        	      This summary TA (TA6) may in turn be referred to from the Prerequisite of another
                        TA. This is an essential feature when dealing with contextual documents: in most cases,
                        one must first ensure that the contextual document is itself “conforming” before using
                        it in a test case over the “main” document. These expressions are pre-processed by
                        the test engine into equivalent XPath boolean expressions.
                        	  
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e163">
               	There are two main reasons for chaining test assertions as described in (a) above:
            </div>
            <div class="para e164">(a1) When a set of tests should logically be done in a particular order, meaning that
               every single test should only be executed if the target instance passed the previous
               tests. For example, the following sequence of tests is expected to be done in this
               order, regarding a Web service definition:
               	  
               <div class="orderedlist e165" numeration="arabic">
                  <div class="listitem e166">
                     <div class="para e167">Normative statement: "The wsdl:definitions MUST be a well-formed XML 1.0 document.
                        The wsdl:definitions namespace MUST have value: http://schemas.xmlsoap.org/wsdl/."
                        This is verified by the test assertion BP2703 below.
                        	      
                        <div class="programlisting e168" xml:space="preserve">
                           		&lt;testAssertion id="BP2703" lg=”xpath20” &gt;
                           		&lt;target&gt;//wsil:descriptionFile[fn:prefix-from-QName
                           		(fn:node-name(*:definitions)) eq 'wsdl' or wsdl:definitions]&lt;/target&gt;
                           		&lt;predicate&gt;$target instance of schema-element($wsdlschema) &lt;/predicate&gt;
                           		...
                           		&lt;/testAssertion&gt;
                        </div>
                        	    
                     </div>
                  </div>
                  <div class="listitem e169">
                     <div class="para e170">Normative statement: "The wsdl:binding element MUST have a wsoap12:binding child element."
                        This is verified by the test assertion BP2402 below.
                        	      
                        <div class="programlisting e171" xml:space="preserve">
                           		&lt;testAssertion id="BP2402" lg=”xpath20” &gt;
                           		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding&lt;/target&gt;
                           		&lt;prerequisite&gt;tag:BP2703($target/../..) eq 'pass'&lt;/prerequisite&gt;
                           		&lt;predicate&gt;child::wsoap12:binding&lt;/predicate&gt;
                           		...
                           		&lt;/testAssertion&gt;
                        </div>
                        	    
                     </div>
                  </div>
                  <div class="listitem e172">
                     <div class="para e173">Normative statement: "The contained soap binding element MUST have a 'transport' attribute."
                        This is verified by the test assertion BP2403 below.
                        	      
                        <div class="programlisting e174" xml:space="preserve">
                           		&lt;testAssertion id="BP2403" lg=”xpath20” &gt;
                           		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding&lt;/target&gt;
                           		&lt;prerequisite&gt;tag:BP2402($target) eq 'pass'&lt;/prerequisite&gt;
                           		&lt;predicate&gt;not(wsoap12:binding[not(@transport)])&lt;/predicate&gt;
                           		...
                           		&lt;/testAssertion&gt;
                        </div>
                        	    
                     </div>
                  </div>
                  <div class="listitem e175">
                     <div class="para e176">Normative statement: "The 'transport' attribute - if any - of the soap binding element
                        MUST have value:
                        	      http://schemas.xmlsoap.org/soap/http." This is verified by the test assertion
                        BP2404 below.
                        	      
                        <div class="programlisting e177" xml:space="preserve">
                           		&lt;testAssertion id="BP2404" lg=”xpath20” &gt;
                           		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding[wsoap12:binding]
                           		&lt;/target&gt;
                           		&lt;prerequisite&gt;tag:BP2403($target) eq 'pass'&lt;/prerequisite&gt;
                           		&lt;predicate&gt;not(wsoap12:binding[@transport ne
                           		'http://schemas.xmlsoap.org/soap/http'])&lt;/predicate&gt;
                           		...
                           		&lt;/testAssertion&gt;
                        </div>
                        	    
                     </div>
                  </div>
               </div>
               	  These four test assertions are chained via their prerequisite elements. This chaining
               means that if one fails, the subsequent tests will not be performed: whatever their
               outcome is, it might not make any sense or would at best produce an unnecessary distraction
               in the test report.
               	
            </div>
            <div class="para e178">(a2) In order to "reuse" (both at scripting time and at run-time) a complex expression
               outcome that has already been handled by another TA. For example in the Web services
               basic profile, a wsdl:binding must either be an rpc-literal binding or a document-literal
               binding. The test for ensuring this is not a simple one:
               	  
               <div class="programlisting e179" xml:space="preserve">
                  	    &lt;testAssertion id="BP2017" lg=”xpath20” &gt;
                  	    &lt;target&gt;//wsil:descriptionFile/wsdl:definitions/wsdl:binding
                  	    [wsoap12:binding]&lt;/target&gt;
                  	    &lt;prerequisite&gt;tag:BP2404($target) eq 'pass'&lt;/prerequisite&gt;
                  	    &lt;predicate&gt;not(.//wsoap12:body/@use != 'literal')
                  	    and (count(.//wsoap12:body) = count(.//wsoap12:body/@use)) and
                  	    ((not(.//wsoap12:*/@style != 'rpc') and
                  	    not(.//wsoap12:operation[not(@style) and not(../../wsoap12:binding/@style)]))
                  	    or (not(.//wsoap12:*/@style != 'document')))&lt;/predicate&gt;
                  	    ...
                  	    &lt;/testAssertion&gt;
               </div>
               	  Several test assertions relate only to document-literal type. Once it is known
               that a binding is of either above type, the test to distinguish an rpc-literal from
               a document-literal is fairly simple. In the following test assertion that applies
               only to document-literal type, this simple test - used here in the target expression
               - guarantees that only document-literal bindings will be selected:
               	  
               <div class="programlisting e180" xml:space="preserve">
                  	    &lt;testAssertion id="BP2111" lg=”xpath20” &gt;
                  	    &lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding
                  	    [not(.//wsoap12:*[@style = 'rpc'])]&lt;/target&gt;
                  	    &lt;prerequisite&gt;tag:BP2017($target) eq 'pass'&lt;/prerequisite&gt;
                  	    &lt;predicate&gt;not(.//wsoap12:body[@parts and contains(@parts," ")])&lt;/predicate&gt;
                  	    ...
                  	    &lt;/testAssertion&gt;
               </div>
               
            </div>
            <div class="para e181">The other form of chaining (b) is done in the Predicate expression. This allows for
               defining "meta-level" test assertions that wrap entire groups of test assertions by
               summarizing their expected outcome in a single logical expression. Such a meta-level
               test assertion can then be referred by other test assertions in their prerequisite
               condition, when this entire group of tests must be passed.
               	For example, consider BP1214 listed in the next section. This test assertion targets
               a SOAP message, but needs to access a contextual document: the interface binding definition
               that governs the content of this message. Before executing BP1214, it is clear that
               the binding definition must be verified. A meta-level test assertion can "summarize"
               all the tests that ensure this correctness for rpc-literal bindings:
               	
               <div class="programlisting e182" xml:space="preserve">
                  	  &lt;testAssertion id="BP-rpc-bindings" lg=”xpath20” &gt;
                  	  &lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding
                  	  [.//wsoap12:*[@style = 'rpc']]&lt;/target&gt;
                  	  &lt;prerequisite&gt;tag:BP2017($target) eq 'pass'&lt;/prerequisite&gt;
                  	  &lt;predicate&gt;(tag:BP2404($target) eq 'pass') and
                  	  (tag:BP2406($target) eq 'pass') and (tag:BP2020($target) eq 'pass') and
                  	  (tag:BP2120b($target) eq 'pass') and (tag:BP2117($target) eq 'pass') and
                  	  (tag:BP2118($target) eq 'pass')
                  	  &lt;/predicate&gt;
                  	  ...
                  	  &lt;/testAssertion&gt;
               </div>
               
               	The above test assertion may then be used as prerequisite for BP1214, over the binding
               definition related to its message target, i.e. the "binding" element parent of the
               "operation" element selected by the XPath expression in the variable $myOpBinding:
               	
               <div class="programlisting e183" xml:space="preserve">
                  	  &lt;testAssertion id="BP1214"&gt;
                  	  &lt;var name="myOpBinding"&gt; ...&lt;/var&gt;
                  	  &lt;prerequisite&gt;tag:BP-rpc-bindings($myOpBinding/..) eq 'pass'&lt;/prerequisite&gt;
                  	  &lt;target type="message:SOAPmessage" &gt;/wsil:testLog/wsil:messageLog/wsil:message[...]
                  	  &lt;/target&gt;
                  	  ...
                  	  &lt;/testAssertion&gt;
               </div>
               
            </div>
         </div><a name="ExecutionSemanticsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e184">
            <div class="title e185">Execution Semantics</div>
            <div class="para e186">
               	The general mode of execution for above TAs, is of a conventional forward-chaining
               rule engine. This is indeed necessary due to the chaining of test assertions, and
               departs radically from how other XPath-based rules systems are processed (e.g. Schematron
               or CAM do not handle chaining). The set of test assertions that have no references
               to other TAs is executed first over all candidate targets. This first set of test
               results for all possible target instances is recorded. In the next iteration of the
               engine, only TAs that have all their references resolved over the first set of results
               are executed in turn. Their results are added to the initial result set. Subsequent
               iterations add to the previous result set until iterations cannot augment anymore
               this result set which is considered stable. At this point, all possible validations
               have been made over the material under test, and they are ready for an (html) test
               report generation.
               
            </div>
            <div class="para e187">
               	In the XPath-extended XML markup of the TAG model, test assertions can be conditionally
               chained as rules to create dynamic test suites, the result of which can also be manipulated
               by higher-level test assertions. This approach is addressing the need to integrate
               validation of various XML artifacts, with validation of combinations of such artifacts
               (consistency across documents). Indeed, this requires composing and orchestrating
               test cases and test suites in a modular way.
               
            </div>
         </div><a name="ImplementationConsiderationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e188">
            <div class="title e189">Implementation Considerations</div>
            <div class="para e190">
               	The automation of TAG methodology is leveraging both XLST2.0 and XPath2.0. However,
               end-users (TA designers) only need to know about XPath to write test assertions. XSLT
               is only used for the execution engine.
               	A two-phase processing of above test assertions has been implemented by the authors,
               as often used when XSLT is the target execution language.
            </div>
            <div class="itemizedlist e191">
               <div class="title e192">Phase 1:</div>
               <div class="listitem e193">
                  <div class="para e194">input = set of test assertions (type: xml + XPath2.0)</div>
               </div>
               <div class="listitem e195">
                  <div class="para e196">processor = TAG engine generator (type: XSLT2.0)</div>
               </div>
               <div class="listitem e197">
                  <div class="para e198">output = test assertions engine for this set (type: XSLT2.0)</div>
               </div>
            </div>
            <div class="itemizedlist e199">
               <div class="title e200">Phase 2:</div>
               <div class="listitem e201">
                  <div class="para e202">input = documents under test and context (xml)</div>
               </div>
               <div class="listitem e203">
                  <div class="para e204">processor = test assertions engine in output of Phase 1 (type: XSLT2.0)</div>
               </div>
               <div class="listitem e205">
                  <div class="para e206">output = final test report (type: xml)</div>
               </div>
            </div>
            <div class="para e207">The first phase amounts to generating an XSLT-hardcoded test suite for a particular
               set of test assertions. The second phase amounts to executing this test suite. In
               addition to increased performance, the two-phase approach allows for advanced parameterization
               features in test assertions at different levels, with the use of variables:
               	
               <div class="itemizedlist e208">
                  <div class="listitem e209">
                     <div class="para e210">“Generation" (or "Phase 1") variables: these are given a value during Phase 1. Such
                        value assignments are hardcoded in the output of Phase 1.  Examples are those identifying
                        contextual documents in a previous example (e.g. $allbooks, $allpublishers).
                     </div>
                  </div>
                  <div class="listitem e211">
                     <div class="para e212">"Run-time" (or “Phase 2”) variables: these may have a different value at each execution
                        of the test assertion. Such variables are used to break down complex expressions for
                        Target, Prerequisite and Predicate, or to point at contextual documents that may vary
                        from one target to the other. In the example below, the Target is a SOAP message,
                        and the variable "myOpBinding" identifies the definition of the Web service operation
                        (here the WSDL file is in the same log as the message trace) associated with this
                        target instance (referred to using the pseudo variable "$target"): 
                     </div>
                  </div>
               </div>
               	
               <div class="programlisting e213" xml:space="preserve">
                  	  &lt;testAssertion id="BP1214"&gt;
                  	  &lt;var name="myOpBinding"&gt;//wsil:descriptionFile/wsdl:definitions/wsdl:binding
                  	  [.//wsoap12:*[@style = 'rpc']]/wsdl:operation
                  	  [@name =  fn:local-name-from-QName(node-name($target/soap12:Body/*[1]))]&lt;/var&gt;
                  	  &lt;target type="message:SOAPmessage" &gt;/wsil:testLog/wsil:messageLog/wsil:message[...]
                  	  &lt;/target&gt;
                  	  ...
                  	  &lt;/testAssertion&gt;
               </div>
               	This test assertion verifies that the message is conforming to some aspect of its
               binding definition.
               
            </div>
            <div class="para e214">
               	Two of the authors have developed test suites for Web Services profiles developed
               by the WS-Interoperability consortium (http://www.ws-i.org) using the XPath2.0-extended
               TAG model.  These test suites include test cases that involve a combination of documents
               (WSDL, Schemas) and sequences of messages. About 250 test assertions were developed
               for three WS profiles. The entire test suite execution process (Phase 1 + Phase 2
               + html rendering of the test report) is handled by stylesheets.
               
            </div>
            <div class="para e215">
               	Prior to this one author had been leading a similar test tool development process
               for WS-I based on conventional programming languages (Java, C#) [4]. The advantage
               of the recent approach using XPath and XSL are:
               	
               <div class="itemizedlist e216">
                  <div class="listitem e217">
                     <div class="para e218">Reliance on specialized XML dialects that have been developed over various platforms
                        and have been tested for consistency across these platforms, removes platform-dependency
                        of test tools (e.g. .NET, Java).
                     </div>
                  </div>
                  <div class="listitem e219">
                     <div class="para e220">Visibility of the TA logic (test assertion definitions are currently embedded in the
                        WS-I Profile document and readable by end-users and developers who need to comply
                        with these profiles). In the previous approach, the logic of tests was buried in the
                        binaries of the test tools.
                     </div>
                  </div>
                  <div class="listitem e221">
                     <div class="para e222">A modest but real gain in test suite design and overall development effort and the
                        related QA cycles.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e223">
               	Originally, the authors attempted to use XPath1.0 as expression language for TAs.
               This was not sufficient to handle complex correlations of XML-fragment (either intra-document
               or cross-document) required by WS-I test suites. XPath2.0 provided new features that
               significantly enhanced the expressive power of target / prerequisite / predicate expressions,
               such as quantified expressions, iterations and an extensive library of functions.
               Advanced correlation patterns inside Predicate could be expressed in a declarative
               way as a set of nested quantified expressions, making it possible to assign and reuse
               variables at each level.
               
            </div>
            <div class="para e224">
               	XSLT2.0 proved a suitable script language to implement a forward-chaining test assertion
               engine thanks to features such as next-match(), while the authors have not been successful
               at trying this with XSLT1.0.
               
            </div>
            <div class="para e225">
               	Along the line of managing complexity by leveraging the composability of test assertions
               and of their execution (chaining of test assertions, parameterization, meta-level
               assertions), a future enhancement will allow a test assertion to define “byproducts”
               , i.e. XML fragments produced by their execution (in addition to the main outcome
               “pass”, “fail” etc.) that can be reused in Prerequisite or Predicate of referring
               test assertions.
               
            </div>
         </div>
      </div><a name="OtherWorksinSemanticValidationofDocumentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e226">
         <div class="title e227">Other Works in Semantic Validation of Documents</div><a name="SchematronANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e228">
            <div class="title e229">Schematron</div>
            <div class="para e230">
               	        Schematron is a simple pattern and rule language well-focused on document
               testing. It leverages XPath functions and expressions, and can be implemented using
               XSLT. Rules in Schematron can be seen as serving similar purpose as test assertions.
               However the authors, after initially attempting to develop WS-I test suites with Schematron
               1.5, had to give up mostly due to its restricted rule execution semantics: there is
               no support for "logical" rule chaining, and in a pattern only one rule - the first
               that matches the context - will execute. This form of "if-then-else" chaining  applies
               to the context matching and not to the result of the rule itself, unlike what is expected
               in conventional rule-based systems.
               	
            </div>
            <div class="para e231">
               	        Schematron has been designed around the idea that the entity under test is
               the document, while in our test assertion engine it is before all an XML fragment,
               subset of some document. Each fragment (target) is systematically identified according
               to a well-defined scheme for its target type. This identity - defined by an XPath
               expression - is not only used for detailed diagnostic information in the test report,
               but is central to the rule chaining mechanism of the test engine, i.e. for deciding
               of the order of the tests on this target. Schematron allows for detailed and dynamic
               diagnostic information that has the ability to fully identify a subset of a document,
               but this does not play any role in the rule processing mechanism. Some valuable convenience
               feature had to be added to test assertions in the form of variables, for handling
               of complex Predicate expressions or to parameterize test assertions. Such variables
               are also supported in Schematron 1.6. On the modeling side, Schematron introduces
               a hierarchy of constructs (assertion, rule, pattern, phase). In contrast, the presented
               approach is based on a flat model relying on a single construct - test assertion -
               composable at different levels, but subject to the same execution semantics.
               	
            </div>
            <div class="para e232">
               	        Although Schematron can be written against any XML document, it is primarily
               intended for XML instances. Namespace handling becomes difficult when writing rules
               against an XML schema, and when there is a namespace prefix in a value of an attribute
               or element. Schemas often need be tested against naming and design rules [5]. Rules
               are label specific, i.e., there is no inheritance. If there is a type hierarchy, separate
               rules have to be written for every type even if the intention is the same. In Schematron
               1.5 rules cannot be reused or combined programmatically, although ISO Schematron has
               more provision for reusability such as abstract pattern and include statement.
               	
            </div>
            <div class="para e233">
               	         In conclusion, although Schematron is well-positioned for document validation
               through its lifecycle and is sufficient for many test cases, it has been designed
               more in the spirit of validating content in a type-checking mode (an extended schema).
               Its rules are intended for detecting patterns in documents and not to be executed
               along a test suite processing model requiring tight control on which tests are executed
               and when based on previous tests results. We believe the concept of test suite is
               appropriate when considering a combination of diverse XML artifacts including XML-formatted
               data of non XML source.
               	
            </div>
         </div><a name="OWLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e234">
            <div class="title e235">OWL</div>
            <div class="para e236">
               	OWL by itself is not a rule or test language. It rather allows for declarative semantic
               models. The handling and mapping of ontologies is an important aspect of validation
               [6]. OWL reasoner can determine if there is a conflict based on the characteristics
               of a particular object instance – in our context, a test target - based on a semantic
               definition of class membership. OWL's “open world assumption” makes it difficult to
               use it to validate documents. The open world assumption states that even if an object
               instance has not declared one of its property, the reasoner cannot assume that it
               does not exist. Typically, a programming routine needs to be written to “close the
               world” by explicitly asserting that this object instance has no such property.
               
            </div>
            <div class="para e237">
               	Because OWL is designed for acceptable computational time, its expressivity has been
               limited. Even in OWL Full (the most expressive level of OWL language), the semantic
               expressivity is limited to constraints around cardinalities and a few relationships
               between class and properties such as transitive, inverse, and uniqueness. Expressing
               arithmetic relationships between properties is virtually impossible. There are also
               few reasoner that can perform OWL Full reasoning and more importantly datatype reasoning
               (particularly user defined datatype necessary to validate against a range of values
               or a code list). OWL reasoners typically process data in triple representation, which
               is memory-greedy. Validating a few megabytes of document on a typical desktop with
               one to two gigabytes of memory almost becomes impossible (industrial strength reasoning
               engine and memory or storage management - such as Oracle RDF database - would be needed).
               
            </div>
         </div><a name="XBRLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e238">
            <div class="title e239">XBRL</div>
            <div class="para e240">
               	The XBRL conformance test suite is worth consideration more as a typical use case
               than a reusable tool. It is an example of validating a (set of) complex document(s)
               with advanced semantics, that must comply with various rules in addition to schema
               compliance. It also encompasses the testing of processors supposed to produce such
               documents, illustrating how document-testing and processor-testing are intertwined.
               	The “minimal” conformance suite focuses on the document validation while “full” conformance
               targets XBRL processors. Full conformance involves other documents than the main document
               being processed, and relies on output documents (Post-Taxonomy Validation infosets)
               that reflect the processing semantics. Minimal conformance generally contains at least
               one test for each appearance in the specification of ‘MUST’ that are not already enforced
               by XML Schema validation.
               	The structure of the test suite is based on the OASIS XSL Conformance Suite.  The
               structure of each individual test is simple:
               	
               <div class="itemizedlist e241">
                  <div class="listitem e242">
                     <div class="para e243">.xsd or .xml input material to the XBRL processor (schema, linkbase, instance)</div>
                  </div>
                  <div class="listitem e244">
                     <div class="para e245">A test case file (.xml)</div>
                  </div>
                  <div class="listitem e246">
                     <div class="para e247">An expected output .xml</div>
                  </div>
               </div>
               	Each test case is described by a "meta-level" XML file that refers to associated
               test material. Some XML files are describing the expected outputs for each test case.
               The overall test engine is an ad-hoc stylesheet that runs the tests. The pass / fail
               decision for each case is based on the comparison of canonical forms of actual output
               and expected output.
               	 A first assessment allows to conclude that each test case could be scripted as a
               test assertion. When specialized operations are needed (like file canonicalization
               using infoset.xsl, or file comparison) these could be wrapped as xsl functions used
               in the test assertion expressions. Assuming a two-phase testing process (running XBRL
               processor, then validating results), the test assertion engine described here could
               handle the validation phase, which relies on XML documents.
               
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e248">
         <div class="title e249">Conclusion</div>
         <div class="para e250">
            A general-purpose test methodology based on a formal notion of test assertion (originally
            not intended exclusively for XML input) has proved adequate for the testing of XML
            artifacts where contextual material of various kinds need be taken into account. When
            extended and implemented with XML dialects such as XPath2.0 and XSLT2.0, this method
            has proved more powerful for such XML inputs than dedicated test tools. The resulting
            test model does not introduce a hierarchy of constructs, but uses a flexible notion
            of test assertion as the main construct for expressing atomic test results as well
            as for chaining and composing test units.
            
         </div>
         <div class="para e251">
            Another benefit of the proposed approach is to keep XSLT “under the hood” and not
            make it part of the definition language of test cases. There is also no need to develop
            an XSLT test program specific to a test suite. This contrasts with ad-hoc test suites
            such as XBRL’s. With a robust test assertion model, only XPath needs be mastered by
            test developers.
            
         </div>
         <div class="para e252">
            Future plans include standardization of the TAG mark-up and its XPath extension, along
            with an open-source - style availability of the XSLT-based engine technology that
            supports it.
            
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e253">
         <div class="title e254">Bibliography</div>
         <div class="bibliomixed e255" xml:id="A1" xreflabel="1">Holman, K., Green, S., Bosak, J., McGrath, T., Schlegel, S. ; 
            <div class="emphasis e256" role="ital">Use of XPath to apply constraints to an XML Schema to produce a subset conformance
               profile ;
            </div> UBL 1.0 Small Business Subset; 2006 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e257" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://docs.oasis-open.org/ubl/cs-UBL-1.0-SBS-1.0/</div>
            
         </div>
         <div class="bibliomixed e258" xml:id="A2" xreflabel="2">Durand, J., Kulvatunyou,  S., Woo  J.,and Martin, M. ; 
            <div class="emphasis e259" role="ital">Testing and Monitoring E-Business using the Event-driven Test Scripting Language ;</div> proceedings I-ESA (Interoperability of Enterprise Systems and Applications), April
            2007
            
         </div>
         <div class="bibliomixed e260" xml:id="A3" xreflabel="3">Glushko, R., and McGrath, T. ; 
            <div class="emphasis e261" role="ital">Analyzing and Designing Documents for Business Informatics and Web Services ;</div> MIT Press, March 2008
            
         </div>
         <div class="bibliomixed e262" xml:id="A4" xreflabel="4">Durand, J. ; 
            <div class="emphasis e263" role="ital">"Will Your SOA Systems Work in the Real World?”  ;</div> STAR-East, Software Testing Analysis and Review Conference, May 2007
            
         </div>
         <div class="bibliomixed e264" xml:id="A5" xreflabel="5">Lubell, J., Kulvatunyou, B., Morris, K.C., Harvey, B. ; 
            <div class="emphasis e265" role="ital">A Tool Kit for Implementing XML Schema Naming and Design Rules ;</div> Extreme Markup Languages Conference, August 2006, Montreal, Canada.
            
         </div>
         <div class="bibliomixed e266" xml:id="A6" xreflabel="6">Anicic, N. , Marjanovic, Z. , Ivezic, N. , Jones, A. W. ; 
            <div class="emphasis e267" role="ital">Semantic Enterprise Application Integration Standards ;</div>  International Journal of Manufacturing Technology and Management (IJMTM) , April,
            2006
            
         </div>
         <div class="bibliomixed e268" xml:id="A7" xreflabel="7">Green, S., Holman, K.; 
            <div class="emphasis e269" role="ital">The Universal Business Language and the Needs of Small Business;</div> iTSC Synthesis Journal 2004.
            
         </div>
         <div class="bibliomixed e270" xml:id="A8" xreflabel="8">
            <div class="emphasis e271" role="ital">Test Assertions Guidelines;</div> OASIS TAG technical Committee, February 2009.
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e272" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.oasis-open.org/committees/document.php?document_id=31076</div>
            
         </div>
      </div>
   </div>
</div>