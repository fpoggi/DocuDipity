<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#JSOX:AJustlySimpleObjectizationforXMLANCHOR" name="JSOX:AJustlySimpleObjectizationforXMLTOC">JSOX: A Justly Simple Objectization for XML</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductorymattersANCHOR" name="IntroductorymattersTOC">Introductory matters</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OnverybasicdataandcollectiontypesANCHOR" name="OnverybasicdataandcollectiontypesTOC">On very basic data and collection types</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OnJSONandJavascript'sabstractcollectiontypesANCHOR" name="OnJSONandJavascript'sabstractcollectiontypesTOC">On JSON and Javascript's abstract collection types</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OnXML'sabstractcollectiontypesANCHOR" name="OnXML'sabstractcollectiontypesTOC">On XML's abstract collection types</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AnexampleofatrivialdocumentportionANCHOR" name="AnexampleofatrivialdocumentportionTOC">An example of a trivial document portion</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OnDOMANCHOR" name="OnDOMTOC">On DOM</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#CommonoperationsonarraysanddictionariesANCHOR" name="CommonoperationsonarraysanddictionariesTOC">Common operations on arrays and dictionaries</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OntheimplementationofabstractcollectiontypesANCHOR" name="OntheimplementationofabstractcollectiontypesTOC">On the implementation of abstract collection types</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AfeatureanalysisofabstractcollectiontypesANCHOR" name="AfeatureanalysisofabstractcollectiontypesTOC">A feature analysis of abstract collection types</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XMLcollectiontypesANCHOR" name="XMLcollectiontypesTOC">XML collection types</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#SimplifyingXMLnodetypingANCHOR" name="SimplifyingXMLnodetypingTOC">Simplifying XML node typing</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#MappingtoJavascripttypesandsyntaxANCHOR" name="MappingtoJavascripttypesandsyntaxTOC">Mapping to Javascript types and syntax</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#MappingtoPythontypesandsyntaxANCHOR" name="MappingtoPythontypesandsyntaxTOC">Mapping to Python types and syntax</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TherestoftheXMLNodesANCHOR" name="TherestoftheXMLNodesTOC">The rest of the XML Nodes</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC">Implementation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExtensibilityANCHOR" name="ExtensibilityTOC">Extensibility</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DocumentsANCHOR" name="DocumentsTOC">Documents</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#SummaryANCHOR" name="SummaryTOC">Summary</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Array</div>
         <div class="singletermTERMS">a[2]</div>
         <div class="singletermTERMS">a = [ 1, 2, 3 ]</div>
         <div class="singletermTERMS">a["2"] = "bar"</div>
         <div class="singletermTERMS">a[2] = "bar"</div>
         <div class="singletermTERMS">a["foo"] = "bar"</div>
         <div class="singletermTERMS">a.length</div>
         <div class="singletermTERMS">a["foo"]</div>
         <div class="singletermTERMS">a[3.1]</div>
         <div class="singletermTERMS">a.foo</div>
         <div class="singletermTERMS">append()</div>
         <div class="singletermTERMS">array[n]</div>
         <div class="singletermTERMS">array[start:end]</div>
         <div class="singletermTERMS">array[start:end:interval]</div>
         <div class="singletermTERMS">array[0:20:2]</div>
         <div class="singletermTERMS">array</div>
         <div class="singletermTERMS">all the images,</div>
         <div class="singletermTERMS">Abstract</div>
         <div class="singletermTERMS">ac</div>
         <div class="singletermTERMS">abstract collection</div>
         <div class="singletermTERMS">abstract collection types</div>
         <div class="singletermTERMS">after</div>
         <div class="singletermTERMS">and yet</div>
         <div class="singletermTERMS">ALLC/ACH.</div>
         <div class="singletermTERMS">Argonautica</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
         <div class="singletermTERMS">API</div>
         <div class="singletermTERMS">Abstract collection types</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">buffer</div>
         <div class="singletermTERMS">be</div>
         <div class="singletermTERMS">bag</div>
         <div class="singletermTERMS">both</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">c = n.childNodes[3]</div>
         <div class="singletermTERMS">c = n[3]</div>
         <div class="singletermTERMS">childNodes</div>
         <div class="singletermTERMS">Clever, but not worth the effort.</div>
         <div class="singletermTERMS">chapter</div>
         <div class="singletermTERMS">cdr'ing</div>
         <div class="singletermTERMS">Communications of the ACM</div>
         <div class="singletermTERMS">Consultant</div>
         <div class="singletermTERMS">Container (type theory)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">dict[key]</div>
         <div class="singletermTERMS">DynaText,</div>
         <div class="singletermTERMS">data</div>
         <div class="singletermTERMS">Doesn't fit the way my tools work.</div>
         <div class="singletermTERMS">Document Object Model,</div>
         <div class="singletermTERMS">DupName</div>
         <div class="singletermTERMS">data</div>
         <div class="singletermTERMS">DOM</div>
         <div class="singletermTERMS">Data modeling</div>
         <div class="singletermTERMS">DeRose</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">eval(...)</div>
         <div class="singletermTERMS">expected</div>
         <div class="singletermTERMS">Elm,</div>
         <div class="singletermTERMS">ECMAScriptÂ® Language Specification.</div>
         <div class="singletermTERMS">everything</div>
         <div class="singletermTERMS">element</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">False</div>
         <div class="singletermTERMS">for k,v in od.items()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">h = [ a=&gt;1, b=&gt;2 ]</div>
         <div class="singletermTERMS">h = { 'a':1, n:'2' }</div>
         <div class="singletermTERMS">h["a"]=1, h["b"]=2</div>
         <div class="singletermTERMS">https://archive.org/details/taleofargonauts00apol</div>
         <div class="singletermTERMS">hierarchical.</div>
         <div class="singletermTERMS">hash table</div>
         <div class="singletermTERMS">homogenous</div>
         <div class="singletermTERMS">heterogeneous</div>
         <div class="singletermTERMS">hierarchy</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">item 7 of myArray</div>
         <div class="singletermTERMS">isEqualNode</div>
         <div class="singletermTERMS">is</div>
         <div class="singletermTERMS">indices,</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">just work</div>
         <div class="singletermTERMS">JQuery API.</div>
         <div class="singletermTERMS">Journal of Computing in Higher Education</div>
         <div class="singletermTERMS">JSON</div>
         <div class="singletermTERMS">J.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">key</div>
         <div class="singletermTERMS">keys</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">length</div>
         <div class="singletermTERMS">loading,</div>
         <div class="singletermTERMS">Lay out footnotes this way</div>
         <div class="singletermTERMS">less</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">myArray(1)</div>
         <div class="singletermTERMS">myArray</div>
         <div class="singletermTERMS">myArray[1]</div>
         <div class="singletermTERMS">myArray.1</div>
         <div class="singletermTERMS">Much too complicated.</div>
         <div class="singletermTERMS">mapping</div>
         <div class="singletermTERMS">multiset</div>
         <div class="singletermTERMS">Medea</div>
         <div class="singletermTERMS">Markup Systems</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">nil</div>
         <div class="singletermTERMS">n["*"]</div>
         <div class="singletermTERMS">n["p":1:21]</div>
         <div class="singletermTERMS">n[1:21:"p"]</div>
         <div class="singletermTERMS">nextSibling</div>
         <div class="singletermTERMS">n[3][2].attrs['class']</div>
         <div class="singletermTERMS">native</div>
         <div class="singletermTERMS">name</div>
         <div class="singletermTERMS">NamedArray,</div>
         <div class="singletermTERMS">NamedArray</div>
         <div class="singletermTERMS">names</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">obj.myProp</div>
         <div class="singletermTERMS">obj["myProp"]</div>
         <div class="singletermTERMS">obj.myProp].</div>
         <div class="singletermTERMS">obj[99] = "hello"</div>
         <div class="singletermTERMS">obj</div>
         <div class="singletermTERMS">obj.99</div>
         <div class="singletermTERMS">od["aardvark"] = "Tubulidentata"</div>
         <div class="singletermTERMS">object.propname</div>
         <div class="singletermTERMS">obj[key]</div>
         <div class="singletermTERMS">obj.key</div>
         <div class="singletermTERMS">Object Model</div>
         <div class="singletermTERMS">OrderedDict</div>
         <div class="singletermTERMS">order</div>
         <div class="singletermTERMS">one</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">parentNode</div>
         <div class="singletermTERMS">Priority queue</div>
         <div class="singletermTERMS">para</div>
         <div class="singletermTERMS">Python</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">replaces</div>
         <div class="singletermTERMS">represents</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">sort</div>
         <div class="singletermTERMS">sort()</div>
         <div class="singletermTERMS">set,</div>
         <div class="singletermTERMS">stanza</div>
         <div class="singletermTERMS">special.</div>
         <div class="singletermTERMS">scalar types</div>
         <div class="singletermTERMS">sderose@acm.org</div>
         <div class="singletermTERMS">Steven</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">T&lt;'A'&gt; = 5</div>
         <div class="singletermTERMS">Too much stuff in there.</div>
         <div class="singletermTERMS">tables</div>
         <div class="singletermTERMS">the 3rd footnote in chapter 4,</div>
         <div class="singletermTERMS">the last word of each speech attributed to Medea,</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">target</div>
         <div class="singletermTERMS">to</div>
         <div class="singletermTERMS">The XML ends up about 10% smaller than the JSON</div>
         <div class="singletermTERMS">THE SNOBOL4 PROGRAMMING LANGUAGE</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">x[-1] = 1;</div>
         <div class="singletermTERMS">x[3.1]</div>
         <div class="singletermTERMS">XMLNode</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="JSOX:AJustlySimpleObjectizationforXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973">
      <div class="title e1">JSOX: A Justly Simple Objectization for XML</div>
      <div class="subtitle e2">Or: How to do better with Python and XML</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2014</div>
            <div class="confdates e6">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">XML can be as easy to work with as JSON. However, this has not been obvious until
               now. JSON is easy because it supports only datatypes that are already native to Javascript
               and uses the same syntax to access them (such as [1:10], ["x"], and 
               <div class="quote e9">.</div> notation). XML, on the other hand, supports additional datatypes, and is most commonly
               handled via SAX or DOM, both of which are low-level and meant to be cross-language.
               Typical developers want high-level access that feels 
               <div class="quote e10">native</div> in the language they are using. These shortcomings have little or nothing to do with
               XML, and can be remedied by a different API. Software that demonstrates this is presented
               and described. It uses Python's richer set of abstract datatypes (such as tuples and
               sets), and provides native Python style syntax with richer semantics than JSON or
               Javascript.
            </div>
         </div>
         <div class="author e11">
            <div class="personname e12">
               <div class="firstname e13">Steven</div>
               <div class="othername e14">J.</div>
               <div class="surname e15">DeRose</div>
            </div>
            <div class="personblurb e16">
               <div class="para e17">Steve DeRose has been working with electronic document and hypertext systems since
                  joining Andries van Dam's FRESS project in 1979. He holds degrees in Computer Science
                  and in Linguistics and a Ph.D. in Computational Linguistics from Brown University.
               </div>
               <div class="para e18">He co-founded Electronic Book Technologies in 1989 to build the first SGML browser
                  and retrieval system, 
                  <div class="quote e19">DynaText,</div> and has been deeply involved in standards development including XML, TEI, HyTime,
                  HTML 4, XPath, XPointer, EAD, Open eBook, OSIS, NLM and others. He has served as Chief
                  Scientist of Brown University's Scholarly Technology Group and Adjunct Associate Professor
                  of Computer Science. He has written many papers, two books, and eleven patents. Most
                  recently he has been working as a consultant in text analytics.
               </div>
            </div>
            <div class="affiliation e20">
               <div class="jobtitle e21">Consultant</div>
               <div class="orgname e22"></div>
            </div>
            <div class="email e23">sderose@acm.org</div>
         </div>
         <div class="legalnotice e24">
            <div class="para e25">Copyright Â© 2014 by the author. Used with permission.</div>
         </div>
         <div class="keywordset e26" role="author">
            <div class="keyword e27">Python</div>
            <div class="keyword e28">DOM</div>
            <div class="keyword e29">API</div>
            <div class="keyword e30">XML</div>
            <div class="keyword e31">JSON</div>
            <div class="keyword e32">Abstract collection types</div>
            <div class="keyword e33">Markup Systems</div>
            <div class="keyword e34">Data modeling</div>
            <div class="keyword e35">Container (type theory)</div>
         </div>
      </div><a name="IntroductorymattersANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e36">
         <div class="title e37">Introductory matters</div>
         <div class="para e38">XML and JSON differ in how they punctuate data; this is obvious. Perhaps less obvious
            is how they differ in the topology and semantics they represent. They share a number
            of basic structures, and from 50,000 feet up they're both 
            <div class="quote e39">hierarchical.</div> This paper is concerned first with the superficial problem of syntax, where JSON
            has achieved a reputation in some quarters for being easier to use than XML; and second
            with the subtler but ultimately more important problem of data modeling.
         </div>
         <div class="para e40">This papers intends to demonstrate in a practical way, that JSON's seeming advantage
            over XML in programming convenience actually has little to do with the languages,
            but much to do with how interfaces 
            <div class="emphasis e41" role="ital">to</div> them have been set up in various programming languages. I demonstrate a programming
            interface to XML data, that is far simpler to use than the APIs usually derived from
            DOM (). In addition, the API supports the stronger semantics and topology of XML,
            and so works not only for the simple cases JSON addresses, but also the countless
            cases where XML's richer selection of abstract data types is needed.
         </div>
         <div class="para e42">This paper has two basic points to make:</div>
         <div class="orderedlist e43">
            <div class="listitem e44">
               <div class="para e45">Programming languages can make it far easier to deal with XML, by using their native
                  facilities for abstract collection types, instead of mechanically implementing the
                  DOM API, which is not optimized for any particular language.
               </div>
            </div>
            <div class="listitem e46">
               <div class="para e47">XML brings to the fore a particular abstract collection type that is not widely discussed,
                  but follows logically from an analysis of other common types. Although this type may
                  not arise so commonly in traditional 
                  <div class="quote e48">data</div> tasks, it does arise all the time in dealing with documents. Trying to manage document-shaped
                  information with arrays and hashes is (of course) possible, but exceedingly awkward.
                  A much better solution is to implement the needed type, and make it as natural to
                  deal with in programming, as arrays and hashes are now.
               </div>
            </div>
         </div>
         <div class="para e49">Asking a developer in the 1950s about hash tables (or dictionaries or associative
            arrays), when all they had in their tools were arrays, would likely have provoked
            responses such as: 
            <div class="quote e50">Much too complicated.</div>  
            <div class="quote e51">Doesn't fit the way my tools work.</div>  
            <div class="quote e52">Programs just don't have to deal with that kind of thing very much.</div>  
            <div class="quote e53">Too much stuff in there.</div>  
            <div class="quote e54">You can build that all with stuff I've already got.</div>  
            <div class="quote e55">Clever, but not worth the effort.</div>  Or even, 
            <div class="quote e56">If the experts who built Fortran didn't see it as necessary, why should I?</div> These were also common responses to Unicode, to object-orientation, and to multi-threading.
            They are much the same arguments made now against XML. And although none of these
            features has become completely ubiquitous, few developers would oppose built-in support
            for them.
            <div class="popupBox e57">
               <div class="popupLabel" onmouseover="$('#d1e115').show('1000');" onmouseout="$('#d1e115').hide('1000');">[ footnote ]</div>
               <div id="d1e115" style="display: none;">
                  <div class="footnote">
                     <div class="para e58">In a discussion at 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e59" xlink:actuate="onRequest" xlink:href="http://programmers.stackexchange.com/questions/173573/history-of-associative-array" xlink:show="new" xlink:type="simple">http://programmers.stackexchange.com/questions/173573/history-of-associative-array</div>, Yannis Rizos suggests that Snobol was the first language (around 1967) to provide
                        a dictionary-like tool built in, which it called 
                        <div class="quote e60">tables</div>: 
                        <div class="quote e61">A table is similar to a one-dimensional array. However, instead of referencing an
                           element with an integer, any data object can be used.
                        </div> (
                        <div class="citation e62" linkend="Gri68"></div>, p.&nbsp;19) For example, 
                        <div class="code e63">T&lt;'A'&gt; = 5</div>.
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e64">As with hashes, Unicode, and other advances, I think the key is to build support into
            the fabric of programming. When developers have to understand Unicode to make their
            code Unicode-safe, they're unlikely to put in the effort â they have better things
            to do, or at least, things much more obviously related to the task at hand. Rather,
            the few character-set specialists need to build Unicode-awareness and Unicode-safety
            into the system libraries and utilities (just try feeding Unicode to the usual *nix
            commands!), so they fade into the background and become just the 
            <div class="quote e65">expected</div> behavior. Then developers with better things to do, will use them â and (if the Unicode
            folks do their implementations right) will notice (perhaps long after) that their
            systems work better. Meanwhile, their managers may notice that they can sell in new
            areas with minimal new development costs.
         </div>
         <div class="para e66">I begin, then, with a look at basic abstract collection types, and at JSON (
            <div class="citation e67" linkend="Cro06"></div>), Javascript (
            <div class="citation e68" linkend="ECM11"></div>), XML (
            <div class="citation e69" linkend="Bra08"></div>), and DOM (
            <div class="citation e70" linkend="LeH04"></div>) in light of the types they use and the syntax commonly provided for getting at them.
            The main portion of the paper then examines the more general notion of abstract collection
            types, some data's need (and XML's support) for a type that JSON does not provide,
            and the design and implementation of an interface in Python, to that additional abstract
            collection type. Given that abstract collection type (which is useful for many things
            besides XML), a syntactically-native, language-appropriate, easy-to-use interface
            to XML's more general data becomes easy.
         </div><a name="OnverybasicdataandcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e71">
            <div class="title e72">On very basic data and collection types</div>
            <div class="para e73">Atomic datatypes such as numbers, strings, and Booleans, are ubiquitous in programming,
               and the problems they pose are, if annoying, at least familiar: 
               <div class="code e74">False</div> vs. 
               <div class="code e75">#F</div> vs. 
               <div class="code e76">0</div> vs. 
               <div class="code e77">nil</div>; 
               <div class="code e78">99</div> vs. 
               <div class="code e79">99</div> vs. 
               <div class="code e80">"099"</div>; and a variety of challenges that arise from mathematical and real-world characteristics
               such as precision, spelling complexity and variability, etc.
            </div>
            <div class="para e81">Arrays are lists of data items, with the items commonly of atomic types, but in general
               of any types. Arrays are organized merely by position, generally using non-negative
               integers. High-level programming languages have included them for a very long time,
               and the syntax for accessing them is generally similar, although programming languages
               avoid the literal subscripts we all learned in early math classes. Developers are
               used to accommodating punctuation differences as they change from one language to
               another: 
               <div class="code e82">$myArray[0]</div> vs. 
               <div class="code e83">myArray(1)</div> vs. 
               <div class="code e84">item 7 of myArray</div>.
            </div>
            <div class="para e85">Dictionaries, hashes, or associative arrays instead organize their members via a second
               piece of data for each: a 
               <div class="quote e86">name</div> or 
               <div class="quote e87">key</div>
               <div class="popupBox e88">
                  <div class="popupLabel" onmouseover="$('#d1e192').show('1000');" onmouseout="$('#d1e192').hide('1000');">[ footnote ]</div>
                  <div id="d1e192" style="display: none;">
                     <div class="footnote">
                        <div class="para e89">Properly speaking, 
                           <div class="quote e90">hash table</div> is a data structure very commonly used to implement such keyed collections (binary
                           search trees are another); but the terms are commonly used interchangeably.
                        </div>
                     </div>
                  </div>
               </div>. They are not so ubiquitously built in as arrays.
               Their punctuation similarly varies: 
               <div class="code e91">h = [ a=&gt;1, b=&gt;2 ]</div> vs. 
               <div class="code e92">h = { 'a':1, n:'2' }</div> vs. 
               <div class="code e93">h["a"]=1, h["b"]=2</div> vs. 
               <div class="code e94">(hash ('a 1) ('b 2))</div>, and so on).
            </div>
            <div class="para e95">With minor variations, these types are simple and widespread. Many programming languages
               provide special syntax for each of them; thus, if you know the programming language,
               you know the syntax for using these types. That is a nice advantage when you deal
               with data that is accurately modeled with these types.
            </div>
            <div class="para e96">It is important to keep in mind that there are several levels of abstraction here.
               A file containing 
               <div class="code e97">[ 1, 2, 3 ]</div> is not an array; it 
               <div class="emphasis e98" role="ital">represents</div> one (it may actually 
               <div class="quote e99">be</div> holes in a piece of compressed wood-pulp); or it might represent a vector in a left-handed
               non-orthogonal 3-space. It might be loaded into 12 bytes of RAM, intended to be interpreted
               as 3 32-bit (signed?) integers; or Javascript commonly represents arrays as hashes,
               by converting the indices from integers to strings that it then hashes. Russel and
               others represent an integer 
               <div class="code e100">n</div> as a set nested 
               <div class="code e101">n</div>-levels deep. And in the end, all of these are merely representations of an abstract
               notion of quantity that cannot be directly perceived. For present purposes we need
               not contend with all this ontological complexity; but the differences between these
               notions are central:
            </div>
            <div class="orderedlist e102">
               <div class="listitem e103">
                  <div class="para e104">The representation of data via a sequence of characters in a text file. For example
                     
                     <div class="code e105">{ 'a':1, 'b':2, 'c':"\u2172" }</div>.
                  </div>
               </div>
               <div class="listitem e106">
                  <div class="para e107">The data structure created from the representation via 
                     <div class="quote e108">loading,</div> composed of constructs implemented by those who implement a given programming language.
                     For example, a contiguous sequence of 12 bytes, preceded by 8 extra bytes of overhead
                     such as the width (4) of the entries, the total length of the area, who owns it, etc.
                  </div>
               </div>
               <div class="listitem e109">
                  <div class="para e110">The interface provided to those data structures for application programmers. For example,
                     
                     <div class="code e111">myArray</div>, or 
                     <div class="code e112">myArray[1]</div> or 
                     <div class="code e113">myArray.1</div> for the second item.
                  </div>
               </div>
            </div>
         </div><a name="OnJSONandJavascript'sabstractcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e114">
            <div class="title e115">On JSON and Javascript's abstract collection types</div>
            <div class="para e116">JSON (JavaScript Object Notation) is a way of representing certain data collections
               as text files. JSON, for most purposes, simply 
               <div class="quote e117">is</div> a part of Javascript: a valid JSON file can be pasted in as the right-hand-side of
               a Javascript assignment statement, and should 
               <div class="quote e118">just work</div>. The reverse is true for simple cases, though not in general. In my opinion, this
               is by far the largest factor in JSON's reputed ease of use:
            </div>
            <div class="orderedlist e119">
               <div class="listitem e120">
                  <div class="para e121">JSON supports just the same 
                     <div class="emphasis e122" role="ital">abstract collection types</div> as Javascript: array (sort of) and dictionary. Thus, the mapping from JSON's idea
                     of how data can be structured, to Javascript's, is trivial; there essentially isn't
                     a 
                     <div class="quote e123">mapping</div> at all.
                  </div>
               </div>
               <div class="listitem e124">
                  <div class="para e125">It supports most of the same 
                     <div class="emphasis e126" role="ital">scalar types</div>: integer, floating point number, Boolean, and string.
                  </div>
               </div>
               <div class="listitem e127">
                  <div class="para e128">Its syntax is almost the same as expressions in Javascript. One exception is that
                     one can't interpolate variables, such as 
                     <div class="code e129">[ 1, myVar, "c",...  ]</div>, so one cannot factor out heavily-reused pieces of data except by introducing conventions
                     outside JSON's awareness. Thus JSON as a representation is slightly 
                     <div class="emphasis e130" role="ital">less</div> capable than Javascript; but within it's capabilities it 
                     <div class="quote e131">is</div> Javascript.
                  </div>
               </div>
               <div class="listitem e132">
                  <div class="para e133">Once loading some JSON is finished (which, like saving, can be a one-step process,
                     for example via 
                     <div class="code e134">eval(...)</div>), the programmer accesses any part of the (formerly JSON) data structure just as
                     if it were the same data declared as native constants in Javascript.
                  </div>
               </div>
            </div>
            <div class="para e135">These are all legitimate virtues of JSON. They are greatest for the Javascript programmer,
               but similar advantages apply in many programming languages because similar basic types
               are common.
            </div>
            <div class="para e136">Javascript's (hence JSON's) selection of abstract collection types, while simple,
               is even smaller than programmers are used to dealing with. If anything, it is slightly
               too small, because there is considerable confusion about Javascript's arrays and dictionaries.
            </div>
            <div class="para e137">Javascript objects are essentially dictionaries, in that they can have properties
               which are unordered and are accessed by name, such as 
               <div class="code e138">obj.myProp</div>. Thus, there is not independent dictionary type.
            </div>
            <div class="para e139">There is an 
               <div class="code e140">Array</div> constructor, which makes objects that support the usual array/list operations (including
               
               <div class="code e141">sort</div>), and whose members can be accessed by 
               <div class="code e142">a[2]</div> syntax. They can be initialized with syntax like 
               <div class="code e143">a = [ 1, 2, 3 ]</div>.
            </div>
            <div class="para e144">So far, this is mostly as one would expect. However, an object's members can also
               be accessed with array syntax: 
               <div class="code e145">obj["myProp"]</div>. This accesses the same property as 
               <div class="code e146">obj.myProp].</div> But if you assign 
               <div class="code e147">obj[99] = "hello"</div>, the integer 99 is converted to the string 
               <div class="quote e148">99</div>, and 
               <div class="code e149">obj</div> gains a property named 
               <div class="quote e150">99</div> (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).
               One could access it as 
               <div class="code e151">obj.99</div> except that Javascript syntax does not allow numbers as operands of 
               <div class="quote e152">.</div>. Likewise, if assigning 
               <div class="code e153">a["2"] = "bar"</div> affects the same member as 
               <div class="code e154">a[2] = "bar"</div>.
            </div>
            <div class="para e155">The killer, however, is this: if you explicitly create an array, you can still index
               into it with non-integers: 
               <div class="code e156">a["foo"] = "bar"</div>. You can set and get such members. However, the value of 
               <div class="code e157">a.length</div> does not change unless those strings; it is defined as the number (property name)
               of the last non-negative-number-named element, plus 1. Obviously that means that arrays
               start at 0. You can happily assign to other numeric indices (quoted or not): x[3.0]
               = 1; x[0.3e3] = 1; x[3.000000000000000001] = 1; x[3.1] = 0; 
               <div class="code e158">x[-1] = 1; </div>. However, only the first three of those five become part of the 
               <div class="quote e159">array</div>; the others quietly become properties instead (therefore still accessible as, for
               example, 
               <div class="code e160">x[3.1]</div>
            </div>
            <div class="para e161">As far as I can tell, this amounts to Javascript having only dictionaries, not arrays,
               as data structures, but both as API (the 
               <div class="code e162">Array</div> constructor makes an object with extra properties and methods such as 
               <div class="code e163">length</div>, 
               <div class="code e164">sort</div>, etc.). Array methods work so long as you behave just so. For example, if you make
               an Array and assign to 
               <div class="code e165">a["foo"]</div> or 
               <div class="code e166">a[3.1]</div>, it does create 
               <div class="code e167">a.foo</div>; but (for example) 
               <div class="code e168">a.length</div> does not increase.
            </div>
            <div class="para e169">Implementing other abstract collection types using only dictionaries is (as with all
               Turing-computable matters) possible, but awkward compared to using types whose semantics
               and consequent APIs directly match the problem at hand. In Javascript's case, Arrays
               are fairly intuitive so long as you carefully follow the implicit rules (rules that
               are not checked by the language at all). If you bump up against the edges, things
               get messy.
            </div>
         </div><a name="OnXML'sabstractcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e170">
            <div class="title e171">On XML's abstract collection types</div>
            <div class="para e172">XML must handle documents; that is its reason for existence. While it has proven useful
               for many other things, such as configuration files, database interchange, and even
               sensor data transfer in automative systems, handling all those at the cost of being
               effective for documents would be failure.
            </div>
            <div class="para e173">So what is a document, really? Document structuring and representation clearly require
               at least three things (
               <div class="citation e174" linkend="Coo87"></div>, 
               <div class="citation e175" linkend="DeR90"></div>):
            </div>
            <div class="orderedlist e176">
               <div class="listitem e177">
                  <div class="para e178">
                     <div class="emphasis e179" role="ital">order</div> (this paragraph comes before that one)
                  </div>
               </div>
               <div class="listitem e180">
                  <div class="para e181">
                     <div class="emphasis e182" role="ital">hierarchy</div> (this chapter contains that section, or this strophe contains that stanza)
                  </div>
               </div>
               <div class="listitem e183">
                  <div class="para e184">a wide variety of 
                     <div class="emphasis e185" role="ital">names</div>
                  </div>
               </div>
            </div>
            <div class="para e186">Disregarding the order of speeches in one scene of a play, or of the steps in a repair
               procedure, both lead to absurdity. That is not to say that 
               <div class="emphasis e187" role="ital">everything</div> in XML is ordered; attributes are not, by definition; some bibliography schemas care
               not how the components of each entry are ordered; and there are many other cases.
               But XML does need to support order to support documents.
            </div>
            <div class="para e188">Hierarchy is also essential â it can makes a great deal of difference whether this
               footnote (or quotation, or other object) is part of one section (or pericope, or procedure),
               vs. another. Again, not 
               <div class="emphasis e189" role="ital">everything</div> is very hierarchical; front-matter may simply be a long, flat list of metadata items.
            </div>
            <div class="para e190">Finally, the type-names of various components are extremely important. Aircraft repair
               manuals contain a variety of warnings, some of which may have mandatory layout requirements
               so they cannot be lost in fine print. Citations and bibliographies are very important
               in some genres. Sacred texts are very careful about the distinction between (canonical)
               content and (merely convenient) annotations. Document representations have reified
               such linguistic categories, so they can be used for all kinds of processing: 
               <div class="quote e191">Lay out footnotes this way</div>; 
               <div class="quote e192">Retrieve all the distinct conference proceedings from the bibliography</div>; 
               <div class="quote e193">Check that all the verses are present in this translation of the Gospel of John</div>; 
               <div class="quote e194">Build a table of contents from the first 'title' element in each 'div' not nested
                  more than 3 divs deep
               </div>; and so on.
            </div>
            <div class="para e195">Element type names are handles by which humans organize their thoughts into writing;
               they are also the usual keys by which processing is triggered, much like class and
               method names in programming. This function can be moved around syntactically, but
               remains central (there is a reason that 
               <div class="code e196">&lt;span class="p"&gt;</div> looks strange).
            </div>
            <div class="para e197">At a minimum, any representation that purports to handle documents needs to support
               these capabilities. Child-nodes must be accessible by both name and position, and
               multiple children of the same type must be permissible.
            </div><a name="AnexampleofatrivialdocumentportionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e198">
               <div class="title e199">An example of a trivial document portion</div>
               <div class="para e200">It is sadly true that those who argue that JSON, SQL, or other 
                  <div class="quote e201">data</div> formats are perfectly adequate for documents, rarely show any examples of realistic
                  documents. Rather, the examples virtually always lack hierarchy; even more frequently
                  lack mixed content (an extraordinarily important omission); often have no relevant
                  order; and usually include nothing notionally like attributes (such as properties
                  of elements as wholes; the occasional exception is IDs).
               </div>
               <div class="para e202">Such examples are unconvincing.</div>
               <div class="para e203">CSV and its kin cannot handle documents well because they lack hierarchy; because
                  (in theory though seldom in practice) they lack order), and because while they may
                  have names (for fields) they lack the ability to put named objects in meaningful orders.
                  About the best you can do is (
                  <div class="citation e204" linkend="Way01"></div>, sec. 10):
               </div>
               <div class="programlisting e205" xml:space="preserve">"h1", "10: The Argonauts"
                  ...
                  "p", But the hero essayed to hush their laments and assuage their pain
                  With words of cheer, and he spake,"
                  "quo", "Take up my war-array,"
                  "p-resume", "To the thralls, and with downcast eyes did these in silence obey."
                  
               </div>
               <div class="para e206">Even in this tiny and unusually simple snippet there are many problems: After the
                  quotation the containing paragraph ought to continue on, but because there is no hierarchy
                  some hack must be used to re-start it. The same thing would happen if we tried to
                  separate the section-heading's number and title; reality is far more complex.
               </div>
               <div class="para e207">Documents require an abstract collection type that permits two important kinds of
                  retrieval at every level of a hierarchy: By order (for global processing such as rendering,
                  indexing, and the like); as well as by position (for many analytic and transformation
                  processes). Moreover, these need to work together. Users must be able to refer to
                  things like 
                  <div class="quote e208">the 3rd footnote in chapter 4,</div> 
                  <div class="quote e209">the last word of each speech attributed to Medea,</div> 
                  <div class="quote e210">all the images,</div> and so on.
               </div>
               <div class="para e211">JSON is vastly more capable than CSV, and so can make a more credible attempt to represent
                  documents; the presence of hierarchy is particularly helpful. But the unavailability
                  of collections whose members are both ordered and named still makes it awkward, and
                  to my knowledge JSON has never been seriously used for substantial documents, such
                  as books, articles, manuals, and so on. It is hard to see a general solution much
                  cleaner than this, because arrays are needed to keep order, while something else is
                  needed to distinguish attributes (which form a dictionary) from sub-elements and text:
               </div>
               <div class="programlisting e212" xml:space="preserve">
                  { "book": [
                  { "section": [
                  { "title": [
                  { "n": 10 },
                  "The Argonauts"
                  ]},
                  { "p": [
                  "But the hero essayed to hush their laments and assuage their pain
                  With words of cheer, and he spake, ",
                  { "quo": [
                  "Take up my war-array,"
                  ]},
                  " To the thralls, and with downcast eyes did these in silence obey."
                  ]}
                  ]}
                  ]}
                  
               </div>
               <div class="para e213">This does represent
                  the needed relationships of precedence and containment; but it is
                  far less readable and far more error-prone than XML.
               </div>
               <div class="programlisting e214" xml:space="preserve">&lt;book&gt;
                  &lt;section&gt;
                  &lt;title&gt;&lt;n&gt;10&lt;/n&gt; The Argonauts&lt;/title&gt;
                  &lt;p&gt;But the hero essayed to hush their laments and assuage their pain
                  With words of cheer, and he spake,
                  &lt;quo&gt;Take up my war-array,&lt;/quo&gt;
                  To the thralls, and with downcast eyes did these in silence obey.&lt;/p&gt;
                  &lt;/section&gt;
                  &lt;/book&gt;
                  
               </div>
               <div class="para e215">Having an abstract collection type that actually corresponds to document topology
                  is simply cleaner. A programming language can provide an appropriate interface to
                  that abstract collection type, and thus enable a much clearer and easier interface
                  to XML than hammering XML-shaped pegs into JSON-shaped holes (however nice the latter's
                  fit for JSON-shaped pegs may be).
               </div>
               <div class="para e216">Python has a rich collection of abstract collection types; rich enough to reveal that
                  the type XML most needs, while not built in, fits into a slot implied by the relationships
                  of abstract collection types that are already available in Python. This type's properties
                  are predicted by symmetry: the same distinctive properties displayed by types already
                  observed can be combined in another way.
               </div>
               <div class="para e217">Defining the missing type is one small step for Python. But having taken that step,
                  XML can be treated in Python much as JSON is treated in Javascript. An implementation
                  in this form makes use of XML in Python nearly as trivial as use of JSON in Javascript.
                  And although support for abstract collection types in Python is particularly strong,
                  analogous APIs for XML can be made with little more work in other languages, vastly
                  simplifying use of XML for developers in general.
               </div>
            </div><a name="OnDOMANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e218">
               <div class="title e219">On DOM</div>
               <div class="para e220">DOM, the 
                  <div class="quote e221">Document Object Model,</div> is a standard, widely-used interface to XML structure. The term 
                  <div class="quote e222">Object Model</div> can mean either the set of formal properties of some data object, or a collection
                  of classes and APIs for accessing something. DOM involves mainly the second sense:
                  it is essentially an API.
               </div>
               <div class="para e223">But DOM is not XML, nor the complete object model of XML in the first sense (although
                  it constrains many things about that object model), nor the only way a programmer
                  can access XML data. This paper discusses an alternative way of dealing with XML in
                  programs, yielding the desired simplification for programmers:
               </div>
               <div class="orderedlist e224">
                  <div class="listitem e225">
                     <div class="para e226">DOM was designed generically rather than with any particular programming language
                        in mind. It is thus not optimized to feel native in Javascript or Python or C++ or
                        anything else. When mechanically implemented, it speaks with an accent. But this has
                        nothing to do with XML syntax or semantics, and building more native interfaces is
                        not that hard.
                     </div>
                  </div>
                  <div class="listitem e227">
                     <div class="para e228">DOM includes two levels in the one notion of Node: A Node in itself, and its context
                        in a tree. While perfectly reasonable, this portmanteau approach makes DOM nodes seem
                        much more complex than need be. In addition, there are general features such as userData,
                        namespaces, isSupported, etc. to complicate matters.
                     </div>
                  </div>
                  <div class="listitem e229">
                     <div class="para e230">DOM defines many subclasses of Node, corresponding to SGML syntactic constructs (comments,
                        PIs, documents, etc.), and for HTML the much lower level of individual element types
                        (p, li, i, etc.). This complicates the API to be learned; conceptually, it is as reasonable
                        to think of XML as including only two Node types: elements and leaves; or even 1:
                        Nodes, some of which contain other Nodes and some of which don't.
                     </div>
                  </div>
                  <div class="listitem e231">
                     <div class="para e232">DOM is a quite low-level interface. For example, it does not provide any way to get
                        the 3rd 
                        <div class="quote e233">p</div> element child of a given node; nor even the 3rd 
                        <div class="emphasis e234" role="ital">element</div> as opposed to text nodes. The latter is particularly annoying
                        because text nodes are in many contexts reliably whitespace-only and irrelevant to
                        most or all processing (it is frustrating to write or even just call the same filtering
                        code so many times). Providing higher-level operations helps immensely, as the popularity
                        of libraries such as JQuery (
                        <div class="citation e235" linkend="JQu"></div>) attests.
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="CommonoperationsonarraysanddictionariesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e236">
            <div class="title e237">Common operations on arrays and dictionaries</div>
            <div class="para e238">Arrays and dictionaries are very common; they are reasonably thought of as the
               simplest collection types: one accessed by integer 
               <div class="quote e239">indices,</div> and one by string (usually) 
               <div class="quote e240">keys</div>. This glosses over many differences in theory, implementation, and use, but will
               suffice for the moment. Some common operations are shown here, for a plain Javascript/JSON
               array, and for the children of a DOM node (other aspects of XML and of DOM are discussed
               later).
            </div>
            <div class="table e241">
               <div class="tbody e242">
                  <div class="tr e243">
                     <div class="th e244">Description</div>
                     <div class="th e245">Javascript</div>
                     <div class="th e246">Javascript DOM</div>
                  </div>
                  <div class="tr e247">
                     <div class="td e248">Get first item</div>
                     <div class="td e249">n[0]</div>
                     <div class="td e250">n.firstChild</div>
                  </div>
                  <div class="tr e251">
                     <div class="td e252">Get second item</div>
                     <div class="td e253">n[1]</div>
                     <div class="td e254">n.childNodes(1)</div>
                  </div>
                  <div class="tr e255">
                     <div class="td e256">Items 1-3</div>
                     <div class="td e257">n.slice(0, 3)</div>
                     <div class="td e258">n.childNodes.slice(0,3)</div>
                  </div>
                  <div class="tr e259">
                     <div class="td e260">"eggs" attribute"</div>
                     <div class="td e261">n.eggs</div>
                     <div class="td e262">n.getAttribute("eggs")</div>
                  </div>
                  <div class="tr e263">
                     <div class="td e264">two items equivalent</div>
                     <div class="td e265">n1 == n2</div>
                     <div class="td e266">n1.isEqualNode(n2)</div>
                  </div>
                  <div class="tr e267">
                     <div class="td e268">two items identical</div>
                     <div class="td e269">n1 === n2</div>
                     <div class="td e270">n1.isSameNode(n2)</div>
                  </div>
                  <div class="tr e271">
                     <div class="td e272">replace item 3</div>
                     <div class="td e273">n1[2] = n3</div>
                     <div class="td e274">n1.replaceChild(n2, n3)</div>
                  </div>
               </div>
            </div>
            <div class="para e275">The Javascript is obviously shorter, cleaner, and perhaps most important, in keeping
               with the rest of the language (ignoring the grey area where arrays and dictionaries
               meet, discussed earlier). Of course there is more to a DOM Node; but these illustrate
               some of the most common operations.
            </div>
            <div class="para e276">Already we can see a simple way to make XML structures far easier
               to deal with in programming languages with even minimal collection structures: Just
               use the native array and dictionary syntax instead of functions, for XML constructs
               that are accessed that way. For example, instead of writing 
               <div class="code e277">c = n.childNodes[3]</div>,
               just say 
               <div class="code e278">c = n[3]</div>; this could be done in current Javascript by making Node (or 
               <div class="quote e279">XMLNode</div> or whatever) be a subclass of Array, with the child-pointers as the members, and
               the other data as properties. Although Javascript does not provide operator overloading,
               in languages that do, other simplifications such as 
               <div class="code e280">==</div> instead of 
               <div class="code e281">isEqualNode</div> can also be provided.
            </div>
            <div class="para e282">Such changes are part of the proposal below, but there is much more that can be done
               by taking the document world's requirements for abstract collection types seriously,
               and using languages that have a more robust notion and range of types.
            </div><a name="OntheimplementationofabstractcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e283">
               <div class="title e284">On the implementation of abstract collection types</div>
               <div class="para e285">Computer scientists use the notion of 
                  <div class="emphasis e286" role="ital">abstract collection types</div> to
                  describe various ways in which data items can be aggregated, such as the arrays and
                  dictionaries already discussed. 
                  <div class="quote e287">Abstract</div> in this case means that the datatypes are characterized by their storage and access
                  behaviors (or topology, if you will), rather than by how they are implemented. Arrays
                  are distinct from hashes because one indexes items by position, and the other by name
                  (or more properly 
                  <div class="quote e288">key</div>).
               </div>
               <div class="para e289">Most any abstract collection type can be concretely implemented using most any concrete
                  data structure; this is to be expected with Turing Machines. For example, arrays are
                  often implemented using the 
                  <div class="quote e290">array</div> data structure (a contiguous series of equal-sized memory blocks), but we have already
                  seen that Javascript is an exception. Sparse arrays such as used in high-dimensionality
                  problems in NLP and physics commonly implement arrays using linked lists or even hashes
                  in order not to waste space on large numbers of empty members.
               </div>
               <div class="para e291">Similarly, an abstract dictionary can be implemented in a concrete array: Just put
                  each key and item together in an array, and then make an array out of those arrays
                  as shown below. Large instances might be slow to access, but provide all needed functionality:
               </div>
               <div class="programlisting e292" xml:space="preserve">
                  myDict = [
                  [ 1,
                  [ "Gouda",     [ "Netherlands" ] ],
                  [ "Wisconsin", [ "Wisconsin"   ] ],
                  ],
                  [ 2,
                  [ "Beemster",  [ "Japan"       ] ],
                  ],
                  [ 3,
                  [ "Brie",      [ "France", "USA" ] ],
                  ]
                  ]
                  
               </div>
               <div class="para e293">As should be clear even from this trivial example, implementing an abstract collection
                  type by using a less-than-natural data structure type frequently involves
                  inserting extra layers. In some cases it doubles the number of layers, commonly with
                  alternating arrays and dictionaries. This introduces several problems:
               </div>
               <div class="para e294">First, it's hard to read. Many developers do not carefully align things
                  as in the example above, although balancing brackets and braces by eye is otherwise
                  difficult.
               </div>
               <div class="para e295">Second, debugging bracketing errors is difficult because there are so few notations
                  (commonly 1 or 2) being used to express so many distinctions (one per layer).
               </div>
               <div class="para e296">Third, there are many different ways to introduce the extra layers, so different people
                  will do so in different ways. Therefore, data with the same abstract structure will
                  show up in various concrete forms, and receiving software is unlikely to copy without
                  modification, compromising data portability.
               </div>
            </div><a name="AfeatureanalysisofabstractcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e297">
               <div class="title e298">A feature analysis of abstract collection types</div>
               <div class="para e299">There are several different abstract collection types beyond array and dictionary,
                  that have substantial functional differences. The most obvious example is the 
                  <div class="quote e300">set,</div> which has quite different semantics because it has neither position nor identifiers,
                  only data items.
               </div>
               <div class="para e301">The 
                  <div class="quote e302">Priority queue</div> (used to choose tasks in order of importance or urgency) is another abstract collection
                  type, which introduces a new feature:
                  Its members are accessed by priority, which is very much like a position in an array;
                  however, unlike with an arrays there can be any number of tasks with the same priority.
                  Dictionaries and sets also fail to encompass priority queues.
               </div>
               <div class="para e303">As before, introducing more layers is a likely if messy workaround, such as grouping
                  tasks by level and then grouping the levels:
               </div>
               <div class="programlisting e304" xml:space="preserve">
                  myDict = [
                  [ "Brie",       "France",      3 ],
                  [ "Gouda",      "Netherlands", 1 ],
                  [ "Beemster",   "Japan",       2 ],
                  [ "Wisconsin",  "Wisconsin",   1 ],
                  ]
                  
               </div>
               <div class="para e305">The priority queue is effectively an array but with duplicate positions.
                  The 
                  <div class="quote e306">bag</div> or 
                  <div class="quote e307">multiset</div> provided in many programming libraries is, similarly, a set but with duplicate entries.
               </div>
               <div class="para e308">Some programming languages provide versions of some or all these
                  abstract collection types, which are immutable, or restricted from being modified.
                  When applicable, this can enable certain kinds of optimization.
               </div>
               <div class="para e309">In dynamic contexts queues and stacks are
                  distinct abstract collection types: Their items, after all, are not accessed either
                  by name or by position, but by rule which concern the collection as a whole. However,
                  in immutable contexts (such as data representation) these distinctions are seldom
                  relevant. Either would likely be transmitted as a simple list; the receiving application
                  can do what it likes.
               </div>
               <div class="para e310">This leads me to suggest the following features for distinguishing abstract collection
                  types:
               </div>
               <div class="orderedlist e311">
                  <div class="listitem e312">
                     <div class="para e313">Is the order (position) of entries a way to refer to them?</div>
                  </div>
                  <div class="listitem e314">
                     <div class="para e315">Are entries identified (named) by some key in addition to their value?</div>
                  </div>
                  <div class="listitem e316">
                     <div class="para e317">Can one position identify only one entry? For example, if you store something in myArray[3]
                        and then do so again, the first item is replaced. But if you store another item in
                        a priority queue under the same priority, the first remains.
                     </div>
                  </div>
                  <div class="listitem e318">
                     <div class="para e319">Can one key identify only one entry?</div>
                  </div>
                  <div class="listitem e320">
                     <div class="para e321">Is the data structure mutable?</div>
                  </div>
               </div>
               <div class="para e322">These features define a space of distinct abstract collection types.
                  The space is not entirely orthogonal; for example, the question of whether there can
                  be multiple entries at the same position is moot if the collection type is not ordered
                  (as dictionaries), and the question of whether there can be multiple entries with
                  the same name is moot if the collection type has no names (as sets).
               </div>
               <div class="para e323">A few more properties are commonly distinguished, which are less relevant here:</div>
               <div class="orderedlist e324">
                  <div class="listitem e325">
                     <div class="para e326">Must the data items in each entry all be of the same type? Arrays are sometimes divided
                        into 
                        <div class="quote e327">homogenous</div> ones (in which all entries' data items must be of the same datatype, and
                        
                        <div class="quote e328">heterogeneous</div> ones (in which items can be of mixed types). For example, Python has arrays, which
                        are heterogeneous, and byteArrays which are homogeneous. Collection types rarely place
                        any restriction on entries containing equivalent (or identical) 
                        <div class="emphasis e329" role="ital">data</div> items.
                     </div>
                  </div>
                  <div class="listitem e330">
                     <div class="para e331">Is the type recursive? That is, can it have as members, items of its own type? Typically
                        programs allows collection types to have any types they like as members, so recursion
                        is the norm (as in all of JSON, Python, and XML).
                     </div>
                  </div>
               </div>
               <div class="para e332">The types and their properties are shown below (parenthesized names are not provided
                  by Python).
               </div>
               <div class="table e333" border="1">
                  <div class="tbody e334" align="center">
                     <div class="tr e335">
                        <div class="th e336">Name</div>
                        <div class="th e337">Position</div>
                        <div class="th e338">Named</div>
                        <div class="th e339">DupPos</div>
                        <div class="th e340">DupName</div>
                        <div class="th e341">Immutable form</div>
                     </div>
                     <div class="tr e342">
                        <div class="td e343">set</div>
                        <div class="td e344">0</div>
                        <div class="td e345">0</div>
                        <div class="td e346">â</div>
                        <div class="td e347">0</div>
                        <div class="td e348">frozenset</div>
                     </div>
                     <div class="tr e349">
                        <div class="td e350">(multiset or bag)</div>
                        <div class="td e351">0</div>
                        <div class="td e352">0</div>
                        <div class="td e353">â</div>
                        <div class="td e354">1
                           <div class="popupBox e355">
                              <div class="popupLabel" onmouseover="$('#d1e768').show('1000');" onmouseout="$('#d1e768').hide('1000');">[ footnote ]</div>
                              <div id="d1e768" style="display: none;">
                                 <div class="footnote">
                                    <div class="para e356">Properly speaking, sets allow duplicate entries, not duplicate names; the definition
                                       of the 
                                       <div class="quote e357">DupName</div> feature can be slightly complicated to account for this if desired.
                                    </div>
                                 </div>
                              </div>
                           </div>
                        </div>
                        <div class="td e358">&nbsp;</div>
                     </div>
                     <div class="tr e359">
                        <div class="td e360">dict, defaultdict</div>
                        <div class="td e361">0</div>
                        <div class="td e362">1</div>
                        <div class="td e363">â</div>
                        <div class="td e364">0</div>
                        <div class="td e365">&nbsp;</div>
                     </div>
                     <div class="tr e366">
                        <div class="td e367">Counter</div>
                        <div class="td e368">0</div>
                        <div class="td e369">1</div>
                        <div class="td e370">â</div>
                        <div class="td e371">1</div>
                        <div class="td e372">&nbsp;</div>
                     </div>
                     <div class="tr e373">
                        <div class="td e374">array/list, bytearray</div>
                        <div class="td e375">1</div>
                        <div class="td e376">0</div>
                        <div class="td e377">0</div>
                        <div class="td e378">â</div>
                        <div class="td e379">tuple, string, u string, buffer</div>
                     </div>
                     <div class="tr e380">
                        <div class="td e381">priority queue</div>
                        <div class="td e382">1</div>
                        <div class="td e383">0</div>
                        <div class="td e384">1</div>
                        <div class="td e385">â</div>
                        <div class="td e386">&nbsp;</div>
                     </div>
                     <div class="tr e387">
                        <div class="td e388">OrderedDict</div>
                        <div class="td e389">1</div>
                        <div class="td e390">1</div>
                        <div class="td e391">0</div>
                        <div class="td e392">0</div>
                        <div class="td e393">namedtuple</div>
                     </div>
                     <div class="tr e394">
                        <div class="td e395">?</div>
                        <div class="td e396">1</div>
                        <div class="td e397">1</div>
                        <div class="td e398">0</div>
                        <div class="td e399">1</div>
                        <div class="td e400">&nbsp;</div>
                     </div>
                  </div>
               </div>
               <div class="para e401">Python's 
                  <div class="quote e402">OrderedDict</div> has much in common with XML child sequences.
                  It is a variation on dictionaries, that also remembers in what order members were
                  added. Members can be added with the usual 
                  <div class="code e403">od["aardvark"] = "Tubulidentata"</div> syntax, and accessed by the same name. It remembers the order items were added, and
                  can iterate in that order with 
                  <div class="code e404">for k,v in od.items()</div> items.
               </div>
               <div class="para e405">However, members cannot be set or retrieved by position, nor can they be moved around
                  (except by deleting each and re-adding it to move it to the end). There is not a method
                  to find out what position an item is in. It also cannot support multiple members with
                  the same name as needed for XML. So OrderedDict functions mainly like a regular dictionary,
                  just with a special iterator.
               </div>
               <div class="para e406">From this table it is obvious that there are two case missing: First, Python does
                  not have multisets (some other languages do). They can be simulated easily with Counter.
                  The last row has no Python type, and no convenient way to simulate it. Sets have neither
                  position nor name; arrays have position but no name; dictionaries have name but no
                  position; but where is the final combination? Where is an abstract collection type
                  that has 
                  <div class="emphasis e407" role="ital">both</div> name and position, and can have repetitions of at least one of them?
               </div>
               <div class="para e408">A full-fledged abstract collection type for the final slot turns out to be
                  exactly the structure that XML needs, but that is hardest to simulate using only arrays
                  and/or dictionaries. I call it 
                  <div class="quote e409">NamedArray,</div> and it is described in the next section.
                  <div class="popupBox e410">
                     <div class="popupLabel" onmouseover="$('#d1e877').show('1000');" onmouseout="$('#d1e877').hide('1000');">[ footnote ]</div>
                     <div id="d1e877" style="display: none;">
                        <div class="footnote">
                           <div class="para e411">There is also room, not shown, for variants of OrderedDict and NamedArray that permit
                              multiple members at the same position, by analogy with priority queues. I have not
                              yet investigated these in any detail, but would tentatively suggest they may be useful
                              for fined-grained version control.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="XMLcollectiontypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e412">
            <div class="title e413">XML collection types</div>
            <div class="para e414">XML includes a few collection types, but the specification itself doesn't
               describe or formalize them as such. The attributes of an element form a dictionary.
               The tokens within an attribute of type IDREFS or NMTOKENS form a homogeneous array.
               But the children of a given element do not constitute any of the types discussed so
               far, because 
               <div class="emphasis e415" role="ital">both</div> their names (element type names) and their positions are important. What are they,
               and how can we best access them with typical programming-language syntax?
            </div>
            <div class="para e416">First, consider XML elements. They are the only Nodes (other than the special case
               of Root), that are not leaves in the XML structure: that can have children. DOM provides
               them as an (abstract) array known as 
               <div class="code e417">childNodes</div>, so they are accessed by position. That's fine as far as it goes, especially if languages
               would make them accessible via their native array syntax as shown earlier.
            </div>
            <div class="para e418">The basic goal here is to find a simple mapping of XML structures to the
               native collection syntax and semantics of Python, much like the simple mapping of
               JSON to the native collection syntax and semantics of Javascript.
            </div>
            <div class="para e419">In practice, many operations on XML do not access child nodes by numerical position;
               getting the 20th child is rarely needed, except when iterating over all children.
               Much more common is to want all the children of a given element type This defines
               a basic requirement for an OrderedDict-like abstract collection type to suffice for
               XML.
            </div>
            <div class="para e420">XML as described by DOM has an orthogonal complexity that gets in the way of this:
               The distinction of nodeType and nodeName. Every element has a name such as 
               <div class="quote e421">para</div> or 
               <div class="quote e422">stanza</div>; but there are also several types of nodes that are not elements. This 2-way or 2-level
               distinction complicates XML processing, so to keep the syntax and semantics simple
               it would help to get rid of it. The next section deals with this.
            </div><a name="SimplifyingXMLnodetypingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e423">
               <div class="title e424">Simplifying XML node typing</div>
               <div class="para e425">Every XML node is one of several nodeTypes, as described by DOM. The fundamental ones
                  are element, attribute, text, processing-instruction, root, namespace, and comment
                  (others have to do with physical rather than logical structure, for example CDATA
                  sections and entity references, which need not concern us here).
                  But elements themselves have types (which DOM calls nodeNames), such as 
                  <div class="quote e426">para</div> or 
                  <div class="quote e427">chapter</div>. The overloading of 
                  <div class="quote e428">type</div> is confusing. The simplification proposed here begins by reducing the variety of
                  node-types:
               </div>
               <div class="orderedlist e429">
                  <div class="listitem e430">
                     <div class="para e431">Root is merely a special case of element.</div>
                  </div>
                  <div class="listitem e432">
                     <div class="para e433">Namespace is merely a special case of attribute.</div>
                  </div>
                  <div class="listitem e434">
                     <div class="para e435">Comments and PIs can be thought of as merely special cases of text (or the PI's can
                        be thought of as a special case of an empty element, in order to treat its 
                        <div class="quote e436">target</div> as an attribute, or to accomodate the commonplace of using attribute syntax within
                        PIs). 
                     </div>
                  </div>
               </div>
               <div class="para e437">Let us call the new unified node construct an 
                  <div class="quote e438">Elm,</div> since it is largely similar to DOM Element, but subsumes the other nodes types as
                  well. By introducing reserved Elm names such as 
                  <div class="quote e439">_TEXT</div>, 
                  <div class="quote e440">_PI</div>, 
                  <div class="quote e441">_COMMENT</div>, and 
                  <div class="quote e442">_ROOT</div>, and by treating the text content of such (empty, leaf) Elms as a special attribute,
                  the inventory of node types drops to just Elms and attributes.
               </div>
               <div class="para e443">Conceptually, Elm leaves could treat individual characters as child nodes, rather
                  than strings. This changes little; in Python strings are a list type, and all the
                  usual list operations can apply to them anyway.
               </div>
               <div class="para e444">The attributes of any given Elm form a dictionary, so it is convenient to introduce
                  a specific node to encapsulate an element's attribute list as a whole (including both
                  regular and namespace attributes). This corresponds to the XML Attribute-list.
               </div>
               <div class="para e445">It has often been suggested that the type name of an XML element is merely a special
                  case of an attribute (it applies to the element as a whole, has a simple token as
                  value, comes from a schema-constrained namespace, etc.). So the element type can be
                  treated merely as an attribute, which we may name 
                  <div class="quote e446">_TYPE</div>.
               </div>
               <div class="para e447">Conveniently, the attribute-list is a familiar type (dictionary), and the Elm has
                  all the positive properties of an array (plus the presence and use of names).
               </div>
            </div><a name="MappingtoJavascripttypesandsyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e448">
               <div class="title e449">Mapping to Javascript types and syntax</div>
               <div class="para e450">Javascript at least seems to have notions of accessing array members, and of accessing
                  object properties. As we have seen, their syntax and semantics overlap somewhat; but
                  to implement an abstract collection type for XML child sequences we can maintain the
                  convention that the children of an Elm are identified by number and accessed via array
                  notation; while the attributes of an Elm are identified by name and accessed via property
                  notation.
                  <div class="popupBox e451">
                     <div class="popupLabel" onmouseover="$('#d1e965').show('1000');" onmouseout="$('#d1e965').hide('1000');">[ footnote ]</div>
                     <div id="d1e965" style="display: none;">
                        <div class="footnote">
                           <div class="para e452">
                              <div class="quote e453">_</div> is used to prefix reserved names such as 
                              <div class="quote e454">_TYPE</div> because it is an acceptable identifier-start character in Javascript, Python, and
                              many other languages. XML names can, however, also include colon, period, and hyphen,
                              which would necessitate using Javascript bracket notations instead of dot notation.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e455">This is enough to permit a much more palatable syntax for dealing with XML structures
                  in Javascript. Such an implementation may want to support the existing DOM methods
                  and properties as well, to ease the way for existing users.
               </div>
            </div><a name="MappingtoPythontypesandsyntaxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e456">
               <div class="title e457">Mapping to Python types and syntax</div>
               <div class="para e458">Given the same unification of subtypes of Node just discussed, the collection of a
                  node's children fits neatly into the taxonomy of abstract collection types discussed
                  earlier, as a more functional analog to OrderedDict. I call it 
                  <div class="quote e459">NamedArray</div>. The basic properties of this new type are:
               </div>
               <div class="orderedlist e460">
                  <div class="listitem e461">
                     <div class="para e462">Order of members is maintained.</div>
                  </div>
                  <div class="listitem e463">
                     <div class="para e464">All the usual array operations are supported, such as accessing members by position,
                        splicing, etc. (
                        <div class="code e465">sort()</div> probably won't be used much for XML, but may be for other applications of NamedArray).
                        Operations that insert members by position (such as 
                        <div class="code e466">append()</div>) take an extra parameter for the name.
                     </div>
                  </div>
                  <div class="listitem e467">
                     <div class="para e468">Like in regular dictionaries, each member of a NamedArray has a name (which is a string
                        for the XML case, but which Python in general would allow to be of any hashable type).
                     </div>
                  </div>
                  <div class="listitem e469">
                     <div class="para e470">Unlike in regular dictionaries, NamedArrays may have multiple entries with the same
                        name (at different positions).
                     </div>
                  </div>
                  <div class="listitem e471">
                     <div class="para e472">All the usual dictionary operations are supported, such as accessing members by name.
                        However, the semantics are slightly different because duplicate names are permitted.
                        Assigning to a member solely by name replaces the first member with that name; so
                        does deleting by name. Members can also be referred to by name and number simultaneously,
                        which refers to the n-th member with the given name.
                     </div>
                  </div>
                  <div class="listitem e473">
                     <div class="para e474">The reserved name 
                        <div class="quote e475">*</div> matches any Elm node type name, but not any of the reserved (
                        <div class="quote e476">_</div>-initial) names.
                     </div>
                  </div>
               </div>
               <div class="para e477">The specific syntax for these operations is described below.</div>
               <div class="para e478">This provides the most commonly-needed operations for XML. Child nodes can be iterated
                  over by number, and the sequence can be edited by the usual splice, append, and other
                  list operations (as in DOM, but with more natural syntax). However, it is equally
                  easy to iterate over all the comments, PIs, text nodes, elements, or elements of a
                  given type, or simply slice out the elements of a given type. These are extremely
                  common requirements in XML processing.
               </div>
               <div class="para e479">This idea led the author to investigate what it takes to support an additional collection
                  type in Python, with the native syntactic niceties.
               </div>
               <div class="para e480">Python doesnât have only the 
                  <div class="code e481">array[n]</div> notation for arrays. It also provides slicing such as 
                  <div class="code e482">array[start:end]</div> (note that the 2nd argument specifies the entry 
                  <div class="emphasis e483" role="ital">after</div> the last one desired â this is commonly convenient). It also provides 
                  <div class="code e484">dict[key]</div> notation, and a separate notion of object properties, accessed like 
                  <div class="code e485">object.propname</div>
                  <div class="popupBox e486">
                     <div class="popupLabel" onmouseover="$('#d1e1036').show('1000');" onmouseout="$('#d1e1036').hide('1000');">[ footnote ]</div>
                     <div id="d1e1036" style="display: none;">
                        <div class="footnote">
                           <div class="para e487">This is distinctive: Perl uses 
                              <div class="code e488">[]</div> for arrays, 
                              <div class="code e489">{}</div> for dicts, and lacks 
                              <div class="code e490">.</div> notation. Javascript uses 
                              <div class="code e491">array[n]</div>, 
                              <div class="code e492">obj[key]</div>, and 
                              <div class="code e493">obj.key</div>, but they are largely synonymous.
                           </div>
                        </div>
                     </div>
                  </div>.
               </div>
               <div class="para e494">Finally, Python has an unusual but very useful 
                  <div class="code e495">array[start:end:interval]</div> notation. For example, 
                  <div class="code e496">array[0:20:2]</div> retrieves every other item from among the array's first 20 entries. This is said
                  to be heavily used with the numpy/scipy scientific and math packages.
               </div>
               <div class="para e497">As with the abstract collection types, there turns out to be a natural combination
                  of these
                  features which is not built in to Python, but is an excellent fit for XML:
               </div>
               <div class="table e498">
                  <div class="tbody e499">
                     <div class="tr e500">
                        <div class="th e501">Description</div>
                        <div class="th e502">DOM</div>
                        <div class="th e503">Pythonish</div>
                     </div>
                     <div class="tr e504">
                        <div class="td e505">Get first child</div>
                        <div class="td e506">n.firstChild</div>
                        <div class="td e507">n[1]</div>
                     </div>
                     <div class="tr e508">
                        <div class="td e509">Get second child</div>
                        <div class="td e510">n.childNodes(2)</div>
                        <div class="td e511">n[2]</div>
                     </div>
                     <div class="tr e512">
                        <div class="td e513">Get last child</div>
                        <div class="td e514">n.lastChild</div>
                        <div class="td e515">n[-1]</div>
                     </div>
                     <div class="tr e516">
                        <div class="td e517">children 1-3</div>
                        <div class="td e518">n.childNodes.slice(0,3)</div>
                        <div class="td e519">n[1, 4)</div>
                     </div>
                     <div class="tr e520">
                        <div class="td e521">two nodes equivalent</div>
                        <div class="td e522">n1.isEqualNode(n2)</div>
                        <div class="td e523">n1 == n2</div>
                     </div>
                     <div class="tr e524">
                        <div class="td e525">two nodes identical</div>
                        <div class="td e526">n1.isSameNode(n2)</div>
                        <div class="td e527">n1 === n2</div>
                     </div>
                     <div class="tr e528">
                        <div class="td e529">replace third child </div>
                        <div class="td e530">n1.replaceChild(n2, n3)</div>
                        <div class="td e531">n1[2] = n3</div>
                     </div>
                     <div class="tr e532">
                        <div class="td e533">get first "p" child</div>
                        <div class="td e534"></div>
                        <div class="td e535">n["p"]</div>
                     </div>
                     <div class="tr e536">
                        <div class="td e537">get third "p" child</div>
                        <div class="td e538"></div>
                        <div class="td e539">n["p":3]</div>
                     </div>
                     <div class="tr e540">
                        <div class="td e541">get last "p" child</div>
                        <div class="td e542"></div>
                        <div class="td e543">n["p":-1]</div>
                     </div>
                     <div class="tr e544">
                        <div class="td e545">get the first 20 "p" children</div>
                        <div class="td e546"></div>
                        <div class="td e547">n["p":1:21]</div>
                     </div>
                     <div class="tr e548">
                        <div class="td e549">get all "p" children from among the first 20 children</div>
                        <div class="td e550"></div>
                        <div class="td e551">n[1:21:"p"]</div>
                     </div>
                     <div class="tr e552">
                        <div class="td e553">walk down by types</div>
                        <div class="td e554"></div>
                        <div class="td e555">doc[âchapâ:3][âsecâ:2]["p"]</div>
                     </div>
                  </div>
               </div>
               <div class="para e556">It is often helpful to be able to get all child Nodes that are in fact elements; as
                  noted earlier 
                  <div class="code e557">n["*"]</div> is
                  defined to do this. The reserved Elm types 
                  <div class="quote e558">_TEXT</div>, 
                  <div class="quote e559">_PI</div>, 
                  <div class="quote e560">_COMMENT</div>, 
                  <div class="quote e561">_ROOT</div>, and 
                  <div class="quote e562">_ATTLIST</div> are simply names when XML uses NamedArray, so NamedArray itself has no awareness
                  of XML convention.
               </div>
               <div class="para e563">NamedArray is mutable, and does not require homogeneity. The members can be data of
                  whatever type. In an XML document many will be Elms, some of which contain NamedArrays
                  of its own; leaf nodes, however, could be inserted as raw strings, or as separate
                  objects corresponding to DOM's Text, Comment, and PI nodes; NamedArray doesn't care.
               </div>
               <div class="para e564">This seems, at least to this author, quite intuitive. The various slicing options
                  make the interface considerably higher-level, and the general applicability of 
                  <div class="code e565">[]</div> considerably reduces the number of methods and properties required to achieve DOM's
                  functionality.
               </div>
               <div class="para e566">The subtlest detail is
                  perhaps the distinction between 
                  <div class="code e567">n["p":1:21]</div> and 
                  <div class="code e568">n[1:21:"p"]</div>. The former retrieves all children named 
                  <div class="quote e569">p</div>, and then retrieves the first 20 of those; the second instead retrieves the first
                  20 children, and then extracts
                  all of those that are named 
                  <div class="quote e570">p</div>. That is, the slicing operations go from left to right. This may seem familiar to
                  users of XPath's successive 
                  <div class="code e571">[]</div> filters.
               </div>
            </div><a name="TherestoftheXMLNodesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e572">
               <div class="title e573">The rest of the XML Nodes</div>
               <div class="para e574">So far we have modeled only the child-sequence requirements of XML, using a new abstract
                  collection type that is not XML-specific, and that fits neatly into the pattern of
                  Python's already-existing types. However, there is more to an XML node than a NamedArray
                  of children: it also has attributes, references to neighboring nodes, properties related
                  to namespaces, and a variety of methods.
               </div>
               <div class="para e575">To begin with attributes, in Javascript they are probably best implemented as properties;
                  however, this can lead to name clashes in relation to properties that are part of
                  the Node implementation (
                  <div class="code e576">nextSibling</div>, etc.). Another option, which seems better when it is possible, is to keep them all
                  in a dictionary. The dictionary in turn can be a property, or as suggested below,
                  the first member of the NamedArray.
               </div>
               <div class="para e577">JSOX has a full-fledged dictionary representing the attribute list as a whole.
                  Because the Elm type (which subsumes DOM nodeType and nodeName) is always present,
                  and considered a reserved attribute, every Elm has at least one member in that dictionary.
                  I favor placing the Attlist dictionary at position 0 in the child sequence, considering
                  it a node in the same way that PIs, comment, and text portions are nodes. Placing
                  it at position 0 fits with where it appears in XML syntax, while also hinting that
                  it is 
                  <div class="quote e578">special.</div> With slicing operations, it can be included or excluded at desired. I see this as
                  a rather nice compromise between (a) most programming languages using 0-based arrays,
                  and (b) many people thinking of the first 
                  <div class="emphasis e579" role="ital">element</div> as #1. Those who disagree can put the attributes elsewhere with no substantial effect
                  on the rest of this proposal.
               </div>
               <div class="para e580">The other DOM properties (
                  <div class="code e581">parentNode</div>, etc.) are provided as properties as usual, as are more
                  Python-native synonyms: cloneNode (copy), textContent (toString),
                  appendChild (append), hasChildNodes and hasAttribute (in), removeAttribute (del),
                  removeChild (del), etc.
               </div>
            </div>
         </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e582">
            <div class="title e583">Implementation</div>
            <div class="para e584">In Python most operators are just shorthand for function calls, and one can override
               the function definitions. The 
               <div class="code e585">[]</div> notation invokes 
               <div class="code e586">__getitem__()</div>. Python already accepts 3 arguments to the bracket notation, and tests show that
               any of them can be a string instead of an integer. Thus, the semantics just described
               are easily implemented:
            </div>
            <div class="programlisting e587" xml:space="preserve">def __getitem__(self, n1, n2=None, n3=None):
               t1 = t2 = t3 = None
               nargs = 1; t1 = type(n1)
               if (n2 != None): nargs = 2; t2 = type(n2)
               if (n3 != None): nargs = 3; t3 = type(n3)
               
               if (nargs==1):
               if (t1==StringType):
               if (name == '*'): return(self.getElements());
               return(self.getByName(t1)[1])
               else:
               return(self._subdata[int(t1)])
               elif (nargs==2):
               if (t1==IntType):
               if (t2==IntType):
               return(self._subdata[t1:t2])
               else:
               return(self.getByName(t2)[t1])
               else:
               if (t2==IntType):
               return(self.getByName(t1)[t2])
               else:
               raise(TypeError)
               return(None)
               else: # nargs==3
               if (t1==IntType and t2==IntType):
               if (t3==IntType):
               return(self._subdata[t1:t2:t3])
               else:
               return(self._subdata[t1:t2].getByName(t3))
               elif (t2==IntType and t3==IntType):
               return(self.getByName(t1)._subdata[t2:t3])
               else:
               raise(TypeError)
               return(None)
               
            </div>
         </div><a name="ExtensibilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e588">
            <div class="title e589">Extensibility</div>
            <div class="para e590">The same kinds of indexing along all the XPath axes (
               <div class="citation e591" linkend="Cla99"></div>) would be similarly useful, perhaps exposed
               as lazily-evaluated properties of type array-of-Node. Some form of lazy evaluation
               or indexing is important here, lest enumerating all preceding or following elements
               be too expensive. It may be that Python's 
               <div class="code e592">buffer</div> type, which supports read-only access to successive subsequences of a sequence (reminiscent
               of Scheme 
               <div class="quote e593">cdr'ing</div> down a list) would provide an effective approach.
            </div>
            <div class="para e594">Although XML's child sequences are modelled well by NamedArray models, documents sometimes
               contain particular components that are logically other types. For example, the rows
               in a table body form an array, while the members of a definition list or glossary
               may form a dictionary, and a shopping list might form a set. Often the difference
               is visible only in a schema or documentation:
            </div>
            <div class="programlisting e595" xml:space="preserve">&lt;!ELEMENT tbody    (tr*)&gt;
               &lt;!ELEMENT glossary (term, definition)*&gt;
               
            </div>
            <div class="para e596">All these can be modeled via NamedArray, but it is more perspicuous to provides no
               syntactic way to indicate that a particular element (type or instance) is conceptually
               a more constrained type, such as array, set, or dict (schema languages can specify
               such semantics, of course). This could be a useful addition both to add clarity to
               XML data, and to aid performance and perspicuity to implementations.
            </div>
            <div class="para e597">Were XML not so well established and so widely and compatibly implemented, this distinction
               could be
               accomplished by some minor syntactic enhancements, such as these which trade on the
               familiarity of arrays and dicts:
            </div>
            <div class="programlisting e598" xml:space="preserve">&lt;x&gt;   &amp;#8212; for the usual XML childSequence
               &lt;[x]&gt; &amp;#8212; to indicate the children constitute a logical array
               &lt;{x}&gt; &amp;#8212; to indicate the children constitute a logical dictionary
               
            </div>
            <div class="para e599">I find this intuitive, but in addition to not being XML-compatible, one runs out of
               punctuation too soon â what would sets use?
               
               <div class="code e600">&lt;&lt;x&gt;&gt;</div>?
               
               <div class="code e601">&lt;âxâ&gt;</div>?
               
               <div class="code e602">&lt;ãxã&gt;</div>?
            </div>
            <div class="para e603">A better solution on both counts is to define a namespace in which the abstract types
               are enumerated (
               <div class="quote e604">ac</div> for 
               <div class="quote e605">abstract collection</div>):
            </div>
            <div class="programlisting e606" xml:space="preserve">&lt;x ac:type="childSequence"&gt;
               &lt;x ac:type="array"&gt;
               &lt;x ac:type="dict"&gt;
               
            </div>
            <div class="para e607">This allows complete extensibility, even for specifying finer properties such
               as homogeneity, recursion, etc.
            </div>
         </div>
      </div><a name="DocumentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e608">
         <div class="title e609">Documents</div>
         <div class="para e610">We now come to the most widespread XML use case for which JSON does not suffice: documents.
            Let us take the 
            <div class="emphasis e611" role="ital">á¼ÏÎ³Î¿Î½Î±ÏÏÎ¹ÎºÎ¬</div> or 
            <div class="emphasis e612" role="ital">Medea</div> as an example (both, after all, have much to do with Jason). As with most documents,
            such works contain long sequences of content objects â many of them verse lines, but
            intermixed with other types: quotations, stanza and section boundaries, and in some
            editions notes, links, catchwords, illustrations, stage directions, and so forth.
         </div>
         <div class="para e613">It should be evident to the reader that re-ordering the parts of a book or chapter
            (or a Web page) in the manner of a JSON hash table is rather worse than mere inconvenience
            (such as seen with the  examples above). So when JSON 
            <div class="quote e614">replaces</div> XML, what is to be done? It is a commonplace that perhaps 80-90% even of corporate
            data, resides in documents rather than databases; but whatever that precise figure
            may be, Appolonius of Rhodes, Clement of Alexandria, and Harry of Hogwarts are not
            going away.
         </div>
         <div class="para e615">In JSON only arrays preserve order, so they must be used. But an array of strings
            is entirely inadequate; one must reconstruct the entire hierarchy of books, chapters,
            sections, stanzas, verse lines, footnotes, and whatever else, via arrays. Then, since
            arrays provide no place to label their entries, each entry must become a collection
            of its own; perhaps a tuple such as 
            <div class="code e616">["stanza", "...." ]</div>, or a dictionary such as 
            <div class="code e617">{"label":"stanza", "content":"...." }</div>.
         </div>
         <div class="para e618">The latter has the advantage of supporting additional properties, whether for formatting,
            linking and notes, or meta-textual information such as that the stanza is missing
            from certain manuscripts. As always, indirection can be used to make an infinite variety
            of hacks possible; but once we have addressed even the most rudimentary demands of
            actual documents, JSON's limitation to arrays and hashes forces us into unintuitive,
            needlessly complex representations.
         </div>
         <div class="para e619">I carried out such a conversion for the much simpler case of Twitter data. By taking
            typical advantage of attributes, the data at once becomes:
         </div>
         <div class="orderedlist e620">
            <div class="listitem e621">
               <div class="para e622">More readable (this, of course, is always subjective).</div>
            </div>
            <div class="listitem e623">
               <div class="para e624">Easily processable for multiple purposes (linguistic processing can ignore attributes,
                  style calculation can ignore content, rendering can use everything, ...).
               </div>
            </div>
            <div class="listitem e625">
               <div class="para e626">Usable with generic software (because the notion of labeled 
                  <div class="emphasis e627" role="ital">and yet</div> ordered items is required for all XML software, but for no JSON software).
               </div>
            </div>
            <div class="listitem e628">
               <div class="para e629">Smaller. 
                  <div class="emphasis e630" role="ital">The XML ends up about 10% smaller than the JSON</div>, with names and whitespace for pretty-printing kept constant. This is partly because
                  attribute names do not need to be quoted, unlike alphanumeric JSON dictionary keys.
               </div>
            </div>
            <div class="listitem e631">
               <div class="para e632">Validatable. This is a particularly important issue. Although it would be possible
                  to design schema languages for JSON, none seem to exist at present. Thus, while it
                  is very easy to save and load JSON from Javascript, it is not at all easy to describe
                  exactly what structure you are sending, or to check that it's right. This rules out
                  JSON for mission-critical applications, unless a special process is created for checking.
               </div>
            </div>
         </div>
         <div class="para e633">XML has been called "verbose."
            But this is often simply wrong. First, skilled rather than mechanical use of XML is
            often syntactically more compact than JSON.
            For example, schemas for XML support default values,
            and in many data-intensive applications many entries have the default
            value (that's why it's the default). Omitting them can
            save a lot; but in JSON, unlike XML, defaults must be implemented at a higher level.
            Second, data compression works very effectively on frequently-repeated things like
            tags. An email exchange on the xml-dev list long ago addressed this in detail (discussed
            by Edd Dumbill at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e634" xlink:actuate="onRequest" xlink:href="http://www.xml.com/pub/a/2004/12/15/deviant.html)." xlink:show="new" xlink:type="simple">http://www.xml.com/pub/a/2004/12/15/deviant.html).</div>
            Third, safe use of JSON often requires processing it twice. Because JSON is essentially
            a subset of Javascript code, it is tempting to simply "eval" it in order to get it
            parsed. Doing so opens the door to injection attacks. The easiest way to avoid this
            is to run a separate regex match first (
            <div class="citation e635" linkend="Cro06"></div>).
         </div>
      </div><a name="SummaryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e636">
         <div class="title e637">Summary</div>
         <div class="para e638">JSON has established itself as an easy way to get data in and out of Javascript programs;
            that is a good and useful thing. This paper, however, contends that XML's reputation
            for relative complexity or difficulty in that context arose in large measure because
            Javascript mechanically translated the language-agnostic Document Object Model to
            become it's API for XML data, rather than choosing syntax and signatures tailored
            to the Javascript sprachgefÃ¼hl.
            <div class="popupBox e639">
               <div class="popupLabel" onmouseover="$('#d1e1355').show('1000');" onmouseout="$('#d1e1355').hide('1000');">[ footnote ]</div>
               <div id="d1e1355" style="display: none;">
                  <div class="footnote">
                     <div class="para e640">Linguists and translators will recognize this as the classic choice between "literal"
                        and "idiomatic" translations in natural language; the format may (or may not) be more
                        precise, but are far less readable, and often feel "foreign," leading to lower acceptance
                        by readers.
                     </div>
                  </div>
               </div>
            </div>
            Javascript programmers accessing XML structures write, for example, 
            <div class="code e641">n.childNodes[3].childNodes[2].getAttribute('class')</div> when they would quite sensibly rather write 
            <div class="code e642">n[3][2].attrs['class']</div> â countless times.
         </div>
         <div class="para e643">There is no reason this has to be the case. Even in Javascript, with a very small
            inventory of abstract collection types and little ability to extend syntax (for example
            by operator overloading), there is no reason not to provide the latter, or some similar
            more native and less annoying syntax.
         </div>
         <div class="para e644">Python provides operator overloading, and so can do even better at providing "native"
            feel for non-Python-derived formats. Such a Python interface to XML structures is
            presented. It provides far higher-level functionality than DOM, such as filtering
            nodes by nodeType and nodeName, slicing and splicing groups of children, and so on.
            The code to implement it is so small that the main portion is included here.
         </div>
         <div class="para e645">However, a deeper question arises when one considers just what abstract collection
            type XML data represents. Most XML constructs constitute ordinary arrays or dictionaries,
            the most basic and widespread collection types. However, the sequence of children
            of a given node does not, in part because it is organized and accessed by 
            <div class="emphasis e646" role="ital">both</div> position and name. An analysis of Python's abstract collection types into their distinctive
            features reveals that XML child sequences fit
            into a symmetry gap in the pattern. This paper presents a 
            <div class="quote e647">NamedArray</div> type and implementation to fill that gap.
         </div>
         <div class="para e648">Some have suggested that JSON will "replace" XML, supposedly because it is simpler
            but still adequate. But any difference in simplicity is minor once you have an appropriate
            API; and JSON has not yet shown itself adequate for XML's primary application space:
            documents. Examples that accompany claims of JSON's adequacy uniformly lack the most
            salient distinctive characteristics of documents. As one example (at the time of writing)
            Wikipedia's article "Document-oriented databases" gave (only) these two examples of
            "documents":
         </div>
         <div class="programlisting e649" xml:space="preserve">{
            FirstName: "Bob",
            Address: "5 Oak St.",
            Hobby: "sailing"
            }
            
            {
            FirstName: "Jonathan",
            Address: "15 Wanamassa Point Road",
            Children: [
            {Name: "Michael", Age: 10},
            {Name: "Jennifer", Age: 8},
            {Name: "Samantha", Age: 5},
            {Name: "Elena", Age: 2}
            ]
            }
            
         </div>
         <div class="para e650">The second at least contains 
            <div class="emphasis e651" role="ital">one</div> example of repetition, and represents it via hierarchy. This is more than many published
            examples,
            but there is not a hint of heterogeneous child sequences; of the same component type
            appearing at multiple levels; of non-trivial nesting; of anything like the distinction
            of sub-parts vs. properties of components; nor mention of schemas, constraints, defaults,
            inheritance, or validation issues.
         </div>
         <div class="para e652">Such examples do nothing to strengthen JSON's case for adequacy in the document world,
            however handy it is in the word of simple non-document data. An adequate system for
            documents must take real account of the fundamental characteristics of documents.
            If the simpler concepts and structures of regular and associative arrays sufficed
            for the world of documents and literature, we'd all have saved ourselves a lot of
            trouble by talking in SQL long ago.
         </div>
         <div class="para e653">Thus I conclude that JSON, while an excellent idea for the niche of config files,
            transmission of simple / tabular / homogeneous data structure, is insufficient to
            handle documents perspicuously. Until it does, the XML world need have no anxiety
            on its account; though we should undertake a more serious effort to make XML more
            accessible to developers new to the field, or in neighboring fields that interacting
            with XML only peripherally.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e654">
         <div class="title e655">Bibliography</div>
         <div class="bibliomixed e656" xml:id="Bra08" xreflabel="Bra08">Bray, Tim, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, FranÃ§ois Yergeau.
            
            <div class="quote e657">Extensible Markup Language (XML) 1.0 (Fifth Edition).</div>
            W3C Recommendation 26 November 2008.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e658" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/REC-xml/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/REC-xml/</div>
         </div>
         <div class="bibliomixed e659" xml:id="Cla99" xreflabel="Cla99">Clark, James and Steve DeRose. 1999.
            XML Path Language (XPath). Version 1.0. W3C Recommendation 16 November 1999.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e660" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath/</div>
         </div>
         <div class="bibliomixed e661" xml:id="Coo87" xreflabel="Coo87">Coombs, James H., Allen H. Renear, Steven J. DeRose. 1987.
            
            <div class="quote e662">Markup systems and the future of scholarly text processing.</div>
            
            <div class="emphasis e663" role="ital">Communications of the ACM</div> 30(11): 933-947.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e664" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=32209" xlink:show="new" xlink:type="simple">http://dl.acm.org/citation.cfm?id=32209</div>
         </div>
         <div class="bibliomixed e665" xml:id="DeR90" xreflabel="DeR90">DeRose, Steven, David G Durand, Elli Mylonas, and Allen Renear. Winter 1990.
            
            <div class="quote e666">What is text, really? </div>
            
            <div class="emphasis e667" role="ital">Journal of Computing in Higher Education</div>
            1(2): 3-26. Springer US.
            doi:
            <div class="biblioid doi e668">10.1007/BF02941632</div>. ISSN 1042-1726.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e669" xlink:actuate="onRequest" xlink:href="http://link.springer.com/article/10.1007%2FBF02941632" xlink:show="new" xlink:type="simple">http://link.springer.com/article/10.1007%2FBF02941632</div>
         </div>
         <div class="bibliomixed e670" xml:id="Dur96" xreflabel="Dur96">Durand, David G., Elli Mylonas, Steven DeRose. 1996.
            
            <div class="quote e671">What Should Markup Really Be:
               Applying theories of text to the design of markup systems.
            </div> 
            <div class="emphasis e672" role="ital">ALLC/ACH.</div>
         </div>
         <div class="bibliomixed e673" xml:id="Cro06" xreflabel="Cro06">Crockford, D. 2006.
            
            <div class="quote e674">The application/json Media Type for JavaScript Object Notation (JSON)</div>
            IETF RFC 4627.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e675" xlink:actuate="onRequest" xlink:href="http://www.ietf.org/rfc/rfc4627.txt" xlink:show="new" xlink:type="simple">http://www.ietf.org/rfc/rfc4627.txt</div>
         </div>
         <div class="bibliomixed e676" xml:id="ECM11" xreflabel="ECM11">ECMA International.
            
            <div class="quote e677">ECMAScriptÂ® Language Specification.</div>
            Standard ECMA-262, 5.1 Edition / June 2011.
            Geneva: Ecma International.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e678" xlink:actuate="onRequest" xlink:href="http://www.ecma-international.org/ecma-262/5.1/" xlink:show="new" xlink:type="simple">http://www.ecma-international.org/ecma-262/5.1/</div>
         </div>
         <div class="bibliomixed e679" xml:id="Gri68" xreflabel="Gri68">
            Griswold, R. E.,  J. F. Poage, I. P. Polonsky. 1968, 1971.
            
            <div class="emphasis e680" role="ital">THE SNOBOL4 PROGRAMMING LANGUAGE</div>. 2nd ed.
            Englewood Cliffs, New Jersey: Prentice-Hall, Inc.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e681" xlink:actuate="onRequest" xlink:href="http://www.math.bas.bg/bantchev/place/snobol/gpp-2ed.pdf" xlink:show="new" xlink:type="simple">http://www.math.bas.bg/bantchev/place/snobol/gpp-2ed.pdf</div>
         </div>
         <div class="bibliomixed e682" xml:id="JQu" xreflabel="JQu">
            
            <div class="quote e683">JQuery API.</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e684" xlink:actuate="onRequest" xlink:href="http://api.jquery.com" xlink:show="new" xlink:type="simple">http://api.jquery.com</div>
         </div>
         <div class="bibliomixed e685" xml:id="LeH04" xreflabel="LeH04">Le Hors, Arnaud, et al. 07 April 2004.
            
            <div class="quote e686">Document Object Model (DOM) Level 3 Core Specification.</div>
            Version 1.0. W3C Recommendation 07 April 2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e687" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/</div>
         </div>
         <div class="bibliomixed e688" xml:id="Way01" xreflabel="Way01">Way, Arthur Sanders (tr). 1901.
            Apollonius Rhodius. 
            <div class="emphasis e689" role="ital">Argonautica</div>.
            London: J. M. Dent and Co.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e690" xlink:actuate="onRequest" xlink:href="https://archive.org/details/taleofargonauts00apol" xlink:show="new" xlink:type="simple">https://archive.org/details/taleofargonauts00apol</div>
            
         </div>
      </div>
   </div>
</div>