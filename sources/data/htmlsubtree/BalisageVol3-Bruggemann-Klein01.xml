<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#EngineeringDocumentApplications%C2%A0%E2%80%94%C2%A0FromUMLModels%0AtoXMLSchemasANCHOR" name="EngineeringDocumentApplications%C2%A0%E2%80%94%C2%A0FromUMLModels%0AtoXMLSchemasTOC">Engineering Document Applications&nbsp;—&nbsp;From UML Models
               to XML Schemas</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OrganizationofthepaperANCHOR" name="OrganizationofthepaperTOC">Organization of the paper</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ModelsinsoftwareengineeringANCHOR" name="ModelsinsoftwareengineeringTOC">Models in software engineering</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ModelingpersistentdataANCHOR" name="ModelingpersistentdataTOC">Modeling persistent data</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#FocusofthispaperANCHOR" name="FocusofthispaperTOC">Focus of this paper</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TransformingUMLmodelstoXMLSchemausingXMIANCHOR" name="TransformingUMLmodelstoXMLSchemausingXMITOC">Transforming UML models to XML Schema using XMI</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XMIschemasfromUMLclassdiagrams:TheXMImappingANCHOR" name="XMIschemasfromUMLclassdiagrams:TheXMImappingTOC">XMI schemas from UML class diagrams: The XMI mapping</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AdaptingtheXMImappingtothedocumentsettingANCHOR" name="AdaptingtheXMImappingtothedocumentsettingTOC">Adapting the XMI mapping to the document setting</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RealizingthelayershiftusingXSLTANCHOR" name="RealizingthelayershiftusingXSLTTOC">Realizing the layer shift using XSLT</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsandrelatedworkANCHOR" name="ConclusionsandrelatedworkTOC">Conclusions and related work</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#LiteratureANCHOR" name="LiteratureTOC">Literature</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 11 - 14, 2009</div>
         <div class="singletermTERMS">Anne</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2009</div>
         <div class="singletermTERMS">Brüggemann-Klein</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Comparing XML Schema Languages.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Dennis</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">instance placeholders</div>
         <div class="singletermTERMS">Introducing Design Patterns in XML Schemata</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">layer shift</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">metamodel</div>
         <div class="singletermTERMS">Meta Object Facility (MOF) Specification.</div>
         <div class="singletermTERMS">Meta Object Facility (MOF) Core Specification.</div>
         <div class="singletermTERMS">MOF 2.0/XMI Mapping.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">OMG Unified Modeling Language (OMG UML).</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">Pagano</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">Using UML To Define XML Document Types.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML und Datenmodellierung.</div>
         <div class="singletermTERMS">XML Schema Best Practices</div>
         <div class="singletermTERMS">XML Schema.</div>
         <div class="singletermTERMS">XML Linking Language (XLink).</div>
         <div class="singletermTERMS">XML Schema Part&nbsp;1: Structures Second Edition.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="EngineeringDocumentApplications%C2%A0%E2%80%94%C2%A0FromUMLModels%0AtoXMLSchemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">Engineering Document Applications&nbsp;—&nbsp;From UML Models
         to XML Schemas
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2009</div>
            <div class="confdates e5">August 11 - 14, 2009</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Modeling is a pivotal activity in the engineering of software systems; it is the key
               method
               to deal with complexity and change. Models support communication and drive software
               development processes. In the Engineering Publishing Technology Group, we aim to leverage
               modeling and other proven methods of software engineering for document engineering
               and
               electronic publishing. Particularly, in this paper, we align UML class diagrams, which
               model
               persistent data, with XML Schemas, which model the XML representation of persistent
               data as
               documents. Our method, which we call uml2xsd, transforms an XMI representation of
               a UML class
               diagram into an XML Schema that constrains XML instances of the UML model. It is patterned
               after transformations into XML Schema that XMI defines for models in its MOF language,
               which
               are closely related to UML class diagrams. With appropriate configuration, our method
               automates a transformation process that has been conceptually defined in our paper
               presented
               at Extreme Markup Languages&nbsp;2007; it incorporates our handling of relations that has
               been presented at Balisage&nbsp;2008.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Dennis</div>
               <div class="surname e11">Pagano</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Dennis Pagano received his diploma in computer science in August 2008 from Technische
                  Universität München. He currently works for the Chair for Applied Software Engineering
                  at Technische Universität München as a research assistant and doctoral candidate.
                  His research interests in the field of Software Engineering range from modeling, meta
                  modeling and semantics to knowledge management and representation as well as intelligent
                  learning. One of his special interests is the connection between Software Engineering
                  and XML based technologies, in particular MOF/UML and XML schema.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="orgname e15">Chair for Applied Software Engineering, Technische Universität
                  München
               </div>
            </div>
         </div>
         <div class="author e16">
            <div class="personname e17">
               <div class="firstname e18">Anne</div>
               <div class="surname e19">Brüggemann-Klein</div>
            </div>
            <div class="personblurb e20">
               <div class="para e21">Anne Brüggemann-Klein is a professor of computer science at Technische Universität
                  München. She received her PhD in Mathematics from Friedrich-Wilhelms-Universität Münster
                  and her Habilitation in Computer Science from Albert-Ludwigs-Universität Freiburg.
                  Her research interest is in document engineering. Earlier work, part of which is cited
                  in the W3C XML Recommendation, focuses on the formal language theory foundation of
                  document languages. Current research explores to what extent novel publishing applications
                  can be composed from appropriately configured XML software with a minimum of programming.
                  The goal is to discover principles, patterns and procedures that reduce complexity
                  and ensure sustainability when developing and maintaining Web applications.
               </div>
            </div>
            <div class="affiliation e22">
               <div class="orgname e23">Engineering Publishing Technology Group, Technische Universität
                  München
               </div>
            </div>
         </div>
         <div class="legalnotice e24">
            <div class="para e25">Copyright © 2009 by the authors.  Used with
               permission.
            </div>
         </div>
      </div><a name="OrganizationofthepaperANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e26" xml:id="sec.organizationOfPaper">
         <div class="title e27">Organization of the paper</div>
         <div class="para e28">In the Engineering Publishing Technology Group, we aim to leverage modeling and other
            proven
            methods of software engineering for document engineering and electronic publishing.
            Particularly, in this paper, we align UML class diagrams, which model persistent data,
            with
            XML Schemas, their implementational counterparts that constrain the XML implementation
            of
            persistent data as documents. We have felt the need to provide, for the Balisage audience,
            in
            the first “real” section of this paper (Models in software engineering)
            some background information on the role of and technology for modeling in software
            engineering. We continue the paper with a section (Modeling persistent data) on the
            place that
            modeling of persistent data and schema engineering for XML implementations of persistent
            data
            should have in software engineering processes. In the next section (Focus of this
            paper), we
            present a management summary of our contributions in this paper.
         </div>
         <div class="para e29">The next four sections expand on a number of aspects: In the first of these four
            (Transforming UML models to XML Schema using XMI), we talk about the ways in which
            we can make
            use of the XML Metadata Interchange XMI for our purposes. The second (XMI schemas
            from UML
            class diagrams: The XMI mapping) reports on the way that XMI maps UML class diagrams
            into XML
            Schemas. The third (Adapting the XMI mapping to the document setting) talks about
            adaptations
            and modifications to the XMI mapping that are required in a document setting. The
            forth and
            final section (Realizing the layer shift using XSLT) introduces our implementation;
            particularly, it explains what we call the layer shift, our method that leverages
            the widely
            implemented XMI export of UML modeling tools.
         </div>
         <div class="para e30">We finish the paper with a section that gives our conclusions and discusses some related
            work.
         </div>
      </div><a name="ModelsinsoftwareengineeringANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e31" xml:id="sec.modelsSWE">
         <div class="title e32">Models in software engineering</div>
         <div class="para e33">In this section, we represent the well-established perspective of the software engineering
            discipline to modeling. The state of the art is discussed in many excellent textbooks.
            We have
            been working with the one by Brügge and Dutoit &nbsp; [
            <div class="xref e34" linkend="BrüggeEtAlsOOSWE"></div>] .
         </div>
         <div class="para e35">Modeling is a pivotal activity in the engineering of software systems. Based on the
            dual
            principles of abstraction and implementation, and used in evolutionary phases that
            provide
            stepwise refinements, it is the key method to deal with complexity and change. Models
            support
            communication and drive software development processes. Modeling is common practice
            particularly in the earlier phases of software development. During requirement analysis,
            models support communication between software engineers and domain experts; during
            design,
            they document design intent to implementors; during implementation, they abstract
            from
            syntactic details of programming languages. The long-standing vision of software engineering,
            namely to drive the development process by models that are systematically transformed
            into
            lower-level models and software artifacts, has more recently found its expression
            in the
            approach of model-driven architecture. It is a widely acknowledged benefit of model-driven
            software development that it enforces uniform coding principles and strategies, leveraging
            best practices, and that it reduces error rates. The most striking advantages are:
         </div>
         <div class="orderedlist e36">
            <div class="listitem e37">
               <div class="para e38">Coherence between models and their implementations; this may go as far as to proven
                  correctness.
               </div>
            </div>
            <div class="listitem e39">
               <div class="para e40">Rational and documented transition between models on different levels of refinement,
                  which
                  enables accountability.
               </div>
            </div>
         </div>
         <div class="para e41">With the Unified Modeling Language UML, the Object Management Group OMG offers a graphical
            notation for defining models. The UML provides several types of diagrams for the modeling
            of
            software systems. Software engineering methods such as the Rational Unified Process
            RUP are
            based on the UML. They are supported by so-called CASE tools; that is, WYSIWYG editors
            to
            create and edit UML diagrams. The more powerful CASE tools allow for code generation
            (forward
            engineering), in pursuit of the vision of model-driven software development. Over
            the last
            decade, the UML has replaced previous modeling languages in software engineering practice.
         </div>
      </div><a name="ModelingpersistentdataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e42" xml:id="sec.dataModels">
         <div class="title e43">Modeling persistent data</div>
         <div class="para e44">Let us turn our attention now to a specific but important aspect of software systems,
            namely
            persistent data. Traditionally, if data volume and access requirements make custom
            formats
            unfeasible, data have been persisted in databases, with relational databases claiming
            the
            lion's share of the market. Increasingly, XML and XML database management systems
            come into
            play, the former as a format for persistent data and the latter for management and
            access of
            the XML data. In particular, XML establishes itself as the data format of choice if
            data are
            structured irregularly (semi-structured data) of if data are genuine textual
            documents&nbsp; [
            <div class="xref e45" linkend="AbiteboulEtAlDataOnTheWeb"></div>] .
         </div>
         <div class="para e46">We pose three requirements for the modeling of persistent data:</div>
         <div class="orderedlist e47">
            <div class="listitem e48">
               <div class="para e49">Modeling of persistent data must be integrated into system modeling.</div>
            </div>
            <div class="listitem e50">
               <div class="para e51">Modeling of persistent data must be independent of data implementation technology.</div>
            </div>
            <div class="listitem e52">
               <div class="para e53">Modeling of persistent data should be amenable to forward engineering.</div>
            </div>
         </div>
         <div class="para e54">How do these requirements mesh with the reality of XML modeling?</div>
         <div class="para e55">With schema languages such as DTD, XML Schema, Relax NG and
            Schematron&nbsp; [
            <div class="xref e56" linkend="W3CRecXMLSchemaStructures"></div>] 
            [
            <div class="xref e57" linkend="vdVlistSchemaTechnologies"></div>] 
            [
            <div class="xref e58" linkend="vdVlistXMLSchema"></div>] , the XML community has developed XML-specific modeling languages that
            are supported by XML-specific modeling
            methodologies&nbsp; [
            <div class="xref e59" linkend="MalerEtAlDTDModeling"></div>] 
            [
            <div class="xref e60" linkend="EcksteinEtAlXMLDatenmodellierung"></div>]  [
            <div class="xref e61" linkend="ConradEtAlXMLConceptualModeling"></div>] 
            [
            <div class="xref e62" linkend="KhanEtAlSchemaDesignPatterns"></div>] 
            [
            <div class="xref e63" linkend="LainevoolXMLPatterns"></div>] 
            [
            <div class="xref e64" linkend="StephensonBestPractices"></div>] . Tool support is available in the form of graphical
            editors for schema languages, requiring XML domain knowledge from software engineers
            who
            develop models.
         </div>
         <div class="para e65">Fundamental weaknesses of this approach are that the modeling depends on the schema
            technology, that the modeling language is very close to the implementation language
            and that
            the modeling of documents is separated from and not integrated into the general system
            modeling. These deficits persist even if XML modeling tools are integrated as modules
            into
            general UML tools, as it is the case, for example, with Altova UModel or HyperModel.
         </div>
         <div class="para e66">What options do we have if we want to truly integrate schema engineering into software
            engineering? In this, we will be guided by proven software engineering procedure.
            In practice,
            in software projects persistent data are modeled as UML class diagrams. Historically,
            there
            are two main options to implement the data. The first option implements data as objects
            in a
            specific programming language and then “marshals” the objects into a
            custom data format for persistent storage. The second option stores data in a database.
            In
            both cases, not only the data but also their models have an implementation counterpart,
            either
            in the form of class declarations in a programming language or in the form of a database
            schema definition. If we persist data as XML documents, the obvious implementational
            counterparts to data models are XML Schemas. Hence, the sound software engineering
            position is
            to regard XML as a target platform for persistent data and to transform data models
            into XML
            Schemas that constrain the XML-encoded data&nbsp; [
            <div class="xref e67" linkend="PaganoDA"></div>] . This puts not only
            XML but also XML Schema and other XML schema languages firmly on the side of implementation
            technologies.
         </div>
      </div><a name="FocusofthispaperANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e68" xml:id="sec.focus">
         <div class="title e69">Focus of this paper</div>
         <div class="para e70">In this paper we present a method, which we call uml2xsd, to translate conceptual
            models
            that, following current software engineering practice, are written as UML class diagrams
            into
            XML Schemas, thus aligning UML class diagrams, which model persistent data, with XML
            Schemas,
            which constrain the XML representation of persistent data as documents. The paper
            is the
            quintessence of research that the first author did for his diploma
            thesis&nbsp; [
            <div class="xref e71" linkend="PaganoDA"></div>]  under the supervision of the second author.
         </div>
         <div class="para e72">We base this work on XMI, a method that the Object Management Group (OMG) has defined
            to turn
            models that are written in its modeling language MOF into equivalent XML Schemas.
            Due to the
            architectural alignment of MOF and UML, MOF models can be considered as specific UML
            models
            that represent concepts in the form of class diagrams. Hence, we were able to pattern
            uml2xsd
            after the OMG translation of MOF models in XML Schema, extending it to concepts that
            are
            present in UML class diagrams but not in MOF models.
         </div>
         <div class="para e73">The OMG method is defined on a conceptual level. We are not aware of any tools that
            actually
            implements this method. Hence, XMI provides a conceptual guideline for uml2xsd, but
            there is
            no precedence for an implementation.
         </div>
         <div class="para e74">There is, however, another aspect of XMI that we can build on: The goal of XMI is
            to
            facilitate exchange of models as XML documents. The MOF language is used as a language
            to
            define metamodels (models whose instances are models), such as the UML metamodel.
            The XMI
            method that we have mentioned above, is used to translate such metamodels into specific
            XML
            Schema documents that are called XMI schemas. Applied to the specific metamodel of
            UML, this
            method yields a single XMI schema that constrains XML representations of UML models,
            which are
            called XMI documents.
         </div>
         <div class="para e75">Our method uml2xsd leverages the common capability of modern UML tools to export UML
            models
            as XMI documents. It transforms an XMI representation of a UML class diagram into
            an XML
            Schema that constrains XML instances of the UML model. It is patterned after transformations
            into XML Schema that XMI defines for models in its MOF language, which, due to the
            architectural alignment, are closely related to UML class diagrams. Our method achieves
            a
            shift from the XML instance layer that XMI supports for model interchange to the XML
            Schema
            layer that supports modeling itself. Being based on XMI as a standardized interchange
            format
            for UML models, uml2xsd is independent of specific UML modeling tools or software
            development
            methods. Technically, uml2xsd is an XSLT program that operates on XML representations
            of UML
            class diagrams, the XMI documents, and turns them into XML Schemas.
         </div>
         <div class="para e76">The core idea behind uml2xsd is to generate from UML class diagrams not XML instances,
            as is
            the XMI way, but XML Schema documents, thus aligning conceptual instances of UML models
            with
            XML instances of XML Schema documents. We make use of the XMI support of UML modeling
            tools in
            that we first export UML class diagrams as XMI documents and then translate the results
            with
            XSLT into XML Schema documents. The translation rules adapt XMI translation rules
            from a
            higher level of the so-called MOF metamodel hierarchy, which is enabled by an alignment
            between the metamodel hierarchy and UML class diagrams. This “layer shift”, which
            we are going
            to explain in more detail further on, validates the uml2xsd approach.
         </div>
         <div class="para e77">In principle, the uml2xsd method should work with XMI data that were exported from
            any UML
            tool. In practice, however, XMI allows for a wide spectrum of variants to represent
            any
            artifact in a UML diagram, so we hesitate to claim too much. We have, however, successfully
            tested the implementation with a number of UML tools, particularly with Enterprise
            Architect
            and Altova UModel.
         </div>
         <div class="para e78">At Extreme Markup Languages 2007, the Engineering Publishing Technology Group has
            presented
            principles, patterns and procedures of translating a conceptual document model in
            form of a
            simple UML class diagram into an XML Schema document&nbsp; [
            <div class="xref e79" linkend="EPTatEML2007"></div>] . In a
            contribution&nbsp; [
            <div class="xref e80" linkend="EPTatBalisage2008"></div>]  at Balisage 2008, we have extended our
            investigation to more complex document models that exhibit relationships between classes,
            coding relationships on the XML side of documents with XLink and embedding processing
            support
            for XLink into XQuery. With appropriate configuration of uml2xsd, we are now able
            to automate
            these translations. We have applied uml2xsd to automatically generate XML Schema documents
            from conceptual models of two XML applications, XBlog and XTunes.
         </div>
         <div class="para e81">We have further evaluated uml2xsd by applying it to the UML 
            <div class="emphasis e82" role="ital">metamodel</div> (which is an
            instance of MOF and, hence, an UML class diagram); the result is an XML Schema for
            UML that is
            equivalent to the XMI encoding rules of UML class diagrams.
         </div>
      </div><a name="TransformingUMLmodelstoXMLSchemausingXMIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e83" xml:id="sec.XMITransform">
         <div class="title e84">Transforming UML models to XML Schema using XMI</div>
         <div class="para e85">As we have briefly sketched out above, there already exists a standard for the generation
            of
            XML Schemas out of models namely XMI, the XML Metadata Interchange specification.
            With XMI,
            the OMG has standardized a data format that aims at the interchange of models. The
            goal is to
            support interoperability of UML modeling tools. There is urgent need for such support
            since,
            particularly in globally distributed software projects, a number of modeling tools
            are
            simultaneously in use. XMI not only supports UML models, but also
            MOF&nbsp; [
            <div class="xref e86" linkend="OMGMOFCore"></div>]  compliant models in general. It defines standards for
            the creation of so called XMI schemas, which represent MOF compliant metamodels such
            as the
            UML metamodel, and XMI documents, which represent the actual models such as UML models;
            the
            latter are instances of a metamodel's representation as an XMI schema. Thus XMI enables
            the
            validation of models in their XML representations against an arbitrary MOF compliant
            metamodel.
         </div>
         <div class="para e87">Since UML is designed using the MOF and because the UML metamodel itself is an instance
            of
            the MOF model&nbsp; [
            <div class="xref e88" linkend="OMGMOF"></div>] , XMI can be (and is in most cases) used to exchange
            and validate UML models via XMI documents. As the names suggest, XMI documents are
            specific
            XML documents and XMI schemas are specific XML Schema documents. So when using XMI,
            UML models
            are actually transformed into XML documents, not into XML Schemas! Why that, didn't
            we state
            above that from the perspective of object persistence, we would expect conceptual
            UML models
            to be transformed into XML Schemas? That's still valid, but XMI was designed to validate
            and
            exchange models, and for that purpose it is best to transform models into XML documents;
            that
            is, document instances that can be validated against an XML Schema using common XML
            software.
         </div>
         <div class="para e89">Since XMI defines rules for generating XMI schemas (which are special XML Schema documents
            as
            we have seen) from MOF compliant metamodels, the question arises whether we can also
            use these
            rules to generate XMI schemas for conceptual UML models. The answer is yes. Because
            of the
            architectural alignment of UML and MOF, conceptual UML models (models represented
            by UML class
            diagrams), are defined using the same concepts as MOF compliant meta
            models.&nbsp; [
            <div class="xref e90" linkend="OMGMOFCore"></div>]  Thus, we are able to interpret UML class diagrams
            as MOF compliant metamodels from an XMI point of view, which allows us to use the
            rules
            defined by the XMI specification to generate XMI schemas from conceptual models. We
            call this
            process, which effectively creates an XMI schema from a conceptual UML model encoded
            in an XMI
            document, 
            <div class="emphasis e91" role="ital">layer shift</div>. The attached figure illustrates the model-instance
            relationships, the mappings and the levels on which the models and their instances
            reside.
         </div>
         <div class="mediaobject e92">
            <div class="imageobject e93">
               <div class="metaBox e94"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e165').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e165" class="metaSource" style="display:none;">                
                     &lt;imagedata<span class="metaAttribute">class='e94'
                        </span><span class="metaAttribute">fileref='../../../vol3/graphics/Bruggemann-Klein01/Bruggemann-Klein01-001.jpg'
                        </span><span class="metaAttribute">format='jpg'
                        </span>
                     &gt;
                     
                  </div>
               </div>
            </div>
         </div>
      </div><a name="XMIschemasfromUMLclassdiagrams:TheXMImappingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e95" xml:id="sec.XMIMapping">
         <div class="title e96">XMI schemas from UML class diagrams: The XMI mapping</div>
         <div class="para e97">In our research&nbsp; [
            <div class="xref e98" linkend="PaganoDA"></div>]  we have surveyed the XMI specification
            regarding its possibilities to map conceptual models to certain XML Schema documents,
            namely
            the XMI schemas. Our focus was to determine whether XMI allows a sound transformation
            of
            models for XML applications into XML Schema documents that represent their document
            classes.
            This question arises from the fact that XMI was designed with a completely different
            goal,
            namely the standardization of the interchange process of MOF compliant models.
         </div>
         <div class="para e99">First of all, although XMI targets MOF compliant models in general, the transformation
            of
            conceptual models in the form of UML class diagrams is possible due to architectural
            alignment
            in the form of the common infrastructure of UML and
            MOF&nbsp; [
            <div class="xref e100" linkend="OMGUMLInfrastructure"></div>] . The OMG defines how to generate
            MOF-compliant models&nbsp; [
            <div class="xref e101" linkend="OMGXMIMapping"></div>]  as a set of predefined rules that can
            also be configured for special purposes. This configuration comprises the use of a
            specific
            set of so-called tagged values in the MOF models that are to be transformed. These
            tagged
            values are also defined in the XMI specification. In the following, we provide a short
            overview of the transformation rules specified in the XMI specification.
         </div>
         <div class="para e102">The general structure of an XMI schema is how we would expect an XML Schema document
            to look
            like, including namespace declarations and imports of XMI specific XML Schema types.
            By
            default, XMI software generates only one XMI schema for a complete UML model, without
            defining
            a target namespace therein. But the annotation of UML packages with an XML namespace
            results
            in the generation of one XMI schema per UML package, each using the specified XML
            namespace as
            target namespace. This allows for the transformation of equally named UML elements
            within
            different packages, what would otherwise be impossible.
         </div>
         <div class="para e103">For UML packages XMI specifies the use of elements with locally defined complex types.
            Each
            complex type is then made up of a choice of the UML elements contained in the according
            package, which are referenced in the choice. Similarly, UML classes are transformed
            into
            element declarations and complex types, but in contrast to packages, the elements'
            types are
            declared globally. The elements and their types are put into the target namespace
            of the
            containing package. The content model of both packages and classes is very generous
            since it
            is realized as an XML Schema choice construct with open bounds, and thus hiding any
            multiplicity by default. But this representation can be changed using tagged values
            that
            enforce the use of the multiplicities as specified in the model.
         </div>
         <div class="para e104">UML attributes are transformed into element declarations, which are directly put into
            a
            choice in the definition of the complex type that represents the containing class.
            Additionally, an attribute declaration is appended for UML attributes with simple
            datatypes
            and a multiplicity of at most one. However, the type of declaration can be influenced
            using
            tagged values, for example to persist the order of the elements using sequences instead
            of
            choices. Every complex type by default references an additional attribute predefined
            in the
            XMI specific XML Schema types that is used as an identifier. However, by annotating
            a UML
            attribute with a certain tagged value, this attribute can be declared as the identifier
            attribute instead.
         </div>
         <div class="para e105">UML associations are defined using association ends that reside in the classes that
            participate in the association. XMI generates both an element declaration and an attribute
            declaration for each association end contained in a class. As the association end's
            type, XMI
            uses the predefined type “Any” that allows arbitrary content for the element. This
            allows the
            instantiation of classes in the content of other classes and therefore enables the
            construction of redundant but valid XML documents. We consider this redundancy a weak
            point of
            the XMI specification.
         </div>
         <div class="para e106">For inheritance, a specific type of association, XMI uses
            “copy-down-inheritance”&nbsp; [
            <div class="xref e107" linkend="OMGXMIMapping"></div>]  by default: The subclass is
            transformed into a complex type under the rules, but first the properties of all base
            classes
            are copied. Then these are extended or replaced by the properties defined in the subclass
            itself. The copy-down-inheritance is only a workaround for the realization of multiple
            inheritance that XML Schema does not support natively. In the sense of the term it
            is not
            really an inheritance mechanism, as the relation between base class and subclass gets
            lost
            during the transformation. If a UML model only uses simple inheritance, the use of
            the native
            XML Schema inheritance mechanism can be enforced by using the proper tagged values.
            In
            contrast to the way associations are represented, the use of copy-down-inheritance
            can't be
            seen as a drawback of XMI, because it is XML Schema that lacks the concept of multiple
            inheritance.
         </div>
      </div><a name="AdaptingtheXMImappingtothedocumentsettingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e108" xml:id="sec.adaptXMIMapping">
         <div class="title e109">Adapting the XMI mapping to the document setting</div>
         <div class="para e110">Clearly the XMI specification was designed with the goal to facilitate the interchange
            and
            validation of models, not to represent conceptual models in the form of XML Schema
            documents.
            But most of the rules that transform UML model concepts into XML Schema concepts are
            sound
            from the perspective of a conceptual model by default or there are possibilities to
            influence
            the rules in a way that they become sound.
         </div>
         <div class="para e111">However, an important concept that is not considered by the XMI specification is abstraction,
            although abstract classes exist in the MOF specification. This may be a result of
            the aim of
            the XMI specification, since it should facilitate the interchange of models. This
            means XMI
            schemas shall facilitate the validation of models in the form of XMI documents, a
            process
            where abstraction plays an inferior role. Considering XML applications that need general
            schema concepts, abstraction would be desirable.
         </div>
         <div class="para e112">Another negative aspect in this context is the declaration of elements for classes,
            the use
            of 
            <div class="emphasis e113" role="ital">instance placeholders</div> as we call them. XMI creates an instance placeholder for each
            class without exception. This is always possible, but not always desirable in the
            context of
            XML applications, because it allows for a variety of valid XML documents implementing
            the
            schema.
         </div>
         <div class="para e114">Furthermore, the third drawback is the realization of associations in XMI, which allows
            for
            redundancy in instance documents. XMI however targets the validation of models regarding
            the
            definition of the according metamodel represented by an XMI schema. Hence, XMI does
            not
            emphasize well-structured and easy to use valid documents. Moreover, there are certain
            tagged
            values that make it possible to prevent element declarations for association ends
            and allow
            for the use of an URI-based linking construct that eliminates redundancy. Unfortunately
            the
            XMI specification doesn't make use of XLink  [
            <div class="xref e115" linkend="W3CRecXLink"></div>]  at this point, which
            could be a helpful concept. This is because the XMI specification was created before
            XLink
            became a W3C standard.
         </div>
         <div class="para e116">Since the schema generation process can mainly be influenced using tagged values,
            we have to
            ask for a general set of tagged values to tailor the schema generation process for
            our needs.
            Having to annotate each and every model element with cryptic tags doesn't really simplify
            a
            software engineer's life. But leaving XMI aside, each transformation process has to
            be
            configurable on UML construct level to transfer design decisions into the schema.
         </div>
         <div class="para e117">Carlson&nbsp; [
            <div class="xref e118" linkend="CarlsonXMLAppsUML"></div>]  proposes the use of a special UML profile for
            XML Schema modeling purposes that defines according stereotypes and tagged values.
            For example
            he introduces the stereotype “XSDcomplexType” which applied to a class specifies that
            this
            class should be realized as a complex XML Schema type. But he also defines stereotypes
            and
            tagged values for other model elements like attributes or association ends (e.g. “XSDelement”
            or “XSDattribute”) and even stereotypes that target model groups whose function is
            to group
            other model elements (e.g. “XSDsequence”). This approach surely makes sense, but the
            terminology Carlson proposes for the profile belongs to the domain of XML Schema,
            not to the
            domain of modeling in general. Hence a software engineer has to have domain knowledge
            of XML
            Schema to ensure that the generated schema has the desired properties, and thus in
            fact has to
            model the schema, not the application. Here we consider it more useful and more general
            to
            hide such tags and preset their values sensibly from the perspective of XML applications
            or
            modeling in general. This way important patterns, principles and procedures could
            be ensured
            and the profile could be made more UML or model specific than XML Schema specific.
         </div>
         <div class="para e119">The major benefits of using XMI schemas are obviously the possibility of reusing an
            existing
            specification and the fact that most CASE tools currently support exporting their
            models as
            XMI documents. The latter fact is important when considering a way to make practical
            use of
            the XMI rules to create XML Schema documents from UML models in software engineering
            processes.
         </div>
      </div><a name="RealizingthelayershiftusingXSLTANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e120" xml:id="sec.layerShift">
         <div class="title e121">Realizing the layer shift using XSLT</div>
         <div class="para e122">XMI compatible UML CASE tools provide the possibility to export models in an XML based,
            standardized format, namely an XMI document. This is a welcome fact for the realization
            of the
            layer shift, which shall create an XMI schema from a conceptual UML model encoded
            in an XMI
            document. It allows for the insertion of an additional transform layer after the creation
            of
            the model during the development process. This means that we get models in a well
            defined
            format, which we can assume as input format for a transformation. It comes in handy
            that XMI
            documents are in fact XML documents, so we can use an XSLT stylesheet to transform
            a UML model
            encoded in an XMI document into XML Schema.
         </div>
         <div class="para e123">Naturally the question arises, whether we cannot simply influence the schema generation
            process of a UML tool to directly transform a UML model into an XMI schema. This question
            is
            inappropriate, though, because UML modeling tools with XMI functionality exclusively
            create
            XMI documents, not XMI schemas. The generation of XMI schemas is thus not part of
            the
            functionality of the mentioned tools, and hence has it to be done separately after
            the export
            of a model.
         </div>
         <div class="para e124">We realize the layer shift with an XSLT 2.0 stylesheet that targets XMI version 2.1
            and
            above. Hereby we focus mainly on the XMI specification, which describes the transformation
            of
            MOF models into XMI schema documents, but we interpret UML models in particular. As
            we have
            found out, tagged values (amongst others) are realized in different ways by different
            tool
            manufacturers. But since they are most important for the tailoring of the schema generation
            process, the XSLT stylesheet has to be able to interpret them. As a matter of fact,
            a general
            interpretation is out of scope for our project and is basically difficult to achieve
            because
            of the high degree of flexibility within XMI. However, we support a number of some
            of the most
            popular tools and integrate an extension point in the stylesheet that makes it easy
            to provide
            additional interpretation modules for further tools. With our implementation we provide
            a
            conceptually sound open source realization of the layer shift that can be used in
            other
            processes.
         </div>
         <div class="para e125">To make it easy for reuse, we have designed our stylesheet to align with the translation
            rules defined by the OMG  [
            <div class="xref e126" linkend="OMGXMIMapping"></div>]  by creating several templates that
            correspond to the several subrules and that have the same names as the according rules
            in the
            official mapping document. Besides interpreting some partially unclear points of the
            mapping
            specification like the handling of package level attributes, we focus on realizing
            the mapping
            as consistent with the specification as possible. Furthermore we implement features
            that allow
            for more flexibility than the specification or even provide additional functionality.
            Examples
            are the possibility to use substitution groups for derived model elements, the ability
            to
            generate model based name prefixes or the use of XLink for the realization of associations.
            To
            enable the use of certain configurations of tagged values, we also provided parameters
            that
            allow to set a default value for each tag.
         </div>
         <div class="para e127">Realizing the layer shift according to the XMI specification naturally leaves its
            mark in the
            resulting schemas: There are many additional elements and attributes that solely support
            the
            interchange process or provide extension points. These XMI-specific schema content
            can be
            removed for schemas that are generated in the case of document engineering.
         </div>
      </div><a name="ConclusionsandrelatedworkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e128" xml:id="sec.conclusions">
         <div class="title e129">Conclusions and related work</div>
         <div class="para e130">In this paper, we have presented a method uml2xsd that transforms conceptual data
            models from
            their UML representations into XML Schema documents. From a software engineering point
            of
            view, our method provides an implementational counterpart to data models that constrains
            the
            XML implementations of model instances (data). Our method provides a missing piece
            for the
            puzzle of data modeling, extending good practice from object-oriented programming
            languages
            and databases to document engineering.
         </div>
         <div class="para e131">Clearly, our method provides a missing link in schema engineering: Data modeling can
            be
            integrated into system modeling, independently of data implementation technology.
         </div>
         <div class="para e132">The implementation of xml2xsd builds on XMI, a standard for model interchange that
            is widely
            supported by UML modeling tools. It follows mapping rules from data models to XMI
            schemas that
            the OMG has conceptually defined, providing the first publicly available implementation
            of
            these rules. Our implementation is open source, configurable and extensible. Hence,
            uml2xsd
            puts forward engineering into the toolbox of schema engineers.
         </div>
         <div class="para e133">Speaking of schema engineers, even if some project confines itself to pure schema
            development, without any ties to software development, our method provides two strong
            benefits: First, we enable modeling to be carried out independently of schema technologies.
            Second, in the vein of forward engineering, schemas can be generated automatically
            from
            models.
         </div>
         <div class="para e134">We consider the presentation&nbsp; [
            <div class="xref e135" linkend="KimberEtAlUML2DTD"></div>]  of Kimber and
            Heintz at Extreme Markup Languages&nbsp;2000 as a direct predecessor of our work. We fully
            subscribe to their position on the relationships between software engineering, document
            engineering and XML technology. In our work, we have taken two further steps: First,
            with XMI
            we base our mapping from model to schema on an OMG standard, also facilitating configuration
            and extension of the XMI mapping. Second, we offer an implementation that works within
            any
            (reasonable) UML environment, requiring, with XSLT, only widely available XML technology.
         </div>
         <div class="para e136">The work that we have presented here is part of a larger endeavor in which we, the
            Engineering Publishing Technology Group, explore to what extent novel publishing applications
            can be composed from appropriately configured XML software with a minimum of programming.
            Our
            goal is to discover principles, patterns and procedures that reduce complexity and
            ensure
            sustainability when developing and maintaining Web applications. Modeling of persistent
            data
            and forward engineering of data models into XML schemas are one building block of
            a metamodel
            for publishing applications that Thomas Schöpf, another member of our group, develops
            in his
            PhD thesis “Eine Software-Architektur für webbasierte
            Publikationssysteme”.
         </div>
      </div><a name="LiteratureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e137">
         <div class="title e138">Literature</div>
         <div class="bibliomixed e139" xml:id="AbiteboulEtAlDataOnTheWeb" xreflabel="AbiteboulEtAlDataOnTheWeb ">S. Abiteboul, D. Suciu: 
            <div class="emphasis e140" role="ital">Data on the Web: From Relations to Semistructured Data and
               XML.
            </div> Morgan Kaufmann 1999.
         </div>
         <div class="bibliomixed e141" xml:id="BrüggeEtAlsOOSWE" xreflabel="BrüggeEtAlsOOSWE ">B. Brügge and A.H. Dutoit. 
            <div class="emphasis e142" role="ital">Object-Oriented Software Engineering: Using UML, Patterns
               and Java.
            </div> Second Edition, Prentice Hall, 2004. 
         </div>
         <div class="bibliomixed e143" xml:id="EPTatEML2007" xreflabel="EPTatEML2007">A. Brüggemann-Klein, Th. Schöpf, K. Toni: 
            <div class="emphasis e144" role="ital">Principles, Patterns and Procedures of XML
               Schema Design — Reporting from the XBlog Project.
            </div> Extreme Markup Languages 2007.
            Available from http://conferences.idealliance.org/extreme/.
         </div>
         <div class="bibliomixed e145" xml:id="EPTatBalisage2008" xreflabel="EPTatBalisage2008">A. Brüggemann-Klein, L. Singer: 
            <div class="emphasis e146" role="ital">Hypertext Links and Relationships in XML Databases.</div>
            Presented at Balisage: The Markup Conference 2008, Montréal, Canada, 2008,
            http://www.balisage.net/. Available from
            http://hyquery.ls-softworks.de/HyperDataSystemsBalisage2008.pdf. doi: 
            <div class="biblioid doi e147">10.4242/BalisageVol1.Bruggemann-Klein01</div>.
         </div>
         <div class="bibliomixed e148" xml:id="CarlsonXMLAppsUML" xreflabel="CarlsonXMLAppsUML">D. Carlson: 
            <div class="emphasis e149" role="ital">Modeling XML Applications with UML: Practical E-Business Applications.</div>
            Redwood City, Addison Wesley Longman Publishing, 2001.
         </div>
         <div class="bibliomixed e150" xml:id="ConradEtAlXMLConceptualModeling" xreflabel="ConradEtAlXMLConceptualModeling">R. Conrad, D. Scheffner, J.-C. Freytag. XML Conceptual Modeling Using UML. In A.H.F.
            Laender, S.W. Liddle, V.C. Storey (eds), 
            <div class="emphasis e151" role="ital">International Conference on Conceptual Modeling
               (ER 2000)
            </div>. LNCS 1920, pp. 558—571. Springer-Verlag 2000.
         </div>
         <div class="bibliomixed e152" xml:id="EcksteinEtAlXMLDatenmodellierung" xreflabel="EcksteinEtAlXMLDatenmodellierung">R. Eckstein, S. Eckstein. 
            <div class="emphasis e153" role="ital">XML und Datenmodellierung.</div> DPunkt-Verlag 2004.
         </div>
         <div class="bibliomixed e154" xml:id="KhanEtAlSchemaDesignPatterns" xreflabel="KhanEtAlSchemaDesignPatterns ">A. Khan, M. Sum. 
            <div class="emphasis e155" role="ital">Introducing Design Patterns in XML Schemata</div>. Sun Developer Network
            2006.
         </div>
         <div class="bibliomixed e156" xml:id="KimberEtAlUML2DTD" xreflabel="KimberEtAlUML2DTD">W.E. Kimber, J.D. Heintz: 
            <div class="emphasis e157" role="ital">Using UML To Define XML Document Types.</div> Presentation at
            Extreme Markup Languages 2000. Available from
            http://www.gca.org/attend/2000_conferences/Extreme_2000/.
         </div>
         <div class="bibliomixed e158" xml:id="LainevoolXMLPatterns" xreflabel="LainevoolXMLPatterns">T. Lainevool. 
            <div class="emphasis e159" role="ital">Develop Effective XML Documents Using Structural Design Patterns.</div>
            http://www.LainevoolXMLPatterns.com/.
         </div>
         <div class="bibliomixed e160" xml:id="MalerEtAlDTDModeling" xreflabel="MalerEtAlDTDModeling">E. Maler, J. El Andaloussi. 
            <div class="emphasis e161" role="ital">Developing SGML DTDs: From Text to Model to Markup.</div>
            Prentice Hall 1995.
         </div>
         <div class="bibliomixed e162" xml:id="OMGMOF" xreflabel="OMGMOF">Object Management Group: 
            <div class="emphasis e163" role="ital">Meta Object Facility (MOF) Specification.</div> Version 1.4.1,
            July 2005. http://www.omg.org/docs/formal/05-05-05.pdf 
         </div>
         <div class="bibliomixed e164" xml:id="OMGMOFCore" xreflabel="OMGMOFCore">Object Management Group: 
            <div class="emphasis e165" role="ital">Meta Object Facility (MOF) Core Specification.</div> Version 2.0,
            January 2006. http://www.omg.org/docs/formal/06-01-01.pdf 
         </div>
         <div class="bibliomixed e166" xml:id="OMGXMIMapping" xreflabel="OMGXMIMapping">Object Management Group: 
            <div class="emphasis e167" role="ital">MOF 2.0/XMI Mapping.</div> Version 2.1.1. December 2007.
            http://www.omg.org/docs/formal/07-12-01.pdf
         </div>
         <div class="bibliomixed e168" xml:id="OMGUMLInfrastructure" xreflabel="OMGUMLInfrastructure">Object Management Group: 
            <div class="emphasis e169" role="ital">OMG Unified Modeling Language (OMG UML).</div> Infrastructure,
            V2.1.2. November 2007. http://www.omg.org/docs/ formal/07-11-04.pdf
         </div>
         <div class="bibliomixed e170" xml:id="PaganoDA" xreflabel="PaganoDA">D. Pagano. 
            <div class="emphasis e171" role="ital">Modeling and Defining XML Applications with UML and XML Schema.</div> Diploma
            Thesis, Technische Universität München, 2008.
         </div>
         <div class="bibliomixed e172" xml:id="StephensonBestPractices" xreflabel="StephensonBestPractices">D. Stephenson. 
            <div class="emphasis e173" role="ital">XML Schema Best Practices</div>. HP Dev Resource 2004.
            http://devresource.hp.com/drc/resources/vdVlistXMLSchemaBestPractices.jsp
         </div>
         <div class="bibliomixed e174" xml:id="vdVlistSchemaTechnologies" xreflabel="vdVlistSchemaTechnologies">E. van der Vlist. 
            <div class="emphasis e175" role="ital">Comparing XML Schema Languages.</div> XML.com 2001.
            http://www.xml.com/lpt/a/884.
         </div>
         <div class="bibliomixed e176" xml:id="vdVlistXMLSchema" xreflabel="vdVlistXMLSchema">E. van der Vlist. 
            <div class="emphasis e177" role="ital">XML Schema.</div> O'Reilly 2002.
         </div>
         <div class="bibliomixed e178" xml:id="W3CRecXLink" xreflabel="W3CRecXLink">World Wide Web Consortium: 
            <div class="emphasis e179" role="ital">XML Linking Language (XLink).</div> W3C Recommendation
            27&nbsp;June&nbsp;2001. http://www.w3.org/TR/xlink/
         </div>
         <div class="bibliomixed e180" xml:id="W3CRecXMLSchemaStructures" xreflabel="W3CRecXMLSchemaStructures">World Wide Web Consortium: 
            <div class="emphasis e181" role="ital">XML Schema Part&nbsp;1: Structures Second Edition.</div>
            W3C Recommendation 28&nbsp;October&nbsp;2004.
            http://www.w3.org/TR/2004/REC-vdVlistXMLSchema-1-20041028/
         </div>
      </div>
   </div>
</div>