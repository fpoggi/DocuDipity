<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#AHybridParallelProcessingforXMLParsingandSchemaValidationANCHOR" name="AHybridParallelProcessingforXMLParsingandSchemaValidationTOC">A Hybrid Parallel Processing for XML Parsing and Schema Validation</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ThechallengeofXMLParsingandSchemaValidationANCHOR" name="ThechallengeofXMLParsingandSchemaValidationTOC">The challenge of XML Parsing and Schema Validation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ParallelXMLProcessingandMulticoresANCHOR" name="ParallelXMLProcessingandMulticoresTOC">Parallel XML Processing and Multi-cores</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#HybridParallelXMLProcessingModelANCHOR" name="HybridParallelXMLProcessingModelTOC">Hybrid Parallel XML Processing Model</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PipelineExecutioninXMLProcessingANCHOR" name="PipelineExecutioninXMLProcessingTOC">Pipeline Execution in XML Processing</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ApplyDataparallelModelANCHOR" name="ApplyDataparallelModelTOC">Apply Data-parallel Model</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ParallelXMLParsingANCHOR" name="ParallelXMLParsingTOC">Parallel XML Parsing</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ChunkPartitionANCHOR" name="ChunkPartitionTOC">Chunk Partition</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SpeculativeParsingANCHOR" name="SpeculativeParsingTOC">Speculative Parsing</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PostProcessingANCHOR" name="PostProcessingTOC">Post-Processing</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ContextinformationANCHOR" name="ContextinformationTOC">Context information</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#WellformednessCheckingANCHOR" name="WellformednessCheckingTOC">Well-formedness Checking</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ResolvingUnresolvedPrefixANCHOR" name="ResolvingUnresolvedPrefixTOC">Resolving Unresolved Prefix</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#LinkingPartialSTREEsANCHOR" name="LinkingPartialSTREEsTOC">Linking Partial S-TREEs</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ParallelSchemaValidationANCHOR" name="ParallelSchemaValidationTOC">Parallel Schema Validation</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PartialValidationANCHOR" name="PartialValidationTOC">Partial Validation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ResidualValidationANCHOR" name="ResidualValidationTOC">Residual Validation</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PerformanceEvaluationANCHOR" name="PerformanceEvaluationTOC">Performance Evaluation</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PerformanceBreakdownANCHOR" name="PerformanceBreakdownTOC">Performance Breakdown</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StandaloneParallelParserPerformanceANCHOR" name="StandaloneParallelParserPerformanceTOC">Standalone Parallel Parser Performance</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ParallelvalidatedparserperformanceANCHOR" name="ParallelvalidatedparserperformanceTOC">Parallel validated parser performance</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#LEGALINFORMATIONANCHOR" name="LEGALINFORMATIONTOC">LEGAL INFORMATION</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">jian.hui.li@intel.com</div>
         <div class="singletermTERMS">Jianhui</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Li</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">qi.zhang@intel.com</div>
         <div class="singletermTERMS">Qi</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">yu.y.wu@intel.com</div>
         <div class="singletermTERMS">Yu</div>
         <div class="singletermTERMS">Yu</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
         <div class="singletermTERMS">zhiqiang.yu@intel.com</div>
         <div class="singletermTERMS">Zhiqiang</div>
         <div class="singletermTERMS">Zhang</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="AHybridParallelProcessingforXMLParsingandSchemaValidationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973">
      <div class="title e1">A Hybrid Parallel Processing for XML Parsing and Schema Validation</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2008</div>
            <div class="confdates e5">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">XML is playing crucial roles in web services, databases, and document representing
               and processing. However, the processing of XML document has been regarded as the main
               performance bottleneck especially for the processing of very large XML data. On the
               other hand, multi-core processing gains increasingly popularity both on the desktop
               computers and server computing machines. To take full advantage of multi-cores, we
               present a novel hybrid parallel XML processing model, which combines data-parallel
               and pipeline processing. It first partitions the XML by chunks to perform data parallel
               processing for both XML parsing and schema validation, then organize and execute them
               as a two stage pipeline to exploit more parallelism. The hybrid parallel XML processing
               model has shown great overall performance advantage on multi-core platform as indicated
               by the experiment performance results.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Yu</div>
               <div class="surname e11">Wu</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13"></div>
            </div>
            <div class="affiliation e14">
               <div class="orgname e15">Intel Corporation</div>
            </div>
            <div class="email e16">yu.y.wu@intel.com</div>
         </div>
         <div class="author e17">
            <div class="personname e18">
               <div class="firstname e19">Qi</div>
               <div class="surname e20">Zhang</div>
            </div>
            <div class="personblurb e21">
               <div class="para e22"></div>
            </div>
            <div class="affiliation e23">
               <div class="orgname e24">Intel Corporation</div>
            </div>
            <div class="email e25">qi.zhang@intel.com</div>
         </div>
         <div class="author e26">
            <div class="personname e27">
               <div class="firstname e28">Zhiqiang</div>
               <div class="surname e29">Yu</div>
            </div>
            <div class="personblurb e30">
               <div class="para e31"></div>
            </div>
            <div class="affiliation e32">
               <div class="orgname e33">Intel Corporation</div>
            </div>
            <div class="email e34">zhiqiang.yu@intel.com</div>
         </div>
         <div class="author e35">
            <div class="personname e36">
               <div class="firstname e37">Jianhui</div>
               <div class="surname e38">Li</div>
            </div>
            <div class="personblurb e39">
               <div class="para e40"></div>
            </div>
            <div class="affiliation e41">
               <div class="orgname e42">Intel Corporation</div>
            </div>
            <div class="email e43">jian.hui.li@intel.com</div>
         </div>
         <div class="legalnotice e44">
            <div class="para e45">Copyright © 2008 Intel Corporation. Used by permission.</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e46">
         <div class="title e47">Introduction</div><a name="ThechallengeofXMLParsingandSchemaValidationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e48">
            <div class="title e49">The challenge of XML Parsing and Schema Validation</div>
            <div class="para e50">Extensible Markup Language (XML) has been playing crucial roles in web services, databases
               and document processing fields. However, it has been commonly perceived that the verbosity
               of XML incurs heavy processing overhead. Several academic and industry efforts have
               been made to accelerate the XML processing, trying to mitigate the performance pain
               point. [6-10]
            </div>
            <div class="para e51">XML parsing and schema validation are two major XML processing loads in most XML based
               applications. XML parsing provides the infoset and XML Schema validation determines
               type information for every node of the document. Beside use on the application perimeter
               to validate input XML messages [1][2], the schema-aware processing gains are significance
               inside application, using XML processing languages like XPath2.0/XSLT2.0, accessing
               XML database, or mapping to Java objects.
            </div>
            <div class="para e52">The schema validation adds extra significant overhead into XML parsing [5]. For example,
               the eBay Web services specification has a few thousand elements and hundreds of complex
               type definitions. Communicating with eBay via the SOAP protocol requires processing
               of large XML documents [2]. Benchmark analysis [3][4] shows that most implementations
               of Web services do not scale well as the size of XML document increases.
            </div>
         </div><a name="ParallelXMLProcessingandMulticoresANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e53">
            <div class="title e54">Parallel XML Processing and Multi-cores</div>
            <div class="para e55">On the hardware front, a recent trend in computer architecture is the rapid adoption
               of chip multiprocessors (CMPs), commonly referred as multi-core processors. Intel,
               as an example, has shipped several of multi-core processors from 2 cores to 8 cores
               and is even leading the trend from multi-core to many-core with their future-oriented
               80-core chip research project[12]. It's no doubt that tomorrow's computers will have
               more cores rather than exponentially faster clock speeds. As more and more web services
               based applications are deploying on multi-core processors, the heavy XML processing
               in web services will need to take full advantage of multi-core processing.
            </div>
            <div class="para e56">In this paper, we present a hybrid parallel processing model for XML parsing and schema
               validation, which combines data-parallel and pipeline parallelization model to achieve
               high performance and good scalability. The parsing and schema validation are two major
               pipeline stages in this model and are both based on a novel chunk-based speculative
               parallel XML processing algorithm. The parallel algorithm first partitions the XML
               document by chunks and then apply data-parallel model to process each chunk in parallel.
            </div>
            <div class="para e57">Several efforts have been made in this field to parallelize XML parsing. Wei Lu first
               presented a pre-scanning based parallel parsing model, which consisted of an initial
               pre-scanning phase to determine the structure of the XML document, followed by a full,
               parallel parser [6]. The results of pre-scanning phase are used to help partition
               the XML document for data parallel processing. The research continued with an attempt
               to parallelize the pre-scanning stage to exploit more parallelism [8]. Michael R.Head
               also explored new techniques for parallelizing parsers for very large XML documents
               [7]. They did not focus on developing parallel XML parsing algorithm, but exposing
               the parallelism by dividing XML parsing process into several phases, such as XML data
               loading, XML parsing and result generation, and then scheduling working threads to
               execute each parsing phase in a pipeline model. The paper discussed a bunch of performance
               issues such as load imbalance and communication and synchronization overhead. Parabix
               uses parallel bitstream technology [10], in its XML parsing by exploiting the SSE
               vector instructions in the Intel architecture [9].
            </div>
            <div class="para e58">Compared to other approaches, our approach tries to avoid the pre-scanning overhead
               [6], as we discovered the pre-scanning overhead is considerable especially after we
               improved the parsing performance [9]. Our the algorithm is chunk-based and each parallel
               sub-task is to process a chunk, it helps processing a large document without loading
               it into the memory. The vectorization approach [10] can be used in the each parallel
               sub-task and therefore complementary to our approach. Moreover, our paper is the first
               one describing the parallel schema validation and the hybrid parallel model. The performance
               evaluation results show the performance benefits by this model and parallel XML parsing
               and schema validation.
            </div>
            <div class="para e59">The rest of the paper is organized as follows. Section 2 introduces hybrid parallel
               XML processing model. Sections 3 and 4 focus on parallel XML parsing and parallel
               schema validation algorithms. The last section gives the performance evaluation results
               and makes a performance comparison with an existed parallel XML parser model.
            </div>
         </div>
      </div><a name="HybridParallelXMLProcessingModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e60">
         <div class="title e61">Hybrid Parallel XML Processing Model</div>
         <div class="para e62">The hybrid parallel XML processing model showing in figure 1 combines pipeline and
            data-parallel model to expose more parallelism and achieve better scalability.
         </div><a name="PipelineExecutioninXMLProcessingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e63">
            <div class="title e64">Pipeline Execution in XML Processing</div>
            <div class="para e65">XML processing can be executed as pipeline. Figure 1 shows two pipeline stages, parsing
               and validation. The two stages can execute as a pipeline based on chunks, which means,
               the parsing stages inputs the XML document by chunks and outputs parsed chunks while
               validation stage inputs the parsed chunk from previous stage and do validation against
               each parsed chunk if it's necessary. After that, it either associates PSVI information
               with each node in the chunk or produce a simple Boolean to indicate whether the document
               is valid.
            </div>
            <div class="para e66">However, the common challenge for a pipeline model is how to maintain load balance
               among pipeline stages. As the speed of producing the parsed chunk can be different
               than the consumption speed of the validator and the difference may vary for different
               chunks.  The parsed chunk pool acts as a cushion to absorb these differences. The
               more detailed discussion about how to assure load balance in pipeline model is out
               of the scope of this paper.
            </div>
         </div><a name="ApplyDataparallelModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e67">
            <div class="title e68">Apply Data-parallel Model</div>
            <div class="para e69">Both the parsing and validation stages can apply chunk based data-parallel model respectively
               to exploit more parallelism.
            </div>
            <div class="para e70">As shown in figure 1, parsing stage contains a number of XML parsers. At first, the
               input XML document is partitioned into chunks and put into a chunk pool. All of XML
               parsers can start speculative parsing once an input chunk in the chunk pool is available
               even though not receiving the whole input XML document. Any parser may perform chunk
               partition when the chunk number in the pool is less than a given threshold. After
               finishing parsing a chunk, the information for the chunk is not complete, the parallel
               parser must carry out post processing for the chunk after all preceding chunks are
               parsed. After that, the parsed chunks hold the complete infoset information for the
               corresponding input chunk and can be put into parsed chunk pool to be processed by
               next stage.
            </div>
            <div class="para e71">Similarly, the validation stage contains multiple parallel validators, each of which
               can perform partial validation once a parsed chunk is available. The parallel validator
               reads the parsed chunk from the pool directly. After validating one chunk, the post
               processing should be executed for all of preceding chunks to produce final validation
               result.
            </div>
            <div class="figure e72" floatstyle="1" xml:id="hybrid" xreflabel="hybrid">
               <div class="mediaobject e73">
                  <div class="imageobject e74">
                     <div class="metaBox e75"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e117').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e117" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e75'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-001.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e76">
                     <div class="para e77">Hybrid parallel XML processing model</div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="ParallelXMLParsingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e78">
         <div class="title e79">Parallel XML Parsing</div>
         <div class="para e80">Parallel XML parsing scans an XML document in parallel as well as checking the well-formedness
            and generates the parsing result. The XML document is divided into chunks so that
            each parser works on a chunk independently and generates its own partial result that
            is merged in document order during the post processing step to produce the final result.
         </div>
         <div class="para e81">The key to the parallel XML parsing algorithm is how to parse a chunk as a part of
            an XML document without seeing the whole document. A chunk may start in the middle
            of some string whose context and grammatical role is unknown. For example, a chunk
            may start as a part of element name or attribute or text value. Without this information,
            the parser does not know how to parse a chunk.
         </div>
         <div class="para e82">We present speculative XML parsing to address this issue. Speculative parsing can
            produce partial result for each chunk and delegate uncompleted work to post processing.
         </div>
         <div class="para e83">To support the speculative processing, we use a simple DOM-like XML tree(S-TREE) as
            our internal representation and the final parsing result. The node in S-TREE only
            has parent and first children link and all of sibling nodes are organized as document
            order, which is very memory efficient. S-TREE can be partially generated in the initial
            parsing step with the rest of the information completed in the later post processing
            step. We use the term of partial S-TREE to refer a partially generated S-TREE by speculative
            parsing for one chunk and all of partial S-TREEs can be linked together to be a completed
            one after post processing.
         </div>
         <div class="para e84">Figure 2 provides a detailed look at the parser. The speculative parsing based algorithm
            brings additional overhead: the chunk partition and the post processing. However,
            the overhead is much smaller than the pre-scanning overhead [6] and it can be amortized
            as the task can be done in parallel with speculative parsing. As shown in the figure,
            typically the chunk partition and the post processing are carried out only once although
            each parallel parser may perform the function. Comparably, the pre-scanning based
            algorithm [6] requires a pre-scanning over the whole document to get the skeleton
            of an XML document before parallel parsing can start.
         </div>
         <div class="figure e85" floatstyle="1" xml:id="PXP" xreflabel="pxp">
            <div class="mediaobject e86">
               <div class="imageobject e87">
                  <div class="metaBox e88"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e137').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e137" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e88'
                           </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-002.jpg'
                           </span><span class="metaAttribute">format='jpg'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e89">
                  <div class="para e90">Parallel XML Parsing Algorithm</div>
               </div>
            </div>
         </div><a name="ChunkPartitionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e91">
            <div class="title e92">Chunk Partition</div>
            <div class="para e93">Chunk partition divides the whole or part of XML document into several of approximately
               equal-sized chunks and puts them into the chunk pool. The chunk size can be decided
               at run time to assure 1) each chunk should be big enough to minimize the number of
               chucks and reduce the post processing workload. 2) each parsing thread has one chunk
               to be processed at least, that is, the number of chunks should be larger than the
               number of working threads.
            </div>
            <div class="para e94">An issue for chunk partition is that a chunk may start in the middle of some string
               as we have discussed before. To make use of speculative parsing, we force each chunk
               must start with left angle bracket "&lt;" by forward searching in XML during partition.
               By this way, each chunk can be regarded as a new XML document though it may not be
               well-formed.
            </div>
         </div><a name="SpeculativeParsingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e95">
            <div class="title e96">Speculative Parsing</div>
            <div class="para e97">This step parses each chunk and generates partial S-TREE.</div>
            <div class="para e98">Because each chunk always begins with left angle bracket "&lt;", our parser works the
               same way as a single threaded or traditional parser does. However, a traditional parser
               may throw an exception if a chunk is not well-formed. For example, figure 3-a is a
               possible chunk partition for a sample XML document, we can find the chunk 3 is not
               well-formed for it starts with an end element. 
            </div>
            <div class="para e99">Speculative parsing deals with this issue by catching and classifying all of ill-formed
               exceptions. We have identified that there are three types of ill-formed exceptions.
               Each exception implies there is an unresolved element. All of unresolved elements
               can be further processed in post processing step.
            </div>
            <div class="para e100">1) Unresolved Start Element; which means the start element has no corresponding end
               element in current chunk. The unresolved start elements include "catalog", "book",
               and "title" in the first chunk of figure 3-a.
            </div>
            <div class="para e101">2) Unresolved End Element; which means the end element appeared when there is no matched
               start element in current chunk. Like the element "title" in the second chunk of figure
               3-a.
            </div>
            <div class="para e102">3) Unresolved Prefix; which means the prefix has no associated namespace definition
               in current chunk. Like the prefix "bw" in the second chunk of figure 3-a.
            </div>
            <div class="figure e103" floatstyle="1" xml:id="Xsample" xreflabel="sample">
               <div class="mediaobject e104">
                  <div class="imageobject e105">
                     <div class="metaBox e106"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e166').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e166" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e106'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-003.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e107">
                     <div class="para e108">Figure3-a A sample XML includes three chunks</div>
                  </div>
               </div>
               <div class="mediaobject e109">
                  <div class="imageobject e110">
                     <div class="metaBox e111"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e172').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e172" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e111'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-004.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e112">
                     <div class="para e113">Figure3-b Speculative Parsing Result of sample XML</div>
                  </div>
               </div>
            </div>
            <div class="para e114">The unresolved start and end elements of a chunk are added to UnresolvedEE queue and
               UnresolvedSE queue respectively. For each unresolved start element, it also records
               the context information like namespace definition. In addition, the Qname of the start
               element and end element are recorded to help the well-formedness check in the post
               processing. The unresolved prefixes are recorded and later on resolved in the post
               processing step. Figure 3-b gives the speculative parsing result for each chunk of
               figure 3-a, which contains generated partial S-TREEs and unresolved elements.
            </div>
            <div class="para e115">Speculative parsing of a chunk may produce a number of partial S-TREEs. A new S-TREE
               is produced whenever the element has no parent in the current chunk. For example,
               the chunk 2 generates two partial S-TREEs as shown in figure 3-b. For each S-TREE,
               a relative depth is recorded to indicate his distance between the current tree and
               the tree with lowest level.
            </div>
         </div><a name="PostProcessingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e116">
            <div class="title e117">Post-Processing</div>
            <div class="para e118">The post processing propagates the context information and performs residual processing
               including checking well-formedness across chunks, resolving unresolved prefix and
               linking partial S-TREEs. As post processing has to be sequentially executed in one
               parallel parser, the algorithm is designed to be highly efficient.
            </div><a name="ContextinformationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e119">
               <div class="title e120">Context information</div>
               <div class="para e121">The post processing propagates context information from the first chunk to the succeeding
                  chunks. The context information is used in the residual processing to complete the
                  parsing of a partial processed chunk. The context information has to include QName,
                  namespace definition and node reference of each unresolved start element in the UnresolvedSE
                  queue to support well-formedness checking, unresolved prefix resolving and partial
                  S-TREEs linking. The context information has to be prepared beforehand at the partial
                  processing as long as the UnresolvedSE queues are formed.
               </div>
            </div><a name="WellformednessCheckingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e122">
               <div class="title e123">Well-formedness Checking</div>
               <div class="para e124">Parallel XML parsing uses two steps to check the well-formedness against an XML document.
                  First, speculative parsing checks the well-formedness inside a chunk and post processing
                  checks unresolved start and end element with a simple and efficient algorithm illustrated
                  in figure 4. In this algorithm, N indicates the number of parsed chunks. 
               </div>
               <div class="figure e125" floatstyle="1" xml:id="wellform" xreflabel="wellform">
                  <div class="mediaobject e126">
                     <div class="imageobject e127">
                        <div class="metaBox e128"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e198').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e198" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e128'
                                 </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-005.jpg'
                                 </span><span class="metaAttribute">format='jpg'
                                 </span><span class="metaAttribute">width='90%'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                     <div class="caption e129">
                        <div class="para e130">Well-formedness checking algorithm</div>
                     </div>
                  </div>
               </div>
               <div class="para e131">This algorithm maintains the global context stack and matches its unresolved start
                  element with the unresolved end elements in the UnresolvedEE queue for each chunk
                  consecutively. After the last chunk has been processed, the global context stack and
                  the UnresolvedEE queue of the chunk should be empty, which indicates all of start
                  elements have matched all of end elements. Then the whole XML document is well-formed;
                  otherwise it throws ill-formed exception.
               </div>
            </div><a name="ResolvingUnresolvedPrefixANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e132">
               <div class="title e133">Resolving Unresolved Prefix</div>
               <div class="para e134">In a well-formed XML document, any prefix must bind to a determined namespace. Speculative
                  parsing can't bind an unresolved prefix to any namespace because its namespace may
                  be defined in a preceding chunk.
               </div>
               <div class="para e135">To resolve unresolved prefixes, the post processing treats the namespace as context
                  information and propagates the namespace information when maintaining the global context
                  stack. It looks up all the ancestors of the element from its direct parent to the
                  root element of XML document in global context stack to find the first matched namespace
                  definition. If successful, all elements with the prefix associate the matched namespace;
                  otherwise it throws unrecognized prefix exception.
               </div>
               <div class="para e136">However, there is an exception for resolving default namespace. If there is no matched
                  default namespace definition for a default prefix, it should not report any error.
                  Because XML specification has specified a pre-defined default namespace, it's not
                  necessary to define a new default namespace in an XML document.
               </div>
            </div><a name="LinkingPartialSTREEsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e137">
               <div class="title e138">Linking Partial S-TREEs</div>
               <div class="para e139">This step links partial S-TREEs together to be a complete S-TREE representing the
                  original XML document. The key to this step is finding the correct parent for the
                  root node of each partial S-TREE. So element's depth is introduced to indicate the
                  relevant depth for the element in its own chunk, which is equal to number of unresolved
                  end element appearing before the element in current chunk. The figure 5 shows how
                  a partial S-TREE is linked to the trunk tree. In this algorithm, N stands for the
                  total number of chunks.
               </div>
               <div class="figure e140" floatstyle="1" xml:id="DOMmerge" xreflabel="dommerge">
                  <div class="mediaobject e141">
                     <div class="imageobject e142">
                        <div class="metaBox e143"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e221').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e221" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e143'
                                 </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-006.jpg'
                                 </span><span class="metaAttribute">format='jpg'
                                 </span><span class="metaAttribute">width='90%'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                     <div class="caption e144">
                        <div class="para e145">Partial S-TREE Linking algorithm</div>
                     </div>
                  </div>
               </div>
               <div class="para e146">After this step, a chunk of XML data can be represented by a number of partial S-TREEs
                  whose information is complete enough that it can be processed by another application,
                  for example, parallel schema validator can start validation based on partial S-TREEs
                  to expose more data-parallel opportunity.
               </div>
            </div>
         </div>
      </div><a name="ParallelSchemaValidationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e147">
         <div class="title e148">Parallel Schema Validation</div>
         <div class="para e149">Like parallel XML parsing, the basic idea of parallel schema validation is dividing
            the whole validation task into a set of subtasks, where each subtask validates a chunk
            of the document. Schema validation can work on partial S-TREE directly rather than
            the raw XML data. The validation stage has two phases, partial validation and residual
            validation, corresponding to speculative parsing and post processing in section 3.
            The figure 6 provides a more detailed look at the parallel validation.
         </div>
         <div class="figure e150" floatstyle="1" xml:id="PSV" xreflabel="psv">
            <div class="mediaobject e151">
               <div class="imageobject e152">
                  <div class="metaBox e153"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e235').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e235" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e153'
                           </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-007.jpg'
                           </span><span class="metaAttribute">format='jpg'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e154">
                  <div class="para e155">Parallel Schema Validating</div>
               </div>
            </div>
         </div><a name="PartialValidationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e156">
            <div class="title e157">Partial Validation</div>
            <div class="para e158">Partial validation starts with schema validation on the partial S-TREEs, which can
               be regarded as a subtask of the whole validation process starting from one of generated
               partial S-TREE so that partial validation can be executed in parallel based on having
               multiple partial S-TREEs. Usually, a finite state machine is used to describe the
               validation process. To validate a partial S-TREE, we must determine the schema type
               for the root element of a partial tree to initialize start of the start of the finite
               state machine.
            </div>
            <div class="para e159">According to schema definition, we can look up all of ancestors for a specific element
               to determine its schema type. As described in last section, each partial S-TREE must
               be linked into the preceding parsed chunks before being validated. So the ancestor
               link for the root element of a partial S-TREE is available. As long as the schema
               type of the root element is determined, the whole partial S-TREE can be validated.
               After finishing validating all of partial S-TREEs in a chunk it generates schema context
               information for all of unresolved start elements in current chunk, and summaries the
               type information in validation summary, which can be used in residual processing.
               The algorithm detail is shown in figure 7.
            </div>
            <div class="figure e160" floatstyle="1" xml:id="Partialval" xreflabel="pval">
               <div class="mediaobject e161">
                  <div class="imageobject e162">
                     <div class="metaBox e163"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e249').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e249" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e163'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-008.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e164">
                     <div class="para e165">Partial Validation Algorithm</div>
                  </div>
               </div>
            </div>
         </div><a name="ResidualValidationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e166">
            <div class="title e167">Residual Validation</div>
            <div class="para e168">Residual validation merges the partial validation result in document order. In fact,
               it just resumes to validate the unresolved start elements in a chunk which has been
               suspended due to its child nodes are not available in that chunk. The only difference
               of residual validation from traditional validation process is that it will use the
               information kept in validation summary to do the validation work other than retrieving
               from original XML document. Figure 8 describes the algorithm.
            </div>
            <div class="figure e169" floatstyle="1" xml:id="Reval" xreflabel="reval">
               <div class="mediaobject e170">
                  <div class="imageobject e171">
                     <div class="metaBox e172"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e261').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e261" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e172'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-009.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e173">
                     <div class="para e174">Residual Validation Algorithm</div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="PerformanceEvaluationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e175">
         <div class="title e176">Performance Evaluation</div>
         <div class="para e177">This section gives the performance evaluation result. In our experiment, we use the
            high performance XML parser in the Intel® XML Software Suite as the baseline, which
            offers 80M/sec throughput single-thread performance on the 2.66G Xeon test machine
            [9]. We first analyzed the performance breakdown for our hybrid parallel processing
            model for XML parsing and schema validation. Then we measured performance of our standalone
            parallel parser, which only parsing and try to analyze its speedup and overhead for
            documents with different size. Then we make a comparison between speculative parsing
            based XML parser and the pre-scanning based approach, using our prototype parallel
            parsers with the two approaches. At last, we show the performance improvement on schema
            validating parser which integrates parallel parsing and schema validation.
         </div>
         <div class="para e178">These performance measurements were taken on a Dual Intel Xeon 5300 processor machine
            (2.66GHz, Quad Core, Shared 8M L2 cache) with 4G RAM. The underlying operating system
            for these tests was Redhat Linux EL4 (kernel 2.6.9).  The test cases are taken from
            Intel's XML Parsing Benchmark [11], whose cases are all from real customer and varied
            in XML size, number of elements and element nesting depth. For example, the size of
            test cases is in ranging from 5K to 20M and the element nesting depth is from zero
            to six.
         </div>
         <div class="para e179">To minimize external system effects on our results, we had exclusive access to the
            machine during testing. Every test ran ten times, to get the average time the first
            time was discard, so as to measure performance with the XML document data already
            cached rather than being read from disk. 
         </div><a name="PerformanceBreakdownANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e180">
            <div class="title e181">Performance Breakdown</div>
            <div class="para e182">Our parallel XML processing model performs the pipeline stages as described, and thus
               we can measure the time of each stage. The sequential stages include chunk partition,
               post processing in XML parsing and residual validation in schema validation. The speculative
               parsing and partial validation can be done in parallel. Figure 9 shows the average
               time consuming percentage of each stage from two threads to eight threads.
            </div>
            <div class="para e183">First, we find the percentage of effort related to chunk partition is nearly zero.
               The main reason is that speculative parsing algorithm can start parsing any part of
               XML as long as it starts with left angle bracket "&lt;", which simplifies the chunk partition
               algorithm.
            </div>
            <div class="para e184">As thread number increases up to eight, we observe the percentage for another two
               sequential stages, post processing and residual validation grows from 10% to 35%.
               If excluding the overhead caused by lock contention, the time consumed by the two
               stages is in direct ratio to chunk number and average element depth of an XML document.
               For example, the worst situation is that the first chunk only has start element while
               the second one only contains end element, which hints the XML document has very high
               depth. We also measure the performance breakdown for such worst XML case.  The result
               shows the percentage taking by post processing and residual validation is less than
               50% in 8 threads, which is acceptable because such worst XML case is rare exception.
            </div>
            <div class="figure e185" floatstyle="1" xml:id="Pbreak" xreflabel="Pbreak">
               <div class="mediaobject e186">
                  <div class="imageobject e187">
                     <div class="metaBox e188"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e286').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e286" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e188'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-010.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e189">
                     <div class="para e190">Performance Breakdowns</div>
                  </div>
               </div>
            </div>
         </div><a name="StandaloneParallelParserPerformanceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e191">
            <div class="title e192">Standalone Parallel Parser Performance</div>
            <div class="para e193">Standalone parallel parser only parses the XML document in parallel and generate DOM-like
               tree. We use the term speedup to measure how well the parallel algorithm scales and
               evaluate the efficiency of parallel algorithms.  Speedup is calculated by dividing
               sequential time by the parallel execution time. We use the XML parser in Intel® XML
               Software Suite as the baseline to get the sequential execution time. The parallel
               time is the time our parallel XML parser spends on build the same DOM-like tree. Figure
               10 shows how the parallel algorithm scales with the number of threads when parsing
               the XML document with different document size.
            </div>
            <div class="figure e194" floatstyle="1" xml:id="purePerf" xreflabel="pureperf">
               <div class="mediaobject e195">
                  <div class="imageobject e196">
                     <div class="metaBox e197"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e298').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e298" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e197'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-011.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e198">
                     <div class="para e199">Speedup of standalone parallel parser on XML document with different size</div>
                  </div>
               </div>
            </div>
            <div class="para e200">From the figure 10, we can see that the bigger the XML document size, the higher speedup
               of parallel parser can achieve. Because bigger XML document can be split into more
               subtasks to be parsed in parallel and can maximize the utilization of multi-processors.
               This algorithm has very good speedup for large XML documents. It is even nearly three
               times faster than sequential parsing with four threads. The speedup for large documents
               is also nearly 4.5 with eight threads. But the overhead of thread communication and
               lock contention is becoming significant when the total sequential parsing time is
               very short for small XML documents. That's the reason why there is no performance
               gain for small XML documents less than 64K. But parallel parser can filter these cases
               at run time by setting a threshold of minimum XML document size. It still makes sense
               because parallel parser is designed for speeding up the parsing of large XML documents.
               
            </div>
            <div class="para e201">Besides, we made a performance comparison analysis against an alternative parallel
               parser prototype presented in paper [6]. Before we use the speculative execution based
               approach, we have developed a prototype using the pre-scanning approach. Figure 11
               gives the performance comparison result for the two parallel XML parsing algorithms
               on large XML document. The result shows the performance of our speculative parsing
               based parser has significantly higher speed-up. Also, the pre-scanning based parsing
               approach doesn't scale very well when we use 8 threads on 8-core machine. 
            </div>
            <div class="figure e202" floatstyle="1" xml:id="comPerf" xreflabel="comperf">
               <div class="mediaobject e203">
                  <div class="imageobject e204">
                     <div class="metaBox e205"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e309').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e309" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e205'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-012.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e206">
                     <div class="para e207">Performance Comparison for two Algorithms</div>
                  </div>
               </div>
            </div>
            <div class="para e208">Speculative parsing based parser avoids the pre-scanning process and reduces the sequential
               execution time as much as possible. An initial evaluation result shows that the average
               overhead of pre-scanning is hundreds times slower than the overhead introduced by
               the sequential execution time of our parallel algorithm, which explains the reason
               that speculative execution based parallel parser performs better than the pre-scanning
               based parallel parser.
            </div>
         </div><a name="ParallelvalidatedparserperformanceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e209">
            <div class="title e210">Parallel validated parser performance</div>
            <div class="para e211">A validating parser performs validation during parsing. Our parallel validating parser
               is an integration of parallel parsing and parallel schema validation with a pipeline
               model. Schema validating parser has two usual usage models. The first, named parallel
               validator only validates the XML document and gives the validation result against
               a given schema. The other also outputs a DOM-like tree with type information at the
               same time, named parallel validating DOM parser.
            </div>
            <div class="para e212">Figure 12 gives the speedup for pure parallel parsing, standalone parallel validation
               and parallel validated DOM parser respectively on large XML documents, using XML schema
               validator in Intel® XML Software Suite as our baseline. The speedup of parallel validating
               DOM parser reaches above 5 on the 8-core test machine. The speedup of parallel validator
               is slightly slower as the baseline uses a faster mode which avoids generating the
               intermediate DOM-like tree. The better speedup of parallel validator than that of
               standalone parallel parser demonstrate the former exposes more parallelism by integrating
               parallel XML parsing and schema validation while has lower overhead of parallel validation
               by using the information summary in the residual processing
            </div>
            <div class="figure e213" floatstyle="1" xml:id="threePerf" xreflabel="threeperf">
               <div class="mediaobject e214">
                  <div class="imageobject e215">
                     <div class="metaBox e216"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e325').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e325" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e216'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Wu01/Wu01-013.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='90%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e217">
                     <div class="para e218">Speedup of Three Parallel Parsers</div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e219">
         <div class="title e220">Conclusion</div>
         <div class="para e221">In this parser, we describe a new parallel XML parsing algorithm with great performance
            and that scales well for up to eight cores by means of speculative based parsing.
            Then we develop a novel parallel schema validation algorithm which can validate partial
            DOM-like trees generated by parallel XML parsers. Based on the two parallel algorithms,
            a hybrid parallel processing model is presented. This model organizes XML parsing
            and schema validation as a two stages execution pipeline and then apply data-parallel
            for each stage to expose more parallelism.  Our results have shown this hybrid parallel
            XML processing model is effective and very efficient.
         </div>
      </div><a name="LEGALINFORMATIONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e222">
         <div class="title e223">LEGAL INFORMATION</div>
         <div class="para e224">This paper is for informational purposes only. THIS DOCUMENT IS PROVIDED "AS IS" WITH
            NO WARRANTIES WHATSOEVER, INCLUDING ANY WARRANTY OF MERCHANTABILITY, NONINFRINGEMENT,
            FITNESS FOR ANY PARTICULAR PURPOSE, OR ANY WARRANTY OTHERWISE ARISING OUT OF ANY PROPOSAL,
            SPECIFICATION OR SAMPLE. Intel disclaims all liability, including liability for infringement
            of any proprietary rights, relating to use of information in this specification. No
            license, express or implied, by estoppel or otherwise, to any intellectual property
            rights is granted herein.
         </div>
         <div class="para e225">Intel, the Intel logo, Intel leap ahead, Intel leap ahead logo, Intel Core, are trademarks
            of Intel Corporation in the United States and other countries.
         </div>
         <div class="para e226">*Other names and brands may be claimed as the property of others.</div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e227">
         <div class="title e228">Bibliography</div>
         <div class="bibliomixed e229" xml:id="A1" xreflabel="Singh2003">G. Singh, S. Bharathi, A. Chervenak, E. Deelman, C. Kesselman, M.Manohar, S. Patil,
            and L. Pearlman. "A Metadata Catalog Service for Data Intensive Applications" In SC'03:
            Proceedings of the 2003 ACM/IEEE conference on Supercomputing, page 33
         </div>
         <div class="bibliomixed e230" xml:id="A2" xreflabel="eBay">eBay. eBay Developers Program 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e231" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://developer.ebay.com/developercenter/soap</div>
         </div>
         <div class="bibliomixed e232" xml:id="A3" xreflabel="Head2005">M. R. Head, M. Govindaraju, A. Slominski, P. Liu, N. Abu-Ghazaleh, R. van Engelen,
            K. Chiu, and M. J. Lewis. "A Benchmark Suite for SOAP-based Communication in Grid
            Web Services." In SC'05: Proceedings of the 2005 ACM/IEEE conference on Supercomputing,
            page 19, Washington, DC, USA, 2005. IEEE Computer Society. doi: 
            <div class="biblioid doi e233">10.1109/SC.2005.2</div>
         </div>
         <div class="bibliomixed e234" xml:id="A4" xreflabel="Head2006">M. R. Head, M. Govindaraju, R. van Engelen, and W. Zhang. "Benchmarking XML Processors
            for Applications in Grid Web Services".  In SC'06: Proceedings of the 2006 ACM/IEEE
            conference on Supercomputing, page 121, New York, NY, USA, 2006. ACM Press. doi: 
            <div class="biblioid doi e235">10.1145/1188455.1188581</div>
         </div>
         <div class="bibliomixed e236" xml:id="A5" xreflabel="Nicola2003">Nicola, M. and John, J., "XML Parsing: a Threat to Database Performance" International
            Conference on Information and Knowledge Management, 2003, pp. 175-178. doi: 
            <div class="biblioid doi e237">10.1145/956863.956898</div>
         </div>
         <div class="bibliomixed e238" xml:id="A6" xreflabel="WeiLu2006">W. Lu, K. Chiu, and Y. Pan "A parallel approach to XML parsing". In The 7th IEEE/ACM
            International Conference on Grid Computing, Barcelona, September 2006. doi: 
            <div class="biblioid doi e239">10.1109/ICGRID.2006.311019</div>
         </div>
         <div class="bibliomixed e240" xml:id="A7" xreflabel="Michael">Michael R. Head and Madhusudhan Govindaraju. "Approaching a Parallelized XML Parser
            Optimizedfor Multi-Core Processor"
         </div>
         <div class="bibliomixed e241" xml:id="A8" xreflabel="Yinfei">Yinfei Pan, Ying Zhang, Kenneth Chiu, Wei Lu, "Parallel XML Parsing Using Meta-DFA",
            Proceedings of the Third IEEE International Conference on e-Science and Grid Computing
         </div>
         <div class="bibliomixed e242" xml:id="A9" xreflabel="Intel">Intel ® XML Software Suite 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e243" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.intel.com/cd/software/products/asmo-na/eng/366637.htm</div>
         </div>
         <div class="bibliomixed e244" xml:id="A10" xreflabel="parabix">parabix, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e245" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://parabix.costar.sfu.ca</div>
         </div>
         <div class="bibliomixed e246" xml:id="A11" xreflabel="Intel">Intel ® XML Software Suite Performance Paper 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e247" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://softwarecommunity.intel.com/isn/downloads/softwareproducts/pdfs/XSSPerformancePaper.pdf</div>
         </div>
         <div class="bibliomixed e248" xml:id="A12" xreflabel="Intel">Intel Multi-core Architecture Briefing.
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e249" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.intel.com/pressroom/archive/releases/20080317fact.html</div>
         </div>
      </div>
   </div>
</div>