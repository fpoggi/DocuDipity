<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#WhereAreAllTheBugs?ANCHOR" name="WhereAreAllTheBugs?TOC">Where Are All The Bugs?</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BackgroundANCHOR" name="BackgroundTOC">Background</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheCodeBaseANCHOR" name="TheCodeBaseTOC">The Code Base</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Zipf'sLawandTFIDFScoringANCHOR" name="Zipf'sLawandTFIDFScoringTOC">Zipf's Law and TF-IDF Scoring</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DistributionofSequenceTypesANCHOR" name="DistributionofSequenceTypesTOC">Distribution of Sequence Types</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TypeScoresANCHOR" name="TypeScoresTOC">Type Scores</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TechniquesANCHOR" name="TechniquesTOC">Techniques</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DistributionofFunctionsANCHOR" name="DistributionofFunctionsTOC">Distribution of Functions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FunctionScoresANCHOR" name="FunctionScoresTOC">Function Scores</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TechniquesANCHOR" name="TechniquesTOC">Techniques</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#SummaryandConclusionsANCHOR" name="SummaryandConclusionsTOC">Summary and Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">analyze-string</div>
         <div class="singletermTERMS">awk</div>
         <div class="singletermTERMS">also</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">buildHTTPServer2</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">cts:query</div>
         <div class="singletermTERMS">concat</div>
         <div class="singletermTERMS">call-calais</div>
         <div class="singletermTERMS">create-server</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">DF(t)</div>
         <div class="singletermTERMS">data</div>
         <div class="singletermTERMS">do-parse</div>
         <div class="singletermTERMS">declare function</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">element(my:result)</div>
         <div class="singletermTERMS">element()</div>
         <div class="singletermTERMS">element</div>
         <div class="singletermTERMS">element(*,my:example)</div>
         <div class="singletermTERMS">empty-sequence()</div>
         <div class="singletermTERMS">element(xproc:xslt)</div>
         <div class="singletermTERMS">element(xproc:xquery)</div>
         <div class="singletermTERMS">empty</div>
         <div class="singletermTERMS">exists</div>
         <div class="singletermTERMS">error</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">Frequency(R) = Frequency(1)/Rk</div>
         <div class="singletermTERMS">Frequency(R)</div>
         <div class="singletermTERMS">find</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">head</div>
         <div class="singletermTERMS">Holstege</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">item()*</div>
         <div class="singletermTERMS">item()*, node(), node()?, node()*, item()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">log</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">map:map</div>
         <div class="singletermTERMS">map:put</div>
         <div class="singletermTERMS">map:get</div>
         <div class="singletermTERMS">meaningful</div>
         <div class="singletermTERMS">mary.holstege@marklogic.com</div>
         <div class="singletermTERMS">Mary</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">navItem</div>
         <div class="singletermTERMS">navItemClosed</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">options</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">Principal Engineer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">string</div>
         <div class="singletermTERMS">sort</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">TF(t)</div>
         <div class="singletermTERMS">tokenize</div>
         <div class="singletermTERMS">Type Introspection in XQuery.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">uniq</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xs:string?</div>
         <div class="singletermTERMS">xs:long</div>
         <div class="singletermTERMS">xs:integer</div>
         <div class="singletermTERMS">xs:QName</div>
         <div class="singletermTERMS">xs:NOTATION</div>
         <div class="singletermTERMS">xquery version</div>
         <div class="singletermTERMS">XPath and XQuery Functions and Operators 3.0</div>
         <div class="singletermTERMS">XQuery 3.0: An XML Query Language</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="WhereAreAllTheBugs?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Where Are All The Bugs?</div>
      <div class="subtitle e2">Introspection in XQuery</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2013</div>
            <div class="confdates e6">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">In a large code and complex code base, it becomes unfeasible to
               manually develop tests for every feature and combination of
               features. The key to quality assurance in this context is automation and focus.
               Automatic generation of tests creates its own problems, however, as the
               execution of a complete cross-product of all interactions will take too long to
               execute, and small defects can give rise to large numbers of regression
               failures that must be manually analyzed. Manually identifying the interactions
               is itself a challenging undertaking, as is automatically generating
               
               <div class="emphasis e9">meaningful</div> test cases. It becomes important to make smart
               choices about what to expend effort on so as to minimize the risk of undetected
               code defects. 
               
            </div>
            <div class="para e10">This paper reports on an attempt to find areas to focus testing on in a
               large XQuery code base by performing XQuery introspection on that code base,
               treating the set of functions and parameter and return types as vocabularies, and
               computing TF-IDF scores over the terms in those vocabularies. To the extent
               that function names and types follow classic Zipf distributions,
               using TF-IDF scoring over those vocabularies makes mathematical sense.
               Terms that score high will be those that are common enough to be important
               (high term frequency) but not so ubiquitous that they tend not to be covered by
               other tests (high inverse document frequency).
               
            </div>
         </div>
         <div class="author e11">
            <div class="personname e12">
               <div class="firstname e13">Mary</div>
               <div class="surname e14">Holstege</div>
            </div>
            <div class="personblurb e15">
               <div class="para e16">Mary Holstege is Principal Engineer at MarkLogic
                  Corporation. She has over 20 years experience as a software engineer in and
                  around markup technologies and information extraction. She holds a Ph.D. from
                  Stanford University in Computer Science, for a thesis on document
                  representation.
               </div>
            </div>
            <div class="affiliation e17">
               <div class="jobtitle e18">Principal Engineer</div>
               <div class="orgname e19">MarkLogic Corporation</div>
            </div>
            <div class="email e20">mary.holstege@marklogic.com</div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright © 2013 Mary Holstege</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e23">
         <div class="title e24">Introduction</div>
         <div class="para e25">Ensuring that software works properly can be a difficult undertaking.
            When a code base is small and worked on by a handful of people,
            you can manually generate tests with good confidence that they cover the ground.
            As the code base grows it develops more complex interactions,
            includes more features, and is modified by more and more developers.
            The code develops unused byways and tangles of dependencies.
            It becomes unfeasible to
            manually develop tests for every feature and combination of features.
            Complete automated testing of all possibilities also becomes increasing less
            feasible:
            developing cases, executing them, and analyzing the results becomes more and
            more time consuming. The sad truth about QA is that the difficulty of ensuring
            that software works correctly does not scale linearly with the size of the code base.
            
         </div>
         <div class="para e26">Analysis of code usage patterns can help focus attention where testing can do
            the most good. Code analysis can also provide a different perspective on the
            code that can lead to uncovering potential issues as well. For example, a
            function that is not called much probably doesn't need a lot of testing. Testing is
            
            designed to limit risk, and the risk of a bug in a rarely used function is
            commensurately low. On the other hand, a function that is widely called may
            
            <div class="emphasis e27">also</div> not need a lot of additional testing on the grounds
            that it is already tested in the process of testing its callers. So again, from
            a risk perspective, the risk of not adding additional tests for that function
            is also low. Beyond simple
            testing, analysis of usage patterns can perhaps highlight areas where APIs can
            be simplified by removing unnecessary options and alternatives.
            
         </div>
         <div class="para e28">
            The schema types and elements used in function argument and return types form
            an important part of the API. Analysis of the usage patterns of declared types
            and elements against the available pool exposed by the in scope schemas can
            also provide insights into possible API simplification, or testing focus.
            
         </div>
         <div class="para e29">The idea explored here is that (a) functions and types form
            vocabularies of sorts 
            and the distribution of usage of those vocabularies follows the well-established
            laws for natural language vocabularies (i.e. Zipf's law) and as such
            (b) TF-IDF score calculations over those vocabularies make mathematical
            sense and (c) high scoring items make interesting and useful targets for
            testing. 
            
         </div>
         <div class="para e30">
            This paper describes a case study in analyzing a large XQuery code base
            using XQuery and XML Schema introspection in an attempt to determine where to
            focus testing efforts, based on this idea. For functions at least, there seems
            to be some reason to conclude that the idea holds promise. Types, less so.
            
         </div>
         <div class="para e31">Several extensions to XQuery are required to perform this introspection:
            a schema component API, functions to provide lists of available functions and
            return types and argument types of functions. It is also convenient, in order
            to implement the entire processing reasonably efficiently in XQuery, to have
            map data types, a structured dump of the parse tree of XQuery modules,
            filesystem access functions, and the ability to evaluated constructed XQuery
            functions.
            
         </div>
      </div><a name="BackgroundANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e32">
         <div class="title e33">Background</div>
         <div class="para e34">About ten years ago, a handful of developers worked on a couple thousand
            lines of XQuery code, and one person manually constructed the tests to add to
            automatic regression suites. All was well. As time went by, the code grew and
            became more complex, the number of people manually constructing tests
            increased, with additional people to manually analyze regression failures. Some
            tests are automatically generated, but such tests tend to raise analysis costs
            when something does fail. The time has come to think about new approaches and
            find ways to focus effort.
            
         </div><a name="TheCodeBaseANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e35">
            <div class="title e36">The Code Base</div>
            <div class="para e37">The code base consists of about 630 thousand lines of
               XQuery code, divided roughly evenly between an old and much modified
               schema-driven GUI
               application for database configuration and management, more recent REST endpoint
               implementations and web applications, and a collection of library modules
               (including some main modules used in triggers). In total there are a little over
               1500 XQuery module files, defining over 68 thousand functions. In addition, the
               particular XQuery implementation associated with this collection of XQuery
               modules also provides a little over 1800 built-in functions. XML schemas are
               actively used to strongly type parameters: there are over 150 schema files
               exposing over 12 thousand global element declarations, 26 thousand named simple
               type definitions, and 7 thousand named complex type definitions. The bulk of
               these schemas 
               relate to XHTML, however. Setting that aside there are over 50 schema files
               exposing over 7 thousand global element declarations, almost 18 thousand named
               simple type 
               definitions, and 3 thousand complex type definitions.
               
            </div>
            <div class="para e38">This is a live and
               active body of code, ranging in age from code first written ten years ago to
               functions still just being implemented today. A peculiar problem with this
               particular code base is the range of syntax in play: The code ranges from
               XQuery 1.0 compliant code to code using some XQuery 3.0 features or
               anticipatory XQuery extensions (similar to although not necessarily identical
               to proposed XQuery features) and some very old code still using some 2003 draft
               syntax. Relying on the XQuery engine itself to analyze such diverse code is
               helpful, because the engine already has to reconcile the syntactic differences
               internally. This peculiarity does mean that third party code analysis tools
               cannot be used.
               
            </div>
            <div class="figure e39" xml:id="fig_detailed_stats">
               <div class="title e40">Detailed statistics</div>
               <div class="informaltable e41" rules="groups">
                  <div class="thead e42">
                     <div class="tr e43">
                        <div class="th e44" colspan="3">XQuery code</div>
                     </div>
                  </div>
                  <div class="tfoot e45">
                     <div class="tr e46">
                        <div class="th e47">Total</div>
                        <div class="td e48">1559</div>
                        <div class="td e49">363497</div>
                     </div>
                  </div>
                  <div class="tr e50">
                     <div class="th e51">Group</div>
                     <div class="th e52">Files</div>
                     <div class="th e53">Lines of code</div>
                  </div>
                  <div class="tr e54">
                     <div class="th e55">Admin GUI</div>
                     <div class="td e56">740</div>
                     <div class="td e57">116714</div>
                  </div>
                  <div class="tr e58">
                     <div class="th e59">Libraries</div>
                     <div class="td e60">333</div>
                     <div class="td e61">137983</div>
                  </div>
                  <div class="tr e62">
                     <div class="th e63">REST endpoints and applications</div>
                     <div class="td e64">387</div>
                     <div class="td e65">101322</div>
                  </div>
                  <div class="tr e66">
                     <div class="th e67">Misc. other</div>
                     <div class="td e68">99</div>
                     <div class="td e69">7478</div>
                  </div>
               </div>
               <div class="informaltable e70" rules="groups">
                  <div class="thead e71">
                     <div class="tr e72">
                        <div class="th e73" colspan="3">Schema Types</div>
                     </div>
                  </div>
                  <div class="tr e74">
                     <div class="th e75">Count</div>
                     <div class="th e76">Total</div>
                     <div class="th e77">Non-XHTML Total</div>
                  </div>
                  <div class="tr e78">
                     <div class="th e79">Files</div>
                     <div class="td e80">158</div>
                     <div class="td e81">56</div>
                  </div>
                  <div class="tr e82">
                     <div class="th e83">Global element declarations</div>
                     <div class="td e84">12324</div>
                     <div class="td e85">7338</div>
                  </div>
                  <div class="tr e86">
                     <div class="th e87">Named simple type definitions</div>
                     <div class="td e88">26536</div>
                     <div class="td e89">17866</div>
                  </div>
                  <div class="tr e90">
                     <div class="th e91">Named complex type definitions</div>
                     <div class="td e92">7038</div>
                     <div class="td e93">3009</div>
                  </div>
               </div>
               <div class="informaltable e94" rules="groups">
                  <div class="thead e95">
                     <div class="tr e96">
                        <div class="th e97" colspan="2">Functions</div>
                     </div>
                  </div>
                  <div class="tr e98">
                     <div class="th e99">Group</div>
                     <div class="th e100">Number of Functions</div>
                  </div>
                  <div class="tr e101">
                     <div class="th e102">Built-in functions (C++)</div>
                     <div class="td e103">1849</div>
                  </div>
                  <div class="tr e104">
                     <div class="th e105">XQuery module functions</div>
                     <div class="td e106">68191</div>
                  </div>
               </div>
            </div>
         </div><a name="Zipf'sLawandTFIDFScoringANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e107">
            <div class="title e108">Zipf's Law and TF-IDF Scoring</div>
            <div class="para e109">Zipf's law is an empirical observation 
               <div class="citation e110" linkend="zipf"></div> that
               in a natural language corpus, the distribution of word frequencies (number of
               occurrences, that is) varies in
               inverse proportion to the rank of the word in frequency order. 
               Mathematically, 
               <div class="code e111">Frequency(R) = Frequency(1)/Rk</div> where
               
               <div class="code e112">Frequency(R)</div> is the frequency of the word of rank
               
               <div class="code e113">R</div> and 
               <div class="code e114">k</div> is some constant.
               If you graph the distribution on log-log axes, you get a straight line.
               Such distributions are very common across various fields and
               applications. This paper will consider sequence types used in function
               parameters and return types as forming one vocabulary, and the names of
               functions themselves forming another, and look at the frequency distribution of
               these terms in the corpus of XQuery modules.
               
            </div>
            <div class="para e115">TF-IDF scoring has become a standard technique for computing relevance
               of documents to full-text queries since it was introduced in 1972
               
               <div class="citation e116" linkend="jones"></div>. TF stands for "term frequency" and is a count of
               how often a particular term occurs in a particular document. In the context
               of full-text search a term is typically a single word, but other terms for
               phrases or wildcards are possible. IDF stands for "inverse document
               frequency" and is the number of documents a term occurs in, as a fraction of
               the total number of documents in the corpus. The "inverse" part of IDF means
               that this number is divided, so that higher document frequencies lead to
               smaller scores.
               
            </div>
            <div class="para e117">When TF-IDF scores are used to compute relevance to a query, the term
               and document frequencies of each query term are combined together.
               The technique is based on a particular probabilistic model of documents,
               but the intuition behind it is simple enough: more occurrences of a query
               term makes a document more relevant, and occurrences of query terms that only
               occur in a few documents makes a document more relevant.
               
            </div>
            <div class="para e118">Various modifications and extensions of the
               technique are currently ubiquitous in modern search engines. It has also been put
               to related purposes, such as computing document similarities and
               clustering.  In these applications there may not be a query per se, but the
               set of terms is taken from the documents themselves. 
               
            </div>
            <div class="para e119">Here, I will attempt to use TF-IDF scores of function calls and types as
               a way of selecting "interesting" functions and types on which to focus QA attention.
               In this model, the XQuery modules play the role of documents, function calls or types
               play the role of terms, and the terms are taken from the documents
               themselves, as one would see in a clustering or similarity application.
               
            </div>
            <div class="para e120">First, we will look at the actual distributions of types and functions,
               to see if computing scores makes sense at all. Where it makes sense to do so, 
               we will look at computed scores qualitatively and quantitatively to try to see 
               whether the high scoring items are indeed interesting targets for testing focus.
               
            </div>
         </div>
      </div><a name="DistributionofSequenceTypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e121">
         <div class="title e122">Distribution of Sequence Types</div>
         <div class="para e123">XQuery 
            <div class="citation e124" linkend="xq30"></div> functions may have declared
            sequence types for their parameters and their return values. XQuery sequence
            types may be either simple type names 
            <div class="citation e125" linkend="xsd11dt"></div> or node
            tests of some kind. It is 
            possible to define sequence types that name a complex type without naming a
            specific element. XQuery
            3.0 
            <div class="citation e126" linkend="xqfo30"></div> also allows for functions tests.
            XQuery sequence
            types also have cardinality indicators, with '?' meaning a sequence of 0 or 1
            instances of the base type, '*' meaning any
            number, '+' meaning 1 or more, and no indicator meaning exactly 1. When no
            explicit sequence type declaration is given, the sequence type is the most
            generic, matching anything: 
            <div class="code e127">item()*</div>.
            
         </div>
         <div class="figure e128" xml:id="fig_ex_function">
            <div class="programlisting e129" xml:space="preserve">
               declare function my:example($x, $y as xs:string?) as element(my:result)
               
            </div>
            <div class="caption e130">
               <div class="para e131">The declaration of an example function. The parameter 
                  <div class="code e132">$x</div>
                  has the (default) sequence type 
                  <div class="code e133">item()*</div>, 
                  <div class="code e134">$y</div> has the
                  sequence type 
                  <div class="code e135">xs:string?</div>, and the returned value has the sequence
                  type 
                  <div class="code e136">element(my:result)</div>.
               </div>
            </div>
         </div>
         <div class="para e137">In this code base and the underlying XQuery engine associated with it,
            the built-in functions return 196 distinct declared sequence types while the
            XQuery modules use 629 distinct declared sequence types. In this particular
            XQuery implementation, it is not possible to declare different named element
            sequence types for parameters or return types of built-in functions.
            That is, a built-in function may be declared as returning
            
            <div class="code e138">element()</div>
            but not 
            <div class="code e139">element(my:result)</div>. 
            If we consolidate all the 
            <div class="code e140">element</div> sequence
            types for module functions, there are only 103 distinct declared sequence types.
            
         </div>
         <div class="para e141">Obviously, the sequence types used in the API form but a small part of
            the total set exposed through the schemas. Only 3 named complex types are
            explicitly used, from the complete set of 3 thousand (non-XHTML) named complex
            types. Only 474 named elements are explicitly used, from the complete set of 7
            thousand. Only 49 named simple types are explicitly used by module
            functions. The overabundance of named schema components is partly because named
            types and are used implicitly in the schema-driven configuration and
            administration UI, and partly a matter of stylistic preference for global
            element declarations and for declaring functions using generic element tests
            (e.g. 
            <div class="code e142">element()</div>) rather than specific complex types
            (
            <div class="code e143">element(*,my:example)</div>). Regardless, it doesn't look like it would
            be helpful to pay special attention to types or elements that are not
            specifically referenced in function signatures.
            
         </div>
         <div class="figure e144" xml:id="fig_rt_dist">
            <div class="title e145">Sequence type distribution (return values)</div>
            <div class="mediaobject e146">
               <div class="imageobject e147">
                  <div class="metaBox e148"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e271').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e271" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e148'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="mediaobject e149">
               <div class="imageobject e150">
                  <div class="metaBox e151"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e275').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e275" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e151'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e152">
               <div class="para e153">The frequency distribution of return value sequence types
                  shown 
                  on a double log scale. The horizontal axis is the rank and the vertical axis is
                  frequency. The top graph shows the distribution for built-in
                  functions; the bottom graph shows the distribution for module functions.
               </div>
            </div>
         </div>
         <div class="para e154">The return type frequency distribution curves in 
            
            <div class="xref e155" linkend="fig_rt_dist"></div> do show that these return types mostly follow a
            power law distribution, although for built-in functions there is
            very substantial drop-off at ends, possibly as a consequence of the
            relatively small vocabulary size.
            
         </div>
         <div class="para e156">The distribution of function parameter sequence types looks very
            similar to that of function return value sequence types, including the
            drop-offs at the extremes for built-in functions, as shown in 
            <div class="xref e157" linkend="fig_arg_dist"></div>
         </div>
         <div class="figure e158" xml:id="fig_arg_dist">
            <div class="title e159">Sequence type distribution (parameters)</div>
            <div class="mediaobject e160">
               <div class="imageobject e161">
                  <div class="metaBox e162"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e292').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e292" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e162'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="mediaobject e163">
               <div class="imageobject e164">
                  <div class="metaBox e165"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e296').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e296" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e165'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-004.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e166">
               <div class="para e167">The frequency distribution of parameter sequence types
                  shown 
                  on a double log scale.  The horizontal axis is the rank and the vertical axis is
                  frequency.  The top graph shows the distribution for built-in
                  functions; the bottom graph shows the distribution for module functions.
               </div>
            </div>
         </div>
         <div class="para e168">The top five return value and parameter sequence types share some
            overlap between built-ins and module functions, although there are some
            interesting differences. The atomic types 
            <div class="code e169">map:map</div> and
            
            <div class="code e170">cts:query</div> are special built-in types, the former anticipating
            XQuery maps, and the latter in support of full-text queries. Given the
            importance of full-text queries to this implementation, the strong showing
            of 
            <div class="code e171">cts:query</div> is unsurprising. The strong showing of
            
            <div class="code e172">map:map</div> demonstrates the utility of this feature. In both
            cases the distribution does suggest that these are important types and
            should be the focus of some QA effort.
            
         </div>
         <div class="para e173">
            In this
            code base it appears that developers use strong types on parameters more
            often than on 
            function return values (as indicated by the higher prevalence of
            
            <div class="code e174">item()*</div> for function return values but not for parameters).
            Simple types dominate the distribution for parameter types but less so for
            return types. The high frequency of 
            <div class="code e175">empty-sequence()</div> in return
            types is a consequence of the fact that the implementation supports
            functions that update the data store, so many functions are called for
            effect rather than for the return value.
            
         </div>
         <div class="table e176" cellpadding="0" pgwide="1">
            <div class="caption e177">
               <div class="para e178">Top 5 sequence types in various categories.</div>
            </div>
            <div class="tr e179">
               <div class="th e180" colspan="2">Return types (modules)</div>
            </div>
            <div class="tr e181">
               <div class="th e182" align="left">Overall</div>
               <div class="td e183">
                  <div class="code e184">item()*, empty-sequence(), xs:string, node(), element(configuration)</div>
               </div>
            </div>
            <div class="tr e185">
               <div class="th e186" align="left">Simple types</div>
               <div class="td e187">
                  <div class="code e188">xs:string, xs:boolean, xs:string*, xs:string?, xs:unsignedLong</div>
               </div>
            </div>
            <div class="tr e189">
               <div class="th e190" align="left">Other</div>
               <div class="td e191">
                  <div class="code e192">item()*, empty-sequence(), node(), element(configuration), node()*</div>
               </div>
            </div>
            <div class="tr e193">
               <div class="th e194" align="left">Simple types (ignoring cardinality)</div>
               <div class="td e195">
                  <div class="code e196">xs:string, xs:unsignedLong, xs:boolean, cts:query, map:map</div>
               </div>
            </div>
            <div class="tr e197">
               <div class="th e198" colspan="6">Return types (built-ins)</div>
            </div>
            <div class="tr e199">
               <div class="th e200" align="left">Overall</div>
               <div class="td e201">
                  <div class="code e202">item()*, empty-sequence(),
                     xs:string, xs:string*, cts:query
                  </div>
               </div>
            </div>
            <div class="tr e203">
               <div class="th e204" align="left">Simple types</div>
               <div class="td e205">
                  <div class="code e206">xs:string, xs:string*, cts:query, xs:boolean, xs:unsignedLong</div>
               </div>
            </div>
            <div class="tr e207">
               <div class="th e208" align="left">Other</div>
               <div class="td e209">
                  <div class="code e210">item()*, empty-sequence(), element()*, element(), node()*</div>
               </div>
            </div>
            <div class="tr e211">
               <div class="th e212" align="left">Simple types (ignoring cardinality)</div>
               <div class="td e213">
                  <div class="code e214">xs:string, xs:unsignedLong, xs:integer, cts:query, xs:boolean</div>
               </div>
            </div>
            <div class="tr e215">
               <div class="th e216" colspan="6">Parameters (modules)</div>
            </div>
            <div class="tr e217">
               <div class="th e218" align="left">Overall</div>
               <div class="td e219">
                  <div class="code e220">xs:string, xs:unsignedLong, map:map, item()*, xs:string?</div>
               </div>
            </div>
            <div class="tr e221">
               <div class="th e222" align="left">Simple types</div>
               <div class="td e223">
                  <div class="code e224">xs:string, xs:unsignedLong, map:map, xs:string?, xs:boolean</div>
               </div>
            </div>
            <div class="tr e225">
               <div class="th e226" align="left">Other</div>
               <div class="td e227">
                  <div class="code e228">item()*, node(), element(configuration), node()?, element()</div>
               </div>
            </div>
            <div class="tr e229">
               <div class="th e230" colspan="6">Parameters (built-ins)</div>
            </div>
            <div class="tr e231">
               <div class="th e232" align="left">Overall</div>
               <div class="td e233">
                  <div class="code e234">xs:string, xs:string*, xs:QName*, xs:string?, xs:anyAtomicType?</div>
               </div>
            </div>
            <div class="tr e235">
               <div class="th e236" align="left">Simple types</div>
               <div class="td e237">
                  <div class="code e238">xs:string, xs:string*, xs:QName*, xs:string?, xs:anyAtomicType</div>
               </div>
            </div>
            <div class="tr e239">
               <div class="th e240" align="left">Other</div>
               <div class="td e241">
                  <div class="code e242">item()*, node(), node()?, node()*, item()</div>
               </div>
            </div>
         </div><a name="TypeScoresANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e243">
            <div class="title e244">Type Scores</div>
            <div class="para e245"> Given that the distribution of types follows a classic
               Zipf distribution, it is not unreasonable to apply the probabilistic
               document model on which TF-IDF scoring is based.
               
            </div>
            <div class="para e246">The score of a particular term 
               <div class="code e247">t</div> that occurs at least
               once in the corpus of 
               <div class="code e248">N</div> documents is given by the following
               equation, where 
               <div class="code e249">log</div> is the natural logarithm,
               
               <div class="code e250">TF(t)</div> is the number of occurrences of 
               <div class="code e251">t</div>, and
               
               <div class="code e252">DF(t)</div> is the number of documents in which 
               <div class="code e253">t</div>
               occurs.
            </div>
            <div class="equation e254">
               <div class="mathphrase e255">
                  score(t) = log(1+TF(t)) / log(DF(t)/N)
                  
               </div>
            </div>
            <div class="para e256">The sequence types with the highest scores are almost all
               distinctly named elements, typically those used as important API
               elements. On the other hand, it must be said that there doesn't seem to
               be any qualitative difference between distinctly named elements with high
               scores and those with much lower scores. Various kinds of 
               <div class="code e257">options</div>
               elements are scattered throughout the range of scores, for
               example. 
               <div class="code e258">element(xproc:xslt)</div> has a much higher score than
               
               <div class="code e259">element(xproc:xquery)</div> but again, it is hard to see a difference in
               the QA needs of these two sequence types. What are we to make of the fact that
               
               <div class="code e260">xs:long</div> has a much lower score than 
               <div class="code e261">xs:integer</div>? Not
               much, I think. Perhaps the vocabulary of sequence types is too small to be
               useful.
               
            </div>
            <div class="figure e262" xml:id="fig_type_scores">
               <div class="title e263">Sequence Type Scores</div>
               <div class="programlisting e264" xml:space="preserve">
                  39.10 element(configuration)
                  33.70 element(opt:options)
                  31.55 element(forest:forest-status)*
                  30.14 element(flexrep:configuration)
                  28.85 element(plugin:plugin-model)?
                  28.66 element(opt:constraint)
                  28.18 element(rsrc:resources)
                  27.74 element(alert:config)
                  27.26 lnk:uri
                  27.09 element(sec:external-security)
                  ...
                  14.10 xs:integer
                  14.04 xs:float
                  ...
                  12.45 element(xproc:xslt)
                  12.30 xs:integer*
                  12.12 xs:double
                  ...
                  8.33 xs:date
                  7.86 xs:long
                  ...
                  7.35 element(xproc:string-replace)
                  7.35 element(xproc:xquery)
                  ...
                  4.79 cts:element-attribute-value-query
                  4.79 element(project)*
                  4.64 xs:long*
                  4.41 cts:word-query
                  4.36 function(*)+
                  4.35 text()
                  4.23 element(test)*
                  4.07 map:map*
                  4.03 function()
                  4.00 cts:element-value-query
                  
               </div>
               <div class="caption e265">
                  <div class="para e266">The scores for the top 10, bottom 10, and some selected sequence
                     types in between are shown, rounded to 2 decimal places.
                  </div>
               </div>
            </div>
         </div><a name="TechniquesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e267">
            <div class="title e268">Techniques</div>
            <div class="para e269">Type frequencies for built-in functions were computed using
               some introspection APIs: a function to enumerate all the defined
               functions, and accessor functions for the return type, the arity of the
               function, and the parameter types. Function accessors defined by Holstege
               
               <div class="citation e270" linkend="mhsc"></div> and function introspection functions defined
               in XQuery 3.0 
               <div class="citation e271" linkend="xqfo30"></div> do not quite do the job. The
               accessors defined by Holstege only give the atomic type names, not the
               full sequence types, while the XQuery 3.0 functions only give access to
               the function name and its arity. I used three additional
               built-in extension functions, one to enumerate the set of functions, and
               two to give the sequence types as string values.
               Maps kept running totals of the usage of each sequence type.
               
            </div>
            <div class="para e272">Computing type frequencies for module functions requires a little
               more. There are two approaches: (1) use an evaluation function that
               imports a given module and uses the same approach as for built-ins, but
               only considering functions in the proper namespace, (2) dump out the
               module parse tree in a structured form and analyze it for the necessary
               information. In this case, I used the second approach, using a built-in
               extension function that dumped out the parse tree. The format of this
               dump was not, alas, XML, so fishing information out of the text relied
               heavily on the XQuery 3.0 function 
               <div class="code e273">analyze-string</div>.
               
            </div>
            <div class="para e274">Doing everything in XQuery was convenient. Doing so meant using
               non-standard features such as maps and access to filesystem information.
               The filesystem access gave me the equivalent of a recursive
               
               <div class="code e275">find</div>. It was handy, but not
               strictly necessary: one could instead use shell scripts to gather up the
               set of module names to process them, and then pass that to the analysis
               module. Strictly speaking, maps are not necessary either, but they made
               it much easier to write the analysis modules.
            </div>
         </div>
      </div><a name="DistributionofFunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e276">
         <div class="title e277">Distribution of Functions</div>
         <div class="para e278">Function call distributions show the same characteristic Zipf
            distribution as types (see 
            <div class="xref e279" linkend="fig_fn_dist"></div>, although with a
            bit of a drop-off at the upper end of the curve. The majority of the top
            10 functions are XQuery standard built-in functions, although map-related
            functions occur at rank 8 and 9. The top 10 most frequently called
            functions are:
            
            <div class="code e280">string</div>, 
            <div class="code e281">concat</div>, 
            <div class="code e282">empty</div>,
            
            <div class="code e283">exists</div>, 
            <div class="code e284">xs:QName</div>, 
            <div class="code e285">error</div>,
            
            <div class="code e286">data</div>, 
            <div class="code e287">map:put</div>, 
            <div class="code e288">map:get</div>,
            and 
            <div class="code e289">not</div>.
            
         </div>
         <div class="figure e290" xml:id="fig_fn_dist">
            <div class="title e291">Function call distribution</div>
            <div class="mediaobject e292">
               <div class="imageobject e293">
                  <div class="metaBox e294"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e544').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e544" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e294'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-005.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e295">
               <div class="para e296">The frequency distribution of function calls
                  shown on a double log scale.  The horizontal axis is the rank and the vertical axis
                  is
                  frequency.
               </div>
            </div>
         </div>
         <div class="para e297">Quite a few functions are not used within the code base at
            all. A total of 497 built-in functions are unused, although only 16
            module functions are unused. Given that there is a much larger number of
            declared module functions, the disproportionate nature of this result 
            demands comment. It turns out that the unused built-in functions include a
            number of accessor functions for special types (defined for API
            completeness), some specialized functions that just happen not to be used
            in the applications in this code base (geospatial functions, for
            example), and the 
            constructor functions for some built-in types including some relatively
            uncommon types such as 
            <div class="code e298">xs:NOTATION</div>. Figure 
            
            <div class="xref e299" linkend="fig_unused_builtins"></div> gives a rough break down.
            
         </div>
         <div class="figure e300" xml:id="fig_unused_builtins">
            <div class="table e301">
               <div class="caption e302">
                  <div class="para e303">Characterization of the built-in functions unused in any
                     module in the code base.
                  </div>
               </div>
               <div class="tr e304">
                  <div class="th e305">Group</div>
                  <div class="th e306">Percent</div>
               </div>
               <div class="tr e307">
                  <div class="th e308" align="left">Accessors and constructors for special built-in types</div>
                  <div class="td e309">30.6</div>
               </div>
               <div class="tr e310">
                  <div class="th e311" align="left">System management and operations</div>
                  <div class="td e312">16.3</div>
               </div>
               <div class="tr e313">
                  <div class="th e314" align="left">Advanced specialized functions</div>
                  <div class="td e315">14.7</div>
               </div>
               <div class="tr e316">
                  <div class="th e317" align="left">Assorted standard functions</div>
                  <div class="td e318">13.8</div>
               </div>
               <div class="tr e319">
                  <div class="th e320" align="left">Mathematical functions</div>
                  <div class="td e321">9.5</div>
               </div>
               <div class="tr e322">
                  <div class="th e323" align="left">Assorted standard XQuery functions</div>
                  <div class="td e324">6.4</div>
               </div>
               <div class="tr e325">
                  <div class="th e326" align="left">Debugging/profiling</div>
                  <div class="td e327">5.4</div>
               </div>
               <div class="tr e328">
                  <div class="th e329" align="left">In active development</div>
                  <div class="td e330">2.4</div>
               </div>
            </div>
         </div>
         <div class="para e331">The fact that certain specialized functions are not called 
            anywhere in the code base is not a problem, per se, but the fact that 
            out of an assortment of special built-in types of a particular class 
            (geospatial, for example) only a couple are not represented at all
            may warrant further investigation. It may be a sign of missing 
            functionality in higher level APIs.
         </div>
         <div class="para e332">The situation with the unused module functions is better: all but
            one of the 
            unused functions have to do with features under active development or
            testing/debugging code. The remaining unused function, however, looks
            like it does represent a genuine oversight.
         </div><a name="FunctionScoresANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e333">
            <div class="title e334">Function Scores</div>
            <div class="para e335"> Again, since the function call distribution follows a classic
               Zipf distribution, it is not unreasonable to apply the probabilistic
               document model on which TF-IDF scoring is based.
               
            </div>
            <div class="figure e336" xml:id="fig_function_scores">
               <div class="title e337">Function Scores</div>
               <div class="programlisting e338" xml:space="preserve">
                  43.02 agui:navItem
                  42.49 admin:database-set-value
                  41.43 agui:navItemClosed
                  41.35 admin:gr-config
                  40.60 admin:database-get-value
                  39.75 agui:reindex-done
                  39.48 admin:db-config
                  38.99 admin:appserver-set-value
                  38.48 admin:appserver-get-value
                  38.04 aws:add-param
                  ...
                  7.35 agui:buildHTTPServer2
                  7.35 converters:set-response-content-type
                  7.35 utils:distinct-values
                  7.35 conf-server:create-server
                  7.35 pipeline:xquery
                  7.35 agui:get-action
                  7.35 entity:call-calais
                  7.35 search-ast:do-parse
                  7.35 compile:build-zip
                  7.35 forest:get-default-rep
                  
               </div>
               <div class="caption e339">
                  <div class="para e340">The scores for top 10 and bottom 10 functions are
                     shown, rounded to 2 decimal places. Function namespaces have been abbreviated
                     to prefixes.
                  </div>
               </div>
            </div>
            <div class="para e341">A look at the functions with the highest scores was encouraging:
               the number one 
               function, called 
               <div class="code e342">navItem</div>, is in a notorious part of the code
               that has been subject to much revision and bug fixes. The function with
               the third highest score was its companion function
               
               <div class="code e343">navItemClosed</div>. Other functions in the top ten were
               service functions used within administrative API. These service
               functions are called from many places, but only from within that one
               module. However, that one module is very large. Document size
               normalization is a common modification to TF-IDF scoring. Perhaps a similar
               normalization here would be useful.
               Most of the top 50 functions are other service functions for
               other modules that have similar calling patterns. Are these good
               functions to focus extra testing effort on?  Perhaps. Directed testing of
               such functions is likely to expose important bugs, but
               probably normal API testing would have accomplished the same thing.
               The fact that only one or two modules uses these functions does increase
               the risk that fewer developers are calling them and therefore they are more
               likely to be making (possibly unwarranted) assumptions about how they
               will be used.
               
            </div>
            <div class="para e344">At the other end of the
               scale, with very low scores, are widely used functions with names like
               
               <div class="code e345">buildHTTPServer2</div> (widely used throughout the Admin UI) and
               
               <div class="code e346">do-parse</div> (a key function for the search APIs) and rarely
               used functions such as 
               <div class="code e347">call-calais</div> and
               
               <div class="code e348">create-server</div>. Are these good functions to avoid expending
               extra testing effort on? Perhaps. Certainly the very widely used functions
               would have been exercised many times in many different contexts through normal
               API testing. The rare functions have demonstrably few interactions with the
               rest of the code, so presumably the risk of not expending a lot of effort on
               testing them is low.
               
            </div>
            <div class="para e349">Quantifying the usefulness of this approach is difficult. Getting a
               concrete measure for the bugginess of a particular function is hard
               as bug reports are linked only weakly to particular files, much less
               individual functions within those files. Here we will take the number of
               source control revisions within the scope of a particular function as a
               measure of how likely it is to need fixing. This is obviously an
               imperfect measure, as source changes may reflect new functionality, or
               trivial formatting changes. It is also a manually intensive measure to
               obtain. The following graph shows statistics for functions that were used
               more than once in the corpus that were defined in
               the same module as the top scoring function.
               It is an admittedly very small data set.
               
            </div>
            <div class="figure e350" xml:id="fig_delta_f_score_dist">
               <div class="title e351">Revisions as a function of score</div>
               <div class="mediaobject e352">
                  <div class="imageobject e353">
                     <div class="metaBox e354"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e652').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e652" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e354'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-006.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e355">
                  <div class="para e356">The number of revisions made to functions as a function
                     of score.
                  </div>
               </div>
            </div>
            <div class="para e357">The correlation of score to the numbers of revisions is positive,
               although not strong (
               <div class="code e358">R
                  <div class="superscript e359">2</div>=0.3048
               </div>).
               There are other associations we might expect to have stronger or more
               meaningful correlations. For example, one might think that the number
               of revisions would correlate with the age of a function, so that older
               functions would tend to have more revisions associated with them. This
               seems to be the case. For this little data set, the number of revisions
               does have a stronger relationship to age, using a power
               function  (
               <div class="code e360">R
                  <div class="superscript e361">2</div>=0.6777
               </div>),
               as shown in 
               <div class="xref e362" linkend="fig_delta_f_age_power_dist"></div>.
               
            </div>
            <div class="figure e363" xml:id="fig_delta_f_age_power_dist">
               <div class="title e364">Revisions as a function of age</div>
               <div class="mediaobject e365">
                  <div class="imageobject e366">
                     <div class="metaBox e367"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e678').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e678" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e367'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-007.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e368">
                  <div class="para e369">The number of revisions made to functions as a function of
                     the age (minimum revision number) of the function. A power curve gives 
                     the best fit.
                  </div>
               </div>
            </div>
            <div class="para e370">Similar relationships held for functions in the hand-generated data
               for a couple of other modules as well, with scores showing a weak direct
               relationship with 
               <div class="code e371">R
                  <div class="superscript e372">2</div>
               </div> values
               around 
               <div class="code e373">0.3</div> and age showing an inverse relationship with 
               
               <div class="code e374">R
                  <div class="superscript e375">2</div>
               </div> values about double that.
               
            </div>
            <div class="para e376">
               However, neither of these correlations holds up well on a larger data set
               across modules, as you can see in 
               
               <div class="xref e377" linkend="fig_large_delta_f_score_dist"></div> and 
               
               <div class="xref e378" linkend="fig_large_delta_f_age_dist"></div>. The best fit line in
               both cases has 
               <div class="code e379">R
                  <div class="superscript e380">2</div>
               </div> of essentially
               zero, virtually indistinguishable from the mean value line. The data 
               behind these numbers is much messier than the hand-generated set, as
               the automated detection of function boundaries is much more error-prone
               and tends to pull in large comment blocks and non-function declarations.
               Nevertheless, it is implausible to suggest that such factors
               overwhelm what would otherwise be an interesting correlation. A manual
               check of the statistics for a particular module from the automated
               data set showed only small deviations from the statistics from the
               manual procedure.
               
            </div>
            <div class="figure e381" xml:id="fig_large_delta_f_score_dist">
               <div class="title e382">Revisions as a function of score</div>
               <div class="mediaobject e383">
                  <div class="imageobject e384">
                     <div class="metaBox e385"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e715').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e715" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e385'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-008.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e386">
                     <div class="para e387">The number of revisions made to functions as a function of
                        the score, using a larger but messier data set.
                     </div>
                  </div>
               </div>
            </div>
            <div class="figure e388" xml:id="fig_large_delta_f_age_dist">
               <div class="title e389">Revisions as a function of age</div>
               <div class="mediaobject e390">
                  <div class="imageobject e391">
                     <div class="metaBox e392"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e725').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e725" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e392'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Holstege01/Holstege01-009.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e393">
                     <div class="para e394">The number of revisions made to functions as a function of
                        the age (minimum revision number), using a larger but messier data set.
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="TechniquesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e395">
            <div class="title e396">Techniques</div>
            <div class="para e397">Some of the same introspective functions for computing
               the distribution of sequence types in modules were used to compute the
               distribution of function calls in modules. The key technique
               involved analyzing the structured dump of the module parse tree for
               function calls, using maps to store running totals, and using
               filesystem access functions to recursively find and process all modules
               in the code base.
               
            </div>
            <div class="para e398">Computing the revisions within a particular function involved
               using the source control system's ability to produce the source code
               annotated with revision numbers. The resulting output was
               chopped up into individual functions manually, with a little help from
               Emacs keyboard macros. A shell script counted up the number of distinct
               revision numbers as well as the minimum revision number for the
               function using standard Unix tools such as 
               <div class="code e399">awk</div>,
               
               <div class="code e400">sort</div>, 
               <div class="code e401">uniq</div>, 
               <div class="code e402">head</div>, and
               
               <div class="code e403">wc</div>.
               
            </div>
            <div class="para e404">The larger data set began with a file containing the annotated
               source files concatenated together. The XQuery function 
               
               <div class="code e405">tokenize</div> was used to chop up the file first into subfiles
               (by looking for the 
               <div class="code e406">xquery version</div> declaration) and then into 
               functions (by looking for 
               <div class="code e407">declare function</div>, and finally into 
               individual lines of code, from which the revision number was obtained.
               Maps were used to collect minimum, maximum, and
               counts of revision number.
            </div>
         </div>
      </div><a name="SummaryandConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e408">
         <div class="title e409">Summary and Conclusions</div>
         <div class="para e410">XQuery introspection can be used to provide a fresh slant on a code
            base, even a fairly large one. An analysis of unused schema components
            (elements and types) proved largely uninteresting because stylistic
            considerations for schema writing dominated actual usage requirements in the
            APIs. The fact that certain extension types (in particular maps) were so common
            suggests that there is a real need for providing such types as part of standard
            XQuery. TF-IDF scores of sequence types did not produce any interesting
            information.
            
         </div>
         <div class="para e411">The analysis of function usage points in a different direction.
            A look at unused functions can highlight some interesting problems, but the
            most frequently used functions are mainly basic standard XQuery functions.
            Looking at a combination of frequency of use and rarity across modules using
            TF-IDF scoring can pinpoint some interesting functions that warrant more QA
            attention. This is a qualitative judgement. Attempts to quantify the
            correlation of score to quality failed, using the number of revisions applied
            to the function as a proxy for quality. Relationships within one module at a
            time hold up better, but are still weak.
            
         </div>
         <div class="para e412">One common
            modification to TF-IDF scoring is to normalize the TF values by the size of the
            document. Since the high scoring functions included many that were only found in
            a very large module, perhaps applying a similar normalization here would lead
            to better results.
            
         </div>
         <div class="para e413">To perform introspection of XQuery from within XQuery, a number of
            extension functions are useful:
            
         </div>
         <div class="variablelist e414">
            <div class="varlistentry e415">
               <div class="term e416">Function accessors</div>
               <div class="listitem e417">
                  <div class="itemizedlist e418">
                     <div class="listitem e419">
                        <div class="para e420">list available functions as function items</div>
                     </div>
                     <div class="listitem e421">
                        <div class="para e422">return name of function item (XQuery 3.0 function-name)</div>
                     </div>
                     <div class="listitem e423">
                        <div class="para e424">return arity of function item (XQuery 3.0 function-arity)</div>
                     </div>
                     <div class="listitem e425">
                        <div class="para e426">return sequence type of return value of a function item</div>
                     </div>
                     <div class="listitem e427">
                        <div class="para e428">return sequence type of specific parameter of a function item</div>
                     </div>
                     <div class="listitem e429">
                        <div class="para e430">get type name from sequence type</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="varlistentry e431">
               <div class="term e432">Type accessors</div>
               <div class="listitem e433">
                  <div class="itemizedlist e434">
                     <div class="listitem e435">
                        <div class="para e436">list global element declarations for a particular schema</div>
                     </div>
                     <div class="listitem e437">
                        <div class="para e438">list named simple type definitions for a particular schema</div>
                     </div>
                     <div class="listitem e439">
                        <div class="para e440">list named complex type definitions for a particular schema</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="varlistentry e441">
               <div class="term e442">Parse tree accessors</div>
               <div class="listitem e443">
                  <div class="itemizedlist e444">
                     <div class="listitem e445">
                        <div class="para e446">return the parse tree for a particular module in structured form, preferably XQuery</div>
                     </div>
                  </div>
                  <div class="para e447">OR:</div>
                  <div class="itemizedlist e448">
                     <div class="listitem e449">
                        <div class="para e450">list the functions declared in a particular module as function items</div>
                     </div>
                     <div class="listitem e451">
                        <div class="para e452">list the functions called in a particular module</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="varlistentry e453">
               <div class="term e454">File system accessors</div>
               <div class="listitem e455">
                  <div class="itemizedlist e456">
                     <div class="listitem e457">
                        <div class="para e458">list contents of a particular directory</div>
                     </div>
                     <div class="listitem e459">
                        <div class="para e460">determine whether a particular file is a directory</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="varlistentry e461">
               <div class="term e462">Maps</div>
               <div class="listitem e463">
                  <div class="para e464">Provide a convenient means of keeping running totals
                     keyed to function names, for example
                  </div>
               </div>
            </div>
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e465">
         <div class="title e466">References</div>
         <div class="bibliomixed e467" xml:id="mhsc" xreflabel="Holstege">
            Holstege, Mary. 
            
            <div class="emphasis e468">Type Introspection in XQuery.</div>
            Presented at Balisage: The Markup Conference 2012, Montréal, Canada, August
            7 - 10, 2012. In Proceedings of Balisage: The Markup Conference 2012. Balisage
            Series on Markup Technologies, vol. 8 (2012). 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e469" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Holstege01/BalisageVol8-Holstege01.html" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol8/html/Holstege01/BalisageVol8-Holstege01.html</div>. doi:
            <div class="biblioid doi e470">10.4242/BalisageVol8.Holstege01</div>.
         </div>
         <div class="bibliomixed e471" xml:id="jones" xreflabel="Jones72">
            Jones, Karen.
            
            <div class="emphasis e472">A statistical interpretation of term specificity and its
               application in retrieval
            </div>. Journal of Documentation 28 (1): 11–21. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e473" xlink:actuate="onRequest" xlink:href="http://www.soi.city.ac.uk/~ser/idfpapers/ksj_orig.pdf" xlink:show="new" xlink:type="simple">http://www.soi.city.ac.uk/~ser/idfpapers/ksj_orig.pdf</div>. doi:
            <div class="biblioid doi e474">10.1108/eb026526</div>.
            1972.
            
         </div>
         <div class="bibliomixed e475" xml:id="xqfo30" xreflabel="F&amp;O30">
            W3C: Michael Kay, editor.
            
            <div class="emphasis e476">XPath and XQuery Functions and Operators 3.0</div>
            Candidate Recommendation. W3C, January 2013.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e477" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-functions-30/</div>
            
         </div>
         <div class="bibliomixed e478" xml:id="xsd11dt" xreflabel="XSD11.2">
            W3C: David Peterson, Shudi (Sandy) Gao 高殊镝, Ashok Malhotra,
            C.M. Sperberg-McQueen, and Henry S. Thompson, editors.  
            
            <div class="emphasis e479">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes.</div>
            W3C. April 2012.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e480" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-2/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema11-2/</div>
            	
         </div>
         <div class="bibliomixed e481" xml:id="xq30" xreflabel="XQuery30">
            W3C: Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, editors.
            
            <div class="emphasis e482">XQuery 3.0: An XML Query Language</div>
            Candidate Recommendation. W3C, January 2013.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e483" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery-30/</div>
            
         </div>
         <div class="bibliomixed e484" xml:id="zipf" xreflabel="Zipf49">
            Zipf, George Kingsley.
            
            <div class="emphasis e485">Human Behaviour and the Principles of Least Effort.</div> 
            Addison-Wesley, 1949.
            
         </div>
      </div>
   </div>
</div>