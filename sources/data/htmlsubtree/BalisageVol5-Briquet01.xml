<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#AVirtualizationBasedRetrievalandUpdateAPIforXMLEncodedCorporaANCHOR" name="AVirtualizationBasedRetrievalandUpdateAPIforXMLEncodedCorporaTOC">A Virtualization-Based Retrieval and Update API for XML-Encoded Corpora</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ProblemdomainANCHOR" name="ProblemdomainTOC">Problem domain</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ImportanceoftheproblemANCHOR" name="ImportanceoftheproblemTOC">Importance of the problem</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ScopeoftheproblemANCHOR" name="ScopeoftheproblemTOC">Scope of the problem</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OurApproachANCHOR" name="OurApproachTOC">Our Approach</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TypicalUseCasesANCHOR" name="TypicalUseCasesTOC">Typical Use Cases</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Usecase1:avoidanceoffalsepositivesforregularexpressionmatchingANCHOR" name="Usecase1:avoidanceoffalsepositivesforregularexpressionmatchingTOC">Use case 1: avoidance of false positives for regular expression matching</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Usecase2:avoidanceoffalsepositivesforkeywordsearchANCHOR" name="Usecase2:avoidanceoffalsepositivesforkeywordsearchTOC">Use case 2: avoidance of false positives for keyword search</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Usecase3:avoidanceoffalsenegativesforregularexpressionmatchingANCHOR" name="Usecase3:avoidanceoffalsenegativesforregularexpressionmatchingTOC">Use case 3: avoidance of false negatives for regular expression matching</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Usecase4:avoidanceoffalsenegativesforkeywordsearchANCHOR" name="Usecase4:avoidanceoffalsenegativesforkeywordsearchTOC">Use case 4: avoidance of false negatives for keyword search</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#HypotheticalUseCasesANCHOR" name="HypotheticalUseCasesTOC">Hypothetical Use Cases</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DocumentRetrievalandUpdateAPIANCHOR" name="DocumentRetrievalandUpdateAPITOC">Document Retrieval and Update API</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InmemoryDocumentDataStructureANCHOR" name="InmemoryDocumentDataStructureTOC">In-memory Document Data Structure</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AddressingAPIANCHOR" name="AddressingAPITOC">Addressing API</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TextRetrievalAPIANCHOR" name="TextRetrievalAPITOC">Text Retrieval API</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TextUpdateAPIANCHOR" name="TextUpdateAPITOC">Text Update API</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TextVirtualizationAPIANCHOR" name="TextVirtualizationAPITOC">Text Virtualization API</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#VirtualTextRetrievalAPIANCHOR" name="VirtualTextRetrievalAPITOC">Virtual Text Retrieval API</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#VirtualTextUpdateAPIandVirtualTagSplicingAPIANCHOR" name="VirtualTextUpdateAPIandVirtualTagSplicingAPITOC">Virtual Text Update API and Virtual Tag Splicing API</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RelatedWorkANCHOR" name="RelatedWorkTOC">Related Work</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#QueryandUpdateFrameworksANCHOR" name="QueryandUpdateFrameworksTOC">Query and Update Frameworks</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#InformationExtractionANCHOR" name="InformationExtractionTOC">Information Extraction</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RegularFragmentationsandXMLFragmentsANCHOR" name="RegularFragmentationsandXMLFragmentsTOC">Regular Fragmentations and XML Fragments</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ReadingContextsANCHOR" name="ReadingContextsTOC">Reading Contexts</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XQueryANCHOR" name="XQueryTOC">XQuery</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OtherrelevantworksANCHOR" name="OtherrelevantworksTOC">Other relevant works</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SemanticTaggingofXMLEncodedCorporaANCHOR" name="SemanticTaggingofXMLEncodedCorporaTOC">Semantic Tagging of XML-Encoded Corpora</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConcludingRemarksANCHOR" name="ConcludingRemarksTOC">Concluding Remarks</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgmentsANCHOR" name="AcknowledgmentsTOC">Acknowledgments</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">and finally</div>
         <div class="singletermTERMS">ATILF</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
         <div class="singletermTERMS">API</div>
         <div class="singletermTERMS">algorithm</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
         <div class="singletermTERMS">Briquet</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">CNRS</div>
         <div class="singletermTERMS">Cyril Briquet</div>
         <div class="singletermTERMS">Communications of the ACM</div>
         <div class="singletermTERMS">contextes de lecture</div>
         <div class="singletermTERMS">cyril.briquet@acm.org</div>
         <div class="singletermTERMS">Cyril</div>
         <div class="singletermTERMS">corpus</div>
         <div class="singletermTERMS">context</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Document Object Model (DOM)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Evaluation Strategies for XQuery Full-Text</div>
         <div class="singletermTERMS">etienne.petitjean@atilf.fr</div>
         <div class="singletermTERMS">Etienne</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">FTIgnore</div>
         <div class="singletermTERMS">Französisches Etymologisches Wörterbuch</div>
         <div class="singletermTERMS">f.</div>
         <div class="singletermTERMS">fleur</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">General Architecture for Text Engineering</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">Information Extraction</div>
         <div class="singletermTERMS">IBM Trainable Information Extraction Systems</div>
         <div class="singletermTERMS">in-place</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">merge</div>
         <div class="singletermTERMS">McMaster University</div>
         <div class="singletermTERMS">Markup Overlap: A Review and a Horse</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">nice text again</div>
         <div class="singletermTERMS">Nancy-Université</div>
         <div class="singletermTERMS">natural linguistic reasoning</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">Oxford English Dictionary</div>
         <div class="singletermTERMS">Once upon a time,</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">pascale.renders@ulg.ac.be</div>
         <div class="singletermTERMS">Pascale</div>
         <div class="singletermTERMS">PhD student</div>
         <div class="singletermTERMS">Petitjean</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Regular Fragmentations</div>
         <div class="singletermTERMS">Reading Contexts</div>
         <div class="singletermTERMS">Research Engineer</div>
         <div class="singletermTERMS">retrieval</div>
         <div class="singletermTERMS">Renders</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">some nice text</div>
         <div class="singletermTERMS">String Projection</div>
         <div class="singletermTERMS">string</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">Tango library</div>
         <div class="singletermTERMS">TraSoGal</div>
         <div class="singletermTERMS">Treating Complex Textual Content as Markup</div>
         <div class="singletermTERMS">Trésor de la Langue Française informatisé</div>
         <div class="singletermTERMS">text</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">University of Liège</div>
         <div class="singletermTERMS">update</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">virtual</div>
         <div class="singletermTERMS">virtualization</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XPath</div>
         <div class="singletermTERMS">XQuery</div>
         <div class="singletermTERMS">XQuery and XPath Full Text 1.0</div>
         <div class="singletermTERMS">XQuery Full-Text for the impatient</div>
         <div class="singletermTERMS">XQuery Update Facility 1.0</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="AVirtualizationBasedRetrievalandUpdateAPIforXMLEncodedCorporaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">A Virtualization-Based Retrieval and Update API for XML-Encoded Corpora
         <div class="popupBox e2">
            <div class="popupLabel" onmouseover="$('#d1e5').show('1000');" onmouseout="$('#d1e5').hide('1000');">[ footnote ]</div>
            <div id="d1e5" style="display: none;">
               <div class="footnote" xml:id="CNRSDETCOLGrant">
                  <div class="para e3">The research reported in this paper was supported by grant ANR-06-CORP-007-03.</div>
               </div>
            </div>
         </div>
      </div>
      <div class="info e4">
         <div class="confgroup e5">
            <div class="conftitle e6">Balisage: The Markup Conference 2010</div>
            <div class="confdates e7">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e8">
            <div class="para e9">Providing support for flexible automated tagging of text-oriented XML documents (i.e.
               text with intersparsed markup) is a challenging issue.
               This requires support for tag-aware full text search (i.e. the capability to skip
               some tags or make invisible whole sections of the document), match points, and transparent
               updates.
               An API addressing this issue is described.
               Based on the virtualization of selected sections of the XML document, the API produces
               a tag-aware representation, backed by the document, that is transparently searchable
               (using keyword search or regular expressions) and updatable, offering support for
               
               <div class="emphasis e10">natural linguistic reasoning</div>.
            </div>
         </div>
         <div class="author e11">
            <div class="personname e12">
               <div class="firstname e13">Cyril</div>
               <div class="surname e14">Briquet</div>
            </div>
            <div class="personblurb e15">
               <div class="para e16">Dr. Cyril Briquet received the PhD degree in Computing Science from the University
                  of Liège in 2008.
                  His research interests include distributed systems and algorithmics, with a particular
                  focus on efficiency and scalability.
                  In 2007, he introduced the first fully Peer-to-Peer Grid middleware (i.e. both P2P
                  computations as well as BitTorrent-based P2P data transfers).
                  During his stay at 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e17" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> in Nancy in 2008-2009
                  <div class="popupBox e18">
                     <div class="popupLabel" onmouseover="$('#d1e33').show('1000');" onmouseout="$('#d1e33').hide('1000');">[ footnote ]</div>
                     <div id="d1e33" style="display: none;">
                        <div class="footnote" xml:id="CyrilBriquetAtCNRS">
                           <div class="para e19">The majority of the research reported here was conducted while Cyril Briquet was at
                              
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e20" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> in 2008-2009.
                           </div>
                        </div>
                     </div>
                  </div>, he implemented algorithms for the automatic detection of fields of information in
                  XML-encoded corpora.
                  Now at McMaster University as a Postdoctoral Fellow in Digital Humanities and High
                  Performance Computing, he is working to scale out the analytics back-end of the Voyeur
                  Tools text analytics software.
               </div>
            </div>
            <div class="affiliation e21">
               <div class="jobtitle e22">Postdoctoral Fellow in Digital Humanities and High Performance Computing</div>
               <div class="orgname e23">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e24" xlink:actuate="onRequest" xlink:href="http://www.mcmaster.ca/" xlink:show="new" xlink:type="simple">McMaster University</div>
               </div>
            </div>
            <div class="affiliation e25">
               <div class="jobtitle e26">Research Engineer</div>
               <div class="orgname e27">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e28" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple">ATILF</div> (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e29" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> &amp; 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e30" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple">Nancy-Université</div>)
               </div>
            </div>
            <div class="email e31">cyril.briquet@acm.org</div>
         </div>
         <div class="author e32">
            <div class="personname e33">
               <div class="firstname e34">Pascale</div>
               <div class="surname e35">Renders</div>
            </div>
            <div class="personblurb e36">
               <div class="para e37">Pascale Renders holds one diploma in Romance languages as well as one diploma in Classics.
                  She is currently completing her PhD studies at University of Liège, in partnership
                  with the 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e38" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple">ATILF</div> lab (Nancy). Her doctoral research topic is the digitization of the Französisches
                  Etymologisches Wörterbuch (FEW), which is the reference etymological and historical
                  dictionary in the Gallo-Roman area. Besides Lexicography and Natural Language Processing,
                  her research interests also encompass Diachronic Linguistics of Romance languages,
                  specifically the key era where Latin evolved into French.
               </div>
            </div>
            <div class="affiliation e39">
               <div class="jobtitle e40">PhD student</div>
               <div class="orgname e41">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e42" xlink:actuate="onRequest" xlink:href="http://www.ulg.ac.be/" xlink:show="new" xlink:type="simple">University of Liège</div>
               </div>
            </div>
            <div class="affiliation e43">
               <div class="jobtitle e44">PhD student</div>
               <div class="orgname e45">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e46" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple">ATILF</div> (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e47" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> &amp; 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e48" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple">Nancy-Université</div>)
               </div>
            </div>
            <div class="email e49">pascale.renders@ulg.ac.be</div>
         </div>
         <div class="author e50">
            <div class="personname e51">
               <div class="firstname e52">Etienne</div>
               <div class="surname e53">Petitjean</div>
            </div>
            <div class="personblurb e54">
               <div class="para e55">Etienne Petitjean is a Research Engineer at the 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e56" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple">ATILF</div> laboratory (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e57" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> &amp; 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e58" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple">Nancy-Université</div>).
               </div>
            </div>
            <div class="affiliation e59">
               <div class="jobtitle e60">Research Engineer</div>
               <div class="orgname e61">
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e62" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/" xlink:show="new" xlink:type="simple">ATILF</div> (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e63" xlink:actuate="onRequest" xlink:href="http://www.cnrs.fr/" xlink:show="new" xlink:type="simple">CNRS</div> &amp; 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e64" xlink:actuate="onRequest" xlink:href="http://www.nancy-universite.fr/" xlink:show="new" xlink:type="simple">Nancy-Université</div>)
               </div>
            </div>
            <div class="email e65">etienne.petitjean@atilf.fr</div>
         </div>
         <div class="legalnotice e66">
            <div class="para e67">Copyright © 2010 Cyril Briquet, Pascale Renders, Etienne Petitjean. All rights reserved.
               Used by permission.
            </div>
         </div>
         <div class="keywordset e68" role="author">
            <div class="keyword e69">XML</div>
            <div class="keyword e70">corpus</div>
            <div class="keyword e71">API</div>
            <div class="keyword e72">text</div>
            <div class="keyword e73">retrieval</div>
            <div class="keyword e74">update</div>
            <div class="keyword e75">algorithm</div>
            <div class="keyword e76">virtual</div>
            <div class="keyword e77">virtualization</div>
            <div class="keyword e78">string</div>
            <div class="keyword e79">context</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e80">
         <div class="title e81">Introduction</div><a name="ProblemdomainANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e82">
            <div class="title e83">Problem domain</div>
            <div class="para e84">XML-encoding a textual corpus is typically achieved through manual tagging,
               i.e. by human operators using a text editor or specialized annotation software,
               or through the application of algorithms that complete the tagging on the basis of
               a known schema.
               
            </div>
            <div class="para e85">The problem we address in this paper is to provide an algorithmic substrate,
               made accessible through an Application Programming Interface (API),
               to achieve automated tagging [
               <div class="xref e86" linkend="ren07a"></div>, 
               <div class="xref e87" linkend="ren09a"></div>, 
               <div class="xref e88" linkend="bri09a"></div>]
               of the digitized version of one of the most complex paper dictionaries.
               This dictionary is the Französisches Etymologisches Wörterbuch (FEW) [
               <div class="xref e89" linkend="projectfew"></div>, 
               <div class="xref e90" linkend="war22a"></div>].
               The FEW is the historical and etymological dictionary of the languages of the gallo-roman
               area
               (i.e. French, Franco-Provençal, Occitan and Gascon in all of their diatopic variations),
               written over the course of more than eighty years.
            </div>
            <div class="para e91">Each article of the FEW describes all derived words (i.e. lexemes) of a given root
               word (i.e. etymon) [
               <div class="xref e92" linkend="buc96a"></div>],
               instead of (as happens in most etymological dictionaries) describing the root word
               of a given derived word.
               Of course, several fields of information are offered for each article, such as the
               etymon and the language in which this etymon originates, the signature of the article,
               footnotes.
               The structure of the article is emphasized through hierarchical numbering and labeling
               of groups of paragraphs and cross-references to these.
               Several fields of information are offered for each lexeme,
               including but not limited to geolinguistic labels, bibliographical references to attestations
               of the lexeme
               and the definition of the lexeme.
               All of these types of information are well-delineated, thus good candidates for tagging.
               In a nutshell, each article of the FEW is a highly structured text that can be described
               through a model [
               <div class="xref e93" linkend="buc96a"></div>] and thus algorithmically processed.
            </div>
            <div class="para e94">Besides these semantic types of information that are expected to be identified through
               automated tagging, formatting markup (such as paragraph, bold, italic, exponent, break
               tags such as end of line or end of column,...) is also available in each article following
               the digitization process (the formatting markup is added either manually or through
               OCR). This enables an on-screen visualization of articles that is faithful to the
               paper version of the dictionary. The availability of paragraph tags is important not
               only to properly format the articles, but to make accessible a first level of structuring
               of the article. Likewise, the availability of break tags enables to correctly tag
               some types of semantic types of information. Many hyphens indeed do not indicate that
               a long word is being cut at the end of the line where they are found, but instead
               convey semantic information (e.g. as part of affixes). And there is no straightforward
               way to automatically disambiguate the syntactic uses from the semantic uses of hyphens
               at the end of lines in the FEW dictionary.
            </div>
            <div class="para e95">To put the FEW dictionary [
               <div class="xref e96" linkend="projectfew"></div>, 
               <div class="xref e97" linkend="war22a"></div>] in perspective, here is a quick comparison with another complex dictionary, the
               well-known Oxford English Dictionary (OED) [
               <div class="xref e98" linkend="oed"></div>]. Whereas the markup used to encode OED articles is proprietary SGML [
               <div class="xref e99" linkend="oed"></div>], the markup used to encode FEW articles is standard XML complying with an XML Schema
               [
               <div class="xref e100" linkend="bri09a"></div>]. The FEW markup is referred to as FFML (FEW Font-style Markup Language) for files
               input to the automated tagging process. It is referred to as FSML (FEW Semantic Markup
               Language) for files output by the automated tagging process. FSML is comprised of
               mostly a superset of FFML, that is augmented with semantic markup. There currently
               exists no in-depth comparison of the scopes of the OED and FEW markups, and it is
               clear that there are differences if only because FEW entries are etymons instead of,
               typically, lexemes. Nonetheless, in very general terms, both markups are intended
               to encode dictionary articles and it is not surprising to see many common features.
               The FEW dictionary, though, is considered to be one of the most complex dictionaries
               in the world [
               <div class="xref e101" linkend="buc96a"></div>], notably because of the ever-present implicitness of many types of information.
               The Table here below provides a shallow quantitative comparison of both dictionaries.
               
               
               <div class="table e102">
                  <div class="caption e103">
                     <div class="para e104">Shallow quantitative comparison of OED [
                        <div class="xref e105" linkend="oedwiki"></div>] and FEW [
                        <div class="xref e106" linkend="buc96a"></div>]
                     </div>
                  </div>
                  <div class="thead e107">
                     <div class="tr e108">
                        <div class="th e109">Feature</div>
                        <div class="th e110">OED</div>
                        <div class="th e111">FEW</div>
                        <div class="th e112">Comment</div>
                     </div>
                  </div>
                  <div class="tbody e113">
                     <div class="tr e114" align="right">
                        <div class="td e115" align="center">Pages</div>
                        <div class="td e116">21730</div>
                        <div class="td e117">16865</div>
                     </div>
                     <div class="tr e118" align="right">
                        <div class="td e119" align="center">Volumes</div>
                        <div class="td e120">20</div>
                        <div class="td e121">25</div>
                     </div>
                     <div class="tr e122" align="right">
                        <div class="td e123" align="center">Entries</div>
                        <div class="td e124">300000</div>
                        <div class="td e125">20000</div>
                        <div class="td e126">FEW entries are etymons, not lexemes, thus fewer</div>
                     </div>
                     <div class="tr e127" align="right">
                        <div class="td e128" align="center">Lexemes</div>
                        <div class="td e129">600000</div>
                        <div class="td e130">900000 (*)</div>
                        <div class="td e131">(*) back-of-the-envelop estimate</div>
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="ImportanceoftheproblemANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e132">
            <div class="title e133">Importance of the problem</div>
            <div class="para e134">Semantically tagging the articles of the FEW is a multi-year linguistics research
               project [
               <div class="xref e135" linkend="ren07a"></div>] that is tremendously important to the historical linguistics community.
               Merely digitizing the FEW, without further processing would only enable full text
               search.
               Tagging the various fields of information would also enable so-called lateral search
               over the whole dictionary.
               Semantic tagging would disambiguate and resolve the implicitness of most of the fields
               of information contained in the dictionary.
            </div>
            <div class="para e136">Given the extreme linguistic complexity of the FEW, only highly-trained human experts
               could theoretically do the job. But there are not enough of them
               to process the twenty thousand articles of the FEW
               and this would be a tedious, error-prone job anyway.
               It was thus decided to use algorithmic automation to tag the fields of information
               of the FEW [
               <div class="xref e137" linkend="ren09a"></div>].
               Even though the articles of the FEW (implicitly) constitute a highly specialized textual
               corpus,
               we believe that the problem can be sufficiently abstracted
               so that our proposed approach is also relevant to other endeavors,
               particularly the processing of text-oriented XML documents (i.e. text with intersparsed
               markup) such as text corpora.
            </div>
         </div><a name="ScopeoftheproblemANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e138">
            <div class="title e139">Scope of the problem</div>
            <div class="para e140">The input of our project is comprised of XML documents,
               each of which represents an article of the FEW and includes basic layout tags (article,
               paragraphs, bold, italic,...)
               that were added by human encoders and/or by OCR software.
               Obviously, all textual contents are eventually enclosed in paragraph and article tags.
               Nonetheless, the element hierarchy is often not the prime model of choice when accessing
               the FEW.
               Identifying fields of information in the FEW indeed focuses on linear regions of text
               where elements can be nested in many ways.
               Thus a very important property is that an FEW article should be considered as a text-oriented
               XML document,
               i.e. a text with intersparsed tags rather than a tree of elements with some textual
               contents found in the leaves.
            </div>
            <div class="para e141">The objective of our project is ultimately to add semantic markup around fields of
               information within a text-oriented XML document
               (fields of information of interest are listed in the Problem domain section here above).
               This requires to first identify these fields of information, then accordingly update
               the XML document.
            </div>
            <div class="para e142">Each article of the FEW dictionary typically features multiple occurrences of 25 or
               so types of information [
               <div class="xref e143" linkend="buc96a"></div>], each of which is detected and tagged by a specific tagging algorithm (see Figure
               1 here below).
            </div>
            <div class="figure e144" xml:id="few-tagging-sequence" xreflabel="few-tagging-sequence">
               <div class="mediaobject e145">
                  <div class="imageobject e146">
                     <div class="metaBox e147"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e274').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e274" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e147'
                              </span><span class="metaAttribute">fileref='../../../vol5/graphics/Briquet01/Briquet01-001.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='360'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e148">
                     <div class="para e149">FEW tagging sequence</div>
                  </div>
               </div>
            </div>
            <div class="para e150">As the dependency graph of tagging algorithms is acyclic, it is possible - though
               not straightforward - to determine the sequence in which they should be applied (the
               so-called retroconversion sequence, e.g. tag definitions, then geolinguistic labels,
               then bibliographic labels,...) [
               <div class="xref e151" linkend="ren09a"></div>, 
               <div class="xref e152" linkend="bri09a"></div>]. An important property is that the order in which tags are inserted into the XML
               document representing an FEW article is known. Therefore, when designing a tagging
               algorithm, one knows which types of information have previously been tagged - and
               thus which ones might interfere with information retrieval and updates.
            </div>
            <div class="para e153">Identification of fields of information in an FEW article by a tagging algorithm is
               typically based on several retrieval primitives:
               keyword search, matching of regular expressions (regexp), 
               as well as matching of contextual tag sequences.
               Most algorithms rely on a combination of several of these primitives,
               often in non-straightforward ways that involve secondary lookups in the contexts surrounding
               initial matches.
               The linguistic challenge resides in handcrafting combinations of retrieval primitives
               that lead to accurate identification of types of informations.
               As the design and implementation of tagging algorithms is beyond the scope of this
               paper,
               we now concentrate on issues that arise from the stated information retrieval requirements.
            </div>
            <div class="para e154">Among the issues that make information retrieval in the FEW quite challenging, two
               classes of issues stand out:
               
               
               <div class="itemizedlist e155">
                  <div class="listitem e156">
                     <div class="para e157">Firstly, some keyword search may be relevant only in some selected contexts, i.e.
                        would lead to false positives if applied to irrelevant contexts.
                     </div>
                  </div>
                  <div class="listitem e158">
                     <div class="para e159">Secondly, the presence of some tags, e.g. such as exponent or end of line tags,
                        within words or groups of words may prevent the matching of keywords and regular expressions,
                        thus leading to false negatives.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e160">Update of (the XML document representing) an FEW article by a tagging algorithm typically
               includes the insertion, removal, displacement or update of text,
               as well as the insertion, displacement or removal of tags.
               The possible presence of many types of tags within updated text regions
               increases the complexity of update operations,
               as these should preserve the well-formedness of the XML document.
               Moreover, the tagging of a text region might be decided based on the identification
               of patterns in a neighboring text region. Support for match points is thus very important,
               as the locus of where to insert a tag is most often decided based on offsets in the
               textual representation of the XML document (these offsets being sometimes far away
               from the XML node whose contents were matched in the identification phase), not relative
               to tags of the XML document.
            </div>
            <div class="para e161">In addition to these retrieval and update challenges, one  must keep in mind that
               the semantic tagging of FEW is a research project [
               <div class="xref e162" linkend="ren07a"></div>] whose object of study is a very complex dictionary. Concretely, another layer added
               to these challenges resides in the lack of knowledge of where tags can appear in the
               text. Even though it might be known that a given tag type is always included in a
               specific parent element, this provides no information on where the given tag appears
               among the textual content of its englobing element. This is the kind of challenge
               one must face when searching both markup and textual contents at the same time [
               <div class="xref e163" linkend="stl01a"></div>].
            </div>
            <div class="para e164">This leads to the following additional requirement: A mechanism must be provided to
               flexibly and easily configure
               the contexts where retrieval and update operations will be applied. This is a challenging
               requirement, as we desire to provide users of the mechanism
               a way to think of the dictionary and express themselves in a familiar environment:
               text without tags.
            </div>
            <div class="para e165">What is required is thus a mechanism that enables flexible, dynamic, tag-aware retrieval
               and update in a text-oriented XML document,
               in order to support 
               <div class="emphasis e166">natural linguistic reasoning</div>.
               Based on our review of the state of the art presented in the section of this paper
               discussing related works (see below),
               we are not aware of any existing XML technology that addresses all of these requirements,
               specifically the provision of a familiar environment to users of the mechanism.
            </div>
         </div><a name="OurApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e167">
            <div class="title e168">Our Approach</div>
            <div class="para e169">The key principle of our approach to the tag-aware retrieval and update problem
               is the virtualization of the text-oriented XML document.
               We propose a mechanism to allow one to easily construct,
               through an Application Programming Interface (API),
               a representation of selected sections of the XML document
               from which types of tags leading to ambiguities - as well as their contents, if required
               -
               have been removed.
               In practice, sections of the XML document are virtualized
               into multiple virtual strings, separated by so-called visible tags,
               according to dynamically-defined tag visibility rules.
               A definition of the virtual string data structure is provided in a further section;
               intuitively, a virtual string is the concatenation of adjacent text chunks,
               except those within elements that are configured to not be added to the virtual string.
            </div>
            <div class="para e170">For example, this section of XML document: 
               <div class="code e171">&lt;X&gt;&lt;Y&gt;some nice text&lt;/Y&gt; &lt;Z&gt;and text to be made invisible&lt;/Z&gt; and &lt;W&gt;finally&lt;/W&gt; &lt;Y&gt;nice
                  text again&lt;/Y&gt;&lt;/X&gt;
               </div> is virtualized into these three virtual strings: (1) 
               <div class="code e172">some nice text</div>, (2) 
               <div class="code e173">and finally</div> and (3) 
               <div class="code e174">nice text again</div>, if using the following configuration: 
               <div class="code e175">&lt;X&gt;</div> and 
               <div class="code e176">&lt;Y&gt;</div> tags should stop the virtualization mechanism, 
               <div class="code e177">&lt;Z&gt;</div> tags as well as their contents (if considered as elements) should be made invisible,
               and 
               <div class="code e178">&lt;W&gt;</div> tags (not their contents, if considered as elements) should be made invisible.
            </div>
            <div class="para e179">How do API users benefit from the virtualization? With ambiguity abstracted away through
               an appropriate configuration of what tags should be made invisible (with or without
               their contents, if considered as elements), the representation of the XML document
               as a sequence of virtual strings
               is more easily searchable, simplifying retrieval (keyword search, regexp matching,
               contextual tag sequence matching).
            </div>
            <div class="para e180">Importantly, each virtual string is backed by the underlying XML document. Updates
               to a virtual string
               are thus transparently propagated to the document.
               Therefore, this constructed representation is also easily updatable.
            </div>
            <div class="para e181">Our approach shares the intent of the Regular Fragmentations
               mechanism proposed by Simon St.Laurent [
               <div class="xref e182" linkend="stl01a"></div>, 
               <div class="xref e183" linkend="rfg"></div>]
               and of the XML Fragments mechanism introduced by Carmel et al. [
               <div class="xref e184" linkend="car03a"></div>],
               to the extent that we wish to devise a transparent mechanism that enables
               mixed-information (text/markup) retrieval in a text-oriented XML document.
               Our proposed virtualization mechanism
               may be viewed as a dynamic, more flexible and - importantly - updatable version
               of the Reading Context mechanism introduced by Xavier Tannier [
               <div class="xref e185" linkend="tan05a"></div>].
               Mixed-information (text/markup) retrieval is provided by our proposed virtualization
               mechanism
               through the backing of virtual strings by the underlying XML document.
               The tag visibility model on which our proposed virtualization mechanism relies
               is an extended version (with slightly different semantics) of the tag visibility model
               initially introduced by Lini et al. [
               <div class="xref e186" linkend="lin01a"></div>]
               and used by Tannier [
               <div class="xref e187" linkend="tan05a"></div>].
               Our proposed API is comprised of exactly the operations that are required to digitize
               the FEW dictionary [
               <div class="xref e188" linkend="projectfew"></div>, 
               <div class="xref e189" linkend="war22a"></div>], no more, no less.
               Nonetheless, we believe it is sufficiently general and extensible
               to be useful to other text-oriented XML document processing needs.
            </div>
            <div class="para e190">The rest of this paper is structured as follows.
               Typical use cases are first described in order to ground our work into real, concrete,
               albeit basic examples.
               Hypothetical use cases are also provided, in order to situate our work within a broader
               context.
               The proposed XML document retrieval and update API is then introduced.
               Related works are subsequently reviewed and their relationships with our work are
               explored.
               Finally, concluding remarks put the proposed API into perspective.
            </div>
         </div>
      </div><a name="TypicalUseCasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e191">
         <div class="title e192">Typical Use Cases</div>
         <div class="para e193">Four typical use cases gathered here below illustrate how our proposed API can help
            design tagging algorithms [
            <div class="xref e194" linkend="ren09a"></div>]. The use cases highlight two major classes of information retrieval issues encountered
            in semantically tagging the FEW dictionary (false positives, false negatives).
         </div><a name="Usecase1:avoidanceoffalsepositivesforregularexpressionmatchingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e195">
            <div class="title e196">Use case 1: avoidance of false positives for regular expression matching</div>
            <div class="para e197">In this use case, the objective is to tag dates. To search for dates, a regular expression
               is applied to the full text version of the XML document.
            </div>
            <div class="para e198">Input (FEW 2, 982b, completus):
               
               <div class="programlisting e199" xml:space="preserve">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;com-&lt;lb merge="no"/&gt;
                  plètement&lt;/i&gt; &lt;def&gt;„action de mettre au complet“&lt;/def&gt; (seit 1750,&lt;lb merge="no"/&gt;
                  text in &lt;biblio&gt;Fér 1787&lt;/biblio&gt;).
               </div>
               
            </div>
            <div class="para e200">Expected output, one 
               <div class="code e201">&lt;date&gt;</div> tag inserted:
               
               <div class="programlisting e202" xml:space="preserve">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;com-&lt;lb merge="no"/&gt;
                  plètement&lt;/i&gt; &lt;def&gt;„action de mettre au complet“&lt;/def&gt; (seit &lt;date&gt;1750&lt;/date&gt;,&lt;lb
                  merge="no"/&gt;
                  text in &lt;biblio&gt;Fér 1787&lt;/biblio&gt;).
               </div>
               
            </div>
            <div class="para e203">If all tags were removed prior to full text search, the string 
               <div class="quote e204">1787</div> would be matched as a licit date. This would lead to a false positive as it has already
               been tagged as part of a bibliographical reference.
            </div>
            <div class="para e205">Instead, 
               <div class="code e206">&lt;biblio&gt;</div> tags (as well as others, in practice) should be made totally invisible, their contents
               included, prior to full text search. The full text to which the search operation is
               applied thus becomes:
               
               <div class="programlisting e207" xml:space="preserve">Nfr. complètement „action de mettre au complet“ (seit 1750, text in ).</div>
               
            </div>
         </div><a name="Usecase2:avoidanceoffalsepositivesforkeywordsearchANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e208">
            <div class="title e209">Use case 2: avoidance of false positives for keyword search</div>
            <div class="para e210">In this use case, the objective is to tag grammatical categories. To search for grammatical
               categories, a keyword search is applied to the full text version of the XML document.
               In practice, the string 
               <div class="quote e211">f.</div> belongs to the keyword list of grammatical categories (it's an abbreviation standing
               for: feminine substantive).
            </div>
            <div class="para e212">Input (FEW 2, 983a, completus):
               
               <div class="programlisting e213" xml:space="preserve">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;fleur incomplète&lt;/i&gt; &lt;def&gt;„f. dé-&lt;lb merge="discard-hyphen"/&gt;
                  pourvue de quelque organe, notamment de corolle“&lt;/def&gt;&lt;lb merge="no"/&gt;
                  (seit &lt;biblio&gt;Trév 1771&lt;/biblio&gt;).
               </div>
               
            </div>
            <div class="para e214">Expected output, no tag inserted:
               
               <div class="programlisting e215" xml:space="preserve">&lt;geoling&gt;Nfr.&lt;/geoling&gt; &lt;i&gt;fleur incomplète&lt;/i&gt; &lt;def&gt;„f. dé-&lt;lb merge="discard-hyphen"/&gt;
                  pourvue de quelque organe, notamment de corolle“&lt;/def&gt;&lt;lb merge="no"/&gt;
                  (seit &lt;biblio&gt;Trév 1771&lt;/biblio&gt;).
               </div>
               
            </div>
            <div class="para e216">If all tags were removed prior to full text search, the string 
               <div class="quote e217">f.</div> would be matched as a licit grammatical category. This would lead to a false positive
               as 
               <div class="quote e218">f.</div> is here an abbreviation of the word 
               <div class="quote e219">fleur</div> (i.e. flower) and has already been tagged as part of the definition of a lexeme.
            </div>
            <div class="para e220">Instead, 
               <div class="code e221">&lt;def&gt;</div> tags (as well as others, in practice and for the relevant algorithm) should be made
               totally invisible, their contents included, prior to full text search. The full text
               to which the search operation is applied thus becomes:
               
               <div class="programlisting e222" xml:space="preserve">Nfr. fleur incomplète (seit Trév 1771).</div>
               
            </div>
         </div><a name="Usecase3:avoidanceoffalsenegativesforregularexpressionmatchingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e223">
            <div class="title e224">Use case 3: avoidance of false negatives for regular expression matching</div>
            <div class="para e225">In this use case, the objective is to tag dates. To search for dates, a regular expression
               is applied to the full text version of the XML document.
               The 
               <div class="quote e226">–</div> character is not a hyphen, but an  en dash. This character, as well as the spacing around it, is accounted for in the
               regular expression used to match dates.
            </div>
            <div class="para e227">Input (FEW 25, 882a, augmentator):
               
               <div class="programlisting e228" xml:space="preserve">&lt;p&gt;Emprunt de &lt;geoling&gt;lttard.&lt;/geoling&gt; &lt;geoling&gt;mlt.&lt;/geoling&gt; &lt;i&gt;&lt;etymon&gt;augmentator&lt;/etymon&gt;&lt;/i&gt;
                  (4&lt;e&gt;e&lt;/e&gt;–&lt;lb merge="no"/&gt;
                  6&lt;e&gt;e&lt;/e&gt; s., &lt;biblio&gt;ThesLL&lt;/biblio&gt; ;
               </div>
               
            </div>
            <div class="para e229">Expected output, one 
               <div class="code e230">&lt;date&gt;</div> tag inserted:
               
               <div class="programlisting e231" xml:space="preserve">&lt;p&gt;Emprunt de &lt;geoling&gt;lttard.&lt;/geoling&gt; &lt;geoling&gt;mlt.&lt;/geoling&gt; &lt;i&gt;&lt;etymon&gt;augmentator&lt;/etymon&gt;&lt;/i&gt;
                  (&lt;date&gt;4&lt;e&gt;e&lt;/e&gt;–&lt;lb merge="no"/&gt;
                  6&lt;e&gt;e&lt;/e&gt; s.&lt;/date&gt;, &lt;biblio&gt;ThesLL&lt;/biblio&gt; ;
               </div>
               
            </div>
            <div class="para e232">If &lt;e&gt; and &lt;lb/&gt; tags were not skipped, the date range 
               <div class="quote e233">4e-6e s.</div> (i.e. 4th-6th century) would be split into six fragments. This would lead to a false
               negative, i.e. the date would not be matched. By virtually removing the &lt;e&gt; and &lt;lb/&gt;
               tags (as well as others, in practice), the date can be matched by a regular expression.
               The full text to which the search operation is applied thus becomes:
               
               <div class="programlisting e234" xml:space="preserve">Emprunt de lttard. mlt. augmentator (4e– 6e s., ThesLL ;</div>
               
            </div>
         </div><a name="Usecase4:avoidanceoffalsenegativesforkeywordsearchANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e235">
            <div class="title e236">Use case 4: avoidance of false negatives for keyword search</div>
            <div class="para e237">In this use case, the objective is to tag affixes (i.e. prefixes and suffixes). To
               search for affixes, a keyword search is applied to the full text version of the XML
               document.
            </div>
            <div class="para e238">Input (FEW 8, 237a, perfectus):
               
               <div class="programlisting e239" xml:space="preserve">&lt;pref id="I 2 a"&gt;a&lt;/pref&gt; mit dem suffix -&lt;i&gt;ivus&lt;/i&gt;</div>
               
            </div>
            <div class="para e240">Expected output, one 
               <div class="code e241">&lt;affix&gt;</div> tag inserted:
               
               <div class="programlisting e242" xml:space="preserve">&lt;pref id="I 2 a"&gt;a&lt;/pref&gt; mit dem suffix &lt;affix&gt;-&lt;i&gt;ivus&lt;/i&gt;&lt;/affix&gt;</div>
               
            </div>
            <div class="para e243">If &lt;i&gt; tags were not skipped, the hyphen of the suffix 
               <div class="quote e244">-ivus</div> would be separated from the rest of the word. This would lead to a false negative,
               i.e. the affix would not be matched. By virtually removing the &lt;i&gt; tags (as well as
               others, in practice), the affix keyword can be matched.
               The full text to which the search operation is applied thus becomes:
               
               <div class="programlisting e245" xml:space="preserve">a mit dem suffix -ivus</div>
               
            </div>
         </div>
      </div><a name="HypotheticalUseCasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e246">
         <div class="title e247">Hypothetical Use Cases</div>
         <div class="para e248">In a general sense, our proposed virtualization mechanism enables to construct views
            of an XML document, dynamically at any time during its processing.
            The mechanism masks selected parts of an XML document and transparently applies updates
            - through the constructed document view - to the XML document. The mechanism operates
            on a representation of the XML document that does not rely on a DOM tree. The representation
            of the XML document exhibits very lightweight storage requirements if one desires
            to process only sections of the document at a time. Therefore, our proposed virtualization
            mechanism is well-suited to process streamed data.
         </div>
         <div class="para e249">An hypothetical use case of growing importance would be the semantic analysis of web
            documents intended to feed the ever-expanding index of a web search engine. Given
            that web search is predicted to evolve towards a better understanding of what web
            documents mean [
            <div class="xref e250" linkend="sav10a"></div>], semantic analysis of a web document may well evolve to become a key problem in
            web search. The ability to easily mask selected tagged regions of a web document to
            try and derive different meanings would thus be an asset when engineering its semantic
            analysis.
         </div>
      </div><a name="DocumentRetrievalandUpdateAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e251">
         <div class="title e252">Document Retrieval and Update API</div>
         <div class="para e253">As most algorithms devised for the semantic tagging of types of information of the
            FEW dictionary operate based on different contextual assumptions, one should be able
            to flexibly and easily configure the retrieval and update operations for each algorithm.
            Why did we choose to expose this mechanism through an Application Programming Interface
            (API)?
            Firstly, tools that can apply only one transformation to an XML document, however
            powerful they are [
            <div class="xref e254" linkend="stl01a"></div>, 
            <div class="xref e255" linkend="rfg"></div>, 
            <div class="xref e256" linkend="tan05a"></div>, 
            <div class="xref e257" linkend="tan06a"></div>, 
            <div class="xref e258" linkend="tan06b"></div>], are not adapted because the semantic tagging of FEW requires each XML document
            to be processed multiple times.
            Secondly, domain-specific languages can serve their purposes well, but often lack
            in generality.
            Thirdly, embeddable domain-specific languages, like XQuery [
            <div class="xref e259" linkend="xqe"></div>] is intended to be, deserve attention but the depth of integration may (currently)
            sometimes be a limiting factor.
            Fourthly, an Application Programming Interface (API) offers great flexibility and
            by design can be easily integrated with user code.
            We have thus decided to expose our proposed virtualization mechanism through an Application
            Programming Interface (API). A Java implementation of this API was completed during
            the summer of 2009.
         </div>
         <div class="para e260">Our proposed document retrieval and update API is actually comprised of a set of six
            distinct APIs (see Figure 2 here below, based on the example illustrating the Our
            Approach section):
            
            <div class="itemizedlist e261">
               <div class="listitem e262">
                  <div class="para e263">addressing API: provides a mechanism to locate target nodes;</div>
               </div>
               <div class="listitem e264">
                  <div class="para e265">text retrieval API: no specific document-level or node-level text retrieval API is
                     provided, user code is expected to rely on standard Java facilities or user-provided
                     custom packages;
                  </div>
               </div>
               <div class="listitem e266">
                  <div class="para e267">text update API: provides a mechanism to update a single text node and insert tags
                     into a single text node;
                  </div>
               </div>
               <div class="listitem e268">
                  <div class="para e269">text virtualization API: provides a mechanism to construct a sequence of virtual strings
                     over a section of the XML document potentially spanning many nodes, from which specified
                     types of tags are virtually removed;
                  </div>
               </div>
               <div class="listitem e270">
                  <div class="para e271">virtual text retrieval API: provides a mechanism to retrieve data within a virtual
                     string, that also provides access to the underlying nodes of the XML document;
                  </div>
               </div>
               <div class="listitem e272">
                  <div class="para e273">virtual text update API and virtual tag splicing API: provides a mechanism to update
                     a virtual string and insert tag into a virtual string, and have the updates transparently
                     propagated to the underlying nodes of the XML document.
                  </div>
               </div>
            </div>
            
         </div>
         <div class="figure e274" xml:id="retrieval-update-api" xreflabel="retrieval-update-api">
            <div class="mediaobject e275">
               <div class="imageobject e276">
                  <div class="metaBox e277"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e557').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e557" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e277'
                           </span><span class="metaAttribute">fileref='../../../vol5/graphics/Briquet01/Briquet01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='620'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e278">
                  <div class="para e279">Document Retrieval and Update API</div>
               </div>
            </div>
         </div>
         <div class="para e280">Before introducing each API, the in-memory representation of XML document on which
            they operate is first described.
         </div><a name="InmemoryDocumentDataStructureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e281">
            <div class="title e282">In-memory Document Data Structure</div>
            <div class="para e283">An important design decision in XML document processing is the in-memory representation
               of its markup and content. A typical choice is the DOM tree representation [
               <div class="xref e284" linkend="dom"></div>]. However, as we are considering text-oriented XML documents only, there are at least
               two arguments against a tree representation.
               
               <div class="itemizedlist e285">
                  <div class="listitem e286">
                     <div class="para e287">Firstly, the structural information contained in the tree branches is practically
                        useless to our purposes as the element hierarchy of the FEW dictionary is not always
                        predictable (see Scope of the problem here above for the rationale). Therefore, the
                        memory footprint of the document representation can be greatly reduced by discarding
                        hierarchical relationships and storing only the list of leaves of the document.
                     </div>
                  </div>
                  <div class="listitem e288">
                     <div class="para e289">Secondly, as the generated XML documents may not be well-formed (due to e.g. unexpected
                        textual data that cannot be recognized by the tagging algorithms), a mechanism to
                        deal with the lack of well-formedness, such as e.g. milestones [
                        <div class="xref e290" linkend="der04a"></div>], is required. A tree representation has thus little benefit.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e291">We decide instead to represent an XML document as a list of nodes, with each node
               being either an XML tag or a text chunk. This in-memory representation matches the
               assumption of text-oriented XML documents. It allows straightforward access to contextual
               relationships (i.e. is-left-of, is-right-of) between nodes, without precluding to
               construct additional data structures on top of it in order to access parent/child
               relationships for specific sections of the document. In the rest of the paper, it
               will be referred to as a node list.
            </div>
            <div class="para e292">In practice, the node list can be easily constructed using a validating SAX parser
               that appends text nodes and tag nodes to the node list as they are loaded to memory.
               Tag attributes are not appended as nodes themselves, but instead are added as properties
               of tag nodes. Comments and processing instructions are currently discarded from the
               XML document (this is an implementation-specific limitation that can be removed through
               additional engineering hours).
            </div>
            <div class="para e293">The existing implementation of the API only considers UTF-8-encoded XML documents.
               Fragments of text of the XML document are normalized as they are inserted into the
               node list as text nodes. A character map enables the API user to configure all licit
               character, character entity references and numeric character references. Character
               sanity is enforced by checking all characters of the XML document against the character
               map. Character entity references and numeric character references are all resolved
               into one Unicode character each, possibly in a private use area. All spacing characters
               are converted to the space character (U+0020), then multiple spaces are compacted
               into one space only. Leading and trailing spaces within high-level structural tags
               (dictionary, article, paragraph) are removed. Break tags (e.g. end of line, end of
               column, end of page,...), despite being tags and not text, are also normalized, i.e.
               redundant break tags are removed.
            </div>
         </div><a name="AddressingAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e294">
            <div class="title e295">Addressing API</div>
            <div class="para e296">The addressing API takes one node as input, and provides a node as output.</div>
            <div class="para e297">Addressing of XML elements, tags or text chunks, in the node list is always relative
               to a target node and always returns a single node (never a set of nodes).
               No mechanism of absolute addressing of XML elements in the XML document is currently
               provided because it was not a requirement for the tagging of the FEW dictionary. An
               absolute addressing mechanism featuring XPath [
               <div class="xref e298" linkend="xpat"></div>] syntax might be supported but at the expense of a severe performance penalty, as
               the node list does not contain the hierarchical structure of a node tree (see In-memory
               Document Data Structure here above for the rationale).
            </div>
            <div class="para e299">Relative addressing of XML elements can be done in three ways: by neighbor access,
               by tag node search, by text node search.
               
               <div class="itemizedlist e300">
                  <div class="listitem e301">
                     <div class="para e302">The left and right neighbor of a target node are always immediately accessible, by
                        construction of the node list.
                     </div>
                  </div>
                  <div class="listitem e303">
                     <div class="para e304">Several tag node search operations are provided by the addressing API: search forwards/backwards
                        for the next tag node matching a given set of tags and/or tag attributes, before the
                        first occurrence of a stopper tag (if specified). It must be noted that forward search
                        and backward search are not equivalent to descendant search or ancestor search [
                        <div class="xref e305" linkend="xpat"></div>] in a tree representation. Consider the following two examples. First example: 
                        <div class="code e306">&lt;X&gt;&lt;Y&gt;some text&lt;/Y&gt;&lt;Z&gt;some text&lt;/Z&gt;&lt;/X&gt;</div>. Second example: 
                        <div class="code e307">&lt;X&gt;&lt;Y&gt;some text&lt;/Y&gt;&lt;/X&gt; &lt;Z&gt;some text&lt;/Z&gt;</div>. A forward search (in our proposed node list representation), relative to the target
                        node 
                        <div class="code e308">&lt;X&gt;</div>, for a 
                        <div class="code e309">&lt;Z&gt;</div> tag will find a match in both examples, whereas a similar descendant search (in a
                        tree representation) would not find a match in the second example.
                     </div>
                  </div>
                  <div class="listitem e310">
                     <div class="para e311">Several text node search operations are provided by the addressing API: search forwards/backwards
                        for the next text node, before the first occurrence of a stopper tag (if specified).
                        Again, forward search and backward search are not equivalent to descendant search
                        or ancestor search [
                        <div class="xref e312" linkend="xpat"></div>] in a tree representation.
                     </div>
                  </div>
               </div>
               In theory, the cost of relative addressing is bounded by the number of nodes in the
               node list. In practice, though, most addressing requests for the tagging of the FEW
               dictionary are fairly local, e.g. within a paragraph of the text encoded into the
               XML document. If the addressing API is considered for searches not exhibiting high
               locality, implementation of auxiliary data structures should be considered to guarantee
               lower bounds in the search cost. To this end, insights (though no direct reuse) could
               certainly be drawn from the skip list [
               <div class="xref e313" linkend="pug90a"></div>] data structure. The availability of such auxiliary data structures would pave the
               way for XPath addressing.
            </div>
         </div><a name="TextRetrievalAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e314">
            <div class="title e315">Text Retrieval API</div>
            <div class="para e316">Neither a dedicated node-level retrieval API (i.e. within individual nodes only) nor
               a document-level text retrieval API are provided (i.e. within all individual nodes
               of the document, considered individually), for two reasons.
            </div>
            <div class="para e317">Firstly, the text chunk of a text node is a classic Java string.
               To achieve node-level text retrieval, it is thus straightforward for user code to
               rely on standard Java facilities such as the operations on Java strings (java.lang.String
               methods), the regular expression engine (java.util.regex package), or user-supplied
               packages.
               This also enables one to plug advanced search mechanisms such as collocate search,
               or search for inflected forms (e.g. mouse/mice).
               For instance, in the context of the FEW dictionary, several semantic tagging algorithms
               depend on a keyword search seeking to match a list of keywords that may each exhibit
               several nontrivial variations.
               The decoupling of node-level text retrieval operations (as well as virtual text retrieval
               over selected sections of the document, which constitutes the core of this paper,
               see below) from other core operations thus offers great flexibility to users.
            </div>
            <div class="para e318">Secondly, document-level retrieval can be achieved by using an additional retrieval
               mechanism on top of the node list representation, such as one of those discussed in
               the Related Work section of this article.
            </div>
            <div class="para e319">Text retrieval over sections of the document (i.e. of its node list representation),
               though, is made possible using the virtual text retrieval API (see below).
            </div>
         </div><a name="TextUpdateAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e320">
            <div class="title e321">Text Update API</div>
            <div class="para e322">The text update API takes one text node and an update specification as input, and
               updates/inserts/deletes text nodes as output.
               In the existing implementation, the updates are not 
               <div class="emphasis e323" role="ital">in-place</div>, i.e. text nodes are actually substituted with an updated copy of themselves.
            </div>
            <div class="para e324">Three operations applicable to a target text chunk are provided by the node-level
               text update API:
               
               <div class="itemizedlist e325">
                  <div class="listitem e326">
                     <div class="para e327">Update (replacement) of a substring of the target text chunk with the specified string.</div>
                  </div>
                  <div class="listitem e328">
                     <div class="para e329">Tagging of a substring of target text chunk with a given tag, i.e. insertion of an
                        opening and a closing tag at specified insertion indexes.
                     </div>
                  </div>
                  <div class="listitem e330">
                     <div class="para e331">Insertion of a list of tags at specified insertion index of target text chunk. Typical
                        use case: inserting an empty element.
                     </div>
                  </div>
               </div>
               The node-level text update API is convenient but can update text or insert tags only
               between a pair of existing tags.
            </div>
         </div><a name="TextVirtualizationAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e332">
            <div class="title e333">Text Virtualization API</div>
            <div class="para e334">The text virtualization API takes one node and a virtualization specification as input,
               and provides a (possibly empty) sequence of virtual strings as output.
            </div>
            <div class="para e335">Just one operation is provided by the API: the construction of a sequence of virtual
               strings based on a specification of tag types visibility provided by the API user.
               The text virtualization API addresses the issue of virtually removing specified types
               of tag, as well as their contents (if specified), from a sequence of sections of a
               text-oriented XML document. We define a section as the sequence of nodes starting
               at a target node and extending immediately prior to (and excluding) the first tag
               node matching a specified stopper tag type (if any), or the end of the document (in
               the absence, after the target node, of any stopper tag matching the specified type).
               The construction of a sequence of virtual strings thus virtualizes a sequence of sections
               of the XML document.
            </div>
            <div class="para e336">We define a virtual string as the data structure:
               
               <div class="itemizedlist e337">
                  <div class="listitem e338">
                     <div class="para e339">based on a string resulting from the concatenation of adjacent text chunks (two text
                        chunks are considered as adjacent if no visible tag occurs between them),
                     </div>
                  </div>
                  <div class="listitem e340">
                     <div class="para e341">that is backed by the underlying text nodes of the XML document,</div>
                  </div>
                  <div class="listitem e342">
                     <div class="para e343">that includes all the information necessary for retrieval and dynamic updates (see
                        Virtual Text Retrieval API and Virtual Text Update API in the following).
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e344">The construction of a sequence of virtual strings is controlled through the specification
               of a visibility partition of all types of tags that can appear in the XML document.
               It relies on a tag visibility model that is an extended version (with slightly different
               semantics) of the tag visibility model initially introduced by Lini et al. [
               <div class="xref e345" linkend="lin01a"></div>] and used by Tannier [
               <div class="xref e346" linkend="tan05a"></div>].
            </div>
            <div class="para e347">Our tag visibility model is comprised of five classes:
               
               <div class="itemizedlist e348">
                  <div class="listitem e349">
                     <div class="para e350">skipped tags: should be virtually removed from the document section under consideration;</div>
                  </div>
                  <div class="listitem e351">
                     <div class="para e352">invisible tags: should be virtually removed, as well as all of their contents (including
                        descendant tags), from the document section under consideration;
                     </div>
                  </div>
                  <div class="listitem e353">
                     <div class="para e354">visible tags: signal the end of the document section under consideration;</div>
                  </div>
                  <div class="listitem e355">
                     <div class="para e356">terminal tags: signal the end of the document section under consideration, as well
                        as of the sequence of sections under consideration;
                        the availability of the visible tag class in addition to the terminal tag class enables
                        to construct a sequence of virtual strings using one API call only (e.g. a visible
                        tag could be &lt;/li&gt; and a terminal tag could be &lt;/ul&gt;);
                     </div>
                  </div>
                  <div class="listitem e357">
                     <div class="para e358">unexpected tags: should not be found within those areas of the document section under
                        consideration that are outside invisible tags.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e359">A visibility partition is a partition of the set of all possible tag types that is
               comprised of five sets, each of which represents a visibility class. 
               A partition is intrinsically comprehensive: all tag types must be included into exactly
               one visibility class each.
               At most four visibility classes can thus be empty.
               When defining a visibility partition, the API user has the option to specify explicitly
               only four visibility classes, with the remaining visibility class (whichever it is)
               implicitly considered as including all tag types not yet assigned to a visibility
               class.
               As will be illustrated through examples, this can be very handy in practice.
            </div>
            <div class="para e360">When invoked on a target node, the text virtualization API constructs a sequence of
               virtual strings, virtual string by virtual string. The text virtualization algorithm
               can be sketched as follows:
               
               <div class="itemizedlist e361">
                  <div class="listitem e362">
                     <div class="para e363">Each time a visible tag or terminal tag is encountered, a virtual string is produced
                        and returned to the calling code (except when the visible tag is comprised between
                        a pair of matching invisible tags, cf. below). Virtual strings keep getting produced
                        until a terminal tag (or the end of the node list) is encountered, at which point
                        the sequence of virtual strings is complete.
                     </div>
                  </div>
                  <div class="listitem e364">
                     <div class="para e365">If an unexpected tag is encountered, an exception is raised.</div>
                  </div>
                  <div class="listitem e366">
                     <div class="para e367">If a skipped tag is encountered, it is skipped, as can be expected.</div>
                  </div>
                  <div class="listitem e368">
                     <div class="para e369">When an opening invisible tag is encountered, all
                        <div class="popupBox e370">
                           <div class="popupLabel" onmouseover="$('#d1e724').show('1000');" onmouseout="$('#d1e724').hide('1000');">[ footnote ]</div>
                           <div id="d1e724" style="display: none;">
                              <div class="footnote" xml:id="visible-within-invisible">
                                 <div class="para e371">After the encounter with an invisible tag, the encounter (immediately or a few nodes
                                    further) with a terminal tag, as well as the encounter with the end of the node list,
                                    triggers a virtual string to be returned to the calling code. This is not the case
                                    when a visible tag is encountered. As invisible tags have precedence over visible
                                    tags, the latter ones are also skipped until a matching closing invisible tag is encountered.
                                 </div>
                              </div>
                           </div>
                        </div> subsequent nodes (both text nodes and tag nodes) are skipped, until a matching closing
                        invisible tag is encountered.
                     </div>
                  </div>
                  <div class="listitem e372">
                     <div class="para e373">When a text node is encountered, its text is added to the virtual string under construction.</div>
                  </div>
               </div>
               
            </div>
            <div class="para e374">As an example, let us consider the following visibility partition over the tag set
               { 
               <div class="code e375">&lt;i&gt;</div>, 
               <div class="code e376">&lt;lb&gt;</div>, 
               <div class="code e377">&lt;s&gt;</div>, 
               <div class="code e378">&lt;t&gt;</div>, 
               <div class="code e379">&lt;u&gt;</div>, 
               <div class="code e380">&lt;v&gt;</div> }:
               
               <div class="itemizedlist e381">
                  <div class="listitem e382">
                     <div class="para e383">skipped tags = { 
                        <div class="code e384">&lt;s&gt;</div>, 
                        <div class="code e385">&lt;lb&gt;</div> }
                     </div>
                  </div>
                  <div class="listitem e386">
                     <div class="para e387">invisible tags = { 
                        <div class="code e388">&lt;i&gt;</div> }
                     </div>
                  </div>
                  <div class="listitem e389">
                     <div class="para e390">visible tags = { 
                        <div class="code e391">&lt;v&gt;</div> }
                     </div>
                  </div>
                  <div class="listitem e392">
                     <div class="para e393">terminal tags = { 
                        <div class="code e394">&lt;t&gt;</div> }
                     </div>
                  </div>
                  <div class="listitem e395">
                     <div class="para e396">unexpected tags = { 
                        <div class="code e397">&lt;u&gt;</div> }
                     </div>
                  </div>
               </div>
               Let the text virtualization API be invoked on the following section of an XML document
               (the target node is the first node, i.e. the text node 
               <div class="quote e398">Once upon a time,</div>), configured with the aforementioned visibility partition:
               
               <div class="programlisting e399" xml:space="preserve">Once upon a time,&lt;i /&gt; there was a &lt;s&gt;sentence with an important&lt;/s&gt; part,&lt;lb merge="no"
                  /&gt;
                  followed by an &lt;i&gt;irrelevant part&lt;/i&gt;.&lt;v /&gt;It was followed by&lt;lb merge="no" /&gt;
                  a second sentence separated from the first by a visible tag.&lt;lb merge="no" /&gt;
                  &lt;v&gt;A word near the end of the third sen-&lt;lb merge="discard-hyphen" /&gt;
                  tence was split by a break tag.&lt;/v&gt;&lt;/t&gt;
                  
               </div>
               A sequence of three virtual strings is returned to the calling code:
               
               <div class="itemizedlist e400">
                  <div class="listitem e401">
                     <div class="para e402">
                        <div class="quote e403">Once upon a time, there was a sentence with an important part, followed by an .</div>
                     </div>
                  </div>
                  <div class="listitem e404">
                     <div class="para e405">
                        <div class="quote e406">It was followed by a second sentence separated from the first by a visible tag.</div>
                     </div>
                  </div>
                  <div class="listitem e407">
                     <div class="para e408">
                        <div class="quote e409">A word near the end of the third sentence was split by a break tag.</div>
                     </div>
                  </div>
               </div>
               Each character of these virtual strings either is backed by a text node of the underlying
               XML document, or is a virtual space. 
               A fourth virtual string would have been added to the sequence if there had been some
               text between 
               <div class="code e410">&lt;/v&gt;</div> and 
               <div class="code e411">&lt;/t&gt;</div>; indeed, empty virtual strings are never added to the returned sequence.
            </div>
            <div class="para e412">The construction of a sequence of virtual strings could be formalized as a generalized
               form of string projection [
               <div class="xref e413" linkend="stp"></div>] applied to a suitable representation of the selected sections of the XML document,
               based on classes of nodes of the node list. The projection alphabet would be comprised
               of one symbol only: text nodes that are not inside an invisible tag. The general alphabet
               would also include as individual symbols the nodes containing standalone tags (either
               opening, closing or empty) whose types match those included in the skipped, visible,
               terminal and unexpected tag visibility classes. The general alphabet would further
               include as individual symbols the sequences of nodes constituting complete elements
               (i.e. opening tag, matching closing tag and the sequence of nodes in-between) whose
               types match those included in the invisible tag visibility class.
            </div>
         </div><a name="VirtualTextRetrievalAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e414">
            <div class="title e415">Virtual Text Retrieval API</div>
            <div class="para e416">The virtual text retrieval API takes one virtual string and an information request
               as input, and provides either the text of the virtual string, a node, an offset or
               a stopper tag as output. Retrieval operations are independently performed by the API
               user on the text of the virtual string provided by the API.
            </div>
            <div class="para e417">The virtual text retrieval API implicitly allows tag-aware search by letting the API
               user perform full text search of a target virtual string. The virtual string exposes
               the string that was virtually constructed from a section of the XML document. This
               string is a normal, regular string that can be searched as any other string. In particular,
               the API user can apply her favorite regexp engine or pattern matching algorithm.
            </div>
            <div class="para e418">To obtain match points [
               <div class="xref e419" linkend="lin01a"></div>] and otherwise access the nodes of the XML document backing the virtual string, all
               the API user needs to provide is the index of the character of interest (from 0 to
               N-1, if the length of the virtual string is N).
               Five operations are provided by the virtual text retrieval API:
               
               <div class="itemizedlist e420">
                  <div class="listitem e421">
                     <div class="para e422">Get the text of the virtual string.</div>
                  </div>
                  <div class="listitem e423">
                     <div class="para e424">Get the text node backing the character at target index in the virtual string.</div>
                  </div>
                  <div class="listitem e425">
                     <div class="para e426">Get the offset, i.e. start index within the virtual string, of the text node backing
                        the character at target index in the virtual string.
                     </div>
                  </div>
                  <div class="listitem e427">
                     <div class="para e428">Get the stopper tag (i.e. visible or terminal tag) delimiting (i.e. immediately following)
                        the virtual string, if any. The stopper tag qualifier can also be obtained.
                     </div>
                  </div>
                  <div class="listitem e429">
                     <div class="para e430">Check whether the character at target index in the virtual string is a virtual space
                        or a regular character.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e431">A virtual space is a space character found in a virtual string, that does not belong
               to any node of the underlying XML document. Virtual spaces are inserted instead of
               break tags. If a break tag is preceded by a hyphen and if it contains a specific attribute
               (i.e. 
               <div class="code e432">merge</div>), the break tag can be processed differently based on the value of the attribute.
               Three behaviors are defined:
               
               <div class="itemizedlist e433">
                  <div class="listitem e434">
                     <div class="para e435">insert a virtual space (default behavior in the absence of the specific attribute);</div>
                  </div>
                  <div class="listitem e436">
                     <div class="para e437">merge the word preceding the break tag and the word following the break tag, preserving
                        the hyphen;
                     </div>
                  </div>
                  <div class="listitem e438">
                     <div class="para e439">merge the word preceding the break tag and the word following the break tag, discarding
                        the hyphen.
                     </div>
                  </div>
               </div>
               The text virtualization API thus takes care of automatically adding virtual spaces
               where specified, and otherwise virtually merges the two parts of hyphenated words,
               preserving or discarding the hyphen as specified. 
               This mechanism lets the API user control how words split by a break tag are processed
               in the presence of a hyphen. All is required from the API user is to set the value
               of a specific attribute for each word split by a break tag that should be virtually
               recomposed into one word when a virtual string is constructed.
            </div>
         </div><a name="VirtualTextUpdateAPIandVirtualTagSplicingAPIANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e440">
            <div class="title e441">Virtual Text Update API and Virtual Tag Splicing API</div>
            <div class="para e442">The virtual text update API takes one virtual string and an update specification as
               input, and updates/inserts/deletes text nodes as output.
               The virtual tag splicing API takes one virtual string and a splicing specification
               as input, and inserts tag nodes as output.
            </div>
            <div class="para e443">The virtual text update API allows to modify the text of a virtual string. The virtual
               tag splicing API allows to splice (i.e. insert) tags into a virtual string.
               Both APIs allow to specify updates in a straightforward manner and have these updates
               transparently propagated to the underlying XML document. This may involve, in addition
               to the update of nodes, the insertion of nodes into the node list as well as the deletion
               of some of its nodes. To specify updates to a virtual string, all the API user needs
               to specify, besides the update description, is the index of the character (or indexes
               of the couple of characters) of interest (from 0 to N-1, if the length of the virtual
               string is N).
            </div>
            <div class="para e444">One operation is provided by the virtual text update API:
               
               <div class="itemizedlist e445">
                  <div class="listitem e446">
                     <div class="para e447">Updating a target substring of a virtual string: a couple of target indexes (i.e.
                        start and end indexes) in the virtual string are specified, along with a replacement
                        string. If the replacement string is shorter than the target substring, some of the
                        rightmost backing text nodes might be completely deleted from the XML document.
                     </div>
                  </div>
               </div>
               Similarly to XQuery updates [
               <div class="xref e448" linkend="xqui"></div>], virtual text updates are not applied immediately. Virtual text updates are accumulated
               into a list of pending updates. The listed updates are all applied when the API user
               explicitly invokes the execution of the updates.
               
            </div>
            <div class="para e449">Two operations are provided by the virtual tag splicing API:
               
               <div class="itemizedlist e450">
                  <div class="listitem e451">
                     <div class="para e452">Inserting a couple of opening and closing tags around a target substring of a virtual
                        string, that is specified with a couple of target indexes (start and end indexes).
                     </div>
                  </div>
                  <div class="listitem e453">
                     <div class="para e454">Inserting a single (opening, closing or empty) tag at a specified index into a virtual
                        string.
                     </div>
                  </div>
               </div>
               Also similarly to XQuery updates [
               <div class="xref e455" linkend="xqui"></div>], virtual tag splicing updates are not applied immediately, but accumulated into
               a list of pending updates that are applied together when explicitly requested by the
               API user.
            </div>
         </div>
      </div><a name="RelatedWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e456">
         <div class="title e457">Related Work</div><a name="QueryandUpdateFrameworksANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e458">
            <div class="title e459">Query and Update Frameworks</div><a name="InformationExtractionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e460">
               <div class="title e461">Information Extraction</div>
               <div class="para e462"> Information Extraction (IE) [
                  <div class="xref e463" linkend="ie"></div>] consists of extracting structured information from unstructured documents. Therefore,
                  the semantic tagging of the FEW dictionary could theoretically be modelled as an IE
                  problem (named entity recognition, coreference resolution, terminology extraction,
                  relationship extraction). In practice, however, we hypothesize (but neither claim
                  nor prove) that the quantity and complexity of the involved rules to identify fields
                  of information in the FEW dictionary together make it intractable to use existing
                  general-purpose IE software [
                  <div class="xref e464" linkend="gate"></div>, 
                  <div class="xref e465" linkend="ibmie"></div>].
               </div>
               <div class="para e466">For instance, the General Architecture for Text Engineering (GATE) [
                  <div class="xref e467" linkend="gate"></div>] makes it straightforward to define a large number of pattern matching and text processing
                  rules, however with limited access to context. From our reading of the online documentation
                  of GATE, we hypothesize that most rules for the semantic tagging of the FEW depend
                  so much on context that they cannot be expressed within GATE.
               </div>
               <div class="para e468">Whether the stated hypothesis is proved or disproved, it will be very interesting
                  to more deeply explore to what extent the semantic tagging of the FEW can be modelled
                  as an IE problem.
               </div>
            </div><a name="RegularFragmentationsandXMLFragmentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e469">
               <div class="title e470">Regular Fragmentations and XML Fragments</div>
               <div class="para e471">The Regular Fragmentations retrieval language and API [
                  <div class="xref e472" linkend="stl01a"></div>, 
                  <div class="xref e473" linkend="rfg"></div>] allows full text search in XML-encoded corpora (keyword search at least, as well
                  as regexp search). Regular Fragmentations does allow updates as it is a filter tool
                  made available through either an XML configuration file or an API. Its internal representation
                  is tree-based and can be modified based on an implied processing model. Matching on
                  both markup and textual content is (currently?) not supported, which makes it unsuitable
                  to the semantic tagging of the FEW dictionary.
               </div>
               <div class="para e474">The XML fragments query mechanism [
                  <div class="xref e475" linkend="car03a"></div>] allows full text search (keyword search only, no regexp search) and structural search
                  in XML-encoded corpora. It does not allow updates. It does support tag-aware search.
                  Queries are described as exemplar fragments of the XML document, which allows tag-aware
                  search, albeit with limited flexibility. Lack of support for join operations is noted
                  to be a 
                  <div class="emphasis e476" role="ital">major limitation of [the] XML fragment model, and a major restriction of most IR systems
                     as compared to DB systems
                  </div> [
                  <div class="xref e477" linkend="car03a"></div>]. This remark also highlights that the major strength of our proposed API is its
                  flexibility: Full access to the underlying XML document is provided with the retrieved
                  results, enabling arbitrary supplementary processing of the retrieved results, as
                  well as arbitrary updates of the underlying XML document.
               </div>
            </div><a name="ReadingContextsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e478">
               <div class="title e479">Reading Contexts</div>
               <div class="para e480">The XTReSy [
                  <div class="xref e481" linkend="lin01a"></div>] retrieval language allows full text search in XML-encoded corpora (keyword search,
                  probably not regexp search).
                  XTReSY does not allow updates. XTReSY supports tag-aware search and has the capability
                  to return match points. Interestingly, text normalization can be flexibly defined
                  and is part of the language. The construction of the in-memory representation of XML
                  documents in our work also features text normalization, but as opposed to XTReSY,
                  punctuation is preserved (as it can constitute useful hints to detect types of information)
                  and case streamlining is left to the API user (see Virtual Text Retrieval API here
                  above). XTReSY actually introduced the concept of tag-aware search (refereed to as
                  tag-dependent search [
                  <div class="xref e482" linkend="lin01a"></div>]). XTReSy also introduced a tag visibility model that is extended by our proposed
                  model (see above).
                  The XTReSy [
                  <div class="xref e483" linkend="lin01a"></div>] tag visibility model is comprised of three classes:
                  
                  <div class="itemizedlist e484">
                     <div class="listitem e485">
                        <div class="para e486">soft tags: can be mapped to skipped tags in our tag visibility model;</div>
                     </div>
                     <div class="listitem e487">
                        <div class="para e488">jump tags: can be mapped to invisible tags in our tag visibility model;</div>
                     </div>
                     <div class="listitem e489">
                        <div class="para e490">hard tags: can be mapped to visible and terminal tags in our tag visibility model.</div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e491">The XGTagger [
                  <div class="xref e492" linkend="tan05a"></div>] retrieval tool allows full text search in XML-encoded corpora (keyword search, as
                  well as regexp search). XGTagger supports tag-aware search but cannot return match
                  points. XGTagger does not allow updates. Instead, an external tool can update (only
                  once) the virtualized XML document. XGTagger relies on the XTReSy [
                  <div class="xref e493" linkend="lin01a"></div>] tag visibility model to virtualize XML documents. Our proposed concept of virtual
                  string is conceptually close to Tannier's concept of reading context. Our virtualization
                  mechanism is more flexible than XGTagger [
                  <div class="xref e494" linkend="tan06a"></div>, 
                  <div class="xref e495" linkend="tan06b"></div>]. Firstly, our API allows to dynamically invoke an arbitrary number of virtualizations
                  and updates to different sections of the XML document. Secondly, XGTagger cannot return
                  match points. Thirdly, though reading contexts are backed by the underlying XML document,
                  XGTagger does not expose the XML document to the external updating tool. Fourthly,
                  our tag visibility model is an extended version of the XTReSy [
                  <div class="xref e496" linkend="lin01a"></div>] model on which XGTagger relies to virtualize XML documents; the distinction between
                  visible and terminal tags in our model allows the API user to transparently obtain
                  a scoped iterator over multiple virtual strings.
               </div>
            </div><a name="XQueryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e497">
               <div class="title e498">XQuery</div>
               <div class="para e499">The XQuery [
                  <div class="xref e500" linkend="xqe"></div>] retrieval language allows, among many powerful features, full text search in XML-encoded
                  corpora (keyword search as well as, to a certain extent, regexp search). The Full
                  Text extension [
                  <div class="xref e501" linkend="xqf"></div>, 
                  <div class="xref e502" linkend="xqfi"></div>, 
                  <div class="xref e503" linkend="imh08a"></div>] adds full-text search capabilities to XQuery. The Full Text extension is a very
                  recently (as of January 2010) stabilized W3C Candidate Recommendation. The Full Text
                  extension does support tag-aware search, to a certain extent. Tags can be configured
                  to be made invisible during search through the use of the 
                  <div class="code e504">FTIgnore</div> option. It must be noted that constructing an intermediate full text representation
                  and searching this full text representations are tightly interwoven, in order to return
                  to user code the XML elements that include contents matching the full text search
                  query.
               </div>
               <div class="para e505">XQuery, through its Update Facility [
                  <div class="xref e506" linkend="xqu"></div>, 
                  <div class="xref e507" linkend="xqui"></div>], allows powerful forms of updates to the processed XML document. The Update Facility
                  is a recently (as of June 2009) stabilized W3C Candidate Recommendation. Its internal
                  representation is tree-based and XPath-addressable [
                  <div class="xref e508" linkend="xpat"></div>]. XQuery Full Text and XQuery Update Facility could thus be combined.
               </div>
               <div class="para e509">XQuery considered together with XQuery Full Text and the XQuery Update Facility is
                  a very powerful and versatile technology. What then could make it unsuitable for the
                  semantic tagging of the FEW dictionary? FEW algorithms often need to perform additional
                  search operations in the textual context around full text search matches. Results
                  returned to user code by XQuery, though, are XML elements. It is thus not straightforward
                  to perform subsequent search operations on these results, or obtain match points for
                  arbitrary characters in the context of the returned results.
               </div>
               <div class="para e510">We hypothesize that our proposed virtual text retrieval API might be implemented in
                  XQuery on top of Full Text. However, we also hypothesize that offering the same expressiveness
                  and flexibility would lead to a performance overhead. Indeed, XQuery returns XML elements
                  instead of virtual strings, which means a partial loss of intermediate information
                  (such as match points) that will have to be reconstructed over and over. It is possible,
                  however, that such performance overhead could be addressed through good software engineering
                  and extensions to the XQuery language.
               </div>
               <div class="para e511">Philosophically, the key feature of our proposed virtualization mechanism over XQuery
                  is to offer linguists a way to think of the dictionary and express themselves in a
                  familiar environment: text without tags.
               </div>
            </div><a name="OtherrelevantworksANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e512">
               <div class="title e513">Other relevant works</div>
               <div class="para e514">The lq-text [
                  <div class="xref e515" linkend="qui08a"></div>] retrieval tool allows full text search in XML-encoded corpora (both keyword search
                  as well as regexp search).
                  It does support a limited form of update, i.e. adding tags around keyword matches.
                  It supports useful Natural Language Processing features such as punctuation-aware
                  and plural-aware search. Its internal representation is not tree-based. It does not
                  support tag-aware search (as considered in this paper), as far as we can tell.
               </div>
               <div class="para e516">The Nexi [
                  <div class="xref e517" linkend="kam06a"></div>] query language allows full text search in XML-encoded corpora (keyword search only).
                  It does not allow updates. It does support tag-aware search based on several expressive
                  query forms (it is claimed to be at least as expressive as XML Fragments [
                  <div class="xref e518" linkend="car03a"></div>], see above), but not to the extent required for the semantic tagging of the FEW
                  dictionary (see [
                  <div class="xref e519" linkend="kam06a"></div>], Section 6, p. 433).
               </div>
            </div>
         </div><a name="SemanticTaggingofXMLEncodedCorporaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e520">
            <div class="title e521">Semantic Tagging of XML-Encoded Corpora</div>
            <div class="para e522">The semantic tagging of the Dictionary of Middle Dutch [
               <div class="xref e523" linkend="voo05a"></div>] as well as of the TLFi dictionary [
               <div class="xref e524" linkend="den03a"></div>, 
               <div class="xref e525" linkend="tlfi"></div>, 
               <div class="xref e526" linkend="tlf04a"></div>] were partially automated. However, due to lack of support for virtualization of
               the XML document, there was little flexibility in the retrieval of the fields of information.
               Exceedingly complex and brittle regular expressions including hard-coded markup were
               used. In practice, this certainly limited any changes to the sequence in which fields
               of information were tagged, and also discouraged the use of attributes in the markup
               (because tags, attributes and attribute values all had to be hard-coded statically
               within the regular expressions).
            </div>
         </div>
      </div><a name="ConcludingRemarksANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e527">
         <div class="title e528">Concluding Remarks</div>
         <div class="para e529">An API providing support for flexible tagging of text-oriented XML documents was introduced
            in this paper. It is based on the virtualization of selected sections of the XML document.
            It enables tag-aware full text search, obtaining match points and transparent updates
            to the underlying XML document.
            The API enabled successful, automated tagging [
            <div class="xref e530" linkend="ren09a"></div>, 
            <div class="xref e531" linkend="bri09a"></div>]
            of a test corpus (146 articles, about 0.75% of the total number of articles) of the
            digitized version of the FEW, which is one of the most complex paper dictionaries.
            Coverage, defined here as the percentage of the length of relevant sections of the
            XML document that are semantically tagged, consistently converges around 99.3%.
            Precision and recall are not yet available. These metrics are very difficult to measure
            in the context of the FEW: A highly-trained human operator would need several days
            to manually add semantic tagging to the average FEW article.
         </div>
         <div class="para e532">A Java implementation of the API was completed during the summer of 2009. The API
            itself is comprised of ~7500 lines of Java code, with additional dependencies on other
            parts of the code base (~69000 lines) of the FEW semantic tagging project, notably
            the node list data structure. It is clear that the current implementation, while 100%
            operational and used in production for a real-world project, can be optimized for
            speed (addressing, virtual text update and virtual tag splicing APIs) and for improved
            memory management (text virtualization API). One of the logical next steps will be
            to package (and optimize) the API implementation and the node list data structure
            into a library, so that other projects can benefit from them as well. External feedback
            on the syntax, semantics and expected performance of the operations provided by the
            API will be valuable.
         </div>
         <div class="para e533">To conclude, the take-home message could be stated as follows. Our proposed virtual
            text retrieval API might be implemented in XQuery on top of Full Text, although probably
            at the expense of a performance overhead. The key feature of our proposed virtualization
            mechanism is to offer linguists a way to think of the dictionary and express themselves
            in a familiar environment: text without tags. Its flexibility and expressiveness are
            derived from (unconsciously, though, at the time of mechanism design) blending prior
            ideas, i.e. reading contexts [
            <div class="xref e534" linkend="lin01a"></div>, 
            <div class="xref e535" linkend="tan06a"></div>, 
            <div class="xref e536" linkend="tan06b"></div>] and regular fragmentations [
            <div class="xref e537" linkend="stl01a"></div>], with a good dose of dynamicity. Given the scope and complexity of the FEW dictionary
            [
            <div class="xref e538" linkend="ren07a"></div>, 
            <div class="xref e539" linkend="war22a"></div>], an environment or data processing abstraction that is flexible and familiar to
            the API user might be more important than the power and breadth of features of successful,
            general-purpose technologies such as XQuery [
            <div class="xref e540" linkend="xqe"></div>]. Support for 
            <div class="emphasis e541">natural linguistic reasoning</div>, i.e. tag-aware mixed-information (text/markup) retrieval and update, is the main
            contribution of our paper.
         </div>
      </div><a name="AcknowledgmentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e542">
         <div class="title e543">Acknowledgments</div>
         <div class="para e544">We would like to thank Xavier Dalem, Stéfan Sinclair and the anonymous reviewers for
            their helpful suggestions that greatly improved the quality of the paper.
            We also would like to thank Eva Buchi for her encouragement to prepare this paper,
            as well as for a particularly relevant bibliographical hint that greatly helped us
            identify related works.
         </div>
         <div class="para e545">Figure 1 includes icons from the 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e546" xlink:actuate="onRequest" xlink:href="http://tango.freedesktop.org/" xlink:show="new" xlink:type="simple">Tango library</div>, under Creative Commons Attribution Share-Alike license.
         </div>
         <div class="para e547">Finally, we would like to thank Chris Lilley for proofreading the final version of
            the paper; of course, all remaining typos and grammatical mistakes are ours.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e548">
         <div class="title e549">Bibliography</div>
         <div class="bibliomixed e550" xml:id="bri09a" xreflabel="Briquet2009a">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e551" xlink:actuate="onRequest" xlink:href="http://www.montefiore.ulg.ac.be/~briquet/" xlink:show="new" xlink:type="simple">Cyril Briquet</div> and Pascale Renders. 
            <div class="emphasis e552" role="ital">«Une approche reposante (RESTful) des aspects opérationnels de la rétroconversion
               du Französisches Etymologisches Wörterbuch (FEW)»
            </div>. Proc. Liège Day in Processing of Gallo-Roman Sources (
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e553" xlink:actuate="onRequest" xlink:href="http://www.trasogal.ulg.ac.be" xlink:show="new" xlink:type="simple">TraSoGal</div>), May 2009.
         </div>
         <div class="bibliomixed e554" xml:id="buc96a" xreflabel="Buchi1996a">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e555" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/perso/buchi/" xlink:show="new" xlink:type="simple">Éva Büchi</div>. 
            <div class="emphasis e556" role="ital">«Les Structures du /Französisches Etymologisches Wörterbuch/. Recherches métalexicographiques
               et métalexicologiques»
            </div>, Niemeyer, Tübingen, 1996.
         </div>
         <div class="bibliomixed e557" xml:id="car03a" xreflabel="Carmel2003a">David Carmel, Yoelle S. Maarek, Matan Mandelbrod, Yosi Mass and Aya Soffer. 
            <div class="emphasis e558" role="ital">«Searching XML documents via XML fragments»</div>. Proc. SIGIR, Toronto, ON, 2003.
         </div>
         <div class="bibliomixed e559" xml:id="den03a" xreflabel="Dendien2003a">Jacques Dendien and Jean-Marie Pierrel. 
            <div class="emphasis e560" role="ital">«Le Trésor de la Langue Française informatisé. Un exemple d’informatisation d’un dictionnaire
               de langue de référence»
            </div>. In Traitement Automatique des Langues 43 (2), 2003.
         </div>
         <div class="bibliomixed e561" xml:id="der04a" xreflabel="DeRose2004a">Steven DeRose. 
            <div class="emphasis e562" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e563" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html" xlink:show="new" xlink:type="simple">Markup Overlap: A Review and a Horse</div>»
            </div>. In Proc. Extreme Markup Languages, Montréal, Québec, August 2004.
         </div>
         <div class="bibliomixed e564" xml:id="dom" xreflabel="DOM">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e565" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/" xlink:show="new" xlink:type="simple">Document Object Model (DOM)</div>. [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e566" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/" xlink:show="new" xlink:type="simple">http://www.w3.org/DOM/</div>
         </div>
         <div class="bibliomixed e567" xml:id="gate" xreflabel="GATE">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e568" xlink:actuate="onRequest" xlink:href="http://gate.ac.uk/" xlink:show="new" xlink:type="simple">General Architecture for Text Engineering</div>. [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e569" xlink:actuate="onRequest" xlink:href="http://gate.ac.uk/" xlink:show="new" xlink:type="simple">http://gate.ac.uk/</div>
         </div>
         <div class="bibliomixed e570" xml:id="ie" xreflabel="IE">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e571" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Information_extraction" xlink:show="new" xlink:type="simple">Information Extraction</div>. [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e572" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Information_extraction" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/Information_extraction</div>
         </div>
         <div class="bibliomixed e573" xml:id="ibmie" xreflabel="IBMIE">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e574" xlink:actuate="onRequest" xlink:href="http://www.research.ibm.com/IE/" xlink:show="new" xlink:type="simple">IBM Trainable Information Extraction Systems</div>. [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e575" xlink:actuate="onRequest" xlink:href="http://www.research.ibm.com/IE/" xlink:show="new" xlink:type="simple">http://www.research.ibm.com/IE/</div>
         </div>
         <div class="bibliomixed e576" xml:id="imh08a" xreflabel="Imhof2008a">Julia Imhof. 
            <div class="emphasis e577" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e578" xlink:actuate="onRequest" xlink:href="http://e-collection.ethbib.ethz.ch/eserv/eth:30791/eth-30791-01.pdf" xlink:show="new" xlink:type="simple">Evaluation Strategies for XQuery Full-Text</div>»
            </div>. M.S. Thesis, ETH Zurich, September 2008.
         </div>
         <div class="bibliomixed e579" xml:id="kam06a" xreflabel="Kamps2006a">Jaap Kamps, Maarten Marx, Maarten de Rijke and Börkur Sigurbjörnsson. 
            <div class="emphasis e580" role="ital">«Articulating Information Needs in XML Query Languages»</div>. In ACM Transactions on Information Systems 24 (4), October 2006. doi: 
            <div class="biblioid doi e581">10.1145/1185877.1185879</div>
         </div>
         <div class="bibliomixed e582" xml:id="lin01a" xreflabel="Lini2001a">Luca Lini, Daniella Lombardini, Michele Paoli, Dario Colazzo and Carlo Sartiani. 
            <div class="emphasis e583" role="ital">«XTReSy: A Text Retrieval System for XML documents»</div>. In D. Buzzetti, H. Short, and G. Pancalddella, editors, Augmenting Comprehension:
            Digital Tools for the History of Ideas. Office for Humanities Communication Publications,
            King's College, London, 2001.
         </div>
         <div class="bibliomixed e584" xml:id="oed" xreflabel="OED">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e585" xlink:actuate="onRequest" xlink:href="http://www.oed.com/" xlink:show="new" xlink:type="simple">Oxford English Dictionary</div>. [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e586" xlink:actuate="onRequest" xlink:href="http://www.oed.com/" xlink:show="new" xlink:type="simple">http://www.oed.com/</div>
         </div>
         <div class="bibliomixed e587" xml:id="oedwiki" xreflabel="OED">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e588" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Oxford_English_Dictionary" xlink:show="new" xlink:type="simple">Oxford English Dictionary</div>. [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e589" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Oxford_English_Dictionary" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/Oxford_English_Dictionary</div>
         </div>
         <div class="bibliomixed e590" xml:id="projectfew" xreflabel="ProjectFEW">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e591" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/few" xlink:show="new" xlink:type="simple">Französisches Etymologisches Wörterbuch</div>. [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e592" xlink:actuate="onRequest" xlink:href="http://www.atilf.fr/few" xlink:show="new" xlink:type="simple">http://www.atilf.fr/few</div>
         </div>
         <div class="bibliomixed e593" xml:id="pug90a" xreflabel="Pugh1990a">William Pugh. 
            <div class="emphasis e594" role="ital">«Skip lists: a probabilistic alternative to balanced trees»</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e595" xlink:actuate="onRequest" xlink:href="http://cacm.acm.org/" xlink:show="new" xlink:type="simple">Communications of the ACM</div> 33 (6), June 1990. doi: 
            <div class="biblioid doi e596">10.1145/78973.78977</div>
         </div>
         <div class="bibliomixed e597" xml:id="qui08a" xreflabel="Quin2008a">Liam R. E. Quin. 
            <div class="emphasis e598" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e599" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol1/html/Quin01/BalisageVol1-Quin01.html" xlink:show="new" xlink:type="simple">Text Retrieval for XML-Encoded Corpora: A Lexical Approach</div>»
            </div>. Proc. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e600" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/" xlink:show="new" xlink:type="simple">Balisage</div>, August 2008. doi: 
            <div class="biblioid doi e601">10.4242/BalisageVol1.Quin01</div>
         </div>
         <div class="bibliomixed e602" xml:id="ren07a" xreflabel="Renders2007a">Pascale Renders. 
            <div class="emphasis e603" role="ital">«L’informatisation du Französisches Etymologisches Wörterbuch : quels objectifs, quelles
               possibilités ?»
            </div>. Proc. Congrès International de Linguistique et de Philologie Romanes, Innsbruck,
            Austria, September 2007.
         </div>
         <div class="bibliomixed e604" xml:id="ren09a" xreflabel="Renders2009a">Pascale Renders and 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e605" xlink:actuate="onRequest" xlink:href="http://www.montefiore.ulg.ac.be/~briquet/" xlink:show="new" xlink:type="simple">Cyril Briquet</div>. 
            <div class="emphasis e606" role="ital">«Conception d’algorithmes de rétroconversion»</div>. Proc. Liège Day in Processing of Gallo-Roman Sources (
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e607" xlink:actuate="onRequest" xlink:href="http://www.trasogal.ulg.ac.be" xlink:show="new" xlink:type="simple">TraSoGal</div>), May 2009.
         </div>
         <div class="bibliomixed e608" xml:id="rfg" xreflabel="RegFrag">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e609" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/projects/fragment/" xlink:show="new" xlink:type="simple">Regular Fragmentations</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e610" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/projects/fragment/" xlink:show="new" xlink:type="simple">http://www.simonstl.com/projects/fragment/</div>
         </div>
         <div class="bibliomixed e611" xml:id="sav10a" xreflabel="Savage2010a">Neil Savage. 
            <div class="emphasis e612" role="ital">«New Search Challenges and Opportunities»</div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e613" xlink:actuate="onRequest" xlink:href="http://cacm.acm.org/" xlink:show="new" xlink:type="simple">Communications of the ACM</div> 53 (1), January 2010. doi: 
            <div class="biblioid doi e614">10.1145/1629175.1629183</div>
         </div>
         <div class="bibliomixed e615" xml:id="stl01a" xreflabel="StLaurent2001a">Simon St.Laurent. 
            <div class="emphasis e616" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e617" xlink:actuate="onRequest" xlink:href="http://www.simonstl.com/articles/regfrag/" xlink:show="new" xlink:type="simple">Treating Complex Textual Content as Markup</div>»
            </div>. Proc. Extreme Markup Languages, Montréal, Québec, 2001.
         </div>
         <div class="bibliomixed e618" xml:id="stp" xreflabel="StringProjection">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e619" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/String_projection" xlink:show="new" xlink:type="simple">String Projection</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e620" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/String_projection" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/String_projection</div>
         </div>
         <div class="bibliomixed e621" xml:id="tlf04a" xreflabel="TLFi04a">
            <div class="emphasis e622" role="ital">«Trésor de la Langue Française informatisé»</div> (TLFi) CD-ROM, CNRS Editions, Paris, 2004.
         </div>
         <div class="bibliomixed e623" xml:id="tlfi" xreflabel="TLFi">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e624" xlink:actuate="onRequest" xlink:href="http://atilf.atilf.fr/tlf.htm" xlink:show="new" xlink:type="simple">Trésor de la Langue Française informatisé</div> [online] [cited April 14, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e625" xlink:actuate="onRequest" xlink:href="http://atilf.atilf.fr/tlf.htm" xlink:show="new" xlink:type="simple">http://atilf.atilf.fr/tlf.htm</div>
         </div>
         <div class="bibliomixed e626" xml:id="tan05a" xreflabel="Tannier2005a">Xavier Tannier, Jean-Jacques Girardot and Mihaela Mathieu. 
            <div class="emphasis e627" role="ital">«Classifying XML Tags through 
               <div class="quote e628">Reading Contexts</div>»
            </div>. Proc. ACM Symposium on Document Engineering, Bristol, UK, 2005. doi: 
            <div class="biblioid doi e629">10.1145/1096601.1096638</div>
         </div>
         <div class="bibliomixed e630" xml:id="tan06a" xreflabel="Tannier2006a">Xavier Tannier. 
            <div class="emphasis e631" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e632" xlink:actuate="onRequest" xlink:href="http://www.atala.org/article.php3?id_article=329" xlink:show="new" xlink:type="simple">Traiter les documents XML avec les 
                  <div class="quote e633">contextes de lecture</div>
               </div>»
            </div>. Traitement Automatique des Langues 47 (1), 2006.
         </div>
         <div class="bibliomixed e634" xml:id="tan06b" xreflabel="Tannier2006b">Xavier Tannier. 
            <div class="emphasis e635" role="ital">«
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e636" xlink:actuate="onRequest" xlink:href="http://www.limsi.fr/Individu/xtannier/Publications/Tannier_These.pdf" xlink:show="new" xlink:type="simple">Extraction et recherche d'information en langage naturel dans les documents semi-structurés</div>»
            </div>. PhD Dissertation, Ecole Nationale Supérieure des Mines, Saint-Etienne, September
            2006.
         </div>
         <div class="bibliomixed e637" xml:id="voo05a" xreflabel="Voort2005a">John van der Voort van der Kleij. 
            <div class="emphasis e638" role="ital">«Reverse Lemmatizing of the Dictionary of Middle Dutch (1885-1929) Using Pattern Matching»</div>. Proc. Conf. Computational Lexicography and Text Research, Budapest, Hungary, 2005.
         </div>
         <div class="bibliomixed e639" xml:id="war22a" xreflabel="Wartburg1922a">Walther von Wartburg et al. 
            <div class="emphasis e640" role="ital">«Französisches Etymologisches Wörterbuch. Eine darstellung des galloromanischen sprachschatzes»</div>, 25 volumes, Bonn/Heidelberg/Leipzig-Berlin/Bâle, Klopp/Winter/Teubner/Zbinden, 1922-2002.
         </div>
         <div class="bibliomixed e641" xml:id="xpat" xreflabel="XPath">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e642" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XPath" xlink:show="new" xlink:type="simple">XPath</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e643" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XPath" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/XPath</div>
         </div>
         <div class="bibliomixed e644" xml:id="xqe" xreflabel="XQuery">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e645" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XQuery" xlink:show="new" xlink:type="simple">XQuery</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e646" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/XQuery" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/XQuery</div>
         </div>
         <div class="bibliomixed e647" xml:id="xqf" xreflabel="XQueryXPathFullText">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e648" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-full-text-10/" xlink:show="new" xlink:type="simple">XQuery and XPath Full Text 1.0</div> [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e649" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-full-text-10/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-full-text-10/</div>
         </div>
         <div class="bibliomixed e650" xml:id="xqfi" xreflabel="XQueryFullTextIntro">Xavier Franc. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e651" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryFullText/index.html" xlink:show="new" xlink:type="simple">XQuery Full-Text for the impatient</div> [online] [cited June 25, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e652" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryFullText/index.html" xlink:show="new" xlink:type="simple">http://www.xmlmind.com/_tutorials/XQueryFullText/index.html</div>
         </div>
         <div class="bibliomixed e653" xml:id="xqui" xreflabel="XQueryUpdateIntro">Xavier Franc. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e654" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html" xlink:show="new" xlink:type="simple">XQuery Update for the impatient: A quick introduction to the XQuery Update Facility</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e655" xlink:actuate="onRequest" xlink:href="http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html" xlink:show="new" xlink:type="simple">http://www.xmlmind.com/_tutorials/XQueryUpdate/index.html</div>
         </div>
         <div class="bibliomixed e656" xml:id="xqu" xreflabel="XQueryUpdate">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e657" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:show="new" xlink:type="simple">XQuery Update Facility 1.0</div> [online] [cited April 15, 2010] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e658" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery-update-10/</div>
         </div>
      </div>
   </div>
</div>