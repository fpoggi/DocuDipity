<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#UsingXProcXSLT20andXSD11tovalidateRESTfulservicesANCHOR" name="UsingXProcXSLT20andXSD11tovalidateRESTfulservicesTOC">Using XProc, XSLT 2.0, and XSD 1.1 to validate RESTful services</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BackgroundANCHOR" name="BackgroundTOC">Background</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AboutRESTANCHOR" name="AboutRESTTOC">About REST</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AboutRackspaceandOpenStackDeveloper%0ADocumentationANCHOR" name="AboutRackspaceandOpenStackDeveloper%0ADocumentationTOC">About Rackspace and OpenStack Developer
                     Documentation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WhyWADL?ANCHOR" name="WhyWADL?TOC">Why WADL?</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#FlexibilityANCHOR" name="FlexibilityTOC">Flexibility</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ContentReuseANCHOR" name="ContentReuseTOC">Content Reuse</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#InlineDocumentationANCHOR" name="InlineDocumentationTOC">Inline Documentation</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#GrammarAgnosticAssertionsANCHOR" name="GrammarAgnosticAssertionsTOC">Grammar Agnostic Assertions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ExtensibilityANCHOR" name="ExtensibilityTOC">Extensibility</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DocumentationfromWADLANCHOR" name="DocumentationfromWADLTOC">Documentation from WADL</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#WADLNormalizationANCHOR" name="WADLNormalizationTOC">WADL Normalization</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheValidationProblemANCHOR" name="TheValidationProblemTOC">The Validation Problem</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ValidatingRESTwithAutomataANCHOR" name="ValidatingRESTwithAutomataTOC">Validating REST with Automata</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheCheckerFormatANCHOR" name="TheCheckerFormatTOC">The Checker Format</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OptimizationANCHOR" name="OptimizationTOC">Optimization</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheValidationPipelineANCHOR" name="TheValidationPipelineTOC">The Validation Pipeline</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OtherUseCasesANCHOR" name="OtherUseCasesTOC">Other Use Cases</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FilteringandErrorReportingANCHOR" name="FilteringandErrorReportingTOC">Filtering and Error Reporting</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AuthorizationANCHOR" name="AuthorizationTOC">Authorization</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#APICoverageANCHOR" name="APICoverageTOC">API Coverage</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ChallengesANCHOR" name="ChallengesTOC">Challenges</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XSD11earlyadoptionANCHOR" name="XSD11earlyadoptionTOC">XSD 1.1, early adoption</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ParsingXPathsinXSLT2ANCHOR" name="ParsingXPathsinXSLT2TOC">Parsing XPaths in XSLT 2</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TestingTheValidationPipelineANCHOR" name="TestingTheValidationPipelineTOC">Testing The Validation Pipeline</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FutureWorkANCHOR" name="FutureWorkTOC">Future Work</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Apigee</div>
         <div class="singletermTERMS">accept</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
         <div class="singletermTERMS">APIs</div>
         <div class="singletermTERMS">automata</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">common:version</div>
         <div class="singletermTERMS">customized version of oXygen</div>
         <div class="singletermTERMS">Calabash</div>
         <div class="singletermTERMS">clouddocs-maven-plugin</div>
         <div class="singletermTERMS">checker format</div>
         <div class="singletermTERMS">Cramer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">DELETE</div>
         <div class="singletermTERMS">DocBook Open Repository</div>
         <div class="singletermTERMS">Docbkx</div>
         <div class="singletermTERMS">david.cramer@rackspace.com</div>
         <div class="singletermTERMS">David</div>
         <div class="singletermTERMS">documentation</div>
         <div class="singletermTERMS">DocBook</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">GET</div>
         <div class="singletermTERMS">gadgets</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">https://github.com/apigee/wadl-library</div>
         <div class="singletermTERMS">https://help.launchpad.net/API/Hacking</div>
         <div class="singletermTERMS">Hacking the Launchpad web service</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">id</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">JSONPath - XPath for JSON</div>
         <div class="singletermTERMS">JAX-RS: Java API for RESTful Web Services</div>
         <div class="singletermTERMS">jorge.williams@rackspace.com</div>
         <div class="singletermTERMS">Jorge</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Launchpad</div>
         <div class="singletermTERMS">Luis</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">method</div>
         <div class="singletermTERMS">Maven</div>
         <div class="singletermTERMS">Mashery</div>
         <div class="singletermTERMS">method</div>
         <div class="singletermTERMS">Mashery: Untold Secrets Behind Managing an API</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">OpenStack</div>
         <div class="singletermTERMS">oXygen XML editor</div>
         <div class="singletermTERMS">oXygen editor</div>
         <div class="singletermTERMS">Open Repose</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">path/to/my/resource</div>
         <div class="singletermTERMS">path/to/my</div>
         <div class="singletermTERMS">Progress</div>
         <div class="singletermTERMS">path/to/98</div>
         <div class="singletermTERMS">path/to/my/resource/xyz</div>
         <div class="singletermTERMS">path/to/101</div>
         <div class="singletermTERMS">plain</div>
         <div class="singletermTERMS">path</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">resource</div>
         <div class="singletermTERMS">resource_type</div>
         <div class="singletermTERMS">representation</div>
         <div class="singletermTERMS">resource_types</div>
         <div class="singletermTERMS">rax:id</div>
         <div class="singletermTERMS">Rackspace</div>
         <div class="singletermTERMS">resource</div>
         <div class="singletermTERMS">representations</div>
         <div class="singletermTERMS">resource_type</div>
         <div class="singletermTERMS">RESTful Web Services</div>
         <div class="singletermTERMS">RESTful Web Services Cookbook.</div>
         <div class="singletermTERMS">REST</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">section</div>
         <div class="singletermTERMS">Swagger</div>
         <div class="singletermTERMS">SoapUI</div>
         <div class="singletermTERMS">SAX</div>
         <div class="singletermTERMS">start</div>
         <div class="singletermTERMS">Swagger Specification.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">tenantId</div>
         <div class="singletermTERMS">The Apigee WADL Library</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">UUID</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">versionDetails</div>
         <div class="singletermTERMS">VersionDetails</div>
         <div class="singletermTERMS">vc:minVersion</div>
         <div class="singletermTERMS">vc:maxVersion</div>
         <div class="singletermTERMS">validation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xml:lang</div>
         <div class="singletermTERMS">xsd:anyURI</div>
         <div class="singletermTERMS">xsdxt:code</div>
         <div class="singletermTERMS">XProc</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="UsingXProcXSLT20andXSD11tovalidateRESTfulservicesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3" xml:id="wadl-balisage">
      <div class="title e1">Using XProc, XSLT 2.0, and XSD 1.1 to validate RESTful services</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2012</div>
            <div class="confdates e5">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">
               Documentation of RESTful services must be accurate and
               detailed. As a REST service is being developed, the
               documentation must be kept up to date and its accuracy
               constantly validated. Once the REST service is
               released the documentation becomes a contract; clients
               may break if an implementation drifts from the
               documented rules. Also, third-party implementations
               must adhere to the rules in order for clients to
               interact with multiple implementations without
               issue. Ensuring conformance to the documentation is
               complicated, tedious, and error prone. We use our
               existing XML documentation pipeline to generate highly
               efficient validators which can check a RESTful service
               (and it's clients) for conformance to the
               documentation at runtime. We validate all aspects of
               the HTTP request including message content, URI
               templates, query parameters, headers, etc. We describe
               the transformation process and some of the
               optimizations that enable real time optimization and
               discuss challenges including testing the documentation
               pipeline and the validators themselves.
               
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Jorge</div>
               <div class="othername e11">Luis</div>
               <div class="surname e12">Williams</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Jorge Williams is a principal architect on the
                  Cloud Integration Team at Rackspace Hosting where
                  he develops tools and services to solve
                  integration problems. He has aided in the design
                  and development of the Repose HTTP proxy, the
                  Cloud Servers API, the OpenStack Compute and
                  Identity APIs, and the OpenStack extension
                  mechanism. He holds a PhD in computer science.
                  
               </div>
            </div>
            <div class="affiliation e15">
               <div class="orgname e16">Rackspace Hosting</div>
            </div>
            <div class="email e17">jorge.williams@rackspace.com</div>
         </div>
         <div class="author e18">
            <div class="personname e19">
               <div class="firstname e20">David</div>
               <div class="surname e21">Cramer</div>
            </div>
            <div class="personblurb e22">
               <div class="para e23">David Cramer is a Documentation Build Developer
                  on the Cloud Doc Tools team at Rackspace Hosting
                  where he helps maintain the XML-based tool chain
                  used to produce Rackspace and OpenStack API
                  documentation. He has also been involved with the
                  DocBook project for several years.
               </div>
            </div>
            <div class="affiliation e24">
               <div class="orgname e25">Rackspace Hosting</div>
            </div>
            <div class="email e26">david.cramer@rackspace.com</div>
         </div>
         <div class="legalnotice e27">
            <div class="para e28">Copyright © 2012 Rackspace US, Inc.</div>
         </div>
         <div class="keywordset e29" role="author">
            <div class="keyword e30">WADL</div>
            <div class="keyword e31">REST</div>
            <div class="keyword e32">APIs</div>
            <div class="keyword e33">validation</div>
            <div class="keyword e34">documentation</div>
            <div class="keyword e35">DocBook</div>
            <div class="keyword e36">automata</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e37" xml:id="Introduction">
         <div class="title e38">Introduction</div>
         <div class="para e39"> REST is fast becoming the standard method by which
            different software systems interact with one another. As
            such, Rackspace produces a large number of RESTful
            services both for both internal and public consumption.
            Because these RESTful services act as integration points,
            they must be documented accurately and at a very high
            level of detail. As a REST service is being developed, the
            documentation must be kept up to date, and the accuracy of
            the documentation as it relates to the actual
            implementation of the service must be constantly
            validated. That said, once the REST service is released
            the documentation becomes a fixed contract. At this time,
            there exists the possibility that an implementation my
            inadvertently drift from what is described in the
            documentation and this may cause clients to break. Also,
            when dealing with open source services, other
            implementations of the same service may be developed by
            third parties, and it's important for these implementation
            to behave according to the rules specified by the
            documentation as well in order for clients to interact
            with multiple implementations without issue. The process
            of ensuring conformance to the documentation is
            complicated, tedious, and error prone. 
         </div>
         <div class="para e40"> To automate the process, we had the idea to use our
            existing XML documentation pipeline based on XProc, XSLT
            2.0, DocBook and WADL, which already produced HTML and PDF
            documentation artifacts, to generate highly efficient
            validators as well. These validators can be used to check
            a RESTful service (and its clients) for conformance to the
            documentation at runtime in a very efficient manner. The
            validators are capable of using an XSD 1.1 implementation
            (either Xerces or Saxon) to validate not just the content
            of a request, but also to perform checks on URI templates
            and query parameters. The process illustrates the power of
            single sourcing, in that the same source that is used to
            produce human readable artifacts is also used to produce
            machine readable validation instructions. As a result,
            from the same artifact, we are able to:
            <div class="itemizedlist e41">
               <div class="listitem e42">
                  <div class="para e43"> document APIs consistently and efficiently.
                     
                  </div>
               </div>
               <div class="listitem e44">
                  <div class="para e45"> produce different documentation artifacts
                     such as user guides, specifications, and quick
                     reference web pages. 
                  </div>
               </div>
               <div class="listitem e46">
                  <div class="para e47"> validate the accuracy of our API
                     implementations and their clients. 
                  </div>
               </div>
               <div class="listitem e48">
                  <div class="para e49"> help describe the calls a particular user
                     is authorized to make in an API. 
                  </div>
               </div>
            </div>
         </div>
         <div class="para e50"> The purpose of this paper is to describe our REST
            documentation pipeline and discuss how it was adapted to
            produce REST validators. We give a detailed overview of
            the transformation process, including a description of
            some of the optimizations performed to achieve efficient
            real time validation. We also describe some of the
            challenges we've encountered -- including testing the
            documentation pipeline.
            
         </div>
      </div><a name="BackgroundANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e51" xml:id="Background">
         <div class="title e52">Background</div><a name="AboutRESTANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e53" xml:id="REST">
            <div class="title e54">About REST</div>
            <div class="para e55"> REST (REpresentational State Transfer) is an
               "architectural style" described by Roy Fielding in his
               PhD dissertation 
               <div class="xref e56" linkend="Fielding2000"></div>. REST
               seeks to adapt the architecture of the Web, along with
               its scalability, performance, and other advantages, as
               a platform for any kind of application. In REST, as on
               the Web, a 
               <div class="emphasis e57">resource</div> is an item of
               interest. Each resource has an address (URI) and one
               or more 
               <div class="emphasis e58">representations</div> (a file
               with a given media type). A client can interact with a
               resource through a URL and these interactions in turn
               act as the engine of application state because the
               representations provide hypermedia links offering
               alternative directions the client can take to proceed
               through the workflow. The RESTful ideal is that just
               as you interact with a Web site and choose which step
               to take next, without being frustrated that the layout
               of the page and links offered have changed since the
               last time you visited the site, so a client using a
               RESTful API can pick its way through a workflow
               without demanding a fixed, brittle contract. Likewise,
               the Web's mature and well-understood caching
               mechanisms can improve the performance and scalability
               of your application, protecting the server from spikes
               in traffic and the client from brief interruptions in
               the server's availability.  
            </div>
            <div class="para e59">While many APIs describe themselves as RESTful, some
               RESTful APIs are more RESTful than others. At the most
               rudimentary level, APIs may employ one or more URIs,
               but still use only one method (GET, POST) to tunnel
               their requests over HTTP and do not represent a
               radical break from WS-* services. APIs that embrace
               the RESTful architecture more fully offer a larger
               number of resources, each with a URI, and map a
               variety of HTTP verbs to the Create Read Update Delete
               (CRUD) operations found in most applications. In these
               services, parameters are passed in with requests
               either as elements of the URI or as query parameters
               appended to the URI. The Web's caching infrastructure
               also comes into play. Finally, in an ideal more often
               discussed than achieved, services that fully embrace
               the idea of hypermedia as the engine of application
               state (HATEOS), relying on the client to navigate
               through the workflow in the same way an end-user at an
               e-commerce site would, by inspecting the available
               links and picking the appropriate one. 
            </div>
         </div><a name="AboutRackspaceandOpenStackDeveloper%0ADocumentationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e60" xml:id="Pipeline">
            <div class="title e61">About Rackspace and OpenStack Developer
               Documentation
            </div>
            <div class="para e62">
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e63" xlink:actuate="onRequest" xlink:href="http://www.rackspace.com" xlink:show="new" xlink:type="simple">Rackspace</div> is a hosting company that found
               itself well positioned to play a significant role in
               the sea change from traditional hosting to cloud
               computing started by Amazon Web Services. The
               Rackspace strategy involves creating an open source
               alternative to the closed, proprietary world of vendor
               lock-in that AWS represents. To that end, Rackspace
               partnered with NASA to create a collection of open
               source cloud software, called 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e64" xlink:actuate="onRequest" xlink:href="http://www.openstack.org" xlink:show="new" xlink:type="simple">OpenStack</div>. Since its launch in 2010,
               OpenStack has enjoyed rapid growth as an open source
               project with hundreds of companies and individuals
               participating. Since much of the code that we develop
               is contributed to OpenStack, we needed an approach to
               documentation that facilitated interchange and
               collaboration. DocBook and the XSLT stylesheets from
               the 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e65" xlink:actuate="onRequest" xlink:href="http://docbook.sourceforge.net/" xlink:show="new" xlink:type="simple">DocBook Open Repository</div> provide the basis
               for our documentation tool chain. 
            </div>
            <div class="para e66">Our documentation pipeline contains the typical
               components: a schema, authoring environment, source
               control system, build system, and hosted artifacts. In
               particular, we use:
               <div class="itemizedlist e67">
                  <div class="listitem e68">
                     <div class="para e69">A variant of the DocBook 5.0 schema,
                        called RackBook. 
                     </div>
                  </div>
                  <div class="listitem e70">
                     <div class="para e71">A Java Web Start version of the 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e72" xlink:actuate="onRequest" xlink:href="http://www.oxygenxml.com/" xlink:show="new" xlink:type="simple">oXygen XML editor</div> with a
                        custom framework to support RackBook and
                        our specific needs. Contributors are free
                        to use any text editor, but the 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e73" xlink:actuate="onRequest" xlink:href="http://docs.rackspace.com/oxygen" xlink:show="new" xlink:type="simple">customized version of oXygen</div>
                        provides many convenience features.
                        
                     </div>
                  </div>
                  <div class="listitem e74">
                     <div class="para e75">Customizations on top of the DocBook
                        XSLT stylesheets to produce pdf and HTML
                        output branded for Rackspace, OpenStack,
                        or other partners as necessary. 
                     </div>
                  </div>
                  <div class="listitem e76">
                     <div class="para e77">An extended version of the 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e78" xlink:actuate="onRequest" xlink:href="http://docbkx-tools.sourceforge.net/docbkx-maven-plugin/" xlink:show="new" xlink:type="simple">Docbkx</div>
                        
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e79" xlink:actuate="onRequest" xlink:href="https://maven.apache.org/" xlink:show="new" xlink:type="simple">Maven</div> plugin to manage
                        build-time dependencies and perform the
                        build logic to generate artifacts. We've
                        extended Docbkx to incorporate 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e80" xlink:actuate="onRequest" xlink:href="http://xmlcalabash.com/" xlink:show="new" xlink:type="simple">Calabash</div> so that we can
                        preprocess our source code with XProc
                        pipelines. Because OpenStack also relies
                        on this tool, we have open sourced our
                        version of the Maven plugin (
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e81" xlink:actuate="onRequest" xlink:href="https://github.com/rackspace/clouddocs-maven-plugin" xlink:show="new" xlink:type="simple">clouddocs-maven-plugin</div>).
                     </div>
                  </div>
                  <div class="listitem e82">
                     <div class="para e83">We store our source code in a internal
                        git repositories and schedule builds using
                        Jenkins jobs.
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="WhyWADL?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e84" xml:id="WhyWADL">
            <div class="title e85">Why WADL?</div>
            <div class="para e86"> We evaluated frameworks that provide test consoles
               and some level of documentation for RESTful APIs like
               
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e87" xlink:actuate="onRequest" xlink:href="http://www.apigee.com" xlink:show="new" xlink:type="simple">Apigee</div>, 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e88" xlink:actuate="onRequest" xlink:href="http://mashery.com/" xlink:show="new" xlink:type="simple">Mashery</div>,
               and 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e89" xlink:actuate="onRequest" xlink:href="http://swagger.wordnik.com/" xlink:show="new" xlink:type="simple">Swagger</div>, but found each lacking one or
               another important feature. We ultimately decided to
               leverage our DocBook-based tool chain to create human
               and machine readable descriptions of the APIs from the
               same source. The human readable artifacts are the
               documentation, and the machine readable WADL would
               facilitate the run-time validation of API calls in the
               via Open Repose, our open source RESTful proxy. There
               are a number of reasons why we chose WADL over using
               an existing alternative description languages or
               designing our DSL: 
               <div class="itemizedlist e90">
                  <div class="listitem e91">
                     <div class="para e92">The WADL vocabulary includes a number of
                        features that facilitate authoring and
                        content reuse. 
                     </div>
                  </div>
                  <div class="listitem e93">
                     <div class="para e94">Since WADL is XML, it fit easily into
                        our existing DocBook pipeline. 
                     </div>
                  </div>
                  <div class="listitem e95">
                     <div class="para e96">The format is extensible and thus it is
                        simple to add support for new features and
                        niche use-cases. 
                     </div>
                  </div>
                  <div class="listitem e97">
                     <div class="para e98">The format is grammar agnostic. This
                        means that a grammar can be specified in
                        XML Schema for XML media types and JSON
                        Schema for JSON media types. 
                     </div>
                  </div>
                  <div class="listitem e99">
                     <div class="para e100">Additionally, grammars can be used not
                        just to make assertions about the content
                        of HTTP payloads as a whole, but also to
                        make assertions about a particular subset
                        of it. 
                     </div>
                  </div>
                  <div class="listitem e101">
                     <div class="para e102">Grammars can also be used to make
                        assertions over all aspects of an HTTP
                        request or response: template parameters,
                        matrix parameters, query parameters and
                        headers. 
                     </div>
                  </div>
                  <div class="listitem e103">
                     <div class="para e104">WADL is specific to the HTTP protocol
                        and captures all of that protocol's
                        features. As such, it's a perfect markup
                        language for semantically describing
                        RESTful services. 
                     </div>
                  </div>
               </div> We elaborate on some of the more
               important features in detail in the following
               sections. 
            </div><a name="FlexibilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e105" xml:id="flexability">
               <div class="title e106">Flexibility</div>
               <div class="para e107">One of the nice features of WADL is that it has
                  a very flexible schema especially when associating
                  URI paths to resources. For example, suppose we
                  have a very sparse API that allows a
                  
                  <div class="code e108">GET</div> and 
                  <div class="code e109">DELETE</div>
                  operation to occur only at the URI
                  
                  <div class="code e110">https://test.api.openstack.com/path/to/my/resource</div>.
                  This can be represented in a WADL in the following
                  manner: 
               </div>
               <div class="figure e111" xml:id="WADLTree" xreflabel="Example 1">
                  <div class="title e112">WADL in Tree Form</div>
                  <div class="programlisting e113" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
                     &lt;grammars/&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="path"&gt;
                     &lt;resource path="to"&gt;
                     &lt;resource path="my"&gt;
                     &lt;resource path="resource"&gt;
                     &lt;method name="GET"&gt;
                     &lt;response status="200 203"/&gt;
                     &lt;/method&gt;
                     &lt;method name="DELETE"&gt;
                     &lt;response status="200"/&gt;
                     &lt;/method&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e114">Note that each individual path segment in the
                  URI is represented by a
                  
                  <div class="code e115">&lt;resource&gt;</div> element. While
                  the approach would work well in cases where the
                  API has a complex structure with many resources,
                  it's overkill for this example. Instead, we can
                  represent the API like this: 
               </div>
               <div class="figure e116" xml:id="WADLFlat" xreflabel="Example 2">
                  <div class="title e117">WADL in Flat Form</div>
                  <div class="programlisting e118" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
                     &lt;grammars/&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="path/to/my/resource"&gt;
                     &lt;method name="GET"&gt;
                     &lt;response status="200 203"/&gt;
                     &lt;/method&gt;
                     &lt;method name="DELETE"&gt;
                     &lt;response status="200"/&gt;
                     &lt;/method&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e119"> Here, a 
                  <div class="code e120">&lt;resource&gt;</div> element
                  covers multiple segments in the path all at once,
                  in this case 
                  <div class="code e121">path/to/my/resource</div>.
                  Given the sparse API, this is far more convenient.
                  The WADL need not be entirely written in the form
                  illustrated in 
                  <div class="xref e122" linkend="WADLTree"></div> (tree
                  form) or in the form in 
                  <div class="xref e123" linkend="WADLFlat"></div>
                  (flat form). A WADL can contain resources that are
                  simultaneously in both forms (mixed form) as
                  illustrated here: 
               </div>
               <div class="figure e124" xml:id="WADLMix" xreflabel="Example 3">
                  <div class="title e125">WADL in Mix Form</div>
                  <div class="programlisting e126" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
                     &lt;grammars/&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="path/to/my"&gt;
                     &lt;resource path="resource"&gt;
                     &lt;method name="GET"&gt;
                     &lt;response status="200 203"/&gt;
                     &lt;/method&gt;
                     &lt;method name="DELETE"&gt;
                     &lt;response status="200"/&gt;
                     &lt;/method&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e127"> In 
                  <div class="xref e128" linkend="WADLMix"></div> we have two
                  
                  <div class="code e129">&lt;resource&gt;</div> elements, one
                  for 
                  <div class="code e130">path/to/my</div> and another for
                  
                  <div class="code e131">resource</div>. The ability to intermix
                  flat and tree forms, allows the WADL author the
                  flexibility to start with a simple API description
                  and expand on it as the API grows in complexity.
                  
               </div>
            </div><a name="ContentReuseANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e132" xml:id="content_reuse">
               <div class="title e133">Content Reuse</div>
               <div class="para e134">WADL contains a number of features that
                  encourages content reuse. First,
                  
                  <div class="code e135">&lt;method&gt;</div>,
                  
                  <div class="code e136">&lt;representation&gt;</div>, and
                  
                  <div class="code e137">&lt;param&gt;</div> elements can be
                  specified separately from individual resources and
                  therefore can be shared between them. For example
                  suppose that you have two resources
                  
                  <div class="code e138">widgets</div> and 
                  <div class="code e139">gadgets</div>
                  both of these resources contain a method to access
                  metadata. You can repeat the method definition in
                  both resources as illustrated in 
                  <div class="xref e140" linkend="wg-one"></div>. 
               </div>
               <div class="figure e141" xml:id="wg-one" xreflabel="Example 4">
                  <div class="title e142">Two resources with a common method</div>
                  <div class="programlisting e143" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets"&gt;
                     &lt;method name="GET"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;/resource&gt;
                     &lt;resource path="gadgets"&gt;
                     &lt;method name="GET"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e144">Repeating the method however can be error prone
                  and tedious. Instead, the method can be written
                  once and referenced from the individual resource
                  as illustrated in 
                  <div class="xref e145" linkend="wg-two"></div>. 
               </div>
               <div class="figure e146" xml:id="wg-two" xreflabel="Example 5">
                  <div class="title e147">Two resources with a common shared
                     method
                  </div>
                  <div class="programlisting e148" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets"&gt;
                     &lt;method href="#getMetadata"/&gt;
                     &lt;/resource&gt;
                     &lt;resource path="gadgets"&gt;
                     &lt;method href="#getMetadata"/&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;method name="GET" id="getMetadata"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e149">Note that the method is referred to by its
                  
                  <div class="code e150">id</div> and the hash (#) is used to
                  denote the internal link. It's possible that
                  multiple related methods can be shared between
                  resources. One can express multiple methods
                  together, as in 
                  <div class="xref e151" linkend="wg-three"></div>,
                  however this too can get tedious an error prone. 
               </div>
               <div class="figure e152" xml:id="wg-three" xreflabel="Example 6">
                  <div class="title e153">Two resources with a common shared
                     methods
                  </div>
                  <div class="programlisting e154" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets"&gt;
                     &lt;method href="#getMetadata"/&gt;
                     &lt;method href="#setMetadata"/&gt;
                     &lt;/resource&gt;
                     &lt;resource path="gadgets"&gt;
                     &lt;method href="#getMetadata"/&gt;
                     &lt;method href="#setMetadata"/&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;method name="GET" id="getMetadata"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;method name="POST" id="setMetadata"&gt;
                     &lt;request&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/request&gt;
                     &lt;response status="200"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e155">To alleviate this issue, WADL defines the
                  concept of a 
                  <div class="code e156">resource_type</div>. A
                  
                  <div class="code e157">resource_type</div> contains common
                  behavior that can be shared between multiple
                  resources. This is illustrated in 
                  <div class="xref e158" linkend="wg-four"></div>. 
               </div>
               <div class="figure e159" xml:id="wg-four" xreflabel="Example 7">
                  <div class="title e160">Two resources with a common resource
                     type
                  </div>
                  <div class="programlisting e161" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets" type="#containsMetadata"/&gt;
                     &lt;resource path="gadgets" type="#containsMetadata"/&gt;
                     &lt;/resources&gt;
                     &lt;resource_type id="containsMetadata"&gt;
                     &lt;method name="GET" id="getMetadata"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;method name="POST" id="setMetadata"&gt;
                     &lt;request&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/request&gt;
                     &lt;response status="200"&gt;
                     &lt;representation mediaType="application/xml" element="wapi:metadata"/&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     &lt;/resource_type&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e162"> Realistically, 
                  <div class="code e163">resource_type</div>s may
                  capture many different methods. They may also
                  introduce common sub-resources as illustrated in
                  
                  <div class="xref e164" linkend="wg-five"></div>. 
               </div>
               <div class="figure e165" xml:id="wg-five" xreflabel="Example 8">
                  <div class="title e166">Two resources with a common complex
                     resource type
                  </div>
                  <div class="programlisting e167" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets" type="#containsMetadata"/&gt;
                     &lt;resource path="gadgets" type="#containsMetadata"/&gt;
                     &lt;/resources&gt;
                     &lt;resource_type id="containsMetadata"&gt;
                     &lt;method href="#getMetadata"/&gt;
                     &lt;method href="#setMetadata"/&gt;
                     &lt;resource id="MetadataKey" path="{key}"&gt;
                     &lt;param name="key" style="template" type="wapi:MetadataKey"/&gt;
                     &lt;method href="#getMetadataItem"/&gt;
                     &lt;method href="#setMetadataItem"/&gt;
                     &lt;method href="#deleteMetadataItem"/&gt;
                     &lt;/resource&gt;
                     &lt;/resource_type&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e168">Note that 
                  <div class="code e169">&lt;method&gt;</div>,
                  
                  <div class="code e170">&lt;representation&gt;</div>,
                  
                  <div class="code e171">&lt;param&gt;</div>, and
                  
                  <div class="code e172">&lt;resource_type&gt;</div> elements
                  need not appear in the same WADL, they may be
                  linked in from an external WADL as illustrated
                  below. 
               </div>
               <div class="figure e173" xml:id="wg-six" xreflabel="Example 9">
                  <div class="title e174">Two resources with a common external
                     resource type
                  </div>
                  <div class="programlisting e175" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets" type="common.wadl#containsMetadata"&gt;
                     &lt;!-- widget specific subresources / methods --&gt;
                     &lt;/resource&gt;
                     &lt;resource path="gadgets" type="common.wadl#containsMetadata"&gt;
                     &lt;!-- gadget specific subresources / methods --&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e176"> Finally, note that multiple
                  
                  <div class="code e177">resource_type</div>s may be associated
                  with a single resource. 
               </div>
               <div class="figure e178" xml:id="wg-seven" xreflabel="Example 10">
                  <div class="title e179">Two resources inheriting from multiple
                     resource types
                  </div>
                  <div class="programlisting e180" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:wapi="http://widget/api/v1"&gt;
                     &lt;grammars&gt;
                     &lt;include href="xsd/widget.xsd"/&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="widgets" type="common.wadl#containsMetadata common.wadl#commonMethods"&gt;
                     &lt;!-- widget specific subresources / methods --&gt;
                     &lt;/resource&gt;
                     &lt;resource path="gadgets" type="common.wadl#containsMetadata common.wadl#commonMethods"&gt;
                     &lt;!-- gadget specific subresources / methods --&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
            </div><a name="InlineDocumentationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e181" xml:id="inline_docs">
               <div class="title e182">Inline Documentation</div>
               <div class="para e183">All elements defined by the WADL specification
                  can be associated with inline documentation via
                  the 
                  <div class="code e184">&lt;doc&gt;</div> element. A simple
                  illustration of this is shown in the example
                  below. 
               </div>
               <div class="figure e185" xml:id="doc" xreflabel="Example 11">
                  <div class="title e186">Resource type with doc element</div>
                  <div class="programlisting e187" xml:space="preserve">&lt;resource_type id="BackupList"&gt;
                     &lt;doc xml:lang="EN" title="Backup List"&gt;
                     &lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;
                     A list of backups. Each backup contains IDs, names, and
                     links -- other attributes are omitted.
                     &lt;/p&gt;
                     &lt;/doc&gt;
                     &lt;method href="#listBackups"/&gt;
                     &lt;/resource_type&gt;
                     
                  </div>
               </div>
               <div class="para e188">Note that 
                  <div class="xref e189" linkend="doc"></div> uses the XHTML
                  grammar for narrative text. This is not a
                  requirement, different narrative text grammars can
                  be used. Also note the used of the
                  
                  <div class="code e190">xml:lang</div> attribute, multiple
                  
                  <div class="code e191">&lt;doc&gt;</div> elements can be used
                  each in a different language to aid in the
                  internationalization of the WADL. The
                  
                  <div class="code e192">title</div> element can be used to give
                  an overview of the documentation text. 
               </div>
            </div><a name="GrammarAgnosticAssertionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e193" xml:id="grammar_aug">
               <div class="title e194">Grammar Agnostic Assertions</div>
               <div class="para e195">WADLs contain a 
                  <div class="code e196">&lt;grammars&gt;</div>
                  element that allows the association of grammars
                  such as XML Schema with a REST API. Grammars may
                  be included by means of the
                  
                  <div class="code e197">&lt;include&gt;</div> element as
                  illustrated in 
                  <div class="xref e198" linkend="wg-seven"></div> or they
                  may be written inline as shown in 
                  <div class="xref e199" linkend="inline"></div>. 
               </div>
               <div class="para e200">The WADL specification does not encourage the
                  use of a specific schema grammar over another, but
                  allows the usage of multiple grammars within the
                  same WADL. This enables support for APIs where
                  resources are exposed via multiple mediatypes such
                  as XML and JSON.
                  
               </div>
               <div class="para e201">Besides using grammars to make assertions about
                  a particular media types, they can also be used to
                  make assertions about other aspects of the HTTP
                  request and response. This is illustrated in 
                  <div class="xref e202" linkend="inline"></div>. 
               </div>
               <div class="figure e203" xml:id="inline" xreflabel="Example 12">
                  <div class="title e204">WADL with inline grammar</div>
                  <div class="programlisting e205" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:csapi="http://docs.openstack.org/compute/api/v1.1"&gt;
                     &lt;grammars&gt;
                     &lt;schema elementFormDefault="qualified"
                     attributeFormDefault="unqualified"
                     xmlns="http://www.w3.org/2001/XMLSchema"
                     xmlns:csapi="http://docs.openstack.org/compute/api/v1.1"
                     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                     targetNamespace="http://docs.openstack.org/compute/api/v1.1"&gt;
                     &lt;simpleType name="Progress"&gt;
                     &lt;restriction base="xsd:int"&gt;
                     &lt;minInclusive value="0"/&gt;
                     &lt;maxInclusive value="100" /&gt;
                     &lt;/restriction&gt;
                     &lt;/simpleType&gt;
                     &lt;simpleType name="UUID"&gt;
                     &lt;restriction base="xsd:string"&gt;
                     &lt;length value="36" fixed="true"/&gt;
                     &lt;pattern value="[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"/&gt;
                     &lt;/restriction&gt;
                     &lt;/simpleType&gt;
                     &lt;/schema&gt;
                     &lt;/grammars&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource id="uuid" path="path/to/my/resource/{uuid}"&gt;
                     &lt;param name="uuid" style="template" type="csapi:UUID"/&gt;
                     &lt;method href="#getMethod" /&gt;
                     &lt;/resource&gt;
                     &lt;resource id="progress" path="path/to/{progress}"&gt;
                     &lt;param name="progress" style="template" type="csapi:Progress"/&gt;
                     &lt;method href="#getMethod" /&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;method id="getMethod" name="GET"&gt;
                     &lt;response status="200 203"/&gt;
                     &lt;/method&gt;
                     &lt;/application&gt;
                     
                  </div>
               </div>
               <div class="para e206"> Here, we define two simple types: 
                  <div class="variablelist e207">
                     <div class="varlistentry e208">
                        <div class="term e209">
                           <div class="code e210">Progress</div>
                        </div>
                        <div class="listitem e211">
                           <div class="para e212"> An int with a value between 0
                              and 100 inclusive. 
                           </div>
                        </div>
                     </div>
                     <div class="varlistentry e213">
                        <div class="term e214">
                           <div class="code e215">UUID</div>
                        </div>
                        <div class="listitem e216">
                           <div class="para e217"> A 36 character long string that
                              represents five groups of
                              hexadecimal digits separated by
                              hyphens. 
                           </div>
                        </div>
                     </div>
                  </div>We associate these simple types
                  with path elements in the URI by means of template
                  parameters. Thus, we are denoting that the URI
                  paths:
                  
                  <div class="code e218">path/to/my/resource/3bba8e68-8af5-11e1-ac65-17a552dd2535</div>
                  and 
                  <div class="code e219">path/to/98</div> are valid according to
                  the WADL, but URI paths such as
                  
                  <div class="code e220">path/to/my/resource/xyz</div> and
                  
                  <div class="code e221">path/to/101</div> are not. 
               </div>
               <div class="para e222">Finally, we can use grammars to make assertions
                  about individual sections of the mediatype by
                  means of 
                  <div class="code e223">plain</div> parameters. This is
                  illustrated in method in 
                  <div class="xref e224" linkend="plain"></div>. 
               </div>
               <div class="figure e225" xml:id="plain" xreflabel="Example 13">
                  <div class="title e226">Method with a plain parameter and a
                     link
                  </div>
                  <div class="programlisting e227" xml:space="preserve">&lt;method name="GET" id="versionDetails"&gt;
                     &lt;response status="200 203"&gt;
                     &lt;representation mediaType="application/xml" element="common:version"&gt;
                     &lt;param name="location" style="plain" type="xsd:anyURI"
                     required="true"
                     path="/common:version/atom:link[@rel='self']/@href"&gt;
                     &lt;link resource_type="#VersionDetails" rel="self"/&gt;
                     &lt;/param&gt;
                     &lt;/representation&gt;
                     &lt;/response&gt;
                     &lt;/method&gt;
                     
                  </div>
               </div>
               <div class="para e228">Here we define that the response to the
                  
                  <div class="code e229">versionDetails</div> method should
                  contain an XML payload that validates against the
                  element defined by the QName
                  
                  <div class="code e230">common:version</div>. Additionally, we
                  make an assertion that at the XPath
                  
                  <div class="code e231">/common:version/atom:link[@rel='self']/@href</div>
                  there should be a value that validates against the
                  type 
                  <div class="code e232">xsd:anyURI</div>. Furthermore, this
                  URI should provide a link to a resource with a
                  
                  <div class="code e233">resource_type</div> of
                  
                  <div class="code e234">VersionDetails</div>. 
               </div>
               <div class="para e235">Note that plain parameters can also be used by
                  mediatypes that are not XML based. 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e236" xlink:actuate="onRequest" xlink:href="https://launchpad.net/" xlink:show="new" xlink:type="simple">Launchpad</div>
                  uses JSONPath to make similar assertions on its JSON
                  based API. This is illustrated in 
                  <div class="xref e237" linkend="jsonpath"></div>. 
               </div>
               <div class="figure e238" xml:id="jsonpath" xreflabel="Example 14">
                  <div class="title e239">Excerpt from Launchpad WADL</div>
                  <div class="programlisting e240" xml:space="preserve">&lt;representation mediaType="application/json" id="wiki_name-page"&gt;
                     &lt;param style="plain" name="total_size" path="$['total_size']" required="true"/&gt;
                     &lt;param style="plain" name="start" path="$['start']" required="true"/&gt;
                     &lt;param style="plain" name="entries" path="$['entries']" required="true"/&gt;
                     &lt;param style="plain" name="resource_type_link" path="$['resource_type_link']"&gt;
                     &lt;link/&gt;
                     &lt;/param&gt;
                     &lt;param style="plain" name="next_collection_link" path="$['next_collection_link']"&gt;
                     &lt;link resource_type="#wiki_name-page-resource"/&gt;
                     &lt;/param&gt;
                     &lt;param style="plain" name="prev_collection_link" path="$['prev_collection_link']"&gt;
                     &lt;link resource_type="#wiki_name-page-resource"/&gt;
                     &lt;/param&gt;
                     &lt;param style="plain" name="entry_links" path="$['entries'][*]['self_link']"&gt;
                     &lt;link resource_type="https://api.staging.launchpad.net/1.0/#wiki_name"/&gt;
                     &lt;/param&gt;
                     &lt;/representation&gt;
                     
                  </div>
               </div>
               <div class="para e241">Here we state that there should exist JSON
                  attributes at the JSONPaths given by
                  
                  <div class="code e242">$['total_size']</div>,
                  
                  <div class="code e243">$['start']</div>, and
                  
                  <div class="code e244">$['entries']</div>. Additionally the
                  fields at 
                  <div class="code e245">$['resource_type_link']</div>,
                  
                  <div class="code e246">$['next_collection_link']</div>,
                  
                  <div class="code e247">$['prev_collection_link']</div>, and
                  
                  <div class="code e248">$['entries'][*]['self_link']</div>
                  should contain links to other resources. 
               </div>
               <div class="para e249">Note that Launchpad uses plain parameters to
                  make assertions about various aspects of the JSON
                  
                  <div class="code e250">representation</div> without having to
                  rely directly on JSON schema. 
               </div>
               <div class="para e251">This ability to reference elements from external
                  WADLs allows for common behavior to be shared
                  between different APIs and has the potential to
                  significantly accelerate the definition of APIs
                  with common attributes and behaviors. 
               </div>
            </div><a name="ExtensibilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e252" xml:id="extensibility">
               <div class="title e253">Extensibility</div>
               <div class="para e254">The WADL specification defines a fairly standard
                  extensibility model of allowing elements and
                  attributes in foreign namespaces. The example
                  below illustrates a number of Apigee extensions,
                  including one which indicates that authentication
                  credentials are not required in this particular
                  method call. 
               </div>
               <div class="figure e255" xml:id="apigeeext" xreflabel="Example 15">
                  <div class="title e256">Method with Apigee Extensions</div>
                  <div class="programlisting e257" xml:space="preserve">&lt;method id="statusespublic_timeline" name="GET" xmlns:apigee="http://api.apigee.com/wadl/2010/07/"&gt;
                     &lt;apigee:tags&gt;
                     &lt;apigee:tag primary="true"&gt;Timeline&lt;/apigee:tag&gt;
                     &lt;apigee:tag&gt;Status&lt;/apigee:tag&gt;
                     &lt;/apigee:tags&gt;
                     &lt;apigee:authentication required="false"/&gt;
                     &lt;apigee:example url="/statuses/public_timeline.{format}"/&gt;
                     &lt;doc title=""
                     apigee:url="http://dev.twitter.com/doc/get/statuses/public_timeline"&gt;Returns
                     the 20 most recent statuses, including retweets if they exist,
                     from non-protected users.&lt;/doc&gt;
                     &lt;/method&gt;
                     
                  </div>
               </div>
               <div class="para e258"> The ability to support extensions means that
                  niche capabilities can be inserted into the WADL
                  in a compatible manner. 
               </div>
            </div>
         </div><a name="DocumentationfromWADLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e259" xml:id="WADL2Docs">
            <div class="title e260">Documentation from WADL</div>
            <div class="para e261">A WADL describes a RESTful API in a machine readable
               format. There is often a need, however, for humans to
               study and understand the available methods,
               parameters, and representations the API offers. Rather
               than manually reproducing that information in a
               documentation format and trying to keep these
               synchronized, clearly a literate programming approach
               is called for. 
            </div>
            <div class="para e262">In pursuing our literate program approach, we
               considered extending DocBook with custom markup that
               we could then use to generate WADL. This approach was
               attractive in that it would allow us to make the
               contract author's experience like writing
               documentation. However, we worried that we would be
               reinventing the wheel and would spend too much time
               creating a content model that could be turned into
               WADL. We also felt that we would need to support
               round-tripping between our extended-DocBook and the
               generated WADL. Ultimately, we decided to allow
               authors to embed WADL markup directly in the DocBook.
               To allow for this we: 
               <div class="itemizedlist e263">
                  <div class="listitem e264">
                     <div class="para e265">Added support for certain elements from
                        the WADL namespace in our customization of
                        DocBook.
                     </div>
                  </div>
                  <div class="listitem e266">
                     <div class="para e267">Added steps to our processing pipeline
                        to turn the WADL elements into
                        DocBook.
                     </div>
                  </div>
               </div>In writing the narrative description of
               the API, you can include either pointers to an
               external WADL or literal WADL. The following example
               shows a fragment of our DocBook-variant with a pointer
               to resource/method combination in an external WADL: 
            </div>
            <div class="figure e268" xml:id="docbookWADL" xreflabel="Example 16">
               <div class="title e269">DocBook With WADL Elements</div>
               <div class="programlisting e270" xml:space="preserve">&lt;section&gt;
                  &lt;title&gt;Volume Lists&lt;/title&gt;
                  &lt;para&gt;
                  These operations provide a list of volumes associated
                  with a particular tenant. Volumes contain a status
                  attribute that can be used as an indication of the
                  current volume state.  Volumes with an
                  &lt;code&gt;AVAILABLE&lt;/code&gt; status are available for
                  use.  A volume with an &lt;code&gt;ATTACHED&lt;/code&gt; is
                  currently attached to a server.  Other possible values
                  for the status attribute include:
                  &lt;code&gt;CREATING&lt;/code&gt;,
                  &lt;code&gt;ATTACHING&lt;/code&gt;,
                  &lt;code&gt;DETACHING&lt;/code&gt;,
                  &lt;code&gt;DELETING&lt;/code&gt;,
                  &lt;code&gt;DELETED&lt;/code&gt;,
                  &lt;code&gt;UNKNOWN&lt;/code&gt;, and
                  &lt;code&gt;ERROR&lt;/code&gt;.
                  &lt;/para&gt;
                  &lt;para&gt;
                  The list of volumes may be filtered by type, backup,
                  name, and status via the respective query parameters.
                  When retrieving a list of volumes via the
                  changes-since parameter, the list will contain volumes
                  that have been deleted since the changes-since time
                  (see Section 3.5, in the OpenStack Compute Dev Guide
                  for a description of Changes-Since).
                  &lt;/para&gt;
                  &lt;resources xmlns="http://wadl.dev.java.net/2009/02"&gt;
                  &lt;resource href="os-block-storage-1.0.wadl#Volumes"&gt;
                  &lt;method href="listVolumes"/&gt;
                  &lt;/resource&gt;
                  &lt;/resources&gt;
                  &lt;/section&gt;
                  
                  
               </div>
            </div>
            <div class="para e271">
               
               <div class="itemizedlist e272">
                  <div class="listitem e273">
                     <div class="para e274">The 
                        <div class="code e275">wadl:resources</div> element
                        wraps one or more resources, as it would
                        in a normal wadl. 
                     </div>
                  </div>
                  <div class="listitem e276">
                     <div class="para e277">The 
                        <div class="code e278">wadl:resource</div> element
                        wraps one or more methods and defines the
                        location of the wadl and the
                        
                        <div class="code e279">id</div> of the resource for
                        the methods. 
                     </div>
                  </div>
                  <div class="listitem e280">
                     <div class="para e281">The 
                        <div class="code e282">wadl:method</div> element
                        points to a method defined in the WADL.
                        Each method becomes a 
                        <div class="code e283">section</div>
                        in the resulting DocBook. All of the
                        methods with a common DocBook
                        
                        <div class="code e284">section</div> ancestor become
                        
                        <div class="code e285">section</div>s within that
                        
                        <div class="code e286">section</div>. Alternatively,
                        you can omit the 
                        <div class="code e287">wadl:method</div>
                        and the system will create sections for
                        all of the methods that are children of
                        the resource in the target wadl. 
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e288">To ease the burden on authors, we have created
               schematron rule in a custom framework for the 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e289" xlink:actuate="onRequest" xlink:href="http://www.oxygenxml.com/" xlink:show="new" xlink:type="simple">oXygen
                  editor
               </div> to validate that the references to
               the WADL point to ids in the WADL. 
            </div>
            <div class="para e290">In addition to pointing to resource and method
               combinations, it is also possible to point to a
               resource and have all the methods within that resource
               pulled into the document or to point to the WADL and
               have all of the resources and methods from the WADL
               pulled in. 
            </div>
            <div class="para e291">Finally, instead of pointing to an external WADL,
               the author can simply include the entire
               
               <div class="code e292">wadl:resource</div> and
               
               <div class="code e293">wadl:method</div>(s) in the DocBook
               document directly. 
            </div>
            <div class="para e294"> The following is an image of the section produced
               in PDF result after processing [
               <div class="xref e295" linkend="docbookWADL"></div>]: 
            </div>
            <div class="figure e296">
               <div class="title e297">Resulting WADL PDF Section</div>
               <div class="mediaobject e298">
                  <div class="imageobject e299">
                     <div class="metaBox e300"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e610').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e610" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e300'
                              </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-001.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='75%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e301"> The following is the WADL method that is being
               imported into the DocBook: 
            </div>
            <div class="figure e302" xml:id="WADLDocMethod" xreflabel="Example 18">
               <div class="title e303">WADL Method</div>
               <div class="programlisting e304" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                  &lt;!-- Volume Methods --&gt;
                  &lt;method name="GET" id="listVolumes"&gt;
                  &lt;doc xml:lang="EN" title="List Volumes"&gt;
                  &lt;db:para role="shortdesc"&gt;
                  List all volumes (IDs, names, links).
                  &lt;/db:para&gt;
                  &lt;db:para&gt;
                  A list of volumes. Each volume contains IDs, names, and
                  links -- other attributes are omitted.
                  &lt;/db:para&gt;
                  &lt;/doc&gt;
                  &lt;request&gt;
                  &lt;param name="changes-since" style="query" required="false" type="xsd:dateTime"/&gt;
                  &lt;param name="type" style="query" required="false" type="osapi:UUID"/&gt;
                  &lt;param name="backup" style="query" required="false" type="osapi:UUID"/&gt;
                  &lt;param name="name"   style="query" required="false" type="xsd:string"/&gt;
                  &lt;param name="marker" style="query" required="false" type="osapi:UUID"/&gt;
                  &lt;param name="limit"  style="query" required="false" type="xsd:int"/&gt;
                  &lt;/request&gt;
                  &lt;response status="200 203"&gt;
                  &lt;representation mediaType="application/xml" element="bs:volumes"&gt;
                  &lt;doc xml:lang="EN"&gt;
                  &lt;xsdxt:code href="samples/core/volumes-sparse.xml" /&gt;
                  &lt;/doc&gt;
                  &lt;/representation&gt;
                  &lt;representation mediaType="application/json"&gt;
                  &lt;doc xml:lang="EN"&gt;
                  &lt;xsdxt:code href="samples/core/volumes-sparse.json" /&gt;
                  &lt;/doc&gt;
                  &lt;/representation&gt;
                  &lt;/response&gt;
                  &lt;!-- Common Faults --&gt;
                  &lt;response&gt;
                  &lt;representation mediaType="application/xml" element="bs:blockstorageFault"/&gt;
                  &lt;representation mediaType="application/json"/&gt;
                  &lt;/response&gt;
                  &lt;response status="503"&gt;
                  &lt;representation mediaType="application/xml" element="bs:serviceUnavailable"/&gt;
                  &lt;representation mediaType="application/json"/&gt;
                  &lt;/response&gt;
                  &lt;response status="401"&gt;
                  &lt;representation mediaType="application/xml" element="bs:unauthorized"/&gt;
                  &lt;representation mediaType="application/json"/&gt;
                  &lt;/response&gt;
                  &lt;response status="403"&gt;
                  &lt;representation mediaType="application/xml" element="bs:forbidden"/&gt;
                  &lt;representation mediaType="application/json"/&gt;
                  &lt;/response&gt;
                  &lt;/method&gt;
               </div>
            </div>
            <div class="para e305"> Note that while many of the attributes and elements
               map directly from the WADL representation to the PDF
               rendering, there exist some subtleties: 
            </div>
            <div class="itemizedlist e306">
               <div class="listitem e307">
                  <div class="para e308">Query parameters are rendered in two
                     different ways: Inline with the URI and in the
                     Request Parameters table 
                  </div>
               </div>
               <div class="listitem e309">
                  <div class="para e310">Section, Table, and Example titles are
                     automatically generated based on context. For
                     example, the example title "List Volumes
                     Response: XML" is generated because there is a
                     representation example of mediaType
                     application/xml that is contained within
                     method called "List Volumes". 
                  </div>
               </div>
               <div class="listitem e311">
                  <div class="para e312">Parameter descriptions are also generated
                     based on context. 
                  </div>
               </div>
               <div class="listitem e313">
                  <div class="para e314">Other parameters such as the
                     
                     <div class="code e315">tenantId</div> parameter are
                     implied simply because of the URI the method
                     is associated with. 
                  </div>
               </div>
               <div class="listitem e316">
                  <div class="para e317">Note the use of the 
                     <div class="code e318">xsdxt:code</div>
                     extension to associate an example document
                     with the API response. 
                  </div>
               </div>
            </div>
         </div><a name="WADLNormalizationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e319" xml:id="WADLNorm">
            <div class="title e320">WADL Normalization</div>
            <div class="para e321">As described in 
               <div class="xref e322" linkend="content_reuse"></div>, the
               WADL format includes a number of features that
               facilitate WADL authoring and content reuse. For
               example, when creating a WADL, it is typical to put
               all of the 
               <div class="emphasis e323" role="bold">method</div>
               elements at the end of the document and refer to them
               indirectly from the 
               <div class="emphasis e324" role="bold">resource</div>s where they are used. You can
               link to methods in a separate WADL. Likewise, you can
               define 
               <div class="emphasis e325" role="bold">resource_type</div>
               elements containing various methods and parameters.
               Each 
               <div class="emphasis e326" role="bold">resource</div> can
               then be declared to be of one or more resource types
               to avoid repeated information. Finally, WADLs can
               refer to XSD files to define data types used in the
               WADL. The XSD files in turn often have a modular
               design. While these features facilitate information
               reuse and support "single point of truth" practices, a
               side effect of the indirection is that WADLs can be
               difficult to process. To address this issue, we
               created a 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e327" xlink:actuate="onRequest" xlink:href="https://github.com/rackspace/wadl-tools/" xlink:show="new" xlink:type="simple">WADL normalizer</div> which uses XSLT to flatten
               out the WADL and associated XSDs. In the WADL, for
               example, all references to 
               <div class="code e328">method</div>s and
               
               <div class="code e329">resource_type</div>s are resolved. Further
               processing is therefore greatly simplified. We have
               made this tool available as open source software. 
            </div>
            <div class="para e330">Use cases for the WADL normalizer include:
               <div class="itemizedlist e331">
                  <div class="listitem e332">
                     <div class="para e333">Preparing the WADL for use with tools
                        like 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e334" xlink:actuate="onRequest" xlink:href="http://www.soapui.org/" xlink:show="new" xlink:type="simple">SoapUI</div>. Limitations and bugs
                        in SoapUI cause it to fail if certain
                        features of the WADL are used. For example
                        if you use 
                        <div class="code e335">resource_types</div> or
                        refer to a method in an external WADL,
                        SoapUI cannot load the WADL and throws and
                        exception. 
                     </div>
                  </div>
                  <div class="listitem e336">
                     <div class="para e337">Preparing the WADL before using it to
                        generate human-readable documentation, as
                        described in 
                        <div class="xref e338" linkend="WADL2Docs"></div>.
                     </div>
                  </div>
                  <div class="listitem e339">
                     <div class="para e340">
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e341" xlink:actuate="onRequest" xlink:href="http://www.openrepose.org/" xlink:show="new" xlink:type="simple">Open
                           Repose
                        </div> uses the WADL normalizer as a
                        preprocessing step before using the WADL for
                        validation is discussed in 
                        <div class="xref e342" linkend="validationPipeline"></div>.
                     </div>
                  </div>
               </div>The WADL normalizer is implemented as
               XSLT 2.0 stylesheets. In their current form, the
               stylesheets use modes to take several passes at the
               WADL, but they would benefit from being implemented as
               an 
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e343" xlink:actuate="onRequest" xlink:href="http://xproc.org/" xlink:show="new" xlink:type="simple">XProc</div>
               pipeline. 
            </div>
            <div class="para e344">The WADL normalizer offers a number of options to
               control the formatting of the normalized wadl file,
               summarized by the usage
               below:
               <div class="programlisting e345" xml:space="preserve">dcramer@anatine ~/rax/wadl-tools/src/test/scala (scalaCLI)
                  $ normalizeWadl.sh -?
                  
                  Usage: normalizeWadl.sh [-?fvx] -w wadlFile
                  
                  OPTIONS:
                  -w wadlFile: The wadl file to normalize.
                  -f Wadl format. path or tree
                  path: Format resources in path format, 
                  e.g. &lt;resource path='foo/bar'/&gt;
                  tree: Format resources in tree format, 
                  e.g. &lt;resource path='foo'&gt;&lt;resource path='bar'&gt;...
                  If you omit the -f switch, the script makes no 
                  changes to the structure of the resources.
                  -v XSD Version (1.0 and 1.1 supported, 1.1 is the default)
                  -x true or false. Flatten xsds (true by default).
                  -r keep or omit. Omit resource_type elements (keep by default).
               </div>
            </div>
            <div class="para e346">One of the most important options is the format of
               the resource paths. By default, the normalizer leaves
               the path attributes on the resource elements
               unchanged. So if the source wadl contains a mixture of
               hierarchical and flat path attribute values, these are
               left untouched. In the following code listing, notice
               that some of the resource elements are nested and
               others have multiple items in the path
               attribute:
               <div class="programlisting e347" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                  	     xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
                  &lt;resources base="https://test.api.openstack.com"&gt;
                  &lt;resource path="a/b"&gt;
                  &lt;resource path="c"&gt;
                  &lt;method href="#foo"/&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;resource path="d"&gt;
                  &lt;resource path="e/f"/&gt;
                  &lt;/resource&gt;
                  &lt;resource path="g"/&gt;
                  &lt;resource path="h/i/{j}/k"&gt;
                  &lt;param name="j" style="template" type="xsd:string" required="true"/&gt;
                  &lt;method href="#foo"/&gt;
                  &lt;/resource&gt;
                  &lt;resource path="h/i/{j}/k/l"&gt;
                  &lt;method href="#foo"/&gt;		
                  &lt;/resource&gt;
                  &lt;/resources&gt;
                  &lt;method id="foo"/&gt;
                  &lt;/application&gt;
               </div>However,
               you can also flatten out these paths or expand them so
               that all the resources are nested. Here's the same
               wadl in the 
               <div class="quote e348">path</div>
               format:
               <div class="programlisting e349" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                  	     xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
                  &lt;resources base="https://test.api.openstack.com"&gt;
                  &lt;resource path="a/b/c" id="d12e4"&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;/resource&gt;
                  &lt;resource path="h/i/{j}/k" id="d12e9"&gt;
                  &lt;param xmlns:rax="http://docs.rackspace.com/api" name="j" style="template"
                  	     type="xsd:string"
                  	     required="true"
                  	     rax:id=""/&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;/resource&gt;
                  &lt;resource path="h/i/{j}/k/l" id="d12e12"&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;/resource&gt;
                  &lt;/resources&gt;
                  &lt;method id="foo"/&gt;
                  &lt;/application&gt;
               </div>The
               
               <div class="code e350">rax:id</div> attributes have been added to
               preserve the original ids that could not be duplicated
               in the normalized wadl without making the wadl
               invalid. These are required for down-stream processing
               when we generate documentation from the normalized
               wadl. 
            </div>
            <div class="para e351">You can also expand the flat paths into a fully
               hierarchical tree format. The following example shows
               the same wadl expanded into the tree
               format:
               <div class="programlisting e352" xml:space="preserve">&lt;application xmlns="http://wadl.dev.java.net/2009/02"
                  	     xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
                  &lt;resources base="https://test.api.openstack.com"&gt;
                  &lt;resource path="a"&gt;
                  &lt;resource path="b"&gt;
                  &lt;resource path="c"&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;resource path="d"&gt;
                  &lt;resource path="e"&gt;
                  &lt;resource path="f"/&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;resource path="g"/&gt;
                  &lt;resource path="h"&gt;
                  &lt;resource path="i"&gt;
                  &lt;resource path="{j}"&gt;
                  &lt;param name="j" style="template" type="xsd:string" required="true"/&gt;
                  &lt;resource path="k"&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;resource path="l"&gt;
                  &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;/resource&gt;
                  &lt;/resources&gt;
                  &lt;method id="foo"/&gt;
                  &lt;/application&gt;
               </div>
            </div>
            <div class="para e353">In addition, the normalizer can optionally flatten
               out XSDs by pulling in included XSDs and filtering
               based on the 
               <div class="code e354">vc:minVersion</div> and
               
               <div class="code e355">vc:maxVersion</div> attributes. 
            </div>
            <div class="para e356">Finally, you can optionally filter out
               
               <div class="code e357">resource_type</div> elements from the
               normalized wadls. In some cases, it is useful to
               preserve these element, but they can cause problems
               for certain tools. Therefore a parameter is provided
               filter out the 
               <div class="code e358">resource_types</div>. 
            </div>
         </div>
      </div><a name="TheValidationProblemANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e359" xml:id="validation">
         <div class="title e360">The Validation Problem</div>
         <div class="para e361">
            As a REST service is being developed, the goal is to
            ensure that the documentation accurately matches the
            implementation. Once a REST service reaches a mature
            state, or is released publicly, the documentation becomes
            a contract; both clients and alternate implementations use
            this contract to guide their development. Iteroperability
            between all parties requires that both the documentation
            and the implementation remain stable, even in the face of
            bug fixes, upgrades, enhancements, and the introduction of
            new features via extensions.
            
         </div>
         <div class="para e362">
            In the presence of these changes, there always exist the
            possibility that either the implementation or its docs may
            inadvertently drift from one another.  This drift often
            introduces incompatibilities that can cause clients to
            fail. Thus, it's important to constantly test that the
            implementation and its documentation conform to one
            another. Unfortunately, our quality engineering teams are
            often not focused on document conformance, or on the
            intricate details of the REST/HTTP aspects of the
            service. Instead, these teams are focused on the
            functionality of the service itself.  It's been our
            experience that a number of incompatibilities often slip
            through the cracks as a result. What's more, because this
            focus on functional testing has little to no regard to
            documentation of the service, we've found cases where both
            the implementation and its tests drift away from the docs
            simultaneously.  Adding to the complexity is the fact that
            service developers tend to allow their implementations to
            be flexible and loose when accepting messages from clients
            — this means that conformance and functional tests
            themselves may inadvertently drift from the service
            contract without notice.
            
         </div>
         <div class="para e363">
            One of our main goals is to better incorporate the
            documentation in the testing process in an automated
            way. The idea is to use the documentation pipeline to
            generate validation rules that can be checked in a layer
            between the function tests and the service itself. This is
            illustrated in 
            <div class="xref e364" linkend="valid"></div>.
            
         </div>
         <div class="figure e365" xml:id="valid">
            <div class="title e366">A REST validator</div>
            <div class="mediaobject e367">
               <div class="imageobject e368">
                  <div class="metaBox e369"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e754').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e754" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e369'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e370">
            Here, the validator intercepts requests from the
            functional tests before they reach the service and check
            them for strict conformance to the documentation.
            Likewise, the validator intercepts the response for the REST
            service and also validates them. There are several
            advantages to taking this approach:
            
            <div class="itemizedlist e371">
               <div class="listitem e372">
                  <div class="para e373">
                     Because the validation rules are generated
                     directly from the documentation, we can ensure
                     that the validator is strictly accurate with
                     conformance to the docs.
                     
                  </div>
               </div>
               <div class="listitem e374">
                  <div class="para e375">
                     Because the validator sits between the
                     functional tests and the service itself, it
                     can be used to check for drift by both parties
                     simultaneously.
                     
                  </div>
               </div>
               <div class="listitem e376">
                  <div class="para e377">
                     The technique can be easily incorporated into
                     existing services — it does not require
                     changes to existing functional tests.                  
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="ValidatingRESTwithAutomataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e378" xml:id="language">
         <div class="title e379">Validating REST with Automata</div>
         <div class="para e380">
            Given any possible HTTP message, the validator in 
            <div class="xref e381" linkend="valid"></div> needs to be able to tell the difference
            between an HTTP message that meets all of the criteria
            defined in the documentation, from an HTTP message that
            does not.  In other words, the validator must accept the
            subset of all HTTP messages that are valid according to
            the description in the source document. The validator also
            needs to categorize those messages that are not valid
            according to the error code that should be generated by
            the underlying REST service, so that the error code that
            the REST service produces can also be verified.
            
         </div>
         <div class="para e382">
            Accepting messages that meet some criteria is a common
            problem in computer science. One technique for solving the
            problem is to utilize an automaton. An automaton is a
            state machine that transitions from an initial
            
            <div class="emphasis e383">start</div> state to other states based on
            the current input. If after the message is read the
            machine is in an 
            <div class="emphasis e384">accept</div> state, then
            the message is accepted, otherwise the message does not
            meet the required criteria.
            
         </div>
         <div class="para e385">
            The idea behind our validators is to translate
            documentation in the form of a WADL (either stand-alone or
            extracted from the contents of a RackBook document), into a
            representation of an automaton that can be used to
            validate messages as they are intercepted between
            functional tests and the REST service.
            
         </div>
         <div class="para e386">
            An example automata is illustrated in 
            <div class="xref e387" linkend="automaton"></div>.
            
         </div>
         <div class="figure e388" xml:id="automaton">
            <div class="title e389">A REST Automaton</div>
            <div class="mediaobject e390">
               <div class="imageobject e391">
                  <div class="metaBox e392"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e794').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e794" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e392'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='70%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e393">
            For simplicity, the automaton above is only checking for
            conformance to the URL path and the HTTP method.  In this
            particular API, the only allowed operation is a GET on the
            path /path/to/record/{date}, where {date} is an xs:date as
            defined by W3C XML Schema 
            <div class="xref e394" linkend="W3CSchema2010"></div>. The start state is S0. There are
            three accept states:
            
            <div class="orderedlist e395">
               <div class="listitem e396">
                  <div class="para e397">
                     SA: accepts HTTP messages that follow the
                     constraints defined by the API.
                     
                  </div>
               </div>
               <div class="listitem e398">
                  <div class="para e399">
                     d30U: accepts HTTP messages for which a 404
                     (Not Found) response should be expected from
                     the REST service.
                     
                  </div>
               </div>
               <div class="listitem e400">
                  <div class="para e401">
                     d30M: accepts HTTP messages for which a 405
                     (Method Not Allowed) should be expected.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e402">
            Starting at state S0, the process examines the URL path,
            one path segment at a time. The HTTP method is not
            accessible until the path has been completely parsed. The
            transition from one state to another is based on input
            matches, except in the case of an ε transition,
            where a state is advanced without regard to the current
            input.  In the machine above, U(x) matches the current URL
            path segment to x, where x may be a regular expression or
            a QName representing an XML Schema simple type. U!(x),
            matches an URL segment that is 
            <div class="emphasis e403">not</div>
            accepted by x. On a successful match the URL path is
            advanced to the next path element.  After the URL path is
            completely read, the machine proceeds to read the HTTP
            Method. Here, M(x) and M!(x), work the same as U(x) and
            U!(x), except they match against the HTTP method instead
            of the URL path segment. Because the automaton is only
            checking for URL paths and Methods the process ends after
            the HTTP method has been read.
            
         </div>
         <div class="para e404">
            
            <div class="xref e405" linkend="inputTable"></div> illustrates the states that are
            transitioned based on an example set of inputs.
            
         </div>
         <div class="table e406" xml:id="inputTable">
            <div class="caption e407">
               <div class="para e408"> Sample input to the automaton on 
                  <div class="xref e409" linkend="automaton"></div>
               </div>
            </div>
            <div class="thead e410">
               <div class="tr e411">
                  <div class="td e412">Input</div>
                  <div class="td e413">States Traveled</div>
                  <div class="td e414">Result</div>
               </div>
            </div>
            <div class="tbody e415">
               <div class="tr e416">
                  <div class="td e417">GET /path/to/record/2001-01-02</div>
                  <div class="td e418">S0, d18e4, d18e5, d18e6, d18e7, d18e9, SA</div>
                  <div class="td e419">200 Okay</div>
               </div>
               <div class="tr e420">
                  <div class="td e421">GET /my/path/</div>
                  <div class="td e422">S0, d30U, d30U, d30U</div>
                  <div class="td e423">404 Not Found</div>
               </div>
               <div class="tr e424">
                  <div class="td e425">PUT /path/to/record/2001-01-02</div>
                  <div class="td e426">S0, d18e4, d18e5, d18e6, d18e7, d30M</div>
                  <div class="td e427">405 Bad Method</div>
               </div>
            </div>
         </div>
      </div><a name="TheCheckerFormatANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e428" xml:id="checker">
         <div class="title e429">The Checker Format</div>
         <div class="para e430">
            REST Automata are internally represented by an XML format,
            which we call the 
            <div class="emphasis e431">checker format</div>. An
            instance document in this format is illustrated in 
            <div class="xref e432" linkend="checkerFormat"></div>.
            
         </div>
         <div class="figure e433" xml:id="checkerFormat">
            <div class="title e434">A representation of the automaton from 
               <div class="xref e435" linkend="automaton"></div> in checker format.
            </div>
            <div class="programlisting e436" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               &lt;checker xmlns="http://www.rackspace.com/repose/wadl/checker"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               &lt;step id="S0" type="START" next="d18e4 SE1 d21e2u"/&gt;
               &lt;step type="URL_FAIL" id="d21e2u" notMatch="path"/&gt;
               &lt;step type="URL" id="d18e4" match="path" next="d18e5 SE1 d21e3u"/&gt;
               &lt;step type="URL_FAIL" id="d21e3u" notMatch="to"/&gt;
               &lt;step type="URL" id="d18e5" match="to" next="d18e6 SE1 d21e4u"/&gt;
               &lt;step type="URL_FAIL" id="d21e4u" notMatch="record"/&gt;
               &lt;step type="URL" id="d18e6" match="record" next="d18e7 SE1 d21e5u"/&gt;
               &lt;step type="URL_FAIL" id="d21e5u" notTypes="xs:date"/&gt;
               &lt;step type="URLXSD"
               id="d18e7"
               match="xs:date"
               label="date"
               next="d18e9 d21e6m SE0"/&gt;
               &lt;step type="METHOD_FAIL" id="d21e6m" notMatch="GET"/&gt;
               &lt;step type="METHOD" id="d18e9" match="GET" next="SA"/&gt;
               &lt;step id="SE0" type="URL_FAIL"/&gt;
               &lt;step id="SE1" type="METHOD_FAIL"/&gt;
               &lt;step id="SA" type="ACCEPT"/&gt;
               &lt;/checker&gt;
               
            </div>
         </div>
         <div class="para e437">
            This simple, terse, document type maps each state in the
            state machine, along with the edges that it connects to,
            into a single step element. All steps in the checker
            format contain an id attribute of type xs:ID which
            uniquely identifies the step in the machine and a type
            attribute which indicates the type of check the step
            performs. Note, that in 
            <div class="xref e438" linkend="checkerFormat"></div>,
            there are two types of URL checks: the steps that check a
            path segment against a regular expression are of type URL,
            and those that check the segment against a simple XML
            Schema type are of type URLXSD.  Connections between steps
            are represented by a next attribute of type
            xs:IDREFs. Additionally, most steps also contain a match
            or notMatch attribute that provides the details of how the
            a match is interpreted.
            
         </div>
         <div class="para e439">
            Currently there exist steps to match against all aspects
            of the HTTP request, including steps that match against
            request media types, that check the well formness of XML
            and JSON content, that validate XML via an W3C XML Schema
            (XSD) 1.1 validator and that check for the presence of
            required elements by means of XPath expressions. Note that
            this is particularly important because a REST service may
            define many different types of elements, the element
            attribute in a representation binds an element to a
            particular operation — and this is enforced via an
            XPath expression step in the machine.
            
         </div>
         <div class="para e440">
            Another important checker step is the XSLT step, which
            performs a transformation of the request message before it
            is validated by the XSD step.  It may seem odd to that an
            XSLT transform may be required for validation, but the
            requirement comes into play in cases where the type of the
            request document needs to be restricted (or extended)
            based on the operation being performed.  Let's say, for
            example, that a REST API dealing with Widgets allows a
            Widget to have all attributes when performing a PUT
            operation, but restricts the POST operation to Widget
            documents containing only a subset of the available
            attributes — this is a common pattern in REST
            services.  The restriction on POST is specified in the
            WADL in 
            <div class="xref e441" linkend="WidgetWADL"></div>.
            
         </div>
         <div class="figure e442" xml:id="WidgetWADL">
            <div class="title e443">Widget WADL</div>
            <div class="programlisting e444" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               
               &lt;application xmlns="http://wadl.dev.java.net/2009/02"
               xmlns:widget="http://rackspace.com/sample/widget"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               &lt;grammars&gt;
               &lt;include href="widget.xsd"&gt;&lt;/include&gt;
               &lt;/grammars&gt;
               &lt;resources base="http://localhost/"&gt;
               &lt;resource path="widget"&gt;
               &lt;param style="template" type="xs:date" name="date"/&gt;
               &lt;!-- The PUT operation allows all widgets as request
               representation. --&gt;
               &lt;method name="PUT"&gt;
               &lt;request&gt;
               &lt;representation mediaType="application/xml" element="widget:widget"/&gt;
               &lt;/request&gt;
               &lt;response&gt;
               &lt;representation mediaType="applicaiton/xml" element="widget:widget"/&gt;
               &lt;/response&gt;
               &lt;/method&gt;
               &lt;!-- The POST operation allows only widgets of the restricted type WidgetForCreate
               --&gt;
               &lt;method name="POST"&gt;
               &lt;request&gt;
               &lt;representation mediaType="application/xml" element="widget:widget"&gt;
               &lt;param style="plain" path="/widget:widget" type="widget:WidgetForCreate"/&gt;
               &lt;/representation&gt;
               &lt;/request&gt;
               &lt;response&gt;
               &lt;representation mediaType="applicaiton/xml" element="widget:widget"/&gt;
               &lt;/response&gt;
               &lt;/method&gt;
               &lt;/resource&gt;
               &lt;/resources&gt;
               &lt;/application&gt;
               
            </div>
         </div>
         <div class="para e445">
            Note that we use a WADL plain parameter (described in
            
            <div class="xref e446" linkend="grammar_aug"></div>) to connect a restricted
            type (which prohibits a number of attributes) of the
            Widget to the POST operation, by specifying the
            WidgetForCreate type and an XPath of where the type should
            apply. In the automaton, this is translated into an XSLT
            step that modifies the request document by adding an
            xsi:type parameter, thus informing the validator to
            validate the contents of the Widget message as an instance
            of the restricted type. In this case, the restriction is
            made in the root document, but these types of restrictions
            can be placed on any element in an XML document.
            
         </div>
         <div class="figure e447" xml:id="WidgetBefore">
            <div class="title e448">Widget Request (before XSLT step)</div>
            <div class="programlisting e449" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               
               &lt;widget xmlns="http://rackspace.com/sample/widget"
               name="MyWidget"/&gt;
               
            </div>
         </div>
         <div class="figure e450" xml:id="WidgetAfter">
            <div class="title e451">Widget Request (after XSLT step)</div>
            <div class="programlisting e452" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               
               &lt;widget xmlns="http://rackspace.com/sample/widget"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               name="MyWidget"  xsi:type="WidgetForCreate"/&gt;
               
            </div>
         </div>
      </div><a name="OptimizationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e453" xml:id="optimization">
         <div class="title e454">Optimization</div>
         <div class="para e455">
            The automata created to validate REST services may be
            quite complex, often involving many states and
            connections. As an example, 
            <div class="xref e456" linkend="compute"></div>
            illustrates the automaton for validating the OpenStack
            Compute API (excluding extensions).
            
         </div>
         <div class="figure e457" xml:id="compute">
            <div class="title e458">OpenStack compute API Automaton</div>
            <div class="mediaobject e459">
               <div class="imageobject e460">
                  <div class="metaBox e461"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e912').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e912" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e461'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-004.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e462">
            Optimization stages may be introduced into the
            transformation process to try to reduce the number of
            states in the automaton. Each optimization stage is simply
            an XSLT that takes a checker document as input and creates
            a checker document with less states as output.
            Optimization stages can therefore be chained together.
            With each stage, the checker document produced should
            perform the exact same function as the original
            unoptimized one.
            
         </div>
         <div class="para e463">
            Currently, optimization stages work by compressing
            redundant (or nondistinguishable) states into a single
            state. Redundant states occur quite frequently because the
            translation code that converts a WADL to a checker
            document does so without regard to the number of states
            produce in order to keep the translation code simple. 
            <div class="xref e464" linkend="compute-nodups"></div> illustrates the effect of
            running these optimization stages on the compute API.
            Note that the number of states is reduced dramatically.
            
         </div>
         <div class="figure e465" xml:id="compute-nodups">
            <div class="title e466">OpenStack compute API Automaton (Optimized)</div>
            <div class="mediaobject e467">
               <div class="imageobject e468">
                  <div class="metaBox e469"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e924').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e924" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e469'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-005.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e470">
            Other optimization techniques are possible.  For example
            an optimization stage may:
            
            <div class="itemizedlist e471">
               <div class="listitem e472">
                  <div class="para e473">
                     Convert the simple type checks in URLXSD steps
                     into regular expression URL steps.
                     
                  </div>
               </div>
               <div class="listitem e474">
                  <div class="para e475">
                     Compress multiple regular extension checks
                     into a single check.
                     
                  </div>
               </div>
               <div class="listitem e476">
                  <div class="para e477">
                     Compress multiple boolean XPath expressions
                     into a single expression.
                     
                  </div>
               </div>
               <div class="listitem e478">
                  <div class="para e479">
                     Compress XPath expressions, XSLT
                     transformations, and XSD schema validation
                     into a single schema aware XSLT transform
                     step.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="TheValidationPipelineANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e480" xml:id="validationPipeline">
         <div class="title e481">The Validation Pipeline</div>
         <div class="para e482">
            The validation pipeline is responsible for producing REST
            automata from WADLs. The pipeline is illustrated in
            
            <div class="xref e483" linkend="pipeline"></div>.
            
         </div>
         <div class="figure e484" xml:id="pipeline">
            <div class="title e485">Validation Pipeline</div>
            <div class="mediaobject e486">
               <div class="imageobject e487">
                  <div class="metaBox e488"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e953').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e953" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e488'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Williams01/Williams01-006.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='80%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e489">
            The first three parts of the pipeline are shared with our
            general documentation pipeline.  The stages utilize XProc,
            XSLT2, and XSD 1.1 to generate the final checker document.
            The final stage, creates an immutable data structure from
            this document that is used by the Repose WADL proxy
            component to process and validate API requests within the
            Repose HTTP proxy. This stage is implemented by means of a
            specialized 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e490" xlink:actuate="onRequest" xlink:href="http://www.saxproject.org/" xlink:show="new" xlink:type="simple">SAX</div>
            handler. The data structure the handler produces is
            essentially a model of the automaton that can be executed
            by the Repose component when validating request. The
            process for validating HTTP request with the data
            structure avoids the use of global state, meaning that
            most context is passed via the call stack. Because of
            this, and because the internal data structure is
            immutable, the entire process is thread safe, meaning that
            it can validate multiple HTTP request simultaneously in
            different threads of execution.
            
         </div>
         <div class="para e491">
            It's important to note that the validation pipeline above
            is a prepossessing step.  Once the immutable data
            structure is create it can be used to handle many HTTP
            request simultaneously, at run-time, and in an efficient
            manner.
            
         </div>
         <div class="para e492">
            Another note is that the stages in the validation pipeline
            are configurable. There are configuration options that
            dictate:
            
            <div class="itemizedlist e493">
               <div class="listitem e494">
                  <div class="para e495">
                     The strictness of the validation — which
                     itself is determined by which validation steps
                     should be added to the final checker.
                     
                  </div>
               </div>
               <div class="listitem e496">
                  <div class="para e497">
                     Specialized options for each individual
                     steps. For example, should an XPath version 2
                     implementation be used in an XPath step?
                     Should Saxon EE or Xerces be used for XSD 1.1
                     validation in the XSD step?
                     
                  </div>
               </div>
               <div class="listitem e498">
                  <div class="para e499">
                     The optimization stages to use.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="OtherUseCasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e500" xml:id="usecases">
         <div class="title e501">Other Use Cases</div>
         <div class="para e502"> The initial goal for creating validators from REST
            documentation is described in 
            <div class="xref e503" linkend="validation"></div>, however, once an implementation of the validation
            pipeline was created, it became evident that the pipeline
            can be used to solve other problems. Some of these
            additional use cases are described below. 
         </div><a name="FilteringandErrorReportingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e504" xml:id="filtering">
            <div class="title e505">Filtering and Error Reporting</div>
            <div class="para e506">
               REST services receive many millions of HTTP requests a
               day. Many of these requests are malformed — the
               result of user errors. Because a validator can detect
               malformed requests, it can filter these from the
               underlying REST implementation. What's more, the
               validator has enough context to respond with an
               appropriate error message.  For example, rather than
               responding with simply a 404 (Not Found), the
               validator can respond with:
               404 /path/to/widget not found, expecting "server |
               image" instead of "widget".
               
            </div>
            <div class="para e507">
               Our implementation has added support to this
               capability and it has proved useful.
               
            </div>
         </div><a name="AuthorizationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e508" xml:id="authz">
            <div class="title e509">Authorization</div>
            <div class="para e510">
               Often different sets of users can access different
               parts of the API. For example, administrators may have
               the capability to reboot a server, but regular users
               may not.  The idea here is to build on the filtering
               capabilities in the previous section and assign
               different sets of users different validators, so that
               administrators have a validator that accepts the
               reboot operation, and regular users have a validator
               that does not.  The interesting thing about this
               use case is that the WADL becomes an authorization
               policy file.
               
            </div>
         </div><a name="APICoverageANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e511" xml:id="coverage">
            <div class="title e512">API Coverage</div>
            <div class="para e513">
               Validators are capable of logging what the stages in
               the automaton have been visited. This information can
               be used to compute test coverage. If there are states
               in the automaton that are not visited by functional
               tests, then the functional tests are obviously missing
               something. Also, in production, the information can be
               used to gain insight into what parts of an API are
               frequently accessed by users.
               
            </div>
         </div>
      </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e514" xml:id="Conclusions">
         <div class="title e515">Conclusions</div>
         <div class="para e516">
            In this paper, we described the process by which we used
            an existing documentation pipeline for documenting REST
            APIs and extend it to support the creation of validators
            that can help confirm that the documentation accurately
            reflects reality or that an implementation does not drift
            from what's stated in the docs.
            
         </div>
         <div class="para e517">
            We took an intermediary approach for performing validation,
            where messages are intercepted between client and server
            applications and an automata-based programming approach
            that enabled the efficient validation of messages at
            run-time.  The technique opened up other use cases such as
            filtering, accurate error reporting, authorization, and
            API coverage. We feel that a main key to the success of
            the project was in choosing a tag set that semantically
            described all aspects of a RESTful service and contained
            author friendly features.
            
         </div>
         <div class="para e518">
            In the next sections we describe some of the challenges we
            encountered while developing the validation pipeline and
            discuss some possible future extensions to the pipeline.
            
         </div><a name="ChallengesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e519" xml:id="Challenges">
            <div class="title e520">Challenges</div><a name="XSD11earlyadoptionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e521" xml:id="XSD11">
               <div class="title e522">XSD 1.1, early adoption</div>
               <div class="para e523">
                  Because OpenStack APIs are extensible, describing the
                  XML media types with XSD 1.0 was not an option, we
                  need the new open content features that are now
                  offered by the XSD 1.1 standard. Since OpenStack is an
                  open and free platform, we have the goal of ensuring
                  that everything that we develop remains open and
                  accessible to the community, while still remaining
                  friendly to enterprise customers. To that end we
                  decided that our validators should support both the
                  Xerces (open source) and the Saxon EE (proprietary)
                  XSD 1.1 implementations.
                  
               </div>
               <div class="para e524">
                  We've had great success in ensuring that our
                  validators interoperate with both implementations
                  seamlessly, however, during the development of the
                  pipeline we have encountered a number of errors with
                  the Xerces implementation.  In fairness, the Xerces
                  implementation is still labeled BETA, and the Xerces
                  team has done a great job of resolving most of the
                  issues we've discovered thus far. The major challenge,
                  for us however, is we've come to rely on XSD 1.1
                  features when there is yet a full, production ready,
                  and free open source XSD 1.1 implementation.
                  
               </div>
            </div><a name="ParsingXPathsinXSLT2ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e525" xml:id="XPath">
               <div class="title e526">Parsing XPaths in XSLT 2</div>
               <div class="para e527">
                  WADL makes references to XPaths when describing plain
                  parameters. These XPaths need to be successfully
                  copied as they proceed along the validation
                  pipeline. Ensuring that the XPaths remain in tact
                  under all circumstances has proved difficult given
                  that there may be conflicts with namespace prefixes,
                  or worst, contention for the default namespace.
                  
               </div>
               <div class="para e528">
                  Our implementation makes a best effort to keep XPath
                  valid, but there are still some edge cases that trip
                  it up. We are debating whether to create an XSLT
                  extension that will enable us to leverage an XPath 2
                  parser, or to write our own XPath 2 parser in XSLT to
                  resolve the issue.
                  
               </div>
            </div><a name="TestingTheValidationPipelineANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e529" xml:id="testing">
               <div class="title e530">Testing The Validation Pipeline</div>
               <div class="para e531">
                  An early challenge that we encountered was that we
                  needed to develop a method of testing the
                  validation pipeline. Because validation and our
                  documentation pipeline both rely on the WADL
                  normalizer, it is important to ensure that the
                  output of the normalizer accurately reflects the
                  intent of the original WADL author. To avoid
                  regressions as we add new features, we implemented
                  a functional testing framework that takes
                  advantage of the xml features of Scala to perform
                  transformations on simple WADLs and WADL+XSD
                  combinations and compare those with the expected
                  result. The following code sample shows one of
                  these tests.
                  
               </div>
               <div class="figure e532" xml:id="WADLTest">
                  <div class="title e533">A WADL normalizer test</div>
                  <div class="programlisting e534" xml:space="preserve">scenario ("The original WADL is in mixed path/tree format"){
                     	given("a WADL with resources in mixed path/tree format")
                     	val inWADL =
                     &lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource path="a/b"&gt;
                     &lt;resource path="c"&gt;
                     	&lt;method href="#foo"/&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;resource path="d"&gt;
                     &lt;resource path="e/f"/&gt;
                     &lt;/resource&gt;
                     &lt;resource path="g"/&gt;
                     &lt;resource path="h/i/{j}/k"&gt;
                     &lt;param name="j" style="template" type="xsd:string" required="true"/&gt;
                     &lt;method href="#foo"/&gt;
                     &lt;/resource&gt;
                     &lt;resource path="h/i/{j}/k/l"&gt;
                     &lt;method href="#foo"/&gt;		
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;method id="foo"/&gt;
                     &lt;/application&gt;
                     	val treeWADL = 
                     &lt;application xmlns="http://wadl.dev.java.net/2009/02"
                     xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
                     &lt;resources base="https://test.api.openstack.com"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="a"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="b"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="c"&gt;
                     &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="d"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="e"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="f"/&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="g"/&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="h"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="i"&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="{j}"&gt;
                     &lt;param name="j" style="template" type="xsd:string" required="true" 
                     repeating="false"/&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="k"&gt;
                     &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                     &lt;resource queryType="application/x-www-form-urlencoded" path="l"&gt;
                     &lt;method xmlns:rax="http://docs.rackspace.com/api" rax:id="foo"/&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resource&gt;
                     &lt;/resources&gt;
                     &lt;method id="foo"/&gt;
                     &lt;/application&gt;
                     when("the WADL is normalized")
                     val normWADL = wadl.normalize(inWADL, TREE)
                     then("the resources should now be in tree format")
                     canon(treeWADL) should equal (canon(normWADL))
                     }
                  </div>
               </div>
               <div class="para e535">
                  Notice that the test infrastructure supports the
                  scenario/given/when/then format of behavioral driven
                  development.
                  
               </div>
            </div>
         </div><a name="FutureWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e536" xml:id="FutureWork">
            <div class="title e537">Future Work</div>
            <div class="para e538">
               The goal described in 
               <div class="xref e539" linkend="validation"></div> is
               not entirely complete because we are still missing
               considerable checks on the HTTP response generated by
               the REST service. We plan on extending the automata to
               account for this.  Additionally, we plan on adding
               JSONPath and JSON Schema stages as only JSON
               well formness is currently tested. We also plan on
               adding support for other validation languages in XML
               such as RelaxNG and Schematron.  Finally, we plan to
               pursue some of the extended use cases we discussed in
               
               <div class="xref e540" linkend="usecases"></div> such as authorization and
               API coverage.
               
            </div>
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e541">
         <div class="title e542">Bibliography</div>
         <div class="bibliomixed e543" xml:id="ApigeeWADL2012" xreflabel="ApigeeWADL2012">
            Apigee. 
            <div class="emphasis e544" role="ital">The Apigee WADL Library</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e545" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://github.com/apigee/wadl-library</div>
            
         </div>
         <div class="bibliomixed e546" xml:id="Fielding2000" xreflabel="Fielding2000">
            Fielding, Roy Thomas.  
            <div class="emphasis e547" role="ital">Architectural
               Styles and the Design of Network-based Software
               Architectures.
            </div> 2000. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e548" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm.</div>
            
         </div>
         <div class="bibliomixed e549" xml:id="Steiner2007" xreflabel="Steiner2007">
            T. Steiner. 
            <div class="emphasis e550" role="ital">Automatic Multi Language
               Program Library Generation for REST APIs
            </div> Master
            Thesis, Institute for Algorithms and Cognitive Systems
            University of Karlsruhe. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e551" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.lsi.upc.edu/~tsteiner/papers/2007/automatic-multi-language-program-library-generation-for-rest-apis-masters-thesis-2007.pdf</div>
            
         </div>
         <div class="bibliomixed e552" xml:id="hREST2008" xreflabel="hREST2008">
            Kopecky, J., Gomadam, K., Vitvar, T.: 
            <div class="emphasis e553" role="ital">hRESTS: an HTML Microformat for Describing RESTful Web Services</div>. In: The 2008 IEEE/WIC/ACM International Conference on Web Intelligence (WI2008),
            Sydney, Australia, IEEE CS Press
            (November 2008)
            
         </div>
         <div class="bibliomixed e554" xml:id="JSONPath2008" xreflabel="JSONPath2008">
            Goessner S. 
            <div class="emphasis e555" role="ital">JSONPath - XPath for
               JSON
            </div> 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e556" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://goessner.net/articles/JsonPath/</div>
            
         </div>
         <div class="bibliomixed e557" xml:id="Jaxrs2009" xreflabel="Jaxrs2009">
            M. Hadley and P. Sandoz, 
            <div class="emphasis e558" role="ital">JAX-RS:
               Java API for RESTful Web Services
            </div>, Java
            Specification Request (JSR), vol. 311, 2009. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e559" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jcp.org/en/jsr/detail?id=311.</div>
            
         </div>
         <div class="bibliomixed e560" xml:id="Launchpad2012" xreflabel="Launchpad2012">
            Launchpad.  
            <div class="emphasis e561" role="ital">Hacking the Launchpad
               web service
            </div> 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e562" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://help.launchpad.net/API/Hacking</div>
            
         </div>
         <div class="bibliomixed e563" xml:id="Mashery2009" xreflabel="Mashery2009">
            Mashery.; 
            <div class="emphasis e564" role="ital">Mashery: Untold Secrets
               Behind Managing an API 
            </div>
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e565" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.readwriteweb.com/archives/mashery_secrets_behind_managing_an_api.php</div>
            
         </div>
         <div class="bibliomixed e566" xml:id="O2007" xreflabel="O2007">
            L. Richardson and S. Ruby. 
            <div class="emphasis e567" role="ital">RESTful Web Services</div>. O’Reilly Media, Inc., May 2007.
            
         </div>
         <div class="bibliomixed e568" xml:id="O2010" xreflabel="O2010">
            Allamaraju, S., and Amudsen, M. 
            <div class="emphasis e569" role="ital">RESTful Web Services
               Cookbook.
            </div> O’Reilly. 2010.
            
         </div>
         <div class="bibliomixed e570" xml:id="O2011" xreflabel="O2011">
            Webber, J., Parastatidis, S., Robinson, I.: 
            <div class="emphasis e571" role="ital">REST in Practice: Hypermedia and
               Systems Architecture.
            </div> O’Reilly &amp; Associates, Sebastopol (2010).
            
         </div>
         <div class="bibliomixed e572" xml:id="Maleshkova2009" xreflabel="Maleshkova2009">
            Maria Maleshkova, Jacek Kopecky, and Carlos Pedrinaci. 
            <div class="emphasis e573" role="ital">Adapting SAWSDL for Semantic Annotations of RESTful Services.</div> In Workshop: Beyond SAWSDL at OnTheMove Federated Conferences &amp; Workshops, 2009.
            
         </div>
         <div class="bibliomixed e574" xml:id="Swager2011" xreflabel="Swager2011">
            Swagger.  
            <div class="emphasis e575" role="ital">Swagger Specification.</div> 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e576" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://swagger.wordnik.com/spec</div>
            
         </div>
         <div class="bibliomixed e577" xml:id="Takase2008" xreflabel="Takase2008">
            T. Takase, S. Makino, S. Kawanaka, K. Ueno, C. Ferris, and A. Ryman, 
            <div class="emphasis e578" role="ital">Definition Languages for RESTful Web Services: WADL vs. WSDL 2.0</div>, IBM Reasearch, 2008
            
         </div>
         <div class="bibliomixed e579" xml:id="WADL2Java2008" xreflabel="WADL2Java2008">
            WADL2Java.  wadl2java Tool Documentation. http://wadl.java.net/wadl2java.html
            
         </div>
         <div class="bibliomixed e580" xml:id="WSDL2007" xreflabel="WSDL2007">
            Chinnici R., Moreau J., Ryan A., and  Weerawarana S. 
            <div class="emphasis e581" role="ital">Web
               Services Description Language (WSDL) Version 2.0.
            </div> June
            2007. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e582" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/wsdl20/</div>
            
         </div>
         <div class="bibliomixed e583" xml:id="W3CSchema2010" xreflabel="W3CSchema2010">
            Gao S., Sperberg-McQueen C. M, and Thompson H. 
            <div class="emphasis e584" role="ital">W3C XML
               Schema Definition Language (XSD)
            </div>. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e585" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema11-1/</div>
            
         </div>
         <div class="bibliomixed e586" xml:id="Hadley2009" xreflabel="Hadley2009">
            M. Hadley.; 
            <div class="emphasis e587" role="ital">Web Application Description Language</div>
            W3C Member Submission. August 2009
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e588" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/Submission/wadl/</div>
            
         </div>
      </div>
   </div>
</div>