<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#OptimizedCartesianproduct:AhybridapproachtoderivationchaincheckinginXSD11ANCHOR" name="OptimizedCartesianproduct:AhybridapproachtoderivationchaincheckinginXSD11TOC">Optimized Cartesian product: A hybrid approach to derivation-chain checking in XSD
               1.1</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XSD11andCoConstraintsANCHOR" name="XSD11andCoConstraintsTOC">XSD 1.1 and Co-Constraints</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AssertionsANCHOR" name="AssertionsTOC">Assertions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ConditionalTypeAssignmentANCHOR" name="ConditionalTypeAssignmentTOC">Conditional Type Assignment</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XSDTerminologyANCHOR" name="XSDTerminologyTOC">XSD Terminology</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DerivationbyRestrictioninXSD11ANCHOR" name="DerivationbyRestrictioninXSD11TOC">Derivation by Restriction in XSD 1.1</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FullStaticApproachANCHOR" name="FullStaticApproachTOC">Full Static Approach</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExpressivityLimitationApproachANCHOR" name="ExpressivityLimitationApproachTOC">Expressivity Limitation Approach</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FullDynamicApproachANCHOR" name="FullDynamicApproachTOC">Full Dynamic Approach</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RuntimeCheckANCHOR" name="RuntimeCheckTOC">Run-time Check</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AnAlgorithmforRunTimeCheckANCHOR" name="AnAlgorithmforRunTimeCheckTOC">An Algorithm for Run-Time Check</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RTCAlgorithmCostAnalysisANCHOR" name="RTCAlgorithmCostAnalysisTOC">RTC Algorithm Cost Analysis</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#HybridApproach:CartesianProductANCHOR" name="HybridApproach:CartesianProductTOC">Hybrid Approach: Cartesian Product</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OptimizedCartesianProductANCHOR" name="OptimizedCartesianProductTOC">Optimized Cartesian Product</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#GeneralideaANCHOR" name="GeneralideaTOC">General idea</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OCPStaticPhaseANCHOR" name="OCPStaticPhaseTOC">OCP Static Phase</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OCPRunTimePhaseANCHOR" name="OCPRunTimePhaseTOC">OCP Run-Time Phase</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OCPCostAnalysisANCHOR" name="OCPCostAnalysisTOC">OCP Cost Analysis</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OCPStaticPhaseAnalysisANCHOR" name="OCPStaticPhaseAnalysisTOC">OCP Static Phase Analysis</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#OCPRunTimePhaseAnalysisANCHOR" name="OCPRunTimePhaseAnalysisTOC">OCP Run-Time Phase Analysis</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ComparingCPOCPandRTCANCHOR" name="ComparingCPOCPandRTCTOC">Comparing CP, OCP, and RTC</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC">Implementation</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RelatedWorksANCHOR" name="RelatedWorksTOC">Related Works</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgementsANCHOR" name="AcknowledgementsTOC">Acknowledgements</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">annotate-type-table</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">assertions</div>
         <div class="singletermTERMS">all</div>
         <div class="singletermTERMS">anyType</div>
         <div class="singletermTERMS">atom</div>
         <div class="singletermTERMS">atoms</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
         <div class="singletermTERMS">Associate professor</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">book</div>
         <div class="singletermTERMS">build-error-condition</div>
         <div class="singletermTERMS">BookEntry</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">co-constraint</div>
         <div class="singletermTERMS">Co-occurrence constraints</div>
         <div class="singletermTERMS">co-constraints</div>
         <div class="singletermTERMS">Conditional Type Assignment</div>
         <div class="singletermTERMS">conditional declarations</div>
         <div class="singletermTERMS">Cartesian Product</div>
         <div class="singletermTERMS">co-occurrence constraints</div>
         <div class="singletermTERMS">conditional</div>
         <div class="singletermTERMS">content model for a generic entry</div>
         <div class="singletermTERMS">Context-determined type</div>
         <div class="singletermTERMS">Context-determined Type Table</div>
         <div class="singletermTERMS">Conditional Type Substitutable in Restriction</div>
         <div class="singletermTERMS">Cartesian product</div>
         <div class="singletermTERMS">corresponding Type Table problem</div>
         <div class="singletermTERMS">Casimirri</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">declared type</div>
         <div class="singletermTERMS">default type alternative</div>
         <div class="singletermTERMS">Declared type</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">ErrorConditionBuilder</div>
         <div class="singletermTERMS">ErrorExpressionSimplifier</div>
         <div class="singletermTERMS">ErrorExpressionEvaluator</div>
         <div class="singletermTERMS">Entry</div>
         <div class="singletermTERMS">error</div>
         <div class="singletermTERMS">extension</div>
         <div class="singletermTERMS">Element Declarations Consistent</div>
         <div class="singletermTERMS">error conditions</div>
         <div class="singletermTERMS">expr</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">from</div>
         <div class="singletermTERMS">FALSE</div>
         <div class="singletermTERMS">final</div>
         <div class="singletermTERMS">fabio@cs.unibo.it</div>
         <div class="singletermTERMS">Fabio</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getStateByName("type-table-map")</div>
         <div class="singletermTERMS">Graduate student</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">handleStartElement</div>
         <div class="singletermTERMS">hybrid</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">it.unibo.cs.cta</div>
         <div class="singletermTERMS">it.unibo.cs.cta.errorexpr</div>
         <div class="singletermTERMS">i-1</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">journal</div>
         <div class="singletermTERMS">javax.xml.xpath</div>
         <div class="singletermTERMS">j'</div>
         <div class="singletermTERMS">JournalEntry</div>
         <div class="singletermTERMS">j'</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">kind</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">lazy boolean evaluator</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">match</div>
         <div class="singletermTERMS">messageTypeBase64</div>
         <div class="singletermTERMS">messageTypeXML</div>
         <div class="singletermTERMS">messageTypeString</div>
         <div class="singletermTERMS">mcasimir@cs.unibo.it</div>
         <div class="singletermTERMS">Maurizio</div>
         <div class="singletermTERMS">Marinelli</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not(@kind='string')</div>
         <div class="singletermTERMS">not(@a = 'v1') and (@a = 'v2')</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">or</div>
         <div class="singletermTERMS">org.apache.xerces.impl.xs.traversers</div>
         <div class="singletermTERMS">org.apache.xerces.xs</div>
         <div class="singletermTERMS">org.apache.xerces.impl.xs</div>
         <div class="singletermTERMS">Optimized Cartesian Product</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">proceedings</div>
         <div class="singletermTERMS">ProceedingsEntry</div>
         <div class="singletermTERMS">Proceedings</div>
         <div class="singletermTERMS">proceedings</div>
         <div class="singletermTERMS">Prefix</div>
         <div class="singletermTERMS">process-element</div>
         <div class="singletermTERMS">potential case enumeration problem</div>
         <div class="singletermTERMS">Proceedings of Extreme Markup Languages</div>
         <div class="singletermTERMS">Proceedings of XML Europe</div>
         <div class="singletermTERMS">pmarinel@cs.unibo.it</div>
         <div class="singletermTERMS">Paolo</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Run-Time Check</div>
         <div class="singletermTERMS">restriction</div>
         <div class="singletermTERMS">regardless</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">simplify</div>
         <div class="singletermTERMS">statically</div>
         <div class="singletermTERMS">Selected type</div>
         <div class="singletermTERMS">state == STATE_AND</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">test</div>
         <div class="singletermTERMS">to</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">TRUE</div>
         <div class="singletermTERMS">th</div>
         <div class="singletermTERMS">type alternative</div>
         <div class="singletermTERMS">Type Table</div>
         <div class="singletermTERMS">TT</div>
         <div class="singletermTERMS">T1</div>
         <div class="singletermTERMS">T2</div>
         <div class="singletermTERMS">TT'</div>
         <div class="singletermTERMS">The corresponding Type Table problem</div>
         <div class="singletermTERMS">The potential case enumeration problem</div>
         <div class="singletermTERMS">Temporary research associate</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">Vitali</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xs:alternative</div>
         <div class="singletermTERMS">XML Schema Definition Language</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">yes</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="OptimizedCartesianproduct:AhybridapproachtoderivationchaincheckinginXSD11ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">Optimized Cartesian product: A hybrid approach to derivation-chain checking in XSD
         1.1
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2008</div>
            <div class="confdates e5">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">As XPath predicates are involved, XSD 1.1 conditional declarations make difficult
               the problem of statically verifying whether a type is a legal restriction of its base.
               The XSD 1.1 current draft adopts a full dynamic approach to the problem. In this paper
               we propose a hybrid solution (neither completely static, nor completely dynamic) to
               the same problem.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Maurizio</div>
               <div class="surname e11">Casimirri</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Maurizio Casimirri is a graduate student in Computer Science, at the University of
                  Bologna.
               </div>
            </div>
            <div class="email e14">mcasimir@cs.unibo.it</div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Graduate student</div>
               <div class="orgname e17">Department of Computer Science, University of Bologna</div>
            </div>
         </div>
         <div class="author e18">
            <div class="personname e19">
               <div class="firstname e20">Paolo</div>
               <div class="surname e21">Marinelli</div>
            </div>
            <div class="personblurb e22">
               <div class="para e23">Paolo Marinelli holds a Master Degree in Computer Science from the University of Bologna.
                  He is a temporary research associate at the Department of Computer Science of the
                  University of Bologna.
               </div>
            </div>
            <div class="affiliation e24">
               <div class="jobtitle e25">Temporary research associate</div>
               <div class="orgname e26">Department of Computer Science, University of Bologna</div>
            </div>
            <div class="email e27">pmarinel@cs.unibo.it</div>
         </div>
         <div class="author e28">
            <div class="personname e29">
               <div class="firstname e30">Fabio</div>
               <div class="surname e31">Vitali</div>
            </div>
            <div class="personblurb e32">
               <div class="para e33">Fabio Vitali is an associate professor at the Department of Computer Science at the
                  University of Bologna. He holds a Laurea degree in Mathematics and a Ph.D. in Computer
                  and Law, both from the University of Bologna. His research interests include markup
                  languages; distributed, coordinated systems; and the World Wide Web. He is the author
                  of several papers on hypertext functionalities, the World Wide Web, and XML.
               </div>
            </div>
            <div class="affiliation e34">
               <div class="jobtitle e35">Associate professor</div>
               <div class="orgname e36">Department of Computer Science, University of Bologna</div>
            </div>
            <div class="email e37">fabio@cs.unibo.it</div>
         </div>
         <div class="legalnotice e38">
            <div class="para e39">Copyright © 2008 by the authors. Reproduced with permission.</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e40" xml:id="sectIntroduction" xreflabel="Introduction">
         <div class="title e41">Introduction</div>
         <div class="para e42">In this paper we propose an 
            <div class="emphasis e43">hybrid</div> solution to the problem of verifying whether a type is a legal restriction of its
            base in XSD 1.1.
         </div>
         <div class="para e44">Version 1.1 of XML Schema (XSD) in now in Working Draft [
            <div class="xref e45" linkend="entryXSD1.1-structures"></div>, 
            <div class="xref e46" linkend="entryXSD1.1-datatypes"></div>]. One of the most important features introduced by XSD 1.1 is Conditional Type Assignment,
            i.e., the possibility for element declarations to assign a type based on XPath predicates.
            CTA is meant to address one of the most evident limitations of XSD 1.0: the 
            <div class="emphasis e47">co-constraint</div> definition support.
         </div>
         <div class="para e48">The CTA introduction in XSD arises an issue concerning the derivation by restriction
            between types containing conditional declarations. Indeed, the type actually assigned
            by a conditional declaration can be known at run-time only and it may vary from element
            to element. Thus the problem of 
            <div class="emphasis e49">statically</div> verifying whether a type is a legal restriction of its base when conditional declarations
            are involved is difficult. It is possible to identify three alternative approaches
            to the problem:
         </div>
         <div class="orderedlist e50">
            <div class="listitem e51">
               <div class="para e52">Limiting the CTA usage in type restrictions.</div>
            </div>
            <div class="listitem e53">
               <div class="para e54">Dynamic verification: at schema compile time no check is performed, but if at run-time
                  we have a document proving that a type is not a legal restriction of its base, an
                  error is thrown.
               </div>
            </div>
            <div class="listitem e55">
               <div class="para e56">Hybrid approach: similar to the previous approach, with the exception that at schema
                  compile time some analysis is performed providing the dynamic phase information that
                  might decrease the operations to be performed.
               </div>
            </div>
         </div>
         <div class="para e57">
            <div class="emphasis e58">Co-occurrence constraints</div> (also known as 
            <div class="emphasis e59">co-constraints</div> ) are rules relating the presence and values of elements and attributes that may
            occur in distinct fragments of an XML document. E.g., we have a co-constraint when
            an attribute value governs the content of an element, or when two attributes are in
            some logic/arithmetic relation, and so on. Co-constraints are present in several XML-based
            languages, among which also languages recommended by W3C.
         </div>
         <div class="para e60">One of the widely recognized limitations of XSD 1.0 [
            <div class="xref e61" linkend="entryXSD1.0-structures"></div>, 
            <div class="xref e62" linkend="entryXSD1.0-datatypes"></div>] is the inability to define co-constraints. This is a serious shortcoming for a schema
            language, and especially for XSD, given its widespread use. Indeed, when a schema
            is not able to capture every validity constraints of a class of XML documents, in
            order to reach a complete validation process specific modules are required to verify
            those constraints not covered by the schema. In such cases, not only the validation
            process becomes more complex, but also the interoperability between applications decreases.
         </div>
         <div class="para e63">Version 1.1 of XSD introduces two mechanisms for the co-constraint definition: 
            <div class="emphasis e64">assertions</div> and  
            <div class="emphasis e65">Conditional Type Assignment</div> (CTA). The former is inspired by Schematron [
            <div class="xref e66" linkend="entrySchematronISOspecification"></div>]. It permits to augment type definitions with XPath predicates (called assertions),
            each specifying a further validity condition besides those enforced by the content
            model. Assertions are particularly useful to require some elements and attributes
            to be in logic or arithmetic relations.
         </div>
         <div class="para e67">CTA, inspired by SchemaPath [
            <div class="xref e68" linkend="entrySchemaPathWWW"></div>], allows an element declaration to conditionally assign a type based on XPath predicates.
            Here we refer to declaration of such a typology as 
            <div class="emphasis e69">conditional declarations</div>. CTA is particularly suitable for those situations where an attribute value governs
            the content of an element. For instance, in order to subject the content of a 
            <div class="code e70">&lt;entry&gt;</div> element (representing a bibliographic entry) to the value of the 
            <div class="code e71">kind</div> attribute, the following conditional declaration might be used
         </div>
         <div class="programlisting e72" xml:space="preserve">
            &lt;xs:element name="entry" type="Entry"&gt;
            	&lt;xs:alternative test="@kind = 'proceedings'" type="ProceedingsEntry" /&gt;
            	&lt;xs:alternative test="@kind = 'journal'"     type="JournalEntry" /&gt;
            	&lt;xs:alternative test="@kind = 'book'"        type="BookEntry" /&gt;
            &lt;/xs:element&gt;
            
         </div>
         <div class="para e73">The above declaration reads as "if 
            <div class="code e74">@kind</div> is 
            <div class="code e75">proceedings</div> then 
            <div class="code e76">&lt;entry&gt;</div> is of type 
            <div class="emphasis e77">ProceedingsEntry</div>, otherwise if 
            <div class="code e78">@kind</div> is 
            <div class="code e79">journal</div> then 
            <div class="code e80">&lt;entry&gt;</div> is of type 
            <div class="emphasis e81">JournalEntry</div>, otherwise if 
            <div class="code e82">@kind</div> is 
            <div class="code e83">book</div> then 
            <div class="code e84">&lt;entry&gt;</div> is of type 
            <div class="emphasis e85">BookEntry</div>, otherwise (none of the above conditions hold) 
            <div class="code e86">&lt;entry&gt;</div> is of type 
            <div class="emphasis e87">Entry</div> (which is a type for generic bibliographic entries). Each 
            <div class="code e88">&lt;xs:alternative&gt;</div> element is named 
            <div class="emphasis e89">type alternative</div> in XSD 1.1.
         </div>
         <div class="para e90">Conditional declarations arise an issue in the derivation by restriction. XSD (both
            1.0 and 1.1) allows to define new types deriving existing ones. A derivation method
            is by restriction. The general principle behind the derivation by restriction is that
            the derived type accepts a subset of what the base type accepts. Thus, given an element
            
            <div class="emphasis e91">E</div>, it is required that the type assigned to 
            <div class="emphasis e92">E</div> in the context of the derived type, be a restriction of the type assigned to 
            <div class="emphasis e93">E</div> in the context of the base type. The presence of conditional declarations heavily
            complicates the static verification of such principle, as it require to analyze logic
            relations among XPath predicates. However, there are at least three alternative approaches
            to the problem of verifying whether a type is a legal restriction of its base:
         </div>
         <div class="variablelist e94">
            <div class="varlistentry e95">
               <div class="term e96">CTA limitation</div>
               <div class="listitem e97">
                  <div class="para e98">Ad hoc limitations are imposed on the CTA usage to ensure a simple static verification
                     of the restriction. For instance, a radical limitation is that when a type contains
                     a conditional declaration it is implicitly final w.r.t. the derivation by restriction.
                  </div>
               </div>
            </div>
            <div class="varlistentry e99">
               <div class="term e100">Full dynamic approach</div>
               <div class="listitem e101">
                  <div class="para e102">At schema compile type, it is never checked whether a type is a legal restriction
                     of its base. However, at validation time, it is checked whether the instance document
                     is an evidence of the fact that a type is not a legal restriction of its base.
                  </div>
               </div>
            </div>
            <div class="varlistentry e103">
               <div class="term e104">Hybrid approach</div>
               <div class="listitem e105">
                  <div class="para e106">Very similar to the full dynamic approach, but at schema compile time conditional
                     declarations are processed in order to precompute those cases in which the derivation
                     by restriction is violated. Such precomputed information is then available (in some
                     form) at run-time, and it can be used by the validator to decrease the number of operations
                     required to conclude whether the current document is an evidence of the fact that
                     a type is not a legal restriction of its base.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e107">The XSD current draft adopts the full dynamic approach. Indeed, at schema compile
            time the derivation by restriction is checked simply ignoring type alternatives. Given
            an element 
            <div class="emphasis e108">E</div>, at run-time it is checked that the type conditionally assigned to 
            <div class="emphasis e109">E</div> in the context of a derived type is a restriction of the type which would be assigned
            to 
            <div class="emphasis e110">E</div> in the context of the base type. Such a condition is then recursively checked also
            for 
            <div class="emphasis e111">E</div> and the base type, until the type hierarchy root is reached. I.e., the condition
            is checked on the entire derivation chain of the initial derived type. We call such
            a solution 
            <div class="emphasis e112">Run-Time Check</div> (RTC). The XSD Working Group publicly 
            <div class="quote e113">solicit input from implementors and users of this specification as to whether the
               current run-time rule should be retained
            </div> [
            <div class="xref e114" linkend="entryXSD1.1-structures"></div>].
         </div>
         <div class="para e115">
            <div class="emphasis e116">Cartesian Product</div> (CP) is another solution but adopts a hybrid approach. At schema compile time it
            analyzes 
            <div class="emphasis e117">all</div> possible cases that may occur at run-time. As the number of such cases is very high,
            it has serious shortcomings concerning the computational cost of the static phase.
         </div>
         <div class="para e118">In this paper we propose a hybrid solution to the problem of the verification of the
            derivation by restriction in presence of conditional declarations. We call our solution
            
            <div class="emphasis e119">Optimized Cartesian Product</div> (OCP). OCP, CP, and RTC have the same extensional behavior. OCP can be seen as an
            optimization to RTC. Indeed, at run-time the number of XPath predicates evaluated
            by OCP is less than or equal to the number of XPath predicates evaluated by RTC. Moreover,
            the OCP static phase requires an acceptable computational cost. So OCP is also an
            optimization to CP (and hence its name). Our paper contribute is two-fold:
         </div>
         <div class="orderedlist e120">
            <div class="listitem e121">
               <div class="para e122">it proposes an optimization to the solution adopted by the XSD current draft;</div>
            </div>
            <div class="listitem e123">
               <div class="para e124">it answers the feedback request about RTC, discussing various possible approaches
                  to the derivation problem, and thoroughly describing three solutions: RTC, CP and
                  OCP;
               </div>
            </div>
         </div>
         <div class="para e125">Our paper is organized as follows. The next section describes XSD 1.1 in relation
            to the problem of the co-constraint definition. In particular it describes CTA and
            assertions. Then we introduce some XSD 1.1 specific terminology in Section “
            <div class="xref e126" linkend="sectXSDTerminology"></div>”. In Section “
            <div class="xref e127" linkend="sectRestrictionXSD1.1"></div>” we describe the problem of the derivation by restriction in presence of conditional
            declarations. There we describe some possible approaches and solutions. In particular,
            we provide a detailed Run-Time Check description, including a computational cost analysis.
            We also discuss about Cartesian Product. Then in Section “
            <div class="xref e128" linkend="sectOurProposal"></div>” we describe our proposal, providing a computational cost analysis for both the static
            phase and the dynamic phase. Then in Section “
            <div class="xref e129" linkend="sectComparison"></div>” we compare RTC, CP and OCP, mainly focusing on the number of XPath predicates evaluated
            at validation time by the three techniques. Then we describe a prototype implementation
            for OCP, which demonstrates the feasibility of our proposal. Before concluding, in
            Section “
            <div class="xref e130" linkend="sectRelatedWorks"></div>” we discuss about some related works.
         </div>
      </div><a name="XSD11andCoConstraintsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e131" xml:id="sectXSD1.1CoConstraints" xreflabel="XSD 1.1 and Co-Constraints">
         <div class="title e132">XSD 1.1 and Co-Constraints</div>
         <div class="para e133">XSD (
            <div class="emphasis e134">XML Schema Definition Language</div>) is the schema language proposed by W3C. Its current version is 1.0, and it is described
            by two W3C recommendations [
            <div class="xref e135" linkend="entryXSD1.0-structures"></div>, 
            <div class="xref e136" linkend="entryXSD1.0-datatypes"></div>]. Although there are many other schema languages (such as RELAX NG [
            <div class="xref e137" linkend="entryRELAXNGISOspecification"></div>], and  Schematron [
            <div class="xref e138" linkend="entrySchematronISOspecification"></div>]), XSD probably is the most known and supported. XSD 1.0 provides support for the
            definition of a number of constraint kinds. For instance, by means of content models,
            it is possible to define the legal content of elements. XSD provides a rich set of
            built-in types for the definition of legal data values. It also provides derivation
            mechanisms, permitting to construct new types from existing ones. Moreover, XSD allows
            to define uniqueness and reference constraints on elements and attributes (cumulatively
            called identity-constraints).
         </div>
         <div class="para e139">However, XSD 1.0 is widely recognized as unable to express a particular kind of constraints:
            
            <div class="emphasis e140">co-occurrence constraints</div> (commonly referred to as 
            <div class="emphasis e141">co-constraints</div>). According to the definition given by the ESW Wiki, co-constraints are 
            <div class="quote e142">rules which govern what kinds of markup (elements, attributes) can occur together
               (co-occur) in an XML document.
            </div> [
            <div class="xref e143" linkend="entryCoOccurrenceConstraintsESWWiki"></div>]. In other words, a co-constraint relates the existence or values of an element (or
            attribute) to the existence or values of other elements (or attributes).
         </div>
         <div class="para e144">Some categorizations for co-constraints do exist. Within the ESW Wiki about 30 use-cases
            are listed, ranging from the mutual exclusion of attributes, to the requirement that
            two elements values must be in some arithmetic relation. In 2001, Norman Walsh and
            John Cowan identified seven kinds of co-constraints [
            <div class="xref e145" linkend="entryWalshCowan2001"></div>].
         </div>
         <div class="para e146">XSD 1.0 is unable to express co-constraints. Such an inability is heavily felt for
            in many user communities. For instance, validation of incoming data is critical for
            e-business infrastructures, that require also the adoption of co-constraints. Adopting
            XSD 1.0 as validation language requires them to implement application-specific modules,
            in order to provide a complete validation process.
         </div>
         <div class="para e147">W3C is releasing a new version of XSD: XSD 1.1. At the time of writing, it is in Last
            Call Working Draft [
            <div class="xref e148" linkend="entryXSD1.1-structures"></div>, 
            <div class="xref e149" linkend="entryXSD1.1-datatypes"></div>]. One of the major improvements over 1.0, is the support for co-constraints definition.
            For this purpose, XSD 1.1
            <div class="popupBox e150">
               <div class="popupLabel" onmouseover="$('#d1e322').show('1000');" onmouseout="$('#d1e322').hide('1000');">[ footnote ]</div>
               <div id="d1e322" style="display: none;">
                  <div class="footnote">
                     <div class="para e151">From here on, we refer to XSD 1.1 just as XSD.</div>
                  </div>
               </div>
            </div> introduces two mechanisms: 
            <div class="emphasis e152">assertions</div> and 
            <div class="emphasis e153">Conditional Type Assignment</div>. Both mechanisms will be described in the next two sections.
         </div><a name="AssertionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e154" xml:id="sectAssertions" xreflabel="Assertions">
            <div class="title e155">Assertions</div>
            <div class="para e156">In XSD 1.1, a complex type may define a sequence of assertions. Each assertion basically
               is an XPath 2.0 predicate. In order to be considered valid, each element assigned
               to a type must satisfy all the assertions defined by that type. Syntactically, an
               assertion is represented by an 
               <div class="code e157">&lt;assert&gt;</div> element, whose 
               <div class="code e158">test</div> attribute specifies the XPath predicate.
            </div>
            <div class="figure e159" floatstyle="1" xml:id="figAssertionsExample" xreflabel="Assertion Example">
               <div class="title e160">Assertion Example</div>
               <div class="programlisting e161" xml:space="preserve">
                  &lt;xs:element name="pages" type="PagesType" /&gt;
                  &lt;xs:complexType name="PagesType"&gt;
                  &lt;xs:attribute name="from" type="xs:positiveInteger" /&gt;
                  &lt;xs:attribute name="to" type="xs:positiveInteger" /&gt;
                  
                  <div class="emphasis e162">&lt;xs:assert test="@from le @to" /&gt;</div>
                  &lt;/xs:complexType&gt;
                  
               </div>
               <div class="caption e163">
                  <div class="para e164">An example of XSD assertions. This assertion enforces the 
                     <div class="code e165">from</div> attribute being less than the 
                     <div class="code e166">to</div> attribute.
                  </div>
               </div>
            </div>
            <div class="para e167">For instance, suppose we want to define an XML language to represent bibliography
               entries. In order to specify the conference proceedings pages in which a paper appears,
               we might define a 
               <div class="code e168">&lt;pages&gt;</div> element with two attributes 
               <div class="code e169">from</div> and 
               <div class="code e170">to</div>. In order to enforce 
               <div class="code e171">from</div> being greater than 
               <div class="code e172">to</div>, the type definition shown in Figure “
               <div class="xref e173" linkend="figAssertionsExample"></div>” might be used.
            </div>
            <div class="para e174">Assertions are clearly inspired by Schematron. However, there are some points of distinction.
               XSD associates assertions to type definitions. On the other hand, Schematron is not
               a typed language, and thus it associates assertions to elements, or, more precisely,
               to a set of elements identified by an expression. Moreover, Schematron allows to define
               assertions involving elements and attributes placed anywhere in the document. On the
               other hand, in XSD an assertion is allowed to involve only elements and attributes
               of the subtree rooted by the element the assertion is checked on: nodes outside that
               subtree are not visible.
               <div class="popupBox e175">
                  <div class="popupLabel" onmouseover="$('#d1e387').show('1000');" onmouseout="$('#d1e387').hide('1000');">[ footnote ]</div>
                  <div id="d1e387" style="display: none;">
                     <div class="footnote">
                        <div class="para e176">This limitation is not enforced by a syntactic limitation on the XPath expression,
                           but rather by the way the XPath Data Model is constructed.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="ConditionalTypeAssignmentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e177" xml:id="sectCTA" xreflabel="Conditional Type Assignment">
            <div class="title e178">Conditional Type Assignment</div>
            <div class="para e179">XSD supports co-constraint definitions by means of another mechanism known as 
               <div class="emphasis e180">Conditional Type Assignment</div> (CTA). An element declaration may specify a sequence of alternative types, each associated
               with an XPath predicate. Within this paper we refer to such declarations as 
               <div class="emphasis e181">conditional</div>. When an element of the instance document is validated against a conditional declaration,
               the XPath predicates are evaluated using the element as context node. The type assigned
               to the element is the one corresponding to the satisfied predicate. If the element
               satisfies more than one predicate, the one occurring first within the schema takes
               precedence. A conditional declaration always specifies a default type, which is assigned
               when no predicates are satisfied. Each alternative type derives from the declared
               type.
            </div>
            <div class="figure e182" floatstyle="1" xml:id="figCTAExample" xreflabel="CTA Example">
               <div class="title e183">CTA Example</div>
               <div class="programlisting e184" xml:space="preserve">
                  &lt;xs:complexType name="Entry"&gt;
                  &lt;xs:sequence&gt;
                  
                  <div class="emphasis e185">content model for a generic entry</div>
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="kind" type="EntryKindType" /&gt;
                  &lt;/xs:complexType&gt;
                  
                  &lt;xs:complexType name="ProceedingsEntry"&gt;
                  &lt;xs:complexContent&gt;
                  &lt;xs:extension base="Entry"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element name="conference" type="Conference" /&gt;
                  &lt;xs:element name="pages" type="Pages" /&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:extension&gt;
                  &lt;/xs:complexContent&gt;
                  &lt;/xs:complexType&gt;
                  
                  &lt;xs:element name="entry" type="Entry"&gt;
                  
                  <div class="emphasis e186">&lt;xs:alternative test="@kind = 'proceedings'" type="ProceedingsEntry" /&gt;</div>
                  &lt;/xs:element&gt;
                  
               </div>
               <div class="caption e187">
                  <div class="para e188">An example of CTA usage. The conditional declaration assigns type 
                     <div class="emphasis e189">Proceedings</div> if the entry is of kind 
                     <div class="emphasis e190">proceedings</div>, otherwise it assigns type 
                     <div class="emphasis e191">Entry</div>.
                  </div>
               </div>
            </div>
            <div class="para e192">In order to show the usefulness of CTA within the co-constraint definition, we consider
               again our language for bibliographic entries. Suppose we want to represent an entry
               through an 
               <div class="code e193">&lt;entry&gt;</div> element, whose 
               <div class="code e194">kind</div> attribute specifies the entry kind (i.e., conference proceedings, technical report,
               and so on). Suppose that we want to enforce the following co-constraint: if the entry
               is of kind proceedings, than the 
               <div class="code e195">&lt;conference&gt;</div> and 
               <div class="code e196">&lt;pages&gt;</div> elements must be present. Then we might define:
            </div>
            <div class="itemizedlist e197">
               <div class="listitem e198">
                  <div class="para e199">an 
                     <div class="emphasis e200">Entry</div> type, constraining the content of a generic entry
                  </div>
               </div>
               <div class="listitem e201">
                  <div class="para e202">a 
                     <div class="emphasis e203">ProceedingsEntry</div> type, derived by 
                     <div class="emphasis e204">Entry</div> and requiring the presence of both 
                     <div class="code e205">&lt;conference&gt;</div> and 
                     <div class="code e206">&lt;pages&gt;</div>.
                  </div>
               </div>
               <div class="listitem e207">
                  <div class="para e208">a conditional declaration for 
                     <div class="code e209">&lt;entry&gt;</div> assigning type 
                     <div class="emphasis e210">ProceedingsEntry</div> if the 
                     <div class="code e211">kind</div> attribute has value 
                     <div class="code e212">"proceedings"</div>, and type 
                     <div class="emphasis e213">Entry</div> otherwise.
                  </div>
               </div>
            </div>
            <div class="para e214">That solution is shown in Figure “
               <div class="xref e215" linkend="figCTAExample"></div>”.
            </div>
            <div class="para e216">Note that, by default if an element does not satisfy any alternative, then it is assigned
               the type specified through the 
               <div class="code e217">type</div> attribute (known as the 
               <div class="emphasis e218">declared type</div>). In order to specify a default type other than the declared type, it is possible
               to explicitly define a 
               <div class="emphasis e219">default type alternative</div>, i.e., a type alternative occurring in last position and without any XPath predicate.
            </div>
            <div class="para e220">XSD 1.1 introduces a new built-in simple type named 
               <div class="emphasis e221">error</div>. No element or attribute is valid against such a type. 
               <div class="emphasis e222">error</div> is typically used in default type alternatives to states that it is an error if no
               type alternative is selected.
            </div>
            <div class="para e223">The CTA mechanism is inspired by SchemaPath, an extension to XSD 1.0 introducing the
               concept of conditional type assignment [
               <div class="xref e224" linkend="entrySchemaPathWWW"></div>]. However, there are some remarkable points of distinction (besides some syntactic
               aspects). In SchemaPath, a conditional declaration does not have the declared type.
               Moreover, while SchemaPath does not put any restriction on XPath predicates, XSD allows
               predicates to access attribute nodes only. Thus, it is not possible to put conditions
               on neither preceding, ancestor, nor descending nodes.
            </div>
         </div>
      </div><a name="XSDTerminologyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e225" xml:id="sectXSDTerminology" xreflabel="XSD Terminology">
         <div class="title e226">XSD Terminology</div>
         <div class="para e227">For the reader unfamiliar with XSD, this section introduces some CTA-related definitions
            taken from the XSD current draft [
            <div class="xref e228" linkend="entryXSD1.1-structures"></div>].
         </div>
         <div class="variablelist e229">
            <div class="varlistentry e230">
               <div class="term e231">
                  <div class="emphasis e232" role="bold">Declared type</div>
               </div>
               <div class="listitem e233">
                  <div class="para e234">Given an element declaration 
                     <div class="emphasis e235">D</div> the declared type of 
                     <div class="emphasis e236">D</div> is either the type referred to by the attribute 
                     <div class="code e237">type</div>, or the anonymous type definition within 
                     <div class="emphasis e238">D</div>
                  </div>
               </div>
            </div>
            <div class="varlistentry e239">
               <div class="term e240">
                  <div class="emphasis e241" role="bold">Context-determined type</div>
               </div>
               <div class="listitem e242">
                  <div class="para e243">Given an element 
                     <div class="emphasis e244">E</div> and a type 
                     <div class="emphasis e245">T</div>, the context-determined type of 
                     <div class="emphasis e246">E</div> in 
                     <div class="emphasis e247">T</div> is the declared type of the declaration 
                     <div class="emphasis e248">D</div> assigned to 
                     <div class="emphasis e249">E</div> by the 
                     <div class="emphasis e250">T</div> content model.
                  </div>
               </div>
            </div>
            <div class="varlistentry e251">
               <div class="term e252">
                  <div class="emphasis e253" role="bold">Type Table</div>
               </div>
               <div class="listitem e254">
                  <div class="para e255">A Type Table is a property of conditional declarations, and it is a sequence of type
                     alternatives (or simply, alternatives). Each alternative corresponds to a 
                     <div class="code e256">xs:alternative</div> element, and it mainly consits of an XPath predicate and a type.
                  </div>
               </div>
            </div>
            <div class="varlistentry e257">
               <div class="term e258">
                  <div class="emphasis e259" role="bold">Selected type</div>
               </div>
               <div class="listitem e260">
                  <div class="para e261">Given an element 
                     <div class="emphasis e262">E</div> and a Type Table 
                     <div class="emphasis e263">TT</div>, the selected type of 
                     <div class="emphasis e264">E</div> is the type associated to the 
                     <div class="emphasis e265">TT</div> alternative satisfied by 
                     <div class="emphasis e266">E</div>.
                  </div>
               </div>
            </div>
            <div class="varlistentry e267">
               <div class="term e268">
                  <div class="emphasis e269" role="bold">Context-determined Type Table</div>
               </div>
               <div class="listitem e270">
                  <div class="para e271">Given an element 
                     <div class="emphasis e272">E</div> and a type 
                     <div class="emphasis e273">T</div>, the context-determined Type Table of 
                     <div class="emphasis e274">E</div> in 
                     <div class="emphasis e275">T</div> is the Type Table of the declaration 
                     <div class="emphasis e276">D</div> assigned to 
                     <div class="emphasis e277">E</div> by the 
                     <div class="emphasis e278">T</div> content model. If 
                     <div class="emphasis e279">D</div> is non-conditional, the context-determined Type Table has the default alternative
                     only, which assigns the declared type.
                  </div>
               </div>
            </div>
         </div>
      </div><a name="DerivationbyRestrictioninXSD11ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e280" xml:id="sectRestrictionXSD1.1" xreflabel="Derivation by Restriction in XSD 1.1">
         <div class="title e281">Derivation by Restriction in XSD 1.1</div>
         <div class="para e282">XSD allows to define new types from existing ones through two derivation mechanisms,
            
            <div class="emphasis e283">extension</div> and 
            <div class="emphasis e284">restriction</div>. The latter is meant to define a type whose content model accepts a subset of what
            the base type content model accepts.
         </div>
         <div class="figure e285" floatstyle="1" xml:id="figCTARestrictionExample" xreflabel="CTA Restriction Example">
            <div class="title e286">CTA Restriction Example</div>
            <div class="programlisting e287" xml:space="preserve">
               &lt;xs:complexType name="B"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="e" type="xs:anyType"&gt;
               &lt;xs:alternative test="@a &gt;  @b" type="T1" /&gt;
               &lt;xs:alternative test="@a &lt;= @b" type="T2" /&gt;
               &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:complexType&gt;
               
               &lt;xs:complexType name="R"&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:restriction base="B"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="e" type="xs:anyType"&gt;
               &lt;xs:alternative test="@a &gt;  @b" type="T2" /&gt;
               &lt;xs:alternative test="@a &lt;= @b" type="T1" /&gt;
               &lt;/xs:element&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;
               
               &lt;xs:complexType name="T1"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="t1" /&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="ab" /&gt;
               &lt;/xs:complexType&gt;
               
               &lt;xs:complexType name="T2"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="t2" /&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="ab" /&gt;
               &lt;/xs:complexType&gt;
               
               
            </div>
            <div class="caption e288">
               <div class="para e289">An example of derivation by restriction involving conditional declarations.</div>
            </div>
         </div>
         <div class="para e290">The presence of conditional declarations within content models immediately arises
            a question concerning the derivation by restriction. In order to explain the issue,
            let us consider the schema snippet shown in Figure “
            <div class="xref e291" linkend="figCTARestrictionExample"></div>”. We can observe that neither 
            <div class="emphasis e292">T1</div> derives from 
            <div class="emphasis e293">T2</div>, nor the converse. Also it is easy to observe that whenever the conditional declaration
            within 
            <div class="emphasis e294">B</div> assigns 
            <div class="emphasis e295">T1</div>, the conditional declaration within 
            <div class="emphasis e296">R</div> assigns 
            <div class="emphasis e297">T2</div>, and vice versa.
         </div>
         <div class="para e298">Now let us consider the following XML fragment:</div>
         <div class="programlisting e299" xml:space="preserve">
            &lt;p xsi:type="R"&gt;
            &lt;e a="5" b="2"&gt; 
            <div class="emphasis e300">&lt;!-- @a &gt; @b --&gt;</div>
            &lt;t2 /&gt;
            &lt;/e&gt;
            &lt;/p&gt;
            
         </div>
         <div class="para e301">As 
            <div class="code e302">&lt;p&gt;</div> is assigned type 
            <div class="emphasis e303">R</div>, its child 
            <div class="code e304">&lt;e&gt;</div> is assigned type 
            <div class="emphasis e305">T2</div>. According to the schema, 
            <div class="code e306">&lt;e&gt;</div> is valid against 
            <div class="emphasis e307">T2</div>. For what previously observed, the type that would be assigned to 
            <div class="code e308">&lt;e&gt;</div> if 
            <div class="code e309">&lt;p&gt;</div> was of type 
            <div class="emphasis e310">B</div> is 
            <div class="emphasis e311">T1</div>. Clearly, 
            <div class="code e312">&lt;e&gt;</div> is not valid against 
            <div class="emphasis e313">T1</div>. Thus we have that 
            <div class="emphasis e314">B</div> rejects something 
            <div class="emphasis e315">R</div> accepts. We can reasonably argue that this is a violation of the principle behind
            the derivation by restriction. And actually, the XSD current draft imposes constraints
            meant to detect as illegal situations like the one above.
         </div>
         <div class="para e316">Before discussing in details how the XSD current draft faces the derivation by restriction
            in presence of conditional declarations, we examine some general approaches to the
            problem.
         </div><a name="FullStaticApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e317" xml:id="sectFullStaticApproach" xreflabel="Full Static Approach">
            <div class="title e318">Full Static Approach</div>
            <div class="para e319">We can think about approaches 
               <div class="emphasis e320">statically</div> (i.e., at schema compile time) deciding whether a conditional declaration within
               a restricted type is compatible with a conditional declaration within the base type.
               I.e., such an approach should decide the following problem. Given two conditional
               declarations 
               <div class="emphasis e321">R</div> and 
               <div class="emphasis e322">B</div>, is there any XML document containing an element 
               <div class="emphasis e323">E</div> such that if 
               <div class="emphasis e324">E</div> is validated against 
               <div class="emphasis e325">R</div> then it is assigned a type which is not a valid restriction of the type that would
               be assigned if 
               <div class="emphasis e326">E</div> was validated against 
               <div class="emphasis e327">B</div>?
            </div>
            <div class="para e328">This is not a simple problem, as it is necessary to verify logic relationships among
               XPath predicates. For instance consider again the conditional declarations shown in
               Figure “
               <div class="xref e329" linkend="figCTARestrictionExample"></div>”. Clearly, the answer to the above question is 
               <div class="emphasis e330">yes</div>, as if the conditional declaration within the restricted type assigns 
               <div class="emphasis e331">T1</div>, then the conditional declaration within the base type assigns 
               <div class="emphasis e332">T2</div>. Thus, we can assert that the derived type is not a legal restriction of its base.
               In order to prove it, we should consider the semantics of the relational operators
               
               <div class="code e333">&gt;</div> and 
               <div class="code e334">&lt;=</div>. Probably, it is not a so difficult task, as the XPath predicates involved in the
               example are quite simple. But if we move to the general case, the problem becomes
               much more difficult, as we have to consider also the other XPath functions and operators.
            </div>
         </div><a name="ExpressivityLimitationApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e335" xml:id="sectExpressivityLimitationApproach" xreflabel="Expressivity Limitation Approach">
            <div class="title e336">Expressivity Limitation Approach</div>
            <div class="para e337">It is possible to identify a class of approaches facing the problem by narrowing the
               CTA usage, in order to avoid the XPath predicates analysis. For instance a simple
               and radical solution to the problem consists in implicitly setting as 
               <div class="emphasis e338">final</div>
               <div class="popupBox e339">
                  <div class="popupLabel" onmouseover="$('#d1e800').show('1000');" onmouseout="$('#d1e800').hide('1000');">[ footnote ]</div>
                  <div id="d1e800" style="display: none;">
                     <div class="footnote">
                        <div class="para e340">In XSD, if a type is set as final, it cannot be derived.</div>
                     </div>
                  </div>
               </div> every complex types containing a conditional declaration. This is the solution adopted
               by SchemaPath. Obviously, this solution might be felt as overly restrictive.
            </div>
            <div class="para e341">Less restrictive solutions may be found. The XSD Working Group discussed a number
               of them. One of such solutions, known as 
               <div class="emphasis e342">Prefix</div>, forces the conditional declaration within the derived type to repeat all the alternatives
               of the conditional declaration within the base type, and allows to append new alternatives.
               Requiring new alternative types to be a restriction of the default type of the base
               declaration, ensures that every type assigned in the context of the derived type is
               a restriction of the type that would be assigned in the context of the base type.
            </div>
            <div class="figure e343" floatstyle="1" xml:id="figCTARestrictionUseCase" xreflabel="CTA Restriction Use Case">
               <div class="title e344">CTA Restriction Use Case</div>
               <div class="programlisting e345" xml:space="preserve">
                  &lt;xs:complexType name="B"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element name="message" type="messageType"&gt;
                  &lt;xs:alternative test="@kind='string'" type="messageTypeString"/&gt;
                  &lt;xs:alternative test="@kind='base64'" type="messageTypeBase64"/&gt;
                  &lt;xs:alternative test="@kind='binary'" type="messageTypeBase64"/&gt;
                  &lt;xs:alternative test="@kind='xml'"    type="messageTypeXML"/&gt;
                  &lt;xs:alternative test="@kind='XML'"    type="messageTypeXML"/&gt;
                  &lt;/xs:element&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:complexType&gt;
                  
                  &lt;xs:complexType name="R"&gt;
                  &lt;xs:complexContent&gt;
                  &lt;xs:restriction base="B"&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element name="message" type="messageType"&gt;
                  &lt;xs:alternative test="@kind='string'" type="messageTypeString"/&gt;
                  &lt;xs:alternative                       type="xs:error"/&gt;
                  &lt;/xs:element&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:restriction&gt;
                  &lt;/xs:complexContent&gt;
                  &lt;/xs:complexType&gt;
                  
               </div>
               <div class="caption e346">
                  <div class="para e347">An example of restriction in presence of CTA. The restricted type definition is meant
                     to accept a subset of what the base type definition accepts.
                  </div>
               </div>
            </div>
            <div class="para e348">Let us consider the schema shown in Figure “
               <div class="xref e349" linkend="figCTARestrictionUseCase"></div>”, which is inspired by the example of CTA usage described in the XSD current draft.
               Within type 
               <div class="emphasis e350">B</div>, the conditional declaration for 
               <div class="code e351">&lt;message&gt;</div> elements assigns a specific message type based on the 
               <div class="code e352">kind</div> attribute value. Type 
               <div class="emphasis e353">R</div> is meant to accept string messages only. In this respect, we might argue that 
               <div class="emphasis e354">R</div> is a legal restriction of 
               <div class="emphasis e355">B</div>. However, Prefix rejects the above schema, as the alternative sequence of the base
               type are not listed in the alternative sequence of the restricted type.
            </div>
         </div><a name="FullDynamicApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e356" xml:id="sectFullDynamicApproach" xreflabel="Full Dynamic Approach">
            <div class="title e357">Full Dynamic Approach</div>
            <div class="para e358">Another approach to the problem is the following: do not perform any check at compile
               time and let schema authors to write conditional declarations as they like, but if
               at run time (i.e., at validation time) there is an evidence of the fact that a type
               is not a legal restriction of its base type, then report the error. W.r.t. the approach
               described in the previous section, this one reaches the maximum expressivity degree
               in writing conditional declarations. Clearly, the drawback is that the same schema
               error might become evident only for certain instance documents, and not for others.
            </div>
            <div class="para e359">This is the approach adopted by the XSD current draft, and will be described in details
               in Section “
               <div class="xref e360" linkend="sectRuntTimeCheck"></div>”.
            </div>
         </div><a name="RuntimeCheckANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e361" xml:id="sectRuntTimeCheck" xreflabel="Run-Time Check">
            <div class="title e362">Run-time Check</div>
            <div class="para e363">As already mentioned in the previous sections, the XSD current draft adopts a dynamic
               approach to the verification of the derivation by restriction in presence of conditional
               declarations. Indeed, the general problem of verifying whether a type 
               <div class="emphasis e364">R</div> is legal restriction of a type 
               <div class="emphasis e365">B</div> is divided in two phases. The first one is meant to be performed at schema compile
               time, and it considers the declared type of element declarations only, thus simply
               ignoring the presence of Type Tables. For the implementation of such a phase, the
               XSD draft refers to the algorithms described in [
               <div class="xref e366" linkend="entryFSAThompson"></div>], [
               <div class="xref e367" linkend="entryFuchs"></div>], and [
               <div class="xref e368" linkend="entryBrzozowski"></div>].
            </div>
            <div class="para e369">The second phase (which we call 
               <div class="emphasis e370">Run-Time Check</div> or simply RTC) is meant to be performed at run-time, and it takes into considerations
               Type Tables. The XSD specs describe it as a rule to decide the validity of an element
               w.r.t. a type. In order to be valid against a type 
               <div class="emphasis e371">T</div>, an element must satisfy a number of constraints. One of such constraints states
               that each child 
               <div class="emphasis e372">E</div> together with 
               <div class="emphasis e373">T</div> must satisfy the 
               <div class="emphasis e374">Conditional Type Substitutable in Restriction</div> constraint (CTSR).
            </div>
            <div class="para e375">Informally, given an element 
               <div class="emphasis e376">E</div> and a type 
               <div class="emphasis e377">T</div>, 
               <div class="emphasis e378">E</div> and 
               <div class="emphasis e379">T</div> satisfy CTSR if the type assigned to 
               <div class="emphasis e380">E</div> in the context of 
               <div class="emphasis e381">T</div>, is a valid restriction of the type assigned to 
               <div class="emphasis e382">E</div> in the context of 
               <div class="emphasis e383">T</div>'s base type. Moreover, 
               <div class="emphasis e384">E</div> and 
               <div class="emphasis e385">T</div>'s base type must recursively satisfy CTSR.
            </div>
            <div class="para e386">For instance, consider again the schema in Figure “
               <div class="xref e387" linkend="figCTARestrictionExample"></div>”, and the following XML document fragment:
            </div>
            <div class="programlisting e388" xml:space="preserve">
               &lt;p xsi:type="R"&gt;
               &lt;e a="5" b="2"&gt;
               &lt;t2 /&gt;
               &lt;/e&gt;
               &lt;/p&gt;
               
            </div>
            <div class="para e389">The first phase checks whether type 
               <div class="emphasis e390">R</div> is a legal restriction of 
               <div class="emphasis e391">B</div>, taking into consideration declared types only. In particular, it is checked whether
               the declared type of the element declaration within 
               <div class="emphasis e392">R</div> (i.e., 
               <div class="emphasis e393">anyType</div>) is a valid restriction of the declared type of the element declaration within 
               <div class="emphasis e394">B</div> (i.e., 
               <div class="emphasis e395">anyType</div>). As 
               <div class="emphasis e396">anyType</div> is a valid restriction of itself, the first phase succeeds.
            </div>
            <div class="para e397">The second phase checks whether or not the input document is an evidence of the fact
               that 
               <div class="emphasis e398">R</div> is 
               <div class="emphasis e399">not</div> a legal restriction of 
               <div class="emphasis e400">B</div>. In particular, RTC checks whether 
               <div class="code e401">&lt;e&gt;</div> and 
               <div class="emphasis e402">R</div> satisfy CTSR. Thus, the Type Table determined by 
               <div class="emphasis e403">R</div> is evaluated, obtaining the selected type 
               <div class="emphasis e404">T2</div>. Then, also the Type Table determined by 
               <div class="emphasis e405">B</div> is evaluated, obtaining the selected type 
               <div class="emphasis e406">T1</div>. As 
               <div class="emphasis e407">T2</div> is not a valid restriction of 
               <div class="emphasis e408">T1</div>, 
               <div class="code e409">&lt;e&gt;</div> and 
               <div class="emphasis e410">R</div> does not satisfy CTSR. As a consequence, 
               <div class="code e411">&lt;p&gt;</div> is not valid against 
               <div class="emphasis e412">R</div>.
            </div><a name="AnAlgorithmforRunTimeCheckANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e413" xml:id="sectRTCAlgorithm" xreflabel="An Algorithm for Run-Time Check">
               <div class="title e414">An Algorithm for Run-Time Check</div>
               <div class="figure e415" floatstyle="1" xml:id="figRTCAlgorithm" xreflabel="RTC Algorithm">
                  <div class="title e416">RTC Algorithm</div>
                  <div class="programlisting e417" xml:space="preserve">
                     void process-element(Element e) {
                     
                     
                     <div class="emphasis e418">...</div>
                     
                     Type T = get-current-type(); 
                     <div class="emphasis e419">// e's parent type</div>
                     
                     TypeTable TT
                     <div class="subscript e420">T</div> = get-context-determined-type-table(e, T);
                     int i = evaluate-type-table(e, TT
                     <div class="subscript e421">T</div>);
                     Type S
                     <div class="subscript e422">T</div> = TT
                     <div class="subscript e423">T</div>.get-alternative(i).getType();
                     
                     boolean error = false;
                     
                     
                     <div class="emphasis e424">// walk on the derivation chain</div>
                     while (T is not xs:anyType and !error) do {
                     
                     Type B = T.base;
                     TypeTable TT
                     <div class="subscript e425">B</div> = get-context-determined-type-table(e, B);
                     int j = evaluate-type-table(e, TT
                     <div class="subscript e426">B</div>);
                     Type S
                     <div class="subscript e427">B</div> = TT
                     <div class="subscript e428">B</div>.getAlternative(j).getType();
                     
                     if (validly-substitutable-as-restriction(S
                     <div class="subscript e429">T</div>, S
                     <div class="subscript e430">B</div>)) {
                     T = B;
                     S
                     <div class="subscript e431">T</div> = S
                     <div class="subscript e432">B</div>;
                     } else {
                     
                     <div class="emphasis e433">// CTSR violation</div>
                     error = true;
                     report-schema-error("vr-cta-substitutable");
                     }
                     }
                     
                     
                     <div class="emphasis e434">...</div>
                     
                     }
                     
                     
                  </div>
                  <div class="caption e435">
                     <div class="para e436">An algorithm implementing RTC.</div>
                  </div>
               </div>
               <div class="para e437">In Figure “
                  <div class="xref e438" linkend="figRTCAlgorithm"></div>” we present an algorithm implementing RTC, in Java-like pseudo-code. The 
                  <div class="emphasis e439">process-element</div> function is meant to be invoked for each element of the instance document. The function
                  body is a simple iterative version of the CTSR constraint definition given in the
                  XSD draft. It iterates over the derivation chain for 
                  <div class="emphasis e440">T</div>, and it stops when either a violation of CTSR occurs or the type hierarchy root (i.e.,
                  
                  <div class="emphasis e441">anyType</div>) is reached.
               </div>
            </div><a name="RTCAlgorithmCostAnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e442" xml:id="sectRTCAlgorithmCostAnalysis" xreflabel="RTC Algorithm Cost Analysis">
               <div class="title e443">RTC Algorithm Cost Analysis</div>
               <div class="para e444">In presenting our cost analysis for the algorithm shown in the previous section, we
                  need to introduce some notations. A Type Table 
                  <div class="emphasis e445">TT</div> is an ordered sequence of 
                  <div class="emphasis e446">n</div> pairs &lt;
                  <div class="emphasis e447">c</div>
                  <div class="subscript e448">1</div>, 
                  <div class="emphasis e449">T</div>
                  <div class="subscript e450">1</div>&gt;, ..., &lt;
                  <div class="emphasis e451">c
                     <div class="subscript e452">n</div>
                  </div>, 
                  <div class="emphasis e453">T
                     <div class="subscript e454">n</div>
                  </div>&gt;, where 
                  <div class="emphasis e455">c
                     <div class="subscript e456">n</div>
                  </div> is the always true condition. We also say that 
                  <div class="emphasis e457">TT</div> has size 
                  <div class="emphasis e458">n</div>.
               </div>
               <div class="para e459">Now, let 
                  <div class="emphasis e460">E</div> and 
                  <div class="emphasis e461">T</div> be an element and a type definition respectively. Consider the derivation chain for
                  
                  <div class="emphasis e462">T</div>. We indicate it with 
                  <div class="emphasis e463">T</div>
                  <div class="subscript e464">1</div>, ..., 
                  <div class="emphasis e465">T
                     <div class="subscript e466">k</div>
                  </div>, where 
                  <div class="emphasis e467">T</div>
                  <div class="subscript e468">1</div> is 
                  <div class="emphasis e469">anyType</div>, 
                  <div class="emphasis e470">T
                     <div class="subscript e471">k</div>
                  </div> is 
                  <div class="emphasis e472">T</div>, and for each 
                  <div class="emphasis e473">i</div> &lt; 
                  <div class="emphasis e474">k</div>, 
                  <div class="emphasis e475">T
                     <div class="subscript e476">i</div>
                  </div> is 
                  <div class="emphasis e477">T
                     <div class="subscript e478">i</div>
                  </div>
                  <div class="subscript e479">+1</div>'s base type. For each 
                  <div class="emphasis e480">i</div> between 1 and 
                  <div class="emphasis e481">k</div>, we denote the context-determined Type Table for 
                  <div class="emphasis e482">E</div> in 
                  <div class="emphasis e483">T
                     <div class="subscript e484">i</div>
                  </div> by 
                  <div class="emphasis e485">TT
                     <div class="subscript e486">i</div>
                  </div>. Moreover we denote the 
                  <div class="emphasis e487">TT
                     <div class="subscript e488">i</div>
                  </div> size by 
                  <div class="emphasis e489">d
                     <div class="subscript e490">i</div>
                  </div>.
               </div>
               <div class="para e491">Now, we can start the RTC algorithm cost analysis. If there is no CTSR violation,
                  the RTC algorithm iterates over the entire derivation chain for 
                  <div class="emphasis e492">T</div>. For each 
                  <div class="emphasis e493">i</div> between 1 and 
                  <div class="emphasis e494">k</div>, the following operations are performed:
               </div>
               <div class="orderedlist e495">
                  <div class="listitem e496">
                     <div class="para e497">get the context-determined Type Table for 
                        <div class="emphasis e498">E</div> in 
                        <div class="emphasis e499">T
                           <div class="subscript e500">i</div>
                        </div>, i.e., 
                        <div class="emphasis e501">TT
                           <div class="subscript e502">i</div>
                        </div>
                     </div>
                  </div>
                  <div class="listitem e503">
                     <div class="para e504">calculate the selected type for 
                        <div class="emphasis e505">E</div> according to 
                        <div class="emphasis e506">TT
                           <div class="subscript e507">i</div>
                        </div>
                     </div>
                  </div>
                  <div class="listitem e508">
                     <div class="para e509">check whether the selected type is validly substitutable as restriction for the selected
                        type calculated at step 
                        <div class="emphasis e510">i</div> - 1.
                     </div>
                  </div>
               </div>
               <div class="para e511">We assume the first operation has a negligible cost. Indeed, given an element 
                  <div class="emphasis e512">E</div> and a type 
                  <div class="emphasis e513">T</div>, the 
                  <div class="emphasis e514">Element Declarations Consistent</div> (EDC) constraint ensures that the context-determined type table for 
                  <div class="emphasis e515">E</div> in 
                  <div class="emphasis e516">T</div> depends on the 
                  <div class="emphasis e517">E</div> name only. Thus it suffices to scan the 
                  <div class="emphasis e518">T</div> content model, looking for an element declaration named as 
                  <div class="emphasis e519">E</div>. As we are not interested in the content model size here, we assume 
                  <div class="emphasis e520">TT
                     <div class="subscript e521">i</div>
                  </div> can be found through a single memory access.
               </div>
               <div class="para e522">We assume the third operation has a negligible cost too. Indeed, we assume for each
                  pair of types &lt;
                  <div class="emphasis e523">A</div>, 
                  <div class="emphasis e524">B</div>&gt;, the schema compile phase already decided whether 
                  <div class="emphasis e525">A</div> is validly substitutable as restriction for 
                  <div class="emphasis e526">B</div>, and that the result is available at run-time and can be read through a single memory
                  access.
               </div>
               <div class="para e527">In our analysis, we do not neglect the second operation cost. Given an element 
                  <div class="emphasis e528">E</div> and a Type Table 
                  <div class="emphasis e529">TT</div>, in order to decide the selected type for 
                  <div class="emphasis e530">E</div> in 
                  <div class="emphasis e531">TT</div>, it might be necessary to evaluate all the XPath conditions in 
                  <div class="emphasis e532">TT</div>.
                  <div class="popupBox e533">
                     <div class="popupLabel" onmouseover="$('#d1e1317').show('1000');" onmouseout="$('#d1e1317').hide('1000');">[ footnote ]</div>
                     <div id="d1e1317" style="display: none;">
                        <div class="footnote">
                           <div class="para e534">To be more precise, as the last predicate of a Type Table is the always true condition,
                              it suffices to evaluate 
                              <div class="emphasis e535">n</div>-1 predicates, where 
                              <div class="emphasis e536">n</div> is the Type Table size.
                           </div>
                        </div>
                     </div>
                  </div> Indeed if 
                  <div class="emphasis e537">TT</div> has the following alternatives &lt;
                  <div class="emphasis e538">c</div>
                  <div class="subscript e539">1</div>, 
                  <div class="emphasis e540">T</div>
                  <div class="subscript e541">1</div>&gt;, ..., &lt;
                  <div class="emphasis e542">c
                     <div class="subscript e543">n</div>
                  </div>, 
                  <div class="emphasis e544">T
                     <div class="subscript e545">n</div>
                  </div>&gt;, then 
                  <div class="emphasis e546">T
                     <div class="subscript e547">i</div>
                  </div> is chosen if and only if none of the conditions 
                  <div class="emphasis e548">c</div>
                  <div class="subscript e549">1</div>, ..., 
                  <div class="emphasis e550">c
                     <div class="subscript e551">i</div>
                  </div>
                  <div class="subscript e552">-1</div> hold, and 
                  <div class="emphasis e553">c
                     <div class="subscript e554">i</div>
                  </div> holds. Thus a correct algorithm for a Type Table evaluation is that evaluating each
                  alternative in order, and stopping as soon as a condition is satisfied. Clearly, such
                  an algorithm is linear in the Type Table size.
               </div>
               <div class="para e555">Coming back to our cost analysis, as 
                  <div class="emphasis e556">TT
                     <div class="subscript e557">i</div>
                  </div> has size 
                  <div class="emphasis e558">d
                     <div class="subscript e559">i</div>
                  </div>, the second operation requires the evaluation of at most 
                  <div class="emphasis e560">d
                     <div class="subscript e561">i</div>
                  </div> XPath conditions.
               </div>
               <div class="para e562">Thus in our analysis, the RTC algorithm cost is given by the number of XPath predicates
                  evaluated. By the observations above, we have that such a cost is upper-bounded by
                  the equation shown in Equation “
                  <div class="xref e563" linkend="equationRTCAlgoUpperBound"></div>”.
               </div>
               <div class="equation e564" xml:id="equationRTCAlgoUpperBound" xreflabel="RTC algorithm upper-bound">
                  <div class="mathphrase e565">
                     <div class="emphasis e566">d</div>
                     <div class="subscript e567">1</div> + ... + 
                     <div class="emphasis e568">d
                        <div class="subscript e569">k</div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="HybridApproach:CartesianProductANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e570" xml:id="sectHybridApproachCartesianProduct" xreflabel="Hybrid Approach: Cartesian Product">
            <div class="title e571">Hybrid Approach: Cartesian Product</div>
            <div class="para e572">There also exist an 
               <div class="emphasis e573">hybrid</div> approach to the problem, i.e., an approach neither fully dynamic, nor fully static.
               A solution taking such an approach is named 
               <div class="emphasis e574">Cartesian Product</div> (CP), and the XSD Working Group considered it for a period. As RTC, CP does not impose
               any limitation on the CTA usage.
            </div>
            <div class="para e575">Adopting a hybrid approach, CP consists of two phases. The former is performed at
               schema compile time, the latter at validation time. During the static phase, the Type
               Tables of the input schema are rewritten. In particular, given a Type Table 
               <div class="emphasis e576">TT
                  <div class="subscript e577">R</div>
               </div> within a type 
               <div class="emphasis e578">R</div> and the corresponding Type Table 
               <div class="emphasis e579">TT
                  <div class="subscript e580">B</div>
               </div> within 
               <div class="emphasis e581">R</div>'s base type, the static phase substitutes 
               <div class="emphasis e582">TT
                  <div class="subscript e583">R</div>
               </div> with the Type Table resulting from the 
               <div class="emphasis e584">Cartesian product</div> between 
               <div class="emphasis e585">TT
                  <div class="subscript e586">R</div>
               </div> and 
               <div class="emphasis e587">TT
                  <div class="subscript e588">B</div>
               </div>.
            </div>
            <div class="para e589">The Cartesian product between 
               <div class="emphasis e590">TT
                  <div class="subscript e591">R</div>
               </div> and 
               <div class="emphasis e592">TT
                  <div class="subscript e593">B</div>
               </div> is a Type Table denoted by 
               <div class="emphasis e594">TT
                  <div class="subscript e595">R</div>
               </div> × 
               <div class="emphasis e596">TT
                  <div class="subscript e597">B</div>
               </div> whose size is the product of the sizes of 
               <div class="emphasis e598">TT
                  <div class="subscript e599">R</div>
               </div> and 
               <div class="emphasis e600">TT
                  <div class="subscript e601">B</div>
               </div>. For each pair of alternatives &lt;&lt;
               <div class="emphasis e602">r
                  <div class="subscript e603">i</div>
               </div>, 
               <div class="emphasis e604">R
                  <div class="subscript e605">i</div>
               </div>&gt;, &lt;
               <div class="emphasis e606">b
                  <div class="subscript e607">j</div>
               </div>, 
               <div class="emphasis e608">B
                  <div class="subscript e609">j</div>
               </div>&gt;&gt; (where the first item is the 
               <div class="emphasis e610">i</div>-th alternative of 
               <div class="emphasis e611">TT
                  <div class="subscript e612">R</div>
               </div>, and the second item is the 
               <div class="emphasis e613">j</div>-th alternative of 
               <div class="emphasis e614">TT
                  <div class="subscript e615">B</div>
               </div>), 
               <div class="emphasis e616">TT
                  <div class="subscript e617">R</div>
               </div> × 
               <div class="emphasis e618">TT
                  <div class="subscript e619">B</div>
               </div> has an alternative whose condition is the conjunction of 
               <div class="emphasis e620">r
                  <div class="subscript e621">i</div>
               </div> and 
               <div class="emphasis e622">b
                  <div class="subscript e623">j</div>
               </div>, and whose type is:
            </div>
            <div class="itemizedlist e624">
               <div class="listitem e625">
                  <div class="para e626">
                     <div class="emphasis e627">R
                        <div class="subscript e628">i</div>
                     </div>, if 
                     <div class="emphasis e629">R
                        <div class="subscript e630">i</div>
                     </div> is a valid restriction of 
                     <div class="emphasis e631">B
                        <div class="subscript e632">j</div>
                     </div>
                  </div>
               </div>
               <div class="listitem e633">
                  <div class="para e634">
                     <div class="emphasis e635">error</div>, otherwise.
                  </div>
               </div>
            </div>
            <div class="para e636">At run-time, given a type 
               <div class="emphasis e637">T</div> and an element 
               <div class="emphasis e638">E</div>, in order to know whether 
               <div class="emphasis e639">E</div> and 
               <div class="emphasis e640">T</div> satisfy CTSR, it suffices to evaluate the (rewritten) context-determined Type Table
               of 
               <div class="emphasis e641">E</div> in 
               <div class="emphasis e642">T</div>. And thus there is no need to walk on the derivation chain.
            </div>
            <div class="para e643">However, given a derivation chain 
               <div class="emphasis e644">T</div>
               <div class="subscript e645">1</div>, ..., 
               <div class="emphasis e646">T
                  <div class="subscript e647">k</div>
               </div>, and an element 
               <div class="emphasis e648">E</div>, let 
               <div class="emphasis e649">TT</div>
               <div class="subscript e650">1</div>, ..., 
               <div class="emphasis e651">TT
                  <div class="subscript e652">k</div>
               </div> be the sequence of context-determined Type Tables before the static phase rewrite
               them. The static phase rewrites those Type Tables in 
               <div class="emphasis e653">TT'</div>
               <div class="subscript e654">1</div>, ..., 
               <div class="emphasis e655">TT'
                  <div class="subscript e656">k</div>
               </div>, where:
            </div>
            <div class="itemizedlist e657">
               <div class="listitem e658">
                  <div class="para e659">
                     <div class="emphasis e660">TT'</div>
                     <div class="subscript e661">1</div> is 
                     <div class="emphasis e662">TT</div>
                     <div class="subscript e663">1</div>, and
                  </div>
               </div>
               <div class="listitem e664">
                  <div class="para e665">
                     <div class="emphasis e666">TT'
                        <div class="subscript e667">i</div>
                     </div> is 
                     <div class="emphasis e668">TT
                        <div class="subscript e669">i</div>
                     </div> × 
                     <div class="emphasis e670">TT'
                        <div class="subscript e671">i</div>
                     </div>
                     <div class="subscript e672">-1</div>, for every 1 &lt; 
                     <div class="emphasis e673">i</div> &lt;= 
                     <div class="emphasis e674">k</div>
                  </div>
               </div>
            </div>
            <div class="para e675">The condition of each alternative of 
               <div class="emphasis e676">TT'
                  <div class="subscript e677">k</div>
               </div> is the conjunction of 
               <div class="emphasis e678">k</div> XPath predicates. Moreover, the 
               <div class="emphasis e679">TT'
                  <div class="subscript e680">k</div>
               </div> size is 
               <div class="emphasis e681">d</div>
               <div class="subscript e682">1</div> ⋅ ... ⋅ 
               <div class="emphasis e683">d
                  <div class="subscript e684">k</div>
               </div>, where 
               <div class="emphasis e685">d
                  <div class="subscript e686">i</div>
               </div> is the 
               <div class="emphasis e687">TT
                  <div class="subscript e688">i</div>
               </div> size. Fixing each 
               <div class="emphasis e689">d
                  <div class="subscript e690">i</div>
               </div> to a constant 
               <div class="emphasis e691">d</div>, that product is 
               <div class="emphasis e692">d
                  <div class="superscript e693">k</div>
               </div>. Such an observation makes clear that the CP static phase might be too expensive.
            </div>
         </div>
      </div><a name="OptimizedCartesianProductANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e694" xml:id="sectOurProposal" xreflabel="Optimized Cartesian Product">
         <div class="title e695">Optimized Cartesian Product</div>
         <div class="para e696">In this section we present our solution to the problem of the derivation by restriction
            in presence of conditional declarations. We call it 
            <div class="emphasis e697">Optimized Cartesian Product</div> (OCP). From the expressivity point of view, our proposal is meant to be fully equivalent
            to Runt-Time Check and Cartesian Product. While being inspired by CP (and hence its
            name), it can also be seen as an RTC optimization.
         </div><a name="GeneralideaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e698" xml:id="sectGeneralIdea" xreflabel="General Idea">
            <div class="title e699">General idea</div>
            <div class="para e700">Our idea is to perform a static analysis on Type Tables, anticipating at compile time
               those cases in which a CTSR violation occurs. Such an analysis is meant to avoid at
               run-time the evaluation of those XPath predicates which do not affect the CTSR checking
               result.
            </div>
            <div class="para e701">For instance, consider the schema shown in Figure “
               <div class="xref e702" linkend="figCTARestrictionUseCase"></div>”. As 
               <div class="emphasis e703">error</div> is not a valid restriction of any type, it is clear that whenever at run-time a 
               <div class="code e704">&lt;message&gt;</div> element does not satisfy the 
               <div class="code e705">@kind='string'</div> predicate within the 
               <div class="emphasis e706">R</div> context (and hence is assigned type 
               <div class="emphasis e707">error</div>), a CTSR violation occurs 
               <div class="emphasis e708">regardless</div> of the actual type that would be assigned within the 
               <div class="emphasis e709">B</div> context.
            </div>
            <div class="para e710">So our approach is to perform a static analysis in order to tell the run-time phase
               something like: if within the context of type 
               <div class="emphasis e711">R</div> the predicate 
               <div class="emphasis e712">a</div> is satisfied, do not evaluate any of the predicates 
               <div class="emphasis e713">b</div>, 
               <div class="emphasis e714">c</div>, or 
               <div class="emphasis e715">d</div> within 
               <div class="emphasis e716">R</div>'s base type, because such an evaluation will not affect the CTSR checking result.
            </div>
            <div class="para e717">Note that our approach does not consider the actual XPath predicate semantics during
               the static analysis. As we already observed, it would be too difficult. Moreover,
               note that, as seen for Cartesian Product, our approach is neither completely static,
               nor completely dynamic, i.e., it is a 
               <div class="emphasis e718">hybrid</div> approach.
            </div>
            <div class="para e719">Before discussing in details our technique, it is worth considering some major problems
               our hybrid approach has to face
            </div>
            <div class="variablelist e720">
               <div class="varlistentry e721">
                  <div class="term e722">
                     <div class="emphasis e723">The corresponding Type Table problem</div>
                  </div>
                  <div class="listitem e724">
                     <div class="para e725">Given a type 
                        <div class="emphasis e726">T</div> and an element declaration 
                        <div class="emphasis e727">D</div>, our general idea is to perform a static analysis of the cases in which 
                        <div class="emphasis e728">T</div> and a generic element matching 
                        <div class="emphasis e729">D</div> violate CTSR. Thus, the context-determined Type Table of that generic element in
                        the base type of 
                        <div class="emphasis e730">T</div> have to be statically decided. Put in a bit more formal way, let 
                        <div class="emphasis e731">B</div> be 
                        <div class="emphasis e732">T</div>'s base type. The static analysis has to answer the following question: which is the
                        Type Table 
                        <div class="emphasis e733">TT'</div> determined by 
                        <div class="emphasis e734">B</div> for an element matching 
                        <div class="emphasis e735">D</div>?
                     </div>
                  </div>
               </div>
               <div class="varlistentry e736">
                  <div class="term e737">
                     <div class="emphasis e738">The potential case enumeration problem</div>
                  </div>
                  <div class="listitem e739">
                     <div class="para e740">Assume for the moment the previous problem can be solved. Thus consider a derivation
                        chain 
                        <div class="emphasis e741">T</div>
                        <div class="subscript e742">1</div>, ..., 
                        <div class="emphasis e743">T</div>
                        <div class="emphasis e744">
                           <div class="subscript e745">k</div>
                        </div>, and the sequence of Type Tables 
                        <div class="emphasis e746">TT</div>
                        <div class="subscript e747">1</div>, ..., 
                        <div class="emphasis e748">TT
                           <div class="subscript e749">k</div>
                        </div> such that each 
                        <div class="emphasis e750">TT
                           <div class="subscript e751">i</div>
                        </div> is the Type Table determined by 
                        <div class="emphasis e752">T
                           <div class="subscript e753">i</div>
                        </div> for a given element. If each 
                        <div class="emphasis e754">TT
                           <div class="subscript e755">i</div>
                        </div> has size 
                        <div class="emphasis e756">d
                           <div class="subscript e757">i</div>
                        </div>, the number of cases that might potentially be verified at run-time is given by 
                        <div class="emphasis e758">d</div>
                        <div class="subscript e759">1</div> ⋅ ... ⋅ 
                        <div class="emphasis e760">d
                           <div class="subscript e761">k</div>
                        </div>. If the Type Tables average size is 
                        <div class="emphasis e762">d</div>, that product is similar to 
                        <div class="emphasis e763">d
                           <div class="superscript e764">k</div>
                        </div>. Enumerating all such potential cases, might lead to an unacceptable static analysis
                        cost. It precisely is the problem of the Cartesian Product technique.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e765">For what concerns the first problem, both the 
               <div class="emphasis e766">Element Declarations Consistent</div> (EDC) constraint and the context-determined Type Table definition provided by the
               XSD current draft help us. Indeed, by EDC it is possible to define for each type 
               <div class="emphasis e767">T</div> a partial function 
               <div class="emphasis e768">tt-map
                  <div class="superscript e769">T</div>
               </div> : QName  → Type Table, such that for each element name 
               <div class="emphasis e770">e</div>, 
               <div class="emphasis e771">tt-map
                  <div class="superscript e772">T</div>
               </div>(
               <div class="emphasis e773">e</div>) returns, if any, the Type Table of an element declaration named 
               <div class="emphasis e774">e</div> within 
               <div class="emphasis e775">T</div>.
            </div>
            <div class="para e776">Given: </div>
            <div class="orderedlist e777">
               <div class="listitem e778">
                  <div class="para e779">
                     <div class="emphasis e780">T</div>, a type;
                  </div>
               </div>
               <div class="listitem e781">
                  <div class="para e782">
                     <div class="emphasis e783">B</div>, the base type of 
                     <div class="emphasis e784">T</div>;
                  </div>
               </div>
               <div class="listitem e785">
                  <div class="para e786">
                     <div class="emphasis e787">D</div>, an element declaration within 
                     <div class="emphasis e788">T</div>;
                  </div>
               </div>
               <div class="listitem e789">
                  <div class="para e790">
                     <div class="emphasis e791">e</div>, the name of 
                     <div class="emphasis e792">D</div>
                  </div>
               </div>
            </div>
            <div class="para e793">the context-determined Type Table within 
               <div class="emphasis e794">B</div> for any element matching 
               <div class="emphasis e795">D</div>, cannot be directly calculated as 
               <div class="emphasis e796">tt-map
                  <div class="superscript e797">T</div>
               </div>(
               <div class="emphasis e798">e</div>), as we have to deal with wildcards (and some other minor details). However, wildcards
               do not pose any particular problem, as EDC states that if a type contains both an
               element declaration 
               <div class="emphasis e799">D</div> and a wildcard 
               <div class="emphasis e800">W</div>, then 
               <div class="emphasis e801">D</div>'s Type Table and the Type Table of any top-level declaration matching 
               <div class="emphasis e802">W</div> must be the same. Moreover, the context-determined Type Table definition states that
               if, within a type 
               <div class="emphasis e803">T</div>, an element 
               <div class="emphasis e804">E</div> does not match any declaration, but matches a wildcard 
               <div class="emphasis e805">W</div>, then the context-determined Type Table within 
               <div class="emphasis e806">T</div> for 
               <div class="emphasis e807">E</div> is the Type Table of the top-level declaration matching 
               <div class="emphasis e808">W</div>, if any. Here, the 
               <div class="emphasis e809">match</div> predicate is always defined in terms of string matching, and never in terms of schema
               component semantics.
            </div>
            <div class="para e810">Thus, it is easy to extend our 
               <div class="emphasis e811">tt-map
                  <div class="superscript e812">T</div>
               </div> function definition so that for any name 
               <div class="emphasis e813">e</div>, 
               <div class="emphasis e814">tt-map
                  <div class="superscript e815">T</div>
               </div>(
               <div class="emphasis e816">e</div>) returns the  context-determined Type Table within 
               <div class="emphasis e817">T</div> for any element 
               <div class="emphasis e818">E</div> named 
               <div class="emphasis e819">e</div>, exactly as defined by the XSD current draft.
            </div>
            <div class="para e820">Note also that although the set of qualified names is infinite, 
               <div class="emphasis e821">tt-map
                  <div class="superscript e822">T</div>
               </div> is defined only for those qualified names matching some element declaration of the
               schema. As the number of element declarations within a schema is finite, also the
               
               <div class="emphasis e823">tt-map
                  <div class="superscript e824">T</div>
               </div> domain is finite. The possibility to statically define the function 
               <div class="emphasis e825">tt-map
                  <div class="superscript e826">T</div>
               </div> solves the 
               <div class="emphasis e827">corresponding Type Table problem</div>.
            </div>
            <div class="para e828">For what concerns the 
               <div class="emphasis e829">potential case enumeration problem</div>, our idea is the following. Given a sequence of Type Tables 
               <div class="emphasis e830">TT</div>
               <div class="subscript e831">1</div>, ..., 
               <div class="emphasis e832">TT
                  <div class="subscript e833">k</div>
               </div> as previously described in the problem definition, we do not consider all the 
               <div class="emphasis e834">k</div> Type Tables together, but rather we analyze each pair of Type Tables 
               <div class="emphasis e835">TT
                  <div class="subscript e836">i</div>
               </div> and 
               <div class="emphasis e837">TT
                  <div class="subscript e838">i-1</div>
               </div> separately. In particular, for each such pair of Type Tables, we identify the cases
               that would cause a CTSR violation for that single derivation step. The results of
               such analysis are made available at run-time as annotations on 
               <div class="emphasis e839">TT
                  <div class="subscript e840">i</div>
               </div>. As we will see, this guarantees an acceptable cost for the static phase. Obviously,
               for any element 
               <div class="emphasis e841">E</div> whose context-determined Type Table is 
               <div class="emphasis e842">TT
                  <div class="subscript e843">i</div>
               </div>, we have information about CTSR for a single derivation step only, and not for the
               whole derivation chain. If that information is not sufficient to decide whether CTSR
               is satisfied or not, it is necessary to walk on the derivation chain in order the
               access the annotations for 
               <div class="emphasis e844">TT
                  <div class="subscript e845">i-1</div>.
               </div>
            </div>
         </div><a name="OCPStaticPhaseANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e846" xml:id="sectOCPStaticPhase" xreflabel="OCP Static Phase">
            <div class="title e847">OCP Static Phase</div>
            <div class="para e848">The static phase consists of two steps. The first step just builds for any type 
               <div class="emphasis e849">T</div> of the schema type hierarchy the 
               <div class="emphasis e850">tt-map
                  <div class="superscript e851">T</div>
               </div> mapping. For any 
               <div class="emphasis e852">T</div> of the schema type hierarchy, the second step annotates the Type Tables within the
               
               <div class="emphasis e853">tt-map
                  <div class="superscript e854">T</div>
               </div> codomain with 
               <div class="emphasis e855">error conditions</div>.
            </div>
            <div class="para e856">In particular, for each type 
               <div class="emphasis e857">T</div> and for each name 
               <div class="emphasis e858">e</div> within the 
               <div class="emphasis e859">tt-map
                  <div class="superscript e860">T</div>
               </div> domain, the alternatives of the Type Table 
               <div class="emphasis e861">tt-map
                  <div class="superscript e862">T</div>
               </div>(
               <div class="emphasis e863">e</div>) are annotated with an error condition. Such a condition specifies the cases in which
               CTSR is broken w.r.t. the context-determined Type Table within 
               <div class="emphasis e864">T</div>'s base.
               <div class="popupBox e865">
                  <div class="popupLabel" onmouseover="$('#d1e2154').show('1000');" onmouseout="$('#d1e2154').hide('1000');">[ footnote ]</div>
                  <div id="d1e2154" style="display: none;">
                     <div class="footnote">
                        <div class="para e866">From here on, given a type 
                           <div class="emphasis e867">T</div>, an element 
                           <div class="emphasis e868">E</div> and the context-determined Type Table 
                           <div class="emphasis e869">TT</div> of 
                           <div class="emphasis e870">E</div> in 
                           <div class="emphasis e871">T</div>, by “
                           <div class="emphasis e872">TT</div>'s base Type Table” we mean the context-determined Type Table of 
                           <div class="emphasis e873">E</div> in 
                           <div class="emphasis e874">T</div>'s base.
                        </div>
                     </div>
                  </div>
               </div> Each error condition simply is a boolean expression built on the base Type Table
               predicates.
            </div>
            <div class="figure e875" floatstyle="1" xml:id="figStaticPhaseAlgo" xreflabel="OCP Static Phase Algorithm">
               <div class="title e876">OCP Static Phase Algorithm</div>
               <div class="programlisting e877" xml:space="preserve">
                  
                  <div class="emphasis e878">// visits a type of the schema type hierarchy</div>
                  void visit-type(Type T) {
                  
                  
                  <div class="emphasis e879">// annotate each context-determined Type Table within the current type</div>
                  for each QName name in tt-map
                  <div class="superscript e880">T</div>.domain {
                  annotate-type-table(tt-map
                  <div class="superscript e881">T</div>(name));
                  }
                  
                  
                  <div class="emphasis e882">// recursive call</div>
                  for each Type D derived from T do {
                  visit-type(D);
                  }
                  }
                  
                  
                  <div class="emphasis e883">// annotates a context-determined Type Table</div>
                  void annotate-type-table(TypeTable ttr) {
                  for each int i s.t. 1 &lt;= i &lt;= ttr.size {
                  
                  <div class="emphasis e884">// build the error condition for the current alternative</div>
                  Expression expr = build-error-condition(ttr, i);
                  
                  <div class="emphasis e885">// simplify the error condition</div>
                  expr = simplify(expr);
                  
                  <div class="emphasis e886">// annotate the current alternative with the simplified condition</div>
                  ttr.get-alternative(i).error-condition = expr;
                  }
                  }
                  
                  
                  <div class="emphasis e887">// builds an error condition for a Type Table alternative</div>
                  Expression build-error-condition(TypeTable ttr, int i) {
                  
                  
                  <div class="emphasis e888">// get the base Type Table</div>
                  TypeTable ttb = ttr.base;
                  if (ttb is absent) {
                  return Expression.FALSE; 
                  <div class="emphasis e889">// In such a case no CTSR violation may occur</div>
                  } else {
                  return build-error-condition_aux(ttr, ttb, i, Expression.FALSE, 1, STATE_OR);
                  }
                  }
                  
                  Expression build-error-condition_aux(TypeTable ttr, TypeTable ttb, int i, Expression
                  left, int j, short state) {
                  if (j &gt; ttb.size) {
                  return left;
                  } else {
                  
                  Expression a;
                  if (j == ttb.size) {
                  a = Expression.TRUE;
                  } else {
                  a = ttb.get-alternative(j).getTest();
                  }
                  
                  Expression right;
                  
                  Type r = ttr.get-alternative(i).getType();
                  Type b = ttb.get-alternative(j).getType();
                  
                  if (r validly restricts b) {
                  NotExpression negatedLiteral = new NotExpression(a);
                  right = build-error-condition_aux(ttr, ttb, i, negatedLiteral, j + 1, STATE_AND);
                  } else {
                  right = build-error-condition_aux(ttr, ttb, i, a, j + 1, STATE_OR);
                  }
                  
                  if (state == STATE_OR) {
                  return new OrExpression(left, right);
                  } else { 
                  <div class="emphasis e890">state == STATE_AND</div>
                  return new AndExpression(left, right);
                  }
                  }
                  }
                  
               </div>
               <div class="caption e891">
                  <div class="para e892">Pseudo-code for the static analysis of OCP.</div>
               </div>
            </div>
            <div class="para e893">The procedure described above is shown in Java-like pseudo-code in Figure “
               <div class="xref e894" linkend="figStaticPhaseAlgo"></div>”. The 
               <div class="code e895">simplify</div> function is not shown: its purpose is to rewrite the error condition in a simpler
               form. In particular, if by 
               <div class="emphasis e896">atom</div> we mean a Type Table XPath predicate, the 
               <div class="code e897">simplify</div> purpose is to minimize the number of atoms within the input expression. 
               <div class="code e898">simplify</div> can be implemented visiting the structure of the expression produced by 
               <div class="code e899">build-error-condition</div>, and applying the lazy boolean evaluation rules shown in the following table:
               <div class="popupBox e900">
                  <div class="popupLabel" onmouseover="$('#d1e2252').show('1000');" onmouseout="$('#d1e2252').hide('1000');">[ footnote ]</div>
                  <div id="d1e2252" style="display: none;">
                     <div class="footnote">
                        <div class="para e901">Symmetric rules for binary operators are not shown.</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="informaltable e902" xml:id="tabRewritingRules" xreflabel="Rewriting Rules">
               <div class="thead e903">
                  <div class="tr e904">
                     <div class="th e905">Input expression</div>
                     <div class="th e906">Rewritten expression</div>
                  </div>
               </div>
               <div class="tr e907">
                  <div class="th e908" colspan="2">or-rules</div>
               </div>
               <div class="tr e909">
                  <div class="td e910">
                     <div class="code e911">FALSE</div> or 
                     <div class="emphasis e912">expr</div>
                  </div>
                  <div class="td e913">
                     <div class="emphasis e914">expr</div>
                  </div>
               </div>
               <div class="tr e915">
                  <div class="td e916">
                     <div class="code e917">TRUE</div> or 
                     <div class="emphasis e918">expr</div>
                  </div>
                  <div class="td e919">
                     <div class="code e920">TRUE</div>
                  </div>
               </div>
               <div class="tr e921">
                  <div class="th e922" colspan="2">and-rules</div>
               </div>
               <div class="tr e923">
                  <div class="td e924">
                     <div class="code e925">FALSE</div> and 
                     <div class="emphasis e926">expr</div>
                  </div>
                  <div class="td e927">
                     <div class="code e928">FALSE</div>
                  </div>
               </div>
               <div class="tr e929">
                  <div class="td e930">
                     <div class="code e931">TRUE</div> and 
                     <div class="emphasis e932">expr</div>
                  </div>
                  <div class="td e933">
                     <div class="emphasis e934">expr</div>
                  </div>
               </div>
               <div class="tr e935">
                  <div class="th e936" colspan="2">not-rules</div>
               </div>
               <div class="tr e937">
                  <div class="td e938">not(
                     <div class="code e939">TRUE</div>)
                  </div>
                  <div class="td e940">
                     <div class="code e941">FALSE</div>
                  </div>
               </div>
               <div class="tr e942">
                  <div class="td e943">not(
                     <div class="code e944">FALSE</div>)
                  </div>
                  <div class="td e945">
                     <div class="code e946">TRUE</div>
                  </div>
               </div>
            </div>
            <div class="para e947">The evaluation of the algorithm of Figure “
               <div class="xref e948" linkend="figStaticPhaseAlgo"></div>” on the schema shown in Figure “
               <div class="xref e949" linkend="figCTARestrictionUseCase"></div>”, annotates the alternatives of the Type Table within 
               <div class="emphasis e950">R</div> with the following error conditions:
            </div>
            <div class="itemizedlist e951">
               <div class="listitem e952">
                  <div class="para e953">
                     <div class="code e954">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or @kind='XML')))</div>
                  </div>
               </div>
               <div class="listitem e955">
                  <div class="para e956">
                     <div class="code e957">TRUE</div>
                  </div>
               </div>
            </div>
            <div class="para e958">The error condition associated to the first alternative states that an element 
               <div class="emphasis e959">E</div> of the instance document and 
               <div class="emphasis e960">R</div> violates CTSR whenever 
               <div class="emphasis e961">E</div> is assigned one of the types 
               <div class="emphasis e962">messageTypeBase64</div> and 
               <div class="emphasis e963">messageTypeXML</div> in the context of 
               <div class="emphasis e964">B</div> (we are in the hypothesis that 
               <div class="emphasis e965">messageTypeString</div> is not a valid restriction of any of those two types). The error condition associated
               to the second alternative states that regardless of the type assigned in the context
               of 
               <div class="emphasis e966">B</div>, a CTSR violation occurs. This is because 
               <div class="emphasis e967">error</div> is not a valid restriction of any of the types of the Type Table within 
               <div class="emphasis e968">B</div>.
            </div>
            <div class="para e969">On the other hand, the algorithm annotates each alternative of the Type Table within
               
               <div class="emphasis e970">B</div> with the error condition 
               <div class="code e971">FALSE</div>. It means that for any element 
               <div class="emphasis e972">E</div>, 
               <div class="emphasis e973">E</div> and 
               <div class="emphasis e974">B</div> do not violate CTSR. This is because 
               <div class="emphasis e975">B</div>'s base is 
               <div class="emphasis e976">anyType</div> and obviously the types within the Type Table within 
               <div class="emphasis e977">B</div> are valid restrictions of 
               <div class="emphasis e978">anyType</div>.
            </div>
         </div><a name="OCPRunTimePhaseANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e979" xml:id="sectOCPRunTimPhase" xreflabel="OCP Run-Time Phase">
            <div class="title e980">OCP Run-Time Phase</div>
            <div class="para e981">At validation time, the annotations on context-determined Type Tables are read in
               order to check CTSR. In particular, let 
               <div class="emphasis e982">E</div> be an element of the instance document, 
               <div class="emphasis e983">T</div> be the type of 
               <div class="emphasis e984">E</div>'s  parent, and 
               <div class="emphasis e985">TT</div> be the context-determined Type Table of 
               <div class="emphasis e986">E</div> in 
               <div class="emphasis e987">T</div>. Firstly, 
               <div class="emphasis e988">TT</div> has to be evaluated. Then, the error condition associated to the satisfied alternative
               is also evaluated. If the error condition evaluates to true, then it is possible to
               conclude that CTSR is not satisfied. Otherwise, the same procedure has to be recursively
               executed using 
               <div class="emphasis e989">T</div>'s base type. The recursive process stops either when a CTSR violation occurs, or
               
               <div class="emphasis e990">anyType</div> is reached.
            </div>
            <div class="figure e991" floatstyle="1" xml:id="figRunTimePhaseAlgo" xreflabel="OCP Run-time Phase Algorithm">
               <div class="title e992">OCP Run-time Phase Algorithm</div>
               <div class="programlisting e993" xml:space="preserve">
                  
                  void process-element(Element e) {
                  
                  
                  <div class="emphasis e994">...</div>
                  
                  
                  <div class="emphasis e995">// e's parent type</div>
                  Type T = current-type();
                  
                  
                  <div class="emphasis e996">// get the context determined Type Table for e</div>
                  TypeTable tt = tt-map
                  <div class="superscript e997">T</div>(e);
                  
                  
                  <div class="emphasis e998">// evaluate the type table </div>
                  int i = evaluate-type-table(e, tt);
                  
                  if (!check-CTSR(e, tt, i)) {
                  report-schema-error("vr-cta-substitutable");
                  }
                  
                  
                  <div class="emphasis e999">...</div>
                  
                  }
                  
                  boolean check-CTSR(Element e, TypeTable ttr, int i) {
                  
                  Alternative alt = ttr.get-alternative(i);
                  Expression err-epxr = alt.error-condition;
                  
                  if (evaluate-error-condition(e, err-expr)) {
                  return false;
                  } else {
                  TypeTable ttb = ttr.base;
                  if (ttb is absent) {
                  return true; // implicitly handles the xs:anyType case
                  } else {
                  int j = evaluate-type-table(e, ttb);
                  
                  
                  <div class="emphasis e1000">// recursive call</div>
                  return check-CTSR(e, ttb, j);
                  }
                  }
                  }
                  
               </div>
               <div class="caption e1001">
                  <div class="para e1002">Algorithm for the run-time phase of OCP.</div>
               </div>
            </div>
            <div class="para e1003">The procedure described above is shown in Java-like pseudo-code in Figure “
               <div class="xref e1004" linkend="figRunTimePhaseAlgo"></div>”. In order to show how it works, let us consider following document:
            </div>
            <div class="programlisting e1005" xml:space="preserve">
               &lt;messages xsi:type="R"&gt;
               &lt;message kind="string"&gt;
               
               <div class="emphasis e1006">...</div>
               &lt;/message&gt;
               &lt;message kind="binary"&gt;
               
               <div class="emphasis e1007">...</div>
               &lt;/message&gt;
               &lt;/messages&gt;
               
            </div>
            <div class="para e1008">and suppose we have to validate it against the schema depicted in Figure “
               <div class="xref e1009" linkend="figCTARestrictionUseCase"></div>” (the error conditions built during the static phase are described in Section “
               <div class="xref e1010" linkend="sectOCPStaticPhase"></div>”). When the first 
               <div class="code e1011">&lt;message&gt;</div> element is processed, its context-determined Type Table is evaluated. It is then
               checked that it satisfies the first condition 
               <div class="code e1012">@kind='string'</div>. As a consequence, it is assigned the first alternative. So the error condition associated
               with that alternative is evaluated. Such a condition is 
               <div class="code e1013">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or @kind='XML')))</div>. Clearly, the error condition is not satisfied (
               <div class="code e1014">not(@kind='string')</div> evaluates to false). Consequently, the Type Table within 
               <div class="emphasis e1015">B</div> has to be evaluated. Again, the first alternative is chosen, and thus its error condition
               is evaluated. But such a condition is 
               <div class="code e1016">FALSE</div>. And so it is possible conclude that the first 
               <div class="code e1017">&lt;message&gt;</div> element and 
               <div class="emphasis e1018">R</div> satisfy CTSR.
            </div>
            <div class="para e1019">For what concerns the second 
               <div class="code e1020">&lt;message&gt;</div> element, we have that it does not satisfy the first alternative predicate, and so
               it is assigned the default alternative. The error condition associated to such alternative
               is 
               <div class="code e1021">TRUE</div>. So we have that the second 
               <div class="code e1022">&lt;message&gt;</div> element and 
               <div class="emphasis e1023">R</div> do not satisfy CTSR.
            </div>
         </div><a name="OCPCostAnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1024" xml:id="sectOCPCostAnalysis" xreflabel="OCP Cost Analysis">
            <div class="title e1025">OCP Cost Analysis</div>
            <div class="para e1026">In this subsection we provide a cost analysis for the static phase and a cost analysis
               for the run-time phase of OCP.
            </div><a name="OCPStaticPhaseAnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1027" xml:id="sectOCPStaticPhaseAnalysis" xreflabel="OCP Static Phase Analysis">
               <div class="title e1028">OCP Static Phase Analysis</div>
               <div class="para e1029">Here we are not interested in analyzing the cost of the static phase applied to the
                  entire schema type hierarchy. Rather, we fix an element name and we consider a single
                  path from the root to a generic leaf of the type hierarchy.
               </div>
               <div class="para e1030">Thus, let 
                  <div class="emphasis e1031">T</div>
                  <div class="subscript e1032">1</div>, ..., 
                  <div class="emphasis e1033">T
                     <div class="subscript e1034">n</div>
                  </div> be a derivation chain, and 
                  <div class="emphasis e1035">e</div> be our element name. We can now consider the sequence of Type Tables 
                  <div class="emphasis e1036">TT</div>
                  <div class="subscript e1037">1</div>, ..., 
                  <div class="emphasis e1038">TT
                     <div class="subscript e1039">n</div>
                  </div>, where 
                  <div class="emphasis e1040">TT
                     <div class="subscript e1041">i</div>
                  </div> is the context-determined Type Table for an element named 
                  <div class="emphasis e1042">e</div> within 
                  <div class="emphasis e1043">T
                     <div class="subscript e1044">i</div>
                  </div>. The size of each 
                  <div class="emphasis e1045">TT
                     <div class="subscript e1046">i</div>
                  </div> is denoted by 
                  <div class="emphasis e1047">d
                     <div class="subscript e1048">i</div>
                  </div>.
               </div>
               <div class="para e1049">Given a 1 &lt; 
                  <div class="emphasis e1050">i</div> &lt;= 
                  <div class="emphasis e1051">n</div>, now we analyze the time needed to annotate 
                  <div class="emphasis e1052">TT
                     <div class="subscript e1053">i</div>
                  </div>.
               </div>
               <div class="para e1054">The function 
                  <div class="code e1055">build-error-condition</div> iterates over the whole alternative sequence of 
                  <div class="emphasis e1056">TT
                     <div class="subscript e1057">i</div>
                  </div>
                  <div class="subscript e1058">-1</div>, and for each alterantive it computes a number of operations whose cost is constant.
                  Thus the function cost is linear in the 
                  <div class="emphasis e1059">TT
                     <div class="subscript e1060">i</div>
                  </div>
                  <div class="subscript e1061">-1</div> size, i.e., 
                  <div class="emphasis e1062">d
                     <div class="subscript e1063">i</div>
                  </div>
                  <div class="subscript e1064">-1</div>
               </div>
               <div class="para e1065">The function 
                  <div class="code e1066">simplify</div> can be implemented visiting the structure of the expression returned by 
                  <div class="code e1067">build-error-condition</div>. The number of nodes of such an expression is linear in 
                  <div class="emphasis e1068">d
                     <div class="subscript e1069">i</div>
                  </div>
                  <div class="subscript e1070">-1</div>. Thus, the 
                  <div class="code e1071">simplify</div> computational cost is linear in 
                  <div class="emphasis e1072">d
                     <div class="subscript e1073">i</div>
                  </div>
                  <div class="subscript e1074">-1</div> too.
               </div>
               <div class="para e1075">As both 
                  <div class="code e1076">simplify</div> and 
                  <div class="code e1077">build-error-condition</div> are called for each alternative of 
                  <div class="emphasis e1078">TT
                     <div class="subscript e1079">i</div>
                  </div>, the asymptotic computational cost for the function 
                  <div class="code e1080">annotate-type-table</div> is 
                  <div class="emphasis e1081">d
                     <div class="subscript e1082">i</div>
                  </div>
                  <div class="subscript e1083">-1</div>⋅
                  <div class="emphasis e1084">d
                     <div class="subscript e1085">i</div>
                  </div>.
               </div>
               <div class="para e1086">Thus, the asymptotic cost for building and simplifying the error conditions of the
                  whole sequence of Type Tables, is given by:
               </div>
               <div class="para e1087">
                  <div class="emphasis e1088">d</div>
                  <div class="subscript e1089">1</div> + 
                  <div class="emphasis e1090">d</div>
                  <div class="subscript e1091">1</div>⋅
                  <div class="emphasis e1092">d</div>
                  <div class="subscript e1093">2</div> + ... + 
                  <div class="emphasis e1094">d
                     <div class="subscript e1095">n</div>
                  </div>
                  <div class="subscript e1096">-1</div>⋅
                  <div class="emphasis e1097">d
                     <div class="subscript e1098">n</div>
                  </div>
               </div>
               <div class="para e1099">We believe such a cost is perfectly acceptable at schema compile time.</div>
            </div><a name="OCPRunTimePhaseAnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1100" xml:id="sectOCPRunTimePhaseAnalysis" xreflabel="OCP Run-Time Phase Analysis">
               <div class="title e1101">OCP Run-Time Phase Analysis</div>
               <div class="para e1102">Here we provide a computational cost analysis of the run-time phase of OCP. As similarly
                  done for RTC, we are interested in determining the number of XPath predicates that
                  have to be evaluated for a generic element of the instance document.
               </div>
               <div class="para e1103">Let 
                  <div class="emphasis e1104">E</div> be an element of the instance document, and 
                  <div class="emphasis e1105">T</div> be the type assigned to 
                  <div class="emphasis e1106">E</div>'s parent. Consider the derivation chain 
                  <div class="emphasis e1107">T</div>
                  <div class="subscript e1108">1</div>, ..., 
                  <div class="emphasis e1109">T
                     <div class="subscript e1110">k</div>
                  </div>, where 
                  <div class="emphasis e1111">T</div>
                  <div class="subscript e1112">1</div> is 
                  <div class="emphasis e1113">anyType</div> and 
                  <div class="emphasis e1114">T
                     <div class="subscript e1115">k</div>
                  </div> is 
                  <div class="emphasis e1116">T</div>. Also consider the usual Type Table sequence 
                  <div class="emphasis e1117">TT</div>
                  <div class="subscript e1118">1</div>, ..., 
                  <div class="emphasis e1119">TT
                     <div class="subscript e1120">k</div>
                  </div>, where 
                  <div class="emphasis e1121">TT
                     <div class="subscript e1122">i</div>
                  </div> is the context-determined Type Table for 
                  <div class="emphasis e1123">E</div> within 
                  <div class="emphasis e1124">T
                     <div class="subscript e1125">i</div>
                  </div>.
               </div>
               <div class="para e1126">If 
                  <div class="emphasis e1127">E</div> and 
                  <div class="emphasis e1128">T</div> satisfy CTSR, the entire Type Table sequence is processed. For any  1 &lt; 
                  <div class="emphasis e1129">i</div> &lt;= 
                  <div class="emphasis e1130">k</div>, 
                  <div class="emphasis e1131">TT
                     <div class="subscript e1132">i</div>
                  </div> is evaluated to obtain the assigned alternative. The cost of such an operation is
                  linear in 
                  <div class="emphasis e1133">d
                     <div class="subscript e1134">i</div>
                  </div>. Once the assigned alternative has been determined, the algorithm evaluates the corresponding
                  error condition. As already discussed, such a condition is a boolean expression over
                  the XPath predicates of 
                  <div class="emphasis e1135">TT
                     <div class="subscript e1136">i</div>
                  </div>
                  <div class="subscript e1137">-1</div>. In our analysis, the cost of evaluating an error condition with 
                  <div class="emphasis e1138">n</div> predicates is linear in 
                  <div class="emphasis e1139">n</div>. As by construction none XPath predicate appear more than once within the same error
                  condition, we have that the error condition associated to the assigned alternative
                  contains at most 
                  <div class="emphasis e1140">d
                     <div class="subscript e1141">i</div>
                  </div>
                  <div class="subscript e1142">-1</div> predicates of 
                  <div class="emphasis e1143">TT
                     <div class="subscript e1144">i</div>
                  </div>
                  <div class="subscript e1145">-1</div>. So its evaluation cost is linear in 
                  <div class="emphasis e1146">d
                     <div class="subscript e1147">i</div>
                  </div>
                  <div class="subscript e1148">-1</div>. Thus, the number of predicates evaluated for 
                  <div class="emphasis e1149">TT
                     <div class="subscript e1150">i</div>
                  </div> is upper-bounded by 
                  <div class="emphasis e1151">d
                     <div class="subscript e1152">i</div>
                  </div> + 
                  <div class="emphasis e1153">d
                     <div class="subscript e1154">i</div>
                  </div>
                  <div class="subscript e1155">-1</div>.
               </div>
               <div class="para e1156">Considering the whole Type Table sequence, the number of evaluated XPath predicates
                  is given by the formula shown in Equation “
                  <div class="xref e1157" linkend="equationOCPRunTimePhaseUpperBound"></div>”.
               </div>
               <div class="equation e1158" xml:id="equationOCPRunTimePhaseUpperBound" xreflabel="OCP run-time phase upper-bound">
                  <div class="mathphrase e1159">2⋅
                     <div class="emphasis e1160">d</div>
                     <div class="subscript e1161">1</div> + ... + 2⋅
                     <div class="emphasis e1162">d
                        <div class="subscript e1163">k</div>
                     </div>
                     <div class="subscript e1164">-1</div> + 
                     <div class="emphasis e1165">d
                        <div class="subscript e1166">k</div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="ComparingCPOCPandRTCANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1167" xml:id="sectComparison" xreflabel="Comparing CP, OCP, and RTC">
         <div class="title e1168">Comparing CP, OCP, and RTC</div>
         <div class="para e1169">In this section we provide a comparison among the main techniques discussed so far:
            Optimized Cartesian Product, Run-Time Check, and Cartesian Product. The comparison
            focuses on the number of XPath predicates evaluated at run-time. Before starting,
            let us first fix some notations. Let:
         </div>
         <div class="itemizedlist e1170">
            <div class="listitem e1171">
               <div class="para e1172">
                  <div class="emphasis e1173">E</div> be an element of the instance document;
               </div>
            </div>
            <div class="listitem e1174">
               <div class="para e1175">
                  <div class="emphasis e1176">T</div> be the type assigned to 
                  <div class="emphasis e1177">E</div>'s parent;
               </div>
            </div>
            <div class="listitem e1178">
               <div class="para e1179">
                  <div class="emphasis e1180">T</div>
                  <div class="subscript e1181">1</div>, ..., 
                  <div class="emphasis e1182">T
                     <div class="subscript e1183">k</div>
                  </div> be the derivation chain for 
                  <div class="emphasis e1184">T</div>, where 
                  <div class="emphasis e1185">T</div>
                  <div class="subscript e1186">1</div> is 
                  <div class="emphasis e1187">anyType</div> and 
                  <div class="emphasis e1188">T
                     <div class="subscript e1189">k</div>
                  </div> is 
                  <div class="emphasis e1190">T</div>;
               </div>
            </div>
            <div class="listitem e1191">
               <div class="para e1192">
                  <div class="emphasis e1193">TT</div>
                  <div class="subscript e1194">1</div>, ..., 
                  <div class="emphasis e1195">TT
                     <div class="subscript e1196">k</div>
                  </div> be the sequence of context-determined Type Tables of 
                  <div class="emphasis e1197">E</div> along the derivation chain;
               </div>
            </div>
            <div class="listitem e1198">
               <div class="para e1199">
                  <div class="emphasis e1200">d
                     <div class="subscript e1201">i</div>
                  </div> be the 
                  <div class="emphasis e1202">TT
                     <div class="subscript e1203">i</div>
                  </div> size, for every 
                  <div class="emphasis e1204">i</div>;
               </div>
            </div>
            <div class="listitem e1205">
               <div class="para e1206">
                  <div class="emphasis e1207">TT'</div>
                  <div class="subscript e1208">1</div>, ..., 
                  <div class="emphasis e1209">TT'
                     <div class="subscript e1210">k</div>
                  </div> be the Type Tables generated by the Cartesian Product static phase.
               </div>
            </div>
         </div>
         <div class="para e1211">Both OCP and RTC evaluate 
            <div class="emphasis e1212">TT
               <div class="subscript e1213">k</div>
            </div> in order to decide which type alternative 
            <div class="emphasis e1214">E</div> has to be assigned. Clearly, both techniques evaluate the same XPath predicates of
            
            <div class="emphasis e1215">TT
               <div class="subscript e1216">k</div>
            </div>. The number of evaluated XPath predicates ranges from 1 to 
            <div class="emphasis e1217">d
               <div class="subscript e1218">k</div>
            </div>.
         </div>
         <div class="para e1219">On the other hand, CP evaluates 
            <div class="emphasis e1220">TT'
               <div class="subscript e1221">k</div>
            </div>. If, for any 
            <div class="emphasis e1222">i</div> between 1 and 
            <div class="emphasis e1223">k</div>, 
            <div class="emphasis e1224">E</div> satisfies the first alternative of 
            <div class="emphasis e1225">TT
               <div class="subscript e1226">i</div>
            </div>, CP is assigned the first alternative of 
            <div class="emphasis e1227">TT
               <div class="subscript e1228">k</div>
            </div>, and thus the condition of that alternative only is evaluated. However, that condition
            is the conjunction of 
            <div class="emphasis e1229">k</div> XPath predicates. So in the best case, CP evaluates 
            <div class="emphasis e1230">k</div> XPath predicates. But if for every 
            <div class="emphasis e1231">i</div> between 1 and 
            <div class="emphasis e1232">k</div> 
            <div class="emphasis e1233">E</div> satisfies the last alternative of 
            <div class="emphasis e1234">TT
               <div class="subscript e1235">i</div>
            </div>, than CP has to process every alternative of 
            <div class="emphasis e1236">TT'
               <div class="subscript e1237">k</div>
            </div>. It means that it has to evaluate 
            <div class="emphasis e1238">d</div>
            <div class="subscript e1239">1</div> ⋅ ... ⋅ 
            <div class="emphasis e1240">d
               <div class="subscript e1241">k</div>
            </div> conditions, where each condition is the conjunction of 
            <div class="emphasis e1242">k</div> XPath predicates.
         </div>
         <div class="para e1243">After the 
            <div class="emphasis e1244">TT'
               <div class="subscript e1245">k</div>
            </div> evaluation, CP already knows whether 
            <div class="emphasis e1246">E</div> and 
            <div class="emphasis e1247">T</div> satisfy CTSR without the need to walk on the derivation chain: if 
            <div class="emphasis e1248">TT'
               <div class="subscript e1249">k</div>
            </div> selected type 
            <div class="emphasis e1250">error</div> then CTSR is violated, otherwise CTSR is satisfied. The problem is that the evaluation
            of 
            <div class="emphasis e1251">TT'
               <div class="subscript e1252">k</div>
            </div> might be very expensive.
         </div>
         <div class="para e1253">On the other hand, after the 
            <div class="emphasis e1254">TT
               <div class="subscript e1255">k</div>
            </div> evaluation, both OCP and RTC execute further operations. OCP evaluates the error
            condition linked to the alternative returned by 
            <div class="emphasis e1256">TT
               <div class="subscript e1257">k</div>
            </div>, while RTC evaluates 
            <div class="emphasis e1258">TT
               <div class="subscript e1259">k</div>
            </div>
            <div class="subscript e1260">-1</div>. Thus, for the purposes of our comparison, it is important to understand whether
            evaluating the error condition is more or less expensive than evaluating 
            <div class="emphasis e1261">TT
               <div class="subscript e1262">k</div>
            </div>
            <div class="subscript e1263">-1</div>. In order deal with a clearer notation, we temporarily rename some variables:
         </div>
         <div class="itemizedlist e1264">
            <div class="listitem e1265">
               <div class="para e1266">
                  <div class="emphasis e1267">T
                     <div class="subscript e1268">k</div>
                  </div> becomes 
                  <div class="emphasis e1269">R</div>;
               </div>
            </div>
            <div class="listitem e1270">
               <div class="para e1271">
                  <div class="emphasis e1272">T
                     <div class="subscript e1273">k</div>
                  </div>
                  <div class="subscript e1274">-1</div> becomes 
                  <div class="emphasis e1275">B</div>;
               </div>
            </div>
            <div class="listitem e1276">
               <div class="para e1277">
                  <div class="emphasis e1278">TT
                     <div class="subscript e1279">k</div>
                  </div> becomes 
                  <div class="emphasis e1280">TT
                     <div class="subscript e1281">R</div>
                  </div>;
               </div>
            </div>
            <div class="listitem e1282">
               <div class="para e1283">
                  <div class="emphasis e1284">TT
                     <div class="subscript e1285">k</div>
                  </div>
                  <div class="subscript e1286">-1</div> becomes 
                  <div class="emphasis e1287">TT
                     <div class="subscript e1288">B</div>
                  </div>;
               </div>
            </div>
            <div class="listitem e1289">
               <div class="para e1290">
                  <div class="emphasis e1291">d
                     <div class="subscript e1292">k</div>
                  </div> becomes 
                  <div class="emphasis e1293">n</div>;
               </div>
            </div>
            <div class="listitem e1294">
               <div class="para e1295">
                  <div class="emphasis e1296">d
                     <div class="subscript e1297">k</div>
                  </div>
                  <div class="subscript e1298">-1</div> becomes 
                  <div class="emphasis e1299">m</div>;
               </div>
            </div>
         </div>
         <div class="para e1300">We denote the 
            <div class="emphasis e1301">TT
               <div class="subscript e1302">R</div>
            </div> alternatives by &lt;
            <div class="emphasis e1303">r</div>
            <div class="subscript e1304">1</div>, 
            <div class="emphasis e1305">R</div>
            <div class="subscript e1306">1</div>&gt;, ..., &lt;
            <div class="emphasis e1307">r
               <div class="subscript e1308">n</div>
            </div>, 
            <div class="emphasis e1309">R
               <div class="subscript e1310">n</div>
            </div>&gt;; and the 
            <div class="emphasis e1311">TT
               <div class="subscript e1312">B</div>
            </div> alternatives by &lt;
            <div class="emphasis e1313">b</div>
            <div class="subscript e1314">1</div>, 
            <div class="emphasis e1315">B</div>
            <div class="subscript e1316">1</div>&gt;, ..., &lt;
            <div class="emphasis e1317">b
               <div class="subscript e1318">m</div>
            </div>, 
            <div class="emphasis e1319">B
               <div class="subscript e1320">m</div>
            </div>&gt;. Moreover, let 
            <div class="emphasis e1321">i</div> be the (index of the) alternative selected by 
            <div class="emphasis e1322">TT
               <div class="subscript e1323">R</div>
            </div>. We denote the error condition associated to that alternative by 
            <div class="emphasis e1324">err
               <div class="subscript e1325">i</div>
            </div>.
         </div>
         <div class="para e1326">As already observed in Section “
            <div class="xref e1327" linkend="sectOCPStaticPhase"></div>”, 
            <div class="emphasis e1328">err
               <div class="subscript e1329">i</div>
            </div> is a boolean expression over the XPath predicates (here called 
            <div class="emphasis e1330">atoms</div>) of 
            <div class="emphasis e1331">TT
               <div class="subscript e1332">B</div>
            </div>. Assuming the simplification process did 
            <div class="emphasis e1333">not</div> rewrite it, 
            <div class="emphasis e1334">err
               <div class="subscript e1335">i</div>
            </div> contains each of the 
            <div class="emphasis e1336">m</div> atoms of 
            <div class="emphasis e1337">TT
               <div class="subscript e1338">B</div>
            </div>.
         </div>
         <div class="figure e1339" floatstyle="1" xml:id="figErrorConditionStructure" xreflabel="OCP Error Condition Example">
            <div class="title e1340">OCP Error Condition Example</div>
            <div class="mediaobject e1341">
               <div class="imageobject e1342">
                  <div class="metaBox e1343"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e3307').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e3307" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e1343'
                           </span><span class="metaAttribute">fileref='../../../vol1/graphics/Marinelli01/Marinelli01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e1344">
               <div class="para e1345">Structure for the error condition 
                  <div class="code e1346">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or (@kind='XML'
                     or FALSE))))
                  </div>. XPath predicates have been abbreviated for conciseness reasons.
               </div>
            </div>
         </div>
         <div class="para e1347">At this point it is important to study the structure of a generic error expression
            
            <div class="emphasis e1348">err
               <div class="subscript e1349">i</div>
            </div>. As also shown in Figure “
            <div class="xref e1350" linkend="figErrorConditionStructure"></div>”, an error condition has a fixed structure: for each 
            <div class="code e1351">or</div> (
            <div class="code e1352">and</div>) operator, its left operand is always a (negated) atom, while its right operand is
            either another binary operator, or 
            <div class="code e1353">FALSE</div> (
            <div class="code e1354">TRUE</div>). Moreover, we can observe that the atoms appear in the same order they appear in
            
            <div class="emphasis e1355">TT
               <div class="subscript e1356">B</div>
            </div>.
         </div>
         <div class="para e1357">It is easy to implement an error condition evaluator as a 
            <div class="emphasis e1358">lazy boolean evaluator</div>: for any input binary operator it always evaluates the left operand first, and it
            evaluates the right operand only if necessary. The atoms of 
            <div class="emphasis e1359">err
               <div class="subscript e1360">i</div>
            </div> actually evaluated by such a boolean evaluator are exactly the same as those evaluated
            by RTC to decide the 
            <div class="emphasis e1361">TT
               <div class="subscript e1362">B</div>
            </div> selected type.
         </div>
         <div class="para e1363">For instance, suppose that for a given 
            <div class="emphasis e1364">j</div> our 
            <div class="emphasis e1365">E</div> element does not satisfy none of 
            <div class="emphasis e1366">b</div>
            <div class="subscript e1367">1</div>, ..., 
            <div class="emphasis e1368">b
               <div class="subscript e1369">j</div>
            </div>
            <div class="subscript e1370">-1</div>, and it does satisfy 
            <div class="emphasis e1371">b
               <div class="subscript e1372">j</div>
            </div>. RTC evaluates 
            <div class="emphasis e1373">b</div>
            <div class="subscript e1374">1</div>, ...,
            <div class="emphasis e1375">b
               <div class="subscript e1376">j</div>
            </div>. Also our technique evaluates those predicates, and it does not evaluate further
            ones. Indeed within 
            <div class="emphasis e1377">err
               <div class="subscript e1378">i</div>
            </div>, 
            <div class="emphasis e1379">b
               <div class="subscript e1380">j</div>
            </div> appears either in negated form as left operand of an 
            <div class="code e1381">and</div> operator, or directly as left operand of an 
            <div class="code e1382">or</div> operator (it depends on whether or not 
            <div class="emphasis e1383">R
               <div class="subscript e1384">i</div>
            </div> is validly substitutable as restriction for 
            <div class="emphasis e1385">B
               <div class="subscript e1386">j</div>
            </div>). In either case, the 
            <div class="emphasis e1387">err
               <div class="subscript e1388">i</div>
            </div> evaluation stops before processing the right operand.
         </div>
         <div class="para e1389">Thus we can conclude that even if it is not possible to simplify 
            <div class="emphasis e1390">err
               <div class="subscript e1391">i</div>
            </div>, OCP and RTC are equivalent in terms of evaluated atoms. But there are cases in which
            
            <div class="emphasis e1392">err
               <div class="subscript e1393">i</div>
            </div> is simplified by the rewriting rules described in Section “
            <div class="xref e1394" linkend="sectOCPStaticPhase"></div>”. Indeed, if there exists a 
            <div class="emphasis e1395">j</div> such that either
         </div>
         <div class="itemizedlist e1396">
            <div class="listitem e1397">
               <div class="para e1398">for each  
                  <div class="emphasis e1399">j</div> &lt; 
                  <div class="emphasis e1400">j'</div> &lt;= 
                  <div class="emphasis e1401">m</div>, 
                  <div class="emphasis e1402">R
                     <div class="subscript e1403">i</div>
                  </div> is not validly substitutable as restriction for 
                  <div class="emphasis e1404">B
                     <div class="subscript e1405">j'</div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e1406">or</div>
         <div class="itemizedlist e1407">
            <div class="listitem e1408">
               <div class="para e1409">for each  
                  <div class="emphasis e1410">j</div> &lt; 
                  <div class="emphasis e1411">j'</div> &lt;= 
                  <div class="emphasis e1412">m</div>, 
                  <div class="emphasis e1413">R
                     <div class="subscript e1414">i</div>
                  </div> is validly substitutable as restriction for 
                  <div class="emphasis e1415">B
                     <div class="subscript e1416">j'</div>
                  </div>,
               </div>
            </div>
         </div>
         <div class="para e1417">then the simplification process removes from 
            <div class="emphasis e1418">err
               <div class="subscript e1419">i</div>
            </div> the atmos 
            <div class="emphasis e1420">b
               <div class="subscript e1421">j</div>
            </div>
            <div class="subscript e1422">+1</div>, ..., 
            <div class="emphasis e1423">b
               <div class="subscript e1424">m</div>
            </div>.
         </div>
         <div class="para e1425">In such cases, if 
            <div class="emphasis e1426">E</div> does not satisfy any of the predicates 
            <div class="emphasis e1427">b</div>
            <div class="subscript e1428">1</div>, ..., 
            <div class="emphasis e1429">b
               <div class="subscript e1430">j</div>
            </div>
            <div class="subscript e1431">+</div>
            <div class="emphasis e1432">
               <div class="subscript e1433">k</div>
            </div>, for some 
            <div class="emphasis e1434">k</div>, then OCP does not need to evaluate the 
            <div class="emphasis e1435">k</div> atoms 
            <div class="emphasis e1436">b
               <div class="subscript e1437">j</div>
            </div>
            <div class="subscript e1438">+1</div>, ..., 
            <div class="emphasis e1439">b
               <div class="subscript e1440">j</div>
            </div>
            <div class="subscript e1441">+</div>
            <div class="emphasis e1442">
               <div class="subscript e1443">k</div>
            </div> in order to decide whether CTSR is satisfied or not. On the other hand, RTC does
            evaluate those atoms, because it has to find the type actually selected by 
            <div class="emphasis e1444">TT
               <div class="subscript e1445">B</div>
            </div>.
         </div>
         <div class="para e1446">Thus, we can conclude that on a single step of a derivation chain, OCP evaluates a
            number of predicates less than or equal to the number of predicates evaluated by RTC.
         </div>
         <div class="para e1447">However, as can be noted from the formulas shown in Equations “
            <div class="xref e1448" linkend="equationRTCAlgoUpperBound"></div>” and “
            <div class="xref e1449" linkend="equationOCPRunTimePhaseUpperBound"></div>”, OCP might evaluate twice the same atoms. Coming back to the notation introduced
            early in this section, if 
            <div class="emphasis e1450">E</div> does not satisfy the error condition of the alternative selected by 
            <div class="emphasis e1451">TT
               <div class="subscript e1452">k</div>
            </div>, then OCP has to evaluate 
            <div class="emphasis e1453">TT
               <div class="subscript e1454">k</div>
            </div>
            <div class="subscript e1455">-1</div>. But as the error condition previously processed was built on the atoms of 
            <div class="emphasis e1456">TT
               <div class="subscript e1457">k</div>
            </div>
            <div class="subscript e1458">-1</div>, it is clear that some predicates of 
            <div class="emphasis e1459">TT
               <div class="subscript e1460">k</div>
            </div>
            <div class="subscript e1461">-1</div> might be processed twice.
         </div>
         <div class="para e1462">However, it is possible to ease such an additional cost if during the processing of
            an error condition, the result of each atom evaluation is stored in some data structure.
            In this way, an XPath predicate is actually evaluated only if it has not been evaluated
            yet.
         </div>
         <div class="para e1463">So we conclude that for a given derivation chain, OCP evaluates a number of XPath
            predicates less than or equal to the number of XPath predicates RTC evaluates.
         </div>
      </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1464" xml:id="sectImplementation" xreflabel="Implementation">
         <div class="title e1465">Implementation</div>
         <div class="para e1466">We realized a prototype implementation of Optimized Cartesian Product, thus demonstrating
            its feasibility. We implemented it in Java within Xerces [
            <div class="xref e1467" linkend="entryXerces"></div>]. Our prototype patches Xerces under three aspects:
         </div>
         <div class="orderedlist e1468">
            <div class="listitem e1469">
               <div class="para e1470">support for XSD 1.1 related components;</div>
            </div>
            <div class="listitem e1471">
               <div class="para e1472">implementation of the OCP static phase;</div>
            </div>
            <div class="listitem e1473">
               <div class="para e1474">implementation of the OCP run-time phase within the existing validation code.</div>
            </div>
         </div>
         <div class="para e1475">As Xerces is an XML parser for XSD 1.0, it does not handle 1.1-specific constructs.
            Our prototype modifies the Xerces modules delegated to the construction of schema
            components (package 
            <div class="code e1476">org.apache.xerces.impl.xs.traversers</div>). It also modifies the Xerces implementation of the XML Schema API [
            <div class="xref e1477" linkend="entryXMLSchemaAPI"></div>], in order to represent type alternative components, and to give element declarations
            awareness of their Type Tables (packages 
            <div class="code e1478">org.apache.xerces.xs</div> and 
            <div class="code e1479">org.apache.xerces.impl.xs</div>).
         </div>
         <div class="para e1480">The OCP static phase is implemented within a separated package 
            <div class="code e1481">it.unibo.cs.cta</div>. The code for the error condition construction is within the class 
            <div class="code e1482">it.unibo.cs.cta.preprocessor.impl.ErrorConditionBuilder</div>. Such a class processes an input XSD schema, associating each type with a map. That
            map is our implementation of 
            <div class="emphasis e1483">tt-map
               <div class="superscript e1484">T</div>
            </div>. Indeed, it associates element names to context-determined Type Tables. 
            <div class="code e1485">ErrorConditionBuilder</div> also annotates each context-determined Type Table with its error conditions. Error
            conditions are built directly using the algorithm described in Section “
            <div class="xref e1486" linkend="sectOCPStaticPhase"></div>”. The classes handling error conditions are within the package 
            <div class="code e1487">it.unibo.cs.cta.errorexpr</div>. In particular, the simplification of error conditions is implemented by 
            <div class="code e1488">ErrorExpressionSimplifier</div>, while their evaluation is implemented by 
            <div class="code e1489">ErrorExpressionEvaluator</div>.
         </div>
         <div class="para e1490">The static phase is delegated to a pre-processor invoked when a schema document is
            loaded. In order to invoke it, the simple and compact code below is used:
         </div>
         <div class="programlisting e1491" xml:space="preserve">
            
            <div class="emphasis e1492">// instantiation </div>
            PreprocessorFactory pf = PreprocessorFactory.getInstance();
            fPreprocessor = pf.createPreprocessorSequence(
            new String[]{"ErrorConditionBuilder"}
            );
            
            <div class="emphasis e1493">// invocation on an XS Model</div>
            fPreprocessor.processModel(model);
            
         </div>
         <div class="para e1494">The static phase result (i.e., association between types and maps) is read calling
            the pre-processor method 
            <div class="code e1495">getStateByName("type-table-map")</div>.
         </div>
         <div class="para e1496">The OCP run-time phase is implemented within the class 
            <div class="code e1497">org.apache.xerces.impl.xs.OptimizedCTAXMLSchemaValidator</div>, a patched version of the original XSD validator provided by Xerces. In particular,
            the code for the CTSR verification is within the method 
            <div class="code e1498">handleStartElement</div>. XPath predicates are evaluated using the interfaces in 
            <div class="code e1499">javax.xml.xpath</div>. Currently, our prototype does not check whether an XPath predicate has already been
            evaluated. Thus, as observed in Section “
            <div class="xref e1500" linkend="sectComparison"></div>”, an XPath predicate might be evaluated twice for the same element.
         </div>
         <div class="para e1501">Our prototype is meant to prove the OCP feasibility, and as such it is not aimed to
            be XSD 1.1 conformant. In particular it has some limitations, the most important of
            which are:
         </div>
         <div class="orderedlist e1502">
            <div class="listitem e1503">
               <div class="para e1504">XPath 1.0 expressions only are accepted;</div>
            </div>
            <div class="listitem e1505">
               <div class="para e1506">all non CTA related syntax is ignored. E.g., 
                  <div class="code e1507">&lt;assert&gt;</div> elements are not considered legal within a schema;
               </div>
            </div>
            <div class="listitem e1508">
               <div class="para e1509">derivations by restriction are checked using the original Xerces code, i.e., XSD 1.0
                  rules are applied.
                  <div class="popupBox e1510">
                     <div class="popupLabel" onmouseover="$('#d1e3704').show('1000');" onmouseout="$('#d1e3704').hide('1000');">[ footnote ]</div>
                     <div id="d1e3704" style="display: none;">
                        <div class="footnote">
                           <div class="para e1511">XSD 1.0 defines the derivation by restriction in terms of ad hoc rules provided by
                              the recommendation itself. XSD 1.1 allows processors to choose the algorithm they
                              like to check whether a content model includes another content model.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e1512">We also developed a small test suite for OCP. It can be run through a simple graphic
            interface. Source code and jars are available from 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1513" xlink:actuate="onRequest" xlink:href="http://tesi.fabio.web.cs.unibo.it/Tesi/OptimizedCartesianProduct" xlink:show="new" xlink:type="simple">http://tesi.fabio.web.cs.unibo.it/Tesi/OptimizedCartesianProduct</div>.
         </div>
      </div><a name="RelatedWorksANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1514" xml:id="sectRelatedWorks" xreflabel="Related Works">
         <div class="title e1515">Related Works</div>
         <div class="para e1516">Among the most known validation languages (DTD [
            <div class="xref e1517" linkend="entryXML11"></div>], RELAX NG [
            <div class="xref e1518" linkend="entryRELAXNGISOspecification"></div>], Schematron [
            <div class="xref e1519" linkend="entrySchematronISOspecification"></div>], DSD [
            <div class="xref e1520" linkend="entryDSD20"></div>], etc), the problem of verifying the subtype relation in presence of conditional
            declarations is very specific to XSD 1.1. Indeed, although there exist at least one
            language, DSD, permitting the definition of conditional content models, that language
            is not type-based, and consequently nor it has any concept of type derivation. We
            do not know works about restriction checking in presence of conditional declarations.
         </div>
         <div class="para e1521">However, there exist works on the problem of verifying whether an XSD 1.0 type is
            a legal restriction of another type [
            <div class="xref e1522" linkend="entryFSAThompson"></div>], [
            <div class="xref e1523" linkend="entryFuchs"></div>], [
            <div class="xref e1524" linkend="entryBrzozowski"></div>]. Those works propose techniques to statically verify whether a type accepts a subset
            of what the base type accepts. On the same line, Neven et al present theoretical results
            about some basic decision problems concerning schemas, among which the problem of
            testing for inclusion of schemas [
            <div class="xref e1525" linkend="entryNeven1PassPreorder"></div>].
         </div>
      </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1526" xml:id="sectConclusions" xreflabel="Conclusions">
         <div class="title e1527">Conclusions</div>
         <div class="para e1528">In XSD 1.1, the presence of conditional declarations increases the difficulty in verifying
            whether a type is a legal restriction of its base. We discussed about three main approaches
            to the problem: CTA usage limitation, run-time verification, and hybrid verification.
            Solutions of the first kind ensure it is possible to 
            <div class="emphasis e1529">statically</div> verify whether a type is a legal restriction of its base, but at the cost of limiting
            the CTA expressivity. Solutions of both second and third kinds allow the highest degree
            of expressivity, but they may recognize as legal restriction also a type accepting
            something its base rejects. They throw an error only for those instance documents
            actually proving that a type is not a legal restriction of its base. Hybrid solutions
            are meant to precompute during the static phase some information that might decrease
            the work to be done at run-time.
         </div>
         <div class="para e1530">In particular, we described the solution adopted by the XSD current draft, which follows
            a run-time approach described within the specs by the Conditional Type Substitutable
            in Restriction (CTSR) constraint. We discussed about an algorithm verifying CTSR,
            and we called it Run-Time Check (RTC). Then we proposed an alternative solution to
            RTC, named Optimized Cartesian Product (OCP). OCP is a hybrid solution. Its idea is
            to analyze conditional declarations in order to statically decide which XPath predicates
            can be ignored at run-time. We showed as, contrary to Cartesian Product (CP) - another
            hybrid solution OCP can be seen as an optimization of - the OCP static analysis cost
            is perfectly acceptable.
         </div>
         <div class="para e1531">We than compared the RTC, OCP and CP techniques, focusing on the number of XPath predicates
            evaluated at run-time. We showed as CP is the worst technique, as it inherits from
            the static phase a high volume of information that might heavily slow down the run-time
            phase. We also showed that although OCP might process the same alternatives twice,
            storing the XPath predicate evaluation results, we can assert that OCP evaluates a
            number of predicates less than or equal to the number of predicates RTC evaluates.
         </div>
         <div class="para e1532">An interesting future work is the experimental comparison among RTC, OCP and CP on
            a base of real schema documents. Moreover it is interesting to improve our error condition
            simplification process. For instance, our simplification rules are not able to rewrite
            expressions like 
            <div class="code e1533">not(@a = 'v1') and (@a = 'v2')</div> into 
            <div class="code e1534">(@a = 'v2')</div>. There are also error conditions that are clearly unsatisfiable when associated to
            a particular alternative. For instance, if the alternative predicate is 
            <div class="code e1535">(@a = 'v1')</div> and the error condition is 
            <div class="code e1536">(@a = 'v2')</div>, it is clear that the error condition will never be satisfied. Improving the simplification
            rule set should increase the number of situations in which OCP is preferable to RTC.
         </div>
      </div><a name="AcknowledgementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1537" xml:id="sectAcknowledgements" xreflabel="Acknowledgements">
         <div class="title e1538">Acknowledgements</div>
         <div class="para e1539">We would like to thank Stefano Zacchiroli for the technical discussions we had during
            the design of the Optimized Cartesian Product technique, the anonymous reviewers for
            their comments, and the XML Schema Working Group for the several and inspiring discussions
            on the topics covered by this paper.
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e1540">
         <div class="title e1541">References</div>
         <div class="bibliomixed e1542" xml:id="entryCoOccurrenceConstraintsESWWiki" xreflabel="Co-occurrence constraints ESW Wiki">Co-occurrence constraints ESW Wiki. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1543" xlink:actuate="onRequest" xlink:href="http://esw.w3.org/topic/Co-occurrence_constraints" xlink:show="new" xlink:type="simple">http://esw.w3.org/topic/Co-occurrence_constraints</div>
         </div>
         <div class="bibliomixed e1544" xml:id="entryDSD20" xreflabel="DSD 2.0">Møller, A. 2002. Document Structure Description 2.0. BRICS, Department of Computer
            Science, University of Aarhus, Aarhus, Denmark. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1545" xlink:actuate="onRequest" xlink:href="http://www.brics.dk/DSD/" xlink:show="new" xlink:type="simple">http://www.brics.dk/DSD/</div>.
         </div>
         <div class="bibliomixed e1546" xml:id="entryFuchs" xreflabel="M. Fuchs, and A. Brown, 2003">M. Fuchs, and A. Brown. Supporting UPA and restriction on an extension of XML Schema.
            In 
            <div class="emphasis e1547">Proceedings of Extreme Markup Languages</div>. August, 2003. Montréal, Québec. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1548" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/extreme03/html/2003/Fuchs01/EML2003Fuchs01.html" xlink:show="new" xlink:type="simple">http://www.idealliance.org/papers/extreme03/html/2003/Fuchs01/EML2003Fuchs01.html</div>.
         </div>
         <div class="bibliomixed e1549" xml:id="entrySchemaPathWWW" xreflabel="P. Marinelli, C. Sacerdoti Coen, and F. Vitali, 2004">P. Marinelli, C. Sacerdoti Coen, and F. Vitali. SchemaPath, a Minimal Extension to
            XML Schema for Conditional Constraints. In 
            <div class="emphasis e1550">Proceedings of the Thirteenth International World Wide Web Conference</div>. New York, NY, USA. May, 2004. Pages 164-174. ACM Press. doi:
            <div class="biblioid doi e1551">10.1145/988672.988695</div>.
         </div>
         <div class="bibliomixed e1552" xml:id="entryNeven1PassPreorder" xreflabel="W. Martens, F. Neven, and T. Schwentick, 2005">W. Martens, F. Neven, and T. Schwentick. Which XML Schemas Admit 1-Pass Preorder Typing?
            In 
            <div class="emphasis e1553">Proceedings of the 10
               <div class="superscript e1554">th</div> International Conference on Database Theory
            </div>. Edinburgh, UK, January 5-7, 2005. LNCS. Volume 3363. Pages 68-82. doi:
            <div class="biblioid doi e1555">10.1007/978-3-540-30570-5_5</div>.
         </div>
         <div class="bibliomixed e1556" xml:id="entryRELAXNGISOspecification" xreflabel="RELAX NG ISO specification">Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar-based
            validation -- RELAX NG. ISO/IEC 19757-2:2003, JTC1/SC34 Committee. Publicly available
            at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1557" xlink:actuate="onRequest" xlink:href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c037605_ISO_IEC_19757-2_2003(E).zip" xlink:show="new" xlink:type="simple">http://standards.iso.org/ittf/PubliclyAvailableStandards/c037605_ISO_IEC_19757-2_2003(E).zip</div>
         </div>
         <div class="bibliomixed e1558" xml:id="entrySchematronISOspecification" xreflabel="Schematron ISO specification">Information technology -- Document Schema Definition Language (DSDL) -- Part 3: Rule-based
            validation -- Schematron. ISO/IEC 19757-3:2006, JTC1/SC34 Committee. Publicly available
            at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1559" xlink:actuate="onRequest" xlink:href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip" xlink:show="new" xlink:type="simple">http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</div>.
         </div>
         <div class="bibliomixed e1560" xml:id="entryBrzozowski" xreflabel="C. M. Sperberg-McQueen, 2005">C. M. Sperberg-McQueen. Applications of Brzozowski derivatives to XML Schema processing.
            In 
            <div class="emphasis e1561">Proceedings of Extreme Markup Languages</div>. August, 2005. Montréal, Québec. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1562" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/Extreme/Proceedings/html/2005/SperbergMcQueen01/EML2005SperbergMcQueen01.html" xlink:show="new" xlink:type="simple">http://www.mulberrytech.com/Extreme/Proceedings/html/2005/SperbergMcQueen01/EML2005SperbergMcQueen01.html</div>.
         </div>
         <div class="bibliomixed e1563" xml:id="entryFSAThompson" xreflabel="H. S. Thompson, and R. Tobin, 2003">H. S. Thompson, and R. Tobin. Using Finite State Automata to Implement W3C XML Schema
            Content Model Validation and Restriction Checking. In 
            <div class="emphasis e1564">Proceedings of XML Europe</div>. London, England. May, 2003. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1565" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/dx_xmle03/papers/02-02-05/02-02-05.html" xlink:show="new" xlink:type="simple">http://www.idealliance.org/papers/dx_xmle03/papers/02-02-05/02-02-05.html</div>.
         </div>
         <div class="bibliomixed e1566" xml:id="entryWalshCowan2001" xreflabel="N. Walsh and J. Cowan, 2001">N. Walsh, and J. Cowan. Schema Language Comparison. December, 2001. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1567" xlink:actuate="onRequest" xlink:href="http://nwalsh.com/xml2001/schematownhall/slides/" xlink:show="new" xlink:type="simple">http://nwalsh.com/xml2001/schematownhall/slides/</div>.
         </div>
         <div class="bibliomixed e1568" xml:id="entryXerces" xreflabel="Xerces">The Apache Software Foundation. Apache Xerces. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1569" xlink:actuate="onRequest" xlink:href="http://xml.apache.org" xlink:show="new" xlink:type="simple">http://xml.apache.org</div>.
         </div>
         <div class="bibliomixed e1570" xml:id="entryXMLSchemaAPI" xreflabel="XML Schema API">Elena Litani. XML Schema API. W3C Member Submission. 22 January 2004. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1571" xlink:actuate="onRequest" xlink:href="http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040122/" xlink:show="new" xlink:type="simple">http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040122/</div>.
         </div>
         <div class="bibliomixed e1572" xml:id="entryXML11" xreflabel="XML 1.1">Extensible Markup Language (XML) 1.1 (Second Edition). W3C Recommendation. 16 August
            2006. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1573" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml11/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml11/</div>.
         </div>
         <div class="bibliomixed e1574" xml:id="entryXSD1.0-structures" xreflabel="XSD 1.0: Structures">XML Schema Part 1: Structures Second Edition. W3C Recommendation. 28 October 2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1575" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-1/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-1/</div> 
         </div>
         <div class="bibliomixed e1576" xml:id="entryXSD1.0-datatypes" xreflabel="XSD 1.0: Datatypes">XML Schema Part 2: Datatypes Second Edition. W3C Recommendation. 28 October 2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1577" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-2/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-2/</div>
         </div>
         <div class="bibliomixed e1578" xml:id="entryXSD1.1-structures" xreflabel="XSD 1.1: Structures">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures. W3C Working Draft.
            20 June 2008. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1579" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/</div>
         </div>
         <div class="bibliomixed e1580" xml:id="entryXSD1.1-datatypes" xreflabel="XSD 1.1: Datatypes">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes. W3C Working Draft.
            20 June 2008. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1581" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/</div>
         </div>
      </div>
   </div>
</div>