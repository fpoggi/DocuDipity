<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#FromXMLtoUDL:aunifieddocumentlanguagesupportingmultiplemarkuplanguagesANCHOR" name="FromXMLtoUDL:aunifieddocumentlanguagesupportingmultiplemarkuplanguagesTOC">From XML to UDL: a unified document language, supporting multiple markup languages</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DistinctionbetweenmarkupanddocumentlanguageANCHOR" name="DistinctionbetweenmarkupanddocumentlanguageTOC">Distinction between markup and document language</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AThemainidea%0AANCHOR" name="%0AThemainidea%0ATOC">
                  The main idea
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#GoalsandnongoalsANCHOR" name="GoalsandnongoalsTOC">Goals and non-goals</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConceptsANCHOR" name="ConceptsTOC">Concepts</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AThenodemodelasaunifieddocumentlanguage%0AANCHOR" name="%0AThenodemodelasaunifieddocumentlanguage%0ATOC">
                     The node model as a unified document language
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AThenoderepresentationofJSONmarkup%0AANCHOR" name="%0AThenoderepresentationofJSONmarkup%0ATOC">
                     The node representation of JSON markup
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXMLmarkuplanguage%0AANCHOR" name="%0AExtensionsoftheXMLmarkuplanguage%0ATOC">
                     Extensions of the XML markup language
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXPathlanguage%0AANCHOR" name="%0AExtensionsoftheXPathlanguage%0ATOC">
                     Extensions of the XPath language
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXQuerylanguage%0AANCHOR" name="%0AExtensionsoftheXQuerylanguage%0ATOC">
                     Extensions of the XQuery language
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AProposal:extensionsofXMLXPathandXQuery%0AANCHOR" name="%0AProposal:extensionsofXMLXPathandXQuery%0ATOC">
                  Proposal: extensions of XML, XPath and XQuery
                  </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXMLnodemodel%0AANCHOR" name="%0AExtensionsoftheXMLnodemodel%0ATOC">
                     Extensions of the XML node model
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXMLmarkuplanguage%0AANCHOR" name="%0AExtensionsoftheXMLmarkuplanguage%0ATOC">
                     Extensions of the XML markup language
                     </a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#%0AExpressingthenewnodeproperties%0AANCHOR" name="%0AExpressingthenewnodeproperties%0ATOC">
                        Expressing the new node properties
                        </a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#%0ASupportingnonXMLmarkup%0AANCHOR" name="%0ASupportingnonXMLmarkup%0ATOC">
                        Supporting non-XML markup
                        </a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXMLserializationmodel%0AANCHOR" name="%0AExtensionsoftheXMLserializationmodel%0ATOC">
                     Extensions of the XML serialization model
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXPathlanguage%0AANCHOR" name="%0AExtensionsoftheXPathlanguage%0ATOC">
                     Extensions of the XPath language
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AExtensionsoftheXQuerylanguage%0AANCHOR" name="%0AExtensionsoftheXQuerylanguage%0ATOC">
                     Extensions of the XQuery language
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CheckingusecasesANCHOR" name="CheckingusecasesTOC">Checking use cases</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AVariousdetails%0AANCHOR" name="%0AVariousdetails%0ATOC">
                  Various details
                  </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AUDLpseudoattributesandpseudotags%0AANCHOR" name="%0AUDLpseudoattributesandpseudotags%0ATOC">
                     UDL - pseudo-attributes and pseudo-tags
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AMixingmarkupstyles%0AANCHOR" name="%0AMixingmarkupstyles%0ATOC">
                     Mixing markup styles
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AXMLsyntaxvariant:%0AANCHOR" name="%0AXMLsyntaxvariant:%0ATOC">
                     XML syntax variant: 
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ADeserializingfrom/serializingtoJSON%0AANCHOR" name="%0ADeserializingfrom/serializingtoJSON%0ATOC">
                     Deserializing from / serializing to JSON
                     </a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#%0ADeserialization%0AANCHOR" name="%0ADeserialization%0ATOC">
                        Deserialization
                        </a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#%0ASerialization%0AANCHOR" name="%0ASerialization%0ATOC">
                        Serialization
                        </a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ASerialization:controllingthelossofinformation%0AANCHOR" name="%0ASerialization:controllingthelossofinformation%0ATOC">
                     Serialization: controlling the loss of information
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AUDLandXSD%0AANCHOR" name="%0AUDLandXSD%0ATOC">
                     UDL and XSD
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0ALimitationsandfutureresearch%0AANCHOR" name="%0ALimitationsandfutureresearch%0ATOC">
                  Limitations and future research
                  </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AIssue:mappingarbitraryXMLtoJSON%0AANCHOR" name="%0AIssue:mappingarbitraryXMLtoJSON%0ATOC">
                     Issue: mapping arbitrary XML to JSON
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AIssue:mappingJSONtoreadableXML%0AANCHOR" name="%0AIssue:mappingJSONtoreadableXML%0ATOC">
                     Issue: mapping JSON to readable XML
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AIssue:RoundtrippingXMLJSONXML%0AANCHOR" name="%0AIssue:RoundtrippingXMLJSONXML%0ATOC">
                     Issue: Round-tripping XML - JSON - XML
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AConceivableextensionofUDL:integrationofstandardizedmappings%0AANCHOR" name="%0AConceivableextensionofUDL:integrationofstandardizedmappings%0ATOC">
                     Conceivable extension of UDL: integration of standardized mappings
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AAlternativestoUDL%0AANCHOR" name="%0AAlternativestoUDL%0ATOC">
                  Alternatives to UDL
                  </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AThemappingapproach%0AANCHOR" name="%0AThemappingapproach%0ATOC">
                     The mapping approach
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AJSONiq%0AANCHOR" name="%0AJSONiq%0ATOC">
                     JSONiq
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AMapitems%0AANCHOR" name="%0AMapitems%0ATOC">
                     Map items
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0ADiscussion%0AANCHOR" name="%0ADiscussion%0ATOC">
                  Discussion
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgementsANCHOR" name="AcknowledgementsTOC">Acknowledgements</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Deserializingfrom/serializingtoJSONANCHOR" name="Deserializingfrom/serializingtoJSONTOC">Deserializing from / serializing to JSON</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ADeserialization%0AANCHOR" name="%0ADeserialization%0ATOC">
                     Deserialization
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ASerialization%0AANCHOR" name="%0ASerialization%0ATOC">
                     Serialization
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Additionalsupportfor&#34;NCNameonlyJSON&#34;ANCHOR" name="Additionalsupportfor&#34;NCNameonlyJSON&#34;TOC">Additional support for "NCName-only JSON"</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0AIntroduction%0AANCHOR" name="%0AIntroduction%0ATOC">
                     Introduction
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ADefinitionofUDLdocumentstyles:nJSONnnJSON%0AANCHOR" name="%0ADefinitionofUDLdocumentstyles:nJSONnnJSON%0ATOC">
                     Definition of UDL document styles: nJSON, nnJSON
                     </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#%0ASpecialsupportfortheprocessingofnJSONdocuments%E2%80%93afurtherextensionofXPath%0AANCHOR" name="%0ASpecialsupportfortheprocessingofnJSONdocuments%E2%80%93afurtherextensionofXPath%0ATOC">
                     Special support for the processing of nJSON documents – a further extension of XPath
                     </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">arrays, booleans, nulls, numbers, objects, type</div>
         <div class="singletermTERMS">array</div>
         <div class="singletermTERMS">alternative markup languages</div>
         <div class="singletermTERMS">abbreviated syntax</div>
         <div class="singletermTERMS">Array constructors</div>
         <div class="singletermTERMS">application</div>
         <div class="singletermTERMS">automatically mapped</div>
         <div class="singletermTERMS">are</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">boolean, type</div>
         <div class="singletermTERMS">be</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">count(/*/*)</div>
         <div class="singletermTERMS">creation of JSON data</div>
         <div class="singletermTERMS">constructed</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">distinct-values(//#year/string())</div>
         <div class="singletermTERMS">doc("foo.json")</div>
         <div class="singletermTERMS">document language</div>
         <div class="singletermTERMS">defaulted node names</div>
         <div class="singletermTERMS">Details</div>
         <div class="singletermTERMS">default node-names</div>
         <div class="singletermTERMS">data selections</div>
         <div class="singletermTERMS">distinctive</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">exml:anonymous</div>
         <div class="singletermTERMS">exml:fullname, exml:maxOccurs</div>
         <div class="singletermTERMS">element name</div>
         <div class="singletermTERMS">element key</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">fn:node-key</div>
         <div class="singletermTERMS">fn:node-model</div>
         <div class="singletermTERMS">fn:deep-equal</div>
         <div class="singletermTERMS">for $s in distinct-values(//#sigs/*)</div>
         <div class="singletermTERMS">false</div>
         <div class="singletermTERMS">foundation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">html</div>
         <div class="singletermTERMS">Handling attributes</div>
         <div class="singletermTERMS">Handling of processing instructions and comments</div>
         <div class="singletermTERMS">Handling elements</div>
         <div class="singletermTERMS">hrennau@yahoo.de</div>
         <div class="singletermTERMS">Hans-Jürgen</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">info-loss</div>
         <div class="singletermTERMS">is</div>
         <div class="singletermTERMS">information language</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">json</div>
         <div class="singletermTERMS">json-content-elements</div>
         <div class="singletermTERMS">json.strict</div>
         <div class="singletermTERMS">json.ignore-names</div>
         <div class="singletermTERMS">json.projection</div>
         <div class="singletermTERMS">json, value</div>
         <div class="singletermTERMS">json, item</div>
         <div class="singletermTERMS">JSON simple values</div>
         <div class="singletermTERMS">JSON null values</div>
         <div class="singletermTERMS">JSON objects</div>
         <div class="singletermTERMS">JSON arrays</div>
         <div class="singletermTERMS">JSON names</div>
         <div class="singletermTERMS">JSON null</div>
         <div class="singletermTERMS">JSON object</div>
         <div class="singletermTERMS">JSON array</div>
         <div class="singletermTERMS">JSON simple value</div>
         <div class="singletermTERMS">JSON&gt;</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">key test</div>
         <div class="singletermTERMS">Key-oriented constructors</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">markup</div>
         <div class="singletermTERMS">method</div>
         <div class="singletermTERMS">max(//#price/xs:decimal(.))</div>
         <div class="singletermTERMS">markup language</div>
         <div class="singletermTERMS">Map constructors</div>
         <div class="singletermTERMS">mappings</div>
         <div class="singletermTERMS">mparse</div>
         <div class="singletermTERMS">mserialize</div>
         <div class="singletermTERMS">map</div>
         <div class="singletermTERMS">Markup integration</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">null</div>
         <div class="singletermTERMS">name, starts, type</div>
         <div class="singletermTERMS">nnjson</div>
         <div class="singletermTERMS">non-XML document without XML declaration</div>
         <div class="singletermTERMS">need</div>
         <div class="singletermTERMS">now</div>
         <div class="singletermTERMS">nJSON</div>
         <div class="singletermTERMS">nnJSON</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">object</div>
         <div class="singletermTERMS">only</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">patternsAndNames</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">return $s</div>
         <div class="singletermTERMS">represented</div>
         <div class="singletermTERMS">Rennau</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">selection of data</div>
         <div class="singletermTERMS">Selecting JSON data with XPath/XQuery.</div>
         <div class="singletermTERMS">sees</div>
         <div class="singletermTERMS">Senior Java developer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">telem</div>
         <div class="singletermTERMS">telem-content-elements</div>
         <div class="singletermTERMS">true</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">transformation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">udl:key</div>
         <div class="singletermTERMS">udl:null</div>
         <div class="singletermTERMS">udl:value</div>
         <div class="singletermTERMS">udl:array</div>
         <div class="singletermTERMS">udl:map</div>
         <div class="singletermTERMS">udl:model</div>
         <div class="singletermTERMS">udl:defaultModel</div>
         <div class="singletermTERMS">udl:markup</div>
         <div class="singletermTERMS">udl:markupSection</div>
         <div class="singletermTERMS">udl</div>
         <div class="singletermTERMS">use of JSON data in expressions</div>
         <div class="singletermTERMS">used in expressions</div>
         <div class="singletermTERMS">UDL</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xml</div>
         <div class="singletermTERMS">xs:double</div>
         <div class="singletermTERMS">xs:decimal</div>
         <div class="singletermTERMS">xs:integer</div>
         <div class="singletermTERMS">xs:boolean</div>
         <div class="singletermTERMS">xs:untypedAtomic</div>
         <div class="singletermTERMS">xs:untyped</div>
         <div class="singletermTERMS">xsi:type</div>
         <div class="singletermTERMS">xml:id</div>
         <div class="singletermTERMS">xs:integer/xs:decimal/xs:double</div>
         <div class="singletermTERMS">XML declaration</div>
         <div class="singletermTERMS">XML</div>
         <div class="singletermTERMS">XDM</div>
         <div class="singletermTERMS">XPath</div>
         <div class="singletermTERMS">XQuery</div>
         <div class="singletermTERMS">XSLT</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="FromXMLtoUDL:aunifieddocumentlanguagesupportingmultiplemarkuplanguagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973">
      <div class="title e1">From XML to UDL: a unified document language, supporting multiple markup languages</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2012</div>
            <div class="confdates e5">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">
               A proposal is made how to extend the XML node model in order to be compatible with
               JSON markup as
               well as XML markup. As XML processing technology (XPath, XQuery, XSLT, XProc) sees
               instances
               of the node model, but does not see syntax, it is thus enabled to handle JSON as well
               as XML. 
               The extended node model is dubbed a Unified Document Language, as it defines the 
               construction of documents from building blocks (nodes)
               which can be encoded in various markup languages (XML, JSON, HTML).      
               
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Hans-Jürgen</div>
               <div class="surname e11">Rennau</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13"></div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Senior Java developer</div>
               <div class="orgname e16">Traveltainment GmbH</div>
            </div>
            <div class="email e17">hrennau@yahoo.de</div>
         </div>
         <div class="legalnotice e18">
            <div class="para e19">Copyright © 2012 by the author. Used with permission.</div>
         </div>
         <div class="keywordset e20" role="author">
            <div class="keyword e21">UDL</div>
            <div class="keyword e22">XML</div>
            <div class="keyword e23">JSON&gt;</div>
            <div class="keyword e24">Markup integration</div>
            <div class="keyword e25">XDM</div>
            <div class="keyword e26">XPath</div>
            <div class="keyword e27">XQuery</div>
            <div class="keyword e28">XSLT</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e29" xml:id="introduction">
         <div class="title e30">Introduction</div>
         <div class="para e31">
            Is an XML document a string or a tree of nodes? Although in many situations it can
            be 
            regarded as both, the “node view” is certainly more essential. It ignores syntax and
            
            sees the information content. Specialized programs (parser and serializer) provide
            for 
            the translation between document string and node tree. General processing technologies
            – 
            e.g. XQuery - ignore syntax. This principle is the very foundation of their power.
            
            Technologically speaking, the name “extensible markup language” is questionable, as
            it 
            emphasizes the surface, rather than the content.
            
         </div>
         <div class="para e32">
            The node view of XML is the result of an evolutionary process. The XML specification
            
            [
            <div class="xref e33" linkend="W3C-XML"></div>] (1998) itself does not use the word “node”. The tree 
            structure is still implicit, hidden behind the rules of well-formedness. The 
            infoset specification [
            <div class="xref e34" linkend="W3C-INFOSET"></div>] (2004) defined the XML document 
            as a tree of information items, which is similar to a tree of nodes.
            The XDM [
            <div class="xref e35" linkend="W3C-XDM"></div>] (2007) rounded the tree model 
            off, pruning it and extending it by replacing character children by a further node
            kind, 
            the text node. This completed node model was at the heart of the technological leap
            which 
            led to XPath 2.0, XSLT 2.0 and XQuery 1.0.
            
         </div>
         <div class="para e36">
            Taking the evolution into consideration, one might wonder about the relationship between
            
            XML and JSON. It is an obvious fact that they are two markup languages. But if XML
            is 
            essentially not a syntax, but an information language backed by a syntax – then we
            should 
            regard JSON as an information language plus syntax, too, and we should explore the
            
            relationships between their information models, rather than dwell on the difference
            of 
            syntax. 
            
         </div>
         <div class="para e37">
            Both models are tree models for hierarchical data. Why don’t we have one single, unified
            
            model for hierarchical data? If we had one, XML and JSON would not be two languages,
            but 
            two syntactical styles – a difference that ceases to exist during data processing,
            between 
            parsing and serializing the data. A uniform data model would enable unified data design
            
            approaches, and data processing could be handled by one single set of technologies.
            XML 
            and JSON parsers would act like adapters. Unfortunately, such a unified model does
            not 
            exist, due to incompatibilities. Although the XML model is larger and more complex,
            it 
            is not a superset of the JSON model. XML lacks arrays and maps and XML names cannot
            
            be arbitrary strings.
            
         </div>
         <div class="para e38">
            These incompatibilities throw a new light on XML. In 2011 Jonathan Robie 
            concluded [
            <div class="xref e39" linkend="ROBIE"></div>]:
            
            <div class="popupBox e40">
               <div class="popupLabel" onmouseover="$('#d1e69').show('1000');" onmouseout="$('#d1e69').hide('1000');">[ blockquote ]</div>
               <div id="d1e69" style="display: none;">
                  <div class="blockquote">
                     <div class="para e41">
                        <div class="emphasis e42" role="ital">
                           The dream of one universal markup language is now past. JSON is clearly here to 
                           stay, and it is becoming the format of choice for data interchange.
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e43">
            A possible response to this perception is a new dream: the dream of one universal
            
            information language, backed by several syntax variants aka markup languages. 
            If XML is not as universal as it looked a few years ago – might we extend the 
            language (no pun intended), restoring the universality? This dream is an illusion
            
            if we regard XML as a final version. In past years, any considered 
            improvements of XML were too insignificant to warrant the disruptions which a new
            
            version might entail. But now we face new proportions, dealing with the issue of 
            universality. We should explore our chances to regain universality by extending 
            the XML model in a moderate, backward compatible way. Eventually, the lessons JSON
            
            taught and teaches us might be to a huge benefit of XML – if we attempt to learn 
            them and act accordingly.
            
         </div>
      </div><a name="DistinctionbetweenmarkupanddocumentlanguageANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e44" xml:id="distinction-between-markup-and-document-language">
         <div class="title e45">Distinction between markup and document language</div>
         <div class="para e46">
            XML processing technology operates on node trees which capture 
            the information content of XML documents. The nodes may be constructed 
            from XML markup text, or in other ways. An XML document 
            
            <div class="emphasis e47" role="ital">is</div> a tree of nodes, 
            and it may be 
            <div class="emphasis e48" role="ital">represented</div> by markup. 
            Therefore one might distinguish a 
            <div class="emphasis e49" role="bold">document language</div>
            from a 
            <div class="emphasis e50" role="bold">markup language</div>. The former is a 
            system which defines basic 
            units of information, possible relationships between such units and rules how 
            they can be combined into composite entities, the document. A markup language 
            is a set of rules how to encode a document as a string. To complete the picture, one
            might 
            add the concept of an 
            <div class="emphasis e51" role="bold">information language</div>, 
            which models information in a more 
            general way – documents and their building blocks, the material 
            that may be inserted into or extracted from a document, and perhaps yet
            other forms of information. The triple XML / Infoset /
            XDM may be viewed as a stack consisting of a markup language, a document language
            
            and an information language. 
            This stack of languages is the foundation of technologies – XPath, XQuery, 
            XSLT, XProc – which enable to address and process information with amazing 
            simplicity and efficiency. 
            
         </div>
         <div class="para e52">
            
            <div class="note e53">
               <div class="title e54">Use of the term "node model"</div>
               <div class="para e55">
                  The node sub model of the XDM can be regarded as a refactoring of the 
                  infoset. The existence of two very similar, yet  distinct tree models – 
                  a tree of information items, and a tree of nodes representing the 
                  information items – is not really necessary and probably due to a 
                  historical process. In this paper, it is the XDM/nodes sub model what 
                  is regarded as the document model, rather than the infoset. The term 
                  used will be “XML node model”, or simply “node model”.
                  
               </div>
            </div>
            
         </div>
         <div class="para e56">
            Nevertheless, JSON has begun to replace XML in many applications. JSON is a 
            simpler and terser markup language, and it is perfectly integrated with 
            JavaScript objects. In many situations, JSON has clear advantages, when 
            neither the loss of expressive power, nor the lack of processing 
            technologies hurt. There is a growing awareness of the need to be 
            flexible, to avoid overhead and use the right tools: the necessity to adapt 
            the choice of markup language to the task at hand [
            <div class="xref e57" linkend="TENNISON"></div>].
            
         </div>
         <div class="para e58">
            Doubtless, the technological support for JSON will continuously evolve. 
            Very doubtful, however, it is if it can ever achieve the level attained 
            by XQuery 3.0 and XSLT 3.0. Maybe this will not be possible without a 
            similar evolution, adding to the markup language a document language 
            and an information language on which to base technology. I cannot 
            image that this would be possible without reinventing many wheels, with 
            the end result – in the best case – of a more limited version of XQuery and XSLT.
            
         </div>
         <div class="para e59">
            Let us explore the alternative: loosen the tight coupling between the 
            XML markup language and the XML document language, extending the latter 
            to become a unified document language (“UDL”) supporting multiple markup 
            languages – XML, JSON, HTML, …
            
         </div>
      </div><a name="%0AThemainidea%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e60" xml:id="the-main-idea">
         <div class="title e61">
            The main idea
            
         </div>
         <div class="para e62">
            This section presents the main idea of UDL – Unified Document Language -
            in a suggestive way and without any precision. It should provide a 
            conceptual backdrop for the remaining sections. What is a document 
            from the “UDL point of view”?
            
         </div>
         <div class="para e63">
            A document is a tree of elements. An element has content, which is either 
            text, or other elements, or both. An element has also two properties 
            designed to identify individual elements and to indicate the semantics 
            of the content. One property is the 
            
            <div class="emphasis e64" role="bold">element name</div>, the other one the 
            
            <div class="emphasis e65" role="bold">element key</div>. The name is a QName 
            and can be chosen irrespective of the sibling names; the key is an 
            arbitrary string and must not be equal to any sibling key.
            This duality implies three different styles how a document may be 
            designed:
            
            <div class="itemizedlist e66">
               <div class="listitem e67">
                  <div class="para e68">
                     name oriented – the elements are identified and described by names
                     
                  </div>
               </div>
               <div class="listitem e69">
                  <div class="para e70">
                     key oriented – the elements are identified and described by keys
                     
                  </div>
               </div>
               <div class="listitem e71">
                  <div class="para e72">
                     mixed – making use of both, names and keys
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e73">
            A document can be represented as a string, using a markup language. 
            XML is a markup language well-suited for name oriented documents; 
            JSON, on the other hand, is good at representing key oriented documents. 
            JSON is limited in this respect that it cannot represent arbitrary documents. 
            Only documents meeting certain constraints (using only unspecific standard 
            names, no attributes, no mixed content) can be represented by JSON. 
            XML, on the other hand, can represent any document, though not very 
            elegantly in the case of key oriented documents. 
            
         </div>
         <div class="para e74">
            The foundation of document processing is the XPath language, with a core 
            designed for selecting nodes within a document. Its query syntax supports 
            a stepwise navigation across the document, where each step filters a set 
            of candidate nodes by a so-called node test. One node test – the name 
            test - refers to the name property. Example:
            
            <div class="programlisting e75" xml:space="preserve">
               a/b[.//c]
            </div>
            This is a selection wholly based on element names. Another node test –
            the key test – refers to the key property. Example:
            
            <div class="programlisting e76" xml:space="preserve">
               #a/#b[.//#c]
            </div>
            This selection is based on element keys, rather than names. 
            Apart from that, the logic is exactly the same. Of course, node tests 
            and key tests can be mixed:
            
            <div class="programlisting e77" xml:space="preserve">
               a/b[.//#c]
            </div>
            
         </div>
         <div class="para e78">
            To generalize, element name and element key are just two properties 
            which XPath expressions and languages built upon XPath (XQuery, XSLT,
            XProc) can reference in a similar way. XML documents and JSON 
            documents are alternative styles of how to represent a UDL document 
            as text string. A parser translates XML documents and JSON documents 
            into UDL documents. A serializer translates a UDL document into an 
            XML document or a JSON document. The translation into XML is always 
            possible without loss of information. The translation into JSON 
            deals with any loss of information as prescribed by 
            serialization parameters. 
            
         </div>
         <div class="para e79">
            The remaining sections present a detailed proposal how to implement 
            the UDL by very limited extensions of the XML node model, XML markup, 
            XPath and XQuery.
            
         </div>
      </div><a name="GoalsandnongoalsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e80" xml:id="goals-and-non-goals">
         <div class="title e81">Goals and non-goals</div>
         <div class="para e82">
            The XML node model shall be turned into a
            unified document language, so that XML
            processing technology - which is built on
            the node model, not on markup - 
            becomes a unified processing technology. In particular,
            the document language must support JSON so that
            the processing technology (XPath, XQuery, XSLT, XProc)
            becomes applicable to JSON data as well as to XML data.
            
         </div>
         <div class="para e83">From this high-level objective 
            several goals are derived.
            
         </div>
         <div class="para e84">
            
            <div class="itemizedlist e85">
               <div class="listitem e86">
                  <div class="para e87">Extend the XML node model, enabling it to represent the information 
                     content of JSON documents as a tree of nodes.
                  </div>
               </div>
               <div class="listitem e88">
                  <div class="para e89">Define the serialization to/deserialization from JSON markup.</div>
               </div>
               <div class="listitem e90">
                  <div class="para e91">Extend the XML markup language, enabling it to express the 
                     extended node model completely.
                  </div>
               </div>
               <div class="listitem e92">
                  <div class="para e93">Extend the XML markup language, enabling the combination of 
                     XML and non-XML markup.
                  </div>
               </div>
               <div class="listitem e94">
                  <div class="para e95">Extend the XPath language, enabling navigation of JSON documents with the 
                     same degree of terseness and flexibility.
                  </div>
               </div>
               <div class="listitem e96">
                  <div class="para e97">Extend the XQuery language, adding shorthand notation for the construction
                     of JSON data.
                  </div>
               </div>
               <div class="listitem e98">
                  <div class="para e99">Make any changes to the XML node model in a backwards compatible way.</div>
               </div>
               <div class="listitem e100">
                  <div class="para e101">Make any changes to the XML markup language in a backwards compatible way.</div>
               </div>
               <div class="listitem e102">
                  <div class="para e103">Make any changes to the XPath language in a backwards compatible way.</div>
               </div>
               <div class="listitem e104">
                  <div class="para e105">Make any changes to the XQuery language in a backwards compatible way.</div>
               </div>
            </div>
            These are non-goals.
            
            <div class="itemizedlist e106">
               <div class="listitem e107">
                  <div class="para e108">
                     Do not attempt to define a mapping from JSON markup to 
                     XML markup (rather, define deserialization from / 
                     serialization to JSON).
                     
                     
                  </div>
               </div>
               <div class="listitem e109">
                  <div class="para e110">
                     Do not attempt to achieve elegance concerning the XML markup 
                     representation of a node tree derived from a JSON document.
                     
                  </div>
               </div>
               <div class="listitem e111">
                  <div class="para e112">
                     Do not attempt to support characters which are valid in JSON but are 
                     not valid in XML.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="ConceptsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e113" xml:id="concepts">
         <div class="title e114">Concepts</div>
         <div class="para e115">
            The proposed approach is an elaboration of a small number of concepts.
            
         </div><a name="%0AThenodemodelasaunifieddocumentlanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e116" xml:id="the-node-model-as-a-unified-document-language">
            <div class="title e117">
               The node model as a unified document language
               
            </div>
            <div class="para e118">
               
               <div class="orderedlist e119">
                  <div class="listitem e120">
                     <div class="para e121">
                        The XML node model is extended in such a way that any 
                        JSON document can be translated into a node tree
                        and back again without loss of information.
                        
                     </div>
                  </div>
                  <div class="listitem e122">
                     <div class="para e123">
                        XML markup continues to represent the complete node model – 
                        an extension of the node model must be accompanied by an 
                        extension of the XML markup language.
                        
                     </div>
                  </div>
                  <div class="listitem e124">
                     <div class="para e125">
                        As JSON markup represents a subset of the node model, 
                        the concept of serialization is elaborated, defining distinct 
                        modes characterized by the acceptable loss of information.
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AThenoderepresentationofJSONmarkup%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e126" xml:id="the-node-representation-of-json-markup">
            <div class="title e127">
               The node representation of JSON markup
               
            </div>
            <div class="para e128">
               
               <div class="orderedlist e129">
                  <div class="listitem e130">
                     <div class="para e131">
                        JSON structures (objects and arrays) and their members are modelled 
                        as element nodes and their child elements, thus enabling continuous 
                        navigation along the descendant axis.
                        
                     </div>
                  </div>
                  <div class="listitem e132">
                     <div class="para e133">
                        As JSON names can be arbitrary strings and must be unique among
                        sibling name/value pairs, they must not represent node 
                        names, which are QNames and need not be unique among
                        sibling elements. Rather, JSON names correspond to a new 
                        node property, [key]. As a consequence, 
                        element nodes have two properties 
                        related to discovery and content semantics: a required [name] property and an 
                        optional [key] property.
                        
                     </div>
                  </div>
                  <div class="listitem e134">
                     <div class="para e135">
                        The contradiction implied by the facts that node names are required and 
                        JSON is incapable of encoding node names is solved by the concept of 
                        
                        <div class="emphasis e136" role="ital">defaulted node names</div>: the nodes 
                        represented by JSON markup do have a name which is an unspecific 
                        standard name that depends on the content model of the 
                        node (representing an object, an array, a simple value or a null value). 
                        A node which has been constructed from JSON markup can afterwards be 
                        renamed without constraints, like any node constructed in any way.
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AExtensionsoftheXMLmarkuplanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e137" xml:id="concepts-extensions-of-the-xml-markup-language">
            <div class="title e138">
               Extensions of the XML markup language
               
            </div>
            <div class="para e139">
               
               <div class="orderedlist e140">
                  <div class="listitem e141">
                     <div class="para e142">
                        The necessary extension of the XML markup language avoids new 
                        syntactical constructs – it completely relies on the semantics 
                        of predefined QNames (e.g. 
                        <div class="code e143">udl:key</div>) used in pseudo-attributes 
                        (constructs which look like an attribute but do not represent a node) 
                        and pseudo-tags (which look like an element but do 
                        not represent a node).
                        
                     </div>
                  </div>
                  <div class="listitem e144">
                     <div class="para e145">
                        XML markup should be “opened”, permitting the local insertion of non-XML markup.
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AExtensionsoftheXPathlanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e146" xml:id="concepts-extensions-of-the-xpath-language">
            <div class="title e147">
               Extensions of the XPath language
               
            </div>
            <div class="para e148">
               
               <div class="orderedlist e149">
                  <div class="listitem e150">
                     <div class="para e151">
                        The XPath language is extended by a third node test – the 
                        
                        <div class="emphasis e152" role="ital">key test</div>, which checks whether 
                        the candidate node has a given key. In a path step, the key test 
                        can be used as alternative to a name test or kind test, which 
                        means that key tests are freely combinable with navigational axes.
                        
                     </div>
                  </div>
                  <div class="listitem e153">
                     <div class="para e154">
                        The syntax of a key test should be as simple as the syntax of a name test.
                        
                     </div>
                  </div>
               </div>        
               
            </div>
         </div><a name="%0AExtensionsoftheXQuerylanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e155" xml:id="concepts-extensions-of-the-xquery-language">
            <div class="title e156">
               Extensions of the XQuery language
               
            </div>
            <div class="para e157">
               
               <div class="orderedlist e158">
                  <div class="listitem e159">
                     <div class="para e160">
                        Extensions of the XQuery language are not essential, as JSON
                        data are element nodes and thus can be processed without any
                        restrictions. 
                        
                     </div>
                  </div>
                  <div class="listitem e161">
                     <div class="para e162">
                        Nevertheless, the addition of some abbreviated
                        syntax for the construction of  "JSON style nodes" 
                        would be quite helpful.
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </div><a name="%0AProposal:extensionsofXMLXPathandXQuery%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e163" xml:id="proposal-extensions-of-xml-xpath-and_xquery">
         <div class="title e164">
            Proposal: extensions of XML, XPath and XQuery
            
         </div>
         <div class="para e165">
            This section describes the proposed extensions of XML, XPath and XQuery in detail.
            
         </div><a name="%0AExtensionsoftheXMLnodemodel%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e166" xml:id="extensions-of-the-xml-node-model">
            <div class="title e167">
               Extensions of the XML node model
               
            </div>
            <div class="para e168">
               The XML node model is extended by two new node properties, [model] 
               and [key]. The result of these changes is a unified node model 
               which can represent XML documents, JSON documents as well as nested 
               combinations of JSON and XML fragments as a tree of nodes which 
               is accessible to XPath navigation and, by implication, XQuery 
               and XSLT processing.
               
            </div>
            <div class="para e169">
               
               <div class="emphasis e170" role="bold">
                  <div class="emphasis e171" role="ital">
                     Details
                     
                  </div>
               </div>
               
            </div>
            <div class="orderedlist e172">
               <div class="listitem e173">
                  <div class="para e174">
                     The node model is extended by a further node property: the 
                     
                     <div class="emphasis e175" role="bold">[key] property</div>. Only element 
                     nodes have a [key], which is possibly empty. The [key] must not
                     be empty if the [parent] is an element whose
                     [model] property (see below) has a value of "map". In any other
                     case (i.e. if [parent] is empty, or is not an element node,
                     or is an element whose [model] is "sequence")
                     the [key] must be empty. The [key] of an element must not be
                     equal to the [key] of any sibling element.
                     
                  </div>
               </div>
               <div class="listitem e176">
                  <div class="para e177">
                     The node model is extended by a further node property: the 
                     
                     <div class="emphasis e178" role="bold">[model] property</div>. Only
                     element nodes have a [model], the value of which must be
                     either "sequence" or "map". If the
                     value is "sequence", the child nodes are an ordered
                     collection and child elements must not have a [key]. Conversely, 
                     if the value is "map", the child nodes are an unordered
                     collection, every child element must have a [key] and there
                     must not be text node children containing a non-whitespace
                     character. Note that the [model] can be regarded as a
                     switch selecting one of two possible content models:
                     sequence based (property value "sequence") or
                     key based (property value "map"). In the former case
                     element content is a sequence of child nodes; in the
                     latter case element content is a map of
                     child elements, using the child [key]s as map keys.
                     The former case corresponds to "conventional XML", 
                     where content is always ordered by position.
                     
                  </div>
               </div>
               <div class="listitem e179">
                  <div class="para e180">
                     
                     <div class="emphasis e181" role="bold">JSON simple values</div>
                     are represented by (not nilled) element nodes which have simple 
                     content, or (in the case of a zero-length string)
                     empty content and a [schema-type] xs:untypedAtomic.
                     
                  </div>
               </div>
               <div class="listitem e182">
                  <div class="para e183">
                     
                     <div class="emphasis e184" role="bold">JSON null values</div> are represented 
                     by nilled elements.
                     
                  </div>
               </div>
               <div class="listitem e185">
                  <div class="para e186">
                     
                     <div class="emphasis e187" role="bold">JSON objects</div> 
                     are represented by (not nilled) element nodes 
                     with [model] equal "map". By implication, such
                     elements may or may not have child elements, but
                     they have no text node children containing
                     non-whitespace characters.
                     The name/value pairs contained by the object are represented by 
                     the element children. Other child nodes (e.g. comments or 
                     whitespace-only text nodes) do not correspond to name/value pairs.
                     Note that an empty object is represented by an element
                     with [model] equal "map" and no child elements.
                     
                  </div>
               </div>
               <div class="listitem e188">
                  <div class="para e189">
                     
                     <div class="emphasis e190" role="bold">JSON arrays</div> are represented by 
                     (not nilled) element nodes satisfying these constraints: (a)
                     [model] equal "sequence",
                     (b) the content is either empty or contains at least one child element; 
                     (c) there are no text node children containing non-whitespace characters. 
                     The array members are represented by the element children. 
                     Other child nodes (e.g. comments or whitespace-only text nodes) 
                     do not correspond to array members.
                     
                  </div>
               </div>
               <div class="listitem e191">
                  <div class="para e192">
                     
                     <div class="emphasis e193" role="bold">JSON names</div> are represented by 
                     the [key] property of element nodes.
                     
                  </div>
               </div>
               <div class="listitem e194">
                  <div class="para e195">
                     When a node tree is constructed from a JSON document, null values, 
                     simple values, arrays and objects are represented by elements which 
                     have 
                     <div class="emphasis e196" role="bold">default node-names</div> (
                     
                     <div class="code e197">udl:null</div>, 
                     
                     <div class="code e198">udl:value</div>, 
                     
                     <div class="code e199">udl:array</div> and 
                     
                     <div class="code e200">udl:map</div>). 
                     As any element names in XML, these names do not have any 
                     built-in semantics: they do not signal that the element has
                     been constructed from a JSON value, and they do not imply specific 
                     values of any node properties. 
                     After an update or if the node tree is constructed in any other way, 
                     the elements representing null values, simple values, arrays and objects 
                     may have any valid node name.
                     
                  </div>
                  <div class="para e201">
                     Note that JSON names and XML names correspond to two distinct node 
                     properties which are utterly independent of each other. And also 
                     note the asymmetry: whereas JSON names are represented in XML markup 
                     by keys (via the 
                     <div class="code e202">udl:key</div> 
                     pseudo-attribute, see next section), XML names cannot 
                     be represented in JSON markup at all. Lossless information mapping in 
                     both directions is nevertheless enabled by arbitrarily defining 
                     JSON markup to represent nodes with default names which are
                     implied by other node properties.
                     
                  </div>
               </div>
            </div>
         </div><a name="%0AExtensionsoftheXMLmarkuplanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e203" xml:id="extensions-of-the-xml-markup-language">
            <div class="title e204">
               Extensions of the XML markup language
               
            </div>
            <div class="para e205">
               The extensions have two purposes: (a) express the 
               new node properties; (b) support the use of non-XML markup within XML 
               documents.
               
            </div><a name="%0AExpressingthenewnodeproperties%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e206" xml:id="expressing-the-new-node-properties">
               <div class="title e207">
                  Expressing the new node properties
                  
               </div>
               <div class="para e208">
                  The XML markup language is extended by rules how to represent the new 
                  node properties.
                  
               </div>
               <div class="para e209">
                  
                  <div class="emphasis e210" role="bold">
                     <div class="emphasis e211" role="ital">
                        Details
                        
                     </div>
                  </div>
                  
               </div>
               <div class="orderedlist e212">
                  <div class="listitem e213">
                     <div class="para e214">
                        A pseudo-attribute (
                        <div class="code e215">udl:model</div>) is introduced which indicates 
                        the value of the 
                        <div class="emphasis e216" role="bold">[model] property</div>. 
                        Possible values are "sequence" and
                        "map". The default value is "sequence", unless the element has an
                        ancestor element with a pseudo-attribute 
                        <div class="code e217">udl:defaultModel</div>,
                        in which case the default is specified by the nearest ancestor 
                        with a 
                        <div class="code e218">udl:defaultModel</div> pseudo-attribute.
                        
                     </div>
                  </div>
                  <div class="listitem e219">
                     <div class="para e220">
                        A pseudo-attribute (
                        <div class="code e221">udl:defaultModel</div>) is introduced which 
                        sets the default value of [model] for the element itself and its
                        descendants. The default value applies to the element itself and
                        to its descendant elements unless the element in question has
                        simple content (in which case [model] is always "sequence"),
                        or has a [model] pseudo-attribute (which overrides the default)
                        or has a nearer ancestor with a 
                        
                        <div class="code e222">udl:defaultModel</div> pseudo-attribute (which shadows
                        any outer default values).
                        
                     </div>
                  </div>
                  <div class="listitem e223">
                     <div class="para e224">
                        A pseudo-attribute (
                        <div class="code e225">udl:key</div>) is introduced which indicates 
                        the value of the 
                        <div class="emphasis e226" role="bold">[key] property</div>. 
                        If an element without 
                        <div class="code e227">udl:key</div> is child of an 
                        element whose [model] is "map", the [key] defaults to the local
                        name of the element. Example:
                        
                        <div class="programlisting e228" xml:space="preserve">
                           &lt;foo udl:model="map"&gt;
                           &lt;bar udl:key="bar"&gt;abc&lt;/foo&gt;
                           &lt;/foo&gt;
                        </div>
                        is equivalent to:
                        
                        <div class="programlisting e229" xml:space="preserve">
                           &lt;foo udl:model="map"&gt;
                           &lt;bar&gt;abc&lt;/foo&gt;
                           &lt;/foo&gt;
                        </div>
                        Note that non-empty [key]s are only allowed for elements
                        with [parent].[model] equal "map". Accordingly, only such
                        elements may have a 
                        <div class="code e230">udl:key</div> pseudo-attribute.
                        Example: if in the following markup
                        
                        <div class="programlisting e231" xml:space="preserve">
                           &lt;foo udl:model="map"&gt;
                           &lt;bar udl:key="21"&gt;abc&lt;/foo&gt;
                           &lt;/foo&gt;
                        </div>
                        the value of 
                        <div class="code e232">udl:model</div> were changed to
                        "sequence", the markup would cease to be well-formed.
                        
                     </div>
                  </div>
               </div>
            </div><a name="%0ASupportingnonXMLmarkup%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e233" xml:id="supporting-non-xml-markup">
               <div class="title e234">
                  Supporting non-XML markup
                  
               </div>
               <div class="para e235">
                  The extensions enable the use of non-XML markup either embedded 
                  in XML markup or completely replacing it.
                  
               </div>
               <div class="para e236">
                  
                  <div class="emphasis e237" role="bold">
                     <div class="emphasis e238" role="ital">
                        Details
                        
                     </div>
                  </div>
                  
               </div>
               <div class="orderedlist e239">
                  <div class="listitem e240">
                     <div class="para e241">
                        The XML syntax model is extended by permitting 
                        
                        <div class="emphasis e242" role="bold">alternative markup languages</div>. 
                        An alternative language can be used in three 
                        different scopes: (a) the content of an element, (b)  
                        a document section of arbitrary length, representing any
                        number of sibling nodes, 
                        (c) the complete document. Three languages are supported: 
                        
                        <div class="code e243">xml</div>,
                        
                        <div class="code e244">json</div>,
                        
                        <div class="code e245">telem</div>,
                        a slightly simplified version of XML 
                        using JSON-like constructs for simple elements meeting 
                        certain constraints. See 
                        
                        <div class="xref e246" linkend="mixing-markup-styles"></div> for details.
                        
                     </div>
                  </div>
                  <div class="listitem e247">
                     <div class="para e248">
                        The XML syntax model is extended by a pseudo-attribute, 
                        
                        <div class="code e249">udl:markup</div>, which specifies the markup 
                        language used to represent the content of an element. 
                        If the value is not 
                        <div class="code e250">xml</div>, the child nodes
                        of the element
                        are the nodes constructed from the markup found in the
                        text content.
                        Only element tags and the pseudo-tag 
                        <div class="code e251">udl:markupSection</div>
                        (see below) may have this 
                        pseudo-attribute. Possible values are: 
                        
                        <div class="code e252">xml</div>, 
                        
                        <div class="code e253">json</div>, 
                        
                        <div class="code e254">telem</div>; 
                        default value is 
                        <div class="code e255">xml</div>. Example:
                        
                        <div class="programlisting e256" xml:space="preserve">
                           &lt;temperatures y="2012" 
                           udl:markup="json"&gt;&lt;![CDATA[
                           "2012-08-01" : 33.2,
                           "2012-08-02" : 28.9,
                           "2012-08-03" : 30.0,
                           "sites" : ["AB", "DK", "PP"],
                           "anno" : {"automatic" : true, "reference" : false}
                           ]]&gt;&lt;/temperatures&gt;
                        </div>
                        Note that the scope of the alternative 
                        markup language is the content of an element and 
                        that the alternative representation is preceded and 
                        followed by the XML start and end tag of the element. 
                        Thus the markup of the example corresponds to an 
                        element with name “temperatures”, which has one attribute 
                        and five child elements. An XML document can use 
                        different markup languages in different elements. 
                        
                     </div>
                  </div>
                  <div class="listitem e257">
                     <div class="para e258">
                        The XML syntax model is extended by a pseudo-tag 
                        
                        <div class="code e259">udl:markupSection</div>, which delimits a 
                        markup section, a section of the document text which 
                        uses a particular markup language. 
                        When constructing the node tree, the pseudo-tag and 
                        its contents represent the nodes constructed from 
                        the contained markup. The markup language is identified 
                        by the 
                        <div class="code e260">udl:markup</div> pseudo-attribute 
                        contained by the pseudo-tag. In the following 
                        example, the pseudo-tag represents five nodes 
                        which are constructed from the JSON markup:          
                        
                        <div class="programlisting e261" xml:space="preserve">
                           &lt;udl:markupSection udl:markup="JSON"&gt;&lt;![CDATA[
                           "2012-08-01" : 33.2,
                           "2012-08-02" : 28.9,
                           "2012-08-03" : 30.0,
                           "sites" : ["AB", "DK", "PP"],
                           "anno" : {"automatic" : true, "reference" : false}
                           ]]&gt;&lt;/udl:markupSection&gt;
                        </div>
                        Note that the pseudo-tag does itself not represent a node – 
                        it has a purely delimiting function.
                        Any non-XML markup may be used which is supported by the 
                        parser. Besides JSON, a parser may support an 
                        implementation-defined set of further markup languages 
                        or domain specific languages.
                        
                     </div>
                  </div>
                  <div class="listitem e262">
                     <div class="para e263">
                        The 
                        <div class="emphasis e264" role="bold">XML declaration</div> is 
                        extended by a further field: 
                        <div class="code e265">markup</div>. Possible 
                        values are: 
                        
                        <div class="code e266">xml</div>, 
                        
                        <div class="code e267">json</div>, 
                        
                        <div class="code e268">html</div>; 
                        default is 
                        <div class="code e269">xml</div>. Depending on the value, 
                        the text following the XML declaration will be 
                        interpreted as XML markup, JSON markup or HTML markup. 
                        Example:
                        
                        <div class="programlisting e270" xml:space="preserve">
                           &lt;?xml markup="json" encoding="ISO-8859-1"?&gt;
                           {
                           "title" : "JSON and XML",
                           "year" : 2012
                           }
                        </div>
                        
                     </div>
                  </div>
                  <div class="listitem e271">
                     <div class="para e272">
                        The XML markup language is augmented by a rule how to parse a 
                        
                        <div class="emphasis e273" role="bold">non-XML document without
                           XML declaration
                        </div>. If the first non-whitespace character 
                        of the text is not the “&lt;” character, the document text is 
                        interpreted as non-XML markup. More precisely, it is 
                        interpreted as the default non-XML markup which is expected 
                        to be JSON, although implementation-defined alternatives 
                        might be considered. Example: the text
                        
                        <div class="programlisting e274" xml:space="preserve">
                           {
                           "title" : "JSON and XML",
                           "year" : 2012
                           }
                        </div>
                        is a valid UDL document.
                        
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="%0AExtensionsoftheXMLserializationmodel%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e275" xml:id="extensions-of-the-xml-serialization-model">
            <div class="title e276">
               Extensions of the XML serialization model
               
            </div>
            <div class="para e277">
               The serialization model must be extended in order to support JSON output.
               
               <div class="orderedlist e278">
                  <div class="listitem e279">
                     <div class="para e280">
                        When the serialization method is 
                        <div class="code e281">xml</div>, 
                        serialization produces conventional XML markup, 
                        augmented by the pseudo-attributes 
                        
                        <div class="code e282">udl:key</div>, 
                        <div class="code e283">udl:model</div> 
                        and 
                        <div class="code e284">udl:defaultModel</div> where appropriate.
                        
                     </div>
                  </div>
                  <div class="listitem e285">
                     <div class="para e286">
                        When the serialization method is 
                        <div class="code e287">xml</div>, the serialization 
                        may nevertheless insert non-XML markup into the document text, 
                        depending on serialization parameters. The non-XML markup is 
                        constrained to represent element contents – that is, every 
                        chunk of non-XML markup is scoped to represent the content 
                        of an element whose start and end tag delimit the chunk.
                        
                     </div>
                  </div>
                  <div class="listitem e288">
                     <div class="para e289">
                        When the serialization method is 
                        <div class="code e290">xml</div>, additional 
                        serialization parameters control the use of alternative markup 
                        within selected elements. Parameter 
                        
                        <div class="code e291">json-content-elements</div> contains a list of expanded 
                        QNames, identifying the elements whose content shall be 
                        represented as JSON markup. In a similar way, parameter 
                        
                        <div class="code e292">telem-content-elements</div> identifies the elements 
                        to be rendered using the 
                        <div class="code e293">telem</div> style. 
                        (For details see 
                        
                        <div class="xref e294" linkend="mixing-markup-styles"></div>).
                        
                     </div>
                  </div>
                  <div class="listitem e295">
                     <div class="para e296">
                        The value range of serialization parameter 
                        
                        <div class="code e297">method</div> is extended by the value 
                        
                        <div class="code e298">json</div>. This value lets the 
                        complete document be serialized as JSON markup.
                        
                     </div>
                  </div>
                  <div class="listitem e299">
                     <div class="para e300">
                        A new serialization parameter 
                        
                        <div class="code e301">info-loss</div> specifies how to handle 
                        information loss implied by the serialization.
                        Special values relate to 
                        situations where JSON markup should be produced but a 
                        node to be serialized contains information which cannot 
                        be expressed by a JSON representation. (There are three cases:
                        (i) mixed content,
                        (ii) the use of attributes,
                        (iii) the use of non-standard element names.) 
                        Three parameter values are supported: 
                        
                        <div class="code e302">json.strict</div>, 
                        
                        <div class="code e303">json.ignore-names</div>, and 
                        
                        <div class="code e304">json.projection</div>. In case of 
                        <div class="code e305">json.strict</div> the 
                        serialization must be aborted; the value 
                        
                        <div class="code e306">json.projection</div> mandates a projection 
                        which simply ignores any information which cannot 
                        be represented; 
                        and the value 
                        <div class="code e307">json.ignore-names</div> means that the 
                        QNames of XML elements are ignored, but any other 
                        incompatibility with the JSON model 
                        (e.g. the use of attributes) 
                        produces an unrecoverable error. (For details see
                        
                        <div class="xref e308" linkend="serialization-controlling-the-loss-of-information"></div>.)
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AExtensionsoftheXPathlanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e309" xml:id="extensions-of-the-xpath-language">
            <div class="title e310">
               Extensions of the XPath language
               
            </div>
            <div class="para e311">
               The extensions are designed to make the processing of
               JSON data as powerful and convenient as the processing
               of XML data. Namely, the [key] property can be checked
               by a 
               <div class="emphasis e312" role="ital">key test</div>, 
               similarly to the checking of the node name by a
               node test.
               
            </div>
            <div class="orderedlist e313">
               <div class="listitem e314">
                  <div class="para e315">
                     The XPath language is extended by a new node test, 
                     an alternative to the existing name test and kind test: 
                     the 
                     <div class="emphasis e316" role="bold">key test</div>. A key test 
                     checks for the candidate node if it has a key equal to 
                     a given key value. In path expressions, key tests can be 
                     combined with XPath axes in the same way as kind tests 
                     and name tests. The syntax of a key test is a # character           
                     immediately followed by the key value delimited by single
                     or double quotes. If the key value contains only name characters,
                     the quotes can be omitted. If quotes are used, occurrences
                     of the actual quote character within the key value
                     must be escaped by an entity or character reference.
                     The characters 
                     <div class="code e317">&amp;</div> and 
                     <div class="code e318">&lt;</div>
                     must always be escaped.
                     Examples of path steps containing a key test:
                     
                     <div class="programlisting e319" xml:space="preserve">
                        #key1
                        #"key1"
                        #”key 2”
                        self::"#key 2"
                        descendant::#key3
                        parent::#"#key4"
                        ancestor::#'++14085! &amp;amp; O&amp;apos;Neill'
                     </div>
                     
                  </div>
               </div>
               <div class="listitem e320">
                  <div class="para e321">
                     A new XPath function 
                     <div class="code e322">fn:node-key</div> returns 
                     the [key] of a given node, or the empty sequence 
                     if the node has no [key]: 
                     
                     <div class="programlisting e323" xml:space="preserve">
                        fn:node-key($node as node()?) as xs:string?
                     </div>
                     Example: the expression
                     
                     <div class="programlisting e324" xml:space="preserve">
                        string-join($x/ancestor-or-self::*/(concat(‘#’, fn:node-key(.)), ‘/’)
                     </div>
                     might return a result like 
                     <div class="code e325">#a/#b/#c</div>.
                     
                  </div>
               </div>
               <div class="listitem e326">
                  <div class="para e327">
                     A new XPath function 
                     <div class="code e328">fn:node-model</div> returns 
                     the [model] of a given node, or the empty sequence
                     if the node is not an element node. The [model] is 
                     represented as a string
                     which is either "sequence" or "map": 
                     
                     <div class="programlisting e329" xml:space="preserve">
                        fn:node-model($node as node()?) as xs:string?
                     </div>
                     
                  </div>
               </div>
               <div class="listitem e330">
                  <div class="para e331">
                     The semantics of function 
                     <div class="code e332">fn:deep-equal</div>
                     is modified as follows: (a) if the arguments are element
                     nodes with different [key]s or with different
                     [models]s, the function returns "false"; (b) if both 
                     arguments are element nodes with [model] equal "map",
                     the comparison ignores non-element children and
                     ignores the order of element children.
                     
                  </div>
               </div>
               <div class="listitem e333">
                  <div class="para e334">
                     The 
                     <div class="emphasis e335" role="ital">abbreviated syntax</div> 
                     is extended by a more intuitive
                     syntax for accessing array members by index, which hides
                     the fact that array members are child nodes:
                     
                     <div class="programlisting e336" xml:space="preserve">
                        foo~[expr] 
                     </div>
                     is equal to
                     
                     
                     <div class="programlisting e337" xml:space="preserve">
                        foo/*[expr]
                     </div>
                     
                  </div>
               </div>
            </div>
         </div><a name="%0AExtensionsoftheXQuerylanguage%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e338" xml:id="extensions-of-the-xquery-language">
            <div class="title e339">
               Extensions of the XQuery language
               
            </div>
            <div class="para e340">
               As JSON items correspond to element nodes, there is no principal
               need to introduce new constructor expressions. In element
               constructors, the pseudo-attributse 
               <div class="code e341">udl:key</div> 
               and 
               <div class="code e342">udl:model</div> are used in the same way as they are
               used in XML markup. In order to reduce verbosity,
               however, several abbreviated variants of element constructors
               are introduced.
               
               <div class="orderedlist e343">
                  <div class="listitem e344">
                     <div class="para e345">
                        
                        <div class="emphasis e346" role="bold">Map constructors</div>
                        are a shorthand for constructing element nodes 
                        with name 
                        <div class="code e347">udl:map</div> and [model] equal "map". Syntax:
                        
                        <div class="programlisting e348" xml:space="preserve">
                           { Expr }
                           
                           is equivalent to:
                           
                           &lt;udl:map udl:model="map"&gt;{ Expr }&lt;/udl:map&gt;
                        </div>
                        
                     </div>
                     <div class="para e349">
                        The children of the newly constructed 
                        <div class="code e350">udl:map</div>
                        element are obtained by (a) evaluating the
                        content expession to an item sequence, (b) replacing
                        in this sequence any document node by its document element,
                        (c) replacing in the resulting sequence any element
                        without a key by a copy which has a key equal to
                        its local name. An error is raised if the result 
                        sequence contains atomic or text node items, or if
                        it contains two elements with the same key. Otherwise,
                        the expression value is guaranteed to be an element
                        which can be serialized to JSON without information loss.
                        
                     </div>
                  </div>
                  <div class="listitem e351">
                     <div class="para e352">
                        
                        <div class="emphasis e353" role="bold">Array constructors</div>
                        are a shorthand for constructing element nodes 
                        which correspond to a JSON array. Syntax:
                        
                        <div class="programlisting e354" xml:space="preserve">
                           [ Expr ]
                           
                           is equivalent to the following code
                           (where p:copy-without-key denotes a pseudo function creating an element copy without
                           [key]):
                           
                           &lt;udl:array&gt;{
                           for $item in Expr return 
                           typeswitch($item)
                           case document-node()  return $item/*/p:copy-without-key(.)
                           case element()        return $item/p:copy-without-key(.)
                           case text()           return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
                           case xs:anyAtomicType return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
                           default               return ()
                           }&lt;/udl:array&gt;
                        </div>
                        
                     </div>
                     <div class="para e355">
                        The children of the newly constructed
                        
                        <div class="code e356">udl:array</div> element are obtained by (a) evaluating
                        the content expression to an item sequence, 
                        (b) replacing in this sequence any document nodes by 
                        their element children, 
                        (c) replacing in the resulting sequence any element
                        with a key by a copy which does not have a key, 
                        (d) replacing in the resulting sequence any atomic values
                        by a 
                        <div class="code e357">udl:value</div> element containing the value as text. 
                        The expression value is guaranteed to be an element which can
                        be serialized to a JSON array without information loss.
                        
                     </div>
                  </div>
                  <div class="listitem e358">
                     <div class="para e359">
                        
                        <div class="emphasis e360" role="bold">Key-oriented constructors</div>
                        are a shorthand for constructing element nodes with a 
                        non-empty [key]. 
                        They have the following syntax:
                        
                        <div class="programlisting e361" xml:space="preserve">
                           Expr ':' Expr
                           
                           Examples:
                           "title" : "XML and JSON"
                           $ti     : $tnode
                           "title" : //title
                           "times" : [ "2012-01-01", "2012-03-31" ],
                           "time" : { "begin" : "2012-01-01", "end" : "2012-03-31" }
                        </div>
                        The value of this expression is determined as follows.
                        
                        <div class="itemizedlist e362">
                           <div class="listitem e363">
                              <div class="para e364">
                                 Evaluate the expression to the left of the
                                 colon; the result must be a single item; 
                                 determine its string value S. 
                                 
                              </div>
                           </div>
                           <div class="listitem e365">
                              <div class="para e366">
                                 Evaluate the expression to the right of the
                                 colon; the result R must be either the
                                 empty sequence or a single item.
                                 
                              </div>
                           </div>
                           <div class="listitem e367">
                              <div class="para e368">
                                 If R is the empty sequence, the value of
                                 the constructor expression is an element
                                 node with name 
                                 <div class="code e369">udl:null</div>,
                                 a [key] property equal S and a
                                 [nilled] property equal true.
                                 
                              </div>
                           </div>
                           <div class="listitem e370">
                              <div class="para e371">
                                 If R is a node, the value of the constructor expression
                                 is a node obtained by making a copy of R
                                 and setting its [key] property to S.
                                 
                              </div>
                           </div>
                           <div class="listitem e372">
                              <div class="para e373">
                                 Otherwise (that is, if R is an atomic value)
                                 the value of the constructor expression is an element 
                                 node with the name 
                                 <div class="code e374">udl:value</div>,
                                 a [key] property equal S and a single
                                 text node child whose string value is 
                                 the string value of R. (Special case:
                                 empty content if the string value of R
                                 is a zero-length string.)
                                 The resulting element has a type annotation
                                 which depends on the type of R. If R
                                 has a number type, the type annotation is
                                 one of these:
                                 
                                 <div class="code e375">xs:double</div>,
                                 
                                 <div class="code e376">xs:decimal</div>,
                                 
                                 <div class="code e377">xs:integer</div>, 
                                 whatever is closest to the type of R.
                                 If R has a boolean type, the type annotation is
                                 
                                 <div class="code e378">xs:boolean</div>. If R is a zero-length
                                 string, the type annotation is 
                                 
                                 <div class="code e379">xs:untypedAtomic</div>. Otherwise, the
                                 default type annotation is used (
                                 
                                 <div class="code e380">xs:untyped</div>).
                                 
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </div><a name="CheckingusecasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e381" xml:id="checking-use-cases">
         <div class="title e382">Checking use cases</div>
         <div class="para e383">
            The proposal made in this paper is motivated by several main use cases. In each of
            these, a significant simplification of the task should be achieved.
            
         </div>
         <div class="itemizedlist e384">
            <div class="listitem e385">
               <div class="para e386">
                  JSON documents must be queried.
                  
               </div>
            </div>
            <div class="listitem e387">
               <div class="para e388">
                  JSON documents must be transformed into other JSON documents.
                  
               </div>
            </div>
            <div class="listitem e389">
               <div class="para e390">
                  JSON documents must be transformed into XML documents.
                  
               </div>
            </div>
            <div class="listitem e391">
               <div class="para e392">
                  JSON documents must be transformed into HTML documents.
                  
               </div>
            </div>
            <div class="listitem e393">
               <div class="para e394">
                  JSON documents must be transformed into other formats (e.g. CSV).
                  
               </div>
            </div>
            <div class="listitem e395">
               <div class="para e396">
                  JSON documents must be created from XML documents.
                  
               </div>
            </div>
            <div class="listitem e397">
               <div class="para e398">
                  JSON documents must be created from other formats (e.g. CSV).
                  
               </div>
            </div>
         </div>
         <div class="para e399">
            The fact that XML standard technologies - XPath, XQuery, XSLT, XProc -
            now accept JSON documents as input suggests a great advantage.
            We should however take a closer look at how the processing of JSON
            data looks. Somewhat arbitrarily, these main aspects may be 
            distinguished:
            
            <div class="itemizedlist e400">
               <div class="listitem e401">
                  <div class="para e402">
                     Selecting JSON data
                     
                  </div>
               </div>
               <div class="listitem e403">
                  <div class="para e404">
                     The use of JSON data within XPath/XQuery expressions
                     and XSLT instructions
                     
                  </div>
               </div>
               <div class="listitem e405">
                  <div class="para e406">
                     Creating JSON data
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e407">
            The 
            <div class="emphasis e408" role="bold">selection of data</div> 
            is a crucial operation, underlying
            virtually all forms of data processing. This is the domain
            of XPath, so we shall take a look at how XPath deals with JSON
            data. 
            The proposal avoids the creation of special item types -
            all JSON data reside in element nodes. Therefore it can
            be expected that the 
            <div class="emphasis e409" role="bold">
               use of JSON data in expressions
            </div>
            and XSLT instructions is indistinguishable from 
            the use of any other element nodes.
            The 
            <div class="emphasis e410" role="bold">creation of JSON data</div> 
            amounts to the creation of
            element nodes, so that again we may expect the same
            ease when creating JSON data as when creating any
            other element nodes.
            
         </div>
         <div class="para e411">
            Let us contemplate a few examples. As input we use the following
            JSON document:
            
         </div>
         <div class="programlisting e412" xml:space="preserve">
            [
            {
            "year" : 2011, 
            "title" : "JSON", 
            "author" : [
            {"last" : "Legoux", "first" : "C."}
            ], 
            "price" : 35.95,
            "sigs" : ["LL1002"]
            }, 
            {
            "year" : 2012, 
            "title" : "XML", 
            "author" : [
            {"last" : "Legoux", "first" : "C."}, 
            {"last" : "Berlin", "first" : "D."}
            ], 
            "price" : 29.95,
            "sigs" : []
            },
            {
            "year" : 2012, 
            "title" : "UDL", 
            "author" : [
            {"last" : "Legoux", "first" : "C."},
            {"last" : "Okuda", "first" : "J."}, 
            {"last" : "Berlin", "first" : "D."}
            ], 
            "price" : 49.95,
            "sigs" : ["KL4005", "KL4011"]
            }
            ]
         </div>
         <div class="para e413">
            The following table shows a series of 
            
            <div class="emphasis e414" role="ital">data selections</div> with
            XPath/XQuery. The expressions typically use key tests (#foo) 
            instead of name tests. Apart from that there is no difference
            compared to conventional uses of XPath. 
            Writing the expressions, one must keep in mind that object members
            (the name/value pairs) and array members are represented by child
            elements of the element representing the object or array,
            respectively.
            
         </div>
         <div class="para e415">
            
            <div class="table e416">
               <div class="caption e417">
                  <div class="para e418">
                     
                     <div class="emphasis e419" role="bold">
                        <div class="emphasis e420" role="ital">
                           Selecting JSON data with XPath/XQuery.
                           
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="metaBox e421"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e859').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e859" class="metaSource" style="display:none;">                
                     &lt;col<span class="metaAttribute">align='left'
                        </span><span class="metaAttribute">class='e421'
                        </span><span class="metaAttribute">span='1'
                        </span><span class="metaAttribute">valign='top'
                        </span>
                     &gt;
                     
                  </div>
               </div>
               <div class="metaBox e422"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e860').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e860" class="metaSource" style="display:none;">                
                     &lt;col<span class="metaAttribute">align='left'
                        </span><span class="metaAttribute">class='e422'
                        </span><span class="metaAttribute">span='1'
                        </span><span class="metaAttribute">valign='top'
                        </span>
                     &gt;
                     
                  </div>
               </div>
               <div class="thead e423">
                  <div class="tr e424" valign="top">
                     <div class="th e425" align="left" valign="top">task</div>
                     <div class="th e426" align="left" valign="top">expression</div>
                     <div class="th e427" align="left" valign="top">result</div>
                  </div>
               </div>
               <div class="tbody e428">
                  <div class="tr e429" valign="top">
                     <div class="td e430">count books</div>
                     <div class="td e431">
                        <div class="code e432">count(/*/*)</div>
                     </div>
                     <div class="td e433">3</div>
                  </div>
                  <div class="tr e434" valign="top">
                     <div class="td e435">maximum price</div>
                     <div class="td e436">
                        <div class="code e437">max(//#price/xs:decimal(.))</div>
                     </div>
                     <div class="td e438">
                        
                        <div class="para e439">49.95</div>
                        
                     </div>
                  </div>
                  <div class="tr e440" valign="top">
                     <div class="td e441">first book title</div>
                     <div class="td e442">
                        <div class="code e443">/*/*[1]/#title/string()</div>
                     </div>
                     <div class="td e444">JSON</div>
                  </div>
                  <div class="tr e445" valign="top">
                     <div class="td e446">all publication years</div>
                     <div class="td e447">
                        <div class="code e448">distinct-values(//#year/string())</div>
                     </div>
                     <div class="td e449">2011 2012</div>
                  </div>
                  <div class="tr e450" valign="top">
                     <div class="td e451">books about UDL</div>
                     <div class="td e452">
                        <div class="code e453">//#title[contains(., 'UDL')]/string()</div>
                     </div>
                     <div class="td e454">UDL</div>
                  </div>
                  <div class="tr e455" valign="top">
                     <div class="td e456">books above 30$</div>
                     <div class="td e457">
                        <div class="code e458">//#title[../#price/xs:decimal(.) gt 30]/string()</div>
                     </div>
                     <div class="td e459">
                        
                        <div class="para e460">JSON UDL</div>
                        
                     </div>
                  </div>
                  <div class="tr e461" valign="top">
                     <div class="td e462">books with a single author</div>
                     <div class="td e463">
                        <div class="code e464">//#title[count(../#author/*) eq 1]</div>
                     </div>
                     <div class="td e465">
                        
                        <div class="para e466">JSON</div>
                        
                     </div>
                  </div>
                  <div class="tr e467" valign="top">
                     <div class="td e468">books without signature</div>
                     <div class="td e469">
                        <div class="code e470">//#title[empty(../#sigs/*)]</div>
                     </div>
                     <div class="td e471">
                        
                        <div class="para e472">XML</div>
                        
                     </div>
                  </div>
                  <div class="tr e473" valign="top">
                     <div class="td e474">books written by Legoux</div>
                     <div class="td e475">
                        <div class="code e476">/*/*[.//#last = 'Legoux']/#title/string()</div>
                     </div>
                     <div class="td e477">
                        
                        <div class="para e478">JSON XML UDL</div>
                        
                     </div>
                  </div>
                  <div class="tr e479" valign="top">
                     <div class="td e480">coauthors of Legoux</div>
                     <div class="td e481">
                        <div class="code e482">distinct-values(//#last[. eq 'Legoux']/../../*/#last[. ne 'Legoux'])</div>
                     </div>
                     <div class="td e483">
                        
                        <div class="para e484">Berlin Okuda</div>
                        
                     </div>
                  </div>
                  <div class="tr e485" valign="top">
                     <div class="td e486">duplicate signatures</div>
                     <div class="td e487">
                        
                        <div class="para e488">
                           <div class="code e489">for $s in distinct-values(//#sigs/*)</div>
                        </div>
                        
                        <div class="para e490">
                           <div class="code e491">where count(//#sigs[* = $s]) gt 1</div>
                        </div>
                        
                        <div class="para e492">
                           <div class="code e493">return $s</div>
                        </div>
                        
                     </div>
                     <div class="td e494">
                        
                        <div class="para e495">LL1002</div>
                        
                     </div>
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e496">
            In order to get a feeling how selected JSON data can be 
            
            <div class="emphasis e497" role="ital">used in expressions</div>
            and how JSON data can be 
            
            <div class="emphasis e498" role="ital">constructed</div>, 
            we build a report that transforms the input
            data into a new structure. The report shall list for each author
            all titles he or she has authored, along with the 
            publication year. An XML version of the report might look 
            like this:
            
            <div class="programlisting e499" xml:space="preserve">
               &lt;authors&gt;
               &lt;author name="Legoux, C."&gt;
               &lt;book title="JSON" year="2011"/&gt;
               &lt;book title="UDL" year="2012"/&gt;
               &lt;book title="XML" year="2012"/&gt;
               &lt;/author&gt;
               &lt;author name="Okuda, J."&gt;
               &lt;book title="UDL" year="2012"/&gt;
               &lt;/author&gt;
               &lt;author name="Berlin, D."&gt;
               &lt;book title="UDL" year="2012"/&gt;
               &lt;book title="XML" year="2012"/&gt;
               &lt;/author&gt;
               &lt;/authors&gt;
               
            </div>
            and a JSON version like this:
            
            <div class="programlisting e500" xml:space="preserve">
               [
               {
               "author" : "Legoux, C.", 
               "books" : [
               {"title" : "JSON", "year" : "2011"}, 
               {"title" : "UDL",  "year" : "2012"}, 
               {"title" : "XML", "year" : "2012"}
               ]
               }, 
               {
               "author" : "Okuda, J.", 
               "books" : [
               {"title" : "UDL", "year" : "2012"}
               ]
               }, 
               {
               "author" : "Berlin, D.", 
               "books" : [
               {"title" : "UDL", "year" : "2012"}, 
               {"title" : "XML", "year" : "2012"}
               ]
               }
               ]
            </div>
            The XML report can be produced with this query:
            
            <div class="programlisting e501" xml:space="preserve">
               &lt;authors&gt;{
               for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
               let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
               order by $author 
               return
               &lt;author name="{$author}"&gt;{
               for $book in $books
               order by $book/#title
               return 
               &lt;book title="{$book/#title}" year="{$book/#year}" /&gt;
               }&lt;/author&gt;   
               }&lt;/authors&gt;
               
            </div>
            and the JSON version can be produced with this query:
            
            <div class="programlisting e502" xml:space="preserve">
               &lt;udl:array&gt;{
               for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
               let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
               order by $author 
               return
               &lt;udl:map udl:model="map"&gt;{
               &lt;udl:value udl:key="author"&gt;{$author}&lt;/udl:value&gt;,
               &lt;udl:array udl:key="books"&gt;{
               for $book in $books
               order by $book/#title
               return 
               &lt;udl:map udl:model="map"&gt;{
               &lt;udl:value udl:key="title"&gt;{$book/#title/string()}&lt;/udl:value&gt;,
               &lt;udl:value udl:key="year"&gt;{$book/#year/string()}&lt;/udl:value&gt;
               }&lt;/udl:map&gt;
               }&lt;/udl:array&gt;
               }&lt;/udl:map&gt;   
               }&lt;/udl:array&gt;
            </div>
            The element constructors required to create JSON nodes
            are somewhat verbose, and the code is not very readable
            as the distinctive information - the key - is embedded
            in stereotyped markup 
            (e.g. 
            
            <div class="code e503">&lt;udl:map udl:key="..."&gt;</div>
            The situation can be amended by resorting to the 
            abbreviated constructors for maps and arrays along with
            the key-oriented constructors 
            (see 
            <div class="xref e504" linkend="extensions-of-the-xquery-language"></div>):
            
            <div class="programlisting e505" xml:space="preserve">
               [
               for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
               let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
               order by $author 
               return
               {
               "author" : $author,
               "books" : [
               for $book in $books
               order by $book/#title
               return 
               {
               "title" : $book/#title/string(),
               "year" : $book/#year/string()
               }
               ]
               }
               ]
            </div>
            The code examples demonstrated that the processing of JSON data
            with XPath and XQuery is comparable to the processing of XML 
            data. For all use cases
            one may expect from XPath/XQuery/XSLT/XProc 
            the same level of support which one is used to get when 
            dealing with similar problems related to XML without JSON.
            This may be taken as encouragement to explore
            the proposal in greater detail.
            
         </div>
      </div><a name="%0AVariousdetails%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e506" xml:id="various-details">
         <div class="title e507">
            Various details
            
         </div><a name="%0AUDLpseudoattributesandpseudotags%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e508" xml:id="udl-pseudo-attributes-and-pseudo-tags">
            <div class="title e509">
               UDL - pseudo-attributes and pseudo-tags
               
            </div>
            <div class="para e510">
               Pseudo-attributes are syntactical constructs which have the lexical 
               form of attributes but can be distinguished from them by the use of 
               a reserved QName. Pseudo-attributes do not represent an attribute node.
               Instead, they represent a node property 
               (
               <div class="code e511">udl:key</div>, 
               <div class="code e512">udl:model</div>) or 
               a default value of a property 
               (
               <div class="code e513">udl:defaultModel</div>), or they identify the markup language
               used locally (
               <div class="code e514">udl:markup</div>).
               
            </div>
            <div class="para e515">
               Pseudo-tags are syntactical constructs which have the lexical form 
               of element tags but can be distinguished from them by the use of a 
               reserved QName. One pseudo-tag is introduced 
               (
               <div class="code e516">udl:markupSection</div>) which delimits a section 
               of non-XML markup.
               
            </div>
            <div class="para e517">
               Four further names from the UDL namespace are used as 
               default element names, given to the nodes constructed 
               from JSON values. It is important to note that these 
               names have no specific semantics and can be used 
               as node name without restrictions like any other 
               QName. The only specific 
               treatment of these names is when serializing to JSON 
               using the 
               <div class="code e518">json.strict</div> mode. In this case a node 
               name which is different from the default name expected 
               (according to the node properties)
               is considered information that would be lost during
               serialization (see 
               
               <div class="xref e519" linkend="serialization-controlling-the-loss-of-information"></div>).
               
            </div>
            <div class="para e520">
               The following table summarizes the use of QNames from the UDL 
               namespace.
               
            </div>
            <div class="para e521">
               
               <div class="table e522" xml:id="table-reserved-names">
                  <div class="caption e523">
                     <div class="para e524">
                        
                        <div class="emphasis e525" role="bold">
                           <div class="emphasis e526" role="ital">
                              Names in the 
                              
                              <div class="code e527">udl</div> namespace and their usage.
                              
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="metaBox e528"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1067').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1067" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e528'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e529"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1068').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1068" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e529'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e530">
                     <div class="tr e531" valign="top">
                        <div class="th e532" align="left" valign="top">Name</div>
                        <div class="th e533" align="left" valign="top">Usage category</div>
                        <div class="th e534" align="left" valign="top">Meaning</div>
                     </div>
                  </div>
                  <div class="tbody e535">
                     <div class="tr e536" valign="top">
                        <div class="td e537">
                           <div class="code e538">udl:null</div>
                        </div>
                        <div class="td e539">element name</div>
                        <div class="td e540">
                           a standard name available for nilled elements with an unspecific name
                           
                        </div>
                     </div>
                     <div class="tr e541" valign="top">
                        <div class="td e542">
                           <div class="code e543">udl:value</div>
                        </div>
                        <div class="td e544">element name</div>
                        <div class="td e545">
                           a standard name available for a simple content element with an unspecific name
                           
                        </div>
                     </div>
                     <div class="tr e546" valign="top">
                        <div class="td e547">
                           <div class="code e548">udl:array</div>
                        </div>
                        <div class="td e549">element name</div>
                        <div class="td e550">
                           a standard name available for a complex element with [model] equal "sequence"
                           
                        </div>
                     </div>
                     <div class="tr e551" valign="top">
                        <div class="td e552">
                           <div class="code e553">udl:map</div>
                        </div>
                        <div class="td e554">element name</div>
                        <div class="td e555">
                           a standard name available for a complex element with [model] equal "map"
                           
                        </div>
                     </div>
                     <div class="tr e556" valign="top">
                        <div class="td e557">
                           <div class="code e558">udl:markupSection</div>
                        </div>
                        <div class="td e559">pseudo tag</div>
                        <div class="td e560">
                           delimits a markup section containing markup which may 
                           be non-XML; the section represents the nodes resulting 
                           from parsing the contained markup text
                           
                        </div>
                     </div>
                     <div class="tr e561" valign="top">
                        <div class="td e562">
                           <div class="code e563">udl:markup</div>
                        </div>
                        <div class="td e564">pseudo attribute</div>
                        <div class="td e565">
                           indicates the markup language used within element content, or 
                           within a markup section
                           
                        </div>
                     </div>
                     <div class="tr e566" valign="top">
                        <div class="td e567">
                           <div class="code e568">udl:model</div>
                        </div>
                        <div class="td e569">pseudo attribute</div>
                        <div class="td e570">
                           represents the [model] property value
                           
                        </div>
                     </div>
                     <div class="tr e571" valign="top">
                        <div class="td e572">
                           <div class="code e573">udl:defaultModel</div>
                        </div>
                        <div class="td e574">pseudo attribute</div>
                        <div class="td e575">
                           sets a default value for the [model] property
                           
                        </div>
                     </div>
                     <div class="tr e576" valign="top">
                        <div class="td e577">
                           <div class="code e578">udl:key</div>
                        </div>
                        <div class="td e579">pseudo attribute</div>
                        <div class="td e580">
                           represents the [key] property value
                           
                        </div>
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AMixingmarkupstyles%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e581" xml:id="mixing-markup-styles">
            <div class="title e582">
               Mixing markup styles
               
            </div>
            <div class="para e583">
               The UDL defines a unified document model which can be 
               represented by different markup languages. This unified 
               content of heterogeneous outward shape invites not only 
               a free choice of the markup language actually used. It 
               also implies that markup languages might be mixed within 
               a document, based on simple rules how to delimit the 
               various chunks of markup. These rules are provided 
               by the 
               <div class="code e584">udl:markup</div> pseudo-attribute and the 
               
               <div class="code e585">udl:markupSection </div>
               pseudo-tag (see 
               
               <div class="xref e586" linkend="supporting-non-xml-markup"></div>).
               
            </div>
            <div class="para e587">
               Occasionally there may be good reasons to use mixed 
               styles. Consider the case that the document as a 
               whole cannot be represented as JSON (e.g. because 
               of attributes and namespaces), but subtrees 
               represent JSON documents (perhaps imported from 
               pure JSON sources, e.g. logged messages). 
               Without the mixing of markup 
               styles, the resulting serialization would be 
               difficult to read, due to the very verbose
               XML representation of JSON nodes. It should
               of course be remembered that this mixing of
               markup styles has no impact on the
               information content of the UDL document,
               which is exclusively defined in terms of nodes
               and their properties.
               
            </div>
            <div class="para e588">  
               The following section describes in detail an 
               additional markup style, which amounts to
               a "small-scale mixing" of XML and JSON, dubbed 
               
               <div class="code e589">telem</div> (text notation for 
               simple elements).
               
            </div>
         </div><a name="%0AXMLsyntaxvariant:%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e590" xml:id="xml-syntax-variant-telem">
            <div class="title e591">
               XML syntax variant: 
               <div class="code e592">telem</div>
               
            </div>
            <div class="para e593">
               XML markup representing JSON data is 
               ugly. Typically it contains many elements which
               correspond to simple values and are 
               tiresome to read. The 
               
               <div class="emphasis e594" role="ital">distinctive</div> property 
               of the elements is shifted from the 
               eye-catching node name to a pseudo-attribute, 
               and the markup is often inflated
               by explicit type annotations:
               
               <div class="programlisting e595" xml:space="preserve">
                  &lt;udl:value udl:key=”foo”&gt;someContent&lt;/udl:value&gt;
                  &lt;udl:value udl:key=”bar” xsi:type="xs:integer"&gt;99&lt;/udl:value&gt;
                  &lt;udl:value udl:key=”foobar” xsi:type="xs:boolean"&gt;true&lt;/udl:value
               </div>
               whereas the JSON representation could not be more succinct:
               
               <div class="programlisting e596" xml:space="preserve">
                  "foo" : "someContent",
                  ”bar”" : 99,
                  "foobar” : true
               </div>
               
            </div>
            <div class="para e597">
               Fragments containing 
               <div class="emphasis e598" role="ital">only</div>
               JSON nodes can best be represented by switching to JSON. But
               sometimes such JSON values occur interspersed with conventional
               XML elements which have specific names, have attributes, etc.
               In such cases it is attractive to apply the JSON
               style to the simple values and retain XML style for
               the fragment as a whole. This option is provided by
               the 
               <div class="code e599">telem</div> markup style. 
               
            </div>
            <div class="para e600">
               This style is XML markup augmented by a shorthand representation
               of simple elements meeting several constraints: 
               
               <div class="itemizedlist e601">
                  <div class="listitem e602">
                     <div class="para e603">
                        element name is the standard name 
                        <div class="code e604">udl:value</div>
                        
                     </div>
                  </div>
                  <div class="listitem e605">
                     <div class="para e606">
                        simple content or nilled
                        
                     </div>
                  </div>
                  <div class="listitem e607">
                     <div class="para e608">
                        no attributes
                        
                     </div>
                  </div>
                  <div class="listitem e609">
                     <div class="para e610">
                        [schema-type] is one of these:
                        
                        <div class="code e611">xs:integer</div>, 
                        
                        <div class="code e612">xs:decimal</div>, 
                        
                        <div class="code e613">xs:double</div>, 
                        
                        <div class="code e614">xs:boolean</div>,
                        
                        <div class="code e615">xs:untypedAtomic</div>, 
                        
                        <div class="code e616">xs:untyped</div>
                        
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e617">
               The syntax corresponds to the JSON representation of a simple 
               or null value, or of a name/value pair with simple or null
               value, depending on whether the element has a [key]. 
               If consecutive element children are represented in 
               
               <div class="code e618">telem</div> style, these representations are 
               separated by a comma. If the value is not put in quotes, it 
               must be a number or one of the constants 
               
               <div class="code e619">true</div>, 
               
               <div class="code e620">false</div> or 
               
               <div class="code e621">null</div>, which will be interpreted as implicit type 
               information, following the JSON rules. Example: the following fragment
               
               <div class="programlisting e622" xml:space="preserve">
                  &lt;e udl:model="map"&gt;
                  &lt;udl:value udl:key="mode"&gt;repeated&lt;/udl:value&gt;
                  &lt;udl:value udl:key="nrep" xsi:type=”xs:integer”&gt;52076&lt;/udl:value&gt;
                  &lt;udl:value udl:key="eval" xs:type=”xs:boolean”&gt;true&lt;/udl:value&gt;
                  &lt;locInfo udl:key="cities"&gt;
                  &lt;udl:value&gt;Paris&lt;/udl:value&gt;
                  &lt;udl:value&gt;London&lt;/udl:value&gt;
                  &lt;udl:value&gt;Manchester&lt;/udl:value&gt;
                  &lt;/locInfo&gt;
                  &lt;/e&gt;
               </div>
               may be alternatively represented this way:
               
               <div class="programlisting e623" xml:space="preserve">
                  &lt;e udl:model="map" udl:markup=”telem”&gt;
                  "mode" : “repeated”,
                  "nrep" : 52076,
                  “eval” : true
                  &lt;locInfo udl:key="cities"&gt;
                  "Paris",
                  "London",
                  "Mancester"
                  &lt;/locInfo&gt;
                  &lt;/e&gt;
               </div>
               Both representations have the same information content.
               
            </div>
         </div><a name="%0ADeserializingfrom/serializingtoJSON%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e624" xml:id="deserializing-from-serializing-to-json">
            <div class="title e625">
               Deserializing from / serializing to JSON
               
            </div>
            <div class="para e626">
               The exact rules for translating JSON into UDL (deserialization) and for 
               translating UDL into JSON (serialization) are listed in the appendix 
               (
               <div class="xref e627" linkend="appendix-deserialization"></div>
               and 
               <div class="xref e628" linkend="appendix-serialization"></div>). 
               In this section, the principles are summarized.
               
            </div><a name="%0ADeserialization%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e629" xml:id="deserialization">
               <div class="title e630">
                  Deserialization
                  
               </div>
               <div class="para e631">
                  During deserialization every JSON “item” (object, array, 
                  simple value, null) is translated into a UDL element node whose 
                  name and content are determined by the kind of the JSON 
                  item (see 
                  
                  <div class="xref e632" linkend="table-deserialization"></div>). 
                  If the JSON item is associated with 
                  a name, the name is copied into the [key] property of the 
                  element node; otherwise the element node has no [key].
                  
               </div>
               <div class="para e633">
                  Numbers and Boolean constants are translated into 
                  simple elements with a [schema-type] property reflecting 
                  the source item (one of: 
                  
                  <div class="code e634">xs:integer</div>,
                  
                  <div class="code e635">xs:decimal</div>,
                  
                  <div class="code e636">xs:double</div>,
                  
                  <div class="code e637">xs:boolean</div>).
                  A string which has non-zero length is translated into
                  a simple element with [schema-type] 
                  <div class="code e638">xs:untyped</div>.
                  A zero-length string is translated into an 
                  empty element node with
                  [schema-type] 
                  <div class="code e639">xs:untypedAtomic</div>,
                  so as to make it distinguishable from a node 
                  constructed from an empty array or object.
                  
               </div>
               <div class="para e640">
                  
                  <div class="table e641" xml:id="table-deserialization">
                     <div class="caption e642">
                        <div class="para e643">
                           
                           <div class="emphasis e644" role="bold">
                              <div class="emphasis e645" role="ital">
                                 Deserialization - translating JSON items into
                                 UDL nodes.
                                 
                              </div>
                           </div>
                           
                        </div>
                     </div>
                     <div class="metaBox e646"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1302').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1302" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e646'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e647"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1303').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1303" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e647'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="thead e648">
                        <div class="tr e649" valign="top">
                           <div class="th e650" align="left" rowspan="2" valign="top">JSON item</div>
                           <div class="th e651" align="center" colspan="3" valign="top">UDL node properties</div>
                           <div class="th e652" align="left" rowspan="2" valign="top">remarks</div>
                        </div>
                        <div class="tr e653" valign="top">
                           <div class="th e654" align="left" valign="top">node-name</div>
                           <div class="th e655" align="left" valign="top">model</div>
                           <div class="th e656" align="left" valign="top">children</div>
                        </div>
                     </div>
                     <div class="tbody e657">
                        <div class="tr e658" valign="top">
                           <div class="td e659">name/value pair</div>
                           <div class="td e660">see below</div>
                           <div class="td e661">see below</div>
                           <div class="td e662">see below</div>
                           <div class="td e663">
                              
                              <div class="para e664">
                                 the JSON value can be any item kind (null, 
                                 simple value, object, array);
                                 
                              </div>
                              
                              <div class="para e665">
                                 all node properties – except 
                                 for the [key] – depend on the item kind; 
                                 
                              </div>
                              
                              <div class="para e666">
                                 the [key] is set to the JSON name 
                                 
                              </div>
                              
                           </div>
                        </div>
                        <div class="tr e667" valign="top">
                           <div class="td e668">null</div>
                           <div class="td e669">
                              <div class="code e670">udl:null</div>
                           </div>
                           <div class="td e671">sequence</div>
                           <div class="td e672">none</div>
                           <div class="td e673">element is nilled</div>
                        </div>
                        <div class="tr e674" valign="top">
                           <div class="td e675">object</div>
                           <div class="td e676">
                              <div class="code e677">udl:map</div>
                           </div>
                           <div class="td e678">map</div>
                           <div class="td e679">elements, one for each name/value</div>
                           <div class="td e680">all child elements have a [key]</div>
                        </div>
                        <div class="tr e681" valign="top">
                           <div class="td e682">array</div>
                           <div class="td e683">
                              <div class="code e684">udl:array</div>
                           </div>
                           <div class="td e685">sequence</div>
                           <div class="td e686">elements, one for each member</div>
                           <div class="td e687">all child elements without a [key]</div>
                        </div>
                        <div class="tr e688" valign="top">
                           <div class="td e689">string (non-empty)</div>
                           <div class="td e690">
                              <div class="code e691">udl:value</div>
                           </div>
                           <div class="td e692">sequence</div>
                           <div class="td e693">text node</div>
                           <div class="td e694">
                              
                              <div class="para e695">
                                 [schema-type] is xs:untyped
                                 
                              </div>
                              
                           </div>
                        </div>
                        <div class="tr e696" valign="top">
                           <div class="td e697">zero-length string</div>
                           <div class="td e698">
                              <div class="code e699">udl:value</div>
                           </div>
                           <div class="td e700">sequence</div>
                           <div class="td e701">none</div>
                           <div class="td e702">
                              [schema-type] is xs:untypedAtomic
                              
                           </div>
                        </div>
                        <div class="tr e703" valign="top">
                           <div class="td e704">number</div>
                           <div class="td e705">
                              <div class="code e706">udl:value</div>
                           </div>
                           <div class="td e707">sequence</div>
                           <div class="td e708">text node</div>
                           <div class="td e709">
                              [schema-type] is one of: xs:integer, xs:decimal, xs:double
                              
                           </div>
                        </div>
                        <div class="tr e710" valign="top">
                           <div class="td e711">true|false</div>
                           <div class="td e712">
                              <div class="code e713">udl:value</div>
                           </div>
                           <div class="td e714">sequence</div>
                           <div class="td e715">text node</div>
                           <div class="td e716">
                              [schema-type] is xs:boolean
                              
                           </div>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a name="%0ASerialization%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e717" xml:id="serialization">
               <div class="title e718">
                  Serialization
                  
               </div>
               <div class="para e719">
                  The translation of UDL nodes into JSON items does not depend on node 
                  names; rather, it is wholly determined by the element content 
                  (empty / element children / text child) and several properties 
                  ([key], [model], [nilled], [schema-type]). The 
                  node name is however checked if the serialization parameter 
                  
                  <div class="code e720">info-loss</div> is 
                  <div class="code e721">json.strict</div>. 
                  In this case, the actual node name is compared with the 
                  default node name associated with the given element content 
                  and properties, and an unrecoverable error is raised if 
                  actual node name and expected node name are not the same.
                  
               </div>
               <div class="para e722">
                  See 
                  <div class="xref e723" linkend="serialization-controlling-the-loss-of-information"></div> 
                  for details about how serialization may accept or reject loss of 
                  information, dependent on serialization 
                  parameter 
                  <div class="code e724">info-loss</div>.
                  
               </div>
               <div class="para e725">
                  
                  <div class="table e726">
                     <div class="caption e727">
                        <div class="para e728">
                           
                           <div class="emphasis e729" role="bold">
                              <div class="emphasis e730" role="ital">
                                 Serialization - translating UDL nodes into JSON items. CT =
                                 complex type with complex content; ST = simple type.
                                 
                              </div>
                           </div>
                           
                        </div>
                     </div>
                     <div class="metaBox e731"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1456').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1456" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e731'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="metaBox e732"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1457').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1457" class="metaSource" style="display:none;">                
                           &lt;col<span class="metaAttribute">align='left'
                              </span><span class="metaAttribute">class='e732'
                              </span><span class="metaAttribute">span='1'
                              </span><span class="metaAttribute">valign='top'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                     <div class="thead e733">
                        <div class="tr e734" valign="top">
                           <div class="th e735" align="center" colspan="4" valign="top">node properties</div>
                           <div class="th e736" align="center" valign="top">JSON item</div>
                        </div>
                        <div class="tr e737" valign="top">
                           <div class="th e738" align="left" valign="top">children</div>
                           <div class="th e739" align="left" valign="top">model</div>
                           <div class="th e740" align="left" valign="top">nilled</div>
                           <div class="th e741" align="left" valign="top">schema-type</div>
                           <div class="th e742" align="left" valign="top"></div>
                        </div>
                     </div>
                     <div class="tbody e743">
                        <div class="tr e744" valign="top">
                           <div class="td e745">empty</div>
                           <div class="td e746">sequence</div>
                           <div class="td e747">false</div>
                           <div class="td e748">
                              <div class="code e749">xs:untyped</div> or CT
                           </div>
                           <div class="td e750">array (empty)</div>
                        </div>
                        <div class="tr e751" valign="top">
                           <div class="td e752">empty</div>
                           <div class="td e753">sequence</div>
                           <div class="td e754">false</div>
                           <div class="td e755">
                              <div class="code e756">xs:untypedAtomic</div> or ST
                           </div>
                           <div class="td e757">string (zero-length)</div>
                        </div>
                        <div class="tr e758" valign="top">
                           <div class="td e759">empty</div>
                           <div class="td e760">map</div>
                           <div class="td e761">false</div>
                           <div class="td e762">any</div>
                           <div class="td e763">object (empty)</div>
                        </div>
                        <div class="tr e764" valign="top">
                           <div class="td e765">empty</div>
                           <div class="td e766">sequence</div>
                           <div class="td e767">true</div>
                           <div class="td e768">any</div>
                           <div class="td e769">null</div>
                        </div>
                        <div class="tr e770" valign="top">
                           <div class="td e771">element children</div>
                           <div class="td e772">sequence</div>
                           <div class="td e773">false</div>
                           <div class="td e774">any</div>
                           <div class="td e775">array</div>
                        </div>
                        <div class="tr e776" valign="top">
                           <div class="td e777">element children</div>
                           <div class="td e778">map</div>
                           <div class="td e779">false</div>
                           <div class="td e780">any</div>
                           <div class="td e781">object</div>
                        </div>
                        <div class="tr e782" valign="top">
                           <div class="td e783">text node</div>
                           <div class="td e784">sequence</div>
                           <div class="td e785">false</div>
                           <div class="td e786">
                              <div class="code e787">xs:double</div>
                           </div>
                           <div class="td e788">number</div>
                        </div>
                        <div class="tr e789" valign="top">
                           <div class="td e790">text node</div>
                           <div class="td e791">sequence</div>
                           <div class="td e792">false</div>
                           <div class="td e793">
                              <div class="code e794">xs:decimal</div>
                           </div>
                           <div class="td e795">number</div>
                        </div>
                        <div class="tr e796" valign="top">
                           <div class="td e797">text node</div>
                           <div class="td e798">sequence</div>
                           <div class="td e799">false</div>
                           <div class="td e800">
                              <div class="code e801">xs:integer</div>
                           </div>
                           <div class="td e802">number</div>
                        </div>
                        <div class="tr e803" valign="top">
                           <div class="td e804">text node</div>
                           <div class="td e805">sequence</div>
                           <div class="td e806">false</div>
                           <div class="td e807">
                              <div class="code e808">xs:boolean</div>
                           </div>
                           <div class="td e809">
                              <div class="code e810">true</div>|
                              <div class="code e811">false</div>
                           </div>
                        </div>
                        <div class="tr e812" valign="top">
                           <div class="td e813">text node</div>
                           <div class="td e814">sequence</div>
                           <div class="td e815">false</div>
                           <div class="td e816">
                              <div class="code e817">xs:untyped</div> or ST
                           </div>
                           <div class="td e818">string</div>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div><a name="%0ASerialization:controllingthelossofinformation%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e819" xml:id="serialization-controlling-the-loss-of-information">
            <div class="title e820">
               Serialization: controlling the loss of information
               
            </div>
            <div class="para e821">
               Serialization of a document to a markup language should 
               preserve all information so that the serialization is a 
               complete representation from which the document may be 
               reconstructed. Such a lossless serialization of a UDL 
               document is always possible for XML markup; it is only 
               in special cases possible for JSON markup. For example, 
               any attributes or non-default element names are lost 
               when serializing to JSON.
               
            </div>
            <div class="para e822">
               However, it depends on circumstances whether such loss 
               of information renders the serialization result worthless. 
               If, for example, the loss consists of element names only 
               and these names were only introduced in order to facilitate 
               document creation or processing, with an understanding that they will 
               get lost during later processing steps – then a serialization 
               which loses element names might be as valuable as a lossless 
               serialization. Such considerations suggest a refinement of 
               the serialization model: a new serialization parameter might 
               control what losses are acceptable and what losses are not 
               acceptable.
               
            </div>
            <div class="para e823">
               The proposal of a unified document language includes such a 
               new serialization parameter: 
               
               <div class="code e824">info-loss</div>. Presently the parameter 
               is only relevant when serializing to JSON. Three values are 
               defined:
               
               <div class="itemizedlist e825">
                  <div class="listitem e826">
                     <div class="para e827">
                        
                        <div class="code e828">json.strict</div> – any information loss causes 
                        an unrecoverable error
                        
                     </div>
                  </div>
                  <div class="listitem e829">
                     <div class="para e830">
                        
                        <div class="code e831">json.ignore-names</div> – element names are ignored, 
                        but any other information loss causes an unrecoverable 
                        error
                        
                     </div>
                  </div>
                  <div class="listitem e832">
                     <div class="para e833">
                        
                        <div class="code e834">json.projection</div> – any information that JSON 
                        cannot represent is simply ignored
                        
                     </div>
                  </div>
               </div>
               In particular, 
               <div class="code e835">info-loss</div> equal 
               
               <div class="code e836">json.projection</div> means:
               
               <div class="itemizedlist e837">
                  <div class="listitem e838">
                     <div class="para e839">
                        element names are ignored
                        
                     </div>
                  </div>
                  <div class="listitem e840">
                     <div class="para e841">
                        attributes are ignored
                        
                     </div>
                  </div>
                  <div class="listitem e842">
                     <div class="para e843">
                        text node siblings of element nodes are ignored (that is, mixed content
                        is projected onto the element children)
                        
                     </div>
                  </div>
               </div>
               
            </div>
         </div><a name="%0AUDLandXSD%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e844" xml:id="udl-and-xsd">
            <div class="title e845">
               UDL and XSD
               
            </div>
            <div class="para e846">
               The proposed extensions of the XML node model amount to 
               the introduction of two new node properties. Obviously, 
               they require also an extension of the XSD language. In 
               particular, constraints concerning the [key] property should 
               be supported. However, such changes are 
               out of scope of this paper.
               
            </div>
         </div>
      </div><a name="%0ALimitationsandfutureresearch%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e847" xml:id="limitations-and-future-research">
         <div class="title e848">
            Limitations and future research
            
         </div>
         <div class="para e849">
            UDL defines the information content of JSON text in terms 
            of a node tree and provides the rules for translating between 
            text and tree, that is, parsing and serialization. This makes 
            JSON data accessible to / producible by XML processing technologies, 
            but there are also important use cases which are not addressed: 
            
            <div class="orderedlist e850">
               <div class="listitem e851">
                  <div class="para e852">
                     given a JSON document, a well-readable XML representation 
                     is required
                     
                  </div>
               </div>
               <div class="listitem e853">
                  <div class="para e854">
                     given an arbitrary XML document, a JSON representation is 
                     required
                     
                  </div>
               </div>
               <div class="listitem e855">
                  <div class="para e856">
                     round-tripping XML - JSON - XML
                     
                  </div>
               </div>
            </div>
            As will be shown below, these are operations which require 
            some change of information content in the formal sense (in terms of 
            nodes and properties), necessary to create a “semantic” equivalence. 
            Such a change of information content cannot be achieved based on 
            parsing/serialization alone. This section explores the basic limitation 
            and makes a suggestion how an extension of the current UDL proposal 
            might look.
            
         </div><a name="%0AIssue:mappingarbitraryXMLtoJSON%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e857" xml:id="mapping-arbitrary-xml-to-json">
            <div class="title e858">
               Issue: mapping arbitrary XML to JSON
               
            </div>
            <div class="para e859">
               A serialization of arbitrary XML documents to JSON is usually 
               not possible without a loss of information, as JSON cannot 
               natively express element names, the distinction between 
               attributes and elements, mixed content and the occurrence 
               of siblings with the same name. This does not mean that JSON 
               could not be used to represent the complete information content 
               of an arbitrary XML document. This representation would however 
               not be a serialization of the XML document tree to JSON, but 
               the (serialized) result of a 
               
               <div class="emphasis e860" role="ital">transformation</div>, 
               a different node tree, adhering to a specific format which 
               is designed to capture the content of arbitrary XML 
               documents (e.g. [
               <div class="xref e861" linkend="JSONML"></div>] ). 
               The equivalence between the 
               resulting JSON (or the node tree it represents) and 
               the original XML document is not based on the data model, 
               but established on the level of a specific mapping 
               application (as a set of rules). 
               
            </div>
         </div><a name="%0AIssue:mappingJSONtoreadableXML%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e862" xml:id="mapping-json-to-readable-xml">
            <div class="title e863">
               Issue: mapping JSON to readable XML
               
            </div>
            <div class="para e864">
               A similar problem concerns the translation of JSON documents 
               into readable XML documents: the documents created by parsing 
               JSON as defined by UDL are well-suited for processing (e.g. 
               per XPath, XQuery, XSLT), but when serialized into XML text 
               look hardly readable. The practical need to obtain a well 
               readable XML representation of a given JSON document, however, 
               cannot be denied. (Think, for example, of a web service which 
               may at user option deliver XML or JSON results). Again, it is 
               a transformation from one tree to a different tree what is 
               required, as opposed to serializations into alternative 
               formats. 
               
            </div>
         </div><a name="%0AIssue:RoundtrippingXMLJSONXML%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e865" xml:id="round-tripping-xml-json-xml">
            <div class="title e866">
               Issue: Round-tripping XML - JSON - XML
               
            </div>
            <div class="para e867">
               The impossibility of serializing arbitrary XML to JSON 
               of course implies that round-tripping XML-JSON-XML is 
               not generally possible solely based on serialization and parsing.
               
            </div>
         </div><a name="%0AConceivableextensionofUDL:integrationofstandardizedmappings%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e868" xml:id="integration-of-standardized-mappings">
            <div class="title e869">
               Conceivable extension of UDL: integration of standardized mappings
               
            </div>
            <div class="para e870">
               Given the scope of UDL’s main goal – a unified document 
               language supporting multiple markup languages – it may be questioned 
               if the UDL concept is complete if not addressing fundamental 
               mapping tasks, too. A conceivable extension of UDL might 
               include two parts: (a) the definition of 
               
               <div class="emphasis e871" role="ital">mappings</div>, which 
               are standardized transformations (XML to JSON, lossless; 
               JSON to readable XML; (b) the integration of these mappings 
               with parsing / serialization into new “first-class” operations, 
               “
               <div class="emphasis e872" role="ital">mparse</div>” (parse &amp; map) and 
               “
               <div class="emphasis e873" role="ital">mserialize</div>” (map &amp; serialize). 
               The appendix contains a first step in this direction 
               [
               <div class="xref e874" linkend="appendix-b"></div>], 
               which is, however, limited to the use case of JSON documents 
               in which all names are NCNames. Another limitation is that it 
               does not yet support attributes in the mapping result, which 
               probably cannot be the last say.  
               
            </div>
            <div class="para e875">
               The mapping between XML and JSON is a question to which 
               already many answers have been given (e.g. 
               [
               <div class="xref e876" linkend="LEE"></div>], 
               [
               <div class="xref e877" linkend="PEMBERTON"></div>], 
               [
               <div class="xref e878" linkend="COUTHURES"></div>], 
               [
               <div class="xref e879" linkend="JSONML"></div>], 
               [
               <div class="xref e880" linkend="BASEX"></div>]). 
               The diversity is mainly due to differences between the 
               exact goals which the solutions pursue (concerning mapping 
               direction, losslessness, readability, configurability, …). 
               It is unclear if the suggested extension of UDL, which 
               involves standardized mappings between XML and JSON, is a 
               realistic task. But it is not hopeless, neither. First, the 
               unified node model provides a conceptual base which other 
               mapping approaches did not have. Second, the goals can be 
               defined precisely, which greatly removes competition between 
               existent solutions and a new standard. And finally, the 
               use of other, non-standard mappings would always remain 
               possible.
               
            </div>
         </div>
      </div><a name="%0AAlternativestoUDL%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e881" xml:id="alternatives-to-udl">
         <div class="title e882">
            Alternatives to UDL
            
         </div>
         <div class="para e883">
            How to process XML and JSON data in a unified way? The approach taken 
            by UDL should be compared with published alternatives. These fall 
            into two categories.
            
            <div class="itemizedlist e884">
               <div class="listitem e885">
                  <div class="para e886">
                     mapping approach – map JSON data to an XML representation and 
                     process the latter
                     
                  </div>
               </div>
               <div class="listitem e887">
                  <div class="para e888">
                     XDM extension – extend the XDM by new item types which can 
                     represent JSON data
                     
                  </div>
               </div>
            </div>
            The second category contains two variants:
            
            <div class="itemizedlist e889">
               <div class="listitem e890">
                  <div class="para e891">
                     extend the XDM by JSON-specific item types (JSONiq)
                     
                  </div>
               </div>
               <div class="listitem e892">
                  <div class="para e893">
                     extend the XDM by generic item types (W3C XSL Working Group proposal)
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e894">
            The next three sections attempt to clarify the relationships between 
            these approaches and UDL.
            
         </div><a name="%0AThemappingapproach%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e895" xml:id="the-mapping-approach">
            <div class="title e896">
               The mapping approach
               
            </div>
            <div class="para e897">
               The mapping approach (e.g. 
               <div class="xref e898" linkend="BASEX"></div>, 
               <div class="xref e899" linkend="PEMBERTON"></div>) 
               is based on an XML 
               representation of JSON data. It uses a simple processing model:
               
               <div class="itemizedlist e900">
                  <div class="listitem e901">
                     <div class="para e902">
                        preprocessing: JSON =&gt; XML
                        
                     </div>
                  </div>
                  <div class="listitem e903">
                     <div class="para e904">
                        processing: applied to XML data
                        
                     </div>
                  </div>
                  <div class="listitem e905">
                     <div class="para e906">
                        optional postprocessing: serialization (possibly to JSON)
                        
                     </div>
                  </div>
               </div>
               
               This is a clean solution, provided the XML representation preserves all 
               information contained in the JSON data, and the mapping rule can be 
               applied bidirectionally without loss of information. To define such a 
               mapping is not very difficult, as one can use reserved element names and 
               introduce helper attributes in order to exclude any information loss 
               (see 
               <div class="xref e907" linkend="table-mapping-approach-reserved-names"></div> for examples).       
               
               
               <div class="table e908" xml:id="table-mapping-approach-reserved-names">
                  <div class="caption e909">
                     <div class="para e910">
                        
                        <div class="emphasis e911" role="bold">
                           <div class="emphasis e912" role="ital">
                              The use of reserved element names and 
                              helper attributes 
                              to assist in the
                              mapping of JSON to/from XML (examples).
                              
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="metaBox e913"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1783').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1783" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e913'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e914"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1784').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1784" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e914'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e915">
                     <div class="tr e916" valign="top">
                        <div class="th e917" align="left" valign="top">source</div>
                        <div class="th e918" align="left" valign="top">elements</div>
                        <div class="th e919" align="left" valign="top">attributes</div>
                     </div>
                  </div>
                  <div class="tbody e920">
                     <div class="tr e921" valign="top">
                        <div class="td e922">
                           <div class="xref e923" linkend="BASEX"></div>
                        </div>
                        <div class="td e924">
                           <div class="code e925">json, value</div>
                        </div>
                        <div class="td e926">
                           <div class="code e927">arrays, booleans, nulls, numbers, objects, type </div>
                        </div>
                     </div>
                     <div class="tr e928" valign="top">
                        <div class="td e929">
                           <div class="xref e930" linkend="COUTHURES"></div>
                        </div>
                        <div class="td e931">
                           <div class="code e932">exml:anonymous</div>
                        </div>
                        <div class="td e933">
                           <div class="code e934">exml:fullname, exml:maxOccurs</div>
                        </div>
                     </div>
                     <div class="tr e935" valign="top">
                        <div class="td e936">
                           <div class="xref e937" linkend="HUNTER"></div>
                        </div>
                        <div class="td e938">
                           <div class="code e939">json, item</div>
                        </div>
                        <div class="td e940">
                           <div class="code e941">boolean, type</div>
                        </div>
                     </div>
                     <div class="tr e942" valign="top">
                        <div class="td e943">
                           <div class="xref e944" linkend="PEMBERTON"></div>
                        </div>
                        <div class="td e945">
                           <div class="code e946">json</div>
                        </div>
                        <div class="td e947">
                           <div class="code e948">name, starts, type</div>
                        </div>
                     </div>
                  </div>
               </div>
               Outwardly, UDL looks similar to such a 
               mapping-for-the-sake-of-processing; it is tempting to 
               classify it as yet another mapping variant. But that would 
               be a mistake. Mapping approaches treat the problem as an 
               XML 
               <div class="emphasis e949" role="ital">application</div>: 
               introduce a specific XML dialect designed to achieve a particular
               goal. Like any application, 
               these approaches are free to require the use 
               of application-specific element names and 
               the addition of attributes with application-specific semantics,
               to be evaluated by application code. The 
               
               <div class="code e950">type</div> attribute, for example, used in 
               [
               <div class="xref e951" linkend="BASEX"></div>] is a helper attribute which clearly 
               duplicates 
               
               <div class="code e952">xsi:type</div> 
               for certain values, yet nevertheless
               had to be introduced as additional attribute, because 
               the value range includes values 
               
               <div class="code e953">array</div> and 
               <div class="code e954">object</div>
               with ad hoc semantics dictated by the mapping 
               task. Such attributes reveal the fact that the
               current XML node model does not support a bidirectional
               mapping into JSON markup. To enable such a mapping,
               the node tree must contain special items with
               serialization semantics.
               This is at odds with the basic principle of serialization
               being a process solely controlled by serialization
               parameters, without a need to interfere with
               the information content of the node tree.
               
            </div>
            <div class="para e955">
               UDL does not 
               <div class="emphasis e956" role="ital">map</div>
               XML nodes to JSON structures.
               It redefines JSON to 
               <div class="emphasis e957" role="ital">be</div>
               a representation of nodes. As a consequence, it need not
               "inject" any ad hoc items into the data tree for
               the sake of controlling a serialization to JSON.
               None of the reserved element and attribute names in
               
               <div class="xref e958" linkend="table-reserved-names"></div>
               have anything to do with JSON or serialization.
               Rather, they represent standard names without semantics,
               reflect node properties
               or signal the markup language currently used
               within a well-defined scope.
               The extended node model 
               is expressive enough to represent JSON structures 
               natively. 
               
            </div>
            <div class="para e959">
               The main difference between UDL and mapping 
               approaches concerns the handling of JSON names. Mapping 
               approaches represent JSON names as element names if possible, 
               and if not, resort to one of two possible solutions: either 
               place the JSON name in an additional attribute (e.g. 
               
               <div class="xref e960" linkend="PEMBERTON"></div>), or define a bidirectional 
               name mapping 
               (e.g. 
               <div class="xref e961" linkend="BASEX"></div>). 
               But there are three differences between 
               the concepts of JSON names and XML names:
               
               <div class="itemizedlist e962">
                  <div class="listitem e963">
                     <div class="para e964">
                        a JSON name has no namespace component
                        
                     </div>
                  </div>
                  <div class="listitem e965">
                     <div class="para e966">
                        a JSON name can use arbitrary characters
                        
                     </div>
                  </div>
                  <div class="listitem e967">
                     <div class="para e968">
                        a JSON name must be unique amongst the JSON names of all 
                        siblings
                        
                     </div>
                  </div>
               </div>
               Note that the last point (the uniqueness 
               constraint) means that a JSON name resembles an 
               
               <div class="code e969">xml:id</div> attribute more than an element name.
               It can be compared to a locally scoped 
               
               <div class="code e970">xml:id</div> attribute (uniqueness among all element 
               children of an element). 
               For these reasons UDL distinguishes
               the concepts of names and keys. It thus enables
               native relationships between nodes and
               XML markup on the one hand and JSON markup on
               the other hand. As a result it becomes possible
               to regard JSON markup and XML markup as alternative
               representations of an information content
               which is defined in terms of nodes and their
               properties.
               Remembering Plato, 
               one kind of “thing” is inferred from - or may cast -
               two different "shadows".
               
            </div>
            <div class="para e971">
               Should we not keep things simple - do we 
               
               <div class="emphasis e972" role="ital">need</div> to 
               extend the document model and introduce new node properties? Imagine this alternative:
               
               <div class="itemizedlist e973">
                  <div class="listitem e974">
                     <div class="para e975">
                        the W3C publishes a small specification defining a standardized bi-directional 
                        mapping between arbitrary strings and QNames
                        
                     </div>
                  </div>
                  <div class="listitem e976">
                     <div class="para e977">
                        the XPath language syntax is slightly extended, introducing a second 
                        notation of a name test (e.g. 
                        <div class="code e978">#foo</div>)
                        which is interpreted as a string which is 
                        
                        <div class="emphasis e979" role="ital">automatically mapped</div> 
                        to a QName according to the standard name mapping:
                        
                        <div class="programlisting e980" xml:space="preserve">
                           a/b/#c       equivalent to:   a/b/c
                           a/b/#c_d     equivalent to:   a/b/c__D
                           a/b/#1       equivalent to:   a/b/_1
                           a/b/#”1 2”   equivalent to:   a/b/_1_00322	   
                           
                        </div>
                        
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e981">
               This is an attractive scenario: one can formulate the XPath expressions 
               without a mental translation, just using the names one 
               
               <div class="emphasis e982" role="ital">sees</div> in the source data. The net 
               result is an elegant approach 
               to the processing of JSON data with XML tools. 
               
            </div>
            <div class="para e983">
               The approach would be a good – and perhaps 
               a better – alternative to UDL if the processing of JSON documents
               with XML tools were the only goal. However, UDL's design
               aims at a unified document model which expresses the entities
               represented by dominant markup languages in
               a native way. Only this way can information content and
               representation (markup) be decoupled and can the latter
               be switched easily at various scales (whole documents, sections
               or single elements) and in various contexts (data and
               program code).
               
            </div>
         </div><a name="%0AJSONiq%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e984" xml:id="jsoniq">
            <div class="title e985">
               JSONiq
               
            </div>
            <div class="para e986">
               JSONiq 
               [
               <div class="xref e987" linkend="JSONIQ"></div>], 
               [
               <div class="xref e988" linkend="JSONIQSPEC"></div>] is an extension of the XQuery 
               language designed to add support for JSON data. Like UDL, 
               JSONiq extends the XDM in order to accommodate JSON structures. 
               However, JSONiq does not change the node sub model of the XDM. 
               Rather, two new item types are introduced, designed to represent 
               JSON data:
               
               <div class="itemizedlist e989">
                  <div class="listitem e990">
                     <div class="para e991">object</div>
                  </div>
                  <div class="listitem e992">
                     <div class="para e993">array</div>
                  </div>
               </div>      
               
            </div>
            <div class="para e994">
               It is interesting to note the parallel: both, JSONiq and 
               UDL extend the XDM in order to accommodate JSON data; but 
               the changes UDL proposes are 
               
               <div class="emphasis e995" role="ital">within</div> the node sub model, 
               whereas JSONiq adds a second sub model for structured data,
               in parallel to the node model. Using the terms proposed in 
               
               <div class="xref e996" linkend="distinction-between-markup-and-document-language"></div>:
               JSONiq keeps the XML 
               document language, but extends the XML information language, 
               whereas UDL shifts the changes into the very document language, 
               refraining from changes outside of the node model.
               
            </div>
            <div class="para e997">
               An advantage UDL offers is to represent JSON data as node 
               trees and thus expose them to XPath navigation. JSONiq, 
               on the other hand, might be easier to accept exactly because 
               it does not introduce any change to the document language 
               and therefore restricts itself to the extension of a query 
               language, rather than an extension of XML.
               
            </div>
         </div><a name="%0AMapitems%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e998" xml:id="map-items">
            <div class="title e999">
               Map items
               
            </div>
            <div class="para e1000">
               The W3C XSL Working Group has made a proposal for extending
               the XDM by a new item type: map items
               [
               <div class="xref e1001" linkend="W3C-XSLT-3.0"></div>]. They represent 
               generic containers, but nevertheless can represent
               JSON data. One should note the
               relationship between JSONiq and the map proposal:
               both approaches mandate new item types which 
               are not nodes and yet can represent structured
               data; but one (JSONiq) resorts to JSON-specific
               items, whereas the other advocates
               generic containers.
               
            </div>
            <div class="para e1002">
               Not being nodes, map items
               are lightweight containers which can collect
               items without requiring or imposing a structural relationship.
               Therefore node relationships between container and members 
               are not possible. This contrasts sharply with the UDL approach 
               which models JSON containers and their members as nodes and
               their child nodes. Only this way can JSON data be seamlessly 
               integrated into the navigational system based on axes and 
               node tests.
               
            </div>
            <div class="para e1003">
               This is not to say that such lightweight containers 
               would not be very useful extensions of XDM. Lightweight 
               containers and nodes cannot replace each other. 
               A node model is required for the navigational power of XPath. 
               Lightweight containers are required to model node relationships 
               independently from their structural relationship. And among 
               other benefits they enable a mapping of keys to node references, 
               rather than the nodes themselves, which is a highly desirable
               feature.
               
            </div>
            <div class="para e1004">
               It is interesting to note a conceptual relationship between
               UDL and the "map proposal": the content of an element with
               [model] equal "map" can be described as a map item
               constrained in the following way: 
               (a) every map value is a child element; (b) every map key
               is the [key] of the associated value.
               
            </div>
         </div>
      </div><a name="%0ADiscussion%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1005" xml:id="discussion">
         <div class="title e1006">
            Discussion
            
         </div>
         <div class="para e1007">
            There is a growing awareness in the XML community that other
            markup languages do, will and should coexist with XML.
            So integration is a crucial task. Being determined
            to integrate, one may look at XML - as well as other
            markup languages - as both: markup, and information
            content represented by markup.
            
         </div>
         <div class="para e1008">
            We happen to be in the possession of a rigorous, formal
            definition of the information content of XML data. 
            If this model is only approximately, but not quite
            capable of expressing what new markup languages
            have to say (compare 
            
            <div class="xref e1009" linkend="the-mapping-approach"></div>),
            this may reflect the circumstances
            when those formal definitions 
            were set down: a point in time when XML 
            structure was the only thing that had to be expressed. 
            But 
            <div class="emphasis e1010" role="ital">now</div> 
            it seems a natural course
            to consider extending the model cautiously,
            turning it into a unified document language. When
            infoset and XDM became recommendations, there was nothing to unify,
            now there is.       
            
         </div>
         <div class="para e1011">
            UDL might change our perception of markup languages:
            they are freely exchangeable 
            in various contexts -
            both in data resources and in program code 
            (within XQuery and XSLT constructors) - 
            and at various scales -
            whole document, document section, single element.
            This becomes possible when different
            markup is seen as alternative representation
            of unified content.
            
         </div>
         <div class="para e1012">
            An evaluation of the UDL proposal may profit from making
            two distinctions. The first distinction is between UDL's 
            central idea and its translation into technical details.
            The idea is to relate multiple markup languages to a single, 
            unified node model, which turns XML processing 
            technologies into general information processing 
            technologies. For this purpose, the node model was
            extended in a particular way (e.g. adding a new node
            property, [key]). Doubtless,
            other approaches how to extend the node model are conceivable,
            too. An evaluation of the UDL proposal might modify
            or even replace the model extensions by alternatives,
            preserving the central idea as such.
            
         </div>
         <div class="para e1013">
            The second distinction is between what UDL does achieve and
            what is deliberately left to a future extension (or to
            complementary components). UDL does not yet
            offer support for certain transformations ("mappings")
            which are acknowledged to be important in the context of markup
            integration. In other words: the existence of
            a unified document language does not yet mean
            comprehensive support for all use cases in the context
            of integrating multiple markup languages.
            An evaluation of the UDL proposal 
            should regard the unified document language as 
            a 
            <div class="emphasis e1014" role="ital">foundation</div> for
            mapping support - not as a substitute.
            
         </div>
      </div><a name="AcknowledgementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1015">
         <div class="title e1016">Acknowledgements</div>
         <div class="para e1017">
            Cordial thanks to David A. Lee who read an earlier version of this paper 
            and gave me most valuable feedback. Without David's criticism
            I would not have realized that a further elaboration 
            of the basic concept was necessary. 
            
         </div>
      </div><a name="Deserializingfrom/serializingtoJSONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e1018" xml:id="appendix-a">
         <div class="title e1019">Deserializing from / serializing to JSON</div>
         <div class="para e1020">
            This appendix contains the precise rules how to deserialize 
            a JSON document to a tree of nodes and how to serialize a 
            tree of nodes to a JSON document.
            
         </div><a name="%0ADeserialization%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1021" xml:id="appendix-deserialization">
            <div class="title e1022">
               Deserialization
               
            </div>
            <div class="para e1023">
               
               <div class="informaltable e1024">
                  <div class="tr e1025" valign="top">
                     <div class="td e1026">
                        <div class="emphasis e1027" role="bold">JSON null</div> =&gt; node
                     </div>
                  </div>
                  <div class="tr e1028" valign="top">
                     <div class="th e1029" align="left">property</div>
                     <div class="th e1030" align="left">value</div>
                  </div>
                  <div class="tr e1031" valign="top">
                     <div class="td e1032">name</div>
                     <div class="td e1033">
                        <div class="code e1034">udl:null</div>
                     </div>
                  </div>
                  <div class="tr e1035" valign="top">
                     <div class="td e1036">key</div>
                     <div class="td e1037">                  
                        if the null is the value of a name/value pair – 
                        the name; empty, otherwise
                        
                     </div>
                  </div>
                  <div class="tr e1038" valign="top">
                     <div class="td e1039">model</div>
                     <div class="td e1040">sequence</div>
                  </div>
                  <div class="tr e1041" valign="top">
                     <div class="td e1042">nilled</div>
                     <div class="td e1043">true</div>
                  </div>
                  <div class="tr e1044" valign="top">
                     <div class="td e1045">schema type</div>
                     <div class="td e1046">
                        <div class="code e1047">xs:untyped</div>
                     </div>
                  </div>
               </div>
               
               
               <div class="informaltable e1048">
                  <div class="tr e1049" valign="top">
                     <div class="td e1050">
                        <div class="emphasis e1051" role="bold">JSON object</div> =&gt; node
                     </div>
                  </div>
                  <div class="tr e1052" valign="top">
                     <div class="th e1053" align="left">property</div>
                     <div class="th e1054" align="left">value</div>
                  </div>
                  <div class="tr e1055" valign="top">
                     <div class="td e1056">name</div>
                     <div class="td e1057">
                        <div class="code e1058">udl:map</div>
                     </div>
                  </div>
                  <div class="tr e1059" valign="top">
                     <div class="td e1060">key</div>
                     <div class="td e1061">                  
                        if the object is the value of a name/value pair – 
                        the name; empty, otherwise
                        
                     </div>
                  </div>
                  <div class="tr e1062" valign="top">
                     <div class="td e1063">model</div>
                     <div class="td e1064">map</div>
                  </div>
                  <div class="tr e1065" valign="top">
                     <div class="td e1066">content</div>
                     <div class="td e1067">
                        the collection of element nodes created by deserializing the 
                        name/value pairs
                        
                     </div>
                  </div>
                  <div class="tr e1068" valign="top">
                     <div class="td e1069">schema type</div>
                     <div class="td e1070">
                        <div class="code e1071">xs:untyped</div>
                     </div>
                  </div>
               </div>
               
               
               <div class="informaltable e1072">
                  <div class="tr e1073" valign="top">
                     <div class="td e1074">
                        <div class="emphasis e1075" role="bold">JSON array</div> =&gt; node
                     </div>
                  </div>
                  <div class="tr e1076" valign="top">
                     <div class="th e1077" align="left">property</div>
                     <div class="th e1078" align="left">value</div>
                  </div>
                  <div class="tr e1079" valign="top">
                     <div class="td e1080">name</div>
                     <div class="td e1081">
                        <div class="code e1082">udl:array</div>
                     </div>
                  </div>
                  <div class="tr e1083" valign="top">
                     <div class="td e1084">key</div>
                     <div class="td e1085">                  
                        if the array is the value of a name/value pair – 
                        the name; empty, otherwise
                        
                     </div>
                  </div>
                  <div class="tr e1086" valign="top">
                     <div class="td e1087">model</div>
                     <div class="td e1088">sequence</div>
                  </div>
                  <div class="tr e1089" valign="top">
                     <div class="td e1090">content</div>
                     <div class="td e1091">
                        the collection of element nodes created by deserializing the 
                        array members
                        
                     </div>
                  </div>
                  <div class="tr e1092" valign="top">
                     <div class="td e1093">schema type</div>
                     <div class="td e1094">
                        <div class="code e1095">xs:untyped</div>
                     </div>
                  </div>
               </div>
               
               
               <div class="informaltable e1096">
                  <div class="tr e1097" valign="top">
                     <div class="td e1098">
                        <div class="emphasis e1099" role="bold">JSON simple value</div> =&gt; node
                     </div>
                  </div>
                  <div class="tr e1100" valign="top">
                     <div class="th e1101" align="left">property</div>
                     <div class="th e1102" align="left">value</div>
                  </div>
                  <div class="tr e1103" valign="top">
                     <div class="td e1104">name</div>
                     <div class="td e1105">
                        <div class="code e1106">udl:value</div>
                     </div>
                  </div>
                  <div class="tr e1107" valign="top">
                     <div class="td e1108">key</div>
                     <div class="td e1109">                  
                        if the value is part of a name/value pair – 
                        the name; empty, otherwise
                        
                     </div>
                  </div>
                  <div class="tr e1110" valign="top">
                     <div class="td e1111">model</div>
                     <div class="td e1112">sequence</div>
                  </div>
                  <div class="tr e1113" valign="top">
                     <div class="td e1114">content</div>
                     <div class="td e1115">
                        if the value is not a zero-length string: a text node 
                        containing the text representation of the value; 
                        empty content, otherwise
                        
                     </div>
                  </div>
                  <div class="tr e1116" valign="top">
                     <div class="td e1117">schema type</div>
                     <div class="td e1118">
                        
                        <div class="itemizedlist e1119">
                           <div class="listitem e1120">
                              <div class="para e1121">
                                 if the JSON value is a number: 
                                 
                                 <div class="code e1122">xs:integer/xs:decimal/xs:double</div> –
                                 depending on the lexical form 
                                 
                              </div>
                           </div>
                           <div class="listitem e1123">
                              <div class="para e1124">
                                 if the JSON value is one of the constants 
                                 
                                 <div class="code e1125">true</div> or 
                                 <div class="code e1126">false</div>: 
                                 
                                 <div class="code e1127">xs:boolean</div>
                                 
                              </div>
                           </div>
                           <div class="listitem e1128">
                              <div class="para e1129">
                                 if the JSON value is a zero-length string: 
                                 
                                 <div class="code e1130">xs:untypedAtomic</div>
                                 
                              </div>
                           </div>
                           <div class="listitem e1131">
                              <div class="para e1132">
                                 otherwise: 
                                 <div class="code e1133">xs:untyped</div>
                                 
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e1134">
               Note: The XML representation of a zero-length JSON string 
               is an empty element with type annotation 
               
               <div class="code e1135">xs:untypedAtomic</div>. The type annotation
               makes the node distinguishable from empty elements
               corresponding to empty arrays or objects.
               
            </div>
         </div><a name="%0ASerialization%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1136" xml:id="appendix-serialization">
            <div class="title e1137">
               Serialization
               
            </div>
            <div class="para e1138">
               
               <div class="emphasis e1139" role="bold">
                  <div class="emphasis e1140" role="ital">
                     Handling attributes
                     
                  </div>
               </div>
               
            </div>
            <div class="para e1141">
               If attributes are encountered, the behaviour depends on the 
               serialization parameter
               
               <div class="code e1142">info-loss</div>: if the value is 
               
               <div class="code e1143">json.projection</div>, the attributes are
               ignored; otherwise, a non-recoverable error is raised.
               
            </div>
            <div class="para e1144">
               
               <div class="emphasis e1145" role="bold">
                  <div class="emphasis e1146" role="ital">
                     Handling of processing instructions and comments
                     
                  </div>
               </div>
               
            </div>
            <div class="para e1147">
               Processing instructions and comments are ignored.
               
            </div>
            <div class="para e1148">
               
               <div class="emphasis e1149" role="bold">
                  <div class="emphasis e1150" role="ital">
                     Handling elements
                     
                  </div>
               </div>
               
            </div>
            <div class="para e1151">
               The handling of elements depends on various properties:
               
               <div class="itemizedlist e1152">
                  <div class="listitem e1153">
                     <div class="para e1154">
                        the [nilled] property
                        
                     </div>
                  </div>
                  <div class="listitem e1155">
                     <div class="para e1156">
                        the [model] property
                        
                     </div>
                  </div>
                  <div class="listitem e1157">
                     <div class="para e1158">
                        the presence of element children
                        
                     </div>
                  </div>
                  <div class="listitem e1159">
                     <div class="para e1160">
                        the presence of text node children
                        
                     </div>
                  </div>
                  <div class="listitem e1161">
                     <div class="para e1162">
                        the [schema-type] property
                        
                     </div>
                  </div>
               </div>
               The following table shows all details.
               
            </div>
            <div class="para e1163">
               
               <div class="table e1164">
                  <div class="caption e1165">
                     <div class="para e1166">
                        
                        <div class="emphasis e1167" role="bold">
                           <div class="emphasis e1168" role="ital">
                              Serialization - translating UDL nodes into JSON items.
                              
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="metaBox e1169"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e2238').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e2238" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e1169'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e1170"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e2239').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e2239" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">align='left'
                           </span><span class="metaAttribute">class='e1170'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">valign='top'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e1171">
                     <div class="tr e1172" valign="top">
                        <div class="th e1173" align="left" rowspan="2" valign="top">UDL element node</div>
                        <div class="th e1174" align="left" colspan="3" valign="top">JSON item</div>
                     </div>
                  </div>
                  <div class="tbody e1175">
                     <div class="tr e1176" valign="top">
                        <div class="td e1177">[nilled] is 
                           <div class="code e1178">true</div>
                        </div>
                        <div class="td e1179">
                           
                           <div class="para e1180">
                              If serialization parameter 
                              
                              <div class="code e1181">info-loss</div> is 
                              
                              <div class="code e1182">json.strict</div> and the element name is not 
                              
                              <div class="code e1183">udl:null</div>, a non-recoverable error is 
                              raised. Otherwise the element is serialized as a 
                              JSON null value.
                              
                           </div>
                           
                        </div>
                     </div>
                     <div class="tr e1184" valign="top">
                        <div class="td e1185" valign="top">
                           
                           <div class="para e1186">[model] = "map"</div>
                           
                        </div>
                        <div class="td e1187">
                           
                           <div class="para e1188">
                              If serialization parameter 
                              
                              <div class="code e1189">info-loss</div> is 
                              
                              <div class="code e1190">json.strict</div> and the element 
                              name is not 
                              
                              <div class="code e1191">udl:map</div>, a non-recoverable error is raised. 
                              Otherwise the element is serialized as a JSON object. 
                              The contained name/value pairs are obtained by serializing 
                              the element children. An error is raised if
                              the element has a text node child with 
                              non-whitespace content.
                              
                           </div>
                           
                           
                        </div>
                     </div>
                     <div class="tr e1192" valign="top">
                        <div class="td e1193">
                           
                           <div class="para e1194">
                              [model] = "sequence";
                              
                           </div>
                           
                           <div class="para e1195">
                              at least one element child
                              
                           </div>
                           
                        </div>
                        <div class="td e1196">
                           
                           <div class="para e1197">
                              If serialization parameter 
                              
                              <div class="code e1198">info-loss</div> is 
                              
                              <div class="code e1199">json.strict</div> and the element 
                              name is not 
                              
                              <div class="code e1200">udl:array</div>, a non-recoverable error is raised. 
                              Otherwise the element is serialized as a JSON array. 
                              The array members are obtained by serializing 
                              the element children. An error is raised if 
                              the element has a text node child with 
                              non-whitespace content.
                              
                           </div>
                           
                           
                        </div>
                     </div>
                     <div class="tr e1201" valign="top">
                        <div class="td e1202">
                           
                           <div class="para e1203">
                              [model] = "sequence";
                              
                           </div>
                           
                           <div class="para e1204">
                              no element children;
                              
                           </div>
                           
                           <div class="para e1205">
                              at least one text node child
                              
                           </div>
                           
                        </div>
                        <div class="td e1206">
                           
                           <div class="para e1207">
                              If serialization parameter 
                              
                              <div class="code e1208">info-loss</div> is 
                              
                              <div class="code e1209">json.strict</div> and the element 
                              name is not 
                              
                              <div class="code e1210">udl:value</div>, a non-recoverable error is raised. 
                              Otherwise, the element is serialized as a JSON simple value.
                              The string values of the text nodes are concatenated and the 
                              result is used to construct a simple JSON value whose type
                              depends on the node's [schema-type]: number (if [schema-type]
                              is equal to or derived from xs:double or xs:decimal),
                              Boolean (if [schema-type] is equal to or derived from xs:boolean)
                              or a string (otherwise).
                              
                           </div>
                           
                        </div>
                     </div>
                     <div class="tr e1211" valign="top">
                        <div class="td e1212">
                           
                           <div class="para e1213">
                              [model] = "sequence";
                              
                           </div>
                           
                           <div class="para e1214">
                              no element children;
                              
                           </div>
                           
                           <div class="para e1215">
                              no text node child;
                              
                           </div>
                           
                           <div class="para e1216">
                              [schema-type] is an atomic type
                              
                           </div>
                           
                        </div>
                        <div class="td e1217">
                           
                           <div class="para e1218">
                              If serialization parameter 
                              
                              <div class="code e1219">info-loss</div> is 
                              
                              <div class="code e1220">json.strict</div> and the element 
                              name is not 
                              
                              <div class="code e1221">udl:value</div>, a non-recoverable error is raised. 
                              Otherwise, the element is serialized as a JSON string 
                              value of zero length.
                              
                           </div>
                           
                           
                        </div>
                     </div>
                     <div class="tr e1222" valign="top">
                        <div class="td e1223">
                           
                           <div class="para e1224">
                              [model] = "sequence";
                              
                           </div>
                           
                           <div class="para e1225">
                              no element children;
                              
                           </div>
                           
                           <div class="para e1226">
                              no text node child;
                              
                           </div>
                           
                           <div class="para e1227">
                              [schema-type] is not atomic
                              
                           </div>
                           
                           
                        </div>
                        <div class="td e1228">
                           
                           <div class="para e1229">
                              If serialization parameter 
                              
                              <div class="code e1230">info-loss</div> is 
                              
                              <div class="code e1231">json.strict</div> and the element 
                              name is not 
                              
                              <div class="code e1232">udl:array</div>, a non-recoverable error is raised. 
                              Otherwise, the element is serialized as an empty JSON array.
                              
                           </div>
                           
                           
                        </div>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </div><a name="Additionalsupportfor&#34;NCNameonlyJSON&#34;ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e1233" xml:id="appendix-b">
         <div class="title e1234">Additional support for "NCName-only JSON"</div>
         <div class="para e1235">
            This appendix describes an extension of the UDL proposal which 
            provides additional support for processing JSON documents in 
            which every name is an NCName. This extension is presented as 
            an appendix as it has a more tentative character than the core 
            parts of the proposal and is more likely to be modified, removed 
            or replaced by alternatives, should the UDL proposal be evaluated 
            as a whole.
            
         </div><a name="%0AIntroduction%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1236" xml:id="appendix-b-introduction">
            <div class="title e1237">
               Introduction
               
            </div>
            <div class="para e1238">
               UDL does not map JSON documents to XML documents, but defines 
               the information content of a JSON document as an UDL node tree. 
               Such a node tree can be serialized as both, JSON or XML. The 
               XML representation of a JSON document is ugly and not meant 
               for human consumption. The UDL proposal regards the readability 
               of this XML representation as a non-goal and concentrates on 
               the node tree which is designed to enable a JSON processing 
               as powerful and elegant as XML processing. The developer is 
               expected to design his JSON processing code while regarding 
               the JSON serialization, not the XML serialization.
               
            </div>
            <div class="para e1239">  
               The poor readability of XML-encoded JSON documents is caused by 
               the fact than JSON names are captured as node keys, rather than 
               node names. The [key] property was introduced because the 
               alternative approach of regarding JSON names as node names 
               would introduce a dependence of the node model’s name 
               representation on whether the JSON name happens to be an 
               NCName: NCNames are preserved, and non-NCNames are changed 
               into the result of a name mapping which is either generic 
               and non-semantic (e.g. “2012” to “_2012”) or semantic and 
               application specific (e.g. “2012” to “year-2012”). A 
               semantic mapping is certainly an interesting solution in 
               many situations (compare for example [
               <div class="xref e1240" linkend="LEE"></div>]), 
               but it gives up the advantages of a unified document 
               language. The purely technical mapping which 
               replaces inacceptable characters, on 
               the other hand, is unnatural, as it amounts to the perspective 
               that “_2012” is the essential information content, whereas 
               “2012” is some deviating representation.
               
            </div>
         </div><a name="%0ADefinitionofUDLdocumentstyles:nJSONnnJSON%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1241" xml:id="njson-nnjson">
            <div class="title e1242">
               Definition of UDL document styles: nJSON, nnJSON
               
            </div>
            <div class="para e1243">
               Nevertheless it cannot be denied that in some situations 
               one would like to have available both, a readable JSON 
               representation and a readable XML representation. For example,
               an increasing number of web services is expected to deliver both,
               XML and JSON, at user option. In this scenario, UDL’s 
               XML representation of a JSON document is downright inappropriate. 
               What is needed is an XML representation whose element names 
               mirror as good as possible the JSON names. If the JSON document 
               contains non-NCName names, the mapping problem arises - but 
               what if all JSON names 
               <div class="emphasis e1244" role="ital">are</div> 
               NCNames? Let us define an 
               
               <div class="emphasis e1245" role="bold">nJSON</div> 
               document as a JSON document in which all names are NCNames.
               An XML representation of an nJSON document may 
               then reuse the JSON names as element names (the local part of it), 
               and yet represent a JSON document without any ambiguity: 
               JSON-serialization using the serialization parameter 
               
               <div class="code e1246">info-loss</div> with a value 
               
               <div class="code e1247">json.ignore-names</div> will yield 
               the same document as the strict JSON-serialization of the 
               counterpart which sticks to unspecific names. Let us further 
               introduce the notion of 
               
               <div class="emphasis e1248" role="bold">nnJSON</div> 
               documents defined as follows: 
               
            </div>
            <div class="orderedlist e1249">
               <div class="listitem e1250">
                  <div class="para e1251">
                     every name is an NCName (indicated by the first “n”)
                     
                  </div>
               </div>
               <div class="listitem e1252">
                  <div class="para e1253">
                     every element with a key has a local name equal to the key (the second “n“)
                     
                  </div>
               </div>
               <div class="listitem e1254">
                  <div class="para e1255">
                     the document is JSON-serializable using 
                     <div class="code e1256">json.ignore-names</div> (the “JSON”)
                     
                  </div>
               </div>
            </div>
            <div class="para e1257">
               Note that (3) implies further constraints: no attributes and no 
               mixed content. At the same time this definition leaves considerable 
               freedom: namespaces and the names of key-less elements can be 
               chosen arbitrarily. nnJSON documents can be regarded as augmented 
               nJSON documents – the additional information consisting of element 
               names which can later be used or discarded, dependent on purpose.
               
            </div>
            <div class="para e1258">
               nnJSON documents have a remarkable property: they represent 
               an unambiguously determined nJSON document, to whose JSON text 
               they can be serialized, using 
               <div class="code e1259">json.ignore-names</div>; 
               and they can also be serialized to a well-readable XML 
               representation of that JSON document. 
               When dealing with nJSON documents, nnJSON can 
               be used as a normalization of information which enables unified 
               processing code: code that is used no matter if the input is 
               JSON or XML and whether the output is JSON or XML. This 
               unified code consumes an nnJSON tree and it produces an 
               nnJSON tree. The UDL extensions discussed so far ensure that 
               the nnJSON output can be alternatively serialized as readable 
               XML or nJSON. The extensions do however not enable the parsing 
               of both, nJSON text (JSON)  and nnJSON text (XML) into an nnJSON 
               tree. After all, the information content of nJSON and nnJSON 
               is different and parsing by definition does not change the 
               information content: parsing alone will always produce one 
               kind of tree or the other. The processing pattern just 
               sketched – “read and write nnJSON” - therefore has to rely 
               on a translation of an nJSON text or node tree into an nnJSON 
               node tree.
               
            </div>
         </div><a name="%0ASpecialsupportfortheprocessingofnJSONdocuments%E2%80%93afurtherextensionofXPath%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e1260" xml:id="support-for-njson">
            <div class="title e1261">
               Special support for the processing of nJSON documents – a further extension of XPath
               
            </div>
            <div class="para e1262">
               After parsing an nJSON document (
               <div class="code e1263">doc("foo.json")</div>) 
               it can easily be transformed into an nnJSON document, e.g. with 
               a simple stylesheet. nJSON documents are however so important 
               that they warrant a built-in support supplied by the UDL 
               extensions. Therefore the present proposal adds a 
               special-purpose-function which combines the JSON parsing 
               and its transformation to an equivalent nnJSON document:
               
            </div>
            <div class="programlisting e1264" xml:space="preserve">
               nnjson($uri as xs:anyURI) as document-node()
            </div>
            <div class="para e1265">
               Further signatures allow for control of several aspects 
               of the result document which are not constrained by the 
               definition of nnJSON documents. These  are:
               
               <div class="orderedlist e1266">
                  <div class="listitem e1267">
                     <div class="para e1268">
                        the element namespaces
                        
                     </div>
                  </div>
                  <div class="listitem e1269">
                     <div class="para e1270">
                        the node name of the root element
                        
                     </div>
                  </div>
                  <div class="listitem e1271">
                     <div class="para e1272">
                        the node names of other elements without a key
                        
                     </div>
                  </div>
               </div>
               Consider an example. Let the following nJSON document 
               be a response to a “getWeather”  service request:
               
               <div class="programlisting e1273" xml:space="preserve">
                  {
                  "date" : "2012-08-06",
                  "place" : " London",
                  "temperatures" : ["12", "21"]
                  }
               </div>
               Here comes a matching nnJSON document:
               
               <div class="programlisting e1274" xml:space="preserve">
                  &lt;getWeatherRS xmlns="http://example.com" udl:model="map"&gt;
                  &lt;date&gt;2012-08-06&lt;/date&gt;
                  &lt;place&gt;London&lt;/place&gt;
                  &lt;temperatures&gt;
                  &lt;t&gt;12&lt;/t&gt;
                  &lt;t&gt;21&lt;/t&gt;
                  &lt;/temperatures&gt;  
                  &lt;/getWeatherRS&gt;
               </div>
               This document looks as a fairly natural representation of 
               the original JSON document, and it can be serialized 
               to the original JSON document using 
               
               <div class="code e1275">json.ignore-names</div>. Note 
               the use of an arbitrary namespace and the choice of 
               intuitive element names for key-less elements. A 
               second signature of the 
               <div class="code e1276">nnjson</div> 
               function enables control of these customizations:
               
               <div class="programlisting e1277" xml:space="preserve">
                  nnjson($uri as xs:anyURI, 
                  $namespace as xs:anyURI?, 
                  $rootName as xs:string, 
                  $patternsAndNames as item()*)
               </div>
               The 
               <div class="code e1278">patternsAndNames</div> parameter expects an alternating 
               sequence of XSLT pattern values and an element name; when 
               renaming a key-less element, the first matching pattern is 
               located and the name is taken from the item following the 
               pattern item. Our example could be produced by the 
               following call:
               
               <div class="programlisting e1279" xml:space="preserve">
                  nnjson("rsp.json", 
                  "http://example.com", 
                  "getWeatherRS", 
                  ("#temperatures/*", "t")
                  )
               </div>
               Using the simple signature without control paramters, on the other hand:
               
               <div class="programlisting e1280" xml:space="preserve">nnjson("rsp.json")</div>
               produces a document without namespace and with 
               some unspecific element names:
               
               <div class="programlisting e1281" xml:space="preserve">
                  &lt;udl:map udl:model="map"&gt;
                  &lt;date&gt;2012-08-06&lt;/date&gt;
                  &lt;place&gt;London&lt;/place&gt;
                  &lt;temperatures&gt;
                  &lt;udl:value&gt;12&lt;/udl:value&gt;
                  &lt;udl:value&gt;21&lt;/udl:value&gt;
                  &lt;/udl:temperatures&gt;  
                  &lt;/udl:map&gt;
               </div>
               The 
               <div class="code e1282">nnjson</div> function is a convenience function which 
               combines the parsing of an nJSON document with a 
               transformation of particular interest. The transformation 
               is defined in such a way that the changes of information 
               content do not interfere with a subsequent JSON-serialization 
               (using 
               <div class="code e1283">json.ignore-names</div>). This curious mixture 
               of parsing and transformation is regarded as a first-class 
               operation deserving a built-in XPath function because of 
               a well-defined relationship between the resulting 
               XML document and the original JSON document.
               
            </div>
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e1284">
         <div class="title e1285">Bibliography</div>
         <div class="bibliomixed e1286" xml:id="BASEX" xreflabel="BaseX">Gruen, Christian, et al. 
            BaseX Documentation Version 7.2, section "JSON Module", p. 125-127. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1287" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://docs.basex.org/wiki/Main_Page</div>.
         </div>
         <div class="bibliomixed e1288" xml:id="COUTHURES" xreflabel="Couthures">Couthures, Alain. 
            JSON for XForms - adding JSON support in XForms data instances. 
            XML Prague 2011, Conference Proceedings, p. 13-24.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1289" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e1290" xml:id="JSON" xreflabel="JSON">Web resource without source information: Introducing JSON.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1291" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://json.org</div>.
         </div>
         <div class="bibliomixed e1292" xml:id="JSONIQ" xreflabel="JSONiq">Robie, Jonathan, Mathias Brantner,
            Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq - XQuery for JSON,
            JSON for XQuery. XML Prague 2012, Conference Proceedings, p. 63-72.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1293" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e1294" xml:id="JSONIQSPEC" xreflabel="JSONiq Specification">Robie, Jonathan, Mathias Brantner,
            Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq: Language Specification.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1295" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jsoniq.com/docs/spec/en-US/html/index.html</div>.
         </div>
         <div class="bibliomixed e1296" xml:id="HUNTER" xreflabel="Hunter">Hunter, Jason. 
            A JSON facade on MarkLogic Server. XML Prague 2011, Conference Proceedings, p. 25-34.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1297" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e1298" xml:id="JSONML" xreflabel="JsonML">Web resource without source 
            information: JSON Markup Language (JsonML). 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1299" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.jsonml.org/</div>.
         </div>
         <div class="bibliomixed e1300" xml:id="LEE" xreflabel="Lee">Lee, David A. JXON: an Architecture for 
            Schema and Annotation Driven JSON/XML Bidirectional Transformations. Presented at
            
            Balisage: The Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. 
            In Proceedings of Balisage: The Markup Conference 2011. Balisage Series on 
            Markup Technologies, vol. 7 (2011). doi:
            <div class="biblioid doi e1301">10.4242/BalisageVol7.Lee01</div>.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1302" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</div>.
         </div>
         <div class="bibliomixed e1303" xml:id="PEMBERTON" xreflabel="Pemberton">Pemberton, Steven. 
            Treating JSON as a subset of XML. XML Prague 2012, 
            Conference Proceedings, p. 81-90.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1304" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</div>.
         </div>
         <div class="bibliomixed e1305" xml:id="ROBIE" xreflabel="Robie">Robie, Jonathan. A universal
            markup language and a universal query language. A contribution to the discussion of
            
            Google group JSONiq, 18 October 2011.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1306" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://groups.google.com/group/jsoniq</div>.
         </div>
         <div class="bibliomixed e1307" xml:id="TENNISON" xreflabel="Tennison">Tennison, Jeni. Opening keynote -
            collisions, chimera and consonance in web content. A presentation at
            xmlprague 2012. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1308" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.slideshare.net/JeniT/collisions-chimera-and-consonance-in-web-content</div>.
         </div>
         <div class="bibliomixed e1309" xml:id="W3C-INFOSET" xreflabel="W3C Information Set">John Cowan and Richard Tobin, eds. 
            XML Information Set. W3C Recommendation 4 February 2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1310" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml-infoset/</div>.
         </div>
         <div class="bibliomixed e1311" xml:id="W3C-XDM" xreflabel="W3C XDM">Mary Fernandez et al, eds. 
            XQuery 1.0 and XPath 2.0 Data Model (XDM). W3C Recommendation 23 January 2007.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1312" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel/</div>.
         </div>
         <div class="bibliomixed e1313" xml:id="W3C-XDM-3.0" xreflabel="W3C XDM 3.0">Norman Walsh et al, eds. 
            XQuery and XPath Data Model 3.0. W3C Working Draft 14 June 2011.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1314" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel-30/</div>.
         </div>
         <div class="bibliomixed e1315" xml:id="W3C-XML" xreflabel="W3C XML">Tim Bray et al, eds. 
            Extensible Markup Language (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November
            2008.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1316" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/REC-xml/</div>.
         </div>
         <div class="bibliomixed e1317" xml:id="W3C-XSLT-3.0" xreflabel="W3C XSLT 3.0">Michael Kay, ed. 
            XSL Transformations (XSLT) Version 3.0. W3C Working Draft 10 July 2012.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e1318" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-30/</div>.
         </div>
      </div>
   </div>
</div>