<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#IndexingQueriesinLuxANCHOR" name="IndexingQueriesinLuxTOC">Indexing Queries in Lux</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#WhyanotherXMLsearchengine?ANCHOR" name="WhyanotherXMLsearchengine?TOC">Why another XML search engine?</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#LuxArchitectureANCHOR" name="LuxArchitectureTOC">Lux Architecture</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#QueryoptimizationwithindexesANCHOR" name="QueryoptimizationwithindexesTOC">Query optimization with indexes</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FormalsettingANCHOR" name="FormalsettingTOC">Formal setting</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FilteringthecontextANCHOR" name="FilteringthecontextTOC">Filtering the context</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PathIndexesANCHOR" name="PathIndexesTOC">Path Indexes</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OtheroptimizationsANCHOR" name="OtheroptimizationsTOC">Other optimizations</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#SpecialFunctionsANCHOR" name="SpecialFunctionsTOC">Special Functions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#SortingANCHOR" name="SortingTOC">Sorting</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RangeComparisonsANCHOR" name="RangeComparisonsTOC">Range Comparisons</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#FLWORexpressionsandvariablesANCHOR" name="FLWORexpressionsandvariablesTOC">FLWOR expressions and variables</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ResultsANCHOR" name="ResultsTOC">Results</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#CorrectnessANCHOR" name="CorrectnessTOC">Correctness</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#IndexingPerformanceANCHOR" name="IndexingPerformanceTOC">Indexing Performance</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#QueryPerformanceANCHOR" name="QueryPerformanceTOC">Query Performance</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NoteonbenchmarkingANCHOR" name="NoteonbenchmarkingTOC">Note on benchmarking</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">a/child::b</div>
         <div class="singletermTERMS">a//b</div>
         <div class="singletermTERMS">ad hoc</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">BaseX</div>
         <div class="singletermTERMS">BaseX Indexes</div>
         <div class="singletermTERMS">baseline</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">collection()</div>
         <div class="singletermTERMS">collection()//chapter[.//videoobject]/title</div>
         <div class="singletermTERMS">count()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">DB2</div>
         <div class="singletermTERMS">difference</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">exists()</div>
         <div class="singletermTERMS">empty()</div>
         <div class="singletermTERMS">Exploring the Unknown</div>
         <div class="singletermTERMS">eXist</div>
         <div class="singletermTERMS">eXist indexing documentation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">f(s1,s2,s3,...) === (f(s1), f(s2), f(s3), ...)</div>
         <div class="singletermTERMS">f(S) === f(sâˆˆS | f(s) is not empty)</div>
         <div class="singletermTERMS">filter</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">lux:exists()</div>
         <div class="singletermTERMS">lux:key</div>
         <div class="singletermTERMS">lux:field-values</div>
         <div class="singletermTERMS">lux:key($field)</div>
         <div class="singletermTERMS">lux:search("book-id:isbn9780123456789")</div>
         <div class="singletermTERMS">Lux web site (high-level documentation)</div>
         <div class="singletermTERMS">Lux repository (source code and documentation)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">MarkLogic</div>
         <div class="singletermTERMS">MarkLogic Admin Guide</div>
         <div class="singletermTERMS">minimal</div>
         <div class="singletermTERMS">Michael</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">optimize(xquery)</div>
         <div class="singletermTERMS">Oracle</div>
         <div class="singletermTERMS">Oracle XML index documentation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">path</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">qname</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">root()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">subsequence()</div>
         <div class="singletermTERMS">subsequence($seq,$start,$length)</div>
         <div class="singletermTERMS">SQL Server</div>
         <div class="singletermTERMS">since at least 1440</div>
         <div class="singletermTERMS">SQL Server XML index documentation</div>
         <div class="singletermTERMS">Shakespeare in XML</div>
         <div class="singletermTERMS">singular</div>
         <div class="singletermTERMS">sokolov@falutin.net</div>
         <div class="singletermTERMS">Senior Architect</div>
         <div class="singletermTERMS">Sokolov</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="IndexingQueriesinLuxANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Indexing Queries in Lux</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2013</div>
            <div class="confdates e5">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">
               Query optimizers often mystify database users: sometimes queries
               run quickly and sometimes they donâ€™t. An intuitive grasp of what
               will work well in an optimizer is often gained only after trial,
               error, inductive logic (i.e. educated guessing), and sometimes
               propitiatory sacrifice. This paper tries to lift the veil by
               describing work on Lux, a new indexed XQuery search engine built
               using Saxon and Lucene, which is freely available under an
               open-source license. Lux optimizes queries by rewriting them as
               equivalent (but usually faster) indexed queries, so its results are
               easier for a user to understand than the abstract query plans
               produced by some optimizers. Lucene-based QName and path indexes
               prove useful in speeding up XQuery execution by Saxon.
               
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Michael</div>
               <div class="surname e11">Sokolov</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">
                  Michael Sokolov is a software developer and data architect.  He has
                  been creating online reference and reading platforms since 1999,
                  first at iFactory, and since 2013 as part of Safari Books Online.
                  He is fascinated by the ways humans interact with large texts via
                  computer and works on document and text processing, indexing, and
                  search. Michael was the data and search architect for the OED
                  online's relaunch in 2010, and in previous lives worked on speech
                  recognition, internationalization, object databases, and in the
                  remote past, computer vision.
                  
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Senior Architect</div>
               <div class="orgname e16">Safari Books Online</div>
            </div>
            <div class="email e17">sokolov@falutin.net</div>
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e18" xlink:actuate="onRequest" xlink:href="http://luxdb.org/" xlink:show="new" xlink:type="simple">http://luxdb.org/</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright Â© V. Michael Sokolov 2013</div>
         </div>
      </div><a name="WhyanotherXMLsearchengine?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e21">
         <div class="title e22">Why another XML search engine?</div>
         <div class="para e23">
            So first: why? There are a number of excellent XQuery databases
            available, both commercial and free ones, even open source.  Some of
            our motivation was historical; for a variety of reasons we ended up
            with a number of applications built on top of a Solr/Lucene data store.
            We keep XML in these indexes, and we can define XPath indexes, but our
            query syntax is limited to Lucene's simple query languages, which are
            not at all XML aware.  So we wanted to be able to use XQuery in an
            efficient way with these pre-existing data stores.
            
         </div>
         <div class="para e24">
            
            <div class="mediaobject e25">
               <div class="imageobject e26">
                  <div class="metaBox e27"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e43').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e43" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e27'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Sokolov01/Sokolov01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            The diagram shows the PubFactory architecture.  Interactions with the
            DB are done using its native API.  For MarkLogic and eXist, this is
            all XQuery.  Solr's APIs are a mixture of Lucene query language and a
            thin Java API that wraps a number of HTTP REST calls.  When using an
            XML-aware database, The XML Indexer component is not required.  We
            created this component to work with Solr, which provides full text
            indexes and typed indexes (for strings, numbers, dates, geolocations
            and so on).
            
         </div>
         <div class="para e28">
            This system design has a lot of nice features: it enabled us to
            accomplish most of what we needed with a leaner technology stack, and
            we gained a degree of power and flexibility by doing so, since we had
            Java programmers on staff who could fill in the missing bits.  But
            having done this we also had to grapple with some missing conveniences
            that those programmers were somewhat reliant on.
            
         </div>
         <div class="para e29">
            We knew from the beginning that we would miss the 
            <div class="emphasis e30">ad
               hoc
            </div> query capabilities that both MarkLogic, and eXist,
            which we had been using, provided.  We had come to rely on CQ and the
            eXist sandbox: what would take their place?  The Solr admin query
            interface is a truly impoverished replacement for these.  In fact it
            has recently gotten a facelift, but the query interface is
            essentially unchanged: you have no opportunity to operate on the
            results beyond selecting which fields are returned.  Worse still, all
            of our indexes would have to be computed in advance.  MarkLogic
            provides a great feature for 
            <div class="emphasis e31">ad hoc</div> querying,
            which I think they call the "universal index." This index provides
            for lookup by word (ie full text search) and value (exact match)
            constrained by the name of containing elements and attributes.
            
         </div>
         <div class="para e32">
            So Lux was really born out of this need for an 
            <div class="emphasis e33">ad
               hoc
            </div> query capability, something akin to what Micah Dubinko
            presented at Balisage last year in 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e34" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Dubinko01/BalisageVol8-Dubinko01.html" xlink:show="new" xlink:type="simple">Exploring
               the Unknown
            </div>.  Our first thought was something like this: "Hey,
            Saxon provides an XQuery capability, and Solr provides indexing and
            storage: all we need to do is marry them, and presto! We'll have an
            indexed XQuery tool." It turned out though that there was a lot more
            work required to produce a usable version of that than it appeared at
            first blush.  This is the story.
            
         </div>
      </div><a name="LuxArchitectureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e35">
         <div class="title e36">Lux Architecture</div>
         <div class="para e37">
            A quick overview of the Lux internal software design provides context
            for the XQuery indexing optimizations that are the main topic of this
            paper.
            
         </div>
         <div class="mediaobject e38">
            <div class="imageobject e39">
               <div class="metaBox e40"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e70').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e70" class="metaSource" style="display:none;">                
                     &lt;imagedata<span class="metaAttribute">class='e40'
                        </span><span class="metaAttribute">fileref='../../../vol10/graphics/Sokolov01/Sokolov01-002.png'
                        </span><span class="metaAttribute">format='png'
                        </span>
                     &gt;
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="variablelist e41">
            <div class="varlistentry e42">
               <div class="term e43">Evaluator</div>
               <div class="listitem e44">
                  <div class="para e45">the highest-level abstraction in Lux.  It contains the
                     other objects listed below (and the underlying Saxon objects) and
                     provides a central access point for all Lux functionality, but in
                     particular provides the evaluate(query) method.
                     
                  </div>
               </div>
            </div>
            <div class="varlistentry e46">
               <div class="term e47">Compiler</div>
               <div class="listitem e48">
                  <div class="para e49">compiles XQuery expressions into an executable form</div>
               </div>
            </div>
            <div class="varlistentry e50">
               <div class="term e51">SaxonTranslator</div>
               <div class="listitem e52">
                  <div class="para e53">translates expressions from Saxon's internal Expression
                     tree structure to Lux's AbstractExpression tree structure.
                  </div>
               </div>
            </div>
            <div class="varlistentry e54">
               <div class="term e55">PathOptimizer</div>
               <div class="listitem e56">
                  <div class="para e57">rewrites AbstractExpression to make use of Lux indexes</div>
               </div>
            </div>
            <div class="varlistentry e58">
               <div class="term e59">FunctionLibrary</div>
               <div class="listitem e60">
                  <div class="para e61">Provides index-aware XQuery functions</div>
               </div>
            </div>
            <div class="varlistentry e62">
               <div class="term e63">XmlIndexer</div>
               <div class="listitem e64">
                  <div class="para e65">Indexes XML documents, generating Lucene field values</div>
               </div>
            </div>
            <div class="varlistentry e66">
               <div class="term e67">Searcher</div>
               <div class="listitem e68">
                  <div class="para e69">Searches the Lucene index, returning matching documents stored there</div>
               </div>
            </div>
            <div class="varlistentry e70">
               <div class="term e71">XML Highlighter</div>
               <div class="listitem e72">
                  <div class="para e73">Highlights terms in a document matching a search query</div>
               </div>
            </div>
            <div class="varlistentry e74">
               <div class="term e75">Query Parser</div>
               <div class="listitem e76">
                  <div class="para e77">Parses queries in Lux's extended Lucene query language and its XML form</div>
               </div>
            </div>
         </div>
      </div><a name="QueryoptimizationwithindexesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e78">
         <div class="title e79">Query optimization with indexes</div>
         <div class="para e80">
            When executing queries in a setting with a large amount of data,
            indexes are critical.  A properly indexed query may execute in less
            than a millisecond while the same query, unoptimized, could easily
            take so long that it would effectively never complete.  In Lux,
            queries are implicitly executed with the entire contents of the index
            as their context: more precisely, wherever there is an absolute
            expression (a path rooted at "/"), Lux inserts, conceptually, a call
            to 
            <div class="code e81">collection()</div>, the function that returns all
            documents.  This approach has been adopted in other databases; we've
            attempted to provide a familiar environment.
            
         </div>
         <div class="para e82">
            Sometimes users exercise control over the indexes that are generated
            and how they are used to resolve queries.  XSLT's key functionality
            is an example of this.  In other cases, like SQL databases, users
            specify the indexes and hope they've chosen the right ones that will
            nudge the optimizer to speed up their queries. And sometimes indexes
            are created and used with little or no user intervention at all. This
            is an ideal situation when it works, but nearly impossible to get
            right all the time in a general case where queries are expressed in a
            complex language such as XQuery. There are two main difficulties:
            knowing which indexes might be useful enough to justify the cost of
            creating them, and then actually applying those indexes to optimize
            queries.
            
         </div>
         <div class="para e83">
            Our philosophy is to provide as much automatic help as possible, so
            the user doesn't have to think, but to get out of the way when the
            user tells us they want manual control.
            
            <div class="orderedlist e84">
               <div class="listitem e85">
                  <div class="para e86">
                     Provide basic indexes that can be applied automatically and
                     relied on to provide value for a wide range of queries.
                     
                  </div>
               </div>
               <div class="listitem e87">
                  <div class="para e88">
                     Give the user clear information about the output of the
                     optimizer. Sometimes the optimizer can be tricked by otherwise
                     insignificant syntactic constructs, like variables. If the user
                     is made aware of this, they can often rectify the situation by
                     rewriting their queries.
                     
                  </div>
               </div>
               <div class="listitem e89">
                  <div class="para e90">
                     Allow the user to specify indexes explicitly: users can be relied
                     on to know when there are especially interesting sequences to be
                     indexed.
                     
                  </div>
               </div>
               <div class="listitem e91">
                  <div class="para e92">
                     Provide users with query constructs that reference the indexes
                     directly. This way users can take over when the optimizer fails.
                     
                  </div>
               </div>
            </div>
            This paper addresses the first point primarily, exploring some
            challenges we overcame providing the built-in indexes and optimizing
            queries to use them, but it's important not to lose sight of the
            bigger picture as well.
            
         </div>
         <div class="para e93">
            It has become standard practice to index XML with the following kinds of
            indexes:
            
            <div class="itemizedlist e94">
               <div class="listitem e95">
                  <div class="para e96">QName indexes</div>
               </div>
               <div class="listitem e97">
                  <div class="para e98">Path indexes</div>
               </div>
               <div class="listitem e99">
                  <div class="para e100">Full text indexes</div>
               </div>
               <div class="listitem e101">
                  <div class="para e102">QName value and/or text indexes</div>
               </div>
               <div class="listitem e103">
                  <div class="para e104">XPath indexes</div>
               </div>
            </div>
            These kinds of indexes are provided by 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e105" xlink:actuate="onRequest" xlink:href="http://docs.marklogic.com/guide/admin/text_index#chapter" xlink:show="new" xlink:type="simple">MarkLogic</div>,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e106" xlink:actuate="onRequest" xlink:href="http://exist-db.org/exist/apps/doc/indexing.xml" xlink:show="new" xlink:type="simple">eXist</div>
            and 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e107" xlink:actuate="onRequest" xlink:href="http://docs.basex.org/wiki/Indexes#Resource_Index" xlink:show="new" xlink:type="simple">BaseX</div>,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e108" xlink:actuate="onRequest" xlink:href="http://msdn.microsoft.com/en-us/library/ms191497.aspx" xlink:show="new" xlink:type="simple">SQL
               Server
            </div> (Primary XML index covers paths and values; full text
            is available, and Secondary index provides XPath), 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e109" xlink:actuate="onRequest" xlink:href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28369/xdb_indexing.htm#CHDFCGGI" xlink:show="new" xlink:type="simple">Oracle</div>
            and 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e110" xlink:actuate="onRequest" xlink:href="http://pic.dhe.ibm.com/infocenter/dzichelp/v2r2/topic/com.ibm.db2z10.doc.xml/src/tpc/db2z_indexxml.htm" xlink:show="new" xlink:type="simple">DB2</div>,
            to name a few popular systems.  A review of the indexing capabilities
            of these and other tools is beyond the scope of this paper, but it is
            apparent that the index types described above are well-represented in
            the field.
            
         </div>
         <div class="para e111">
            Lux currently provides path, full text, element/attribute full text,
            and xpath indexes.  We've done some work on an element/attribute
            value index as well.  The optimizer generates search expressions
            using the path indexes, and in some cases, the full text indexes and
            XPath indexes.  The user can make explicit use of all the indexes for
            search, optimized counting, and sorting by calling index-aware
            functions provided in the Lux function library.
            
         </div>
         <div class="para e112">
            There are a variety of optimizations using indexes we could imagine
            applying in order to make a query go faster: Filtering the input
            collection to include only "relevant" documents is the main one, and
            it sounds simple enough, but there are a lot of specific cases to be
            considered, and there is a real danger of over-optimizing and getting
            incorrect results.  Optimizations tend to have a patchwork character,
            and in order to stay on top of things, it's important to have a
            formal framework we can use to prove to ourselves that the
            optimizations are correct; that they preserve the correct results.
            
         </div><a name="FormalsettingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e113">
            <div class="title e114">Formal setting</div>
            <div class="para e115">
               Because XQuery is a functional language, it's natural to think of
               queries as functions, and to apply the formalisms of functional
               logic. In this light, query optimizations can be described formally
               as a special kind of homomorphism 
               <div class="popupBox e116">
                  <div class="popupLabel" onmouseover="$('#d1e199').show('1000');" onmouseout="$('#d1e199').hide('1000');">[ footnote ]</div>
                  <div id="d1e199" style="display: none;">
                     <div class="footnote">
                        <div class="para e117">A homomorphism is
                           a kind of mapping that preserves structure.
                        </div>
                     </div>
                  </div>
               </div> over
               the space of all queries.  A function is generally defined as a
               mapping from one set to another: in this case from sequences of
               documents to sequences of items. So in this terminology, two
               queries are homomorphic if they represent the same mapping from
               documents to items.  We won't take this formal setup very far, but
               we note that homomorphism is preserved by composition. In other
               words if two optimizations are "correct" independently, applying
               both of them will still be "correct", in the sense of preserving
               correct results, and we can apply them in whichever order we
               choose.  This is important because it enables us to work on query
               transformations independently, without worrying that making changes
               in one place will suddenly cause problems to crop up somewhere
               completely different.
               
            </div>
            <div class="para e118">
               Defining optimization as a mapping from queries to queries has
               another nice property: it means we can fairly easily show the user
               what the optimized query is: it's just a different (hopefully
               faster) query that returns the same result.  This is different from
               the situation in some systems, where optimizations are completely
               opaque to the user, or are presented as a kind of abstract "query
               plan" that bears little or no resemblance to an actual query.  Of
               course the user needs to be able to understand the optimized XQuery
               form, but given that they wrote the original XQuery, it shouldn't
               be too much of a stretch for them.
               
            </div>
         </div><a name="FilteringthecontextANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e119">
            <div class="title e120">Filtering the context</div>
            <div class="para e121">
               It is often the case that query expressions return an empty sequence
               when evaluated in the context of a given document.  For example, the
               query 
               <div class="code e122">//chapter[.//videoobject]/title</div> returns the titles
               of all (DocBook) chapters containing references to videos.  Suppose
               our database contains 1000 books broken into a document for every
               chapter.  Only a small fraction of these may actually contain videos,
               but a naÃ¯ve unoptimized implementation might have to load every one
               of those documents into memory, parse them, evaluate the query on
               them, only to return nothing. One of the main goals of the optimizer
               is to filter the context early in the process, using indexes, so that
               all this unnecessary work can be avoided.
               
            </div>
            <div class="para e123">
               We said that we operate on the whole database by replacing "/" with
               collection().  We can think of every query to be optimized then as
               some function whose single argument is the sequence of all
               documents.  What we'd like to be able to do is to filter out all
               documents from that sequence that have no chance of contributing to
               the query results.  Intuitively we know that the result of
               
               
               <div class="popupBox e124">
                  <div class="popupLabel" onmouseover="$('#d1e215').show('1000');" onmouseout="$('#d1e215').hide('1000');">[ blockquote ]</div>
                  <div id="d1e215" style="display: none;">
                     <div class="blockquote">
                        <div class="para e125">
                           <div class="code e126">
                              collection()//chapter[.//videoobject]/title
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               
               will be the same as the result of:
               
               
               <div class="popupBox e127">
                  <div class="popupLabel" onmouseover="$('#d1e220').show('1000');" onmouseout="$('#d1e220').hide('1000');">[ blockquote ]</div>
                  <div id="d1e220" style="display: none;">
                     <div class="blockquote">
                        <div class="para e128">
                           <div class="code e129">
                              collection('chapters with videos (and titles)')//chapter[.//videoobject]/title
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               
               Some XQuery expressions, and in particular path expressions, have
               the nice property of commuting with sequences: that is, their
               result sequence will be the sequence formed by applying the
               expression to each element of the input sequence in turn.  Or, more
               concisely:
               
               
               <div class="popupBox e130">
                  <div class="popupLabel" onmouseover="$('#d1e225').show('1000');" onmouseout="$('#d1e225').hide('1000');">[ blockquote ]</div>
                  <div id="d1e225" style="display: none;">
                     <div class="blockquote">
                        <div class="para e131">
                           <div class="code e132">
                              f(s1,s2,s3,...) === (f(s1), f(s2), f(s3), ...)
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               
               Combining this with the fact that sequences don't nest, we get that
               (for these functions):
               
               
               <div class="popupBox e133">
                  <div class="popupLabel" onmouseover="$('#d1e230').show('1000');" onmouseout="$('#d1e230').hide('1000');">[ blockquote ]</div>
                  <div id="d1e230" style="display: none;">
                     <div class="blockquote">
                        <div class="para e134">
                           <div class="code e135">
                              f(S) === f(sâˆˆS | f(s) is not empty) 
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               
               which just basically says that we only need to run the query on
               documents that will return results - we can skip all the other ones
               since they are irrelevant.
               
               
            </div>
            <div class="para e136">
               This is very useful.  What it means is that if we can come up with
               some index query that selects only those documents that return
               results for a given XQuery, then we can use that to filter the
               documents "up front," and save a lot of processing.  Actually it's
               OK to retrieve more documents than we need, but the game is to
               retrieve as few as possible without missing any important ones.  
               
            </div>
            <div class="para e137">
               So that's goal #1 of the optimizer: for any XQuery, produce an
               index query that minimizes the number of documents required to be
               retrieved.  How do we do that?  The strategy is to devise indexes,
               and queries, that match XQuery primitives like QNames and simple
               comparisons, and then to combine those primitive queries when they
               appear as part of more complex, composite expressions, like
               sequences, boolean operators, set operators, FLWOR expressions and
               so on. In particular what the Lux optimizer does is to perform a
               depth-first walk of the syntax tree of a query, pushing, popping,
               and combining index queries on a stack as it goes.  The
               pseudo-logic of 
               <div class="code e138">optimize(xquery)</div> goes something like
               this:
               
               
               <div class="programlisting e139" xml:space="preserve">
                  if (xquery has no children)
                  push a corresponding primitive index query
                  else 
                  let current-query = match-all
                  for each child expression
                  pop the child-query
                  if (child is absolute (contains a Root sub-expression: /))
                  replace the Root with search(child-query)
                  else
                  let current query = combine (current-query, child-query)
                  push current-query
                  
               </div>
               
            </div>
         </div><a name="PathIndexesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e140">
            <div class="title e141">Path Indexes</div>
            <div class="para e142">
               Let's look more closely at optimizing queries with path expressions
               in them, since these expressions are uniquely characteristic of
               querying tree-structured data like XML.  We've implemented
               different kinds of structure-related indexes, and it's interesting
               to compare what each one buys, and what it costs.
               
            </div>
            <div class="para e143">
               The most basic approach that captures some document structure is
               just to index all the names of all the elements and attributes (the
               QNames) in each document.  If we do that, we can easily make sure
               not to go looking for videos in documents that don't have them.  
               
            </div>
            <div class="para e144">
               But the simple QName index doesn't really capture anything about
               relationships of nodes within a document.  It feels like it ought
               to be possible to search chapter titles independently from
               searching book titles or section titles, for example, even if they
               are all tagged with &lt;title&gt;, as in DocBook.  A natural thing
               to do is to index the complete path of every named node. We've done
               this by treating each path as a kind of "sentence" in which each
               node name is a single word or token. Then using phrase queries and
               similar queries based on token-proximity, we can express
               constraints like 
               <div class="code e145">a/child::b</div>, 
               <div class="code e146">a//b</div> (and
               others) much more precisely.  With the simple QName index, it isn't
               possible to write a query even for 
               <div class="code e147">//a//b</div> that won't
               match other irrelevant documents as well (such as
               
               <div class="code e148">&lt;b&gt;&lt;a/&gt;&lt;/b&gt;</div>).
               
            </div>
            <div class="para e149">
               Here's a concrete example:
               
            </div>
            <div class="mediaobject e150">
               <div class="imageobject e151">
                  <div class="metaBox e152"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e270').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e270" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e152'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Sokolov01/Sokolov01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e153">
               The figure shows a syntax tree for the example expression roughly
               as it would be expressed by the Saxon parser, in blue rectangles,
               and in orange it shows the corresponding Lucene pseudo-query that
               is generated by Lux.  Parent queries are formed by joining together
               child queries using the recursive process described above.  The
               combine() method alluded to there is somewhat complex for path
               queries.  Its job is to characterize the relationship between two
               child expressions and to generate as precisely as possible (ie
               matching as few documents as possible, without missing any) a query
               corresponding to the parent expression.  For the simple boolean
               queries that are generated when only QName indexes are in use, this
               is generally just a matter of deciding whether the children should
               be AND-ed together or OR-ed together.  The choice is typically
               dictated by the character of the parent expression: most are
               restrictive and generate AND-queries, but some, like "or", "|", and
               "union" conjoin their child expressions and generate OR-queries.
               
            </div>
            <div class="para e154">
               Joining path queries also requires computing a distance between two
               subexpressions.  The optimizer computes this distance when visiting
               path expressions (a/b) and predicates (a[b]), translating
               non-adjacent path axes like descendant, and intervening wildcard
               steps like /*/*/ into corresponding phrase distances in the Lucene
               proximity query.
               
            </div>
            <div class="para e155">
               Once the optimizer has generated a Lucene query corresponding to an
               XQuery expression, it replaces the collection() (or /) expression
               with a call to Lux's search function, passing it the generated query
               as its argument.
               
            </div>
            <div class="para e156">
               One benefit of the Lux architecture is that it optimizes
               expression trees that have already been optimized to some extent by
               Saxon.  Saxon reduces a number of equivalent expressions to a
               simpler canonical form, making it easier to perform the analysis
               needed for optimization.  There are some drawbacks to this approach
               as well: Saxon converts some expressions (like atomized sequences)
               into internal forms that have no direct correspondence with
               XQuery expressions, so some clever inferencing is required in those
               cases to create an equivalent XQuery.
               
            </div>
            <div class="para e157">
               Of course we can keep on devising more and more precise indexes.
               Consider indexing every occurrence of every path, so that we keep a
               count of each path as well: that should give us a handle on queries
               involving positional predicates like 
               <div class="code e158">//title[2]</div>.  We
               often want to know if there is a second same-named element since it
               might violate a schema that requires a singleton.  Indexing paths
               as phrases in Lucene doesn't really lend itself well to maintaining
               this kind of statistic since the tokens in that case are QNames.
               But if we index each complete path as a token (i.e. "/a/b/c" as a
               single token, rather than "a b c" as three tokens associated by
               position-proximity), then the index will maintain a term count for
               us.
               
            </div>
            <div class="para e159">
               We have made some experiments with these "path occurrence" queries.
               The path queries become token queries, possibly involving
               wildcards, rather than phrase queries.  The performance of the
               resulting queries is roughly the same as the phrase-like queries
               described before.  The promise of indexing positional predicates
               proves difficult to realize, though.  In Lucene, the primary
               function of term frequency counts is to compute relevance-ranking
               scores: using them to 
               <div class="emphasis e160">filter</div> queries is much more involved,
               requiring some deeper spelunking into Lucene's internals, but this
               is a promising avenue for future work.
               
            </div>
         </div><a name="OtheroptimizationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e161">
            <div class="title e162">Other optimizations</div>
            <div class="para e163">The optimizer knows a few other tricks, beyond simply ignoring
               irrelevant documents.
               
            </div><a name="SpecialFunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e164">
               <div class="title e165">Special Functions</div>
               <div class="para e166">
                  In general, function calls are opaque to the optimizer, but it
                  does apply special optimizations for a few built-in XPath
                  functions: 
                  <div class="code e167">root()</div>, 
                  <div class="code e168">exists()</div>,
                  
                  <div class="code e169">empty()</div>, 
                  <div class="code e170">count()</div> and
                  
                  <div class="code e171">subsequence()</div>.
                  
               </div>
               <div class="para e172">
                  
                  <div class="code e173">count()</div>, 
                  <div class="code e174">exists()</div>, and
                  
                  <div class="code e175">empty()</div> can be evaluated using indexes only, without
                  loading documents, when it can be determined that their arguments
                  are faithfully modeled by an appropriate query.  When this
                  inference can be made, the speedup is are often dramatic, so we
                  go to some lengths to track a few properties that characterize
                  the precision of the Lucene query that the optimizer generates.
                  
               </div>
               <div class="para e176">
                  If we can prove that a given Lucene query retrieves *only* the
                  documents that produce XQuery results, no more and no fewer, then
                  we call the query 
                  <div class="emphasis e177">minimal</div>.  A minimal query
                  is the best we can do in terms of filtering the context set for
                  the query.  When their arguments' queries are minimal,
                  
                  <div class="code e178">exists()</div> and 
                  <div class="code e179">empty()</div> are replaced by an
                  index-aware analogue, 
                  <div class="code e180">lux:exists()</div>, which simply
                  checks whether any documents match a (Lucene) query (or its
                  negation, in the case of empty()).
                  
               </div>
               <div class="para e181">
                  Another useful property that some queries have is that they only
                  return one result per document.  We call these
                  
                  <div class="emphasis e182">singular</div>.  It's useful to track singularity
                  since a minimal, singular query can be counted efficiently, using
                  indexes only.  It's not always possible to tell whether a query's
                  result will be singular, but in some cases it is.  In particular,
                  if a query returns only documents (or root element nodes), then
                  it will be singular.  Lux recognizes that the 
                  <div class="code e183">root()</div>
                  function is singular, and counts paths ending with
                  
                  <div class="code e184">/root()</div> in an efficient manner.
                  
               </div>
               <div class="para e185">
                  The 
                  <div class="code e186">subsequence($seq,$start,$length)</div> function provides
                  a fixed window into a larger sequence.  We can rely on the XQuery
                  processor's lazy evaluation to avoid retrieving documents beyond
                  the right edge of the window.  When the windowed sequence is
                  singular, we can also avoid loading the documents to the left of
                  the window by telling the Lucene searcher to skip the number of
                  documents indicated by subsequence's second argument.  Also note
                  that Saxon does us the favor of translating numeric predicates
                  ($sequence[10]) into subsequence function calls, so the same
                  optimization applies to those.
                  
               </div>
            </div><a name="SortingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e187">
               <div class="title e188">Sorting</div>
               <div class="para e189">
                  Sorting a sequence using an XQuery "order by" clause typically
                  requires the entire sequence to be loaded into memory in order to
                  evaluate the ordering expression for use in sorting, even if only
                  a subset of the documents will eventually contribute to the
                  overall query result (they may be filtered by subsequence() for
                  example). We can do better when the ordering expression has been
                  indexed.
                  
               </div>
               <div class="para e190">
                  Lux can populate a Lucene field for any user-supplied XPath
                  expression, and exposes these fields in XQuery via the
                  
                  <div class="code e191">lux:key</div> (formerly 
                  <div class="code e192">lux:field-values</div>)
                  function.  When the optimizer finds a
                  
                  <div class="code e193">lux:key($field)</div> call used as an ordering expression,
                  the field argument is used to order the Lucene query result.  In
                  general results can be ordered much more quickly this way.  Such
                  optimizations are applicable for single-valued fields with string
                  and numeric values.  They support empty least/greatest, and can
                  handle multiple fields.
                  
               </div>
            </div><a name="RangeComparisonsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e194">
               <div class="title e195">Range Comparisons</div>
               <div class="para e196">
                  Lux optimizes range comparisons (=, !=, &lt;, &lt;=, &gt;, &gt;=, eq,
                  ne, gt, ge, le, lt) when one of the operands is a constant, and
                  the other is a call to lux:key() or can be proven to match an
                  indexed expression.  For example, if there is a string-valued
                  index called "book-id" on 
                  <div class="code e197">//book/@id</div>, the expression
                  
                  <div class="code e198">//book[@id="isbn9780123456789"]</div> would be optimized
                  into something like:
                  
                  <div class="code e199">lux:search("book-id:isbn9780123456789")</div>, and
                  evaluated using indexed lookup. There will be additional clauses
                  to the generated query, such as path constraints.  Also, equality
                  tests may be optimized using the built-in full text indexes.  In
                  the example above, a word-based query such as:
                  
                  <div class="code e200">&lt;@id:isbn9780123456789</div> would be generated, which
                  would find the given isbn, ignoring text normalizations such as
                  case, in any id attribute.  These text queries are less selective
                  than the query based on the XPath index, but can often be
                  selective enough, depending on the structure of the documents.
                  
               </div>
            </div><a name="FLWORexpressionsandvariablesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e201">
               <div class="title e202">FLWOR expressions and variables</div>
               <div class="para e203">
                  There are no special optimizations related to these constructs,
                  but they do present special problems.  Lux doesn't make any
                  attempt to apply constraints from where clauses, but since Saxon
                  converts most where clauses to predicates, this isn't a
                  significant drawback.  Variables are handled by keeping track of
                  variable bindings while the try is being optimized, and applying
                  any query constraints from a variable's bound expression to its
                  containing expression as if it were simply expanded in place.
                  
               </div>
            </div>
         </div><a name="ResultsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e204">
            <div class="title e205">Results</div><a name="CorrectnessANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e206">
               <div class="title e207">Correctness</div>
               <div class="para e208">
                  It's critical to ensure that an "optimized" query returns the same
                  results as the original, but it's not always so easy to prove that
                  a given optimization is homomorphic.  Sometimes we think we've done
                  so, but a counterexample arises. If we were better mathematicians,
                  perhaps we wouldn't need to, but as engineers, we take a pragmatic
                  approach and build lots of tests.
                  
               </div>
               <div class="para e209">
                  XQTS was a great help, in resolving query translation issues, and
                  somewhat helpful in testing the optimizer.  But it isn't targeted
                  at testing queries to be run over large numbers of documents, so
                  we created our own test suite to ensure that our optimizations do
                  in fact improve query speed. In the course of doing this, we
                  uncovered numerous bugs, even though we had a nearly 100% pass
                  rate on XQTS.  You just can't have enough unit tests.
                  
               </div>
            </div><a name="IndexingPerformanceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e210">
               <div class="title e211">Indexing Performance</div>
               <div class="para e212">
                  Of course the whole point of this exercise is to improve query
                  performance.  No paper about optimization would be complete
                  without some measurements.  And we have been able to make
                  improvements.  In some ways it's uninteresting to look at
                  specific performance comparisons with and without index
                  optimizations, since the improvement (when there is one) can
                  usually be made arbitrarily large simply by adding more documents
                  to the database.  There are a few inferences to be drawn from the
                  numbers, though.
                  
               </div>
               <div class="para e213">
                  Note on the test data: we used Jon Bosak's hamlet.xml (courtesy
                  of ibiblio.org) to generate a set of 6636 documents, one for each
                  element in the play's markup.  So there are a single PLAY
                  document, five ACT documents, and so on, in our test set.
                  
               </div>
               <div class="para e214">
                  We evaluated the cost, in bytes, of enabling various indexing
                  options.  The size of the indexes is an important consideration
                  since it has an effect on memory consumption and on the amount of
                  disk I/O the system will need to perform when updating and
                  merging.  For the Hamlet test set, the relative sizes of the
                  index fields are given in the following table, in bytes, and as a
                  percentage of the size required to store the XML documents.
                  
               </div>
               <div class="informaltable e215">
                  <div class="thead e216">
                     <div class="tr e217">
                        <div class="td e218">Index Option</div>
                        <div class="td e219">Size (in bytes)</div>
                        <div class="td e220">% of xml</div>
                     </div>
                  </div>
                  <div class="tr e221">
                     <div class="td e222">XML Storage</div>
                     <div class="td e223">1,346,560</div>
                     <div class="td e224">100%</div>
                  </div>
                  <div class="tr e225">
                     <div class="td e226">Full Text</div>
                     <div class="td e227">1,765,376</div>
                     <div class="td e228">100%</div>
                  </div>
                  <div class="tr e229">
                     <div class="td e230">Node Text</div>
                     <div class="td e231">1,770,496</div>
                     <div class="td e232">100%</div>
                  </div>
                  <div class="tr e233">
                     <div class="td e234">Paths</div>
                     <div class="td e235">122,880</div>
                     <div class="td e236">100%</div>
                  </div>
                  <div class="tr e237">
                     <div class="td e238">QNames</div>
                     <div class="td e239">88,064</div>
                     <div class="td e240">100%</div>
                  </div>
               </div>
               <div class="para e241">
                  The Full Text index includes all of the text, but no node name
                  information.  The Node Text index indexes each text token
                  together with its element (or attribute) context.  Note that the
                  sizes of the QName and Path indexes are fairly low relative to
                  the size of the documents themselves (also: the QName index isn't
                  needed if we have a Path index).  The next section shows the
                  effect of these indexes on query performance.
                  
               </div>
            </div><a name="QueryPerformanceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e242">
               <div class="title e243">Query Performance</div>
               <div class="para e244"> 
                  The table below shows the time, in milliseconds, to evaluate a
                  certain query with different indexes enabled.  The queries were
                  repeated 500 times in order to smooth out the noise in the
                  measurements.  The column labeled 
                  <div class="emphasis e245">baseline</div>
                  represents an unfiltered baseline where every query is evaluated
                  against every document.  The 
                  <div class="emphasis e246">qname</div> column
                  filtered documents using qname indexes, and the
                  
                  <div class="emphasis e247">path</div> shows results for path indexes.  The
                  
                  <div class="emphasis e248">%change</div> and 
                  <div class="emphasis e249">difference</div>
                  columns show the difference between qname and path indexing;
                  positive values indicate greater times for qname indexes.  The
                  queries have been sorted in descending order by this difference.
                  
               </div>
               <div class="informaltable e250">
                  <div class="thead e251">
                     <div class="tr e252">
                        <div class="td e253">query</div>
                        <div class="td e254">baseline</div>
                        <div class="td e255">qname</div>
                        <div class="td e256">path</div>
                        <div class="td e257">%change</div>
                        <div class="td e258">difference</div>
                     </div>
                  </div>
                  <div class="tr e259">
                     <div class="td e260">/LINE</div>
                     <div class="td e261">444</div>
                     <div class="td e262">262</div>
                     <div class="td e263">185</div>
                     <div class="td e264">29.19</div>
                     <div class="td e265">76.48</div>
                  </div>
                  <div class="tr e266">
                     <div class="td e267">//ACT/TITLE/root()//SCENE/TITLE/root()//SPEECH/TITLE/root()</div>
                     <div class="td e268">338</div>
                     <div class="td e269">31</div>
                     <div class="td e270">2</div>
                     <div class="td e271">92.01</div>
                     <div class="td e272">28.52</div>
                  </div>
                  <div class="tr e273">
                     <div class="td e274">/ACT['content'=SCENE]</div>
                     <div class="td e275">318</div>
                     <div class="td e276">32</div>
                     <div class="td e277">8</div>
                     <div class="td e278">75.12</div>
                     <div class="td e279">24.04</div>
                  </div>
                  <div class="tr e280">
                     <div class="td e281">/ACT//SCENE</div>
                     <div class="td e282">366</div>
                     <div class="td e283">40</div>
                     <div class="td e284">18</div>
                     <div class="td e285">55.62</div>
                     <div class="td e286">22.25</div>
                  </div>
                  <div class="tr e287">
                     <div class="td e288">/ACT[SCENE='content']</div>
                     <div class="td e289">372</div>
                     <div class="td e290">29</div>
                     <div class="td e291">8</div>
                     <div class="td e292">70.46</div>
                     <div class="td e293">20.43</div>
                  </div>
                  <div class="tr e294">
                     <div class="td e295">/ACT[.='content']</div>
                     <div class="td e296">360</div>
                     <div class="td e297">30</div>
                     <div class="td e298">9</div>
                     <div class="td e299">68.08</div>
                     <div class="td e300">20.42</div>
                  </div>
                  <div class="tr e301">
                     <div class="td e302">/ACT/SCENE[.='content']</div>
                     <div class="td e303">333</div>
                     <div class="td e304">29</div>
                     <div class="td e305">9</div>
                     <div class="td e306">67.47</div>
                     <div class="td e307">19.57</div>
                  </div>
                  <div class="tr e308">
                     <div class="td e309">/ACT/SCENE</div>
                     <div class="td e310">359</div>
                     <div class="td e311">35</div>
                     <div class="td e312">15</div>
                     <div class="td e313">55.61</div>
                     <div class="td e314">19.46</div>
                  </div>
                  <div class="tr e315">
                     <div class="td e316">count(//ACT/SCENE/ancestor::document-node())</div>
                     <div class="td e317">151</div>
                     <div class="td e318">20</div>
                     <div class="td e319">0</div>
                     <div class="td e320">95.59</div>
                     <div class="td e321">19.12</div>
                  </div>
                  <div class="tr e322">
                     <div class="td e323">number((/ACT/SCENE)[1])</div>
                     <div class="td e324">17</div>
                     <div class="td e325">23</div>
                     <div class="td e326">5</div>
                     <div class="td e327">74.62</div>
                     <div class="td e328">17.16</div>
                  </div>
                  <div class="tr e329">
                     <div class="td e330">/ACT/text()</div>
                     <div class="td e331">379</div>
                     <div class="td e332">18</div>
                     <div class="td e333">8</div>
                     <div class="td e334">56.25</div>
                     <div class="td e335">10.13</div>
                  </div>
                  <div class="tr e336">
                     <div class="td e337">/*[self::ACT/SCENE/self::*='content']</div>
                     <div class="td e338">366</div>
                     <div class="td e339">16</div>
                     <div class="td e340">6</div>
                     <div class="td e341">60.85</div>
                     <div class="td e342">9.74</div>
                  </div>
                  <div class="tr e343">
                     <div class="td e344">/ACT//*</div>
                     <div class="td e345">323</div>
                     <div class="td e346">20</div>
                     <div class="td e347">10</div>
                     <div class="td e348">47.62</div>
                     <div class="td e349">9.52</div>
                  </div>
                  <div class="tr e350">
                     <div class="td e351">/ACT</div>
                     <div class="td e352">342</div>
                     <div class="td e353">17</div>
                     <div class="td e354">9</div>
                     <div class="td e355">46.84</div>
                     <div class="td e356">7.96</div>
                  </div>
                  <div class="tr e357">
                     <div class="td e358">/*[self::ACT/SCENE='content']</div>
                     <div class="td e359">321</div>
                     <div class="td e360">13</div>
                     <div class="td e361">5</div>
                     <div class="td e362">60.95</div>
                     <div class="td e363">7.92</div>
                  </div>
                  <div class="tr e364">
                     <div class="td e365">//ACT|//SCENE</div>
                     <div class="td e366">497</div>
                     <div class="td e367">37</div>
                     <div class="td e368">35</div>
                     <div class="td e369">7.69</div>
                     <div class="td e370">2.85</div>
                  </div>
                  <div class="tr e371">
                     <div class="td e372">//ACT</div>
                     <div class="td e373">334</div>
                     <div class="td e374">24</div>
                     <div class="td e375">21</div>
                     <div class="td e376">11.47</div>
                     <div class="td e377">2.75</div>
                  </div>
                  <div class="tr e378">
                     <div class="td e379">//ACT[exists(SCENE)]</div>
                     <div class="td e380">334</div>
                     <div class="td e381">21</div>
                     <div class="td e382">18</div>
                     <div class="td e383">11.97</div>
                     <div class="td e384">2.51</div>
                  </div>
                  <div class="tr e385">
                     <div class="td e386">(/)[.//ACT]</div>
                     <div class="td e387">390</div>
                     <div class="td e388">35</div>
                     <div class="td e389">33</div>
                     <div class="td e390">7.07</div>
                     <div class="td e391">2.47</div>
                  </div>
                  <div class="tr e392">
                     <div class="td e393">//ACT[empty(SCENE)]</div>
                     <div class="td e394">521</div>
                     <div class="td e395">27</div>
                     <div class="td e396">24</div>
                     <div class="td e397">8.86</div>
                     <div class="td e398">2.39</div>
                  </div>
                  <div class="tr e399">
                     <div class="td e400">for $doc in //ACT order by lux:field-values('sortkey', $doc) return $doc</div>
                     <div class="td e401">385</div>
                     <div class="td e402">39</div>
                     <div class="td e403">37</div>
                     <div class="td e404">5.27</div>
                     <div class="td e405">2.06</div>
                  </div>
                  <div class="tr e406">
                     <div class="td e407">for $doc in //ACT order by $doc/lux:field-values('sortkey'),
                        $doc/lux:field-values('sk2') return $doc
                     </div>
                     <div class="td e408">525</div>
                     <div class="td e409">26</div>
                     <div class="td e410">24</div>
                     <div class="td e411">7</div>
                     <div class="td e412">1.82</div>
                  </div>
                  <div class="tr e413">
                     <div class="td e414">//ACT[.//SCENE]</div>
                     <div class="td e415">328</div>
                     <div class="td e416">37</div>
                     <div class="td e417">36</div>
                     <div class="td e418">4.17</div>
                     <div class="td e419">1.54</div>
                  </div>
                  <div class="tr e420">
                     <div class="td e421">//ACT/@*</div>
                     <div class="td e422">265</div>
                     <div class="td e423">21</div>
                     <div class="td e424">20</div>
                     <div class="td e425">6.27</div>
                     <div class="td e426">1.32</div>
                  </div>
                  <div class="tr e427">
                     <div class="td e428">subsequence (//ACT, 1, 10)</div>
                     <div class="td e429">275</div>
                     <div class="td e430">18</div>
                     <div class="td e431">17</div>
                     <div class="td e432">5.96</div>
                     <div class="td e433">1.07</div>
                  </div>
                  <div class="tr e434">
                     <div class="td e435">(//ACT)[1]</div>
                     <div class="td e436">8</div>
                     <div class="td e437">14</div>
                     <div class="td e438">13</div>
                     <div class="td e439">7.54</div>
                     <div class="td e440">1.06</div>
                  </div>
                  <div class="tr e441">
                     <div class="td e442">//ACT[not(SCENE)]</div>
                     <div class="td e443">291</div>
                     <div class="td e444">19</div>
                     <div class="td e445">18</div>
                     <div class="td e446">4.51</div>
                     <div class="td e447">0.86</div>
                  </div>
                  <div class="tr e448">
                     <div class="td e449">not(//ACT/root()//SCENE)</div>
                     <div class="td e450">169</div>
                     <div class="td e451">1</div>
                     <div class="td e452">0</div>
                     <div class="td e453">50.89</div>
                     <div class="td e454">0.51</div>
                  </div>
                  <div class="tr e455">
                     <div class="td e456">(for $doc in collection() return string ($doc/*/TITLE))[2]</div>
                     <div class="td e457">8</div>
                     <div class="td e458">10</div>
                     <div class="td e459">10</div>
                     <div class="td e460">3.9</div>
                     <div class="td e461">0.39</div>
                  </div>
                  <div class="tr e462">
                     <div class="td e463">//ACT/SCENE[1]</div>
                     <div class="td e464">416</div>
                     <div class="td e465">22</div>
                     <div class="td e466">21</div>
                     <div class="td e467">1.08</div>
                     <div class="td e468">0.24</div>
                  </div>
                  <div class="tr e469">
                     <div class="td e470">for $doc in //ACT order by $doc/lux:field-values('sortkey') return $doc</div>
                     <div class="td e471">280</div>
                     <div class="td e472">24</div>
                     <div class="td e473">24</div>
                     <div class="td e474">0.84</div>
                     <div class="td e475">0.20</div>
                  </div>
                  <div class="tr e476">
                     <div class="td e477">not(//ACT)</div>
                     <div class="td e478">16</div>
                     <div class="td e479">1</div>
                     <div class="td e480">1</div>
                     <div class="td e481">18.88</div>
                     <div class="td e482">0.19</div>
                  </div>
                  <div class="tr e483">
                     <div class="td e484">/node()</div>
                     <div class="td e485">236</div>
                     <div class="td e486">157</div>
                     <div class="td e487">157</div>
                     <div class="td e488">0.1</div>
                     <div class="td e489">0.16</div>
                  </div>
                  <div class="tr e490">
                     <div class="td e491">/*/ACT</div>
                     <div class="td e492">314</div>
                     <div class="td e493">22</div>
                     <div class="td e494">21</div>
                     <div class="td e495">0.15</div>
                     <div class="td e496">0.03</div>
                  </div>
                  <div class="tr e497">
                     <div class="td e498">(/)[.//*/@attr]</div>
                     <div class="td e499">459</div>
                     <div class="td e500">0</div>
                     <div class="td e501">0</div>
                     <div class="td e502">-180.29</div>
                     <div class="td e503">0.00</div>
                  </div>
                  <div class="tr e504">
                     <div class="td e505">//*[@attr]</div>
                     <div class="td e506">414</div>
                     <div class="td e507">0</div>
                     <div class="td e508">0</div>
                     <div class="td e509">-6.53</div>
                     <div class="td e510">0.00</div>
                  </div>
                  <div class="tr e511">
                     <div class="td e512">//*/@attr</div>
                     <div class="td e513">322</div>
                     <div class="td e514">0</div>
                     <div class="td e515">0</div>
                     <div class="td e516">53.42</div>
                     <div class="td e517">0.00</div>
                  </div>
                  <div class="tr e518">
                     <div class="td e519">//ACT/@id</div>
                     <div class="td e520">338</div>
                     <div class="td e521">0</div>
                     <div class="td e522">0</div>
                     <div class="td e523">27.49</div>
                     <div class="td e524">0.00</div>
                  </div>
                  <div class="tr e525">
                     <div class="td e526">//AND</div>
                     <div class="td e527">382</div>
                     <div class="td e528">0</div>
                     <div class="td e529">0</div>
                     <div class="td e530">-18.86</div>
                     <div class="td e531">0.00</div>
                  </div>
                  <div class="tr e532">
                     <div class="td e533">//lux:foo</div>
                     <div class="td e534">455</div>
                     <div class="td e535">0</div>
                     <div class="td e536">0</div>
                     <div class="td e537">75.42</div>
                     <div class="td e538">0.00</div>
                  </div>
                  <div class="tr e539">
                     <div class="td e540">//node()/@attr</div>
                     <div class="td e541">322</div>
                     <div class="td e542">0</div>
                     <div class="td e543">0</div>
                     <div class="td e544">32.51</div>
                     <div class="td e545">0.00</div>
                  </div>
                  <div class="tr e546">
                     <div class="td e547">/ACT[@id=123]</div>
                     <div class="td e548">435</div>
                     <div class="td e549">0</div>
                     <div class="td e550">1</div>
                     <div class="td e551">-135.83</div>
                     <div class="td e552">0.00</div>
                  </div>
                  <div class="tr e553">
                     <div class="td e554">/ACT[SCENE/@id=123]</div>
                     <div class="td e555">452</div>
                     <div class="td e556">0</div>
                     <div class="td e557">0</div>
                     <div class="td e558">-24.56</div>
                     <div class="td e559">0.00</div>
                  </div>
                  <div class="tr e560">
                     <div class="td e561">count(/)</div>
                     <div class="td e562">287</div>
                     <div class="td e563">0</div>
                     <div class="td e564">1</div>
                     <div class="td e565">-197.15</div>
                     <div class="td e566">0.00</div>
                  </div>
                  <div class="tr e567">
                     <div class="td e568">count(//ACT/ancestor::document-node())</div>
                     <div class="td e569">152</div>
                     <div class="td e570">0</div>
                     <div class="td e571">0</div>
                     <div class="td e572">66.07</div>
                     <div class="td e573">0.00</div>
                  </div>
                  <div class="tr e574">
                     <div class="td e575">count(//ACT/root())</div>
                     <div class="td e576">165</div>
                     <div class="td e577">0</div>
                     <div class="td e578">0</div>
                     <div class="td e579">-49.56</div>
                     <div class="td e580">0.00</div>
                  </div>
                  <div class="tr e581">
                     <div class="td e582">empty((/)[.//ACT and .//SCENE])</div>
                     <div class="td e583">15</div>
                     <div class="td e584">0</div>
                     <div class="td e585">0</div>
                     <div class="td e586">67.55</div>
                     <div class="td e587">0.00</div>
                  </div>
                  <div class="tr e588">
                     <div class="td e589">empty(/)</div>
                     <div class="td e590">13</div>
                     <div class="td e591">0</div>
                     <div class="td e592">0</div>
                     <div class="td e593">-176.63</div>
                     <div class="td e594">0.00</div>
                  </div>
                  <div class="tr e595">
                     <div class="td e596">empty(//ACT)</div>
                     <div class="td e597">14</div>
                     <div class="td e598">0</div>
                     <div class="td e599">0</div>
                     <div class="td e600">-377.25</div>
                     <div class="td e601">0.00</div>
                  </div>
                  <div class="tr e602">
                     <div class="td e603">empty(//ACT) and empty(//SCENE)</div>
                     <div class="td e604">14</div>
                     <div class="td e605">0</div>
                     <div class="td e606">0</div>
                     <div class="td e607">-67.5</div>
                     <div class="td e608">0.00</div>
                  </div>
                  <div class="tr e609">
                     <div class="td e610">empty(//ACT/root())</div>
                     <div class="td e611">470</div>
                     <div class="td e612">0</div>
                     <div class="td e613">0</div>
                     <div class="td e614">37.91</div>
                     <div class="td e615">0.00</div>
                  </div>
                  <div class="tr e616">
                     <div class="td e617">empty(//ACT/root()//SCENE)</div>
                     <div class="td e618">448</div>
                     <div class="td e619">0</div>
                     <div class="td e620">0</div>
                     <div class="td e621">-78.32</div>
                     <div class="td e622">0.00</div>
                  </div>
                  <div class="tr e623">
                     <div class="td e624">exists((/)[.//ACT and .//SCENE])</div>
                     <div class="td e625">10</div>
                     <div class="td e626">0</div>
                     <div class="td e627">0</div>
                     <div class="td e628">-185.37</div>
                     <div class="td e629">0.00</div>
                  </div>
                  <div class="tr e630">
                     <div class="td e631">exists(/)</div>
                     <div class="td e632">13</div>
                     <div class="td e633">0</div>
                     <div class="td e634">0</div>
                     <div class="td e635">69.54</div>
                     <div class="td e636">0.00</div>
                  </div>
                  <div class="tr e637">
                     <div class="td e638">exists(//ACT)</div>
                     <div class="td e639">10</div>
                     <div class="td e640">0</div>
                     <div class="td e641">0</div>
                     <div class="td e642">-53.78</div>
                     <div class="td e643">0.00</div>
                  </div>
                  <div class="tr e644">
                     <div class="td e645">exists(//ACT) and exists(//SCENE)</div>
                     <div class="td e646">11</div>
                     <div class="td e647">0</div>
                     <div class="td e648">0</div>
                     <div class="td e649">64.64</div>
                     <div class="td e650">0.00</div>
                  </div>
                  <div class="tr e651">
                     <div class="td e652">exists(//ACT/root())</div>
                     <div class="td e653">363</div>
                     <div class="td e654">0</div>
                     <div class="td e655">0</div>
                     <div class="td e656">0.86</div>
                     <div class="td e657">0.00</div>
                  </div>
                  <div class="tr e658">
                     <div class="td e659">exists(//ACT/root()//SCENE)</div>
                     <div class="td e660">377</div>
                     <div class="td e661">0</div>
                     <div class="td e662">0</div>
                     <div class="td e663">79.15</div>
                     <div class="td e664">0.00</div>
                  </div>
                  <div class="tr e665">
                     <div class="td e666">not((/)[.//ACT and .//SCENE])</div>
                     <div class="td e667">4</div>
                     <div class="td e668">0</div>
                     <div class="td e669">0</div>
                     <div class="td e670">4.59</div>
                     <div class="td e671">0.00</div>
                  </div>
                  <div class="tr e672">
                     <div class="td e673">not(//ACT) and empty(//SCENE)</div>
                     <div class="td e674">5</div>
                     <div class="td e675">0</div>
                     <div class="td e676">1</div>
                     <div class="td e677">-205.65</div>
                     <div class="td e678">0.00</div>
                  </div>
                  <div class="tr e679">
                     <div class="td e680">not(//ACT/root())</div>
                     <div class="td e681">352</div>
                     <div class="td e682">0</div>
                     <div class="td e683">0</div>
                     <div class="td e684">-17.33</div>
                     <div class="td e685">0.00</div>
                  </div>
                  <div class="tr e686">
                     <div class="td e687">(for $doc in collection() return data($doc//TITLE))[2]</div>
                     <div class="td e688">15</div>
                     <div class="td e689">9</div>
                     <div class="td e690">9</div>
                     <div class="td e691">-0.69</div>
                     <div class="td e692">-0.06</div>
                  </div>
                  <div class="tr e693">
                     <div class="td e694">subsequence (//ACT, 1, 1)</div>
                     <div class="td e695">13</div>
                     <div class="td e696">11</div>
                     <div class="td e697">11</div>
                     <div class="td e698">-1.52</div>
                     <div class="td e699">-0.17</div>
                  </div>
                  <div class="tr e700">
                     <div class="td e701">//ACT[exists(.//SCENE)]</div>
                     <div class="td e702">347</div>
                     <div class="td e703">34</div>
                     <div class="td e704">35</div>
                     <div class="td e705">-0.9</div>
                     <div class="td e706">-0.31</div>
                  </div>
                  <div class="tr e707">
                     <div class="td e708">not(/)</div>
                     <div class="td e709">15</div>
                     <div class="td e710">1</div>
                     <div class="td e711">2</div>
                     <div class="td e712">-35.76</div>
                     <div class="td e713">-0.36</div>
                  </div>
                  <div class="tr e714">
                     <div class="td e715">//ACT[not(empty(.//SCENE))]</div>
                     <div class="td e716">340</div>
                     <div class="td e717">23</div>
                     <div class="td e718">23</div>
                     <div class="td e719">-1.84</div>
                     <div class="td e720">-0.42</div>
                  </div>
                  <div class="tr e721">
                     <div class="td e722">//*/ACT/SCENE</div>
                     <div class="td e723">396</div>
                     <div class="td e724">35</div>
                     <div class="td e725">35</div>
                     <div class="td e726">-1.4</div>
                     <div class="td e727">-0.49</div>
                  </div>
                  <div class="tr e728">
                     <div class="td e729">(/)[.//ACT][.//SCENE]</div>
                     <div class="td e730">340</div>
                     <div class="td e731">24</div>
                     <div class="td e732">24</div>
                     <div class="td e733">-2.89</div>
                     <div class="td e734">-0.69</div>
                  </div>
                  <div class="tr e735">
                     <div class="td e736">count(//ACT/root()//SCENE)</div>
                     <div class="td e737">315</div>
                     <div class="td e738">34</div>
                     <div class="td e739">35</div>
                     <div class="td e740">-3.99</div>
                     <div class="td e741">-1.36</div>
                  </div>
                  <div class="tr e742">
                     <div class="td e743">//ACT[SCENE='content']</div>
                     <div class="td e744">324</div>
                     <div class="td e745">32</div>
                     <div class="td e746">33</div>
                     <div class="td e747">-4.3</div>
                     <div class="td e748">-1.38</div>
                  </div>
                  <div class="tr e749">
                     <div class="td e750">//SCENE[last()]</div>
                     <div class="td e751">623</div>
                     <div class="td e752">45</div>
                     <div class="td e753">46</div>
                     <div class="td e754">-3.24</div>
                     <div class="td e755">-1.46</div>
                  </div>
                  <div class="tr e756">
                     <div class="td e757">//SCENE[1]</div>
                     <div class="td e758">626</div>
                     <div class="td e759">37</div>
                     <div class="td e760">39</div>
                     <div class="td e761">-4.57</div>
                     <div class="td e762">-1.69</div>
                  </div>
                  <div class="tr e763">
                     <div class="td e764">/ancestor-or-self::node()</div>
                     <div class="td e765">285</div>
                     <div class="td e766">239</div>
                     <div class="td e767">241</div>
                     <div class="td e768">-0.77</div>
                     <div class="td e769">-1.84</div>
                  </div>
                  <div class="tr e770">
                     <div class="td e771">//ACT/TITLE | //SCENE/TITLE| //SPEECH/TITLE</div>
                     <div class="td e772">425</div>
                     <div class="td e773">55</div>
                     <div class="td e774">57</div>
                     <div class="td e775">-3.87</div>
                     <div class="td e776">-2.13</div>
                  </div>
                  <div class="tr e777">
                     <div class="td e778">/PLAY/(ACT|PERSONAE)/TITLE</div>
                     <div class="td e779">342</div>
                     <div class="td e780">19</div>
                     <div class="td e781">21</div>
                     <div class="td e782">-11.31</div>
                     <div class="td e783">-2.15</div>
                  </div>
                  <div class="tr e784">
                     <div class="td e785">/*</div>
                     <div class="td e786">288</div>
                     <div class="td e787">310</div>
                     <div class="td e788">312</div>
                     <div class="td e789">-0.73</div>
                     <div class="td e790">-2.26</div>
                  </div>
                  <div class="tr e791">
                     <div class="td e792">count(//ACT)</div>
                     <div class="td e793">222</div>
                     <div class="td e794">19</div>
                     <div class="td e795">21</div>
                     <div class="td e796">-12.14</div>
                     <div class="td e797">-2.31</div>
                  </div>
                  <div class="tr e798">
                     <div class="td e799">//SCENE[2]</div>
                     <div class="td e800">571</div>
                     <div class="td e801">57</div>
                     <div class="td e802">60</div>
                     <div class="td e803">-4.65</div>
                     <div class="td e804">-2.65</div>
                  </div>
                  <div class="tr e805">
                     <div class="td e806">//ACT[count(SCENE) = 0]</div>
                     <div class="td e807">253</div>
                     <div class="td e808">18</div>
                     <div class="td e809">21</div>
                     <div class="td e810">-17.2</div>
                     <div class="td e811">-3.10</div>
                  </div>
                  <div class="tr e812">
                     <div class="td e813">/descendant-or-self::SCENE[1]</div>
                     <div class="td e814">452</div>
                     <div class="td e815">26</div>
                     <div class="td e816">30</div>
                     <div class="td e817">-13.43</div>
                     <div class="td e818">-3.49</div>
                  </div>
                  <div class="tr e819">
                     <div class="td e820">//ACT[.='content']</div>
                     <div class="td e821">368</div>
                     <div class="td e822">27</div>
                     <div class="td e823">31</div>
                     <div class="td e824">-13.13</div>
                     <div class="td e825">-3.55</div>
                  </div>
                  <div class="tr e826">
                     <div class="td e827">/self::node()</div>
                     <div class="td e828">292</div>
                     <div class="td e829">309</div>
                     <div class="td e830">314</div>
                     <div class="td e831">-1.58</div>
                     <div class="td e832">-4.88</div>
                  </div>
                  <div class="tr e833">
                     <div class="td e834">number((/descendant-or-self::ACT)[1])</div>
                     <div class="td e835">364</div>
                     <div class="td e836">19</div>
                     <div class="td e837">25</div>
                     <div class="td e838">-30.09</div>
                     <div class="td e839">-5.72</div>
                  </div>
                  <div class="tr e840">
                     <div class="td e841">/</div>
                     <div class="td e842">312</div>
                     <div class="td e843">347</div>
                     <div class="td e844">362</div>
                     <div class="td e845">-4.45</div>
                     <div class="td e846">-15.44</div>
                  </div>
                  <div class="tr e847">
                     <div class="td e848"></div>
                     <div class="td e849">288.23</div>
                     <div class="td e850">34.52</div>
                     <div class="td e851">31.15</div>
                     <div class="td e852">9.76</div>
                     <div class="td e853"></div>
                  </div>
               </div>
               <div class="para e854">
                  It is clear that the path index is providing some benefit when
                  the queries contain paths with multiple named steps.  In other
                  cases there is sometimes some increase in query time - it's not
                  entirely clear why, but the absolute value of this increase tends
                  to be small.  It may be that there is some further improvement
                  possible by avoiding the use of positional queries when there are
                  not any useful path constraints in the query.
                  
               </div>
            </div><a name="NoteonbenchmarkingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e855">
               <div class="title e856">Note on benchmarking</div>
               <div class="para e857">
                  Some reviewers expressed the desire for comparative performance
                  benchmarks with other database systems.  We've known 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e858" xlink:actuate="onRequest" xlink:href="http://www.phrases.org.uk/meanings/Comparisons%20are%20odious.html" xlink:show="new" xlink:type="simple">since
                     at least 1440
                  </div> that "comparisons are odious," or, according
                  to Dogberry, in a later gloss, "odorous."  One would like the
                  data, but we don't feel well-placed to provide an objective
                  benchmark comparing our system against others.  The best I can
                  offer is that we observe comparable performance with other
                  indexed XQuery systems, and simply note that the key factor for
                  performance is to extend the cases where indexes can be applied.
                  
               </div>
            </div>
         </div>
      </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e859">
         <div class="title e860">Conclusions</div>
         <div class="para e861">
            We described an XML search engine, Lux, based on Saxon and Lucene.
            We gave an overview of how it optimizes queries, and we explored its
            Path indexes in more depth.  Measurements show a substantial benefit
            from using these indexes. For many queries the Path index can provide
            additional benefit beyond what the QName index does, with a small
            additional cost in terms of index size.  We also described some other
            index-based optimizations that Lux applies.
            
         </div>
         <div class="para e862">
            The indexing techniques described here are not unique to
            Lux. Although we're not aware of any existing use of proximity
            queries to match path constraints, it's a natural enough idea and is
            almost certainly in use in other systems as well. The main innovation
            here is the application of XML-unaware indexing technology to
            accelerate XML-aware queries, and the new combination of existing
            open source software packages to provide a reliable and powerful
            indexing and query system.  Leveraging existing technology decreases
            the amount of code that needs to be maintained and tested, and leads
            to a high quality product with less effort than might otherwise be
            required.
            
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e863">
         <div class="title e864">Bibliography</div>
         <div class="bibliomixed e865">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e866" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol8/html/Dubinko01/BalisageVol8-Dubinko01.html" xlink:show="new" xlink:type="simple">Exploring
               the Unknown
            </div>, Micah Dubinko, 2012 Balisage conference proceedings, doi:
            <div class="biblioid doi e867">10.4242/BalisageVol8.Dubinko01</div>.
            
         </div>
         <div class="bibliomixed e868">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e869" xlink:actuate="onRequest" xlink:href="http://docs.marklogic.com/guide/admin/text_index#chapter" xlink:show="new" xlink:type="simple">MarkLogic Admin Guide</div>
            
         </div>
         <div class="bibliomixed e870">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e871" xlink:actuate="onRequest" xlink:href="http://exist-db.org/exist/apps/doc/indexing.xml" xlink:show="new" xlink:type="simple">eXist indexing documentation</div>
            
         </div>
         <div class="bibliomixed e872">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e873" xlink:actuate="onRequest" xlink:href="http://docs.basex.org/wiki/Indexes#Resource_Index" xlink:show="new" xlink:type="simple">BaseX Indexes</div>
            
         </div>
         <div class="bibliomixed e874">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e875" xlink:actuate="onRequest" xlink:href="http://msdn.microsoft.com/en-us/library/ms191497.aspx" xlink:show="new" xlink:type="simple">SQL
               Server XML index documentation
            </div>
            
         </div>
         <div class="bibliomixed e876">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e877" xlink:actuate="onRequest" xlink:href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28369/xdb_indexing.htm#CHDFCGGI" xlink:show="new" xlink:type="simple">Oracle XML index documentation</div>
            
         </div>
         <div class="bibliomixed e878">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e879" xlink:actuate="onRequest" xlink:href="http://www.ibiblio.org/xml/examples/shakespeare/" xlink:show="new" xlink:type="simple">Shakespeare in XML</div>
            
         </div>
         <div class="bibliomixed e880">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e881" xlink:actuate="onRequest" xlink:href="http://luxdb.org/" xlink:show="new" xlink:type="simple">Lux web site (high-level
               documentation)
            </div>
            
         </div>
         <div class="bibliomixed e882">
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e883" xlink:actuate="onRequest" xlink:href="http://github.com/msokolov/lux/" xlink:show="new" xlink:type="simple">Lux repository (source code and documentation)</div>
            
         </div>
      </div>
   </div>
</div>