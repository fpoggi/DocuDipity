<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#AnalysingXSLTStreamabilityANCHOR" name="AnalysingXSLTStreamabilityTOC">Analysing XSLT Streamability</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MajorpointsANCHOR" name="MajorpointsTOC">Major points</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreaminginXSLT30ANCHOR" name="StreaminginXSLT30TOC">Streaming in XSLT3.0</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StreamabilityrulesANCHOR" name="StreamabilityrulesTOC">Streamability rules</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AQuickTourANCHOR" name="AQuickTourTOC">A Quick Tour</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BasicDesignANCHOR" name="BasicDesignTOC">Basic Design</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeterminingstreamingpropertiesANCHOR" name="DeterminingstreamingpropertiesTOC">Determining streaming properties</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DisplayingtheresultsANCHOR" name="DisplayingtheresultsTOC">Displaying the results</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeliveringtheserviceANCHOR" name="DeliveringtheserviceTOC">Delivering the service</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#LimitationsandassumptionsANCHOR" name="LimitationsandassumptionsTOC">Limitations and assumptions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExpandingXPathExpressionsANCHOR" name="ExpandingXPathExpressionsTOC">Expanding XPath Expressions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InclusionsANCHOR" name="InclusionsTOC">Inclusions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ApplyingStreamabilityRulesANCHOR" name="ApplyingStreamabilityRulesTOC">Applying Streamability Rules</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PreprocessingandrewritingANCHOR" name="PreprocessingandrewritingTOC">Preprocessing and rewriting</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeclarativetablesANCHOR" name="DeclarativetablesTOC">Declarative tables</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TypemodelANCHOR" name="TypemodelTOC">Type model</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ContextfocusandtypeANCHOR" name="ContextfocusandtypeTOC">Context focus and type</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ResourcereferencesANCHOR" name="ResourcereferencesTOC">Resource references</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#VariablesANCHOR" name="VariablesTOC">Variables</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#FunctionsANCHOR" name="FunctionsTOC">Functions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AppliedtemplatesANCHOR" name="AppliedtemplatesTOC">Applied templates</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AssessingsweepandpostureANCHOR" name="AssessingsweepandpostureTOC">Assessing sweep and posture</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#UsageANCHOR" name="UsageTOC">Usage</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#GeneralStreamabilityRulesANCHOR" name="GeneralStreamabilityRulesTOC">General Streamability Rules</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#EvaluatingexpressionsandinstructionsANCHOR" name="EvaluatingexpressionsandinstructionsTOC">Evaluating expressions and instructions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#EvaluatingbuiltinfunctionsANCHOR" name="EvaluatingbuiltinfunctionsTOC">Evaluating built-in functions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DeterminingANCHOR" name="DeterminingTOC">Determining </a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#InteractiveDisplayANCHOR" name="InteractiveDisplayTOC">Interactive Display</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SerialisingtoHTMLANCHOR" name="SerialisingtoHTMLTOC">Serialising to HTML</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InteractivityANCHOR" name="InteractivityTOC">Interactivity</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Doingwhatthecompiler(usually)doesn'tANCHOR" name="Doingwhatthecompiler(usually)doesn'tTOC">Doing what the compiler (usually) doesn't</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ControllingthevolumeofdisplayeddataANCHOR" name="ControllingthevolumeofdisplayeddataTOC">Controlling the volume of displayed data</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Who&amp;howbesttoprocessXSLT?ANCHOR" name="Who&amp;howbesttoprocessXSLT?TOC">Who &amp; how best to process XSLT?</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AsyntacticallycoherentspecificationANCHOR" name="AsyntacticallycoherentspecificationTOC">A syntactically coherent specification</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ProblemsANCHOR" name="ProblemsTOC">Problems</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AcknowledgementsANCHOR" name="AcknowledgementsTOC">Acknowledgements</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Quovadis?ANCHOR" name="Quovadis?TOC">Quo vadis?</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">AxisStep</div>
         <div class="singletermTERMS">AndExpr</div>
         <div class="singletermTERMS">ancestor::*</div>
         <div class="singletermTERMS">attribute()?</div>
         <div class="singletermTERMS">attribute()</div>
         <div class="singletermTERMS">addUsage</div>
         <div class="singletermTERMS">addPosture</div>
         <div class="singletermTERMS">a[@href]</div>
         <div class="singletermTERMS">attribute value templates</div>
         <div class="singletermTERMS">Absorption</div>
         <div class="singletermTERMS">absorption</div>
         <div class="singletermTERMS">active</div>
         <div class="singletermTERMS">all</div>
         <div class="singletermTERMS">August 5 - 8, 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">body</div>
         <div class="singletermTERMS">back-up</div>
         <div class="singletermTERMS">before</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2014</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">choice-group</div>
         <div class="singletermTERMS">ContextItemExpr</div>
         <div class="singletermTERMS">class="streamProperty posture"</div>
         <div class="singletermTERMS">copy()</div>
         <div class="singletermTERMS">Classifying Expressions</div>
         <div class="singletermTERMS">Classifying Calls to Built-In Functions</div>
         <div class="singletermTERMS">Consuming</div>
         <div class="singletermTERMS">Crawling</div>
         <div class="singletermTERMS">Climbing</div>
         <div class="singletermTERMS">choice group</div>
         <div class="singletermTERMS">control focus</div>
         <div class="singletermTERMS">context item type</div>
         <div class="singletermTERMS">childless-node</div>
         <div class="singletermTERMS">can</div>
         <div class="singletermTERMS">context posture</div>
         <div class="singletermTERMS">construct</div>
         <div class="singletermTERMS">collapse</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">doc</div>
         <div class="singletermTERMS">display:none</div>
         <div class="singletermTERMS">display:inline</div>
         <div class="singletermTERMS">document-node()</div>
         <div class="singletermTERMS">display</div>
         <div class="singletermTERMS">div</div>
         <div class="singletermTERMS">Determining the Static Type of a Construct</div>
         <div class="singletermTERMS">display this line?, wrap onto a new line?</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">else</div>
         <div class="singletermTERMS">element()</div>
         <div class="singletermTERMS">element(amount)*</div>
         <div class="singletermTERMS">expr-init</div>
         <div class="singletermTERMS">Expression.explain()</div>
         <div class="singletermTERMS">expert system</div>
         <div class="singletermTERMS">every</div>
         <div class="singletermTERMS">expand</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">false()</div>
         <div class="singletermTERMS">function()</div>
         <div class="singletermTERMS">FunctionCall name="position"</div>
         <div class="singletermTERMS">for $v in ...</div>
         <div class="singletermTERMS">following-sibling::*/descendant-or-self::*</div>
         <div class="singletermTERMS">fold()</div>
         <div class="singletermTERMS">function-catalog.xml</div>
         <div class="singletermTERMS">ForExpr</div>
         <div class="singletermTERMS">fn:fold-left(N,A,I)</div>
         <div class="singletermTERMS">flat</div>
         <div class="singletermTERMS">formulae</div>
         <div class="singletermTERMS">Free-ranging</div>
         <div class="singletermTERMS">focus changing</div>
         <div class="singletermTERMS">focus-controlling</div>
         <div class="singletermTERMS">focus-controlled</div>
         <div class="singletermTERMS">function / named template</div>
         <div class="singletermTERMS">free-ranging</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">grounded</div>
         <div class="singletermTERMS">generalOperand</div>
         <div class="singletermTERMS">GS-find-operands</div>
         <div class="singletermTERMS">GSR</div>
         <div class="singletermTERMS">General Streamability Rules</div>
         <div class="singletermTERMS">guaranteed streamable</div>
         <div class="singletermTERMS">Grounded</div>
         <div class="singletermTERMS">General Streamability Rules</div>
         <div class="singletermTERMS">guaranteed streamabilty</div>
         <div class="singletermTERMS">grounded</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">href="example{position()}.xml"</div>
         <div class="singletermTERMS">head()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">IfExpr</div>
         <div class="singletermTERMS">if</div>
         <div class="singletermTERMS">item()*</div>
         <div class="singletermTERMS">item()?</div>
         <div class="singletermTERMS">id</div>
         <div class="singletermTERMS">item()</div>
         <div class="singletermTERMS">ixsl:page()//pre//span[@type=$type]</div>
         <div class="singletermTERMS">ixsl:set-attribute</div>
         <div class="singletermTERMS">inspection</div>
         <div class="singletermTERMS">iterating</div>
         <div class="singletermTERMS">it</div>
         <div class="singletermTERMS">its</div>
         <div class="singletermTERMS">Inspection</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">john@jwlresearch.com</div>
         <div class="singletermTERMS">John</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">key()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">let $v :=..</div>
         <div class="singletermTERMS">last()</div>
         <div class="singletermTERMS">Lumley</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">map()</div>
         <div class="singletermTERMS">mode-set</div>
         <div class="singletermTERMS">map()*</div>
         <div class="singletermTERMS">mostly</div>
         <div class="singletermTERMS">Motionless</div>
         <div class="singletermTERMS">motionless</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">name()</div>
         <div class="singletermTERMS">name(.)</div>
         <div class="singletermTERMS">none</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">Navigation</div>
         <div class="singletermTERMS">navigation</div>
         <div class="singletermTERMS">no PHP or Java required</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">operand</div>
         <div class="singletermTERMS">off-tree</div>
         <div class="singletermTERMS">one</div>
         <div class="singletermTERMS">operands</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">pre</div>
         <div class="singletermTERMS">PostfixExpr A[B]</div>
         <div class="singletermTERMS">p:grounded</div>
         <div class="singletermTERMS">pages</div>
         <div class="singletermTERMS">posture</div>
         <div class="singletermTERMS">posture/sweep</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">QuantifiedExpr</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">returnType</div>
         <div class="singletermTERMS">roaming</div>
         <div class="singletermTERMS">role</div>
         <div class="singletermTERMS">reverse-cascades</div>
         <div class="singletermTERMS">REx Parser Generator</div>
         <div class="singletermTERMS">Roaming</div>
         <div class="singletermTERMS">roaming</div>
         <div class="singletermTERMS">role</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">s:sequence-constructor</div>
         <div class="singletermTERMS">s:focus="change|controlling|controlled"</div>
         <div class="singletermTERMS">StringLiteral value="foo"</div>
         <div class="singletermTERMS">subsequence()</div>
         <div class="singletermTERMS">s:posture="striding"</div>
         <div class="singletermTERMS">select</div>
         <div class="singletermTERMS">separator</div>
         <div class="singletermTERMS">span</div>
         <div class="singletermTERMS">s:posture="grounded"</div>
         <div class="singletermTERMS">span class="XMLBody|XSLBody"</div>
         <div class="singletermTERMS">style="display:none"</div>
         <div class="singletermTERMS">Streaming</div>
         <div class="singletermTERMS">Streamability</div>
         <div class="singletermTERMS">Saxonica Community: Streaming Analysis</div>
         <div class="singletermTERMS">streaming</div>
         <div class="singletermTERMS">stream</div>
         <div class="singletermTERMS">Streaming in the Saxon XSLT Processor</div>
         <div class="singletermTERMS">store</div>
         <div class="singletermTERMS">sweep</div>
         <div class="singletermTERMS">Striding</div>
         <div class="singletermTERMS">static type</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">treat as</div>
         <div class="singletermTERMS">then</div>
         <div class="singletermTERMS">transmission</div>
         <div class="singletermTERMS">top-level</div>
         <div class="singletermTERMS">top-down</div>
         <div class="singletermTERMS">type-dependent usage</div>
         <div class="singletermTERMS">transmission</div>
         <div class="singletermTERMS">template</div>
         <div class="singletermTERMS">text-value-templates</div>
         <div class="singletermTERMS">Transmission</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">U{xs:string, xs:decimal, xs:date}</div>
         <div class="singletermTERMS">usage</div>
         <div class="singletermTERMS">undone</div>
         <div class="singletermTERMS">usage-dependent type</div>
         <div class="singletermTERMS">usage</div>
         <div class="singletermTERMS">U-type</div>
         <div class="singletermTERMS">U{N}</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">VarRef</div>
         <div class="singletermTERMS">very large</div>
         <div class="singletermTERMS">very</div>
         <div class="singletermTERMS">variable / param</div>
         <div class="singletermTERMS">value</div>
         <div class="singletermTERMS">viz.</div>
         <div class="singletermTERMS">very large</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:stream</div>
         <div class="singletermTERMS">xsl:template</div>
         <div class="singletermTERMS">xsl:function</div>
         <div class="singletermTERMS">xsl:mode name=".." streamable="yes"</div>
         <div class="singletermTERMS">xsl:sequence</div>
         <div class="singletermTERMS">xsl:for-each select="book"</div>
         <div class="singletermTERMS">xsl:sort</div>
         <div class="singletermTERMS">xp:</div>
         <div class="singletermTERMS">xsl:result-document</div>
         <div class="singletermTERMS">xp:FunctionCall[@name='position']</div>
         <div class="singletermTERMS">xsl:include href="more.xsl"</div>
         <div class="singletermTERMS">xpath3.0-parse.xslt</div>
         <div class="singletermTERMS">xp:parse.xpath()</div>
         <div class="singletermTERMS">xp:is.AVT()</div>
         <div class="singletermTERMS">xsl:apply-templates[empty(@select)]</div>
         <div class="singletermTERMS">xsl:next-match</div>
         <div class="singletermTERMS">xp:is.sequence-constructor()</div>
         <div class="singletermTERMS">xsl:param</div>
         <div class="singletermTERMS">xsl:include</div>
         <div class="singletermTERMS">xsl:import</div>
         <div class="singletermTERMS">xp:least-common-supertypes($type0)($type1)</div>
         <div class="singletermTERMS">xs:string</div>
         <div class="singletermTERMS">xs:untypedAtomic</div>
         <div class="singletermTERMS">xs:string*</div>
         <div class="singletermTERMS">xp:union-type($types as xs:string*)</div>
         <div class="singletermTERMS">xsl:for-each</div>
         <div class="singletermTERMS">xsl:for-each select="amount"</div>
         <div class="singletermTERMS">xs:integer</div>
         <div class="singletermTERMS">xs:boolean</div>
         <div class="singletermTERMS">xsl:variable</div>
         <div class="singletermTERMS">xsl:iterate</div>
         <div class="singletermTERMS">xsl:apply-templates</div>
         <div class="singletermTERMS">xsl:*</div>
         <div class="singletermTERMS">xp:*</div>
         <div class="singletermTERMS">xsl:value-of</div>
         <div class="singletermTERMS">xsl:choose</div>
         <div class="singletermTERMS">xsl:copy</div>
         <div class="singletermTERMS">xslstreamyes</div>
         <div class="singletermTERMS">xslstreamno</div>
         <div class="singletermTERMS">XPExpr</div>
         <div class="singletermTERMS">XPath 3.0 Grammar</div>
         <div class="singletermTERMS">XPath and XQuery Functions and Operators 3.0</div>
         <div class="singletermTERMS">XSLT 3.0 Streaming for the masses</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="AnalysingXSLTStreamabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Analysing XSLT Streamability</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2014</div>
            <div class="confdates e5">August 5 - 8, 2014</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Determining streamability of constructs in XSLT3.0 involves application of a set of
               rules that appear to be complex. A tool that analyses these rules on a given stylesheet
               has
               been developed to help developers understand why sections which were designed with
               streaming
               might fail the required conditions. This paper discusses the structure of this analysis
               tool. The development was funded by Saxonica. 
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">John</div>
               <div class="surname e11">Lumley</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">A Cambridge engineer by background, John Lumley created the AI group at Cambridge
                  Consultants in the early 1980s and then joined HPLabs Bristol as one of its founding
                  members. He worked there for 25 years, managing and contributing in a variety of
                  software/systems fields, latterly specialising in XSLT-based document engineering,
                  in
                  which he subsequently gained a PhD. He is currently helping develop the Saxon XSLT
                  processor for Saxonica.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="orgname e15">jωL Research</div>
            </div>
            <div class="affiliation e16">
               <div class="orgname e17">Saxonica</div>
            </div>
            <div class="email e18">john@jwlresearch.com</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright © 2014 jωL Research Ltd. All rights reserved.</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e21">
         <div class="title e22">Introduction</div>
         <div class="para e23">XSLT has gradually developed over the past decade from a 'browser-based' document
            transformer/generator into a fully-fledged, industrial scale, functional processing
            tool,
            aimed at XML documents. As such its 3.0 version has introduced support for
            
            <div class="quote e24">streaming</div> processing of very large documents. To do this effectively, the
            XSLT specification has had to outline a very extensive, very detailed, and ostensibly
            very
            complex, set of rules defining the conditions under which a given program can be guaranteed
            to
            be processable in a streaming manner.
         </div>
         <div class="para e25">This paper describes an interactive static analysis and display tool that can be used
            to
            examine the evaluation of these rules on (fragments of) a given XSLT stylesheet, so
            developers
            of processes intended for streaming may understand better whether their programs can
            indeed be
            processed in a streaming fashion, and if not, perhaps why not. This tool also includes
            active
            linking to appropriate sections of the specification to further increase comprehension.
            
         </div>
         <div class="para e26">As the tool was being developed while these rules were being developed, proven and
            changed
            by the XSLT Working Group, it was important that the tool itself could be flexible
            to changes
            in these rules. [See 
            <div class="xref e27" linkend="type.model"></div> for a very good case of this happening.]
            Accordingly, the tool makes significant use of declarative descriptions of sections
            of the
            rules rather than direct code, some defined directly within the tool, some as external
            data
            files and some extracted from the specification itself, or other parts of the specification
            definitional framework. 
         </div>
         <div class="para e28">This paper is organised as follows: </div>
         <div class="itemizedlist e29">
            <div class="listitem e30">
               <div class="para e31">The model for streaming in XSLT 3.0 is presented and the specification-defined rules
                  are discussed briefly.
               </div>
            </div>
            <div class="listitem e32">
               <div class="para e33">The tool is illustrated in action on a simple example taken from the XSLT
                  specification.
               </div>
            </div>
            <div class="listitem e34">
               <div class="para e35">The basic overall design is discussed: analysing the streaming properties, displaying
                  the results and delivering the tool as a web service.
               </div>
            </div>
            <div class="listitem e36">
               <div class="para e37">XPath expressions embedded in XSLT programs need to be expanded into their parse trees
                  for analysis – the model for doing this is detailed. 
               </div>
            </div>
            <div class="listitem e38">
               <div class="para e39">The model for evaluating the streamability rules is discussed in some detail, with
                  all
                  the streaming properties being attached to the stylesheet tree as attributive
                  properties.
               </div>
            </div>
            <div class="listitem e40">
               <div class="para e41">Interactive display of the results involves serialisation of the annotated result
                  tree
                  as an HTML page, with styling through CSS and interaction through a Saxon-CE supported
                  XSLT2.0 stylesheet. 
               </div>
            </div>
            <div class="listitem e42">
               <div class="para e43">A final conclusion presents lessons for the development of this type of analysis tool
                  within the XML world.
               </div>
            </div>
         </div>
         <div class="para e44">The entirety of the tool is written in XSLT3.0 and of course is about manipulating
            XSLT3.0. Thus a reasonable knowledge of XSLT3.0 (or at least 2.0) is assumed on the
            part of
            the reader.
         </div>
         <div class="note e45">
            <div class="para e46">This paper discusses interpreting the rules for guaranteed streamability within XSLT,
               but through the imperfect eyes of the author and the potentially fallible medium of
               a
               program that ostensibly follows those rules. In particular the samples and examples
               in the
               paper date mainly from the Working Draft specification of December 2013 and several
               changes
               have occurred since, especially in a new static type model. 
               <div class="emphasis e47">The definitive guide
                  is the specification itself, which is, and always will be, the ultimate
                  arbiter
               </div>. The author assumes no responsibility for errors (positive or negative),
               omissions and shortcomings. If in doubt read the 20,000 words yourself!
            </div>
         </div><a name="MajorpointsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e48">
            <div class="title e49">Major points</div>
            <div class="para e50">The development of this tool is based on three major points, which can be relevant
               to
               any similar system that needs to analyse properties of an XSLT program:
            </div>
            <div class="itemizedlist e51">
               <div class="listitem e52">
                  <div class="para e53">The entire coding can be, and perhaps is best, written in XSLT3.0</div>
               </div>
               <div class="listitem e54">
                  <div class="para e55">The best data structure to hold a lot of varied information about an XSLT program
                     is
                     the tree that defines the program itself.
                  </div>
               </div>
               <div class="listitem e56">
                  <div class="para e57">Declarative structures (tables, trees, even parts of the specification) can be used
                     effectively to either i) be interpreted to evaluate effect, or even ii) compiled to
                     program sections, or an intermediate computational form such as maps.
                  </div>
               </div>
            </div>
         </div>
      </div><a name="StreaminginXSLT30ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e58">
         <div class="title e59">Streaming in XSLT3.0</div>
         <div class="para e60">One of the design goals in updating XSLT from version 2.0 to version 3.0 was support
            for
            processing 
            <div class="quote e61">very large</div> documents – XML documents whose complete tree
            descriptions could not fit in memory, and for which processing or generation of output
            would
            have to proceed before all input had been read. The full details of the design chosen
            can be
            found in the 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e62" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streaming" xlink:show="new" xlink:type="simple">Streaming</div> and
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e63" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability" xlink:show="new" xlink:type="simple">Streamability</div> sections
            of the XSLT3.0 specification. Two papers on streaming presented at XML Prague 2014
            (
            <div class="xref e64" linkend="Braaksma1"></div>, 
            <div class="xref e65" linkend="Kay"></div>) give much more detail.
         </div>
         <div class="para e66">The basic approach chosen is to declare that a given document should be processed
            in a
            streaming manner by using the 
            <div class="code e67">&lt;xsl:stream
               href="
            </div>
            <div class="emphasis e68">
               <div class="code e69">doc</div>
            </div>
            <div class="code e70">"&gt;</div> instruction which
            processes the (XML) data of the given document according to the instructions supplied
            as
            children of the 
            <div class="code e71">xsl:stream</div> and returns the result. The essential issue is whether
            the instructions requested as a set can process the document without having to either
            i)
            collect and 
            <div class="emphasis e72">store</div> the whole document to produce the result or ii)
            
            <div class="emphasis e73">back-up</div> to parts of the document 
            <div class="emphasis e74">before</div> the
            current context node. 
         </div>
         <div class="para e75">The model used is to examine two contextual properties of the instructions:
            
            <div class="emphasis e76">posture</div> and 
            <div class="emphasis e77">sweep</div>, and determine whether the
            sequence constructor (the sequence of contained instructions) of the 
            <div class="code e78">xsl:stream</div>
            has a 
            <div class="code e79">grounded</div> posture. If so then the processing of the 
            <div class="code e80">xsl:stream</div>
            is 
            <div class="emphasis e81">guaranteed streamable</div> and a compliant streaming XSLT3.0 processor will
            process the document in a streaming manner. Such analysis is completely static and
            can be
            performed either at compile time (which is what a compiler will need to do) or in
            a separate
            phase of static analysis and display, which this paper is about.
         </div>
         <div class="para e82">Partially quoting 
            <div class="xref e83" linkend="Kay"></div>, these two properties are functions of the
            construct itself (an XSL instruction, an XPath expression term or a function call),
            the
            context posture (i.e. the posture generally of the 'parent') and sometimes the data
            type. They
            have the following meanings: 
         </div>
         <div class="popupBox e84">
            <div class="popupLabel" onmouseover="$('#d1e160').show('1000');" onmouseout="$('#d1e160').hide('1000');">[ blockquote ]</div>
            <div id="d1e160" style="display: none;">
               <div class="blockquote">
                  <div class="title e85">The sweep of a construct</div>
                  <div class="para e86">The 
                     <div class="emphasis e87">sweep</div> indicates how much of the input document is needed to
                     evaluate the construct. The values are
                  </div>
                  <div class="itemizedlist e88">
                     <div class="listitem e89">
                        <div class="para e90">
                           <div class="emphasis e91">Motionless</div>: the construct either doesn’t look at the input
                           document at all, or it only needs to look at the place where the input document is
                           currently positioned.
                        </div>
                     </div>
                     <div class="listitem e92">
                        <div class="para e93">
                           <div class="emphasis e94">Consuming</div>: the construct needs to read everything between the
                           current start tag and the corresponding end tag
                        </div>
                     </div>
                     <div class="listitem e95">
                        <div class="para e96">
                           <div class="emphasis e97">Free-ranging</div>: the construct potentially needs to read outside
                           the slice of the document represented by the current element and its ancestors.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="popupBox e98">
            <div class="popupLabel" onmouseover="$('#d1e184').show('1000');" onmouseout="$('#d1e184').hide('1000');">[ blockquote ]</div>
            <div id="d1e184" style="display: none;">
               <div class="blockquote">
                  <div class="title e99">The posture of a construct</div>
                  <div class="para e100">The 
                     <div class="emphasis e101">posture</div> is concerned with determining whether an expression
                     returns nodes from the streamed input document, and if so, where these nodes come
                     from.
                     There are five values:
                  </div>
                  <div class="itemizedlist e102">
                     <div class="listitem e103">
                        <div class="para e104">
                           <div class="emphasis e105">Grounded</div>: this means that the expression doesn't return nodes
                           from the streamed input. It either returns atomic values (or function items), or it
                           returns nodes from non-streamed documents only.
                        </div>
                     </div>
                     <div class="listitem e106">
                        <div class="para e107">
                           <div class="emphasis e108">Striding</div>: this means that the expression returns a set of nodes
                           from the streamed input document, in document order, and that none of these nodes
                           will
                           contain another node in the result (none is an ancestor or descendant of
                           another).
                        </div>
                     </div>
                     <div class="listitem e109">
                        <div class="para e110">
                           <div class="emphasis e111">Crawling</div>: again, the expression returns a set of nodes from the
                           streamed input document, in document order, but this time some of the nodes may be
                           ancestors or descendants of others.
                        </div>
                     </div>
                     <div class="listitem e112">
                        <div class="para e113">
                           <div class="emphasis e114">Climbing</div>: The specification assumes that when an input document
                           is streamed, a stack of information is retained containing details of the names and
                           attributes of all ancestor elements of the element at which the stream is currently
                           positioned. Any expression that accesses ancestor nodes or their attributes from this
                           stack has a posture of climbing.
                        </div>
                     </div>
                     <div class="listitem e115">
                        <div class="para e116">
                           <div class="emphasis e117">Roaming</div> : This indicates that an expression navigates off to
                           parts of the document that aren't accessible when streaming, such as preceding or
                           following siblings.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="StreamabilityrulesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e118">
            <div class="title e119">Streamability rules</div>
            <div class="para e120">The specification provides a 
               <div class="emphasis e121">very</div> detailed and very large set of
               rules for determining these properties for a given construct in a given situation
               within an
               XSLT stylesheet. (To give a sense of the size, the streamability rules take approximately
               20,000 words of the 160,000 in the specification's main body, and the section on streaming
               itself another 6000 words.) The detail is necessary to ensure that simple constructs,
               which
               at first glance should be streamable, actually are – a highly conservative simpler
               set of
               rules would exclude many common cases.
            </div>
            <div class="note e122">
               <div class="para e123">Whilst these rules are intended to be complete, 
                  <div class="xref e124" linkend="Braaksma2"></div>, presented
                  at XML London , gives a more informal set of guidelines, intended to support designers
                  creating or refactoring their code for streaming.
               </div>
            </div>
            <div class="para e125">These rules split into four general categories: i) a set of 
               <div class="emphasis e126">General
                  Streamability Rules
               </div> (usually abbreviated to GSR), ii) a set of specific rules
               for every XSL instruction, iii) rules for each XPath expression term and iv) rules
               for all
               built-in XPath functions. Examples of these rules will be given in later sections.
            </div>
            <div class="para e127">To analyse the streamability of a given 
               <div class="code e128">xsl:stream</div> instruction it is
               (usually) necessary to recursively apply these rules to 
               <div class="emphasis e129">every</div> construct
               contained within (every XSL instruction, every XPath term), and in addition any 'external'
               resources, such as 
               <div class="code e130">xsl:template</div> or 
               <div class="code e131">xsl:function</div> (and their
               definitions) that may be invoked.
               <div class="popupBox e132">
                  <div class="popupLabel" onmouseover="$('#d1e250').show('1000');" onmouseout="$('#d1e250').hide('1000');">[ footnote ]</div>
                  <div id="d1e250" style="display: none;">
                     <div class="footnote">
                        <div class="para e133">Applicable templates must be invoked in a mode that has been declared to be
                           streamable (
                           <div class="code e134">xsl:mode name=".." streamable="yes"</div>) so the set of templates to
                           be examined is restricted.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e135">It is anticipated that developers who are designing streamable transformations, will
               acquire a sense of the spirit of these rules, but to start may have to work through
               the
               rules in detail on a given problem. Whilst these calculations can be performed 'by
               hand', it
               can be somewhat tortuous, and slow, involving very deep recursions and much scrolling
               back
               and forth through the specification
               <div class="popupBox e136">
                  <div class="popupLabel" onmouseover="$('#d1e258').show('1000');" onmouseout="$('#d1e258').hide('1000');">[ footnote ]</div>
                  <div id="d1e258" style="display: none;">
                     <div class="footnote">
                        <div class="para e137">The author was present when the XSLT Working Group analysed 'by hand' (and
                           conference call) the streamability of a 5 instruction stylesheet, with XPath expressions
                           perhaps 4-5 terms deep. They almost managed to complete the process in about 50
                           minutes.
                        </div>
                     </div>
                  </div>
               </div>.
            </div>
            <div class="para e138">To assist in such early study of streamability, the author has built a tool, funded
               by
               Saxonica, to perform such analysis on a given stylesheet and display the results in
               a form
               that the intermediate properties and the relevant rules can be explored interactively.
               The
               rest of this paper is about the structure of this tool.
            </div>
            <div class="note e139">
               <div class="para e140">The tool is at the time of writing available at 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e141" xlink:actuate="onRequest" xlink:href="http://dev.saxonica.com/stream/index.html" xlink:show="new" xlink:type="simple">Saxonica Community: Streaming
                     Analysis
                  </div> which is intended only to analyse small single stylesheets (no support
                  for inclusion), or some of the specification and W3C test-case examples. Saxonica
                  Ltd
                  reserves the right to withdraw this service without notice and makes no guarantees
                  as to
                  the veracity of the results. 
               </div>
            </div>
         </div>
      </div><a name="AQuickTourANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e142">
         <div class="title e143">A Quick Tour</div>
         <div class="para e144">The tool is controlled by and presents its results as an XHTML web page, which is
            usually
            connected to a server providing the analysis operation. It's best to start off with
            a quick
            picture of what the tool provides, operating in this case on one of the examples from
            the
            specification:
         </div>
         <div class="figure e145" xml:id="sample-a">
            <div class="title e146">Sample stylesheet</div>
            <div class="mediaobject e147">
               <div class="imageobject e148">
                  <div class="metaBox e149"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e280').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e280" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e149'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e150">A stylesheet can be uploaded to the analysis tool, or as in this case, a pre-loaded
            example taken from the specification is selected. A serialised version of the source
            is
            displayed, with styling, line-numbering and fold/unfold controls. The
            
            <div class="code e151">xsl:template</div> and 
            <div class="code e152">xsl:stream</div> have green backgrounds as the analysis
            has concluded that they are 
            <div class="emphasis e153">guaranteed streamable</div> – if this were not the
            case they would have red backgrounds. The implicit sequence constructors have been
            displayed
            explicitly. Many of the elements of the serialisation are sensitive to mouse-click...
         </div>
         <div class="figure e154" xml:id="sample-b">
            <div class="title e155">XPath expressions revealed</div>
            <div class="mediaobject e156">
               <div class="imageobject e157">
                  <div class="metaBox e158"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e297').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e297" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e158'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e159">By clicking on the two XPath-containing attributes (
            <div class="code e160">@match</div> and
            
            <div class="code e161">@select</div> of lines 2 and 5 respectively) we reveal the full trees representing
            the parsing of these expressions, whose properties will become crucial in determining
            streamability. By selecting amongst the check-boxes we can then show some of the streaming
            properties that have been calculated:
         </div>
         <div class="figure e162" xml:id="sample-c">
            <div class="title e163">Streaming properties displayed</div>
            <div class="mediaobject e164">
               <div class="imageobject e165">
                  <div class="metaBox e166"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e311').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e311" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e166'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e167">Here we have chosen to display both the 
            <div class="quote e168">role</div> of each of the XPath
            expressions (whose importance will be explained later), and the calculated 
            <div class="emphasis e169">static
               type
            </div> and 
            <div class="emphasis e170">posture</div> for each element in both XPath expression
            and XSLT instruction constructs. These are displayed in distinctly shortened and styled
            forms,
            as if they were attributive properties of each element.
         </div>
         <div class="figure e171" xml:id="sample-d">
            <div class="title e172">Applied rules identified</div>
            <div class="mediaobject e173">
               <div class="imageobject e174">
                  <div class="metaBox e175"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e328').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e328" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e175'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-004.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e176">Not only is it useful to display the calculated property, but it is also exceptionally
            helpful to understand why it has that value. In this case we have displayed the sections
            of
            the 
            <div class="quote e177">General Streamability Rules</div> that were triggered, if those rules were used
            on that particular construct. If we click on one of these decorations a subsidiary
            browser
            window or tab shows the first section of the rules which were applied:.
         </div>
         <div class="figure e178" xml:id="sample-e">
            <div class="title e179">Applicable general streamability rules</div>
            <div class="mediaobject e180">
               <div class="imageobject e181">
                  <div class="metaBox e182"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e339').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e339" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e182'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-005.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e183">Here case 
            <div class="code e184">1.b.iii.A.II</div> was appropriate (the 
            <div class="quote e185">usage</div> wasn't
            modified). Other relevant portions of the specification can be displayed in a similar
            manner –
            clicking on the 
            <div class="code e186">AxisStep</div> element brings up the specification-defined process for
            determination of the streamability of such an expression:
         </div>
         <div class="figure e187" xml:id="sample-f">
            <div class="title e188">Relevant specification sections linked</div>
            <div class="mediaobject e189">
               <div class="imageobject e190">
                  <div class="metaBox e191"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e357').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e357" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e191'
                           </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-006.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e192">The rest of this paper looks at the details of the design of the tools to achieve
            these
            effects.
         </div>
      </div><a name="BasicDesignANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e193">
         <div class="title e194">Basic Design</div>
         <div class="para e195">The tool splits broadly into three sections: i) determining the appropriate streaming
            properties for all nodes on a stylesheet 'tree', ii) preparing an interactive display
            of the
            stylesheet where these properties can be examined and iii) combining these in a web-server
            such that stylesheets can be uploaded and interactive result web pages returned. With
            the
            exception of the web-server package deployment, the analysis tool is built entirely
            in
            XSLT3.0, generating an interactive display result which is a combination of (X)HTML,
            CSS and
            XSLT2.0 delivered using Saxon-CE. 
         </div><a name="DeterminingstreamingpropertiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e196">
            <div class="title e197">Determining streaming properties</div>
            <div class="para e198">To analyse the streaming properties for a given stylesheet, we at least need to
               recursively descend the stylesheet tree from any 
               <div class="code e199">xsl:stream</div> instructions, or
               
               <div class="code e200">xsl:template</div> nodes that can be invoked in a streamable mode, and calculate
               these properties based on a contextual state, the specific construct and most likely
               the
               properties of its children, hence the deep recursion. Not only does this process have
               to
               involve XSLT instructions, it must also involve XPath expressions contained within
               various
               attributes of those instructions, as they are the mechanisms whereby XSLT selects
               data nodes
               of interest, and their behaviour in 'moving around' the data tree is critical to
               streamability. In effect, for purposes of streamability, the XPath expressions (which
               can be
               described from their parse trees) are tree-extensions of the main stylesheet, albeit
               technically anchored through attributes rather than elemental children. 
            </div>
            <div class="para e201">This process starts by producing a modified version of the XSLT tree, in which
               additional sub-trees describe these XPath expressions and which has explicit sequence
               constructors. For example the template:
            </div>
            <div class="figure e202" xml:id="show-2">
               <div class="title e203">Sample XSLT</div>
               <div class="programlisting e204" xml:space="preserve">&lt;xsl:template match="/"&gt;
                  &lt;xsl:stream href="book.xml"&gt;
                  &lt;xsl:for-each select="book"&gt;
                  &lt;xsl:for-each select="chapter"&gt;
                  &lt;xsl:result-document href="chapter{position()}.xml"&gt;
                  &lt;xsl:copy-of select="."/&gt;
                  &lt;/xsl:result-document&gt;
                  &lt;/xsl:for-each&gt;
                  &lt;/xsl:for-each&gt;
                  &lt;/xsl:stream&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
            <div class="para e205">is transformed into another tree with additional children and attributes:</div>
            <div class="figure e206" xml:id="show-3">
               <div class="title e207">Transformed XSLT</div>
               <div class="programlisting e208" xml:space="preserve">&lt;xsl:template match="/" l:no="2" xmlns:xp="http://saxonica.com/xpathParse" xmlns:s="StreamAnalysis"&gt;
                  &lt;xp:AxisStep axis="self" nodeTest="document-node()" s:role="match"/&gt;
                  &lt;s:sequence-constructor&gt;
                  &lt;xsl:stream href="book.xml" l:no="3"&gt;
                  &lt;s:sequence-constructor&gt;
                  &lt;xsl:for-each select="book" l:no="4"&gt;
                  &lt;xp:AxisStep axis="child" nodeTest="element(book)" s:role="select"/&gt;
                  &lt;s:sequence-constructor&gt;
                  &lt;xsl:for-each select="chapter" l:no="5"&gt;
                  &lt;xp:AxisStep axis="child" nodeTest="element(chapter)" s:role="select"/&gt;
                  &lt;s:sequence-constructor&gt;
                  &lt;xsl:result-document href="chapter{position()}.xml" l:no="6"&gt;
                  &lt;xp:FunctionCall name="position" s:role="AVT.href.1"/&gt;
                  &lt;s:sequence-constructor&gt;
                  &lt;xsl:copy-of select="." l:no="7"&gt;
                  &lt;xp:ContextItemExpr s:role="select"/&gt;
                  &lt;/xsl:copy-of&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:result-document&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:for-each&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:for-each&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:stream&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
            <div class="para e209">The sequence constructors have been made explicit as 
               <div class="code e210">s:sequence-constructor</div> children
               <div class="popupBox e211">
                  <div class="popupLabel" onmouseover="$('#d1e395').show('1000');" onmouseout="$('#d1e395').hide('1000');">[ footnote ]</div>
                  <div id="d1e395" style="display: none;">
                     <div class="footnote">
                        <div class="para e212">We could have used 
                           <div class="code e213">xsl:sequence</div> which in XSLT3.0 can contain a sequence
                           constructor (!) but placing it in a separate namespace makes the implementation
                           tidier.
                        </div>
                     </div>
                  </div>
               </div>. If, for example, the 
               <div class="code e214">xsl:for-each select="book"</div> had contained an
               
               <div class="code e215">xsl:sort</div> directive, this would 
               <div class="emphasis e216">not</div> be contained within
               the sequence constructor pseudo-child. The XPath expressions contained within attributes
               have been placed as children in the 
               <div class="code e217">xp:</div> namespace, each having an attribute
               (
               <div class="code e218">@s:role</div>) describing the role it takes within the containing instruction,
               using a simple naming scheme for identifying expressions contained within attribute
               value
               templates. (The 
               <div class="code e219">@l:no</div> attributes have been added to denote original source line
               numbers, for use in eventual display.) 
            </div>
            <div class="para e220">With the expanded XSLT tree, a top-down analysis of the streamability is performed,
               by
               evaluating the extensive rules outlined in the specification over tree nodes and their
               children. The results are returned as a copy of the input tree decorated with a series
               of
               attributes describing the streaming properties of each node. The inner
               
               <div class="code e221">xsl:result-document</div> sub-tree of our example becomes: 
            </div>
            <div class="figure e222" xml:id="show-4">
               <div class="title e223">Analysed XSLT</div>
               <div class="programlisting e224" xml:space="preserve">&lt;xsl:result-document id="d7794e12" href="chapter{position()}.xml" l:no="6"
                  s:contextItemType="element(chapter)" s:staticType="item()*" s:usage="transmission"
                  s:contextPosture="striding" s:href="#streamability-xsl-result-document" s:posture="grounded"
                  s:sweep="consuming" s:general="2.d.ii"&gt;
                  &lt;xp:FunctionCall id="d7794e13" name="position" s:role="AVT.href.1"
                  s:contextItemType="element(chapter)" s:staticType="xs:integer" s:contextPosture="striding"
                  s:href="#streamability-fn-position" s:posture="grounded" s:sweep="motionless" s:general="2.a"
                  s:sweepOriginal="motionless" s:generalOperand="1.b.ii"/&gt;
                  &lt;s:sequence-constructor id="d7794e14" s:contextItemType="element(chapter)"
                  s:staticType="element(chapter)" s:usage="absorption" s:href="#classifying-sequence-constructors"
                  s:contextPosture="striding" s:posture="grounded" s:sweep="consuming" s:sweepOriginal="consuming"
                  s:usageOriginal="absorption" s:generalOperand="1.b.ii,1.c.i" s:potentialConsumer=""&gt;
                  &lt;xsl:copy-of id="d7794e15" select="." l:no="7" s:contextItemType="element(chapter)"
                  s:staticType="element(chapter)" s:usage="transmission" s:contextPosture="striding"
                  s:href="#streamability-xsl-copy-of" s:posture="grounded" s:sweep="consuming"
                  s:general="2.d.ii"&gt;
                  &lt;xp:ContextItemExpr id="d7794e16" s:role="select" s:contextItemType="element(chapter)"
                  s:staticType="element(chapter)" s:usage="absorption"
                  s:href="#streamability-of-context-item-expression" s:contextPosture="striding"
                  s:posture="striding" s:sweep="consuming" s:sweepOriginal="motionless"
                  s:usageOriginal="absorption" s:generalOperand="1.b.iii.A.II,1.b.iii.B.2.1,1.c.i"
                  s:potentialConsumer=""/&gt;
                  &lt;/xsl:copy-of&gt;
                  &lt;/s:sequence-constructor&gt;
                  &lt;/xsl:result-document&gt;
               </div>
            </div>
            <div class="para e225">(The details of these annotations will be described later.) </div>
         </div><a name="DisplayingtheresultsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e226">
            <div class="title e227">Displaying the results</div>
            <div class="para e228">At this point, technically the analysis of the streamability is complete – examining
               these streaming properties can assess whether an 
               <div class="code e229">xsl:stream</div> instruction is
               indeed 
               <div class="emphasis e230">guaranteed streamable</div>. However to be useful these results should
               be displayed in a meaningful way, and with some interaction to restrict the almost
               certain
               information overload. The basic approach is to convert the result tree into a serialised
               HTML 
               <div class="code e231">pre</div>, which is styled through CSS, and where the visibility of various
               sections can be controlled interactively, in this case using Saxon-CE transforms attached
               to
               callbacks. The 
               <div class="code e232">xp:FunctionCall[@name='position']</div> shown highlighted in 
               <div class="xref e233" linkend="show-4"></div> is displayed as a line:
            </div>
            <div class="figure e234" xml:id="show-5">
               <div class="title e235">Displayed analysed expression</div>
               <div class="mediaobject e236">
                  <div class="imageobject e237">
                     <div class="metaBox e238"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e457').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e457" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e238'
                              </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-007.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e239">which is actually represented as a structure within 
               <div class="code e240">pre</div> as
               <div class="popupBox e241">
                  <div class="popupLabel" onmouseover="$('#d1e463').show('1000');" onmouseout="$('#d1e463').hide('1000');">[ footnote ]</div>
                  <div id="d1e463" style="display: none;">
                     <div class="footnote">
                        <div class="para e242">Multi-line expansion and indentation is shown for clarity, but the single line is
                           actually 
                           <div class="quote e243">flat</div>.
                        </div>
                     </div>
                  </div>
               </div>:
            </div>
            <div class="figure e244" xml:id="show-6">
               <div class="title e245">Serialised display of analysed XSLT</div>
               <div class="programlisting e246" xml:space="preserve">&lt;span class="XPtop" role="AVT.href" style="display:inline"&gt;
                  &lt;span class="lineNumber"&gt; &lt;/span&gt;
                  &lt;span class="XPelem"&gt;
                  &lt;a target="_spec" href="XSLT3.0-Spec#streamability-fn-position"&gt;FunctionCall&lt;/a&gt;
                  &lt;/span&gt;
                  &lt;span class="XMLatt"&gt;
                  name=&lt;span class="XMLquot"&gt;"position"&lt;/span&gt;
                  &lt;/span&gt;
                  &lt;span class="stream"&gt;
                  &lt;span class="streamProperty role" type="role" style="display:inline"&gt;
                  &lt;span class="propName"&gt;r:&lt;/span&gt; AVT.href.1
                  &lt;/span&gt;
                  &lt;span class="streamProperty contextItemType" type="contextItemType" style="display:none"&gt;
                  &lt;span class="propName"&gt;ct:&lt;/span&gt; document-node()
                  &lt;/span&gt;
                  &lt;span class="streamProperty staticType" type="staticType" style="display:inline"&gt;
                  &lt;span class="propName"&gt;t:&lt;/span&gt; xs:integer
                  &lt;/span&gt;
                  ...
                  &lt;span class="streamProperty posture" type="posture" style="display:inline"&gt;
                  &lt;span class="propName"&gt;p:&lt;/span&gt; grounded
                  &lt;/span&gt;
                  ...
                  &lt;span class="streamProperty generalOperand" type="generalOperand" style="display:inline"&gt;
                  &lt;a target="_spec" href="XSLT3.0-Spec#gsr-1.b.ii"&gt;
                  &lt;span class="propName"&gt;rule.op:&lt;/span&gt;1.b.ii&lt;/a&gt;
                  &lt;/span&gt;
                  &lt;/span&gt;
                  &gt;
                  &lt;/span&gt;
               </div>
            </div>
            <div class="para e247">The 
               <div class="quote e248">stream</div> span contains all the streaming properties, each being styled
               and differentiated via CSS through the 
               <div class="code e249">@class</div> attribute. Interaction through
               the tool check-boxes toggles the 
               <div class="code e250">@style</div> between 
               <div class="code e251">display:none</div> and
               
               <div class="code e252">display:inline</div>, thus revealing or concealing the properties. The
               
               <div class="code e253">generalOperand</div> class contains a hyperlink to the section of the General
               Streamability Rules that was used when treating this construct as an operand of its
               parent.
               How these decorations are added is described later. 
            </div>
         </div><a name="DeliveringtheserviceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e254">
            <div class="title e255">Delivering the service</div>
            <div class="para e256">The analysis tool is an XSLT transform that delivers a modified XSLT tree. The display
               generator is another transform that takes that tree and delivers an (interactive)
               HTML page.
               These could be combined into a single package, but we have chosen to implement this
               analysis
               as a web service, permitting stylesheets to be uploaded for examination. To do this
               we've
               used the 
               <div class="xref e257" linkend="Servlex"></div> webapp package tool . The general architecture of the
               delivery platform is: 
            </div>
            <div class="figure e258" xml:id="show-7">
               <div class="title e259">Streamability analysis as a web service</div>
               <div class="mediaobject e260">
                  <div class="imageobject e261">
                     <div class="metaBox e262"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e508').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e508" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e262'
                              </span><span class="metaAttribute">fileref='../../../vol13/graphics/Lumley01/Lumley01-008.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e263">Apart from delivery of resource classes (e.g. 
               <div class="code e264">*.html</div>,
               <div class="code e265">*.css</div> and
               
               <div class="code e266">*.js</div>, which includes the Saxon-CE 'compiler'...), three principal messages
               are processed by the web package:
            </div>
            <div class="variablelist e267">
               <div class="varlistentry e268">
                  <div class="term e269">analyze.html</div>
                  <div class="listitem e270">
                     <div class="para e271">Executes an XSLT transform that generates the main tool page, including collecting
                        all the preloaded examples and forming drop-down selectors to choose them.
                     </div>
                  </div>
               </div>
               <div class="varlistentry e272">
                  <div class="term e273">analyzeStream</div>
                  <div class="listitem e274">
                     <div class="para e275">Is accompanied by the upload of the source stylesheet
                        <div class="popupBox e276">
                           <div class="popupLabel" onmouseover="$('#d1e533').show('1000');" onmouseout="$('#d1e533').hide('1000');">[ footnote ]</div>
                           <div id="d1e533" style="display: none;">
                              <div class="footnote">
                                 <div class="para e277">At present relative indirect stylesheets (e.g. 
                                    <div class="code e278">xsl:include
                                       href="more.xsl"
                                    </div>) are not supported, as of course the server cannot
                                    request from the client file system, though 'web-accessible' links could be
                                    followed. A system where all the stylesheets were web-accessible could be
                                    developed easily.
                                 </div>
                              </div>
                           </div>
                        </div>which is processed for analysis followed by serialisation of the result
                        into an interactive web-page, which displays in a frame in the main tool.
                     </div>
                  </div>
               </div>
               <div class="varlistentry e279">
                  <div class="term e280">XSLT3.0-Spec</div>
                  <div class="listitem e281">
                     <div class="para e282">Generates an annotated version of the current W3C specification, mostly in terms
                        of labelling all the cases in the 
                        <div class="quote e283">General Streamability Rules</div> so they
                        can linked to by fragment identifiers (e.g. 
                        <div class="code e284">#gsr-1.b.iii.A.II</div>). The
                        specification is displayed in a separate tab or window for ease of use. (The annotated
                        specification should be stored in the Servlex web cache, so this regeneration should
                        be infrequent.)
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e285"> This delivery mechanism will not be described further in this paper, save that we
               found
               Servlex to be an excellent vehicle for constructing such a service.
            </div>
         </div><a name="LimitationsandassumptionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e286">
            <div class="title e287">Limitations and assumptions</div>
            <div class="para e288">The tool assumes of course that the stylesheets are well formed XML, and syntactically
               correct XSLT, or more correctly only analyses them on the basis that they are syntactically
               correct. Little error checking is performed.
            </div>
         </div>
      </div><a name="ExpandingXPathExpressionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e289">
         <div class="title e290">Expanding XPath Expressions</div>
         <div class="para e291">To analyse XSLT streamability it is necessary to examine from where in the XML input
            tree
            data is being collected by stylesheet instructions. These operations are obviously
            described
            as XPath expressions, which can be highly compound in nature, such as mixing searches
            along
            different axes (child, ancestor, following etc.), predicates and a number of built-in
            functions. Analysis of streamability has to examine the structures of these expressions
            - the
            rules are described with reference to the EBNF grammar for XPath, defined in 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e292" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/#nt-bnf" xlink:show="new" xlink:type="simple">XPath 3.0 Grammar</div>. Thus for our
            purposes it is most convenient to generate parse result trees corresponding to the
            XPath
            expressions contained in attribute values (e.g. 
            <div class="code e293">@select</div>) or attribute value
            templates (e.g. 
            <div class="code e294">href="example{position()}.xml"</div>).
         </div>
         <div class="para e295">As the analysis is being performed in an XSLT environment, such parsing can be performed
            most conveniently with a parser itself written in XSLT. Luckily the 
            <div class="xref e296" linkend="REx"></div>
            parser generator can be configured to generate parsers in several languages, including
            XSLT,
            which can both test against a grammar and built a result XML parse tree. REx can indeed
            generate a working XPath 3.0 parser to run in XSLT. The nub of the expansion is shown
            in 
            <div class="xref e297" linkend="operand"></div> :
         </div>
         <div class="figure e298" xml:id="operand">
            <div class="title e299">Parsing XPath expressions</div>
            <div class="programlisting e300" xml:space="preserve">&lt;xsl:include href="../rex/xpath3.0-parse.xslt"/&gt;
               ...
               &lt;xsl:template match="@select|@test|@match|@group-adjacent" mode="operand"&gt;
               &lt;xsl:variable name="role" select="name(.)"/&gt;
               &lt;xsl:for-each select="xp:parse.xpath(.)"&gt;
               &lt;xsl:copy&gt;
               &lt;xsl:sequence select="@*"/&gt;
               &lt;xsl:attribute name="s:role" select="$role"/&gt;
               &lt;xsl:sequence select="*|text()"/&gt;
               &lt;/xsl:copy&gt;
               &lt;/xsl:for-each&gt;
               &lt;/xsl:template&gt;
               
            </div>
         </div>
         <div class="para e301">
            <div class="code e302">xpath3.0-parse.xslt</div> links to the transform that has been generated by REx.
            
            <div class="code e303">xp:parse.xpath()</div> performs some tactical rewriting of an XPath string (see 
            <div class="xref e304" linkend="rewrites"></div>), calls the REx-generated parser and does some post-processing
            (namespace remapping, collapsing of singleton leaf sub-trees, etc...) before returning
            the
            completed parse-tree. The 
            <div class="code e305">operand</div> mode generates a child element containing that
            XPath parse tree, identified with the role of the expression (in this case the attribute
            name)
            - this role will be used in later operations to identify different instruction-specific
            treatments as far as effect on streaming is concerned. These operands trees are generated
            from
            a main template shown in 
            <div class="xref e306" linkend="Expand-constructs"></div>, where not only are common XPath
            carriers (e.g. 
            <div class="code e307">@select</div>) processed, but also attributes that are identified as
            containing 
            <div class="emphasis e308">attribute value templates</div>, using the predicate test function
            
            <div class="code e309">xp:is.AVT()</div>.
         </div>
         <div class="figure e310" xml:id="Expand-constructs">
            <div class="title e311">Expanding constructs</div>
            <div class="programlisting e312" xml:space="preserve">&lt;xsl:template match="xsl:*" mode="xp:P"&gt;
               &lt;xsl:copy&gt;
               &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
               &lt;xsl:call-template name="line-number"/&gt;
               &lt;xsl:apply-templates select="." mode="xp:implict-select"/&gt;
               &lt;xsl:apply-templates select="@select,@test,@match,@group-adjacent" mode="operand"/&gt;
               &lt;xsl:apply-templates select="@*[xp:is.AVT(.)]" mode="operand"/&gt;
               &lt;xsl:for-each-group select="*|text()[matches(.,'\S+')]"
               group-adjacent="xp:is.sequence-constructor(.)"&gt;
               &lt;xsl:choose&gt;
               &lt;xsl:when test="current-grouping-key()"&gt;
               &lt;s:sequence-constructor&gt;
               &lt;xsl:apply-templates select="current-group()" mode="#current"/&gt;
               &lt;/s:sequence-constructor&gt;
               &lt;/xsl:when&gt;
               &lt;xsl:otherwise&gt;
               &lt;xsl:apply-templates select="current-group()" mode="#current"/&gt;
               &lt;/xsl:otherwise&gt;
               &lt;/xsl:choose&gt;
               &lt;/xsl:for-each-group&gt;
               &lt;/xsl:copy&gt;
               &lt;/xsl:template&gt;
            </div>
         </div>
         <div class="para e313">As well as generating the operand trees, this template also: </div>
         <div class="itemizedlist e314">
            <div class="listitem e315">
               <div class="para e316">processes instructions that have an implicit selection role, such as
                  
                  <div class="code e317">xsl:apply-templates[empty(@select)]</div> or 
                  <div class="code e318">xsl:next-match</div> to add
                  the implicit context XPath expression tree,
               </div>
            </div>
            <div class="listitem e319">
               <div class="para e320">assigns a line-number-recording attribute, and</div>
            </div>
            <div class="listitem e321">
               <div class="para e322">collects all the contiguous elements and text nodes of the sequence constructor(s)
                  together under 
                  <div class="code e323">s:sequence-constructor</div> elements. The function
                  
                  <div class="code e324">xp:is.sequence-constructor()</div> provides a suitable test – elements which are
                  configurations or parameters of the instruction, such as 
                  <div class="code e325">xsl:param</div> or
                  
                  <div class="code e326">xsl:sort</div>, return 
                  <div class="code e327">false()</div>.
               </div>
            </div>
         </div><a name="InclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e328">
            <div class="title e329">Inclusions</div>
            <div class="para e330">Stylesheets often include resources from other stylesheets, using
               
               <div class="code e331">xsl:include</div> and 
               <div class="code e332">xsl:import</div> redirection instructions. For
               purposes of streamability analysis they can both be treated similarly (implicit match
               priorities are immaterial) and their document bodies are expanded as children of the
               instruction. As far as this analysis is concerned, templates, functions and variable
               directly within such inclusions are considered 
               <div class="quote e333">top-level</div> to the outer
               stylesheet. (The web-delivered service cannot process relative inclusions from uploaded
               stylesheets.) 
            </div>
         </div>
      </div><a name="ApplyingStreamabilityRulesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e334">
         <div class="title e335">Applying Streamability Rules</div>
         <div class="para e336">With the complete expanded stylesheet we have all the necessary program information
            to
            commence the streamability analysis. Whilst the rules are written recursively
            
            <div class="quote e337">top-down</div>, the author found it helpful to split the process into three
            sequential phases during which the tree is modified: required functionally equivalent
            rewrites
            of some expressions to ensure possible streamability, determination of context focus
            and
            construct type, followed by assessment of posture and sweep.
         </div><a name="PreprocessingandrewritingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e338" xml:id="rewrites">
            <div class="title e339">Preprocessing and rewriting</div>
            <div class="para e340">There are a number of (equivalence) rewrites defined in the specification that are
               required to either i) generate a canonical form or ii) make common constructs streamable.
               Some of these are most conveniently applied as textual rewrites to the original string
               (e.g.
               
               <div class="code e341">//</div> -&gt; 
               <div class="code e342">/descendant-or-self::node()/</div> ). Others are best applied as
               rewrites on the tree, such as 
               <div class="xref e343" linkend="rootNode"></div> where the 
               <div class="code e344">treat as</div>
               expression, forcing 
               <div class="code e345">document-node()</div> type, has been parsed to a tree.
            </div>
            <div class="figure e346" xml:id="rootNode">
               <div class="title e347">Root node rewriting</div>
               <div class="programlisting e348" xml:space="preserve">&lt;xsl:template match="PathExpr[Token[1]='/'][count(*) gt 1]"&gt;
                  &lt;RelativePathExpr&gt;  
                  &lt;xsl:apply-templates select="
                  xp:parse.xPath('root(self::node()) treat as document-node()'),
                  tail(*)"/&gt;
                  &lt;/RelativePathExpr&gt;
                  &lt;/xsl:template&gt;
               </div>
            </div>
         </div><a name="DeclarativetablesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e349" xml:id="declarative.tables">
            <div class="title e350">Declarative tables</div>
            <div class="para e351">While the tree modifications described in this section are actually carried out by
               sets
               of XSLT templates and functions, as much use as possible has been made of declarative
               tables
               that define appropriate properties, that the XSLT can interpret to process sections
               correctly. Using such tables increases flexibility and coherence extensively, collecting
               all
               relevant properties together in one place and often making some changes merely altering
               the
               value of an attribute.
            </div>
            <div class="figure e352" xml:id="instructionConstructs">
               <div class="title e353">Instruction descriptions</div>
               <div class="programlisting e354" xml:space="preserve">&lt;xsltConstructs&gt;
                  &lt;X:for-each focus-changing="controlling controlled"
                  f-c="select:controlling sequence:controlled"/&gt;
                  &lt;X:iterate focus-changing="controlling controlled"/&gt;
                  &lt;X:result-document staticType="item()*"/&gt;
                  &lt;X:stream focus-changing="controlled" context-posture="striding"/&gt;
                  &lt;X:template focus-changing="controlling controlled" href="#streamable-templates"/&gt;
                  &lt;X:text staticType="text()"/&gt;
                  &lt;X:value-of staticType="text()"/&gt;
                  &lt;X:when href="#streamability-xsl-choose"/&gt;
                  &lt;X:otherwise href="#streamability-xsl-choose"/&gt;
                  &lt;s:sequence-constructor href="#classifying-sequence-constructors"/&gt;
                  &lt;/xsltConstructs&gt;
               </div>
            </div>
            <div class="para e355">These descriptions for some XSLT instructions describe i) if they are focus-changing
               and
               if so, which of their operands control and are controlled by the change, using an
               order or
               simple proforma, ii) a static type for the instruction, if it is independent of that
               determined from context or children and iii) a hyperlink to the relevant streamability
               specification section if it is not in the canonical form (e.g.
               
               <div class="code e356">#streambility-of-xsl-copy</div>). This description is used to produce a series of
               maps relating instruction name to property such as 
               <div class="code e357">$spec-ref()</div>,
               
               <div class="code e358">$staticTypes()</div> that are used within XSLT processes described later.
            </div>
            <div class="figure e359" xml:id="expressionConstructs">
               <div class="title e360">Expression descriptions</div>
               <div class="programlisting e361" xml:space="preserve">&lt;expressionConstructs href="#classifying-expressions"&gt;
                  &lt;xp:Expr usage="T*"/&gt;
                  &lt;xp:ForExpr usage="N T" href="#streamability-of-for-expressions"/&gt;
                  &lt;xp:SimpleForClause/&gt;
                  &lt;xp:LetExpr usage="N T"/&gt;
                  &lt;xp:QuantifiedExpr staticType="xs:boolean" href="#streamability-of-quantified-expressions"/&gt;
                  &lt;xp:IfExpr usage="if:I then:T else:T" href="#streamability-of-if-expressions"
                  choice-group="then else"/&gt;
                  &lt;xp:OrExpr staticType="xs:boolean" usage="I I"/&gt;
                  &lt;xp:AndExpr staticType="xs:boolean" usage="I I"/&gt;
                  &lt;xp:ComparisonExpr staticType="xs:boolean" usage="A A"/&gt;
                  ...
                  &lt;xp:Root staticType="document-node()"/&gt;
                  &lt;/expressionConstructs&gt;
               </div>
            </div>
            <div class="para e362">For XPath expression constructs we also describe the 
               <div class="emphasis e363">usage</div> using a
               proforma derived from a table (
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e364" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streaming" xlink:show="new" xlink:type="simple">Classifying Expressions</div>) within the specification 
               <div class="popupBox e365">
                  <div class="popupLabel" onmouseover="$('#d1e726').show('1000');" onmouseout="$('#d1e726').hide('1000');">[ footnote ]</div>
                  <div id="d1e726" style="display: none;">
                     <div class="footnote">
                        <div class="para e366">It didn't quite appear that the table was itself regular enough to derive this data
                           from it automatically, but perhaps I should have persisted.
                        </div>
                     </div>
                  </div>
               </div>, and membership of a 
               <div class="emphasis e367">choice group</div> of some of the operands.
               For example, the 
               <div class="code e368">IfExpr</div> usage is defined to be that the operand having the
               
               <div class="code e369">if</div> role has an 
               <div class="emphasis e370">inspection</div> usage, and both the
               
               <div class="code e371">then</div> and 
               <div class="code e372">else</div> operands have 
               <div class="code e373">transmission</div> usage, as
               well defining that the 
               <div class="code e374">then</div> and 
               <div class="code e375">else</div> operands constitute a
               
               <div class="code e376">choice-group</div> (which effectively means that only 
               <div class="emphasis e377">one</div> of
               them, not both, must read the input stream).
            </div><a name="TypemodelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e378" xml:id="type.model">
               <div class="title e379">Type model</div>
               <div class="para e380">For some constructs the 
                  <div class="emphasis e381">static type</div> is needed to assess
                  streamability properties. [The most common case is assessing the value of a node which
                  is
                  known to be childless, such as an attribute or a text node - in this case no subtree
                  has
                  to be traversed to derive the complete string value.]
               </div>
               <div class="para e382">Initially the analysis model used a type hierarchy, which for streaming could be
                  somewhat coarser than can be strictly assessed - all XSL instructions were assessed
                  as
                  having static type 
                  <div class="code e383">item()*</div>, whereas a finer granularity was available, but
                  not needed, for the streamability analysis. The type hierarchy was defined for the
                  analysis tool by a tree:
               </div>
               <div class="figure e384" xml:id="types">
                  <div class="title e385">Type hierarchy</div>
                  <div class="programlisting e386" xml:space="preserve">&lt;item&gt;
                     &lt;node&gt;
                     &lt;document-node/&gt;
                     &lt;element/&gt;
                     &lt;attribute childless="true"/&gt;
                     &lt;text childless="true"/&gt;
                     &lt;comment childless="true"/&gt;
                     &lt;processing-instruction childless="true"/&gt;
                     &lt;namespace childless="true"/&gt;
                     &lt;/node&gt;
                     &lt;xs:anyAtomicType&gt;
                     &lt;xs:boolean/&gt;
                     &lt;xs:string/&gt;
                     &lt;xs:anyURI/&gt;
                     &lt;xs:QName/&gt;
                     ...
                     &lt;xs:gMonthDay/&gt;
                     &lt;xs:gDay/&gt;
                     &lt;xs:duration&gt;
                     &lt;xs:dayTimeDuration/&gt;
                     &lt;xs:yearMonthDuration/&gt;
                     &lt;/xs:duration&gt;
                     &lt;xs:double/&gt;
                     &lt;xs:float/&gt;
                     &lt;xs:decimal&gt;
                     &lt;xs:integer/&gt;
                     &lt;/xs:decimal&gt;
                     &lt;/xs:anyAtomicType&gt;
                     &lt;!-- Function and map types --&gt;
                     &lt;/item&gt;
                  </div>
               </div>
               <div class="para e387">The most common operation required using this type hierarchy was to assess a composite
                  type for a sequence of operands, calculated as the narrowest type in the type hierarchy
                  which is the type or super-type of all members of the sequence. This was most readily
                  assessed using a precomputed map of maps
                  
                  <div class="code e388">xp:least-common-supertypes($type0)($type1)</div> derived from this tree of types. 
               </div>
               <div class="para e389">Subsequent detailed study (see note in the next section) revealed that a more general
                  model involving union of types was needed. Thus between the first submission of this
                  paper
                  and the final publication the type model migrated to a 
                  <div class="emphasis e390">U-type</div> where
                  types were classified as a partial union of 28 fundamental types (7 nodal, e.g.
                  
                  <div class="code e391">element()</div>; 19 primitive atomic, e.g. 
                  <div class="code e392">xs:string</div>;
                  
                  <div class="code e393">function()</div> and 
                  <div class="code e394">xs:untypedAtomic</div>) A sequence is an instance of
                  a U-type 
                  <div class="emphasis e395">U</div> if every item in the sequence is an instance of one of the
                  fundamental types in 
                  <div class="emphasis e396">U</div>, considered as a set. For example, the
                  sequence 
                  <div class="code e397">(23, "Paris")</div> is an instance of the U-type 
                  <div class="code e398">U{xs:string,
                     xs:decimal, xs:date}
                  </div> because both items in the sequence belong to item types in
                  this U-type. Shorthand forms for common groupings were defined, e.g.
                  
                  <div class="emphasis e399">U{N}</div> denotes the union of all the node types.
               </div>
               <div class="para e400">Luckily the tool could migrate relatively smoothly, by representing a U-type as an
                  order-insensitive sequence of the constituent fundamental types as 
                  <div class="code e401">xs:string*</div>
                  (and stored as an attribute value as a whitespace-separated string, that can easily
                  be
                  tokenised back to a sequence), with a small number of additional helper maps and
                  functions, such as 
                  <div class="code e402">$uTypes('N')</div> and 
                  <div class="code e403">xp:union-type($types as
                     xs:string*)
                  </div>. Some of the special cases for expressions, instructions and
                  functions had to be altered to use these type-determination functions rather than
                  those
                  using the type-hierarchy tree. 
               </div>
            </div>
         </div><a name="ContextfocusandtypeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e404">
            <div class="title e405">Context focus and type</div>
            <div class="para e406">Whilst 
               <div class="emphasis e407">posture</div> and 
               <div class="emphasis e408">sweep</div> are the main
               properties to be analysed, two other subsidiary properties need to be assessed:
               
               <div class="emphasis e409">static type</div> and 
               <div class="emphasis e410">control focus</div>. Whilst this could
               be achieved contemporary with the posture/sweep analysis, it is somewhat clearer,
               and
               certainly easier to debug, to carry this out as a recursive descent/ascent pre-pass.
               
            </div>
            <div class="para e411">Certain instructions and expressions change the context focus for evaluation of their
               children. For a simple example, 
               <div class="code e412">xsl:for-each</div> obviously can (and almost
               invariably does) change the sequence of context nodes for evaluation of its descendant
               instructions. An 
               <div class="code e413">xsl:for-each</div> is said to be 
               <div class="emphasis e414">focus
                  changing
               </div>, its 
               <div class="code e415">@select</div> expression (which of course is represented as
               an expression tree identified 
               <div class="code e416">@s:role="select"</div>) is said to be
               
               <div class="emphasis e417">focus-controlling</div> and its sequence constructor is
               
               <div class="emphasis e418">focus-controlled</div>. These are identified on the tree through attributes
               
               <div class="code e419">s:focus="change|controlling|controlled"</div> respectively.
            </div>
            <div class="para e420">During this pass it is also possibly to analyse static type, propagating a
               
               <div class="emphasis e421">context item type</div> downwards (as a tunneled variable), changing it
               through focus-changing instructions, where generally the context item type for the
               controlled children is that of the assessed static type of the controlling (child)
               operand.
               For example the sequence constructor of 
               <div class="code e422">xsl:for-each select="amount"</div> will have
               a context item type of 
               <div class="code e423">element(amount)*</div> as that is the assessed static type of
               the XPath expression tree. The context type is recorded for subsequent display as
               a
               
               <div class="code e424">@s:contextType</div> attribute.
            </div>
            <div class="para e425">When leaves are reached, either it defines its own type (e.g. 
               <div class="code e426">FunctionCall
                  name="position"
               </div> has type 
               <div class="code e427">xs:integer</div>, which can be inferred from the
               function signature; 
               <div class="code e428">StringLiteral value="foo"</div> has type 
               <div class="code e429">xs:string</div>)
               or its static type is the context type (e.g. 
               <div class="code e430">ContextItemExpr</div>, aka '.'). On the
               way back either there are definitive rules provided (e.g. 
               <div class="code e431">QuantifiedExpr</div> has
               type 
               <div class="code e432">xs:boolean</div> and 
               <div class="code e433">PostfixExpr A[B]</div> has a type which is the type
               of 
               <div class="code e434">A</div>), or it has a sequence composite type, or appropriate union type
               calculated as described above. 
            </div>
            <div class="para e435">For expressions the specification gives a table of type determination
               
               <div class="quote e436">formulae</div> (
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e437" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#determining-static-type" xlink:show="new" xlink:type="simple">Determining the Static
                  Type of a Construct
               </div>). Whilst the static types defined (e.g. 
               <div class="code e438">AndExpr</div>
               has type 
               <div class="code e439">xs:boolean</div>) are determined from entries in the declarative table of
               
               <div class="xref e440" linkend="expressionConstructs"></div> , currently most of these cases are defined by
               pattern-matching templates. 
            </div>
            <div class="note e441">
               <div class="para e442">The tool proved to be of some worth in this area when I discovered a test-case that
                  was failing to be streamable, involving the expression 
                  <div class="code e443">xsl:value-of
                     select="head(/BOOKLIST/BOOKS/ITEM[1]/PRICE/ancestor::*/@*)"
                  </div>. The issue was that
                  whilst the static type of 
                  <div class="code e444">head()</div> was 
                  <div class="code e445">item()?</div> the instruction
                  failed streamability (a potentially overlapping sub-tree would have to be traversed
                  to
                  determine the textual value, due to the 
                  <div class="code e446">ancestor::*</div> step.) However if the
                  type of 
                  <div class="code e447">head()</div> is inferred to be the same type as its principal argument, in
                  this case 
                  <div class="code e448">attribute()?</div>, then that is technically a
                  
                  <div class="emphasis e449">childless-node</div>, whose text value 
                  <div class="emphasis e450">can</div> be
                  retrieved without further movement across the tree. A set of about a dozen functions
                  (e.g.
                  
                  <div class="code e451">subsequence()</div>) needed such specialist treatment. The XSLT Working Group had
                  to change the type model to encompass unions of fundamental types (see above) and
                  classify
                  functions that used their principal arguments in a 
                  <div class="emphasis e452">transmission</div> usage
                  (such as 
                  <div class="code e453">head()</div> ) to use such unions.
               </div>
            </div>
         </div><a name="ResourcereferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e454">
            <div class="title e455">Resource references</div>
            <div class="para e456">Whilst most of the assessment is carried out in a recursive tree descent/ascent manner,
               XSLT (and XPath) constructs can reference non-child resources in three specific ways:
               
               <div class="emphasis e457">variable / param</div> references, 
               <div class="emphasis e458">function / named
                  template
               </div> calls and 
               <div class="emphasis e459">template</div> applications. To complete
               streaming analysis these references must be examined and require 
               <div class="quote e460">off-tree</div>
               mechanisms. We'll discuss each in term:
            </div><a name="VariablesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e461">
               <div class="title e462">Variables</div>
               <div class="para e463">Variables can be declared both in XSLT (
                  <div class="code e464">xsl:variable</div> and
                  
                  <div class="code e465">xsl:param</div>) and in XPath (
                  <div class="code e466">let $v :=..</div>, 
                  <div class="code e467">for $v in
                     ...
                  </div>) and in both cases the scoping of reference to their
                  
                  <div class="emphasis e468">value</div> follows the
                  
                  <div class="code e469">following-sibling::*/descendant-or-self::*</div> compound axis
                  <div class="popupBox e470">
                     <div class="popupLabel" onmouseover="$('#d1e1014').show('1000');" onmouseout="$('#d1e1014').hide('1000');">[ footnote ]</div>
                     <div id="d1e1014" style="display: none;">
                        <div class="footnote">
                           <div class="para e471">Within our expanded XSLT trees all references will be through elements such as
                              
                              <div class="code e472">VarRef</div> - even 
                              <div class="emphasis e473">text-value-templates</div> will have been
                              expanded into element trees.
                           </div>
                        </div>
                     </div>
                  </div>. Processing such references is most simply achieved by
                  
                  <div class="emphasis e474">iterating</div> across construct bodies, accumulating maps of processed
                  variables which are tunneled down through to following-siblings and their descendants.
                  For
                  example in assessing static type, sections of the code relating to variables are
                  approximately:
               </div>
               <div class="figure e475" xml:id="variableTypes">
                  <div class="title e476">Variables and types</div>
                  <div class="programlisting e477" xml:space="preserve">&lt;xsl:template match="xp:*|xsl:*|s:sequence-constructor" mode="s:Type"&gt;
                     &lt;xsl:param name="variables" as="map(xs:string,element())" select="map:new()" tunnel="yes"/&gt;
                     ...
                     &lt;xsl:iterate select="*|text()"&gt;
                     &lt;xsl:param name="variables" select="$variables"/&gt;
                     &lt;xsl:variable name="temp" as="item()*"&gt;
                     &lt;xsl:apply-templates select="." mode="#current"&gt;
                     &lt;xsl:with-param name="variables" select="$variables" tunnel="yes"/
                     &lt;/xsl:apply-templates&gt;
                     &lt;/xsl:variable&gt;
                     &lt;xsl:sequence select="$temp"/&gt;
                     &lt;xsl:if test="self::xsl:variable|self::xsl:param|self::xp:QE.var"&gt;
                     &lt;xsl:next-iteration&gt;
                     &lt;xsl:with-param name="variables" as="map(xs:string,element())"
                     select="map:new(($variables,map:entry(@name,$temp)))"/&gt;
                     &lt;/xsl:next-iteration&gt;
                     &lt;/xsl:if&gt;
                     &lt;/xsl:iterate&gt;
                     ...
                     &lt;/xsl:template&gt;
                     
                     &lt;xsl:template match="xsl:variable|xsl:param" mode="s:staticTypeVal" as="xs:string?"
                     priority="1.5"&gt;
                     &lt;xsl:param name="children" select="()" as="element()*"/&gt;
                     &lt;xsl:value-of select="xp:composite-type-multiple($children/@s:staticType)"/&gt;
                     &lt;/xsl:template&gt;
                     
                     &lt;xsl:template match="xp:VarRef" mode="s:staticTypeVal" as="xs:string"&gt;
                     &lt;xsl:param name="variables" as="map(xs:string,element())" select="map:new()" tunnel="yes"/&gt;
                     &lt;xsl:value-of select="($variables(@name)/@s:staticType,'UNKNOWN VAR/TYPE')[1]"/&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               <div class="para e478">In the first template, the iteration across the children using
                  
                  <div class="code e479">xsl:iterate</div> accumulates a parameter 
                  <div class="code e480">$variables</div> as a map which
                  relates variable name to the in-scope processed variable tree for that name. The tree
                  value will i) be fully decorated with its properties (in this case including
                  
                  <div class="code e481">@staticType</div> and ii) have had all variables 
                  <div class="emphasis e482">it</div> refers
                  to in its definition interpolated fully as regards streaming properties. Each child
                  in
                  turn is processed with a full current binding of variables passed as a tunneled parameter
                  
                  <div class="code e483">$variables</div>, which can in turn be updated in scope
                  <div class="popupBox e484">
                     <div class="popupLabel" onmouseover="$('#d1e1050').show('1000');" onmouseout="$('#d1e1050').hide('1000');">[ footnote ]</div>
                     <div id="d1e1050" style="display: none;">
                        <div class="footnote">
                           <div class="para e485">Whilst this of course can be processed using a recursive template, using
                              
                              <div class="code e486">xsl:iterate</div> introduces much more coherence in what is essentially a
                              contained tail-recursive iteration. Using a high-order function such as
                              
                              <div class="code e487">fold()</div> isn't terribly practical when XSLT instructions predominate.
                              Equally the immutable 
                              <div class="code e488">map()</div> of XSLT3.0 makes tracking variable scoping
                              vastly easier than alternative methods.
                           </div>
                        </div>
                     </div>
                  </div>.
               </div>
               <div class="para e489">The second template assesses the static type of a variable as the composite type of
                  
                  <div class="emphasis e490">its</div> children, which actually should be null or a singleton - either
                  the 
                  <div class="code e491">@select</div> operand, or a single sequence constructor. The final template
                  shows how the static type is evaluated for a 
                  <div class="code e492">VarRef</div> construct (the only
                  construct within the XPath grammar which actually interpolates variable name references),
                  by lookup in the supplied map. 
               </div>
            </div><a name="FunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e493" xml:id="functions">
               <div class="title e494">Functions</div>
               <div class="para e495">Built-in and stylesheet functions are global entities, which may be referenced
                  (almost) anywhere within the stylesheet tree. Fortunately the streamability rules
                  only
                  require knowledge of the type of the result and the required type of the arguments
                  to
                  assess the streamability of a call. For built-in functions, the 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e496" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple">XPath and XQuery Functions and
                     Operators 3.0
                  </div> specification uses a definitional XML file
                  
                  <div class="code e497">function-catalog.xml</div> that contains all the data defining each function,
                  such as signatures, and from which the specification is constructed. The specification
                  contains a table in 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e498" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#classifying-built-in-functions" xlink:show="new" xlink:type="simple">Classifying
                     Calls to Built-In Functions
                  </div> that defines further (usage) properties. By taking a
                  copy of 
                  <div class="code e499">function-catalog.xml</div> and adding some minor annotations, we can
                  construct maps that will both identify type and usage for function calls and their
                  arguments:
               </div>
               <div class="figure e500" xml:id="functionCatalog">
                  <div class="title e501">Built-in function catalog</div>
                  <div class="programlisting e502" xml:space="preserve">&lt;fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                     ...
                     &lt;fos:function name="head" diff="add" at="E"&gt;
                     &lt;fos:signatures&gt;
                     &lt;fos:proto name="head" return-type="item()?"&gt;
                     &lt;fos:arg name="arg" type="item()*" usage="transmission"/&gt;
                     &lt;/fos:proto&gt;
                     &lt;/fos:signatures&gt;
                     &lt;fos:properties&gt;
                     &lt;fos:property&gt;deterministic&lt;/fos:property&gt;
                     &lt;fos:property&gt;context-independent&lt;/fos:property&gt;
                     &lt;fos:property&gt;focus-independent&lt;/fos:property&gt;
                     &lt;/fos:properties&gt;
                     ...
                     &lt;/fos:function&gt;
                     ...
                     &lt;/fos:functions&gt;
                     
                     &lt;xsl:variable name="functions" as="map(xs:string,item()*)" use-when="false()"
                     select="map:new(
                     for $f in (doc('function-catalog.xml')//fos:function[not(@prefix='op')]) 
                     return map:entry(
                     $f/(if(@prefix = ('math')) then @prefix||':' else '') || @name,
                     let 
                     $proto := $f/fos:signatures/fos:proto
                     return 
                     map:new((
                     map:entry('returnType',distinct-values($proto/@return-type)[last()]),
                     map:entry('args',$proto[last()]/map:new(fos:arg/map:entry(position(),.)))
                     ))))"/&gt;
                     
                     &lt;xsl:variable name="default-dot-functions" as="xs:string*"
                     select="map:keys($functions)! .[$functions(.)('args')(1)/@default='.']"/&gt;
                  </div>
               </div>
               <div class="para e503">In 
                  <div class="xref e504" linkend="functionCatalog"></div> we show the entry for 
                  <div class="code e505">head()</div> in
                  which we have added a 
                  <div class="code e506">transmission</div> usage property to its sole argument. The
                  variable 
                  <div class="code e507">$functions</div> has been constructed from that file as a map keyed by the
                  function name, each entry containing a map of some properties of that function,
                  
                  <div class="emphasis e508">viz.</div> the 
                  <div class="code e509">returnType</div> and a further map containing
                  entries for each argument of the last definition (which is usually the most complete),
                  keyed by position. This map, and others like it are used extensively within the analysis
                  <div class="popupBox e510">
                     <div class="popupLabel" onmouseover="$('#d1e1116').show('1000');" onmouseout="$('#d1e1116').hide('1000');">[ footnote ]</div>
                     <div id="d1e1116" style="display: none;">
                        <div class="footnote">
                           <div class="para e511">It is tempting to see whether the table 
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e512" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#classifying-built-in-functions" xlink:show="new" xlink:type="simple">Classifying Calls to Built-In Functions</div> in the specification is regular
                              enough that the usage can be extracted automatically. On the other hand one can argue
                              that fundamental properties of the function, such as usage, belong in the definitive
                              catalog. 
                           </div>
                        </div>
                     </div>
                  </div>: expanding implicit 
                  <div class="code e513">'.'</div> arguments for built-in functions (e.g.
                  
                  <div class="code e514">name()</div> being equivalent to 
                  <div class="code e515">name(.)</div>) is supported by computing
                  the set of function names for which that is the case as shown
                  
                  <div class="code e516">$default-dot-functions</div>.
               </div>
               <div class="para e517">Stylesheet functions can be analysed as a global set at top level: type signatures
                  can
                  then be recorded as a similar map to that used for built-in functions. Fortunately,
                  and
                  certainly avoiding issues of analysing recursive functions, the return type is generalised
                  as 
                  <div class="code e518">item()*</div>. Similar mechanisms can be used for named templates. 
               </div>
            </div><a name="AppliedtemplatesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e519">
               <div class="title e520">Applied templates</div>
               <div class="para e521">
                  <div class="code e522">xsl:apply-templates</div> invokes pattern-matching processing on each of the
                  members of their selected sequence. As such complete assessment of their return would
                  require some indirect assessment. Fortunately as far as streamability is concerned
                  this is
                  much simpler – the instruction is assumed to generate results of 
                  <div class="code e523">item()*</div>
                  type, and the 
                  <div class="emphasis e524">posture/sweep</div> streamability properties can be
                  determined mostly locally within the 
                  <div class="code e525">xsl:apply-templates</div> instruction itself:
                  other templates that may be triggered only have to be assessed as being in a totally
                  streamable 
                  <div class="code e526">mode-set</div>. 
               </div>
            </div>
         </div><a name="AssessingsweepandpostureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e527">
            <div class="title e528">Assessing sweep and posture</div>
            <div class="para e529">A similar, though much more complex, recursive descent/ascent process is used to
               determine the posture and sweep. A 
               <div class="emphasis e530">context posture</div> is propagated
               downwards, and alters through focus-changing instructions, with generally the context
               posture for controlled sub-trees being the assessed 
               <div class="emphasis e531">posture</div> of the
               controlling operand. The sweep of each of the construct operands is assessed and the
               composite sweep and posture is then calculated for the ensemble and becomes the sweep
               and
               posture for the construct. As much of the analysis as possible is calculated from
               definition
               tables described earlier.
            </div>
            <div class="para e532">The properties are represented on the tree as attributes (e.g.
               
               <div class="code e533">s:posture="striding"</div>), so they can be extracted from result through XPath.
               But to reduce errors through mistyping, a defined set of global variables, each having
               an
               
               <div class="code e534">attribute()</div> type and suitable name/value can be defined, such as
               
               <div class="code e535">$p.grounded</div> whose value is 
               <div class="code e536">@s:posture="grounded"</div>. Moreover, the
               most common 'stream failure' results from 
               <div class="emphasis e537">roaming</div> posture and
               
               <div class="emphasis e538">free-ranging</div> sweep, so this is abbreviated: 
               <div class="code e539">$RFR =
                  ($p.roaming,$s.free-ranging)
               </div>. Using these variables when setting properties reduces
               typing errors extensively, as the complier will of course complain about undefined
               variables. 
            </div>
            <div class="para e540">The generic form of processing is a template of the following canonical
               structure:
            </div>
            <div class="figure e541" xml:id="generic.posture.sweep">
               <div class="title e542">Generic assessment of posture and sweep</div>
               <div class="programlisting e543" xml:space="preserve">&lt;xsl:template match="
                  <div class="emphasis e544">construct</div>" mode="addPosture"&gt;
                  &lt;xsl:param name="contextPosture" as="xs:string?" tunnel="yes"/&gt;  
                  &lt;xsl:variable name="children" as="element()*"&gt;
                  &lt;xsl:apply-templates select="*" mode="#current"/&gt;
                  &lt;/xsl:variable&gt;     
                  &lt;xsl:copy&gt;
                  &lt;xsl:call-template name="expr-init"/&gt;
                  
                  <div class="emphasis e545">    Code to decide posture sweep and return:
                     i) suitable @s:posture, @s:sweep
                     ii) $children, in document order, each appropriately decorated.
                  </div>
                  &lt;/xsl:template&gt;
               </div>
            </div>
            <div class="para e546">Usually all children are evaluated, sometimes when focus changes, altering the
               
               <div class="emphasis e547">context posture</div> for their evaluation. Then the result is constructed
               as a copy of the original node, a series of initial attributes (all existing attributes,
               a
               hyperlink to the appropriate section of the specification, the context posture etc.)
               are
               written on by the template 
               <div class="code e548">expr-init</div>, followed by the calculated posture and
               sweep, again as attributes, and finally the evaluated children are added.
            </div>
            <div class="para e549">Currently there are 12 primary templates of for assessing 
               <div class="code e550">xsl:*</div> XSLT
               instructions and 18 for processing 
               <div class="code e551">xp:*</div> XPath expression constructs. Many of
               these make calls on the General Streamability Rules.
            </div>
            <div class="para e552">A subsidiary property needed for analysis, 
               <div class="emphasis e553">usage</div>, described below,
               is written on to the tree by push-processing in mode 
               <div class="code e554">addUsage</div>, before the main
               evaluating is performed, again through mostly push-processing in mode
               
               <div class="code e555">addPosture</div>. 
            </div><a name="UsageANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e556">
               <div class="title e557">Usage</div>
               <div class="para e558">Constructs act as 
                  <div class="emphasis e559">operands</div> for their parents (or sometimes
                  ancestors) and as such the parent can use the information from the operand in several
                  ways, described as the 
                  <div class="emphasis e560">usage</div> property, which again partially quoting
                  
                  <div class="xref e561" linkend="Kay"></div>, can take the following values:
               </div>
               <div class="itemizedlist e562">
                  <div class="listitem e563">
                     <div class="para e564">
                        <div class="emphasis e565">Absorption</div>: the parent expression makes use of information
                        from the entire sub-tree rooted at nodes returned by the operand expression.
                     </div>
                  </div>
                  <div class="listitem e566">
                     <div class="para e567">
                        <div class="emphasis e568">Inspection</div>: the parent expression makes use of properties of
                        the nodes returned by the operand expression that can be established while positioned
                        at a node's start tag.
                     </div>
                  </div>
                  <div class="listitem e569">
                     <div class="para e570">
                        <div class="emphasis e571">Transmission</div>: the parent expression returns nodes delivered
                        by the operand expression.
                     </div>
                  </div>
                  <div class="listitem e572">
                     <div class="para e573">
                        <div class="emphasis e574">Navigation</div>: the parent expression performs arbitrary
                        reordering of the returned nodes, or navigates away from them in arbitrary
                        ways.
                     </div>
                  </div>
               </div>
               <div class="para e575">As these properties are used quite extensively, the constructs in the tree are
                  decorated with an 
                  <div class="code e576">@s:usage</div> attribute in a single pass before posture and
                  sweep is assessed, by consulting declarations and suitable maps.
               </div>
            </div><a name="GeneralStreamabilityRulesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e577" xml:id="GSR">
               <div class="title e578">General Streamability Rules</div>
               <div class="para e579">Rules for assessing posture and sweep for many of the constructs devolve to some
                  assessment of a set of more general rules with different configured treatments for
                  the
                  individual operands of the construct. For example:
               </div>
               <div class="popupBox e580">
                  <div class="popupLabel" onmouseover="$('#d1e1278').show('1000');" onmouseout="$('#d1e1278').hide('1000');">[ blockquote ]</div>
                  <div id="d1e1278" style="display: none;">
                     <div class="blockquote">
                        <div class="title e581">19.8.4.37 Streamability of xsl:value-of</div>
                        <div class="para e582">The posture and sweep of 
                           <div class="code e583">xsl:value-of</div> follow the general streamability
                           rules. The operand roles and their usages are as follows:
                        </div>
                        <div class="itemizedlist e584">
                           <div class="listitem e585">
                              <div class="para e586">The 
                                 <div class="code e587">select</div> expression (usage
                                 
                                 <div class="emphasis e588">absorption</div>)
                              </div>
                           </div>
                           <div class="listitem e589">
                              <div class="para e590"> The 
                                 <div class="code e591">separator</div> attribute value template (usage
                                 
                                 <div class="emphasis e592">absorption</div>)
                              </div>
                           </div>
                           <div class="listitem e593">
                              <div class="para e594">The contained sequence constructor (usage
                                 
                                 <div class="emphasis e595">absorption</div>).
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e596">The General Streamability Rules, part of which is shown in 
                  <div class="xref e597" linkend="sample-e"></div>
                  are a nested tree of calculations and decisions, up to six levels deep, with 25 separate
                  steps and cases (many of which are applied iteratively to each operand) and an embedded
                  decision table. To apply these for a given construct we need to i) identify which
                  of the
                  child (or sometimes descendant) constructs have influence and what are their mode
                  of
                  
                  <div class="quote e598">usage</div>.
               </div>
               <div class="para e599">While expanding XPath expressions the role of a construct was attached to the parse
                  tree as an 
                  <div class="code e600">@s:role</div> attribute, so simple XPath search can extract necessary
                  operands. In this case we have already given every node a unique 
                  <div class="code e601">id</div> so simple
                  maps of 
                  <div class="code e602">id</div> and associated property can be used.
               </div>
               <div class="para e603">The GSR are implemented as a single named XSLT template, which has the following
                  features:
               </div>
               <div class="itemizedlist e604">
                  <div class="listitem e605">
                     <div class="para e606">The context item is assumed to be the construct element to be assessed.</div>
                  </div>
                  <div class="listitem e607">
                     <div class="para e608">The following parameters can be supplied, or may be derived:</div>
                     <div class="variablelist e609">
                        <div class="varlistentry e610">
                           <div class="term e611">contextPosture</div>
                           <div class="listitem e612">
                              <div class="para e613">The context posture from the parent</div>
                           </div>
                        </div>
                        <div class="varlistentry e614">
                           <div class="term e615">operands</div>
                           <div class="listitem e616">
                              <div class="para e617">a set of descendant items that should be considered as operands. These can
                                 be searched for through a push mode 
                                 <div class="code e618">GS-find-operands</div>.
                              </div>
                           </div>
                        </div>
                        <div class="varlistentry e619">
                           <div class="term e620">context-postures</div>
                           <div class="listitem e621">
                              <div class="para e622">A map of operand 
                                 <div class="code e623">id</div>s and the associated or required posture for
                                 the operand having that 
                                 <div class="code e624">id</div>. (This becomes useful for complex
                                 instructions such as 
                                 <div class="code e625">xsl:apply-templates</div> or
                                 
                                 <div class="code e626">xsl:iterate</div> where the operands can include sections of attribute
                                 value templates within child elements, and postures can vary across the set of
                                 operands.)
                              </div>
                           </div>
                        </div>
                        <div class="varlistentry e627">
                           <div class="term e628">children</div>
                           <div class="listitem e629">
                              <div class="para e630">Possible children of the construct, which will otherwise be evaluated
                                 recursively.
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e631">The first action in this template is to assess the sweeps of all the operands,
                  corresponding to step 1 of 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e632" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#dt-general-streamability-rules" xlink:show="new" xlink:type="simple">GSR</div>,
                  consisting of some dozen tests and a table lookup for each operand. After such processing
                  each operand element will be decorated with attributes 
                  <div class="code e633">@s:sweep</div> (a possibly
                  adjusted sweep), 
                  <div class="code e634">@s:sweepOriginal</div> (when the sweep was changed by the GSR
                  rules), 
                  <div class="code e635">@s:usageOriginal</div> (when the usage has been altered likewise) and
                  
                  <div class="code e636">@s:potentialConsumer</div> if the operand is so judged from rule
                  
                  <div class="code e637">1.c</div>. Parts of the code to do this are:
               </div>
               <div class="figure e638" xml:id="GSR.code.sweep">
                  <div class="title e639">Calculating sweep</div>
                  <div class="programlisting e640" xml:space="preserve">&lt;xsl:variable name="table.1.b.iii.B" as="map(*)"
                     select="map{
                     'grounded' := map{'absorption':='S',            'inspection':='S', 'transmission':='S',
                     'navigation':='S'},
                     'climbing' := map{'absorption':='free-ranging', 'inspection':='S', 'transmission':='S',
                     'navigation':='free-ranging'},
                     'striding' := map{'absorption':='consuming',    'inspection':='S', 'transmission':='S',
                     'navigation':='free-ranging'},
                     'crawling' := map{'absorption':='free-ranging', 'inspection':='S', 'transmission':='S',
                     'navigation':='free-ranging'}
                     }"/&gt;
                     &lt;xsl:variable name="swept" as="item()*"&gt;
                     &lt;xsl:for-each select="$children/descendant-or-self::*[@id=$operands.id]"&gt;
                     &lt;xsl:variable name="T" select="@s:staticType"/&gt;
                     &lt;xsl:variable name="P" select="@s:posture"/&gt;
                     &lt;xsl:variable name="S" select="@s:sweep"/&gt;
                     &lt;xsl:variable name="U" select="@s:usage"/&gt;
                     &lt;xsl:copy&gt;
                     &lt;xsl:sequence select="@*"/&gt;
                     &lt;xsl:attribute name="s:sweepOriginal" select="@s:sweep" on-empty="()"/&gt;
                     &lt;xsl:attribute name="s:usageOriginal" select="@s:usage" on-empty="()"/&gt;
                     &lt;xsl:variable name="results" as="map(*)*"&gt;
                     &lt;xsl:sequence select="map{'posture':=$P, 'USAGE':=$U}"/&gt;
                     &lt;xsl:choose&gt;
                     &lt;xsl:when test="$S = 'free-ranging' or $P = 'roaming'"&gt;
                     &lt;xsl:sequence select="map{'rule':='1.b.i','sweep':='free-ranging'}"/&gt;
                     &lt;/xsl:when&gt;
                     &lt;xsl:when test="$P = 'grounded'"&gt;
                     &lt;xsl:sequence select="map{'rule':='1.b.ii','sweep':= @s:sweep}"/&gt;
                     &lt;/xsl:when&gt;
                     &lt;xsl:otherwise&gt;
                     &lt;xsl:variable name="childless.absorption" select="$U = 'absorption' and xp:is-childless-type($T)"/&gt;
                     &lt;xsl:variable name="Up" select="if($childless.absorption) then 'inspection' else $U"/&gt;
                     &lt;xsl:sequence select="map{'rule' := '1.b.iii.A.' || (if($childless.absorption) then
                     'I' else 'II'),
                     'usage':= if(empty($Up)) then 'NO USAGE DEFINED' else $Up}"/&gt;
                     &lt;xsl:if test="exists($Up) and exists($P)"&gt;
                     &lt;xsl:sequence select="map{'rule':=string-join(('1.b.iii.B',($P,$Up)!$table.axes(.)!string(.)),'.')}"/&gt;
                     &lt;xsl:if test="map:keys($table.1.b.iii.B) = $P"&gt;
                     &lt;xsl:variable name="row" select="$table.1.b.iii.B($P)"/&gt;
                     &lt;xsl:if test="map:keys($row)=$Up"&gt;
                     &lt;xsl:sequence select="map{
                     'sweep':= (let $s := $table.1.b.iii.B($P)($Up) return (if($s eq 'S') then @s:sweep
                     else $s))}"/&gt;
                     &lt;/xsl:if&gt;
                     &lt;/xsl:if&gt;
                     &lt;/xsl:if&gt;
                     &lt;/xsl:otherwise&gt;
                     &lt;/xsl:choose&gt;
                     &lt;/xsl:variable&gt;
                     &lt;xsl:attribute name="s:sweep" select="$results!.('sweep')"/&gt;
                     &lt;xsl:attribute name="s:usage" select="$results!.('usage')" on-empty="()"/&gt;
                     &lt;xsl:attribute name="s:generalOperand" select="$results!.('rule')" separator=","/&gt;
                     &lt;xsl:choose&gt;
                     &lt;xsl:when test="$results!.('sweep')='consuming'"&gt;
                     &lt;xsl:attribute name="s:generalOperand" select="$results!.('rule'),'1.c.i'" separator=","/&gt;
                     &lt;xsl:attribute name="s:potentialConsumer"/&gt;
                     &lt;/xsl:when&gt;
                     &lt;xsl:when test="@s:usage='transmission' and not(@s:posture = 'grounded')"&gt;
                     &lt;xsl:attribute name="s:generalOperand" select="$results!.('rule'),'1.c.ii'" separator=","/&gt;
                     &lt;xsl:attribute name="s:potentialConsumer"/&gt;
                     &lt;/xsl:when&gt;
                     &lt;/xsl:choose&gt;
                     &lt;xsl:sequence select="*|text()"/&gt;
                     &lt;/xsl:copy&gt;
                     &lt;/xsl:for-each&gt;
                     &lt;/xsl:variable&gt;
                  </div>
               </div>
               <div class="para e641">What 
                  <div class="xref e642" linkend="GSR.code.sweep"></div> is showing is that the code generally tries to
                  reflect the structure of the rules as laid out in the specification, even using a
                  map to
                  represent table 
                  <div class="code e643">1.b.iii.B</div>, and with the same abbreviations
                  <div class="popupBox e644">
                     <div class="popupLabel" onmouseover="$('#d1e1411').show('1000');" onmouseout="$('#d1e1411').hide('1000');">[ footnote ]</div>
                     <div id="d1e1411" style="display: none;">
                        <div class="footnote">
                           <div class="para e645">It would be comparatively trivial to parse that map from an even simpler
                              representation, possibly even from the specification itself.
                           </div>
                        </div>
                     </div>
                  </div>. Note that the intermediate variable 
                  <div class="code e646">$results</div> computed for each
                  operand is typed as a sequence of 
                  <div class="code e647">item()</div> but is actually a sequence of
                  
                  <div class="code e648">map()*</div>, which can be used to transmit heterogeneous information, in this
                  case both the properties of direct interest (e.g. 
                  <div class="emphasis e649">sweep</div>) but also the
                  rule-invoked indicators. Using the XPath simple map operator, we can extract multiple
                  values through an expression such as 
                  <div class="code e650">$results!.('rule')</div>.
               </div>
               <div class="note e651">
                  <div class="para e652">It would be possible to use the same technique here as is used for posture and sweep
                     attributes described above, i.e. defining variables which are map entries, e.g.
                     
                     <div class="code e653">$map:p.grounded := map{'posture':='grounded'}</div>, which would reduce the
                     effect of typing errors.
                  </div>
               </div>
               <div class="para e654">Assessing the posture is handled similarly, checking the conditions of section 2 over
                  the sweep-assessed operands. Finally the posture and sweep of the construct is determined,
                  written onto a copy of the construct element (together with GSR provenance from section
                  2)
                  and the children are placed in the new parent. 
               </div>
            </div><a name="EvaluatingexpressionsandinstructionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e655">
               <div class="title e656">Evaluating expressions and instructions</div>
               <div class="para e657">Most XPath expression terms can be evaluated with the General Streamability Rules,
                  suitable usage having been written onto operands from the maps described in 
                  <div class="xref e658" linkend="declarative.tables"></div>. Others require more specialist treatment, such as the
                  
                  <div class="code e659">ForExpr</div> for which the test can be two-stage:
               </div>
               <div class="figure e660" xml:id="ForExpr">
                  <div class="title e661">Posture and sweep of the ForExpr</div>
                  <div class="programlisting e662" xml:space="preserve">&lt;xsl:choose&gt;
                     &lt;xsl:when test="$children[2]/@s:posture = 'grounded'"&gt;
                     &lt;xsl:call-template name="general-streamability.operands"&gt;
                     &lt;xsl:with-param name="children" as="item()*" select="$children"/&gt;
                     &lt;/xsl:call-template&gt;
                     &lt;/xsl:when&gt;
                     &lt;xsl:otherwise&gt;
                     &lt;xsl:sequence select="$RFR,$children"/&gt;
                     &lt;/xsl:otherwise&gt;
                     &lt;/xsl:choose&gt;
                  </div>
               </div>
               <div class="para e663">where if the return (the second child) is grounded, the General Streamability Rules
                  apply, otherwise the construct is 
                  <div class="code e664">roaming</div> and
                  
                  <div class="emphasis e665">free-ranging</div>. The most interesting and perhaps important, are the
                  
                  <div class="code e666">AxisStep</div> terms, which really define movement around the input tree. The
                  tests (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e667" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/#streamability-of-axis-steps" xlink:show="new" xlink:type="simple">19.8.7.7 Streamability of Axis Steps</div>) are a little more complex and involve six
                  cases and a tabular form, relating context posture and the axis of travel. Whilst
                  this
                  could perhaps be interpreted, in the end an extended 
                  <div class="code e668">xsl:choose</div> was the
                  simplest form.
               </div>
               <div class="para e669">XSLT instructions tend to be more complex in their streamability than XPath
                  expressions, so while some (e.g. 
                  <div class="code e670">xsl:copy</div>) are analysed completely with the
                  General Streamability Rules, many require specialist templates, especially to handle
                  issues such as instruction configuration elements (e.g. 
                  <div class="code e671">xsl:sort</div>) and
                  determining what are the active operands for streamability. To make these somewhat
                  more
                  coherent, a number of helper functions are used: 
               </div>
               <div class="variablelist e672">
                  <div class="varlistentry e673">
                     <div class="term e674">xp:AVT()</div>
                     <div class="listitem e675">
                        <div class="para e676">Returns all the nodes of the input that represent 
                           <div class="emphasis e677">attribute value
                              templates
                           </div> in the instruction.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e678">
                     <div class="term e679">xp:active()</div>
                     <div class="listitem e680">
                        <div class="para e681">Returns all operands of input nodes that are 
                           <div class="emphasis e682">active</div> in
                           creating a sequence (
                           <div class="code e683">@select</div> or
                           
                           <div class="code e684">s:sequence-constructor</div>)
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e685">Similarly, some of the common instruction-varying actions can be cast as templates
                  in
                  a specific mode, such as 
                  <div class="code e686">GS-find-operands</div>, which finds the appropriate
                  operands for an instruction for application of General Streamability Rules. For example
                  
               </div>
               <div class="figure e687" xml:id="find.GSR.operands">
                  <div class="title e688">Find operands for General Streamability Rules</div>
                  <div class="programlisting e689" xml:space="preserve"> &lt;xsl:template match="xsl:apply-templates" mode="GS-find-operands"&gt;
                     &lt;xsl:sequence select="xp:active(.)|
                     xp:active(xsl:with-param)|xp:active(xsl:sort)|xp:AVT(xsl:sort)"/&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               <div class="para e690">where for 
                  <div class="code e691">xsl:apply-templates</div> operands could appear i) as active parts of
                  the instruction itself (in this case 
                  <div class="code e692">@select</div>), ii) within active sections of
                  
                  <div class="code e693">xsl:param</div> and 
                  <div class="code e694">xsl:sort</div> options (either as 
                  <div class="code e695">@select</div>
                  or sequence constructors) or iii) within 
                  <div class="emphasis e696">attribute value templates</div>
                  within the 
                  <div class="code e697">xsl:sort</div> declarations (typically in attributes such as
                  
                  <div class="code e698">@order</div>). 
               </div>
            </div><a name="EvaluatingbuiltinfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e699">
               <div class="title e700">Evaluating built-in functions</div>
               <div class="para e701">Calls to built-in functions (mostly from XPath, but a few, such as 
                  <div class="code e702">key()</div>,
                  that are specialist for XSLT) have to be examined in terms of both the streamability
                  properties of their arguments and the use the function makes of the results of those
                  arguments. For most functions this can be expressed as an evaluation of the General
                  Streamability Rules, with suitable 
                  <div class="emphasis e703">usage</div>. In the specification this
                  is described as a list with an entry of each function using a proforma representation,
                  e.g. 
                  <div class="quote e704">
                     <div class="code e705">fn:fold-left(N,A,I)</div>
                  </div> which indicates that the arguments
                  have usage 
                  <div class="emphasis e706">navigation</div>, 
                  <div class="emphasis e707">absorption</div> and
                  
                  <div class="emphasis e708">inspection</div> respectively. Currently these usages are written onto
                  the arguments of the function definitions in 
                  <div class="code e709">function-catalog.xml</div> whence they
                  are converted into maps as described in 
                  <div class="xref e710" linkend="functions"></div>, but in theory these
                  properties could be read from the specification itself. For some dozen functions (such
                  as
                  
                  <div class="code e711">last()</div>) there are specialist rules - these are handled by simple templates: 
               </div>
               <div class="figure e712" xml:id="function.last">
                  <div class="title e713">Streamability of last()</div>
                  <div class="programlisting e714" xml:space="preserve">&lt;xsl:template match="xp:FunctionCall[@name='last']" mode="addPosture"&gt;
                     &lt;xsl:param name="contextPosture" as="xs:string?" tunnel="yes"/&gt;
                     &lt;xsl:copy&gt;
                     &lt;xsl:call-template name="expr-init"/&gt;
                     &lt;xsl:sequence
                     select="if($contextPosture = ('striding','crawling','roaming'))
                     then $RFR else ($p.grounded,$s.motionless)"/&gt;
                     &lt;/xsl:copy&gt;
                     &lt;/xsl:template&gt;
                  </div>
               </div>
               <div class="para e715">where 
                  <div class="code e716">$RFR</div> denotes 
                  <div class="emphasis e717">roaming</div> and
                  
                  <div class="emphasis e718">free-ranging</div> as described earlier.
               </div>
            </div><a name="DeterminingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e719">
               <div class="title e720">Determining 
                  <div class="emphasis e721">guaranteed streamabilty</div>
               </div>
               <div class="para e722">Finally all the components of a top-level 
                  <div class="code e723">xsl:stream</div> or
                  
                  <div class="code e724">xsl:template</div> have been evaluated against the rules and any sequence
                  constructor can be examined for a 
                  <div class="emphasis e725">grounded</div> posture and a template
                  
                  <div class="code e726">@match</div> checked for a 
                  <div class="emphasis e727">motionless</div> sweep. The element is
                  marked 
                  <div class="code e728">@s:streamable</div> with the boolean satisfaction of these conditions,
                  whence the analysis of that sub-tree is complete. Later display can give visual
                  indication. For templates of course they form a modal group which might be invoked
                  by
                  other templates - the mode is marked streamable (in a map) only if i) the mode is
                  declared
                  streamable and ii) all templates within that mode are themselves proven guaranteed
                  streamable
                  <div class="popupBox e729">
                     <div class="popupLabel" onmouseover="$('#d1e1618').show('1000');" onmouseout="$('#d1e1618').hide('1000');">[ footnote ]</div>
                     <div id="d1e1618" style="display: none;">
                        <div class="footnote">
                           <div class="para e730">Mutually interacting streamable modes are not supported in this tool.</div>
                        </div>
                     </div>
                  </div>.
               </div>
            </div>
         </div>
      </div><a name="InteractiveDisplayANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e731">
         <div class="title e732">Interactive Display</div>
         <div class="para e733">Once the analysis has been completed, the result needs to be displayed. As all the
            information is attached to the expanded XLST/expression tree as namespaced attributes,
            we
            could either i) display the original program in some serialised form and arrange some
            linkage
            from that serialisation to appropriate points in the 'shadow tree' or ii) display
            the whole
            expanded tree including properties as a serialisation and selectively display desired
            sections. The second appeared to be the simplest route, albeit at the cost of a 
            <div class="emphasis e734">very
               large
            </div> serialised form even for modest programs. 
         </div><a name="SerialisingtoHTMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e735">
            <div class="title e736">Serialising to HTML</div>
            <div class="para e737">The tree is serialised to be displayed within a 
               <div class="code e738">pre</div> section of the web
               page, by a specialist XSLT-coded serialiser with the following features:
            </div>
            <div class="itemizedlist e739">
               <div class="listitem e740">
                  <div class="para e741">As the tree is well-formed XML, and space is at a premium, indentation is strict and
                     closing tags are omitted.
                  </div>
               </div>
               <div class="listitem e742">
                  <div class="para e743">Line numbering follows the document order of elements in the original XSLT and is
                     displayed at the start of each corresponding line in the serialisation.
                  </div>
               </div>
               <div class="listitem e744">
                  <div class="para e745">A fold/unfold group (as a 
                     <div class="code e746">span</div> containing two span-contained images,
                     only one of which should be visible) follows for any element in the result tree that
                     has
                     children.
                  </div>
               </div>
               <div class="listitem e747">
                  <div class="para e748">The element name and primary attributes are written surrounded by classifying
                     
                     <div class="code e749">span</div>s - some note of line length is considered and line-breaks can be
                     interpolated. Some names are shortened and the information is attached to the span
                     class, e.g. the 
                     <div class="code e750">xp:</div> prefix dropped from XPath constructs.
                  </div>
               </div>
               <div class="listitem e751">
                  <div class="para e752">The span of elements decorated 
                     <div class="code e753">@s:streamable</div> (i.e.
                     
                     <div class="code e754">xsl:template</div>, 
                     <div class="code e755">xsl:stream</div>) are classified as
                     
                     <div class="code e756">xslstreamyes</div> or 
                     <div class="code e757">xslstreamno</div> as appropriate. 
                  </div>
               </div>
               <div class="listitem e758">
                  <div class="para e759">All the streaming properties follow, each with an enveloping 
                     <div class="code e760">span</div> and
                     differentiating classes: e.g. 
                     <div class="code e761">class="streamProperty posture"</div>. Name/values
                     for these properties are simplified, e.g. 
                     <div class="code e762">s:posture="grounded"</div> displays as
                     
                     <div class="code e763">p:grounded</div>. 
                  </div>
               </div>
               <div class="listitem e764">
                  <div class="para e765">Specification hyperlinks are cast as 
                     <div class="code e766">a[@href]</div> elements around the
                     appropriate display text. 
                  </div>
               </div>
               <div class="listitem e767">
                  <div class="para e768">All the children of an element exist within a 
                     <div class="code e769">span
                        class="XMLBody|XSLBody"
                     </div> on the line following the element head. Thus when
                     folding an element this 
                     <div class="code e770">span</div> is set to 
                     <div class="code e771">style="display:none"</div>.
                     This provides a consistent model for fold/unfold, albeit at the cost of an additional
                     nested 
                     <div class="code e772">span</div> for every element.
                  </div>
               </div>
            </div>
            <div class="para e773">The styling is defined by a CSS stylesheet that exploits these classes, starting with
               the 
               <div class="code e774">display</div> styling all XPath expansions and streaming properties set to
               
               <div class="code e775">none</div>
               <div class="popupBox e776">
                  <div class="popupLabel" onmouseover="$('#d1e1721').show('1000');" onmouseout="$('#d1e1721').hide('1000');">[ footnote ]</div>
                  <div id="d1e1721" style="display: none;">
                     <div class="footnote">
                        <div class="para e777">For large stylesheets 'top-level' constructs (e.g. 
                           <div class="code e778">xsl:template</div>) could
                           of course be defined to display in a folded state. The streamability of such entities
                           would still be visible as red/green backgrounds of course.
                        </div>
                     </div>
                  </div>
               </div>.
            </div>
         </div><a name="InteractivityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e779">
            <div class="title e780">Interactivity</div>
            <div class="para e781">The selection of stylesheets to analyse and examine is a simple use of forms and server
               response, piping the serialised response HTML into a given target frame. More interesting
               is
               the interaction within the analysed stylesheet. There are four types of interaction,
               three
               of which are implemented by triggered templates in a simple Saxon-CE executed XSLT
               2.0
               transform.
            </div>
            <div class="variablelist e782">
               <div class="varlistentry e783">
                  <div class="term e784">Fold/unfold</div>
                  <div class="listitem e785">
                     <div class="para e786">The fold/unfold buttons are intercepted by 
                        <div class="code e787"> &lt;xsl:template
                           match="span[@class='folder']/span[@class=('collapse','expand')]"
                           mode="ixsl:onclick"&gt;
                        </div> which arranges to swap the visibility of the
                        
                        <div class="emphasis e788">collapse</div> and 
                        <div class="emphasis e789">expand</div> buttons, and then
                        proceeds to change the display style of the following 
                        <div class="quote e790">body</div> span
                        (
                        <div class="code e791">@class=('XMLBody','XSLBody')</div>) accordingly.
                     </div>
                  </div>
               </div>
               <div class="varlistentry e792">
                  <div class="term e793">Expanding XPath expressions</div>
                  <div class="listitem e794">
                     <div class="para e795"> All displays of attributes that contain XPath expressions (and
                        
                        <div class="emphasis e796">attribute value templates</div> as well) are classed as
                        
                        <div class="code e797">XPExpr</div>, together with an attribute on the span that identifies the
                        
                        <div class="emphasis e798">role</div>. 
                        <div class="code e799">&lt;xsl:template match="span[@class='XPExpr']"
                           mode="ixsl:onclick"&gt;
                        </div> when triggered, searches in the following instruction
                        body serialisation for the 
                        <div class="code e800">span</div> that contains the tree for that
                        expression, marked with a 
                        <div class="code e801">@role</div> attribute, and then toggles the state of
                        the display property.
                     </div>
                  </div>
               </div>
               <div class="varlistentry e802">
                  <div class="term e803">Displaying streaming properties</div>
                  <div class="listitem e804">
                     <div class="para e805">Changes in the state of the check-boxes (which are computed as part of the
                        returned HTML for an analysed stylesheet) are recognised by 
                        <div class="code e806">&lt;xsl:template
                           match="input[@class='showType']" mode="ixsl:onclick"&gt;
                        </div>, which then alter the
                        display state of 
                        <div class="emphasis e807">all</div> the effected stream property spans through
                        
                        <div class="code e808">ixsl:page()//pre//span[@type=$type]</div>, using the
                        
                        <div class="code e809">ixsl:set-attribute</div> instruction. (This also of course changes display
                        state of properties which are invisible for higher reasons, such as being in a folded
                        structure, but it maintains coherence.)
                     </div>
                  </div>
               </div>
               <div class="varlistentry e810">
                  <div class="term e811">Specification hyper-linking</div>
                  <div class="listitem e812">
                     <div class="para e813">As the result HTML has already been decorated with 
                        <div class="code e814">a[@href]</div> links to
                        the appropriate section anchors in the (modified) specification, these links operate
                        outside the purview of the Saxon-CE based stylesheet. The specification is displayed
                        typically in a separate window or tab
                        <div class="popupBox e815">
                           <div class="popupLabel" onmouseover="$('#d1e1807').show('1000');" onmouseout="$('#d1e1807').hide('1000');">[ footnote ]</div>
                           <div id="d1e1807" style="display: none;">
                              <div class="footnote">
                                 <div class="para e816">Under some arrangements with all being displayed in a single tab/window, it is
                                    possible to enrich the explanation of application of the General Streamability
                                    Rules, by highlighting all the rules that were relevant to a particular case. This
                                    requires i) 
                                    <div class="code e817">div</div> grouping of sections of the specification GSR (which
                                    can be done automatically) and ii) altering the display properties of these
                                    
                                    <div class="code e818">div</div> sections. Unfortunately this appears not to be possible (as one
                                    would wish) between different tabs or windows within a browser....
                                 </div>
                              </div>
                           </div>
                        </div>.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e819">The point to note here is that 
               <div class="emphasis e820">all</div> the decisions of 
               <div class="quote e821">display
                  this line?, wrap onto a new line?
               </div> are performed by the browser, requiring a
               minimalist approach from the analysis tool itself. 
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e822">
         <div class="title e823">Conclusion</div>
         <div class="para e824">This paper has described a tool that performs a very detailed and exhaustive analysis
            of
            the streaming properties of an XSLT program, and displays the results in a form where
            a human
            designer might be able to examine these properties to either i) understand why a program
            cannot stream or ii) get a better feel for the interaction between XSLT instructions
            and XPath
            expressions and streaming behaviour.
         </div>
         <div class="para e825">But it could also be considered as an example of analysing a program (or other data
            structure) for certain properties within an XML-based framework, using a tree-based
            'parsing'
            of the program as the main data structure, adding properties as attributes and processing
            the
            tree in a generally top-down recursive manner
            <div class="popupBox e826">
               <div class="popupLabel" onmouseover="$('#d1e1832').show('1000');" onmouseout="$('#d1e1832').hide('1000');">[ footnote ]</div>
               <div id="d1e1832" style="display: none;">
                  <div class="footnote">
                     <div class="para e827">A critical requirement might be that referential mechanisms and dependencies (e.g.
                        variables) follow descendant or following-sibling scoping.
                     </div>
                  </div>
               </div>
            </div>. Thus some of the lessons from this tool might be pertinent to other situations,
            which are normally the province of opaque compilers, such as reachability analysis.
         </div><a name="Doingwhatthecompiler(usually)doesn'tANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e828">
            <div class="title e829">Doing what the compiler (usually) doesn't</div>
            <div class="para e830">A comformant XSLT compiler supporting streaming of course has to apply these rules
               to
               check streamability
               <div class="popupBox e831">
                  <div class="popupLabel" onmouseover="$('#d1e1841').show('1000');" onmouseout="$('#d1e1841').hide('1000');">[ footnote ]</div>
                  <div id="d1e1841" style="display: none;">
                     <div class="footnote">
                        <div class="para e832">Actually they are permitted to extend the cases in which they can stream, but they
                           must support cases which are 
                           <div class="emphasis e833">guaranteed streamable</div> according to the
                           specification rules.
                        </div>
                     </div>
                  </div>
               </div> but does not have to explain why a construct cannot be streamed. This tool
               effectively animates the analysis leaving a trail both of its conclusions, in results
               and
               intermediate data, and pointers to the relevant rules that were applied, making it
               less of a
               hit-and-miss affair for the designer to acheive his streamability goals. Of course
               a
               compiler could do similar (e.g. Saxon has an 
               <div class="code e834">-explain</div> option that displays the
               optimised execution plan) but this tool does this independently of any implementation,
               as
               the rules are strictly part of the specification. 
            </div>
         </div><a name="ControllingthevolumeofdisplayeddataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e835">
            <div class="title e836">Controlling the volume of displayed data</div>
            <div class="para e837">One of the problems was the sheer amount of data to be viewed/displayed – some 8-10
               additional properties, stored as attributes for every construction element, both instruction
               and XPath expression. One option was to display all the properties for a single given
               element at a time, perhaps on a status bar, or a popup, but much of the understanding
               of the
               streaming rules in action comes from examining the properties of all the operands
               of a
               construct as an ensemble, together with the relevant rules. I chose to enable entire
               classes
               to be viewed selectively – it certainly permits one to view 
               <div class="quote e838">reverse-cascades</div>
               of usually 
               <div class="code e839">roaming</div> posture propagating from some errant action.
            </div>
            <div class="para e840">Alternatives, that could be programmed relatively easily using more detailed Saxon-CE
               interaction, could show properties for a small portion of the tree at a time (e.g.
               selected
               element, direct children and a limited number of ancestors), or even explore graphical
               symbology and other shorthand forms.
            </div>
         </div><a name="Who&amp;howbesttoprocessXSLT?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e841">
            <div class="title e842">Who &amp; how best to process XSLT?</div>
            <div class="para e843">The problem involved analysis of a program most of whose components are written in
               XML.
               Thus an XSLT enthusiast, such as the author, would reach for that tool as the primary
               instrument. The fact that the program to be analysed was itself XSLT caused very few
               problems, and made several areas easier. 
            </div>
            <div class="para e844">The first issue was how to analyse the XPath expressions. Initially I chose to add
               an
               expansion to Saxon to exploit its 
               <div class="code e845">Expression.explain()</div> method to generate a
               parse tree, but after some success it became clear that a lot of rewrites that Saxon
               was
               doing internally needed to be 
               <div class="quote e846">undone</div> or otherwise modified to get to the
               constructs that streamability required. Then a switch to a parser, written in XSLT
               and
               generated by 
               <div class="xref e847" linkend="REx"></div>, made the situation much clearer and the whole analysis
               solution could be written entirely in non-extended XLST 3.0
               <div class="popupBox e848">
                  <div class="popupLabel" onmouseover="$('#d1e1879').show('1000');" onmouseout="$('#d1e1879').hide('1000');">[ footnote ]</div>
                  <div id="d1e1879" style="display: none;">
                     <div class="footnote">
                        <div class="para e849">To be fair, Mike Kay had suggested 
                           <div class="xref e850" linkend="REx"></div> as a possibility in the
                           initial project outline, but the author had had some experience, before working with
                           Saxonica, on using 
                           <div class="code e851">Expression.explain()</div>, so that was in the first design.
                           
                        </div>
                     </div>
                  </div>
               </div>. 
            </div>
            <div class="para e852">Probably the most useful lesson is that a simple variant of the source XSLT program,
               held as an XML tree, can act as its own parse tree, which can be traversed, read and
               decorated entirely by XSLT programs. Of course properties have to be capable of being
               grounded to effective strings to attach to tree element nodes, which was possible
               even at a
               stretch when the type model moved to a union type. With with a suitable system of
               indexed
               map structures held within the analyser, and keyed through unique ids, even this restriction
               might be overcome.
            </div>
         </div><a name="AsyntacticallycoherentspecificationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e853">
            <div class="title e854">A syntactically coherent specification</div>
            <div class="para e855">Early on in the development it became imperative that there should be some means of
               finding the correct place in the XSLT specification to examine constructs that were
               being
               evaluated, if only for debugging the tool itself. Whilst much of the specification
               is very
               richly hyper-linked internally, there was still an enormous amount of scrolling around,
               losing a place, having to revert to and search through the table of contents (which
               on the
               author's browser occupies some 14 
               <div class="quote e856">pages</div>) all the while trying to retain a
               mental (stack) model in one's head. Could we build a hyperlink from say an
               
               <div class="code e857">xsl:value-of</div> element to the relevant section of the specification?
            </div>
            <div class="para e858">Most fortunately, but certainly by design, many of the sections (in this case
               
               <div class="code e859">19.8.4.37</div> of the December 2013 Working Draft) had hyperlink anchors which
               were extremely coherent, quite fine-grained and followed the scheme
               
               <div class="code e860">#streamability-xsl-</div>
               <div class="emphasis e861">
                  <div class="code e862">{local-name(.)}</div>
               </div>, in this
               case 
               <div class="code e863">#streamability-xsl-value-of</div>. The exceptions (which were often to a parent
               category) could be handled by attributive declarations in a table, such as shown in
               
               <div class="xref e864" linkend="expressionConstructs"></div>. In the case of the General Streamability Rules, the
               combination of nested lists and a table required preprocessing to bury a series of
               anchor
               points (and 
               <div class="code e865">div</div> groupings) to support display.
            </div>
            <div class="para e866">Equally, the existence of and access to, even more definitive documents behind the
               specification, such as 
               <div class="code e867">function-catalog.xml</div>, meant we could latch onto and use
               definitive information, avoiding transcription errors and making it possible for the
               tool to
               track eventual changes in some cases automatically.
            </div>
         </div><a name="ProblemsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e868">
            <div class="title e869">Problems</div>
            <div class="para e870">Apart from the size and apparent complexity of the streamability rules themselves,
               a
               small number of other problems appeared including
            </div>
            <div class="itemizedlist e871">
               <div class="listitem e872">
                  <div class="para e873">the size of the resultant fully-serialised output</div>
               </div>
               <div class="listitem e874">
                  <div class="para e875">debugging the tool itself</div>
               </div>
            </div>
            <div class="para e876">Whilst the analysis of streamability for a modest stylesheet is relatively quick
               (seconds or less), the serialisation, and particularly the browser display of that
               serialisation can be lengthy. A glance at 
               <div class="xref e877" linkend="show-6"></div> shows that each streaming
               property takes about 100 characters to define for display in the current serialised
               form,
               which means each construct (instruction, expression term) takes about 1kB to display.
               (The
               serialisation of the example in 
               <div class="xref e878" linkend="sample-a"></div> is just under 14kB long.) Clearly
               there could be economies in the terms used (class names are over-generous for example)
               and
               some server-performed compression of the results and associated CSS might improve
               matters by
               perhaps a factor of three. With some more active participation from the Saxon-CE stylesheet,
               such as encoding/decoding property values perhaps an order of magnitude could be gained
               <div class="popupBox e879">
                  <div class="popupLabel" onmouseover="$('#d1e1943').show('1000');" onmouseout="$('#d1e1943').hide('1000');">[ footnote ]</div>
                  <div id="d1e1943" style="display: none;">
                     <div class="footnote">
                        <div class="para e880">Technically we might be able to implement the analysis tool in XSLT2.0 and hence
                           consider a total Saxon-CE in-browser solution, but the use of XSLT3.0 facilities
                           (especially mode declarations and maps, as curiously HOFs were confined to a very
                           small
                           number of cases) makes the development very much more straighforward. Of course anyone
                           using streaming must be using XSLT3.0 anyway.
                        </div>
                     </div>
                  </div>
               </div>. 
            </div>
            <div class="para e881">The simplicity of keeping all the analysed data on the XSLT tree and then serialising
               the whole was very effective in getting the tool developed, but an alternative would
               be to
               split off the data just before serialisation and provide that as a separate
               
               <div class="code e882">id</div>-mapped data structure that the Saxon-CE stylesheet would use. 
            </div>
            <div class="para e883">Unsurprisingly early debugging of the tool wasn't extremely easy, as the sheer volume
               of
               data and especially the O(100) different types of instructions and expressions made
               focussing on a single problem difficult. Building the tools as a number of phases
               helped
               (e.g. expanding all the XPath trees, marking the focus control, calculating the static
               type)
               so that successive phases could be checked to 
               <div class="quote e884">mostly</div> work
               <div class="popupBox e885">
                  <div class="popupLabel" onmouseover="$('#d1e1957').show('1000');" onmouseout="$('#d1e1957').hide('1000');">[ footnote ]</div>
                  <div id="d1e1957" style="display: none;">
                     <div class="footnote">
                        <div class="para e886">The main phases expand / focus control / static type / usage / posture &amp; sweep
                           were pretty separable until the new U-type model introduced 
                           <div class="quote e887">usage-dependent
                              type
                           </div> to complement the existing 
                           <div class="quote e888">type-dependent usage</div> . At this
                           point some sections of the type and usage phases had to be merged.
                        </div>
                     </div>
                  </div>
               </div>. However once a certain stage was reached a lot of the further development could
               be carried out merely by altering or expanding tables. 
            </div>
         </div><a name="AcknowledgementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e889">
            <div class="title e890">Acknowledgements</div>
            <div class="para e891">Apart from funding the venture, Mike Kay set me a very interesting and what turned
               out
               to be a surprisingly complex challenge, but one of XSLT working on XSLT that I very
               much
               enjoy. Florent Georges deserves thanks for the excellence of, and excellent support
               for, the
               Servlex webapp delivery mechanism which made mounting the tool as a web service
               comparatively plain (all XML) sailing, with 
               <div class="emphasis e892">no PHP or Java required</div>!
               O'Neil Delpratt was his usual cheerful self in helping get the tool installed on Saxonica
               servers.
            </div>
         </div><a name="Quovadis?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e893">
            <div class="title e894">Quo vadis?</div>
            <div class="para e895">During the writing of this paper it became clear that more of the tool's behaviour
               could
               be derived from direct interpretation of some sections of the specification, thanks
               mainly
               to the coherence in its logical structure. This would increase the tolerance of the
               tool to
               (modest) changes in the specification. Changes to the serialisation and storage outlined
               above could be helpful also.
            </div>
            <div class="para e896">Whilst the original intention of the tool was to enable a given stylesheet to be
               analysed, perhaps its future value is really in being able to increase understanding
               of what
               the essence of the streamability rules is, by providing a highly detailed
               
               <div class="quote e897">walkthrough</div> of their application on fragments of XSLT of interest. It might
               also be interesting to see whether a rudimentary 
               <div class="quote e898">expert system</div>, in the form
               of patterns matching some design metaphors (e.g. adding a 
               <div class="code e899">copy()</div> action to
               avoid returning nodes from the input) might be able to suggest alterations that might
               enable
               streamability where originially this cannot be guaranteed. 
            </div>
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e900">
         <div class="title e901">References</div>
         <div class="bibliomixed e902" xml:id="Braaksma1" xreflabel="Braaksma1">Braaksma, Abel: 
            <div class="quote e903">XSLT 3.0 Streaming
               for the masses
            </div> [online] XML Prague 2014 proceedings, pp29–80,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e904" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf</div>
            
         </div>
         <div class="bibliomixed e905" xml:id="Braaksma2" xreflabel="Braaksma2">Braaksma, Abel: 
            <div class="quote e906">Streaming Design
               Patterns or: How I Learned to Stop Worrying and Love the Stream
            </div> [online] XML London
            2014 proceedings, pp24–52,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e907" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://xmllondon.com/2014/xmllondon-2014-proceedings.pdf</div>
            
         </div>
         <div class="bibliomixed e908" xml:id="Kay" xreflabel="Kay">Kay, Michael: 
            <div class="quote e909">Streaming in the Saxon XSLT
               Processor
            </div>[online] XML Prague 2014 proceedings, pp81–102
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e910" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf</div>
            
         </div>
         <div class="bibliomixed e911" xml:id="REx" xreflabel="REx">Rademacher, Gunther: 
            <div class="quote e912">REx Parser
               Generator
            </div>[online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e913" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.bottlecaps.de/rex/</div>
            
         </div>
         <div class="bibliomixed e914" xml:id="Servlex" xreflabel="Servlex">Georges, Florent: 
            <div class="quote e915">Servlex: (: Web
               Applications and REST Services Framework for XQuery, XProc and XSLT. :)
            </div>[online]
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e916" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://serlvex.net</div>
            
         </div>
      </div>
   </div>
</div>