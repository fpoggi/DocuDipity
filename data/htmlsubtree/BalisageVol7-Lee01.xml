<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#JXON:anArchitectureforSchemaandAnnotationDrivenJSON/XMLBidirectional%0A%09%09TransformationsANCHOR" name="JXON:anArchitectureforSchemaandAnnotationDrivenJSON/XMLBidirectional%0A%09%09TransformationsTOC">JXON: an Architecture for Schema and Annotation Driven JSON/XML Bidirectional
               		Transformations</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionJXONANCHOR" name="IntroductionJXONTOC">Introduction - JXON</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DivingInANCHOR" name="DivingInTOC">Diving In</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#JXONattemptstosolvethisproblemANCHOR" name="JXONattemptstosolvethisproblemTOC">JXON attempts to solve this problem</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#JSON/XMLwhat'stheproblem?ANCHOR" name="JSON/XMLwhat'stheproblem?TOC">JSON/XML what's the problem?</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AnonymousvaluesANCHOR" name="AnonymousvaluesTOC">Anonymous values</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ArraysANCHOR" name="ArraysTOC">Arrays</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ImplicitTypes(eg&#34;DuckTyping&#34;)ANCHOR" name="ImplicitTypes(eg&#34;DuckTyping&#34;)TOC">Implicit Types (e.g. "Duck Typing")</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IdentifiersANCHOR" name="IdentifiersTOC">Identifiers</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#NamespacesANCHOR" name="NamespacesTOC">Namespaces</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ProcessingInstructionsANCHOR" name="ProcessingInstructionsTOC">Processing Instructions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AttributesANCHOR" name="AttributesTOC">Attributes</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#CharacterSetANCHOR" name="CharacterSetTOC">Character Set</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#CommentsANCHOR" name="CommentsTOC">Comments</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DocumentNodeANCHOR" name="DocumentNodeTOC">Document Node</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SerializationANCHOR" name="SerializationTOC">Serialization</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#EncodingsANCHOR" name="EncodingsTOC">Encodings</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExistingDesignsandImplementationsANCHOR" name="ExistingDesignsandImplementationsTOC">Existing Designs and Implementations</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#LimitationsofexistingimplementationsANCHOR" name="LimitationsofexistingimplementationsTOC">Limitations of existing implementations</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RationaleandUseCasesANCHOR" name="RationaleandUseCasesTOC">Rationale and Use Cases</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#CategoriesofTransformationsANCHOR" name="CategoriesofTransformationsTOC">Categories of Transformations</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#UnidirectionalTransformationsANCHOR" name="UnidirectionalTransformationsTOC">Unidirectional Transformations</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#BidirectionalTransformationsANCHOR" name="BidirectionalTransformationsTOC">Bi-directional Transformations</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RoundtriptransformationsANCHOR" name="RoundtriptransformationsTOC">Round trip transformations</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UseCasesforXML/JSONtransformationsANCHOR" name="UseCasesforXML/JSONtransformationsTOC">Use Cases for XML/JSON transformations</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#MessagepassingANCHOR" name="MessagepassingTOC">Message passing</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XMLContentDatabasesANCHOR" name="XMLContentDatabasesTOC">XML Content Databases</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#HTML/XHTMLANCHOR" name="HTML/XHTMLTOC">HTML/XHTML</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XMLSchemasANCHOR" name="XMLSchemasTOC">XML Schemas</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#UsingXMLtechnologieswithJSONdataANCHOR" name="UsingXMLtechnologieswithJSONdataTOC">Using XML technologies with JSON data</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#PreexistingdataANCHOR" name="PreexistingdataTOC">Preexisting data</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XMLStandardSchemasANCHOR" name="XMLStandardSchemasTOC">XML Standard Schemas</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DeveloperFamiliarityANCHOR" name="DeveloperFamiliarityTOC">Developer Familiarity</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DesignANCHOR" name="DesignTOC">Design</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#GoalsANCHOR" name="GoalsTOC">Goals</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#PrimaryObjectivesANCHOR" name="PrimaryObjectivesTOC">Primary Objectives</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DesignOverviewANCHOR" name="DesignOverviewTOC">Design Overview</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TransformationoftheObjectModelANCHOR" name="TransformationoftheObjectModelTOC">Transformation of the Object Model</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#PatternsandRulePropertiesANCHOR" name="PatternsandRulePropertiesTOC">Patterns and Rule Properties</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#MarkupAgnosticbutXMLBasedANCHOR" name="MarkupAgnosticbutXMLBasedTOC">Markup Agnostic but XML Based </a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#SchemaandannotationbasedtransformationsANCHOR" name="SchemaandannotationbasedtransformationsTOC">Schema and annotation based transformations</a></div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#XSDSchemaANCHOR" name="XSDSchemaTOC">XSD Schema</a></div>
                  </div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#RNGSchemaANCHOR" name="RNGSchemaTOC">RNG Schema</a></div>
                  </div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RuleGenerationANCHOR" name="RuleGenerationTOC">Rule Generation</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TransformationANCHOR" name="TransformationTOC">Transformation</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Bidirectional(&#34;RoundTripping&#34;)ANCHOR" name="Bidirectional(&#34;RoundTripping&#34;)TOC">Bidirectional ("Round Tripping")</a></div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#AcceptableLossesANCHOR" name="AcceptableLossesTOC">Acceptable Losses</a></div>
                  </div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#OptionalLossesANCHOR" name="OptionalLossesTOC">Optional Losses</a></div>
                  </div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ImplicitInformationANCHOR" name="ImplicitInformationTOC">Implicit Information</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#JXONTransformationsANCHOR" name="JXONTransformationsTOC">JXON Transformations</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AtomicTypesANCHOR" name="AtomicTypesTOC">Atomic Types</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#valueelementANCHOR" name="valueelementTOC">value element</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StructuredTypesANCHOR" name="StructuredTypesTOC">Structured Types</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#NamingandnamespacesANCHOR" name="NamingandnamespacesTOC">Naming and namespaces</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ElementsandAttributesANCHOR" name="ElementsandAttributesTOC">Elements and Attributes</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#childrenelementANCHOR" name="childrenelementTOC">children element</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#attributeselementANCHOR" name="attributeselementTOC">attributes element</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TextelementsANCHOR" name="TextelementsTOC">Text elements</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC">Implementation</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#JXONProcessorANCHOR" name="JXONProcessorTOC">JXON Processor</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ParsingSchemaANCHOR" name="ParsingSchemaTOC">Parsing Schema</a></div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#RNGSupportANCHOR" name="RNGSupportTOC">RNG Support</a></div>
                  </div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ConvertingbetweenJSONandJXMLANCHOR" name="ConvertingbetweenJSONandJXMLTOC">Converting between JSON and JXML</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XSLTprocessingANCHOR" name="XSLTprocessingTOC">XSLT processing</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Retrospective;LimitationsandLessonsANCHOR" name="Retrospective;LimitationsandLessonsTOC">Retrospective; Limitations and Lessons</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UseofXSDSchemaANCHOR" name="UseofXSDSchemaTOC">Use of XSD Schema</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RequiresanXMLSchemaANCHOR" name="RequiresanXMLSchemaTOC">Requires an XML Schema</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#RecursivestructuresANCHOR" name="RecursivestructuresTOC">Recursive structures</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#LocalElementsANCHOR" name="LocalElementsTOC">Local Elements</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UseofSchemaAnnotationsANCHOR" name="UseofSchemaAnnotationsTOC">Use of Schema Annotations</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Intermediatefile(JXONdocument)generationinJavaANCHOR" name="Intermediatefile(JXONdocument)generationinJavaTOC">Intermediate file (JXON document) generation in Java</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XQueryforXSLTgenerationANCHOR" name="XQueryforXSLTgenerationTOC">XQuery for XSLT generation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XSLTfortransformationANCHOR" name="XSLTfortransformationTOC">XSLT for transformation</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#AutogenerationofXSLTANCHOR" name="AutogenerationofXSLTTOC">Auto generation of XSLT</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#NamingandnamespacesANCHOR" name="NamingandnamespacesTOC">Naming and namespaces</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#CharacterSetANCHOR" name="CharacterSetTOC">Character Set</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AppendixANCHOR" name="AppendixTOC">Appendix</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PatternsANCHOR" name="PatternsTOC">Patterns</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExampleofJSONfileconvertedintoJXMLANCHOR" name="ExampleofJSONfileconvertedintoJXMLTOC">Example of JSON file converted into JXML</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FullexampleANCHOR" name="FullexampleTOC">Full example</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#XSDSchemaANCHOR" name="XSDSchemaTOC">XSD Schema</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#BOOKSXMLANCHOR" name="BOOKSXMLTOC">BOOKS XML</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#BOOKSJSONANCHOR" name="BOOKSJSONTOC">BOOKS JSON</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExampleXSLTgenerationANCHOR" name="ExampleXSLTgenerationTOC">Example XSLT generation</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 2 - 5, 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">dlee@epocrates.com</div>
         <div class="singletermTERMS">David</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">JSON schema</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Lee</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">possible</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">See</div>
         <div class="singletermTERMS">Senior Principal Software Engineer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">unidirectional</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML</div>
         <div class="singletermTERMS">XSLT</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="JXON:anArchitectureforSchemaandAnnotationDrivenJSON/XMLBidirectional%0A%09%09TransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">JXON: an Architecture for Schema and Annotation Driven JSON/XML Bidirectional
         		Transformations
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2011</div>
            <div class="confdates e5">August 2 - 5, 2011</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">JSON and XML are seen by some as competing markup formats for content and data.
               				JSON has become predominant in the mobile and browser domains while XML dominates
               				the Server, Enterprise and Document domains. Where these domains meet and need
               to
               				exchange information there is pressure for one domain to impose on the other their
               				markup format. JXON is an architecture that addresses this problem by providing
               for
               				high quality bidirectional transformations between XML and JSON. Previous approaches
               				provide for only a single mapping intended to cover all cases, but generally cover
               				few cases well. JXON uses Schema and annotations to allow highly customizable
               				transformations that can be tuned for individual schemas, elements, attributes
               and
               				types yet still be easily configured.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">David</div>
               <div class="surname e11">Lee</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">David Lee has over 25 years experience in the software industry responsible
                  					for many major projects in small and large companies including Sun Microsystems,
                  					IBM, Centura Software (formerly Gupta.), Premenos, Epiphany (formerly
                  					RightPoint), WebGain, Nexstra, Epocrates. As senior principal software engineer
                  					at Epocrates, Inc., Mr Lee is responsible for managing data integration,
                  					storage, retrieval, and processing of clinical knowledge databases for the
                  					leading clinical information provider.
               </div>
               <div class="para e14">Key career contributions include Real-time AIX OS extensions for optimizing transmission
                  					of real-time streaming video (IBM), secure encrypted EDI over internet email
                  					(Premenos), porting the Centura Team Desktop system to Solaris (Gupta, Centura),
                  					optimizations of large Enterprise CRM systems (Epiphany), author of xmlsh (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e15" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org/" xlink:show="new" xlink:type="simple">http://www.xmlsh.org</div> ) an open
                  					source scripting language for XML.
               </div>
            </div>
            <div class="affiliation e16">
               <div class="jobtitle e17">Senior Principal Software Engineer</div>
               <div class="orgname e18">Epocrates, Inc.</div>
            </div>
            <div class="email e19">dlee@epocrates.com</div>
         </div>
         <div class="legalnotice e20">
            <div class="para e21">Copyright © 2011 David A. Lee</div>
         </div>
      </div><a name="IntroductionJXONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e22">
         <div class="title e23">Introduction - JXON</div>
         <div class="para e24">JXON is both a design architecture and a reference implementation of a tool for JSON
            <div class="popupBox e25">
               <div class="popupLabel" onmouseover="$('#d1e42').show('1000');" onmouseout="$('#d1e42').hide('1000');">[ footnote ]</div>
               <div id="d1e42" style="display: none;">
                  <div class="footnote">
                     <div class="para e26">JSON JavaScript Object Notation 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e27" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.json.org</div>
                        				
                     </div>
                  </div>
               </div>
            </div>/XML 
            <div class="popupBox e28">
               <div class="popupLabel" onmouseover="$('#d1e49').show('1000');" onmouseout="$('#d1e49').hide('1000');">[ footnote ]</div>
               <div id="d1e49" style="display: none;">
                  <div class="footnote">
                     <div class="para e29">XML - Extensible Markup Language (XML) 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e30" xlink:actuate="onRequest" xlink:href="http://www.w3.org/XML/" xlink:show="new" xlink:type="simple">http://www.w3.org/XML/</div>
                        				
                     </div>
                  </div>
               </div>
            </div> transformations. Unlike other XML/JSON transformation architectures and
            			tools, JXON attempts to fulfill the needs of both XML and JSON authors and developers
            			equally. 
         </div>
         <div class="para e31">JXON provides the ability to easily describe both unidirectional and bidirectional
            XML/JSON
            			transformations that produce markup which authors of that particular format would
            like
            			to use.
         </div>
      </div><a name="DivingInANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e32">
         <div class="title e33">Diving In</div>
         <div class="para e34">To get a quick idea of the problem that JXON is attempting to solve consider the following
            			pair of documents representing the same information in 
            <div class="emphasis e35">XML</div> and JSON.
         </div>
         <div class="para e36">
            			
            <div class="programlisting e37" xml:space="preserve">&lt;BOOKS&gt;
               &lt;BOOK id="1"&gt;
               &lt;TITLE&gt;My Favorite Book&lt;/TITLE&gt;
               &lt;PRICE&gt;1.23&lt;/PRICE&gt;
               &lt;/BOOK&gt;
               &lt;BOOK id="1a"&gt;
               &lt;TITLE&gt;XML for Dummies&lt;/TITLE&gt;
               &lt;PRICE&gt;5.25&lt;/PRICE&gt;
               &lt;/BOOK&gt;
               &lt;BOOK id="3"&gt;
               &lt;TITLE&gt;JSON for Dummies&lt;/TITLE&gt;
               &lt;PRICE&gt;200.95&lt;/PRICE&gt;
               &lt;/BOOK&gt;
               &lt;/BOOKS&gt;
            </div>
            		
         </div>
         <div class="para e38">
            			
            <div class="programlisting e39" xml:space="preserve">{ "BOOKS" : [ 
               { "id" : "1"  , "title": "My Favorite Book" , "price" : 1.23 },
               { "id" : "1a" , "title": "XML for Dummies"  , "price" : 5.25},
               { "id" : "3"  , "title": "JSON for Dummies" , "price" : 200.95 }
               ]}
               
            </div>
            		
         </div>
         <div class="para e40">The XML and JSON are both in styles which a native author of that markup type may
            wish to
            			use. It appears that there is an obvious and simple mapping between the formats,
            and in
            			fact there should be a simple reversible lossless transformation so that given
            a
            			document in either XML or JSON it could be transformed to the other format and
            back and
            			end up identical. This seems like such a simple problem not even worth discussing.
            But
            			in reality there are no existing tools which can actually do this generically without
            			hand coding a transformation, both directions, in one or more programming languages.
            The
            			resulting code in say 
            <div class="emphasis e41">XSLT</div>
            <div class="popupBox e42">
               <div class="popupLabel" onmouseover="$('#d1e80').show('1000');" onmouseout="$('#d1e80').hide('1000');">[ footnote ]</div>
               <div id="d1e80" style="display: none;">
                  <div class="footnote">
                     <div class="para e43">XSLT - XSL Transformations (XSLT) Version 2.0 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e44" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt20/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt20/</div>
                     </div>
                  </div>
               </div>
            </div> or JAVA
            <div class="popupBox e45">
               <div class="popupLabel" onmouseover="$('#d1e86').show('1000');" onmouseout="$('#d1e86').hide('1000');">[ footnote ]</div>
               <div id="d1e86" style="display: none;">
                  <div class="footnote">
                     <div class="para e46">JAVA 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e47" xlink:actuate="onRequest" xlink:href="http://www.java.com/" xlink:show="new" xlink:type="simple">http://www.java.com</div>
                     </div>
                  </div>
               </div>
            </div>
            			could be very large and tedious to write. Furthermore
            			such code may not easily be reused for a new document schema.
         </div>
         <div class="para e48">There are many subtleties to this problem. Just a few to think about that highlight
            the
            			issues:
         </div>
         <div class="para e49">
            			
            <div class="itemizedlist e50">
               <div class="listitem e51">
                  <div class="para e52">How would a translation know to consistently use a string value for "id" and "title"
                     but
                     						a numeric value for "price"?
                  </div>
               </div>
               <div class="listitem e53">
                  <div class="para e54">Where does the "BOOK" element come from when translating to XML?</div>
               </div>
               <div class="listitem e55">
                  <div class="para e56">How does the JSON to XML transformation code know to make "id" into an attribute in
                     XML
                     						but not price or title? 
                  </div>
               </div>
               <div class="listitem e57">
                  <div class="para e58">How does the XML to JSON translation know to construct an array in JSON?</div>
               </div>
               <div class="listitem e59">
                  <div class="para e60">Where does the name conversion rule for "TITLE" vs "title" and "PRICE" vs "price"
                     						occur?
                  </div>
               </div>
            </div>
            		
         </div>
         <div class="para e61">As a comparison the default XML to JSON transformation from json.org produces the
            				following JSON 
            <div class="programlisting e62" xml:space="preserve">
               {
               "childNodes": [
               {
               "childNodes": [
               {
               "childNodes": ["My Favorite Book"],
               "tagName": "TITLE"
               },
               {
               "childNodes": [1.23],
               "tagName": "PRICE"
               }
               ],
               "id": 1,
               "tagName": "BOOK"
               },
               {
               "childNodes": [
               {
               "childNodes": ["XML for Dummies"],
               "tagName": "TITLE"
               },
               {
               "childNodes": [5.25],
               "tagName": "PRICE"
               }
               ],
               "id": "1a",
               "tagName": "BOOK"
               },
               {
               "childNodes": [
               {
               "childNodes": ["JSON for Dummies"],
               "tagName": "TITLE"
               },
               {
               "childNodes": [200.95],
               "tagName": "PRICE"
               }
               ],
               "id": 3,
               "tagName": "BOOK"
               }
               ],
               "tagName": "BOOKS"
               }
            </div>
            			
         </div>
         <div class="para e63">Note some non-ideal artifacts of this transformation (which are common among
            				existing tools)
         </div>
         <div class="para e64">
            				
            <div class="itemizedlist e65">
               <div class="listitem e66">
                  <div class="para e67">Inconsistent typing of the "id" value</div>
               </div>
               <div class="listitem e68">
                  <div class="para e69">Very verbose and complex JSON representation</div>
               </div>
               <div class="listitem e70">
                  <div class="para e71">JSON arrays where simple values should be used</div>
               </div>
               <div class="listitem e72">
                  <div class="para e73">Pairs of 'name/value' members where native JSON member names should be
                     							used. 
                  </div>
               </div>
               <div class="listitem e74">
                  <div class="para e75">Unnecessary distinctions between how attributes and child elements are
                     							serialized.
                  </div>
               </div>
            </div>
            			
         </div>
         <div class="para e76">Other existing tools attempt to solve this problem various ways, optimizing for
            				either XML or JSON and often making simplifying assumptions which are valid for
            only
            				some kinds of documents. The results can be good for some special cases but overall
            				there is no existing solution that provides good transformations that work equally
            				well in both directions for a wide variety of documents and produce markup close
            to
            				what a human author would want to create or use.
         </div><a name="JXONattemptstosolvethisproblemANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e77">
            <div class="title e78">JXON attempts to solve this problem</div>
            <div class="para e79">As an example, the following is an RNG
               <div class="popupBox e80">
                  <div class="popupLabel" onmouseover="$('#d1e147').show('1000');" onmouseout="$('#d1e147').hide('1000');">[ footnote ]</div>
                  <div id="d1e147" style="display: none;">
                     <div class="footnote">
                        <div class="para e81">Relax NG - 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e82" xlink:actuate="onRequest" xlink:href="http://relaxng.org/" xlink:show="new" xlink:type="simple">http://relaxng.org</div>
                        </div>
                     </div>
                  </div>
               </div> Compact Notation schema which fully describes both the schema and rules
               				for the bidirectional lossless transformation for the example above. This is all
               				that is needed for JXON to produce both XML to JSON and JSON to XML transformations.
               <div class="programlisting e83" xml:space="preserve">default namespace = ""
                  #&lt;jxon:pattern name="simple"/&gt;
                  grammar {
                  start =  Books
                  
                  #&lt;jxon:children wrap="array"/&gt;
                  Books = element BOOKS { Book+ }
                  
                  #&lt;jxon:json_name omit="true"/&gt;
                  Book = element BOOK {
                  attribute id { xsd:NMTOKEN },
                  Title, 
                  Price
                  }
                  #&lt;jxon:json_name name="title"/&gt;
                  Title =    element TITLE { text }
                  
                  #&lt;jxon:json_name name="price"/&gt;
                  Price = element PRICE { xsd:decimal }
                  }
               </div>And the equivalent schema in XSD using Annotations instead of comments.
            </div>
            <div class="para e84">
               		
               <div class="programlisting e85" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"
                  xmlns:jxon="http://www.xmlsh.org/jxon"&gt;
                  &lt;xs:annotation&gt; &lt;xs:appinfo&gt;
                  &lt;jxon:pattern name="simple"/&gt;
                  &lt;/xs:appinfo&gt;
                  &lt;/xs:annotation&gt;
                  
                  &lt;xs:element name="BOOKS"&gt;
                  &lt;xs:annotation &gt; &lt;xs:appinfo&gt;
                  &lt;jxon:children wrap="array"/&gt;
                  &lt;/xs:appinfo&gt;
                  &lt;/xs:annotation&gt;
                  &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element maxOccurs="unbounded" ref="BOOK"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;/xs:complexType&gt;
                  &lt;/xs:element&gt;
                  
                  &lt;xs:element name="BOOK"&gt;
                  &lt;xs:annotation&gt; &lt;xs:appinfo&gt;
                  &lt;jxon:json_name omit="true"/&gt;
                  &lt;/xs:appinfo&gt;&lt;/xs:annotation&gt;
                  &lt;xs:complexType&gt;
                  &lt;xs:sequence&gt;
                  &lt;xs:element ref="TITLE"/&gt;
                  &lt;xs:element ref="PRICE"/&gt;
                  &lt;/xs:sequence&gt;
                  &lt;xs:attribute name="id" use="required" type="xs:NMTOKEN"/&gt;
                  &lt;/xs:complexType&gt;
                  &lt;/xs:element&gt;
                  
                  &lt;xs:element name="TITLE" type="xs:string"&gt;
                  &lt;xs:annotation&gt; &lt;xs:appinfo&gt;
                  &lt;jxon:json_name name="title"/&gt;
                  &lt;/xs:appinfo&gt;&lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  
                  &lt;xs:element name="PRICE" type="xs:decimal"&gt;
                  &lt;xs:annotation&gt; &lt;xs:appinfo&gt;
                  &lt;jxon:json_name name="price"/&gt;
                  &lt;/xs:appinfo&gt;
                  &lt;/xs:annotation&gt;
                  &lt;/xs:element&gt;
                  &lt;/xs:schema&gt;
                  
               </div>
               
            </div>
         </div>
      </div><a name="JSON/XMLwhat'stheproblem?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e86">
         <div class="title e87">JSON/XML what's the problem?</div>
         <div class="para e88">JSON has become a very popular and useful markup language among some developers and
            			use cases, particularly in browser and mobile applications. These developers require
            			JSON to be delivered from and to services which often use XML as their back end
            data
            			model. This support requires clean and robust transformations of XML to and from
            JSON.
            			Because of subtle but significant differences in both the data model and the
            			serialization format this transformation is either done by hand coding, or by
            			sacrificing the clarity of the markup on either the JSON or the XML.
         </div>
         <div class="para e89">JSON and XML are conceptually similar. They are both text based markup languages designed
            to
            			represent data in a format which is human readable, interchangeable across environments
            			and parseable by most programming languages. On the surface they seem quite similar,
            			with the major apparent difference being a slightly terser notation for JSON for
            simple
            			things (lack of end tags). There are many mappings between JSON and XML, and programs
            			that implement those mappings. This, in theory, allows one to choose the markup
            and
            			tool-set of your choice and transform it to the other at will. Servers that store
            XML
            			data can produce JSON data for clients that need it, and visa-versa.
         </div>
         <div class="para e90">Reality, unfortunately, is not so simple. JSON and XML are fundamentally (and often
            			subtly) incompatible in their abstract data models. They are both sufficiently
            rich that
            			they can describe each other's data model, so creating a mapping from arbitrary
            XML to
            			JSON and visa-versa is 
            <div class="emphasis e91">possible</div> but the result can be very complex.
            			This has led people to design mappings which accommodate only a subset of XML or
            			tailored to particular schemas.
         </div><a name="AnonymousvaluesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e92">
            <div class="title e93">Anonymous values</div>
            <div class="para e94">JSON values are anonymous. They only acquire names by being referenced in an object
               (map).
               				For example, the following is a valid JSON
               				document.
               <div class="programlisting e95" xml:space="preserve">
                  	"Hello World"	
                  
               </div> The analogous XML
               				document would need a root element with child text content or perhaps an
               				attribute.
               <div class="programlisting e96" xml:space="preserve">	&lt;root&gt;Hello World&lt;/root&gt;
                  or
                  	&lt;root value="Hello World"/&gt;
               </div>
            </div>
            <div class="para e97"> In the degenerate case this means entire JSON documents can be composed of single
               				(or arrays of) anonymous values which have no direct mapping to the XML data
               				model.
            </div>
            <div class="para e98">When mapping JSON to XML this additional markup cannot generally be derived from
               				the JSON data itself, but rather needs external rules to decide on the approach.
               				When mapping XML to JSON the presence of an element with text children or attribute
               				value may not necessarily imply creation of an anonymous JSON value, but rather
               the
               				element and attribute names are commonly used to create named members of JSON
               				objects such as
               				
               <div class="programlisting e99" xml:space="preserve">
                  	{ "root" : "Hello World" }
                  					or
                  	{"root" : { "value" : "Hello World" }}
                  
               </div>
               			
            </div>
         </div><a name="ArraysANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e100">
            <div class="title e101">Arrays</div>
            <div class="para e102">JSON has a native representation of arrays which does not exist as native types in
               				XML. XSD Schema has support for values which can be interpreted as tokenized lists,
               				but there is no direct markup for an array of objects. Arrays can be represented
               in
               				XML in several ways ; repeated elements, repeated elements grouped by a common
               				parent, usefully named attributes, usefully named elements and tokenized strings.
               
            </div>
            <div class="para e103">For example the following JSON array </div>
            <div class="para e104">
               <div class="programlisting e105" xml:space="preserve">
                  	[ 1 , "String" ]
                  
               </div> Could be represented in XML as any of
               				the following (and many other ways) 
            </div>
            <div class="para e106">
               				
               <div class="programlisting e107" xml:space="preserve">
                  	&lt;array&gt;1 String&lt;/array&gt;
                  	
                  	&lt;array&gt;&lt;entry&gt;1&lt;/entry&gt;&lt;entry&gt;String&lt;/entry&gt;&lt;array&gt;
                  	
                  	&lt;array entry1="1" entry2="String"/&gt;
                  	
                  	&lt;entry&gt;1&lt;/entry&gt;&lt;entry&gt;String&lt;/entry&gt;
                  
               </div>
               			
            </div>
            <div class="para e108">Mapping XML to JSON arrays is possible but since there is no single mapping, and since
               XML
               				semantics by itself doesnt indicate array representation, one must know via external
               				information to treat specific XML markup as a JSON array. Given any of the above
               				examples, its not obvious that they should be mapped to a JSON array as opposed
               to
               				some other JSON structure (such as a simple value or object).
            </div>
         </div><a name="ImplicitTypes(eg&#34;DuckTyping&#34;)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e109">
            <div class="title e110">Implicit Types (e.g. "Duck Typing")</div>
            <div class="para e111">JSON values make use of implicit types which can be inferred by the serialization
               				format. For example 
               <div class="code e112">1</div> is a Numeric type, while 
               <div class="code e113">"1"</div> is
               				String type. This is common in programming languages, but not as common in markup
               				languages. In XML, without a schema, the token 
               <div class="code e114">1</div> is xs:anyType and it's
               				up the application to infer a type (possibly using a schema, or up to application
               				logic).
            </div>
            <div class="para e115">This leads to problems mapping XML to JSON. When a plain character string value
               				from XML is mapped, what JSON type should be used? It's tempting to use the value
               				instance to deduce the type, but this could be very dangerous. An application
               may be
               				expecting string types and if one instance happens to translate 
               <div class="code e116">1</div> to a
               				numeric type because it looks like one, and another translates "one" to a string
               				this could break the application.
            </div>
            <div class="para e117">Translating atomic values from JSON to XML is not as problematic as generally
               				typing can simply be ignored because the serialization format for string and numbers
               				is the same in XML, although other atomic types like boolean, dates etc can be
               more
               				problematic.
            </div>
         </div><a name="IdentifiersANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e118">
            <div class="title e119">Identifiers</div>
            <div class="para e120">JSON allows any string as a identifier (Object member name). XML is much more restrictive
               				for identifiers. Translation of XML identifiers (element and attribute names)
               to
               				JSON member names causes few problems, but the reverse can lead to invalid XML.
               For
               				example "a value" is a valid member name in JSON but not a valid attribute or
               				element name in XML
            </div>
         </div><a name="NamespacesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e121">
            <div class="title e122">Namespaces</div>
            <div class="para e123">XML supports namespaces, while JSON does not. Mapping QNames in XML with
               				namespaces to member names in JSON can lead to ambiguous, complex or duplicate
               				names. Translating member names in JSON to XML QName may lose namespaces.
            </div>
         </div><a name="ProcessingInstructionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e124">
            <div class="title e125">Processing Instructions</div>
            <div class="para e126">XML supports Processing Instructions, which are absent from the JSON data
               				model.
            </div>
         </div><a name="AttributesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e127">
            <div class="title e128">Attributes</div>
            <div class="para e129">JSON has no concept or representation for Attributes (as distinct from other
               				values).
            </div>
            <div class="para e130">When mapping XML to JSON, attributes are often translated to named object members
               				(along with child elements). When mapping JSON to XML it requires external knowledge
               				to determine when to map members to attributes.
            </div>
         </div><a name="CharacterSetANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e131">
            <div class="title e132">Character Set</div>
            <div class="para e133">JSON supports a broader set of text characters (Unicode code points) then XML. For
               				example JSON supports the NUL character ('\0') whereas NUL is invalid in XML even
               if
               				encoded as an entity (&amp;#0;). This implies that JSON character data cannot be
               				mapped to XML character data losslessly without application specific
               				encodings.
            </div>
         </div><a name="CommentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e134">
            <div class="title e135">Comments</div>
            <div class="para e136">XML directly supports comments while JSON does not. Comments were originally
               				allowed in JSON but Douglas Crockford removed them 
               <div class="popupBox e137">
                  <div class="popupLabel" onmouseover="$('#d1e262').show('1000');" onmouseout="$('#d1e262').hide('1000');">[ footnote ]</div>
                  <div id="d1e262" style="display: none;">
                     <div class="footnote">
                        <div class="para e138">
                           						
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e139" xlink:actuate="onRequest" xlink:href="http://developer.yahoo.com/yui/theater/video.php?v=crockford-json" xlink:show="new" xlink:type="simple">http://developer.yahoo.com/yui/theater/video.php?v=crockford-json</div>
                        </div>
                        <div class="para e140">The main reason I took comments out was that I saw people who were trying
                           						to control what the parser would do based on what was in the comments, and
                           						that totally broke interoperability. There's no way I could control the way
                           						they were using comments, so the most effective fix was to take the comments
                           						out.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e141">Comments could be encoded in JSON using special object member names (such as
               				"_comment") requiring application support to understand these were comments and
               not
               				data.
            </div>
            <div class="para e142">A common case is to simply strip comments from XML when mapping to JSON, and to
               				not insert comments when mapping JSON to XML.
            </div>
         </div><a name="DocumentNodeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e143">
            <div class="title e144">Document Node</div>
            <div class="para e145">JSON does not have a Document Node, where XML does. This is generally not problem
               in
               				practice as the XML Document Node is usually implicitly created in the model,
               and
               				has no textual representation.
            </div>
         </div><a name="SerializationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e146">
            <div class="title e147">Serialization</div>
            <div class="para e148">The text Serialization format for JSON and XML differ significantly. Often the
               				serialization format is the main focus of JSON vs. XML mappings. I assert that
               the
               				serialization format is completely irrelevant for purposes of mapping and
               				transformations; the formats are well defined and there exist a large number of
               				implementations which can parse and serialize XML and JSON. If one focuses instead
               				on the abstract data model, the issue of serialization (both parsing and generation)
               				becomes a trivial implementation issue.
            </div>
         </div><a name="EncodingsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e149">
            <div class="title e150">Encodings</div>
            <div class="para e151">Related to the Serialization format, encodings for JSON and XML can differ. JSON is
               defined
               				to support only the UTF-8 encoding while XML can use many different encodings.
               Like
               				serialization, I assert that encoding is irrelevant. If one works with the JSON
               and
               				XML abstract data Models instead of their serialization and encoding formats these
               				issues disappear. 
            </div>
         </div>
      </div><a name="ExistingDesignsandImplementationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e152">
         <div class="title e153">Existing Designs and Implementations</div>
         <div class="para e154">There are many existing models, designs, and implementations for translating XML to
            			JSON, JSON to XML or both. The advantages and limitations were considered in the
            design
            			of JXON. These include (but not limited to) the following
            <div class="itemizedlist e155">
               <div class="listitem e156">
                  <div class="para e157">The JSON to XML converter from json.org 
                     <div class="xref e158" linkend="jsonorg"></div>
                  </div>
               </div>
               <div class="listitem e159">
                  <div class="para e160">JSONx 
                     <div class="xref e161" linkend="jsonx"></div>
                  </div>
               </div>
               <div class="listitem e162">
                  <div class="para e163">Badgerfish 
                     <div class="xref e164" linkend="badgerfish"></div>
                  </div>
               </div>
               <div class="listitem e165">
                  <div class="para e166">Rabbitfish 
                     <div class="xref e167" linkend="rabbitfish"></div>
                  </div>
               </div>
               <div class="listitem e168">
                  <div class="para e169">JSON Markup Language (JsonML) 
                     <div class="xref e170" linkend="jsonml"></div>
                  </div>
               </div>
               <div class="listitem e171">
                  <div class="para e172">XSLTJSON, XML to JSON using XSLT 
                     <div class="xref e173" linkend="xsltjson"></div>
                  </div>
               </div>
               <div class="listitem e174">
                  <div class="para e175">XML to JSON jQuery Plugin 
                     <div class="xref e176" linkend="jquery"></div>
                  </div>
               </div>
               <div class="listitem e177">
                  <div class="para e178">Boomerang - A bidirectional programming language for ad-hoc, textual data.
                     							
                     <div class="xref e179" linkend="boomerang"></div>
                  </div>
               </div>
               <div class="listitem e180">
                  <div class="para e181">XSugar - Dual Syntax for XML Languages 
                     <div class="xref e182" linkend="xsugar"></div>
                  </div>
               </div>
               <div class="listitem e183">
                  <div class="para e184">OGF Standards: Data Format Description Language (DFDL) 
                     <div class="xref e185" linkend="dfdl"></div>
                     					
                  </div>
               </div>
               <div class="listitem e186">
                  <div class="para e187">MLJSON - An XML Facade over JSON
                     <div class="xref e188" linkend="mljson"></div>
                  </div>
               </div>
            </div>
         </div><a name="LimitationsofexistingimplementationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e189">
            <div class="title e190">Limitations of existing implementations</div>
            <div class="para e191">Existing implementations and designs share many common limitations which make them
               				less then ideal for many use cases. The existing models tend to fall into these
               use
               				cases.
            </div>
            <div class="itemizedlist e192">
               <div class="listitem e193">
                  <div class="para e194">Represent arbitrary JSON in an XML format</div>
               </div>
               <div class="listitem e195">
                  <div class="para e196">Represent arbitrary XML in a JSON format</div>
               </div>
               <div class="listitem e197">
                  <div class="para e198">Convert XML to JSON in a JSON friendly format</div>
               </div>
               <div class="listitem e199">
                  <div class="para e200">Convert JSON to XML in a XML friendly format</div>
               </div>
            </div>
            <div class="para e201">In cases where round tripping is a goal inevitably either the JSON or the XML end
               				up being very "non friendly". Conversely mappings to "friendly" formats tend to
               lose
               				too much information to support round tripping (or only in a small subset of
               				documents).
            </div>
            <div class="para e202">All investigated designs have fixed rules that apply either globally, or if
               				configurable, to an entire document. None of the designs can adjust the mapping
               				rules localized to portions of a document.
            </div>
            <div class="para e203">The major limitations which JXON attempts to address include the following.
               <div class="itemizedlist e204">
                  <div class="listitem e205">
                     <div class="para e206">Single model for all documents and parts of documents</div>
                     <div class="para e207">Most implementations impose a single model for transformation for all
                        							documents and parts of documents. They attempt to fit a single pattern
                        							for all uses. This "one size fits all" approach ends up being "one size
                        							fits nothing", as every mapping imposes some compromises, whether its
                        							information loss, usability or applicability to a particular use. Since
                        							different use cases may accept different sets of compromises, trying to
                        							fit a single transformation mapping for a large set of use cases ends up
                        							with a poor fit for most of them.
                     </div>
                  </div>
                  <div class="listitem e208">
                     <div class="para e209">JSON or XML Centric</div>
                     <div class="para e210">Some designs focus on producing JSON from arbitrary XML, others on
                        							producing XML from arbitrary JSON. The result is that one side or the
                        							other is "stuck" with the artifacts of the mapping and do not end up
                        							with a document in a format which would be natural for markup developers
                        							in that language. JXON attempts to produce bidirectional transformations
                        							to "friendly" formats in each directly equally.
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="RationaleandUseCasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e211">
         <div class="title e212">Rationale and Use Cases</div>
         <div class="para e213">JXON is based on the assumption that there are real world needs for a JSON/XML
            			transformation. Why is there such a need? Many existing systems work just fine
            using XML
            			or JSON by itself with no need of an alternative representation for data. The problems
            			which JXON is intended to address arise when data crosses domains. Due to technical
            and
            			as well social reasons domains have evolved which embrace either XML or JSON almost
            			exclusively. XML has largely been adopted by the enterprise and content storage
            domains,
            			as well as enterprise messaging. JSON has evolved into the browser and mobile space
            			which started using XML but have changed over the last decade to be almost entirely
            JSON
            			based. The problem is when these domains need to exchange data. One solution is
            to
            			simply produce data in the format required at the point of request. This is a feasible
            			solution when the data is dynamically generated (computed data, simple messaging,
            data
            			residing in-memory in native language structures), or exists in an entirely separate
            			format to begin with (such as relational data). In many cases, however, data already
            			exists in XML or JSON in one domain and needs to be exchanged with another domain.
            For
            			example a document may exist in XML form on a server and needs to be deployed to
            a
            			browser or mobile device in JSON format. One approach to this problem is to try
            to
            			"push" one's domain format into the other's domain. For example, if clients require
            JSON
            			documents then simply store the JSON format on the server. This can work when there
            is
            			really no compelling reason to have XML on the server in the first place, and has
            			spawned the growth of JSON databases. Alternatively one can try to force clients
            to
            			accept XML because that is the format on the server. 
         </div>
         <div class="para e214">I argue that it is preferable in many cases to accept that there are compelling
            			reasons for each domain to want data in its own format, and to provide for a
            			transformation from one format to another closest to the point of the domain boundary.
            			This allows the tools already in use in the particular domain to work with their
            			'native' format and to minimize the impact of format differences to domain boundary
            			layer. This way neither domain needs to make compromises in design and implementation
            to
            			satisfy issues of a different domain. 
         </div>
         <div class="para e215">JXON is designed to make that boundary crossing as easy as possible and with as few
            			compromises as possible.
         </div><a name="CategoriesofTransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e216">
            <div class="title e217">Categories of Transformations</div>
            <div class="para e218">There are several major categories of JSON/XML transformation problems which are
               				really subsets of functionality. Not all use cases require all levels of
               				functionality but by supporting the most stringent requirements implicitly creates
               				support for the rest. In general there is a correlation between information fidelity
               				and the category of transformation. For example a unidirectional XML to JSON
               				transformation may lose significant amounts of information (and yet still be
               				useful). While a full round trippable transformation, by its very nature, must
               				maintain a maximum amount of information in either the instance documents or the
               				transformation logic. Note that these transformation categories are not specific
               to
               				XML and JSON but apply equally well to any kind of document formats.
            </div>
            <div class="figure e219" xml:id="categories">
               <div class="title e220">Types JSON/XML transformations</div>
               <div class="mediaobject e221">
                  <div class="imageobject e222">
                     <div class="metaBox e223"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e393').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e393" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e223'
                              </span><span class="metaAttribute">fileref='../../../vol7/graphics/Lee01/Lee01-001.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='75%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e224">
                  <div class="para e225">Types of JSON/XML transformations</div>
               </div>
            </div><a name="UnidirectionalTransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e226">
               <div class="title e227">Unidirectional Transformations</div>
               <div class="para e228">Some transformations are 
                  <div class="emphasis e229">unidirectional</div>; information goes
                  					only one way. Unidirectional transformations may have a wide range of
                  					information fidelity, but are often useful with significant information loss.
                  					Some unidirectional transformations are generic, that is the rules are static
                  					and do not depend on the source or target schemas. Other transformations may
                  be
                  					tailored for specific source and target document schemas.
               </div>
            </div><a name="BidirectionalTransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e230">
               <div class="title e231">Bi-directional Transformations</div>
               <div class="para e232">Bi-directional support transforming in both directions (from XML to JSON or
                  					JSON to XML).
               </div>
            </div><a name="RoundtriptransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e233">
               <div class="title e234">Round trip transformations</div>
               <div class="para e235">Round trip transformations are a special kind of bi-directional
                  					transformations that attempt to produce semantically equivalent documents after
                  					transforming from one format to another then back.
               </div>
            </div>
         </div><a name="UseCasesforXML/JSONtransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e236" xml:id="usecases">
            <div class="title e237">Use Cases for XML/JSON transformations</div>
            <div class="para e238">There are several use cases that require or benefit by one of the categories of
               				XML/JSON transformations. The more useful cases are where the data in a domain
               not
               				only is desired in a specific format, but also persist or may be manipulated by
               				tools specialized for that format and that the data needs to be exchanged with
               				another domain using a different format. Examples of good use cases for
               				transformations include the following.
            </div><a name="MessagepassingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e239">
               <div class="title e240">Message passing</div>
               <div class="para e241">Many enterprise systems operate on XML based messages. If these are to be sent
                  					to a domain needing JSON then the messages must be transformed from XML to JSON.
                  					Responses may come back in JSON and need to be transformed back to XML. In this
                  					case unidirectional transformations may be sufficient (one for requests and one
                  					for responses), although if the request and response correspond to the same
                  					schema then a bidirectional transformation may be better suited.
               </div>
            </div><a name="XMLContentDatabasesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e242">
               <div class="title e243">XML Content Databases</div>
               <div class="para e244">If data is stored in an XML Content database and JSON is required by a JSON
                  					consumer then transformation from XML to JSON is needed. If JSON producer
                  					requires data to be stored in an XML Content database then it needs to
                  					transformed to XML. The transformations may or may not require round trip
                  					(lossless) transformations depending on the needs of the application.
               </div>
            </div><a name="HTML/XHTMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e245">
               <div class="title e246">HTML/XHTML</div>
               <div class="para e247">If data is in HTML format there are tools available to transform it to XHTML
                  					format. If that data is required in JSON then a XML to JSON transformation is
                  					required. The reverse is also possible, generating HTML from JSON.
               </div>
            </div><a name="XMLSchemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e248">
               <div class="title e249">XML Schemas</div>
               <div class="para e250">A schema language for JSON is being developed 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e251" linkend="jsonschema" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">JSON
                     						schema
                  </div> but implementations at the time of this writing are sparse and
                  					the technology is immature. If a high quality JSON to XML transformation is
                  					available then XML Schema validation could be used to validate JSON documents.
                  					This would leverage the mature technologies for XML Schemas without having to
                  					reinvent them specific to JSON.
               </div>
            </div><a name="UsingXMLtechnologieswithJSONdataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e252">
               <div class="title e253">Using XML technologies with JSON data</div>
               <div class="para e254">Many XML technologies are very mature and powerful. Equivalent JSON
                  					technologies are only starting to be developed. There is simply no equivalent
                  to
                  					tools like XSLT, XQuery
                  <div class="popupBox e255">
                     <div class="popupLabel" onmouseover="$('#d1e448').show('1000');" onmouseout="$('#d1e448').hide('1000');">[ footnote ]</div>
                     <div id="d1e448" style="display: none;">
                        <div class="footnote">
                           <div class="para e256">XQuery 1.0: An XML Query Language 
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e257" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery/</div>
                           </div>
                        </div>
                     </div>
                  </div>
                  					, XProc
                  <div class="popupBox e258">
                     <div class="popupLabel" onmouseover="$('#d1e454').show('1000');" onmouseout="$('#d1e454').hide('1000');">[ footnote ]</div>
                     <div id="d1e454" style="display: none;">
                        <div class="footnote">
                           <div class="para e259">XProc: An XML Pipeline Language 
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e260" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xproc/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xproc/</div>
                              						
                           </div>
                        </div>
                     </div>
                  </div>
                  					, Schematron
                  <div class="popupBox e261">
                     <div class="popupLabel" onmouseover="$('#d1e461').show('1000');" onmouseout="$('#d1e461').hide('1000');">[ footnote ]</div>
                     <div id="d1e461" style="display: none;">
                        <div class="footnote">
                           <div class="para e262">Schematron 
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e263" xlink:actuate="onRequest" xlink:href="http://www.schematron.com/" xlink:show="new" xlink:type="simple">http://www.schematron.com/</div>
                           </div>
                        </div>
                     </div>
                  </div>
                  					for JSON.
               </div>
               <div class="para e264">Use of a high quality XML/JSON transformation could allow use of XML
                  					technologies on JSON data without having to reinvent the entire XML ecosystem
                  					for JSON. This may require bidirectional transformations but not necessary round
                  					trip (lossless) transformations depending on the needs of the application. In
                  					the case where the source and target data are different schemas, a pair of
                  					unidirectional transformations is needed instead of a bidirectional
                  					transformation.
               </div>
            </div><a name="PreexistingdataANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e265">
               <div class="title e266">Preexisting data</div>
               <div class="para e267">There exists 'in the wild' a huge amount of preexisting content in XML format.
                  					This content could be made available to JSON oriented domains by the use of XML
                  					to JSON transformations instead of having to re-author the content directly in
                  					JSON. In cases where there is existing JSON content, or processes that produce
                  					JSON content only, that content can be made available to XML oriented domains
                  by
                  					the use of a JSON to XML transformation instead of re-authoring the content.
                  				
               </div>
            </div><a name="XMLStandardSchemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e268">
               <div class="title e269">XML Standard Schemas</div>
               <div class="para e270">There is a large body of XML standard schemas which have evolved over the last
                  					decade. They span a huge section of industry, research, academia and publishing.
                  					These schemas took significant effort to develop. By using a XML to JSON
                  					transformation this body of knowledge can be leveraged into a new markup
                  					technology without having to start from scratch.
               </div>
            </div><a name="DeveloperFamiliarityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e271">
               <div class="title e272">Developer Familiarity</div>
               <div class="para e273">One of the big reasons for the different domains which have adopted JSON or
                  					XML is developer familiarity. Web and browser developers, having experience with
                  					JavaScript are more comfortable with JSON even on platforms where XML support
                  is
                  					equal or even better. Similarly server and data processing developers are often
                  					more comfortable with XML even in use cases where JSON is well supported. If
                  					there is a technology which bridges XML and JSON easily and accurately then
                  					developers don't need to leave their area of familiarity.
               </div>
            </div>
         </div>
      </div><a name="DesignANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e274">
         <div class="title e275">Design</div><a name="GoalsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e276">
            <div class="title e277">Goals</div>
            <div class="para e278">The goals of this design are to address many of the limitations of existing
               				implementations and to provide a simple method for customizing the transformation.
               				At the same time it's recognized that not all limitations can be addressed, nor
               				necessarily need be addressed, and that this design may not meet the objectives
               of
               				everyone. The use cases 
               <div class="emphasis e279" role="ital">See</div>
               				
               <div class="xref e280" linkend="usecases"></div> were of particular use in focusing the design
               				goals.
            </div><a name="PrimaryObjectivesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e281">
               <div class="title e282">Primary Objectives</div>
               <div class="para e283">The following are the primary design objectives. Not all objectives can
                  					necessarily be met with the same transformation.
               </div>
               <div class="para e284">
                  					
                  <div class="itemizedlist e285">
                     <div class="listitem e286">
                        <div class="para e287">Unidirectional and bidirectional transformations from a instance
                           								of a JSON document to an instance of an XML document.
                        </div>
                     </div>
                     <div class="listitem e288">
                        <div class="para e289">The option of lossless round trip transformations.</div>
                     </div>
                     <div class="listitem e290">
                        <div class="para e291">The XML and JSON instances should be in a form which is desirable
                           								by XML and JSON developers respectively. 
                        </div>
                     </div>
                     <div class="listitem e292">
                        <div class="para e293">A simple method of modifying the transformation rules for parts of
                           								a document as well as the whole document for a class of
                           								documents.
                        </div>
                     </div>
                     <div class="listitem e294">
                        <div class="para e295">A pattern based rule system to allow specifying common patterns
                           								for mappings instead of having to code explicit details.
                        </div>
                     </div>
                     <div class="listitem e296">
                        <div class="para e297">Implicit mappings of JSON and XSD atomic types and common
                           								structures by leveraging XML Schema information.
                        </div>
                     </div>
                  </div>
                  				
               </div>
            </div>
         </div><a name="DesignOverviewANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e298">
            <div class="title e299">Design Overview</div>
            <div class="figure e300" xml:id="figure1">
               <div class="title e301">JXON Processor</div>
               <div class="mediaobject e302">
                  <div class="imageobject e303">
                     <div class="metaBox e304"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e532').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e532" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e304'
                              </span><span class="metaAttribute">fileref='../../../vol7/graphics/Lee01/Lee01-002.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='50%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e305">
                  <div class="para e306">Figure 1. JXON Processor data flow</div>
               </div>
            </div>
            <div class="figure e307" xml:id="fig_xml2json">
               <div class="title e308">XML to JSON</div>
               <div class="mediaobject e309">
                  <div class="imageobject e310">
                     <div class="metaBox e311"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e541').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e541" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e311'
                              </span><span class="metaAttribute">fileref='../../../vol7/graphics/Lee01/Lee01-003.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='50%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e312">
                  <div class="para e313">Transforming XML to JSON data flow</div>
               </div>
            </div>
            <div class="figure e314" xml:id="fig_json2xml">
               <div class="title e315">JSON to XML</div>
               <div class="mediaobject e316">
                  <div class="imageobject e317">
                     <div class="metaBox e318"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e550').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e550" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e318'
                              </span><span class="metaAttribute">fileref='../../../vol7/graphics/Lee01/Lee01-004.jpg'
                              </span><span class="metaAttribute">format='jpg'
                              </span><span class="metaAttribute">width='50%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e319">
                  <div class="para e320">Transforming JSON to XML data flow</div>
               </div>
            </div><a name="TransformationoftheObjectModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e321">
               <div class="title e322">Transformation of the Object Model</div>
               <div class="para e323">As mentioned previously, the text format of XML vs. JSON tends to get a great deal
                  of
                  					focus, while I assert it is actually a trivial issue. This design performs all
                  					transformation logic at the Object Model level not at the text format level.
                  To
                  					accomplish this a very simple XML schema is used which represents the JSON
                  					Object Model precisely. This implementation uses the JXML schema (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e324" xlink:actuate="onRequest" xlink:href="http://xml.calldei.com/JsonXML" xlink:show="new" xlink:type="simple">http://xml.calldei.com/JsonXML</div>) to represent the JSON object model
                  					and the conversion tools supplied by xmlsh (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e325" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org" xlink:show="new" xlink:type="simple">http://www.xmlsh.org</div>). In particular the json2xml (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e326" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org/CommandXml2json" xlink:show="new" xlink:type="simple">http://www.xmlsh.org/CommandXml2json</div>) and xml2json (
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e327" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org/CommandJson2xml" xlink:show="new" xlink:type="simple">http://www.xmlsh.org/CommandJson2xml</div> ) commands. Other schemas and
                  					tools could just as easily be used as long as they provide a precise
                  					representation of the JSON object model in XML (such as JSONx 
                  <div class="xref e328" linkend="jsonx"></div> ).
               </div>
               <div class="para e329">Transformation at the Object Model level provides the following
                  					benefits:
               </div>
               <div class="para e330">
                  					
                  <div class="itemizedlist e331">
                     <div class="listitem e332">
                        <div class="para e333">Reduces the problem to an XML-to-XML transformation problem
                           								instead of a Markup-to-Markup problem.
                        </div>
                     </div>
                     <div class="listitem e334">
                        <div class="para e335">Decouples transformation logic from serialization logic</div>
                     </div>
                     <div class="listitem e336">
                        <div class="para e337">Allows all processing to be implemented with XML tools which are
                           								mature and feature full.
                        </div>
                     </div>
                     <div class="listitem e338">
                        <div class="para e339">Allows focus on the transformation logic instead of serialization
                           								logic.
                        </div>
                     </div>
                     <div class="listitem e340">
                        <div class="para e341">Provides for some schema validation of the generated JSON to check
                           								for JSON well-formedness prior to serializing as JSON.
                        </div>
                     </div>
                  </div>
                  				
               </div>
            </div><a name="PatternsandRulePropertiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e342">
               <div class="title e343">Patterns and Rule Properties</div>
               <div class="para e344">A major problem with XML/JSON transformation is that there are many ways to do it.
                  These
                  					can be classified into 'patterns' which define the rules for bidirectional
                  					transformation of a given set of terms.
               </div>
               <div class="para e345">Patterns are defined in a global configuration file which defines specific named patterns
                  					which can be referenced by the annotations, and configuration properties of each
                  					pattern which can be selectively overwritten in a specific annotation. The
                  					properties of a pattern define basic building blocks of transformation such as
                  					element and attribute wrapping, name translations, handling of namespaces and
                  					typing of atomic values. The code to implement a pattern can be very complex,
                  					especially if reverse transformation is desired. By having the framework
                  					predefine patterns, a developer can simply tag an element, attribute, or type
                  					with a pattern name and the rules will be applied to that element (and
                  					optionally its derived and contained types).
               </div>
               <div class="para e346">This is intended to be extensible so that new patterns can be added to the
                  					code to enrich the range of transformation options, and need only be identified
                  					by name to be applied. At present there are two patterns supported "full" and
                  					"simple". These are intended to demonstrate extremes between transformation
                  					categories. More patterns are in development.
               </div>
               <div class="para e347">Patterns are applied to items (documents, elements, attributes, types) by using
                  					the annotation  
                  <div class="emphasis e348">&lt;jxon:pattern name="pattern name"/&gt;</div>
                  					This applies all the rule properties associated with that pattern as applicable
                  					to the item type.  It also applies the properties to the derived and contained
                  					types.   For example applying a pattern at the schema root applies the pattern
                  					to all items.   Applying to an element affects the element, its attributes, and
                  					all local element declarations.   Applying a pattern to a type affects the type
                  					and all derived types.
               </div>
               <div class="para e349">
                  <div class="emphasis e350">See 
                     <div class="xref e351" linkend="patterns"></div>
                  </div>
               </div>
            </div><a name="MarkupAgnosticbutXMLBasedANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e352">
               <div class="title e353">Markup Agnostic but XML Based </div>
               <div class="para e354">While a primary goal of the design is to provide a transformation which is
                  					markup agnostic ( treats XML and JSON as equals). The reality is that the tools
                  					for processing markup are much more mature and feature full in the XML space
                  					than the JSON space. This practical issue lead to a design which is "XML Based"
                  					but also "markup agnostic". The technologies used are primarily XML based, and
                  					the design itself is based on XML Schema, Annotations in schema, XQuery and XSLT
                  					processing. This does force a compromise in design which is definitely XML
                  					oriented, but still providing the end result (input and output of the
                  					transformations) markup agnostic.
               </div>
            </div><a name="SchemaandannotationbasedtransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e355">
               <div class="title e356">Schema and annotation based transformations</div>
               <div class="para e357">Analysis of the existing implementation limitations and the primary objectives
                  					lead to the conclusion that a Schema and associated annotations could provide
                  					much of the external information needed guide the transformations in both
                  					directions.
               </div>
               <div class="para e358"> For example on generating JSON, Schema type information can inform the choice
                  					of which JSON types to generate. On generating XML, Schema can provide the
                  					missing pieces of structure which may have been omitted in the JSON, for example
                  					the correct element names, wrapping elements, namespaces etc.
               </div>
               <div class="para e359">Schema Annotations allow specifying ancillary information which is to apply
                  					only to a specific element, attribute or type without having to add addressing
                  					to the rule-set. The addressing is implicit by the location of the annotation.
                  					Since types can be annotated as well as specific elements and attributes,
                  					patterns can applied to all elements/attributes of that type in one location.
                  					Similarly type hierarchies can be annotated by placing the annotations at the
                  					appropriate location in the type hierarchy.
               </div>
               <div class="para e360">Individual properties of patterns can be overridden at any location, which
                  					acts similarly to object derivation. For example the "simple" pattern can be
                  					used for the document as a whole, while on an individual element its JSON name
                  					can be modified via annotation while inheriting all other derived properties
                  of
                  					the pattern.
               </div><a name="XSDSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e361">
                  <div class="title e362">XSD Schema</div>
                  <div class="para e363">The initial implementation directly supports XSD Schema only. This is an
                     						implementation artifact derived by use of the Apace Schema API, not a design
                     						restriction. XSD Annotations may inserted into any schema item (document,
                     						element, type etc) which will override either the current in-effect pattern
                     						or any of the pattern rules. JXON annotation must occur within the "appinfo"
                     						XSD annotation element. Only elements within the jxon namespace are
                     						processed, the rest are ignored.
                  </div>
                  <div class="para e364">The following at the beginning of a schema indicates that the entire
                     						document defaults to the "full" pattern
                  </div>
                  <div class="programlisting e365" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:jxon="http://www.xmlsh.org/jxon"&gt;
                     	&lt;xs:annotation&gt;
                     		&lt;xs:appinfo&gt;
                     			&lt;jxon:pattern  name="full"/&gt;
                     		&lt;/xs:appinfo&gt;
                     	&lt;/xs:annotation&gt;
                     	...
                  </div>
                  <div class="para e366">The following indicates that the ITEM element and all its child elements
                     						use the "simple" pattern and that the ITEM element itself will be
                     						represented by the JSON Name "BOOK". 
                     <div class="note e367">
                        <div class="para e368">Note that the "json_name" element is a sibling, not a child of "pattern". This
                           								indicates that the name only applies to this element, not to its
                           								descendant local elements.
                        </div>
                     </div>
                     					
                  </div>
                  <div class="programlisting e369" xml:space="preserve">&lt;xs:element name="ITEM"&gt;
                     		&lt;xs:annotation&gt;
                     			&lt;xs:appinfo&gt;
                     				&lt;jxon:pattern  name="simple"/&gt;
                     				&lt;jxon:json_name name="BOOK"/&gt;
                     			&lt;/xs:appinfo&gt;
                     		&lt;/xs:annotation&gt;
                     ...
                  </div>
               </div><a name="RNGSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e370">
                  <div class="title e371">RNG Schema</div>
                  <div class="para e372">The design supports use of any XML schema which can be annotated. However
                     						the current implementation only directly supports XSD.
                  </div>
                  <div class="para e373">RelaxNG (both Compact and XML formats) is indirectly supported by the use of comments
                     in
                     						RNG and translating the RNG into XSD and the comments into XSD
                     						annotations.
                  </div>
                  <div class="para e374">The following RNG compact syntax uses comments starting with
                     <div class="emphasis e375"> #&lt;jxon:
                        						
                     </div>to map a different JSON name to an element
                  </div>
                  <div class="programlisting e376" xml:space="preserve">#&lt;jxon:json_name  name="TITLE"/&gt;
                     element NAME { xs:string }
                  </div>
                  <div class="para e377">This is converted to the following XSD notation.</div>
                  <div class="programlisting e378" xml:space="preserve">&lt;xs:element name="NAME"&gt;
                     		&lt;xs:annotation&gt;
                     			&lt;xs:appinfo&gt;
                     				&lt;jxon:json_name name="TITLE"/&gt;
                     			&lt;/xs:appinfo&gt;
                     		&lt;/xs:annotation&gt;
                     ...
                  </div>
                  <div class="para e379">Similarly comments in the RNG XML syntax are supported in the same
                     						way.
                  </div>
               </div>
            </div><a name="RuleGenerationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e380">
               <div class="title e381">Rule Generation</div>
               <div class="para e382">A pair of transformation rules (XSLT files) for a class of documents is
                  					generated.
               </div>
               <div class="para e383">The XML Schema (for the XML document) is read along with the global configuration.
                  The
                  					schema is traversed and a XSLT file is produced for each direction (JSON to XML
                  					and XML to JSON) based on each element, attribute, and type defined in the
                  					schema. Schema Annotations are used to choose which pattern applies to each
                  					term, and provides optional customization to the patterns for that item.
                  					Patterns can be applied recursively, or only to targeted items.
               </div>
               <div class="para e384">The result is a pair of XSLT files.</div>
            </div><a name="TransformationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e385">
               <div class="title e386">Transformation</div>
               <div class="para e387">The XSLT files produced by the rule generation can be used without any
                  					ancillary information. Reference to the schema or configuration information is
                  					not needed. 
               </div>
               <div class="para e388">Running a transformation from JSON to XML requires converting the JSON to JXML
                  					format then running XSLT. Schema validation can be applied after the
                  					transformation. 
               </div>
               <div class="para e389">Running a transformation from XML to JSON requires running the XSLT then
                  					converting from the result JXML to JSON. Schema validation can be applied to
                  the
                  					input prior to running the transformation, and to the JXML after transformation
                  					to validate JSON well-formedness.
               </div>
            </div><a name="Bidirectional(&#34;RoundTripping&#34;)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e390">
               <div class="title e391">Bidirectional ("Round Tripping")</div>
               <div class="para e392">JXON is intended for bidirectional transformations ("Round Tripping"), although the
                  same
                  					architecture and implementation could be used for unidirection transformations
                  					(XML to JSON or JSON to XML). A bidirectional transformation can be either
                  					Lossless or Lossy (or somewhere in between). This can depend on the patterns
                  					being used, the schema, and actual instances of documents. 
               </div>
               <div class="para e393">The definition of "Lossless" and "Lossy" depends on what one considers
                  					"important information", although the terms do convey some meaning. Consider
                  a
                  					scale measuring the results of a round trip transformation with one side exact
                  					byte for byte bidirectional transformation for every document instance
                  					transformed ("Lossless"), and the other side no correlation whatsoever between
                  					the two documents ("Unidirectional"), with "Lossy" being somewhere in between.
                  					Even this linear scale is misleading because some document instances
                  					corresponding to the same schema may have different translation characteristics
                  					then others. The design goals of JXON are to provide reasonably defined
                  					translation characteristics. Choosing a particular pattern or configuration
                  					attributes of a pattern will effect the translation, and it is up to the
                  					developer to determine the importance of the specific effects.
               </div>
               <div class="para e394">The JXON architecture does not attempt to implement "Purely Lossless" transformations
                  at
                  					the text serialization (byte sequence) level. 
               </div><a name="AcceptableLossesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e395">
                  <div class="title e396">Acceptable Losses</div>
                  <div class="para e397">The JXON architecture does not attempt to preserve some characteristics of XML or
                     JSON at
                     						all. These are considered "Acceptable Losses" for this project and for the
                     						purposes of definitions do not contribute to the meaning of "Lossless". 
                  </div>
                  <div class="para e398">The following XML information is not attempted to be preserved.</div>
                  <div class="para e399">
                     						
                     <div class="itemizedlist e400">
                        <div class="listitem e401">
                           <div class="para e402">Serialization Format</div>
                           <div class="para e403">The Text Serialization format of XML is not considered.
                              									Transformations are done at the XDM abstraction level so
                              									characteristics such as encoding, ignorable whitespace,
                              									character entities, CDATA etc are not considered as a
                              									significant characteristic.
                           </div>
                        </div>
                        <div class="listitem e404">
                           <div class="para e405">External Entities</div>
                           <div class="para e406">External entities in XML are expanded as part of the XML parsing and are not
                              									represented in JSON as entities.  They are not converted to
                              									external entities when generating XML from JSON.
                           </div>
                        </div>
                        <div class="listitem e407">
                           <div class="para e408">DTD and Schema</div>
                           <div class="para e409">DTD and Schema references in XML are not retained as part of
                              									the transformation. They may be reconstructed as part of the XML
                              									generation but no attempt is made at representing DTD or Schema
                              									information in the JSON output.
                           </div>
                        </div>
                        <div class="listitem e410">
                           <div class="para e411">Comments</div>
                           <div class="para e412">Comments are removed during XML processing. They exist as part
                              									of the XDM model but in the current implementation they are
                              									ignored. 
                           </div>
                        </div>
                        <div class="listitem e413">
                           <div class="para e414">Processing Instructions</div>
                           <div class="para e415">Processing instructions are removed during XML processing.
                              									They exist as part of the XDM model but in the current
                              									implementation they are ignored. 
                           </div>
                        </div>
                        <div class="listitem e416">
                           <div class="para e417">Application level XML markup</div>
                           <div class="para e418">XML markup which has meaning by application specific
                              									processors is not explicitly preserved, or may be partially
                              									preserved. For example XInclude processing (like External
                              									Entities) may be merged into the XDM model during parsing so is
                              									not transfered into the JSON markup explicitly. XLink and
                              									XPointer markup is not attempted to be processed specially. 
                           </div>
                           <div class="para e419">XML markup which has specific meaning to an application may
                              									not have any related meaning in JSON.. For example an XSLT file
                              									translated to JSON looses its meaning in that the resultant JSON
                              									document has no supporting processors for XSLT.
                           </div>
                        </div>
                     </div>
                     					
                  </div>
               </div><a name="OptionalLossesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e420">
                  <div class="title e421">Optional Losses</div>
                  <div class="para e422">Sometimes perfect Lossless bidirectional transformation is not important. JXON provides
                     						the ability to perform Lossy transformations which can still produce useful
                     						results. A simple example is value typing. If there is no schema or
                     						annotation to describe the type of a value then transformations can lose
                     						that type. A numeric type in JSON round tripped may become a String type.
                     						This change of type information may or may not matter to the
                     						application.
                  </div>
                  <div class="para e423">Another case is where attributes or elements are requested to be ignored
                     						(in JSON or XML). This obviously causes problems unidirectional as well as
                     						bidirectional transformations. Omitted elements and attributes could be
                     						regenerated on reverse transformation according to the schema (or
                     						annotations) but the values cannot be extracted from the document
                     						instance.
                  </div>
                  <div class="para e424">A more subtle type of losses can occur when assumptions are made about
                     						documents which is not explicit in the schema or the JXON annotation. For
                     						example the "simple" pattern translates XML elements and attributes to JSON
                     						members. This pattern can round trips losslessly as long as there are no
                     						repeated element children or duplicate element or attribute names. However
                     						given an XML document that doesn't conform to the assumptions can produce
                     						invalid JSON, or the round trip may be produce ambiguous results.
                  </div>
                  <div class="para e425">Future enhancements could detect and warn the developers of the sort of
                     						losses or errors which could be expected.
                  </div>
               </div>
            </div><a name="ImplicitInformationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e426">
               <div class="title e427">Implicit Information</div>
               <div class="para e428">The JXON architecture makes significant use of "Implicit Information". Since
                  					an XSLT file is generated for both directions of mapping, not all information
                  					needed to build the documents during transformation need to be in the documents
                  					themselves. This allows many features not available with other JSON/XML designs
                  					. 
               </div>
               <div class="para e429">A simple example is naming. Suppose a XML document has an element
                  					&lt;my_element&gt; and we wish to create a JSON document with an object member "The
                  					Element". This can be specified as a name attribute to the pattern for
                  					"my_element" (via annotation in the schema) and will be encoded into both XSLT
                  					files. The resulting JSON document has no explicit reference to the XML element
                  					name, yet via the XSLT will create the correct element name. The same concept
                  					solves a large number of issues usually considered deficient in many XML/JSON
                  					mapping tools such as:
               </div>
               <div class="para e430">
                  					
                  <div class="itemizedlist e431">
                     <div class="listitem e432">
                        <div class="para e433">Namespaces</div>
                        <div class="para e434">XML Namespaces can be preserved round-tripped through JSON without
                           								encoding the namespace itself in the JSON file. JSON objects can
                           								produce elements and attributes with namespaces without having the
                           								namespace information in the JSON document itself.
                        </div>
                     </div>
                     <div class="listitem e435">
                        <div class="para e436">Element and Attribute distinction</div>
                        <div class="para e437">Some patterns map elements and attributes both to named JSON
                           								members. The distinction between element and attribute is not
                           								present in the JSON document. On the reverse transformation the
                           								elements and attributes can be reconstructed.
                        </div>
                     </div>
                     <div class="listitem e438">
                        <div class="para e439">JSON Arrays</div>
                        <div class="para e440">JSON arrays can be created from various XML structures. The
                           								resultant JSON may lose the original XML element or attribute names,
                           								but on the reverse translation these items are reconstructed.
                           								Starting from JSON, arrays can be wrapped in generated XML elements
                           								or into a tokenized list value.
                        </div>
                     </div>
                     <div class="listitem e441">
                        <div class="para e442">Value type Information</div>
                        <div class="para e443">When translating XML to JSON the value type can be lost ( e.g. 
                           <div class="code e444">"value" : 1</div>
                           								vs. 
                           <div class="code e445"> &lt;value&gt;1&lt;/value&gt;</div>)
                        </div>
                        <div class="para e446">When translating back from XML to JSON the type information can be
                           								restored even though it is not present in the instance
                           								document.
                        </div>
                     </div>
                     <div class="listitem e447">
                        <div class="para e448">Constructed or deleted elements</div>
                        <div class="para e449">Some patterns construct or delete markup, yet are reversible. For
                           								example wrapping elements may be removed when XML is converted to
                           								JSON. On the reverse transformation they can be reconstructed.
                           								Anonymous JSON objects (such as the root document) can have elements
                           								synthesized.
                        </div>
                     </div>
                     <div class="listitem e450">
                        <div class="para e451">Composed Values</div>
                        <div class="para e452">XSD "list" items in XML are a single atomic value. When translated
                           								to JSON they can be split into Array notation (separate JSON
                           								objects). On the reverse transformation they can be reformed back
                           								into a single atomic value.
                        </div>
                     </div>
                  </div>
                  				
               </div>
            </div>
         </div>
      </div><a name="JXONTransformationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e453">
         <div class="title e454">JXON Transformations</div>
         <div class="para e455">The current JXON design and implementation supports the following types of
            			transformations. Since JXON is still in development these will likely change as
            			experience is gained and the implementation matures. A primary goal of choosing
            the
            			types of transformations is to find the right level of control of the mapping logic
            			which is both implementable and not too difficult for the user to control. The
            rules use
            			information from the schema as well as allow configuration properties externally
            (via
            			the configuration file and inline schema annotations). These transformation rules,
            and
            			their properties, are then grouped into "patterns" which can be applied 'as is'
            or
            			overridden with specific changes.
         </div><a name="AtomicTypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e456">
            <div class="title e457">Atomic Types</div>
            <div class="para e458">JXON uses the schema type declarations for simple types to attempt to determine
               				the proper JSON type. The XSD schema type hierarchy is searched until a matching
               				known type is found. If a matching type is found then the corresponding JSON type
               is
               				used, otherwise the String type is used.
            </div>
            <div class="para e459">Any type derived from xs:double, xs:float or xs:decimal are mapped to a JSON
               				Number.
            </div>
            <div class="para e460">Any type derived from xs:boolean is mapped to a JSON Boolean literal.</div>
            <div class="para e461">All other types are mapped to a JSON String.</div>
            <div class="para e462">Empty XML elements are mapped a JSON null.
               <div class="table e463" frame="box" rules="all">
                  <div class="caption e464">
                     <div class="para e465">Example Atomic Type Conversion</div>
                  </div>
                  <div class="thead e466">
                     <div class="tr e467">
                        <div class="th e468">xs:type</div>
                        <div class="th e469">XML</div>
                        <div class="th e470">JSON</div>
                     </div>
                  </div>
                  <div class="tbody e471">
                     <div class="tr e472">
                        <div class="td e473">xs:integer</div>
                        <div class="td e474">1</div>
                        <div class="td e475">1</div>
                     </div>
                     <div class="tr e476">
                        <div class="td e477">xs:boolean</div>
                        <div class="td e478">true</div>
                        <div class="td e479">true</div>
                     </div>
                     <div class="tr e480">
                        <div class="td e481">xs:string</div>
                        <div class="td e482">John Doe</div>
                        <div class="td e483">"John Doe"</div>
                     </div>
                     <div class="tr e484">
                        <div class="td e485">empty</div>
                        <div class="td e486">&lt;empty/&gt;</div>
                        <div class="td e487">null</div>
                     </div>
                  </div>
               </div>
            </div><a name="valueelementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e488">
               <div class="title e489">value element</div>
               <div class="para e490">In the JXON schema the "value" element controls how atomic values are
                  					transformed. In the following example, the value element specifies that schema
                  					information should be used for both the value transformation as well as
                  					determine JSON array mapping
               </div>
               <div class="para e491">
                  					
                  <div class="programlisting e492" xml:space="preserve">
                     	&lt;value wrap="schema" type="schema" /&gt;
                     
                  </div>
                  				
               </div>
               <div class="para e493"> The following overrides default behaviour and specifies that the JSON Number type
                  should
                  					be used with no wrapping 
                  <div class="programlisting e494" xml:space="preserve">
                     	&lt;value type="number" /&gt;
                     
                  </div>
                  				
               </div>
            </div>
         </div><a name="StructuredTypesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e495">
            <div class="title e496">Structured Types</div>
            <div class="para e497">JXON maps XSD "list" types (and derived types such as IDTOKENS) to JSON arrays and
               				on reverse maps the associated arrays back to a space separated atomic value.
               
            </div>
            <div class="para e498">
               				
               <div class="table e499" frame="box" rules="all">
                  <div class="caption e500">
                     <div class="para e501">Example list type conversions</div>
                  </div>
                  <div class="thead e502">
                     <div class="tr e503">
                        <div class="th e504">xs:type</div>
                        <div class="th e505">XML</div>
                        <div class="th e506">JSON</div>
                     </div>
                  </div>
                  <div class="tbody e507">
                     <div class="tr e508">
                        <div class="td e509">xs:NMTOKENS</div>
                        <div class="td e510">Hi There</div>
                        <div class="td e511">[ "Hi","There"]</div>
                     </div>
                     <div class="tr e512">
                        <div class="td e513">xs:IDREFS</div>
                        <div class="td e514">id1 id2 id3</div>
                        <div class="td e515">[ "id2" , "id2" , "id3"]</div>
                     </div>
                     <div class="tr e516">
                        <div class="td e517">&lt;xs:list itemType="xs:integer"/&gt;</div>
                        <div class="td e518">1 2 3 4</div>
                        <div class="td e519">[ 1 , 2 , 3 , 4]</div>
                     </div>
                  </div>
               </div>
               			
            </div>
            <div class="para e520"> The value element can be used to force wrapping by a JSON array even if the
               				schema does not identify a value as a list type. For example the following overrides
               				the schema information and tells the JXON processor to wrap the value with a JSON
               				array of strings. 
               <div class="programlisting e521" xml:space="preserve">
                  	&lt;value type="string" wrap="array"/&gt;
                  
               </div>
               			
            </div>
         </div><a name="NamingandnamespacesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e522">
            <div class="title e523">Naming and namespaces</div>
            <div class="para e524">JXON provides a flexible method for configuring name transformations. JSON and XML
               names
               				can differ significantly in possible characters and practical use. The default
               				configuration is to ignore namespaces and use the same name for XML elements and
               				attributes as JSON members. Although namespaces are not present in the JSON document
               				they are reconstructed when translating JSON to XML. Thie naming rule can be
               				overridden on a type, element or attribute basis (and child items) by supplying
               a
               				regular expression which translates the full XML name (in Clark notation
               <div class="popupBox e525">
                  <div class="popupLabel" onmouseover="$('#d1e922').show('1000');" onmouseout="$('#d1e922').hide('1000');">[ footnote ]</div>
                  <div id="d1e922" style="display: none;">
                     <div class="footnote">
                        <div class="para e526">"Clark Notation" is an informal name given to the proposal by James Clark for a simple
                           represtntation of QNames 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e527" xlink:actuate="onRequest" xlink:href="http://www.jclark.com/xml/xmlns.htm" xlink:show="new" xlink:type="simple">http://www.jclark.com/xml/xmlns.htm</div>
                        </div>
                     </div>
                  </div>
               </div>) to the
               				JSON name. This allows the uri and localname portions of a QName to be used in
               				generation of a JSON name. Since the document instance is not avaiable during
               rule
               				generation, namespace prefixes are not known so are not accounted for in the naming
               				rules. You do not have to supply the reverse regex for reverse mappings, in fact
               the
               				mappings can be lossy while still being fully reversable because the naming
               				information is stored in the XSLT files. The JSON member names have to be unique
               				within a JSON object, however, in order to be able to match the corresponding
               XSLT
               				rule (and XML name). It is interesting to note that even if namespace information
               is
               				not mapped into the JSON output, that namespaces are not lost on reverse mapping.
               It
               				is only in the case where multiple element or attributes with the same name but
               in
               				different namespaces are used within a single schema and document instance that
               				namespaces need be considered at all in the nameing mappings to provide for lossless
               				round tripping.
            </div>
            <div class="para e528">This naming rule can also be used to get around the problem of same-named
               				attributes and elements in XML by assigning them unique names in JSON.
            </div>
            <div class="para e529">
               				
               <div class="table e530">
                  <div class="metaBox e531"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e933').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e933" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">class='e531'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='35%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e532"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e934').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e934" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">class='e532'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='31%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="metaBox e533"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e935').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e935" class="metaSource" style="display:none;">                
                        &lt;col<span class="metaAttribute">class='e533'
                           </span><span class="metaAttribute">span='1'
                           </span><span class="metaAttribute">width='34%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
                  <div class="thead e534">
                     <div class="tr e535">
                        <div class="th e536">Name rule</div>
                        <div class="th e537">Clark Name</div>
                        <div class="th e538">JSON Name</div>
                     </div>
                  </div>
                  <div class="tbody e539">
                     <div class="tr e540">
                        <div class="td e541">&lt;json_name search="\{([^}]*)\}?(.+)$" replace="$2"/&gt;</div>
                        <div class="td e542">{http://www.myorg.org}name</div>
                        <div class="td e543">name</div>
                     </div>
                     <div class="tr e544">
                        <div class="td e545">&lt;json_name name="Json Name"/&gt;</div>
                        <div class="td e546">{http://www.myorg.org}name</div>
                        <div class="td e547">Json Name</div>
                     </div>
                     <div class="tr e548">
                        <div class="td e549">&lt;json_name search="\{([^}]*)\}?(.+)$" replace="1_$2"/&gt;</div>
                        <div class="td e550">{http://www.myorg.org}name</div>
                        <div class="td e551">1_name</div>
                     </div>
                  </div>
               </div>
               			
            </div>
         </div><a name="ElementsandAttributesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e552">
            <div class="title e553">Elements and Attributes</div>
            <div class="para e554">XML Elements and Attributes are both mapped to JSON Object members. JSON Object
               				members must be a direct child of a JSON Object. This implies that all XML Elements
               				and Attributes must be placed as direct children of a JSON Object (must not be
               				parent-less or a direct child of a JSON Array.). The Element and Attribute rules
               				interact with the Wrapping Rules to enforce this constraint as well as provides
               				variants on how elements and attributes are placed within the containing object.
               
            </div><a name="childrenelementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e555">
               <div class="title e556">children element</div>
               <div class="para e557">The children element in JXON specifies how to encode XML element children in
                  					JSON. The following declaration in the "full" pattern specifies that child
                  					elements should be wrapped in a JSON object as the "_children" member 
               </div>
               <div class="programlisting e558" xml:space="preserve">
                  	&lt;children wrap="object" name="_children" /&gt;
                  
               </div>
               <div class="para e559">The following declaration used in the "simple" pattern specifies that child
                  					elements are transformed into JSON members without wrapping
                  <div class="programlisting e560" xml:space="preserve">
                     	&lt;children wrap="none" /&gt;
                     
                  </div> Of course this will only produce valid JSON if there are no repeated elements
                  					or are duplicates of unwrapped attributes. 
               </div>
            </div><a name="attributeselementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e561">
               <div class="title e562">attributes element</div>
               <div class="para e563">The attributes element in JXON specifies how to encode XML attributes in JSON.
                  					The following declaration in the "full" pattern specifies that attributes are
                  					wrapped in a JSON object as the "_attributes" member. 
                  <div class="programlisting e564" xml:space="preserve">
                     
                     	&lt;attributes wrap="object" name="_attributes" /&gt;
                     
                  </div>
               </div>
               <div class="para e565">The following declaration used in the "simple" pattern specifies that
                  					attributes are transformed into JSON members without wrapping
                  <div class="programlisting e566" xml:space="preserve">
                     	&lt;attributes wrap="none" /&gt;
                     
                  </div>
                  				
               </div>
            </div>
         </div><a name="TextelementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e567">
            <div class="title e568">Text elements</div>
            <div class="para e569">Text elements can be treated as simple values or as objects. They can be wrapped
               				along with child elements, or in their own member. The JXON text element determines
               				the behaviour. 
            </div>
            <div class="para e570">The following example from the "simple" pattern wraps all text into an object
               				member named "_text".
            </div>
            <div class="programlisting e571" xml:space="preserve">
               	&lt;text wrap="object" name="_text" /&gt;
               
            </div>
            <div class="para e572">The following example from the "full" pattern treats text the same as child
               				elements (putting each text element as a separate value in the _children
               				array)
            </div>
            <div class="programlisting e573" xml:space="preserve">
               	&lt;text wrap="none"/&gt;
               
            </div>
         </div>
      </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e574">
         <div class="title e575">Implementation</div>
         <div class="para e576">The current JXON implementation is an experimental prototype with the intent of exploring
            			the design and usefulness of the architecture. The intent is to become a production
            			quality tool, but at the time of this writing it is still in prototype phase; functional
            			but not yet feature complete. The code is entirely open source, uses only open
            source
            			libraries and is licensed with the "Simplified BSD License".
            <div class="popupBox e577">
               <div class="popupLabel" onmouseover="$('#d1e1014').show('1000');" onmouseout="$('#d1e1014').hide('1000');">[ footnote ]</div>
               <div id="d1e1014" style="display: none;">
                  <div class="footnote">
                     <div class="para e578">
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e579" xlink:actuate="onRequest" xlink:href="http://www.freebsd.org/copyright/freebsd-license.html" xlink:show="new" xlink:type="simple">http://www.freebsd.org/copyright/freebsd-license.html</div> "Simplified BSD License" also known as the "2 clause BSD License" and
                        					the "FreeBSD License"
                     </div>
                  </div>
               </div>
            </div> It is distributed as part of the JSON extension module for xmlsh 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e580" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org/ModuleJson" xlink:show="new" xlink:type="simple">http://www.xmlsh.org/ModuleJson</div>.
            			The code can run within xmlsh itself or as an independant command or embedded in
            a java
            			application.
         </div>
         <div class="para e581">As described in the Design Overview, JXON produces a pair of XSLT files from a schema
            			and a configuration file. These XSLT files can then be used for transformations
            without
            			further reference to the schema or the JXON processor. Input and output to the
            XSLT
            			files are XML. On the JSON side this is XML in JXML format which can be converted
            to and
            			from JSON losslessly, or converted to other lossless formats such as JSONX
            <div class="xref e582" linkend="jsonx"></div>.
         </div>
         <div class="figure e583" xml:id="jsonxslt">
            <div class="title e584">JXON Processor implementation</div>
            <div class="mediaobject e585">
               <div class="imageobject e586">
                  <div class="metaBox e587"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1032').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1032" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e587'
                           </span><span class="metaAttribute">fileref='../../../vol7/graphics/Lee01/Lee01-005.jpg'
                           </span><span class="metaAttribute">format='jpg'
                           </span><span class="metaAttribute">width='50%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e588">
               <div class="para e589">JXON Processor implementation internals</div>
            </div>
         </div>
         <div class="para e590">The resulting XSLT is produced as XSLT 2.0 for a non-schema-aware processor so that
            the
            			entire process may be executed entirely with open source software. 
         </div><a name="JXONProcessorANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e591">
            <div class="title e592">JXON Processor</div>
            <div class="para e593">The JXON processor (
               <div class="xref e594" linkend="figure1"></div>) is run once per schema to produce the pair
               				of transformation XSLT files. The program (called "jsonxslt" 
               <div class="xref e595" linkend="jsonxslt"></div>.) is written partially in Java and partially in XQuery. The
               				Java portion parses command line arguments, reads the Schema (using the Apache
               				implementation of the XML Schema API) and generates a much simpler form of the
               				schema and annotations in XML form. The intermediary schema format corresponds
               to
               				the same schema as the configuration format as well as the annotation (JXON).
               This
               				allows the configuration data to be cleanly merged with the annotation and the
               				resulting document and internal representations all having the same namespace
               and
               				sharing the same meaning for items. 
            </div>
            <div class="para e596">Java is used for this component because parsing, and particularly comprehending
               				XSD schema is a challenging task suited well to reusing an existing API. The
               				simplified schema and the global configuration file is then passed to the XQuery
               				component, once each for conversion to XSLT for the JSON to XML translation and
               				again for producing the XML to JSON. XQuery was chosen for this component because
               it
               				is a good fit for XQuery. The process is largely that of querying and producing
               XML
               				(XSLT) output from a complex set of algorithms. The two XQuery programs are tightly
               				coupled (and share common modules). This is necessary because the specifics of
               the
               				XSLT rules generated for one direction need to match exactly the rules generated
               for
               				the reverse direction in order to achieve round trip transformations. 
            </div>
            <div class="para e597">The result is 2 XSLT files which have encoded all the rules, augmented by the annotations,
               				into a set of XSLT templates. These templates match every element and attribute
               of
               				the input (Either XML or JXML), apply the encoded transformation and output the
               				transformed XML.  (
               <div class="emphasis e598">See </div>
               <div class="xref e599" linkend="apendex_xslt"></div>
            </div><a name="ParsingSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e600">
               <div class="title e601">Parsing Schema</div>
               <div class="para e602"> </div><a name="RNGSupportANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e603">
                  <div class="title e604">RNG Support</div>
                  <div class="para e605">Ideally native support for RelaxNG will be built into the project but for
                     						now support is by means of the 
                     <div class="emphasis e606">trang 
                        <div class="xref e607" linkend="trang"></div>
                     </div> converter and a transformation which converts XSD comments
                     						into XSD Annotations. Comments are used instead of RNG annotations because
                     						trang does not sufficiently support translating RNG annotations to XSD
                     						annotations.
                  </div>
               </div>
            </div>
         </div><a name="ConvertingbetweenJSONandJXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e608" xml:id="jxml">
            <div class="title e609">Converting between JSON and JXML</div>
            <div class="para e610">As described in the design, the JXON processor consumes and produces JSON in JXML
               				format. This could in theory be any other full fidelity JSON representation in
               				XML.
            </div>
            <div class="para e611">This JXML format may be useful by itself as it can be converted to other JSON XML
               				formats such as JSONX 
               <div class="xref e612" linkend="jsonx"></div>or used as an input to other processors
               				that operate purely on the JSON Object Model as apposed to the JSON Serialized
               Text
               				form.
            </div>
            <div class="para e613">To convert from JSON to JXML and reverse, two tools are used from xmlsh command
               				library (json2xml, xml2json). These tools are very simple and can be run standalone
               				(outside the xmlsh environment), or could be re-implemented easily. Source code
               is
               				available for these tools as well as all of xmlsh, also licensed using the
               				Simplified BSD License. The json2xml tool makes use of the JSON API available
               from
               				json.org, with some minor enhancements, mainly to preserve the order of object
               				members while parsing JSON. The xml2json tool does not use the JSON API because
               of
               				severe limits to that library, rather the serialization was written from
               				scratch.
            </div>
            <div class="para e614">Neither of these tools are particularly complicated and could be replaced by user
               				written code. The techniques for parsing and serializing JSON are well known and
               				many implementations are available. You can see from the sample below that the
               JXML
               				format is extremely verbose, but its advantage is it directly models the JSON
               data
               				model.
            </div>
         </div><a name="XSLTprocessingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e615">
            <div class="title e616">XSLT processing</div>
            <div class="para e617">Once the JXON process is complete the 2 resulting XSLT files can be used at any
               				time. One file is used to transform JSON as represented in JXML to the target
               XML
               					
               <div class="emphasis e618" role="ital">See</div>
               				
               <div class="xref e619" linkend="fig_json2xml"></div>. 
            </div>
            <div class="para e620">The other file is used to transform XML to JXML 
               <div class="emphasis e621" role="ital">See</div>
               				
               <div class="xref e622" linkend="fig_xml2json"></div>.
            </div>
            <div class="para e623">The conversion between JXON and JSON is performed using the json2xml and xml2json
               				tools 
               <div class="emphasis e624" role="ital">See</div>
               				
               <div class="xref e625" linkend="jxml"></div>
            </div>
            <div class="para e626">The XSLT files are currently created to run with any XSLT 2.0 non-schema aware
               				processor. The implementation uses Saxon
               <div class="popupBox e627">
                  <div class="popupLabel" onmouseover="$('#d1e1106').show('1000');" onmouseout="$('#d1e1106').hide('1000');">[ footnote ]</div>
                  <div id="d1e1106" style="display: none;">
                     <div class="footnote">
                        <div class="para e628">SAXON - The XSLT and XQuery Processor
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e629" xlink:actuate="onRequest" xlink:href="http://saxon.sourceforge.net/" xlink:show="new" xlink:type="simple">http://saxon.sourceforge.net/</div>
                        </div>
                     </div>
                  </div>
               </div>
               			
            </div>
         </div>
      </div><a name="Retrospective;LimitationsandLessonsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e630">
         <div class="title e631">Retrospective; Limitations and Lessons</div>
         <div class="para e632">JXON began as an experiment to explore the feasibility of intelligent cross markup
            			transformations. Key to this experiment is the recognition that Markup Schema contains
            			significant information which can be used to aid cross markup transformation.
            			Recognizing this I assert that in essence cross markup transformation is fundamentally
            a
            			Schema oriented issue, not a document instance issue. Lack of JSON Schema places
            a
            			severe limit in the amount of automated decision making possible leaving one side
            only
            			with schema information. This limit did make many design decisions easier, although
            less
            			ideal, in particular to focus on the XML schema as the source of transformation
            logic. 
         </div><a name="UseofXSDSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e633">
            <div class="title e634">Use of XSD Schema</div>
            <div class="para e635">Recognizing that Schema was a core concept in the design, XSD Schema was chosen for
               the
               				implementation. In concept any schema language should work, but XSD was chosen
               due
               				to its prevalence and the availability of API's which can query the schema (XML
               				Schema API). XSD Schema is complex. The fact that an API is needed to query it
               to
               				get meaningful information (instead of say using XQuery directly on the schema),
               is
               				an indication of how complex it is. Even the API itself is complex. This decision
               				required the use of a Java component instead of relying entirely on XML tools.
               
            </div>
            <div class="para e636">Ideally any XML Schema language should be able to be able to be used. Since the source
               				schema is only used early on in the work-flow (to generate a simpler intermediate
               				document), supporting alternative schemas such as RNG natively should not be that
               				difficult and may be introduced in a later version of the implementation.  The
               				current support for RNG via translation to XSD is a viable alternative.
            </div><a name="RequiresanXMLSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e637">
               <div class="title e638">Requires an XML Schema</div>
               <div class="para e639">Since the transformation generation is Schema based, this implies you must
                  					have an XML Schema to define a transformation. If you are starting with XML
                  					there are many tools to generate a schema based on sample XML. But if you are
                  					starting with JSON there are no such tools. This is an area which could use
                  					improvement. For now you are forced to create a schema which matches up with
                  how
                  					the JSON would be generated using one of the existing patterns. Perhaps a
                  					schema-less transformation mode would be useful to bootstrap this
                  					process.
               </div>
            </div><a name="RecursivestructuresANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e640">
               <div class="title e641">Recursive structures</div>
               <div class="para e642">JXON allows for recursive structures insomuch as XSD does. Since rules are
                  					associated with a specific element declaration you cannot target different rules
                  					for different levels of recursion.
               </div>
            </div><a name="LocalElementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e643">
               <div class="title e644">Local Elements</div>
               <div class="para e645">JXON allows for local elements in XSD. Local elements of the same name as
                  					other local or global elements can be targeted individually. This allows
                  					samed-named XML elements to map to differently named JSON elements. However,
                  as
                  					in recursion, it is only supported in the same fashion as XSD. If a document
                  					instance references the same element in different contexts they cannot be
                  					targeted differently unless it is a local element declaration.
               </div>
            </div>
         </div><a name="UseofSchemaAnnotationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e646">
            <div class="title e647">Use of Schema Annotations</div>
            <div class="para e648">The choice of using XML Schema (particularly XSD) then led to the decision to put
               				the human augmented information into the XML schema document itself (as
               				annotations). This decision is definitely debatable. 
            </div>
            <div class="para e649">The advantage of annotating the schema itself instead of using an external "rules
               file" is
               				that information can be associated directly to the specific item (type, element,
               				attribute) without having to target that item externally with perhaps XPath or
               type
               				references. The transformation logic then resides right with the item definitions
               in
               				the schema and contains a minimal amount of extra information. On the other hand,
               				this forces editing of the schema in order to modify the transformation logic.
               				Different transformations for the same class of documents then requires separate
               				schemas. This means that different schemas may need to be maintained that differ
               				only in the JXON annotations. While JXON does not require that instance documents
               				use the same schema during transformation as was used during the generation process,
               				this can be a problem as changes to the authoritative schema require editing the
               				schemas used for the JXON configurations. 
            </div>
            <div class="para e650">Another issue of annotating schema directly is that it requires duplication of
               				information if the same properties are to be applied to different items. This
               is
               				mitigated by the use of "patterns" which group properties and allow you to specify
               				only the pattern name. However if the rules were in an external file they could
               use
               				a single definition for common properties and use instead multiple targets (e.g
               				XPaths) to apply the properties to multiple items. 
            </div>
         </div><a name="Intermediatefile(JXONdocument)generationinJavaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e651">
            <div class="title e652">Intermediate file (JXON document) generation in Java</div>
            <div class="para e653">Use of the Apache implementation of the XML Schema API requires use of a Java component
               for
               				part of the generation process. To minimize the reliance on Java coding an
               				intermediate XML file is generated with a simplified version of the schema along
               				with the annotations. This worked out fairly well as it separated the logic for
               				parsing the schema from the rest of the processing. One problem is that the format
               				for the intermediate is a moving target. Exactly what constitutes a "minimal
               				simplified representation of the schema" depends on the needs of downstream
               				processing. Adding new features and making changes to the XSLT generation code
               often
               				requires going back to the Java code to add or change the content of the
               				intermediate file.
            </div>
            <div class="para e654">Once the initial stage is complete then the rest of the XSLT generation can be
               				done using pure XML tools. This allowed for easier development and debugging.
               
            </div>
            <div class="para e655">Use of an intermediate representation for the schema also benefits from being
               				schema language agnostic. A different input schema language (such as RelaxNG)
               could
               				be used while generating the same JXON intermediate format and leaving the rest
               of
               				the processing unchanged.
            </div>
         </div><a name="XQueryforXSLTgenerationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e656">
            <div class="title e657">XQuery for XSLT generation</div>
            <div class="para e658">XQuery is used to generate the XSLT output given the intermediate schema file and
               a
               				configuration file. Choice of XQuery seems a good fit for the problem. The input
               and
               				output is entirely XML and the processing logic is query and data oriented logic
               				operations. This fits the XQuery use case quite well. Certainly XSLT or Java could
               				have been used for this component, but the choice of XQuery worked well.
            </div>
         </div><a name="XSLTfortransformationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e659">
            <div class="title e660">XSLT for transformation</div>
            <div class="para e661">The output of the JXON processor is a pair of XSLT files. These XSLT files are
               				used for the actual transformations. Choice of XSLT seems an obvious match. The
               				transformation is a collection of matching templates along with generation rules.
               				This fits the XSLT model very well. 
            </div><a name="AutogenerationofXSLTANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e662">
               <div class="title e663">Auto generation of XSLT</div>
               <div class="para e664">In practice the resultant XSLT can be both large and non-ideal. For example
                  					the XSLT for Docbook is over 10,000 templates. XSLT 2.0 without schema support
                  					was chosen for the initial implementation. The rationale is to provide an
                  					implementation which is entirely "open source" and can be run without licensing.
                  					However since the problem is fundamentally a schema problem, making use of a
                  					schema-aware XSLT may have significant value. For example when a rule applies
                  to
                  					a type, templates are generated for every possible occurrence of that type.
                  					Using a schema aware XSLT processor could optimize this to matching on types
                  					instead of names (at least for the XML to JSON conversion). 
               </div>
               <div class="para e665">Generation of the XSLT code is also quite tricky and difficult to debug which
                  					limits ease of adding transformation rules. In particular writing the code that
                  					generates XSLT which can transform bidirectionally is quite tedious. This is
                  					definitely an area that could use significantly improvement and
                  					optimization.
               </div>
            </div>
         </div><a name="NamingandnamespacesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e666">
            <div class="title e667">Naming and namespaces</div>
            <div class="para e668">The mechanism for customizing name and namespace mappings is based on regular
               				expressions. This is quite powerful but may not be powerful enough. The reason
               				regular expressions were chosen is an artifact of the implementation; is that
               its
               				the most flexible string manipulation feature in XQuery which doesn't require
               an
               				"eval". This area could use enhancements.
            </div>
            <div class="para e669">The naming rules only have access to the localname and URI of the QName. This means
               that
               				prefixes cannot be used as part of the name mappings. When generating XML from
               JSON
               				prefixes are constructed and namespace declarations are added as needed. The
               				resulting XML will most likely have a different lexical representation then a
               source
               				XML after round tripping due to the difference in prefixes and locations of
               				namespace declarations. Possibly making use of the prefix bindings in the XSD
               would
               				be useful although there is no guarantee these same prefixes would be used in
               				instance documents.
            </div>
            <div class="para e670">Using the default naming rules which ignore the namespace when generating JSON can
               lead to
               				ambiguity problems if two QNames from different namespaces are allowed as attribute
               				or child element names in a given element. This is resolved by overriding the
               naming
               				rule for one of the ambiguous names.
            </div>
            <div class="para e671">Better control over prefix assignment and namespace declaration placement would be
               				a useful enhancement.
            </div>
         </div><a name="CharacterSetANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e672">
            <div class="title e673">Character Set</div>
            <div class="para e674">JXON uses JXML's handling of non-XML representable characters such as \0 by
               				keeping them in JSON escaped format when mapped to XML. While this is losses,
               it is
               				non-ideal as it takes application logic to parse these values correctly. I know
               of
               				no better solution to this problem as XML simply cannot encode the full Unicode
               				code-set which is allowed in JSON.
            </div>
         </div>
      </div><a name="AppendixANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e675">
         <div class="title e676">Appendix</div><a name="PatternsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e677" xml:id="patterns">
            <div class="title e678">Patterns</div>
            <div class="para e679">The following is the JXON global configuration markup of the "full" and "simple"
               				patterns.
            </div>
            <div class="programlisting e680" xml:space="preserve">
               &lt;patterns xmlns="http://www.xmlsh.org/jxon" default="full"&gt;
               	&lt;pattern name="full"&gt;
               		&lt;element&gt;
               			&lt;!-- Wrap all child text and elements in an object --&gt;
               			&lt;children wrap="object" name="_children" /&gt;
               			
               			&lt;!-- Wrap all attributes in an object --&gt;
               			&lt;attributes wrap="object" name="_attributes" /&gt;
               
               			&lt;!-- Do not wrap text by itself, it is in the _children --&gt;
               			&lt;text wrap="none"/&gt;
               
               			&lt;!-- Values are typed and wrapped according to schema --&gt;
               			&lt;value wrap="schema" type="schema" /&gt;
               			&lt;json_name	search="\{([^}]*)\}?(.+)$" replace="$2"/&gt;
               		&lt;/element&gt;
               
               		&lt;attribute&gt;
               			&lt;value wrap="schema" type="schema" /&gt;
               			&lt;json_name	search="\{([^}]*)\}?(.+)$" replace="$2"/&gt;
               		&lt;/attribute&gt;
               
               	&lt;/pattern&gt;
               
               	&lt;pattern name="simple"&gt;
               		&lt;element&gt;
               			&lt;children wrap="none" /&gt;
               			&lt;attributes wrap="none" /&gt;
               			&lt;text wrap="object" name="_text" /&gt;
               			&lt;value wrap="schema" type="schema" /&gt;
               			&lt;json_name	search="\{([^}]*)\}?(.+)$" replace="$2"/&gt;
               			&lt;override/&gt;
               		&lt;/element&gt;
               		&lt;attribute&gt;
               			&lt;value wrap="schema" type="schema" /&gt;
               			&lt;json_name	search="\{([^}]*)\}?(.+)$" replace="$2"/&gt;
               		&lt;/attribute&gt;
               	&lt;/pattern&gt;
               
               &lt;/patterns&gt; 
               
            </div>
         </div><a name="ExampleofJSONfileconvertedintoJXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e681" xml:id="jsontojxml">
            <div class="title e682">Example of JSON file converted into JXML</div>
            <div class="para e683">JSON Sample</div>
            <div class="programlisting e684" xml:space="preserve">{
               	"id": "0001",
               	"type": "donut",
               	"name": "Cake",
               	"ppu": 0.55,
               
               	"topping":
               		[
               			{ "id": "5001", "type": "None" },
               			{ "id": "5002", "type": "Glazed" },
               			{ "id": "5005", "type": "Sugar" },
               		]
               }
            </div>
            <div class="para e685">JXML Sample</div>
            <div class="programlisting e686" xml:space="preserve">&lt;object xmlns="http://www.xmlsh.org/jxml"&gt;
               &lt;member name="id"&gt;
               &lt;string&gt;0001&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="type"&gt;
               &lt;string&gt;donut&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="name"&gt;
               &lt;string&gt;Cake&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="ppu"&gt;
               &lt;number&gt;0.55&lt;/number&gt;
               &lt;/member&gt;
               &lt;member name="topping"&gt;
               &lt;array&gt;
               &lt;object&gt;
               &lt;member name="id"&gt;
               &lt;string&gt;5001&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="type"&gt;
               &lt;string&gt;None&lt;/string&gt;
               &lt;/member&gt;
               &lt;/object&gt;
               &lt;object&gt;
               &lt;member name="id"&gt;
               &lt;string&gt;5002&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="type"&gt;
               &lt;string&gt;Glazed&lt;/string&gt;
               &lt;/member&gt;
               &lt;/object&gt;
               &lt;object&gt;
               &lt;member name="id"&gt;
               &lt;string&gt;5005&lt;/string&gt;
               &lt;/member&gt;
               &lt;member name="type"&gt;
               &lt;string&gt;Sugar&lt;/string&gt;
               &lt;/member&gt;
               &lt;/object&gt;
               &lt;/array&gt;
               &lt;/member&gt;
               &lt;/object&gt;
            </div>
         </div><a name="FullexampleANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e687">
            <div class="title e688">Full example</div>
            <div class="para e689">The following is a full example of a bidirectional round trip JSON/XML
               				transformation using a variant of the "BOOKS" schema
            </div><a name="XSDSchemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e690">
               <div class="title e691">XSD Schema</div>
               <div class="para e692">The XSD schema marked up with JXON annotations</div>
               <div class="programlisting e693" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:jxon="http://www.xmlsh.org/jxon"&gt;
                  	&lt;!-- Default document pattern is "full" --&gt;
                  	&lt;xs:element name="BOOKLIST"&gt;
                  	&lt;xs:annotation&gt;
                  		&lt;!--BOOKLIST and decendants follow "simple" pattern --&gt;
                  		&lt;xs:appinfo&gt;
                  			&lt;jxon:pattern name="simple" /&gt;
                  		&lt;/xs:appinfo&gt;
                  	&lt;/xs:annotation&gt;
                  		&lt;xs:complexType&gt;
                  			&lt;xs:sequence&gt;
                  				&lt;xs:element ref="BOOKS"/&gt;
                  				&lt;xs:element ref="CATEGORIES"/&gt;
                  			&lt;/xs:sequence&gt;
                  		&lt;/xs:complexType&gt;
                  	&lt;/xs:element&gt;
                  
                  	&lt;xs:element name="BOOKS"&gt;
                  		&lt;xs:annotation&gt;
                  		&lt;xs:appinfo&gt;
                  			&lt;!-- Wrap all child elements in a JSON Array --&gt;
                  			&lt;jxon:children wrap="array" /&gt;
                  		&lt;/xs:appinfo&gt;
                  	&lt;/xs:annotation&gt;
                  		&lt;xs:complexType&gt;
                  			&lt;xs:sequence&gt;
                  				&lt;xs:element ref="ITEM" maxOccurs="unbounded"/&gt;
                  			&lt;/xs:sequence&gt;
                  		&lt;/xs:complexType&gt;
                  	&lt;/xs:element&gt;
                  
                  	&lt;xs:element name="CATEGORIES"&gt;
                  
                  		
                  		&lt;xs:complexType mixed="true"&gt;
                  			&lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                  				&lt;xs:element ref="CATEGORY"/&gt;
                  			&lt;/xs:sequence&gt;
                  			&lt;xs:attribute name="DESC" type="xs:string" use="required"/&gt;
                  		&lt;/xs:complexType&gt;
                  	&lt;/xs:element&gt;
                  	&lt;xs:element name="CATEGORY"&gt;
                  		&lt;xs:annotation&gt;
                  			&lt;!-- CATEGORY and children use the simple pattern --&gt;
                  			&lt;xs:appinfo&gt;
                  				&lt;jxon:pattern  name="simple"/&gt;
                  			&lt;/xs:appinfo&gt;
                  		&lt;/xs:annotation&gt;
                  		&lt;xs:complexType&gt;
                  			&lt;xs:attribute name="CODE" type="xs:ID" use="required"/&gt;
                  			&lt;xs:attribute name="DESC" type="xs:string" use="required"&gt;
                  
                  			&lt;/xs:attribute&gt;
                  			&lt;xs:attribute name="NOTE" type="xs:string" use="optional"/&gt;
                  		&lt;/xs:complexType&gt;
                  	&lt;/xs:element&gt;
                  
                  	&lt;xs:element name="ITEM"&gt;
                  	&lt;xs:annotation&gt;
                  		&lt;xs:appinfo&gt;
                  			&lt;!-- ITEM and children use the simple pattern --&gt;
                  			&lt;jxon:pattern name="simple" /&gt;
                  			&lt;!-- Rename the XML ITEM element to BOOK in JSON --&gt;
                  			&lt;jxon:json_name name="BOOK"/&gt;
                  
                  		&lt;/xs:appinfo&gt;
                  	&lt;/xs:annotation&gt;
                  		&lt;xs:complexType&gt;
                  			&lt;xs:sequence&gt;
                  				&lt;xs:element name="TITLE" type="xs:string" minOccurs="1"&gt;
                  				&lt;/xs:element&gt;
                  				&lt;xs:element name="AUTHOR" type="xs:string"/&gt;
                  				&lt;xs:element name="PUBLISHER" type="xs:string"/&gt;
                  				&lt;xs:element name="PUB-DATE" type="xs:date"/&gt;
                  				&lt;xs:element name="LANGUAGE" type="languageType"/&gt;
                  				&lt;xs:element name="PRICE" type="moneyType"&gt;
                  				&lt;/xs:element&gt;
                  				&lt;xs:element name="QUANTITY" type="xs:integer"/&gt;
                  				&lt;xs:element name="ISBN" type="ISBNType"/&gt;
                  				&lt;xs:element name="PAGES" type="xs:integer"&gt;
                  				&lt;xs:annotation&gt;
                  						&lt;xs:appinfo&gt;
                  							&lt;!-- Demonstrate we can override the default JSON type with string --&gt;
                  							&lt;jxon:value  type="string"/&gt;
                  						&lt;/xs:appinfo&gt;
                  				&lt;/xs:annotation&gt;
                  				&lt;/xs:element&gt;
                  				&lt;xs:element name="DIMENSIONS" type="dimensionsType"&gt;
                  					&lt;xs:annotation&gt;
                  						&lt;xs:appinfo&gt;
                  							&lt;!-- Wrap dimension children in an object member named "value" --&gt;
                  							&lt;jxon:text wrap="object" name="value" /&gt;
                  						&lt;/xs:appinfo&gt;
                  					&lt;/xs:annotation&gt;
                  					
                  				&lt;/xs:element&gt;
                  				&lt;xs:element name="WEIGHT" type="weightType"&gt;
                  					&lt;xs:annotation&gt;
                  					&lt;xs:appinfo&gt;
                  						&lt;!-- wrap WEIGHT text in an object member named "amount" --&gt;
                  						&lt;jxon:text wrap="object" name="amount"/&gt;
                  					&lt;/xs:appinfo&gt;
                  				&lt;/xs:annotation&gt;
                  				&lt;/xs:element&gt;
                  			&lt;/xs:sequence&gt;
                  			&lt;xs:attribute name="CAT" type="xs:IDREF" use="required"/&gt;
                  			&lt;xs:attribute name="TAX" type="xs:NMTOKEN" use="optional" default="V"/&gt;
                  		&lt;/xs:complexType&gt;
                  	&lt;/xs:element&gt;
                  
                  	&lt;xs:simpleType name="languageType"&gt;
                  		&lt;xs:restriction base="xs:string"&gt;
                  			&lt;xs:enumeration value="English"/&gt;
                  			&lt;xs:enumeration value="French"/&gt;
                  			&lt;xs:enumeration value="German"/&gt;
                  			&lt;xs:enumeration value="Spanish"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:complexType name="moneyType"&gt;
                  		&lt;xs:simpleContent&gt;
                  			&lt;xs:extension base="xs:decimal"&gt;
                  				&lt;xs:attribute name="currency" type="currencyType"/&gt;
                  			&lt;/xs:extension&gt;
                  		&lt;/xs:simpleContent&gt;
                  	&lt;/xs:complexType&gt;
                  
                  	&lt;xs:simpleType name="currencyType"&gt;
                  		&lt;xs:restriction base="xs:string"&gt;
                  			&lt;xs:enumeration value="USD"/&gt;
                  			&lt;xs:enumeration value="GBP"/&gt;
                  			&lt;xs:enumeration value="EUR"/&gt;
                  			&lt;xs:enumeration value="CAD"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:simpleType name="ISBNType"&gt;
                  		&lt;xs:restriction base="xs:string"&gt;
                  			&lt;xs:pattern value="[0-9]{9}[0-9X]"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:complexType name="dimensionsType"&gt;
                  		&lt;xs:simpleContent&gt;
                  			&lt;xs:extension base="dimensionsContentType"&gt;
                  				&lt;xs:attribute name="UNIT" type="lengthUnitType"&gt;
                  				&lt;/xs:attribute&gt;
                  			&lt;/xs:extension&gt;
                  		&lt;/xs:simpleContent&gt;
                  	&lt;/xs:complexType&gt;
                  
                  	&lt;xs:simpleType name="dimensionsContentType"&gt;
                  		&lt;xs:restriction&gt;
                  			&lt;xs:simpleType&gt;
                  				&lt;xs:list itemType="dimensionType"/&gt;
                  			&lt;/xs:simpleType&gt;
                  			&lt;xs:length value="3"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:simpleType name="lengthUnitType"&gt;
                  		&lt;xs:restriction base="xs:string"&gt;
                  			&lt;xs:enumeration value="in"/&gt;
                  			&lt;xs:enumeration value="cm"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:simpleType name="dimensionType"&gt;
                  		&lt;xs:restriction base="xs:decimal"&gt;
                  			&lt;xs:minExclusive value="0.00"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  
                  	&lt;xs:complexType name="weightType"&gt;
                  		&lt;xs:simpleContent&gt;
                  					
                  			&lt;xs:extension base="xs:decimal"&gt;
                  				&lt;xs:attribute name="UNIT" type="weightUnitType"/&gt;
                  
                  			&lt;/xs:extension&gt;
                  		&lt;/xs:simpleContent&gt;
                  	&lt;/xs:complexType&gt;
                  
                  	&lt;xs:simpleType name="weightUnitType"&gt;
                  		&lt;xs:restriction base="xs:string"&gt;
                  			&lt;xs:enumeration value="oz"/&gt;
                  			&lt;xs:enumeration value="g"/&gt;
                  		&lt;/xs:restriction&gt;
                  	&lt;/xs:simpleType&gt;
                  &lt;/xs:schema&gt;
                  
               </div>
            </div><a name="BOOKSXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e694">
               <div class="title e695">BOOKS XML</div>
               <div class="para e696">The BOOKS xml file</div>
               <div class="programlisting e697" xml:space="preserve">&lt;BOOKLIST&gt;
                  &lt;BOOKS&gt;
                  	&lt;ITEM CAT="MMP"&gt;
                  	&lt;TITLE&gt;Pride and Prejudice&lt;/TITLE&gt;
                  	&lt;AUTHOR&gt;Jane Austen&lt;/AUTHOR&gt;
                  	&lt;PUBLISHER&gt;Modern Library&lt;/PUBLISHER&gt;
                  	&lt;PUB-DATE&gt;2002-12-31&lt;/PUB-DATE&gt;
                  	&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  	&lt;PRICE&gt;4.95&lt;/PRICE&gt;
                  	&lt;QUANTITY&gt;187&lt;/QUANTITY&gt;
                  	&lt;ISBN&gt;0679601686&lt;/ISBN&gt;
                  	&lt;PAGES&gt;352&lt;/PAGES&gt;
                  	&lt;DIMENSIONS UNIT="in"&gt;8.3 5.7 1.1&lt;/DIMENSIONS&gt;
                  	&lt;WEIGHT UNIT="oz"&gt;6.1&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  	&lt;ITEM CAT="P"&gt;
                  		&lt;TITLE&gt;Wuthering Heights&lt;/TITLE&gt;
                  		&lt;AUTHOR&gt;Charlotte Bront&amp;#xeb;&lt;/AUTHOR&gt;
                  		&lt;PUBLISHER&gt;Penguin Classics&lt;/PUBLISHER&gt;
                  		&lt;PUB-DATE&gt;2002-12-31&lt;/PUB-DATE&gt;
                  		&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  		&lt;PRICE&gt;6.58&lt;/PRICE&gt;
                  		&lt;QUANTITY&gt;113&lt;/QUANTITY&gt;		
                  		&lt;ISBN&gt;0141439556&lt;/ISBN&gt;
                  		&lt;PAGES&gt;430&lt;/PAGES&gt;
                  &lt;DIMENSIONS UNIT="in"&gt;1 5.2 7.8&lt;/DIMENSIONS&gt;
                  		&lt;WEIGHT UNIT="oz"&gt;11.2&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  	&lt;ITEM CAT="P"&gt;
                  		&lt;TITLE&gt;Tess of the d'Urbervilles&lt;/TITLE&gt;
                  		&lt;AUTHOR&gt;Thomas Hardy&lt;/AUTHOR&gt;
                  		&lt;PUBLISHER&gt;Bantam Classics&lt;/PUBLISHER&gt;
                  		&lt;PUB-DATE&gt;1984-05-01&lt;/PUB-DATE&gt;
                  		&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  		&lt;PRICE&gt;4.95&lt;/PRICE&gt;
                  		&lt;QUANTITY&gt;85&lt;/QUANTITY&gt;		
                  		&lt;ISBN&gt;0553211684&lt;/ISBN&gt;
                  		&lt;PAGES&gt;480&lt;/PAGES&gt;
                  &lt;DIMENSIONS UNIT="in"&gt;6.8 4.2 0.8&lt;/DIMENSIONS&gt;
                  		&lt;WEIGHT UNIT="oz"&gt;7.7&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  	&lt;ITEM CAT="P"&gt;
                  		&lt;TITLE&gt;Jude the Obscure&lt;/TITLE&gt;
                  		&lt;AUTHOR&gt;Thomas Hardy&lt;/AUTHOR&gt;
                  		&lt;PUBLISHER&gt;Penguin Classics&lt;/PUBLISHER&gt;
                  		&lt;PUB-DATE&gt;1998-09-01&lt;/PUB-DATE&gt;
                  		&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  		&lt;PRICE&gt;4.95&lt;/PRICE&gt;
                  		&lt;QUANTITY&gt;129&lt;/QUANTITY&gt;		
                  		&lt;ISBN&gt;0140435387&lt;/ISBN&gt;
                  		&lt;PAGES&gt;528&lt;/PAGES&gt;
                  &lt;DIMENSIONS UNIT="in"&gt;7.8 5.2 0.9&lt;/DIMENSIONS&gt;
                  		&lt;WEIGHT UNIT="oz"&gt;10.9&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  	&lt;ITEM CAT="H"&gt;
                  		&lt;TITLE&gt;The Big Over Easy&lt;/TITLE&gt;
                  		&lt;AUTHOR&gt;Jasper Fforde&lt;/AUTHOR&gt;
                  		&lt;PUBLISHER&gt;Hodder &amp;amp; Stoughton&lt;/PUBLISHER&gt;
                  		&lt;PUB-DATE&gt;2005-07-11&lt;/PUB-DATE&gt;
                  		&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  		&lt;PRICE&gt;16.47&lt;/PRICE&gt;
                  		&lt;QUANTITY&gt;129&lt;/QUANTITY&gt;		
                  		&lt;ISBN&gt;0340835672&lt;/ISBN&gt;
                  		&lt;PAGES&gt;346&lt;/PAGES&gt;
                  &lt;DIMENSIONS UNIT="cm"&gt;22.5 18 3.5&lt;/DIMENSIONS&gt;
                  		&lt;WEIGHT UNIT="g"&gt;390&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  	&lt;ITEM CAT="P"&gt;
                  		&lt;TITLE&gt;The Eyre Affair&lt;/TITLE&gt;
                  		&lt;AUTHOR&gt;Jasper Fforde&lt;/AUTHOR&gt;
                  		&lt;PUBLISHER&gt;Penguin&lt;/PUBLISHER&gt;
                  		&lt;PUB-DATE&gt;2003-02-25&lt;/PUB-DATE&gt;
                  		&lt;LANGUAGE&gt;English&lt;/LANGUAGE&gt;
                  		&lt;PRICE&gt;16.47&lt;/PRICE&gt;
                  		&lt;QUANTITY&gt;129&lt;/QUANTITY&gt;		
                  		&lt;ISBN&gt;0142001805&lt;/ISBN&gt;
                  		&lt;PAGES&gt;384&lt;/PAGES&gt;
                  &lt;DIMENSIONS UNIT="in"&gt;7.8 5 0.9&lt;/DIMENSIONS&gt;
                  		&lt;WEIGHT UNIT="oz"&gt;9&lt;/WEIGHT&gt;
                  	&lt;/ITEM&gt;
                  
                  &lt;/BOOKS&gt;
                  &lt;CATEGORIES DESC="Miscellaneous categories"&gt;
                  &lt;CATEGORY CODE="P" DESC="Paperback"/&gt;
                  &lt;CATEGORY CODE="MMP" DESC="Mass-market Paperback"/&gt;
                  &lt;CATEGORY CODE="H" DESC="Hard Cover"/&gt;
                  &lt;/CATEGORIES&gt;
                  &lt;/BOOKLIST&gt;
                  		
               </div>
            </div><a name="BOOKSJSONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e698">
               <div class="title e699">BOOKS JSON</div>
               <div class="para e700">The BOOKS JSON document</div>
               <div class="programlisting e701" xml:space="preserve">{
                  "BOOKLIST":
                  {
                  "BOOKS":
                  [
                  {
                  "BOOK":
                  {
                  "CAT":"MMP",
                  "TITLE":"Pride and Prejudice",
                  "AUTHOR":"Jane Austen",
                  "PUBLISHER":"Modern Library",
                  "PUB-DATE":"2002-12-31",
                  "LANGUAGE":"English",
                  "PRICE":4.95,
                  "QUANTITY":187,
                  "ISBN":"0679601686",
                  "PAGES":"352",
                  "DIMENSIONS":
                  {
                  "UNIT":"in",
                  "value":
                  [8.3,5.7,1.1]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"oz",
                  "amount":6.1
                  }
                  }
                  },
                  {
                  "BOOK":
                  {
                  "CAT":"P",
                  "TITLE":"Wuthering Heights",
                  "AUTHOR":"Charlotte BrontÃ«",
                  "PUBLISHER":"Penguin Classics",
                  "PUB-DATE":"2002-12-31",
                  "LANGUAGE":"English",
                  "PRICE":6.58,
                  "QUANTITY":113,
                  "ISBN":"0141439556",
                  "PAGES":"430",
                  "DIMENSIONS":
                  {
                  "UNIT":"in",
                  "value":
                  [1,5.2,7.8]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"oz",
                  "amount":11.2
                  }
                  }
                  },
                  {
                  "BOOK":
                  {
                  "CAT":"P",
                  "TITLE":"Tess of the d'Urbervilles",
                  "AUTHOR":"Thomas Hardy",
                  "PUBLISHER":"Bantam Classics",
                  "PUB-DATE":"1984-05-01",
                  "LANGUAGE":"English",
                  "PRICE":4.95,
                  "QUANTITY":85,
                  "ISBN":"0553211684",
                  "PAGES":"480",
                  "DIMENSIONS":
                  {
                  "UNIT":"in",
                  "value":
                  [6.8,4.2,0.8]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"oz",
                  "amount":7.7
                  }
                  }
                  },
                  {
                  "BOOK":
                  {
                  "CAT":"P",
                  "TITLE":"Jude the Obscure",
                  "AUTHOR":"Thomas Hardy",
                  "PUBLISHER":"Penguin Classics",
                  "PUB-DATE":"1998-09-01",
                  "LANGUAGE":"English",
                  "PRICE":4.95,
                  "QUANTITY":129,
                  "ISBN":"0140435387",
                  "PAGES":"528",
                  "DIMENSIONS":
                  {
                  "UNIT":"in",
                  "value":
                  [7.8,5.2,0.9]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"oz",
                  "amount":10.9
                  }
                  }
                  },
                  {
                  "BOOK":
                  {
                  "CAT":"H",
                  "TITLE":"The Big Over Easy",
                  "AUTHOR":"Jasper Fforde",
                  "PUBLISHER":"Hodder &amp; Stoughton",
                  "PUB-DATE":"2005-07-11",
                  "LANGUAGE":"English",
                  "PRICE":16.47,
                  "QUANTITY":129,
                  "ISBN":"0340835672",
                  "PAGES":"346",
                  "DIMENSIONS":
                  {
                  "UNIT":"cm",
                  "value":
                  [22.5,18,3.5]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"g",
                  "amount":390
                  }
                  }
                  },
                  {
                  "BOOK":
                  {
                  "CAT":"P",
                  "TITLE":"The Eyre Affair",
                  "AUTHOR":"Jasper Fforde",
                  "PUBLISHER":"Penguin",
                  "PUB-DATE":"2003-02-25",
                  "LANGUAGE":"English",
                  "PRICE":16.47,
                  "QUANTITY":129,
                  "ISBN":"0142001805",
                  "PAGES":"384",
                  "DIMENSIONS":
                  {
                  "UNIT":"in",
                  "value":
                  [7.8,5,0.9]
                  },
                  "WEIGHT":
                  {
                  "UNIT":"oz",
                  "amount":9
                  }
                  }
                  }],
                  "CATEGORIES":
                  {
                  "_attributes":
                  {
                  "DESC":"Miscellaneous categories"
                  },
                  "_children":
                  ["\n    ",
                  {
                  "CATEGORY":
                  {
                  "CODE":"P",
                  "DESC":"Paperback"
                  }
                  },"\n    ",
                  {
                  "CATEGORY":
                  {
                  "CODE":"MMP",
                  "DESC":"Mass-market Paperback"
                  }
                  },"\n    ",
                  {
                  "CATEGORY":
                  {
                  "CODE":"H",
                  "DESC":"Hard Cover"
                  }
                  },"\n"]
                  }
                  }
                  }
                  
               </div>
            </div>
         </div><a name="ExampleXSLTgenerationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e702" xml:id="apendex_xslt">
            <div class="title e703">Example XSLT generation</div>
            <div class="para e704">The markup for ITEM/DIMENSIONS in the above XSD produces these sets of XSLT patterns.
               				Note that this code generation is in progress and is a prime target for change
               and
               				optimization.
            </div>
            <div class="para e705">XSLT to convert XML to JSON</div>
            <div class="programlisting e706" xml:space="preserve">
               
               &lt;xsl:template priority="1" match="ITEM/DIMENSIONS"&gt;
               &lt;member name="DIMENSIONS"&gt;
               &lt;xsl:choose&gt;
               &lt;!-- No attributes or child elements - jump to text  --&gt;
               &lt;xsl:when test="empty(@*|*)"&gt;
               &lt;array&gt;
               &lt;xsl:for-each select="tokenize(.,' ')"&gt;
               &lt;number&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/number&gt;
               &lt;/xsl:for-each&gt;
               &lt;/array&gt;
               &lt;/xsl:when&gt;
               &lt;!-- Otherwise need to make an object out of this --&gt;
               &lt;xsl:otherwise&gt;
               &lt;object&gt;
               					&lt;!-- For each element and attribute make a member --&gt;
               				  &lt;xsl:for-each select="@*|*"&gt;
               &lt;xsl:apply-templates select="."/&gt;
               &lt;/xsl:for-each&gt;
               &lt;!-- Wrap text in a _text node only for simple types --&gt;
               				  &lt;xsl:if test="string(.)"&gt;
               &lt;member name="value"&gt;
               &lt;array&gt;
               &lt;xsl:for-each select="tokenize(.,' ')"&gt;
               &lt;number&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/number&gt;
               &lt;/xsl:for-each&gt;
               &lt;/array&gt;
               &lt;/member&gt;
               &lt;/xsl:if&gt;
               &lt;/object&gt;
               &lt;/xsl:otherwise&gt;
               &lt;/xsl:choose&gt;
               &lt;/member&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="1" match="ITEM/DIMENSIONS" mode="wrap"&gt;
               &lt;object&gt;
               &lt;xsl:apply-templates select="."/&gt;
               &lt;/object&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="1" match="ITEM/DIMENSIONS/text()" mode="#all"&gt;
               &lt;array&gt;
               &lt;xsl:for-each select="tokenize(.,' ')"&gt;
               &lt;number&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/number&gt;
               &lt;/xsl:for-each&gt;
               &lt;/array&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="2" match="ITEM/DIMENSIONS/@UNIT" mode="#all"&gt;
               &lt;member name="UNIT"&gt;
               &lt;string&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/string&gt;
               &lt;/member&gt;
               &lt;/xsl:template&gt;
               
            </div>
            <div class="para e707">XSLT to convert JSON to XML</div>
            <div class="programlisting e708" xml:space="preserve">
               &lt;xsl:template priority="1"
               match="member[@name='BOOK']/object/member[@name='DIMENSIONS']/object"&gt;
               &lt;xsl:apply-templates select="*"/&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="1"
               match="member[@name='BOOK']/object/member[@name='DIMENSIONS']/string |
               member[@name='BOOK']/object/member[@name='DIMENSIONS']/number"&gt;
               &lt;xsl:value-of select="string()"/&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="1" match="member[@name='BOOK']/object/member[@name='DIMENSIONS']"&gt;
               &lt;xsl:element name="DIMENSIONS" namespace=""&gt;
               &lt;xsl:apply-templates select="*"/&gt;
               &lt;/xsl:element&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="1"
               match="member[@name='BOOK']/object/member[@name='DIMENSIONS']/object/member[@name='value']"&gt;
               &lt;xsl:copy-of select="string-join( array/(number|string) , ' ')"/&gt;
               &lt;/xsl:template&gt;
               
               &lt;xsl:template priority="2"
               match="member[@name='BOOK']/object/member[@name='DIMENSIONS']/object/member[@name='UNIT']/string
               |
               member[@name='BOOK']/object/member[@name='DIMENSIONS']/object/member[@name='UNIT']/number"&gt;
               &lt;xsl:value-of select="string()"/&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template priority="2"
               match="member[@name='BOOK']/object/member[@name='DIMENSIONS']/object/member[@name='UNIT']"&gt;
               &lt;xsl:attribute name="UNIT" namespace=""&gt;
               &lt;xsl:apply-templates select="*"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:template&gt;
               
            </div>
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e709">
         <div class="title e710">References</div>
         <div class="bibliomixed e711" xml:id="jsonorg" xreflabel="JSONORG"> The JSON to XML converter from json.org
            				
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e712" xlink:actuate="onRequest" xlink:href="http://www.json.org/javadoc/org/json/XML.html" xlink:show="new" xlink:type="simple">http://www.json.org/javadoc/org/json/XML.html</div>
            		
         </div>
         <div class="bibliomixed e713" xml:id="jsonx"> JSONx is an IBM® standard format to represent JSON as XML 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e714" xlink:actuate="onRequest" xlink:href="http://publib.boulder.ibm.com/infocenter/wsdatap/v3r8m1/index.jsp?topic=/xs40/convertingbetweenjsonandjsonx05.htm" xlink:show="new" xlink:type="simple">http://publib.boulder.ibm.com/infocenter/wsdatap/v3r8m1/index.jsp?topic=/xs40/convertingbetweenjsonandjsonx05.htm</div>
            		
         </div>
         <div class="bibliomixed e715" xml:id="badgerfish">The Badgerfish notation for XML in JSON. The normative site
            				
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e716" xlink:actuate="onRequest" xlink:href="http://badgerfish.ning.com/" xlink:show="new" xlink:type="simple">http://badgerfish.ning.com/</div> has
            			vanished off the web but many references still remain including XSLTJSON
         </div>
         <div class="bibliomixed e717" xml:id="rabbitfish">The Rabbitfish notation for XML in JSON. References are
            			made to rabbitfish notation in XSLTJSON 
         </div>
         <div class="bibliomixed e718" xml:id="xsltjson" xreflabel="XSLTJSON">XSLTJSON, XML to JSON using XSLT 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e719" xlink:actuate="onRequest" xlink:href="http://www.bramstein.com/projects/xsltjson/" xlink:show="new" xlink:type="simple">http://www.bramstein.com/projects/xsltjson/</div>
         </div>
         <div class="bibliomixed e720" xml:id="jsonml" xreflabel="JSONML"> JSON Markup Language (JsonML)
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e721" xlink:actuate="onRequest" xlink:href="http://jsonml.org/" xlink:show="new" xlink:type="simple">http://jsonml.org/</div>
            		
         </div>
         <div class="bibliomixed e722" xml:id="jquery" xreflabel="JQUERY"> jQuery XML to JSON Plugin 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e723" xlink:actuate="onRequest" xlink:href="http://www.fyneworks.com/jquery/xml-to-json/" xlink:show="new" xlink:type="simple">http://www.fyneworks.com/jquery/xml-to-json/</div>
            		
         </div>
         <div class="bibliomixed e724" xml:id="boomerang" xreflabel="BOOMERANG">Boomerang - A bidirectional
            			programming language for ad-hoc, textual data. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e725" xlink:actuate="onRequest" xlink:href="http://www.seas.upenn.edu/~harmony/" xlink:show="new" xlink:type="simple">http://www.seas.upenn.edu/~harmony/</div>
            		
         </div>
         <div class="bibliomixed e726" xml:id="xsugar" xreflabel="XSUGAR"> XSugar - Dual Syntax for XML Languages
            				
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e727" xlink:actuate="onRequest" xlink:href="http://www.brics.dk/xsugar/" xlink:show="new" xlink:type="simple">http://www.brics.dk/xsugar/</div>
            		
         </div>
         <div class="bibliomixed e728" xml:id="jsonschema" xreflabel="JSONSCHEMA"> JSON Schema 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e729" xlink:actuate="onRequest" xlink:href="http://json-schema.org/" xlink:show="new" xlink:type="simple">http://json-schema.org//</div>
            		
         </div>
         <div class="bibliomixed e730" xml:id="dfdl" xreflabel="DFDL">OGF Standards: Data Format Description Language
            			(DFDL) 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e731" xlink:actuate="onRequest" xlink:href="http://www.ogf.org/dfdl/" xlink:show="new" xlink:type="simple">http://www.ogf.org/dfdl/</div>
            		
         </div>
         <div class="bibliomixed e732" xml:id="apacheschema" xreflabel="APACHESCHEMA"> Apace Schema API implementation
            			of the XML Schema API 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e733" xlink:actuate="onRequest" xlink:href="http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040309/" xlink:show="new" xlink:type="simple">http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040309/</div>
         </div>
         <div class="bibliomixed e734" xml:id="trang" xreflabel="TRANG"> Trang - Multi-format schema converter based
            			on RELAX NG 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e735" xlink:actuate="onRequest" xlink:href="http://www.thaiopensource.com/relaxng/trang.html" xlink:show="new" xlink:type="simple">http://www.thaiopensource.com/relaxng/trang.html</div>
         </div>
         <div class="bibliomixed e736" xml:id="mljson" xreflabel="MLJSON">MLJSON provides a facade on top of MarkLogic for treating MarkLogic as a store for
            JSON documents and data. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e737" xlink:actuate="onRequest" xlink:href="http://developer.marklogic.com/code/mljson" xlink:show="new" xlink:type="simple">http://developer.marklogic.com/code/mljson</div>
         </div>
      </div>
   </div>
</div>