<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#%0AExtendingXMLwithSHORTREFsspecifiedinRELAXNGANCHOR" name="%0AExtendingXMLwithSHORTREFsspecifiedinRELAXNGTOC">
               Extending XML with SHORTREFs specified in RELAX NG</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC"> Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RELAXNGschemaasagrammarANCHOR" name="RELAXNGschemaasagrammarTOC"> RELAX NG schema as a grammar</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC"> Implementation</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ResultsandfuturedirectionsANCHOR" name="ResultsandfuturedirectionsTOC"> Results and future directions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RelatedworkANCHOR" name="RelatedworkTOC"> Related work</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConcretesyntaxschemaextensionforBalisagesubmissionsANCHOR" name="ConcretesyntaxschemaextensionforBalisagesubmissionsTOC"> Concrete syntax schema extension for Balisage submissions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConcretesyntaxextensionofXHTMLschemaANCHOR" name="ConcretesyntaxextensionofXHTMLschemaTOC"> Concrete syntax extension of XHTML schema</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC"> Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">abstract</div>
         <div class="singletermTERMS">alternate set</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bold</div>
         <div class="singletermTERMS">Beyond SGML</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
         <div class="singletermTERMS">Blažević</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">CDATA</div>
         <div class="singletermTERMS">code</div>
         <div class="singletermTERMS">compact syntax</div>
         <div class="singletermTERMS">concrete</div>
         <div class="singletermTERMS">Computer Networks</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">data</div>
         <div class="singletermTERMS">dataExcept</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">emphasis</div>
         <div class="singletermTERMS">Extreme Markup Languages</div>
         <div class="singletermTERMS">Exoterica Technical Report</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">follow set</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">interleave</div>
         <div class="singletermTERMS">IFIP Congress</div>
         <div class="singletermTERMS">International Organization for Standardization</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">J. ACM 11</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">listitem</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">mblazevic@stilo.com</div>
         <div class="singletermTERMS">Mario</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">North Holland Publishing Company</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">omissible+</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">para</div>
         <div class="singletermTERMS">programlisting</div>
         <div class="singletermTERMS">plain-text</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">quote</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">strict.rng</div>
         <div class="singletermTERMS">shortrefs</div>
         <div class="singletermTERMS">should</div>
         <div class="singletermTERMS">Software: Practice and Experience</div>
         <div class="singletermTERMS">Senior software architect</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">terminal</div>
         <div class="singletermTERMS">text</div>
         <div class="singletermTERMS">textDeriv</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">terminal</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">usemap</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">vice versa</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="%0AExtendingXMLwithSHORTREFsspecifiedinRELAXNGANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">
         Extending XML with SHORTREFs specified in RELAX NG
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2012</div>
            <div class="confdates e5">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">
               We present a novel method for specifying concrete syntax, based on and compatible
               with the RELAX NG schema standard. A
               parsing method is described for a well-formed XML document conforming to the given
               concrete syntax specification. The
               output of the parser is another XML document conforming to the abstract syntax described
               by the base RELAX NG schema.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Mario</div>
               <div class="surname e11">Blažević</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">
                  The author has a Master's degree in Computer Science from University of Novi Sad,
                  Yugoslavia. Since moving to
                  Canada in 2000, he has been working for OmniMark Technologies, later acquired by Stilo
                  International plc.,
                  mostly in the area of markup processing and on development of the OmniMark programming
                  language.
               </div>
            </div>
            <div class="email e14">mblazevic@stilo.com</div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Senior software architect</div>
               <div class="orgname e17">Stilo International plc.</div>
            </div>
         </div>
         <div class="legalnotice e18">
            <div class="para e19">Copyright © 2012 Stilo International plc. All rights reserved.</div>
         </div>
      </div>
      <div class="note e20">
         <div class="para e21">
            This paper has been inspired in part by Sam Wilmott's 1993 internal report, 
            <div class="quote e22">Beyond SGML</div>[
            <div class="citation e23" linkend="w93"></div>]. I
            also want to thank my colleague Jacques Légaré for his valuable comments and clarifications,
            and Stilo
            International for giving me time to do interesting work.
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e24">
         <div class="title e25"> Introduction</div>
         <div class="para e26">SGML had this feature called SHORTREF. It allowed the DTD designer to specify that
            certain strings called 
            <div class="emphasis e27">shortrefs</div>
            should in some contexts be interpreted as markup tags. For the authors using an SGML
            DTD with a well-designed set of
            shortrefs, the effect was similar to using a kind of Wiki markup.
         </div>
         <div class="para e28">As with other parts of SGML, the specification syntax for shortrefs was idiosyncratic.[
            <div class="citation e29" linkend="s86"></div>] 
            Furthermore, the method of their specification typically relied on some other rarely-used
            features of SGML DTDs, such as
            STARTTAG entities. This combination ensured that only an expert in SGML DTDs could
            hope to design shortrefs correctly,
            so they remained obscure and rarely used. When SGML was replaced by its simplified
            successor XML, nobody regretted their
            omission.
         </div>
         <div class="para e30">Or did they?</div>
         <div class="para e31">Many people stubbornly refuse to abandon their non-XML syntaxes. Programming language
            designers still use the
            old-fashioned EBNF grammars[
            <div class="citation e32" linkend="b59"></div>] in their specifications instead of XML Schema. Even some languages
            that are at the very core of various XML technologies, such as XPath, are not XML.
            The RELAX NG schema language, though
            specified in XML syntax[
            <div class="citation e33" linkend="c01"></div>], defines a non-XML 
            <div class="quote e34">compact syntax</div>[
            <div class="citation e35" linkend="c02c"></div>] as well.
         </div>
         <div class="para e36">The strongest evidence of yearning for shortrefs, however, is the myriad of 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e37" xlink:actuate="onRequest" xlink:href="http://www.wikimatrix.org/" xlink:show="new" xlink:type="simple">Wiki languages</div> in existence. Here we have a large family of actual markup
            languages, whose main purpose is to be converted to HTML, another markup language,
            and still they are not fully tagged
            XML. SGML DTDs with shortrefs and appropriate declarations could accomplish the task.[
            <div class="citation e38" linkend="j04"></div>] Instead,
            Wiki engines typically store their pages as plain text, parse them using hand-coded
            parsers written in various
            general-purpose languages, and convert them directly to HTML for presentation.[
            <div class="citation e39" linkend="b07"></div>]
         </div>
         <div class="para e40">There are many downsides to this architecture. Most Wiki pages are stored unvalidated
            and unstructured, which makes them
            suboptimal for searching and very difficult to automatically restructure. They are
            missing all XML tool chain
            support. All these problems are judged to be outweighed by the benefit of the special
            notation. A solution that
            preserves this notational convenience while keeping markup in XML documents would
            be a clear winner.
         </div>
         <div class="para e41">The present paper aims to deliver one solution that satisfies these criteria: given
            a relatively simple syntax
            specification that follows the established standards, it allows the author to create
            valid XML without entering XML
            tags. In other words, it resurrects SGML shortrefs in a more modern context of well-formed
            XML and RELAX NG schema
            specifications.
         </div>
      </div><a name="RELAXNGschemaasagrammarANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e42">
         <div class="title e43"> RELAX NG schema as a grammar</div>
         <div class="para e44">If our job is to specify how some text is to be parsed, one obvious place to start
            is from grammars, or more
            specifically context-free grammars; they have been successfully used for this purpose
            for more than half a
            century[
            <div class="citation e45" linkend="b59"></div>]. Here is an example of such a grammar for a small fragment of a Wiki markup language,
            specified in a variant of the EBNF notation:
         </div>
         <div class="programlisting e46" xml:space="preserve">paragraph  ::= (plain-text | bold | italic)* "\n\n"?
            bold       ::= "**" (plain-text | italic)* "**"
            italic     ::= "//" (plain-text | bold)* "//"
            plain-text ::= ([^\n*/]+ | "\n" [^\n] | "*" [^*] | "/" [^/])+
         </div>
         <div class="para e47">The 
            <div class="quote e48">plain-text</div> production is rather tricky. This context-free grammar is working directly on plain-text
            input with no
            help from any lexical layer, so 
            <div class="quote e49">plain-text</div> has to exclude the three markers (
            <div class="code e50">**</div>, 
            <div class="code e51">//</div>, and the newline) in order
            to avoid ambiguity. The production would become even more complicated as more markup
            is added to the grammar.
         </div>
         <div class="para e52">Once the input text is parsed according to the grammar, we can represent the resulting
            abstract syntax tree as XML and
            use the following compact RELAX NG schema for its validation:
         </div>
         <div class="programlisting e53" xml:space="preserve">paragraph  = element para { (plain-text | bold | italic)* }
            bold       = element bold { (plain-text | italic)* }
            italic     = element italic { (plain-text | bold)* }
            plain-text = text
         </div>
         <div class="para e54">The similarities between the two notations above are striking. The main difference
            is that the former specifies a
            
            <div class="emphasis e55">concrete</div> syntax, and the latter the 
            <div class="emphasis e56">abstract</div> syntax[
            <div class="citation e57" linkend="m62"></div>]. To become concrete, and thus
            useful for parsing text, the RELAX NG schema needs to specify the string markers,
            or 
            <div class="emphasis e58">terminal</div> symbols. We could try
            the following modification, which brings the schema even closer to the EBNF grammar:
         </div>
         <div class="programlisting e59" xml:space="preserve">paragraph  = element para {
            (plain-text | bold | italic)*,
            "&amp;#x0a;&amp;#x0a;"?
            }
            bold       = element bold { "**", (plain-text | italic)*, "**" }
            italic     = element italic { "//", (plain-text | bold)*, "//" }
            plain-text = text
         </div>
         <div class="para e60">The RELAX NG specification[
            <div class="citation e61" linkend="c01"></div>] unfortunately does not allow text-matching and element-matching
            patterns to be grouped together, and that makes the above schema invalid. To make
            our concrete-syntax schema
            syntactically correct, we need to enclose each string marker into an element of its
            own. These elements will belong to
            the special 
            <div class="code e62">terminal</div> namespace so we can distinguish them from the structural elements:
         </div>
         <div class="programlisting e63" xml:space="preserve">paragraph  = element para {
            (plain-text | bold | italic)*,
            paragraph_separator?
            }
            bold       = element bold {
            bold_marker,
            (plain-text | italic)*,
            bold_marker
            }
            italic     = element italic {
            italic_marker,
            (plain-text | bold)*,
            italic_marker
            }
            plain-text = text
            
            bold_marker         = element terminal:bold_marker { "**" }
            italic_marker       = element terminal:italic_marker { "//" }
            paragraph_separator = element terminal:paragraph_separator {
            "&amp;#x0a;&amp;#x0a;"
            }
         </div>
         <div class="para e64">We could also replace the 
            <div class="code e65">text</div> pattern by 
            <div class="code e66">string{pattern="([^\n*/]+|\n[^\n]|\*[^*]|/[^/])+"} </div> to replicate the
            grammar even closer. As noted above, however, this pattern grows more complex as more
            markers are added to the grammar,
            which makes it difficult to maintain. Another downside is that the schema would lose
            the modularity properties that
            RELAX NG normally provides.
         </div>
         <div class="para e67">The 
            <div class="quote e68">plain-text</div> pattern is meant to match any text up to any marker that is allowed in the context.
            Rather than require
            the user to construct this pattern every time a new marker is introduced, we can change
            the meaning of the 
            <div class="code e69">text</div>
            pattern to match what we need. In the standard RELAX NG semantics, 
            <div class="code e70">text</div> matches all text content up to the next
            element tag; in our modified semantics, it will match all text content until the next
            marker recognizable in the
            context, or until the next element tag.
         </div>
         <div class="para e71">Our parser must construct an abstract syntax tree with element nodes like 
            <div class="code e72">bold</div> that are not present in the input. To
            achieve this, we need to add another semantic extension and infer the missing element
            tags[
            <div class="citation e73" linkend="b10"></div>]. This is especially necessary for features like Wiki lists, where a single indented
            asterisk can denote
            the beginning of both a list and a list item. This is similar to the OMITTAG feature
            of SGML, the main difference being
            that our input must be well-formed XML; the element's start-tag and its end-tag must
            both be present or both omitted.
         </div>
         <div class="para e74">The only elements with omissible tags will be those in the 
            <div class="code e75">terminal</div> namespace and those whose namespace URI begins
            with the prefix 
            <div class="code e76">omissible+</div> (which is perfectly legal according to RFC 2396). In the schema fragment above, the
            default
            namespace should be made omissible; in other words, the schema should be preceded
            by
         </div>
         <div class="programlisting e77" xml:space="preserve">default namespace = "omissible+http://my.namespace.com/"
            namespace terminal = "http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
         </div>
         <div class="para e78">The elements in the 
            <div class="code e79">terminal</div> namespace are perfectly ordinary XML elements; what gives them a special meaning
            is
            that the parser deletes them from the constructed syntax tree together with their
            content. The elements with the
            
            <div class="code e80">omissible+</div> namespace prefix will be kept in the normalized XML output, but their URI prefix
            will be removed. This
            stripping of terminal elements and omissible namespace prefixes is the default mode
            of operation. The parser can also be
            made to emit all the terminal nodes and keep the omissible namespace prefixes. For
            the above example schema and the
            input paragraph
         </div>
         <div class="programlisting e81" xml:space="preserve">Here's a **fat
            and somewhat //slanted
            // text**
            example.
         </div>
         <div class="para e82">the default output of the parser is</div>
         <div class="programlisting e83" xml:space="preserve">&lt;paragraph xmlns="http://my.namespace.com"&gt;Here's a &lt;bold&gt;fat
            and somewhat &lt;italic&gt;slanted
            &lt;/italic&gt; text&lt;/bold&gt;
            example.&lt;/paragraph&gt;
            
         </div>
         <div class="para e84">and the raw output, if requested, would be</div>
         <div class="programlisting e85" xml:space="preserve">&lt;paragraph
            xmlns="omissible+http://my.namespace.com"
            xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
            &gt;Here's a &lt;bold&gt;&lt;terminal:bold_marker&gt;**&lt;/terminal:bold_marker&gt;fat
            and somewhat &lt;italic&gt;&lt;terminal:italic_marker&gt;//&lt;/terminal:italic_marker&gt;slanted
            &lt;terminal:italic_marker&gt;//&lt;/terminal:italic_marker&gt;&lt;/italic&gt; text&lt;terminal:bold_marker&gt;**&lt;/terminal:bold_marker&gt;&lt;/bold&gt;
            example.&lt;terminal:paragraph_separator&gt;
            
            &lt;/terminal:paragraph_separator&gt;&lt;/paragraph&gt;
         </div>
         <div class="para e86">Both these outputs are well-formed XML and contain no text markers. The former is
            valid against the original RELAX NG
            schema, and the latter is valid against the enriched schema. If we want to replicate
            the behaviour of an SGML DTD, where
            one can alternate between shortrefs and regular element tags, all we need do is combine
            the two schemata into one. The
            cleanest way to accomplish the same effect is to have the concrete-syntax schema include
            the original one, combining the
            original definitions with its own. If the original schema was defined in file 
            <div class="code e87">strict.rng</div>, the extended schema could be
            defined in a separate file as follows:
         </div>
         <div class="programlisting e88" xml:space="preserve">default namespace = "omissible+http://my.namespace.com/"
            namespace terminal = "http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
            
            include "strict.rng"
            
            paragraph  |= element para {
            (plain-text | bold | italic)*,
            paragraph_separator?
            }
            bold       |= element bold {
            bold_marker,
            (plain-text | italic)*,
            bold_marker
            }
            italic     |= element italic {
            italic_marker,
            (plain-text | bold)*,
            italic_marker
            }
            plain-text  = text
            
            bold_marker         = element terminal:bold_marker { "**" }
            italic_marker       = element terminal:italic_marker { "//" }
            paragraph_separator = element terminal:paragraph_separator {
            "&amp;#x0a;&amp;#x0a;"
            }
         </div>
         <div class="para e89">Both the default and the raw output (i.e., the abstract and the concrete syntax tree)
            now conform to the same RELAX NG
            schema, and we can use any conforming RELAX NG validator to verify this.
         </div>
      </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e90">
         <div class="title e91"> Implementation</div>
         <div class="para e92">The parser for the schema specifications described in the previous section has been
            implemented in Haskell and can be
            found at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e93" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://hackage.haskell.org/package/concrete-relaxng-parser</div>. It compiles to a standalone executable
            that requires two file names as arguments: the target RELAX NG schema (with or without
            any concrete-syntax extensions),
            and the input XML document.
         </div>
         <div class="para e94">The implementation of the concrete-syntax parser is based on the RELAX NG reference
            implementation[
            <div class="citation e95" linkend="c02"></div>] with its novel algorithm based on Brzozowski derivatives[
            <div class="citation e96" linkend="b64"></div>] [
            <div class="citation e97" linkend="s05"></div>], together with some extensions described in our previous work[
            <div class="citation e98" linkend="b10"></div>]. In particular,
            the inference of the missing element tags is the same as in [
            <div class="citation e99" linkend="b10"></div>], the only change being its
            restriction to the set of elements whose namespace URI begins with the string 
            <div class="code e100">omissible+</div>. The rest of this section
            will concentrate on details that have not been described elsewhere.
         </div>
         <div class="para e101">The biggest change from [
            <div class="citation e102" linkend="b10"></div>] is in the 
            <div class="code e103">textDeriv</div> function. Both in the reference validator and
            in the previous normalizer implementation, this function must match its pattern argument
            against its entire text node
            argument. Now a pattern is allowed to consume only a prefix of the current text node,
            so the Brzozowski derivatives
            cannot be calculated as easily. One possible solution would be to calculate the derivative
            character by character, but
            its performance would be unacceptable. We also considered introducing a lexical layer
            that separates all possible
            syntactic markers from the rest of the text, but in the end we settled for a mixed
            derivative/continuation-passing
            algorithm. The 
            <div class="code e104">textDeriv</div> function takes two continuations, one invoked in case the pattern consumes the entire
            text
            node and the other in case there is some leftover text. This way each pattern is free
            to consume as much text as it can
            match in a single try, and pass the rest to the continuation pattern.
         </div>
         <div class="para e105">This technique unfortunately does not implement the 
            <div class="code e106">interleave</div> patterns properly. If their semantics from the RELAX NG
            specification was carried over to the text nodes literally, it would imply that an
            
            <div class="code e107">interleave</div> pattern should match any
            interleaving of the character sequences matched by its two branches. This semantics
            would be very difficult to implement
            efficiently, but more importantly, it would probably be useless in practice. Instead,
            
            <div class="code e108">textDeriv</div> implements the
            
            <div class="code e109">interleave</div> pattern as an alternation: one of its branches is matched followed by the other.
            This semantics is
            unfortunately not composable. At this time we must recommend against the use of 
            <div class="code e110">interleave</div> in concrete syntax
            definitions. The semantics of 
            <div class="code e111">interleave</div> across multiple XML elements and text nodes is not affected by this problem.
         </div>
         <div class="para e112">Another significant hurdle to overcome in the adaptation of RELAX NG to the task of
            parsing text is its 
            <div class="code e113">text</div>
            pattern. Having been designed for the validation of XML documents, RELAX NG allows
            the 
            <div class="code e114">text</div> pattern to match any
            arbitrary contiguous region of text. The boundaries of this region are determined
            by the surrounding markup tags. Since
            we cannot count on these hard boundaries, we must keep track of all syntactic markers
            that can appear instead of element
            tags. These markers are divided into two sets, the 
            <div class="emphasis e115">alternate set</div> and the 
            <div class="emphasis e116">follow set</div>. The former contains all
            markers that can begin an alternative to the current pattern, while the latter contains
            all markers that can appear
            after the end of the current pattern.
         </div>
         <div class="para e117">The same approach is applied to 
            <div class="code e118">data</div> and 
            <div class="code e119">dataExcept</div> patterns: they are bounded by the next following
            marker. They consume the longest possible prefix, recognized by the data type, of
            the text preceding the marker.
         </div>
         <div class="para e120">Whitespace is for the most part handled the same as all other text. The only two exceptions
            are that the whitespace
            consumption does not affect the alternate set and follow set of syntactic markers,
            and that any amount of whitespace can
            precede an explicit element tag. The latter feature follows the behaviour of the standard
            RELAX NG validator, which
            ignores whitespace between elements.
         </div>
      </div><a name="ResultsandfuturedirectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e121">
         <div class="title e122"> Results and future directions</div>
         <div class="para e123">The presented RELAX NG extension could be applied to many RELAX NG schemata and used
            to shorten their instances. Whether
            it 
            <div class="emphasis e124">should</div> be applied to any particular schema depends mostly on outside factors like the target
            audience and
            document corpus. There are also, however, several technical factors that must be taken
            into consideration.
         </div>
         <div class="itemizedlist e125">
            <div class="listitem e126">
               <div class="para e127"> Syntactic markers can only be used to infer element tags without any specified attributes.
                  This shortcoming is partly
                  a consequence of the inability to specify fixed attribute values in RELAX NG, and
                  could potentially be remedied by
                  future extensions.
               </div>
            </div>
            <div class="listitem e128">
               <div class="para e129"> While a schema extended with syntactic markers and omissible element tags can replicate
                  most common uses of SGML
                  SHORTREF feature, it is a fundamentally different mechanism. A SHORTREF can expand
                  to any general entity, which is
                  free to include multiple elements with specified attributes and arbitrary content.
                  A syntactic marker serves only to
                  guide the parser in which omissible elements should be inferred, and these inferred
                  elements are the only possible
                  addition to the parsed output.
               </div>
            </div>
            <div class="listitem e130">
               <div class="para e131"> SGML derives some benefit from being a large and integrated specification. In particular,
                  we can offer no equivalent
                  to SGML 
                  <div class="code e132">usemap</div> declaration which can activate an arbitrary set of shortrefs in any position in the
                  document, or turn
                  them all off. Since our input is well-formed XML, we could instead introduce special
                  processing instructions that
                  affect the parser's behaviour. The main obstacle currently is that the RELAX NG infrastructure
                  normalizes the XML
                  input, removing all processing instructions prior to validation and parsing. The 
                  <div class="code e133">CDATA</div> marked sections are also
                  normalized away, which presents an even more serious problem because the parser may
                  infer elements within them.
               </div>
            </div>
            <div class="listitem e134">
               <div class="para e135"> The current performance of the parser is sufficient for authoring documents with
                  syntactic markers and occasional
                  one-off conversion to a fully tagged instance, but it would impose a significant overhead
                  in a repeatedly invoked
                  markup-processing pipeline. The worst-case performance of any parser implementation
                  will depend on the details of the
                  schema; since RELAX NG does not impose LL(1) or similar constraints, neither do we.
               </div>
            </div>
            <div class="listitem e136">
               <div class="para e137"> A judicious use of syntactic markers can ease the XML document authoring in a text
                  editor. Their benefits would be
                  diminished if used with an XML editor; they could even degrade the experience in this
                  context.
               </div>
            </div>
            <div class="listitem e138">
               <div class="para e139"> There is currently no support for automatic inference of the desired element nesting
                  level, like Wiki for example does
                  with the indentation of the list item bullets. To allow an element to be nested within
                  itself, the schema must specify
                  a different syntactic marker for each element nesting level. Alternatively, one can
                  always nest explicit element tags.
               </div>
            </div>
            <div class="listitem e140">
               <div class="para e141"> On the positive side, the concrete-syntax schema can be as modular as a regular,
                  abstract-syntax RELAX NG schema. It
                  is possible to experiment with multiple different concrete syntaxes for the same abstract
                  syntax, for example, or
                  
                  <div class="emphasis e142">vice versa</div>.
               </div>
            </div>
            <div class="listitem e143">
               <div class="para e144"> The parser translates an XML document from concrete to abstract syntax. There is
                  currently no tool support for
                  performing a reverse translation. This would be a problem for any deployment scenario
                  which allows a document to be
                  edited in both the explicitly-tagged and its concrete syntax variant.
               </div>
            </div>
         </div>
         <div class="para e145">As a proof of concept, the present paper has been written in concrete syntax and translated
            to the abstract syntax
            conforming with the target schema. The concrete-syntax schema extension is given in
            
            <div class="xref e146" linkend="schema"></div>.
         </div>
         <div class="para e147">The sample schema extension modifies seven elements: 
            <div class="code e148">code</div>, 
            <div class="code e149">emphasis</div>, 
            <div class="code e150">listitem</div>, 
            <div class="code e151">para</div>, 
            <div class="code e152">programlisting</div>, 
            <div class="code e153">quote</div>,
            and 
            <div class="code e154">title</div>. Their tags are made omissible in all contexts where they can occur, with the exception
            of 
            <div class="code e155">emphasis</div> which
            must be explicitly tagged inside 
            <div class="code e156">programlisting</div> and inside an inferred 
            <div class="code e157">emphasis</div>. Each of the seven elements is also
            given a concrete syntax with different terminal symbols. Authored with the full use
            of these extensions, the present
            paper contains a total of 141 element tags — mostly of elements with required attributes.
            Once parsed into an
            explicitly tagged XML instance, it gains additional 284 element tags.
         </div>
         <div class="para e158">Another example in 
            <div class="xref e159" linkend="xhtml"></div> presents a small extension of the modularized RELAX NG schema for XHTML 1.0[
            <div class="citation e160" linkend="c08"></div>]. We hope to prepare more concrete syntax extensions like these for other XML schemata
            in the
            future.
         </div>
      </div><a name="RelatedworkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e161">
         <div class="title e162"> Related work</div>
         <div class="para e163">The tool presented herein treats the RELAX NG schema as an abstract syntax description,
            and sprinkles it with some
            extensions for describing the concrete syntax of the language. There have been other
            tools[
            <div class="citation e164" linkend="p09"></div>] [
            <div class="citation e165" linkend="q11"></div>] using the same approach of starting with the abstract syntax and extending it
            with concrete syntax annotations. The abstract syntax notation in these related works
            is tool-specific, since they don't
            use XML as the abstract syntax tree.
         </div>
         <div class="para e166">On the other hand, there are numerous reports[
            <div class="citation e167" linkend="b00"></div>] [
            <div class="citation e168" linkend="c03"></div>] [
            <div class="citation e169" linkend="m04"></div>] [
            <div class="citation e170" linkend="r05"></div>] that focus on using XML as the target abstract syntax tree (AST) notation of a
            parser for some concrete syntax. To perform their parsing, however, they use parser-generators
            such as ANTLR[
            <div class="citation e171" linkend="p95"></div>] and other traditional parsing tools, so they specify their concrete syntax in the
            formalism those tools
            require. Those that use an XML schema at all, use it only to validate the generated
            AST.
         </div>
      </div><a name="ConcretesyntaxschemaextensionforBalisagesubmissionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e172" xml:id="schema">
         <div class="title e173"> Concrete syntax schema extension for Balisage submissions</div>
         <div class="programlisting e174" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
            &lt;grammar ns="omissible+http://docbook.org/ns/docbook"
            xmlns:explicit="http://docbook.org/ns/docbook"
            xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
            xmlns:non-syntactic="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Nonterminal_symbols"
            xmlns="http://relaxng.org/ns/structure/1.0"
            datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
            
            &lt;!-- The balisage-1-3a.rng schema included below is semantically equivalent to the
            original Balisage 
            schema, but slightly refactored with the following definitions added for reuse:
            
            - code.content
            - emphasis.content
            - para.content
            - programlisting.content
            - quote.content
            - title.content
            --&gt;
            &lt;include href="balisage-1-3a.rng"&gt;
            &lt;define name="programlisting.content"&gt;
            &lt;ref name="programlisting.content.explicit"/&gt;
            &lt;/define&gt;
            &lt;/include&gt;
            
            &lt;define name="title" combine="choice"&gt;
            &lt;element name="title"&gt;
            &lt;ref name="title.attlist"/&gt;
            &lt;ref name="title.content"/&gt;
            &lt;ref name="paragraph_separator"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="para" combine="choice"&gt;
            &lt;element name="para"&gt;
            &lt;ref name="para.attlist"/&gt;
            &lt;ref name="para.content.non-recursive"/&gt;
            &lt;ref name="paragraph_separator"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="programlisting" combine="choice"&gt;
            &lt;element name="programlisting"&gt;
            &lt;ref name="programlisting.attlist"/&gt;
            &lt;ref name="programlisting_open_marker"/&gt;
            &lt;ref name="programlisting.content.explicit"/&gt;
            &lt;ref name="programlisting_close_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="listitem" combine="choice"&gt;
            &lt;element name="listitem"&gt;
            &lt;ref name="listitem.attlist"/&gt;
            &lt;ref name="listitem_marker"/&gt;
            &lt;oneOrMore&gt;
            &lt;ref name="para.level"/&gt;
            &lt;/oneOrMore&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="code" combine="choice"&gt;
            &lt;element name="code"&gt;
            &lt;ref name="code.attlist"/&gt;
            &lt;ref name="code_marker"/&gt;
            &lt;ref name="code.content"/&gt;
            &lt;ref name="code_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="emphasis" combine="choice"&gt;
            &lt;element name="emphasis"&gt;
            &lt;ref name="emphasis.attlist"/&gt;
            &lt;ref name="emphasis_marker"/&gt;
            &lt;ref name="emphasis.content.non-recursive"/&gt;
            &lt;ref name="emphasis_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="quote" combine="choice"&gt;
            &lt;element name="quote"&gt;
            &lt;ref name="quote.attlist"/&gt;
            &lt;ref name="quote_marker"/&gt;
            &lt;ref name="quote.content"/&gt;
            &lt;ref name="quote_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;!-- inlined emphasis.content, but with only explicit nested emphasis --&gt;
            &lt;define name="emphasis.content.non-recursive"&gt;
            &lt;zeroOrMore&gt;
            &lt;choice&gt;
            &lt;text/&gt;
            &lt;ref name="link"/&gt;
            &lt;ref name="citation"/&gt;
            &lt;ref name="emphasis.explicit"/&gt;
            &lt;ref name="footnote"/&gt;
            &lt;ref name="trademark"/&gt;
            &lt;ref name="email"/&gt;
            &lt;ref name="code"/&gt;
            &lt;ref name="superscript"/&gt;
            &lt;ref name="subscript"/&gt;
            &lt;ref name="quote"/&gt;
            &lt;ref name="xref"/&gt;
            &lt;/choice&gt;
            &lt;/zeroOrMore&gt;
            &lt;/define&gt;
            
            &lt;!-- emphasis element with explicit tags --&gt;
            &lt;define name="emphasis.explicit"&gt;
            &lt;element name="explicit:emphasis"&gt;
            &lt;ref name="emphasis.attlist"/&gt;
            &lt;ref name="emphasis.content"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;!-- para.content minus the block-level elements which can recursively nest a paragraph
            --&gt;
            &lt;define name="para.content.non-recursive"&gt;
            &lt;zeroOrMore&gt;
            &lt;choice&gt;
            &lt;text/&gt;
            &lt;ref name="citation"/&gt;
            &lt;ref name="code"/&gt;
            &lt;ref name="email"/&gt;
            &lt;ref name="emphasis"/&gt;
            &lt;ref name="equation"/&gt;
            &lt;ref name="inlinemediaobject"/&gt;
            &lt;ref name="link"/&gt;
            &lt;ref name="subscript"/&gt;
            &lt;ref name="superscript"/&gt;
            &lt;ref name="trademark"/&gt;
            &lt;ref name="quote"/&gt;
            &lt;ref name="xref"/&gt;
            &lt;/choice&gt;
            &lt;/zeroOrMore&gt;
            &lt;/define&gt;
            
            &lt;!-- programlisting.content with only the explicit emphasis --&gt;
            &lt;define name="programlisting.content.explicit"&gt;
            &lt;zeroOrMore&gt;
            &lt;choice&gt;
            &lt;text/&gt;
            &lt;ref name="emphasis.explicit"/&gt;
            &lt;ref name="superscript"/&gt;
            &lt;ref name="subscript"/&gt;
            &lt;/choice&gt;
            &lt;/zeroOrMore&gt;
            &lt;/define&gt;
            
            &lt;define name="emphasis_marker"&gt;
            &lt;element name="terminal:emphasis_marker"&gt;
            &lt;value type="string"&gt;''&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="paragraph_separator"&gt;
            &lt;element name="terminal:paragraph_separator"&gt;
            &lt;value type="string"&gt;&amp;#x0a;&amp;#x0a;&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="programlisting_open_marker"&gt;
            &lt;element name="terminal:programlisting_open_marker"&gt;
            &lt;value type="string"&gt;{{{&amp;#x0a;&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="programlisting_close_marker"&gt;
            &lt;element name="terminal:programlisting_close_marker"&gt;
            &lt;value type="string"&gt;&amp;#x0a;}}}&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="listitem_marker"&gt;
            &lt;element name="terminal:listitem_marker"&gt;
            &lt;value type="token"&gt;*&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="code_marker"&gt;
            &lt;element name="terminal:code_marker"&gt;
            &lt;value type="string"&gt;`&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="quote_marker"&gt;
            &lt;element name="terminal:quote_marker"&gt;
            &lt;value type="string"&gt;"&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            &lt;/grammar&gt;
         </div>
      </div><a name="ConcretesyntaxextensionofXHTMLschemaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e175" xml:id="xhtml">
         <div class="title e176"> Concrete syntax extension of XHTML schema</div>
         <div class="programlisting e177" xml:space="preserve">&lt;grammar ns="omissible+http://www.w3.org/1999/xhtml"
            xmlns:explicit="http://www.w3.org/1999/xhtml"
            xmlns:terminal="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"
            xmlns="http://relaxng.org/ns/structure/1.0"&gt;
            
            &lt;include href="xhtml/xhtml-strict.rng"/&gt;
            
            &lt;define name="head" combine="choice"&gt;
            &lt;element name="head"&gt;
            &lt;ref name="head.content"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="title" combine="choice"&gt;
            &lt;element name="title"&gt;
            &lt;text/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="body" combine="choice"&gt;
            &lt;element name="body"&gt;
            &lt;ref name="Block.model"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="p" combine="choice"&gt;
            &lt;element name="p"&gt;
            &lt;ref name="paragraph_separator"/&gt;
            &lt;ref name="Inline.model"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ol" combine="choice"&gt;
            &lt;element name="ol"&gt;
            &lt;oneOrMore&gt;
            &lt;ref name="ol.li"/&gt;
            &lt;/oneOrMore&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ul" combine="choice"&gt;
            &lt;element name="ul"&gt;
            &lt;oneOrMore&gt;
            &lt;ref name="ul.li"/&gt;
            &lt;/oneOrMore&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="hr" combine="choice"&gt;
            &lt;element name="hr"&gt;
            &lt;ref name="hr_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="em" combine="choice"&gt;
            &lt;element name="em"&gt;
            &lt;ref name="emphasis_marker"/&gt;
            &lt;ref name="em.content.non-recursive"/&gt;
            &lt;ref name="emphasis_marker"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ol.li"&gt;
            &lt;element name="li"&gt;
            &lt;ref name="ol_item_marker"/&gt;
            &lt;ref name="li.content.non-recursive"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ul.li"&gt;
            &lt;element name="li"&gt;
            &lt;ref name="ul_item_marker"/&gt;
            &lt;ref name="li.content.non-recursive"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="em.content.non-recursive"&gt;
            &lt;zeroOrMore&gt;
            &lt;choice&gt;
            &lt;text/&gt;
            &lt;ref name="abbr"/&gt;
            &lt;ref name="acronym"/&gt;
            &lt;ref name="br"/&gt;
            &lt;ref name="cite"/&gt;
            &lt;ref name="code"/&gt;
            &lt;ref name="dfn"/&gt;
            &lt;ref name="kbd"/&gt;
            &lt;ref name="q"/&gt;
            &lt;ref name="samp"/&gt;
            &lt;ref name="span"/&gt;
            &lt;ref name="strong"/&gt;
            &lt;ref name="var"/&gt;
            &lt;ref name="em.explicit"/&gt;
            &lt;/choice&gt;
            &lt;/zeroOrMore&gt;
            &lt;/define&gt;
            
            &lt;define name="li.content.non-recursive"&gt;
            &lt;zeroOrMore&gt;
            &lt;choice&gt;
            &lt;text/&gt;
            &lt;ref name="Inline.class"/&gt;
            &lt;ref name="address"/&gt;
            &lt;ref name="blockquote"/&gt;
            &lt;ref name="div"/&gt;
            &lt;ref name="pre"/&gt;
            &lt;ref name="Heading.class"/&gt;
            &lt;ref name="dl"/&gt;
            &lt;ref name="p.explicit"/&gt;
            &lt;ref name="ol.explicit"/&gt;
            &lt;ref name="ul.explicit"/&gt;
            &lt;/choice&gt;
            &lt;/zeroOrMore&gt;
            &lt;/define&gt;
            
            &lt;define name="em.explicit"&gt;
            &lt;element name="explicit:em"&gt;
            &lt;ref name="em.attlist"/&gt;
            &lt;ref name="Inline.model"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="p.explicit"&gt;
            &lt;element name="explicit:p"&gt;
            &lt;ref name="p.attlist"/&gt;
            &lt;ref name="Inline.model"/&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ol.explicit"&gt;
            &lt;element name="explicit:ol"&gt;
            &lt;ref name="ol.attlist"/&gt;
            &lt;oneOrMore&gt;
            &lt;ref name="li"/&gt;
            &lt;/oneOrMore&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ul.explicit"&gt;
            &lt;element name="explicit:ul"&gt;
            &lt;ref name="ul.attlist"/&gt;
            &lt;oneOrMore&gt;
            &lt;ref name="li"/&gt;
            &lt;/oneOrMore&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="emphasis_marker"&gt;
            &lt;element name="terminal:emphasis_marker"&gt;
            &lt;value type="string"&gt;*&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="paragraph_separator"&gt;
            &lt;element name="terminal:paragraph_separator"&gt;
            &lt;value type="string"&gt;&amp;#x0a;&amp;#x0a;&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="line_separator"&gt;
            &lt;element name="terminal:line_separator"&gt;
            &lt;value type="string"&gt;&amp;#x0a;&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ol_item_marker"&gt;
            &lt;element name="terminal:ol_item_marker"&gt;
            &lt;value type="token"&gt;&amp;#x0a;# &lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="ul_item_marker"&gt;
            &lt;element name="terminal:ul_item_marker"&gt;
            &lt;value type="token"&gt;&amp;#x0a;* &lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            
            &lt;define name="hr_marker"&gt;
            &lt;element name="terminal:hr_marker"&gt;
            &lt;value type="token"&gt;&amp;#x0a;----&lt;/value&gt;
            &lt;/element&gt;
            &lt;/define&gt;
            &lt;/grammar&gt;
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e178">
         <div class="title e179"> Bibliography</div>
         <div class="bibliomixed e180" xml:id="b59">
            Backus, J.W.,
            The Syntax and Semantics of the Proposed International Algebraic Language of Zürich
            ACM-GAMM Conference,
            
            <div class="emphasis e181">Proceedings of the International Conference on Information Processing, UNESCO</div>,
            1959, pp.125-132.
            
         </div>
         <div class="bibliomixed e182" xml:id="b64">
            Brzozowski, J. A. 1964. Derivatives of Regular Expressions. 
            <div class="emphasis e183">J. ACM 11</div>,
            4 (Oct. 1964), 481-494.
            doi:
            <div class="biblioid doi e184">10.1145/321239.321249</div>.
            
         </div>
         <div class="bibliomixed e185" xml:id="b00">
            Greg J. Badros. 2000.
            JavaML: a markup language for Java source code.
            
            <div class="emphasis e186">Computer Networks</div> 33, 1-6 (June 2000), 159-177.
            doi:
            <div class="biblioid doi e187">10.1016/S1389-1286(00)00037-2</div>.
            
         </div>
         <div class="bibliomixed e188" xml:id="b07">
            Mark Bergsma, 2007. Wikimedia architecture
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e189" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.nedworks.org/~mark/presentations/kennisnet/Wikimedia%20architecture%20(kennisnet).pdf</div>
            
         </div>
         <div class="bibliomixed e190" xml:id="b10">
            Mario Blažević, 2010. Grammar-driven Markup Generation.
            In 
            <div class="emphasis e191">Proceedings of Balisage: The Markup Conference 2010</div>.
            Balisage Series on Markup Technologies, vol. 5 (2010).
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e192" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol5/html/Blazevic01/BalisageVol5-Blazevic01.html</div>.
            doi:
            <div class="biblioid doi e193">10.4242/BalisageVol5.Blazevic01</div>.
            
         </div>
         <div class="bibliomixed e194" xml:id="c01">
            James Clark and Makoto Murata. RELAX NG Specification.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e195" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://relaxng.org/spec-20011203.html</div>, 2001. ISO/IEC 19757-2:2003.
            
         </div>
         <div class="bibliomixed e196" xml:id="c02">
            James Clark. An algorithm for RELAX NG validation
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e197" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.thaiopensource.com/relaxng/derivative.html</div>
            
         </div>
         <div class="bibliomixed e198" xml:id="c02c">
            James Clark. RELAX NG compact syntax, Committee Specification 21 November 2002, OASIS
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e199" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://relaxng.org/compact-20021121.html</div>
            
         </div>
         <div class="bibliomixed e200" xml:id="c08">
            James Clark. Modularization of XHTML in RELAX NG
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e201" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.thaiopensource.com/relaxng/xhtml/</div>
            
         </div>
         <div class="bibliomixed e202" xml:id="c03">
            James R. Cordy, 2003.
            Generalized Selective XML Markup of Source Code Using Agile Parsing.
            In 
            <div class="emphasis e203">Proceedings of the 11th IEEE International Workshop on Program Comprehension</div> (IWPC '03).
            IEEE Computer Society, Washington, DC, USA, 144-
            
         </div>
         <div class="bibliomixed e204" xml:id="j04">
            Rick Jeliffe. From Wiki to XML, through SGML.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e205" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xml.com/pub/a/2004/03/03/sgmlwiki.html</div>
            
         </div>
         <div class="bibliomixed e206" xml:id="m62">
            John McCarthy,
            Towards a Mathematical Science of Computation,
            Proceedings of 
            <div class="emphasis e207">IFIP Congress</div> 1962,
            pages 21-28,
            
            <div class="emphasis e208">North Holland Publishing Company</div>, Amsterdam
            
         </div>
         <div class="bibliomixed e209" xml:id="m04">
            J.I. Maletic, M. Collard, and H. Kagdi,
            Leveraging XML technologies in developing program analysis tools.
            IEEE Digest 2004, 80 (2004), doi:
            <div class="biblioid doi e210">10.1049/ic:20040255</div>.
            
         </div>
         <div class="bibliomixed e211" xml:id="p95">
            Parr, T. J. and Quong, R. W.  ANTLR: A predicated-LL(k) parser generator.
            
            <div class="emphasis e212">Software: Practice and Experience</div>,
            volume 25, issue 7, 1995. John Wiley &amp; Sons, Ltd.
            doi:
            <div class="biblioid doi e213">10.1002/spe.4380250705</div>
            
         </div>
         <div class="bibliomixed e214" xml:id="p09">
            Jaroslav Porubän, Michal Forgáč, and Miroslav Sabo, Annotation Based Parser Generator.
            
            <div class="emphasis e215">Proceedings of the International Multiconference on Computer Science and Information
               Technology
            </div>, 2009, pp. 707–714
            
         </div>
         <div class="bibliomixed e216" xml:id="q11">
            Luis Quesada, Fernando Berzal, and Juan-Carlos Cubero,
            A Tool for Model-Based Language Specification.
            Department of Computer Science and Artificial Intelligence, CITIC, University of Granada,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e217" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://arxiv.org/abs/1111.3970v1</div>
            
         </div>
         <div class="bibliomixed e218" xml:id="r05">
            Raihan Al-Ekram and Kostas Kontogiannis. 2005.
            An XML-Based Framework for Language Neutral Program Representation Generic Analysis.
            In 
            <div class="emphasis e219">Proceedings of the Ninth European Conference on Software Maintenance and Reengineering
               (CSMR '05)
            </div>.
            IEEE Computer Society, Washington, DC, USA, 42-51.
            doi:
            <div class="biblioid doi e220">10.1109/CSMR.2005.10</div>
            
         </div>
         <div class="bibliomixed e221" xml:id="s05">
            Sperberg-McQueen, C. M. Applications of Brzozowski derivatives to XML schema processing.
            In 
            <div class="emphasis e222">Extreme Markup Languages</div> 2005, page 26, Internet, 2005. IDEAlliance.
            
         </div>
         <div class="bibliomixed e223" xml:id="s86">
            Standard Generalized Markup Language (SGML)
            
            <div class="emphasis e224">International Organization for Standardization</div> ISO 8879:1986
            
         </div>
         <div class="bibliomixed e225" xml:id="w93">
            Sam Wilmott, Beyond SGML.
            
            <div class="emphasis e226">Exoterica Technical Report</div> ETR-9, 1993.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e227" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://developers.omnimark.com/etcetera/etr09/</div>
            
         </div>
      </div>
   </div>
</div>