<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#DecisionmakinginXSLFOformattingANCHOR" name="DecisionmakinginXSLFOformattingTOC">Decision making in XSL-FO formatting</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XSL11ProcessingModelANCHOR" name="XSL11ProcessingModelTOC">XSL 1.1 Processing Model</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#EffectondecisionmakingANCHOR" name="EffectondecisionmakingTOC">Effect on decision making</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CaseStudyPLOSONEJournalANCHOR" name="CaseStudyPLOSONEJournalTOC">Case Study - PLOS ONE Journal</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XSL11capabilitiesANCHOR" name="XSL11capabilitiesTOC">XSL 1.1 capabilities</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#GraphicshandlingANCHOR" name="GraphicshandlingTOC">Graphics handling</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TablehandlingANCHOR" name="TablehandlingTOC">Table handling</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExtensibleStylesheetLanguage(XSL)RequirementsVersion20ANCHOR" name="ExtensibleStylesheetLanguage(XSL)RequirementsVersion20TOC">Extensible Stylesheet Language (XSL) Requirements Version 2.0</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PrintandPageLayoutCommunityGroupANCHOR" name="PrintandPageLayoutCommunityGroupTOC">Print and Page Layout Community Group</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#EmphasisonfeedbackANCHOR" name="EmphasisonfeedbackTOC">Emphasis on feedback</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AdaptSaxonCEeventmodeltoXSLFO?ANCHOR" name="AdaptSaxonCEeventmodeltoXSLFO?TOC">Adapt Saxon-CE event model to XSL-FO?</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Consultant</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">Graham</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">tgraham@mentea.net</div>
         <div class="singletermTERMS">Tony</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XSL-FO</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="DecisionmakinginXSLFOformattingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973">
      <div class="title e1">Decision making in XSL-FO formatting</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2013</div>
            <div class="confdates e5">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">XSL-FO has a very linear processing model that has served it well, but very often
               it is necessary to make decisions on what will be in the formatted output based on
               the sizes of the formatted output, and XSL 1.1 as defined does not let you do that.
               This paper looks at what's needed to be done to get that sort of decision making into
               XSL-FO processing today and at some possible future developments.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Tony</div>
               <div class="surname e11">Graham</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Tony Graham is the chair of the Print and Page Layout Community Group at the W3C.</div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Consultant</div>
               <div class="orgname e16">Mentea</div>
            </div>
            <div class="email e17">tgraham@mentea.net</div>
         </div>
         <div class="legalnotice e18">
            <div class="para e19">Copyright © 2013 Mentea</div>
         </div>
         <div class="keywordset e20" role="author">
            <div class="keyword e21">XSL-FO</div>
         </div>
      </div><a name="XSL11ProcessingModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e22">
         <div class="title e23">XSL 1.1 Processing Model</div>
         <div class="para e24">Extensible Stylesheet Language (XSL) 1.1 [XSL11] is defined to cover
            both transformation and formatting.  The transformation part was
            broken out as XSLT long before XSL 1.1 became a Recommendation, so the XSLT spec,
            bar a few paragaphs about XSLT, is concerned with formatting the result of a XSLT
            transformation, where:
         </div>
         <div class="popupBox e25">
            <div class="popupLabel" onmouseover="$('#d1e40').show('1000');" onmouseout="$('#d1e40').hide('1000');">[ blockquote ]</div>
            <div id="d1e40" style="display: none;">
               <div class="blockquote">
                  <div class="para e26">Formatting is enabled by including formatting semantics in the result tree. Formatting
                     semantics are expressed in terms of a catalog of classes of formatting objects. The
                     nodes of the result tree are formatting objects. The classes of formatting objects
                     denote typographic abstractions such as page, paragraph, table, and so forth. Finer
                     control over the presentation of these abstractions is provided by a set of formatting
                     properties, such as those controlling indents, word- and letter spacing, and widow,
                     orphan, and hyphenation control. In XSL, the classes of formatting objects and formatting
                     properties provide the vocabulary for expressing presentation intent.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e27">Figure 1 is the detailed conceptual model diagram from XSL 1.1.  It shows a linear
            process from XML source to the result of the XSLT stage to the formatted output.
         </div>
         <div class="figure e28" xml:id="model1">
            <div class="title e29">XSL 1.1 processing model</div>
            <div class="mediaobject e30">
               <div class="imageobject e31">
                  <div class="metaBox e32"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e50').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e50" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e32'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e33">The process of turning XML in the FO vocabulary into formatted, and more than likely
            paginated, output is itself defined in multiple stages.  Figure 2, also from XSL 1.1,
            shows how the XML representation of the formatting objects is turned into actual objects
            (as 'actual' as bits and bytes in computer memory can be), expressions in property
            values are resolved, and the formatter then makes areas.  The formatted areas could
            be written out to a graphical or document format (such as PDF, PostScript, or RTF)
            or, in some cases, could be written out as an XML representation of the area tree
            for later processing.
         </div>
         <div class="figure e34" xml:id="model2">
            <div class="title e35">Summary of the process</div>
            <div class="mediaobject e36">
               <div class="imageobject e37">
                  <div class="metaBox e38"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e58').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e58" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e38'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e39">The XSL spec itself notes that its design follows that of DSSSL [DSSSL]:</div>
         <div class="popupBox e40">
            <div class="popupLabel" onmouseover="$('#d1e61').show('1000');" onmouseout="$('#d1e61').hide('1000');">[ blockquote ]</div>
            <div id="d1e61" style="display: none;">
               <div class="blockquote">
                  <div class="para e41">XSL builds on the prior work on Cascading Style Sheets [CSS2] and the Document Style
                     Semantics and Specification Language [DSSSL].
                  </div>
               </div>
            </div>
         </div>
         <div class="para e42">and the linear processing model with transformation and formatting stages follows
            that of DSSSL:
         </div>
         <div class="figure e43" xml:id="dsssl1">
            <div class="title e44">DSSSL processing model</div>
            <div class="mediaobject e45">
               <div class="imageobject e46">
                  <div class="metaBox e47"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e71').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e71" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e47'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="figure e48" xml:id="dsssl2">
            <div class="title e49">DSSSL formatting</div>
            <div class="mediaobject e50">
               <div class="imageobject e51">
                  <div class="metaBox e52"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e78').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e78" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e52'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-004.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e53">DSSSL goes one step further - or XSL took one step back from DSSSL - since DSSSL states:</div>
         <div class="popupBox e54">
            <div class="popupLabel" onmouseover="$('#d1e81').show('1000');" onmouseout="$('#d1e81').hide('1000');">[ blockquote ]</div>
            <div id="d1e81" style="display: none;">
               <div class="blockquote">
                  <div class="para e55">DSSSL is independent of the type of formatter,
                     formatting system, or other transformation processor.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e56">and James Clark's Jade DSSSL procssor [JADE] came with RTF, TeX, and MIF backends
            for formatted output.
         </div>
         <div class="para e57">This separation of concerns between a style engine and a backend is not explicit in
            either the original XSL Requirements Summary [XSLReq] or the XSL spec, but the linear
            processing model did allow XSL processing to be implemented on top of existing formatters,
            and of the six formatters for which test results [XSLCRTest] were provided so the
            XSL 1.0 specification could progress from Candidate Recommendation to Proposed Recommendation,
            two - Arbortext and PassiveTeX - used existing formatters to make the pages.
         </div><a name="EffectondecisionmakingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e58">
            <div class="title e59">Effect on decision making</div>
            <div class="para e60">To take a simplistic view of decision making - that it's just that: making decisions
               - then there's obviously a lot of decision making going on in the XSL processing model:
            </div>
            <div class="itemizedlist e61">
               <div class="listitem e62">
                  <div class="para e63">The stylesheet writer decides how to style the class of the source documents</div>
               </div>
               <div class="listitem e64">
                  <div class="para e65">The XSLT processor, by selecting template rules based on the structure of the source
                     document (and possibly on other factors) and by evaluating conditional expressions,
                     decides what goes in the result tree
                  </div>
               </div>
               <div class="listitem e66">
                  <div class="para e67">The XSL formatter decides where pages, lines, etc., should break, decides what should
                     change when one area intrudes on another, and decides (based on values of properties
                     such as 'overflow', etc.) what to do when an area or a graphic is too large for the
                     available space
                  </div>
               </div>
            </div>
            <div class="para e68">yet these are all decisions taken in isolation at different points in the processing.</div>
         </div>
      </div><a name="CaseStudyPLOSONEJournalANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e69">
         <div class="title e70">Case Study - PLOS ONE Journal</div>
         <div class="para e71">
            PLOS ONE [PONE] is an international, peer-reviewed, open-access, online publication
            published by PLOS (Public Library of Science) [PLOS], a nonprofit publisher and advocacy
            organization headquartered in San Francisco, California, USA.
         </div>
         <div class="para e72">The author was selected to implement a XSL-FO-based system for producing PDFs of PLOS
            ONE articles.  The PDFs had to replicate PLOS ONE's existing house style.
         </div>
         <div class="para e73">PLOS ONE receives manuscripts in Word, LaTeX, or RTF formats, then converts these
            to XML conforming to the NLM Journal Publishing DTD v3.0 prior to publication.
         </div>
         <div class="para e74">PLOS ONE articles are formatted in two-column pages.  Figures may be either column-wide
            or page-wide, and tables may be column-wide, page-wide, or rotated so their width
            is page-high, but there is no size information for either figures or tables in the
            source XML.  Figures and graphics may also float to either the top or bottom of the
            page or column.
         </div><a name="XSL11capabilitiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e75">
            <div class="title e76">XSL 1.1 capabilities</div>
            <div class="para e77">XSL 1.1 defines a 'before-float-reference-area' on a page, but does not define an
               area for content floated to the 'after' end of the page, and the 'before-float-reference-area',
               when instantiated, takes the full width of the fo:region-body of the page.
            </div>
            <div class="para e78">PLOS therefore had to choose a XSL formatter based on the availability of vendor extensions
               to support more ways to float than defined by XSL 1.1.
            </div>
         </div><a name="GraphicshandlingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e79">
            <div class="title e80">Graphics handling</div>
            <div class="para e81">Graphics at least have an intrinsic size and, in formats such as TIFF, have an intrinsic
               resolution as well.
            </div>
            <div class="para e82">The process for determining whether graphics are column-wide or page-wide is:</div>
            <div class="itemizedlist e83">
               <div class="listitem e84">
                  <div class="para e85">Download copies of TIFF images from PLOS ONE article web page</div>
                  <div class="para e86">In production, PLOS will have the graphics available on their servers, so this is
                     only ncessary while developing the stylesheet.
                  </div>
               </div>
               <div class="listitem e87">
                  <div class="para e88">Run ImageMagick 'identify' on each graphic to get its width, height, horizontal resolution,
                     and vertical resolution and write the information to a '.identify' file for each graphic
                  </div>
               </div>
               <div class="listitem e89">
                  <div class="para e90">In the XSLT stylesheet, when processing a graphic, get the contents of the corresponding
                     '.identify' file using 'unparsed-text()', tokenize the returned string to get the
                     four values, then calculate the graphic's width by dividing the width in pixels by
                     the horizontal resolution.  When the calculateed width is less than or equal to the
                     width of a column, it is made column-wide, otherwise it is made page-wide.
                  </div>
               </div>
            </div>
            <div class="para e91">The PLOS ONE authoring guidelines allow graphics sized up to the height of the page
               body, but figures may have captions of up to 300 characters, as well as having a label,
               title, and DOI that also appear in the formatted output.  XSL doesn't allow floated
               FOs to break across a page, so imilarly to as described below for tables, the processing
               system 'preformats' the figure captions at both widths and writes out the area tree
               to be used as input by the main stylesheeet so the stylesheet reduces the allowed
               maximum height of the graphic so the graphic won't push its following caption into
               the footer area.
            </div>
         </div><a name="TablehandlingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e92">
            <div class="title e93">Table handling</div>
            <div class="para e94">Tables, as noted above, are presented one of three ways -- column-wide, page-wide,
               or page-high -- depending on which best fits the content of the table.  Deciding which
               to do is entirely up to the processing system since the source XML, converted from
               other sources as it was, does not include even the few presentation-oriented attributes
               defined by the DTD.
            </div>
            <div class="para e95">The NLM/JATS DTDs support [TableWrap] specifying the orientation of a combined table
               and caption but do not provide a way to indicate the width of a table.  The NISO JATS
               table model does allow a 'style' attribute on 'table' and 'caption', but not on the
               'table-wrap' that contains them both.
            </div>
            <div class="para e96">The sample files provided at the start of the project included TIFF images of each
               of the tables in the samples as well as TIFF files for the graphics, and it wasn't
               until the project was underway that it was made clear that the images of the tables
               were artifacts of the existing processing system and, not only were they not going
               to be available for new documents, the new system was expected to produce those as
               well.
            </div>
            <div class="para e97">The implemented approach makes a temporary 'sizer' formatted document containing each
               table at each width, saves the area tree from that document, and provides the area
               tree as a parameter to the stylesheet that produces the FO for the final formatted
               output.
            </div>
            <div class="para e98">The 'sizer' document comprises three pages that each have a different fixed width
               and a large height (since the formatter doesn't support '&lt;fo:root media-usage="bounded-in-one-dimension"&gt;').
               Every table in the source XML has an ID, so the tables on each page are given a unique
               ID in their FO document by prefixing a page-specific prefix to the tables original
               ID.  The following figure shows tables from an article formatted at page-wide, column-wide,
               and page-high widths.  The first two tables fit within a column, but the third overflows
               a column.
            </div>
            <div class="figure e99" xml:id="sizer">
               <div class="title e100">'sizer' document</div>
               <div class="mediaobject e101">
                  <div class="imageobject e102">
                     <div class="metaBox e103"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e162').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e162" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e103'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-005.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e104">The stylesheet that produces the 'sizer' document is very simple.  A template matching
               the document node does all the work, and the stylesheet imports the 'main' stylesheet
               so the tables are formatted exactly as they would be in the final output.  Since there
               are only three pages, the stylesheet does not even define any page-sequence masters,
               so each fo:page-sequence refers directly to a fo:simple-page-master.
            </div>
            <div class="programlisting e105" xml:space="preserve">
               &lt;fo:root&gt;
               &lt;fo:layout-master-set&gt;
               &lt;xsl:call-template name="define-sizer-simple-page-masters"/&gt;
               &lt;/fo:layout-master-set&gt;
               &lt;fo:page-sequence master-reference="page-wide"&gt;
               &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
               &lt;xsl:apply-templates select="//table-wrap"&gt;
               &lt;xsl:with-param name="prefix" select="'page-wide-'" as="xs:string" tunnel="yes" /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/fo:flow&gt;
               &lt;/fo:page-sequence&gt;
               &lt;fo:page-sequence master-reference="column-wide"&gt;
               &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
               &lt;xsl:apply-templates select="//table-wrap"&gt;
               &lt;xsl:with-param name="prefix" select="'column-wide-'" as="xs:string" tunnel="yes"
               /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/fo:flow&gt;
               &lt;/fo:page-sequence&gt;
               &lt;fo:page-sequence master-reference="page-high"&gt;
               &lt;fo:flow flow-name="body" xsl:use-attribute-sets="fo:flow"&gt;
               &lt;xsl:apply-templates select="//table-wrap"&gt;
               &lt;xsl:with-param name="prefix" select="'page-high-'" as="xs:string" tunnel="yes" /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/fo:flow&gt;
               &lt;/fo:page-sequence&gt;
               &lt;/fo:root&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e106">The only template that has so far been needed to override the default processing just
               stops bibliographic cross-references or references to supplemantary material generating
               a fo:basic-link so there's no longer warnings from the XSL formatter about unresolved
               cross-references:
            </div>
            <div class="programlisting e107" xml:space="preserve">&lt;xsl:template match="xref[@ref-type = ('bibr', 'supplementary-material')]"&gt;
               &lt;xsl:apply-templates /&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e108">The main stylesheet declares variables for the page width, margins, etc., so the same
               values are used in the main stylesheet to produce the final output and to work out
               whether graphics should be page-wide or column-wide and used in the 'sizer' stylesheet
               to set the pages' dimensions.
            </div>
            <div class="para e109">As stated previously, the area tree for the 'sizer' document is saved as XML, and
               the filename of the area tree XML passed to the main stylesheet, when run separately,
               as a parameter value.  When the stylesheet comes to process a 'table-wrap', it looks
               up the dimensions of the table variants in the 'sizer' area tree and, based on the
               dimensions, decides which format of the table to use.  The following figure shows
               two of the tables from the 'sizer' document in the final formatted output.
            </div>
            <div class="figure e110" xml:id="pages">
               <div class="title e111">Formatted pages</div>
               <div class="mediaobject e112">
                  <div class="imageobject e113">
                     <div class="metaBox e114"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e181').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e181" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e114'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-006.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e115">Current capabilities include automatic sizing of tables to be column-wide, page-wide,
               or page-high (either column-width or page-width), with manual overrides available
               to force a table to be page-wide or page high, plus automatic breaking of tables that
               are too high (or, for page-high tables, too wide) for the available space.  When tables
               are broken into multiple subtables, each subtable gets its column widths from the
               'sizer' table both so the subtables use the same widths and to avoid the automatic
               table algorithm optimising eacch subtable and leaving space at the bottom of a page.
            </div>
            <div class="para e116">It hasn't yet been necessary to produce TIFF images of each table, but if it were
               required, the main stylesheet would output a separate FO document with individually-sized
               page dimensions for each table.  Those FO documents would then be formatted to PDF
               or PostScript and then converted to TIFF using ImageMagick.
            </div>
         </div>
      </div><a name="ExtensibleStylesheetLanguage(XSL)RequirementsVersion20ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e117">
         <div class="title e118">Extensible Stylesheet Language (XSL) Requirements Version 2.0</div>
         <div class="para e119">The "Extensible Stylesheet Language (XSL) Requirements Version 2.0" Working Draft
            [XSLFO20-Req], published two years after XSL 1.1, includes among its requirements
            several that require or allow more decision making within the XSL formatter or that
            break the linear sequence of the XSL 1.1 processing model, including:
         </div>
         <div class="itemizedlist e120">
            <div class="listitem e121">
               <div class="para e122">Section 2.3, Feedback from pagination stage</div>
               <div class="para e123">This calls for "the ability to use information from the pagination step of one formatting
                  episode in determining layout of the following formatting episode" and "making changes
                  to the pages, reordering pages, merging multiple flows and do many other post processing
                  tasks."  This is what was done in the PLOS ONE example above, but if it could be realised
                  in a XSL-FO 2.0 specification and in a XSL-FO 2.0 formatter, then it may be easier
                  to use compared to the current bespoke solution that is stitched together using Apache
                  Ant.
               </div>
            </div>
            <div class="listitem e124">
               <div class="para e125">Section 3.1, Including information from formatting time</div>
               <div class="para e126">This calls for the XSL-FO expression language "to allow expressions that include information
                  that’s only available at formatting time."  If implemented, it wouldn't necessarily
                  put more decision making in the XSL formatter, but would let the output change the
                  output in a way that isn't possible at present.
               </div>
            </div>
            <div class="listitem e127">
               <div class="para e128">Section 3.2, Pagination information</div>
               <div class="para e129">The ability "to compute expressions that are based on information that is only available
                  after the pagination stage" would be another twist to the linear processing model.
               </div>
            </div>
            <div class="listitem e130">
               <div class="para e131">Section 2.1.4, Copyfitting</div>
               <div class="para e132">Copyfitting, in XSL-FO 2.0 terms, would be the ability to "shrink or grow content
                  (change properties of text, line-spacing, ...) to make it constrain to a certain area."
                  The requirements also anticipate that "multiple instances of alternative content can
                  be provided to determine best fit" and that copyfitting would act "across a given
                  number of pages, regions, columns etc, for example to constrain the number of pages
                  to 5 pages."
               </div>
               <div class="para e133">Again, this would put more decision making within the XSL formatter but, once specified
                  in the input FO document, it would be beyond the direct control of the XSLT stylesheet
                  and of the stylesheet writer.
               </div>
            </div>
         </div>
      </div><a name="PrintandPageLayoutCommunityGroupANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e134">
         <div class="title e135">Print and Page Layout Community Group</div>
         <div class="para e136">The charter of the W3C XML Print and Page Layout Working Group, which was developing
            XSL-FO 2.0 and produced a series of working drafts, expired in early 2013.  However,
            following the inception of Business and Community Groups at the W3C, the Print and
            Page Layout Community Group [PPL] has been operating since early 2012.  It has no
            charter and no support from the W3C other than that provided to all Community Groups,
            but after a period of relative inactivity, it is now producing new ideas and trying
            out new solutions for XSL-FO processing.
         </div><a name="EmphasisonfeedbackANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e137">
            <div class="title e138">Emphasis on feedback</div>
            <div class="para e139">Following a post by Patrick Gundlach of Speedata on the eve of his XML Prague 2013
               talk [Sppedata], the CG turned its attention to feedback, or the lack of it, in XSL-FO
               processing.  The CG produced a short list of examples where feedback, as the basis
               for decision making, would be useful [CustReq].  Some of them have direct equivalents
               in the XSL-FO 2.0 requirements document, but others do not.
            </div>
            <div class="para e140">It was quite easy for several on the public-ppl@w3.org mailing list to agree on the
               usefulness of more feedback in XSL-FO processing (while others are happy with XSL
               1.1 as it is today [Hahn]), but the difficulty was in doing anything about it given
               the limited resources of the CG.  In response to comments on the mailing list, Arved
               Sandstrom of MagicLamp Software produced a proof-of-concept extension function [FOPRunXSLTExt]
               for both the Saxon and Xerces XSLT processors that, mid-transform, runs the Apache
               FOP XSL formatter [FOP] on a provided FO document and returns (a reference to) the
               area tree XML for the formatted result.
            </div>
            <div class="para e141">Several examples of the extension function in action are provided on the PPL wiki.
               The example below demonstrates a solution to requirement #9, "Ability to modify label
               field width in a single list when labels are large", from [CustReq].
            </div>
            <div class="para e142">The example's source XML includes two lists that, when transformed with the default
               stylesheet and formatted, are cleverly contrived to have list item label widths that
               are either too wide or too narrow for the labels in the lists.
            </div>
            <div class="figure e143" xml:id="wrong">
               <div class="title e144">Wrong list item label widths</div>
               <div class="mediaobject e145">
                  <div class="imageobject e146">
                     <div class="metaBox e147"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e235').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e235" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e147'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-007.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e148">When the same XML is transformed with a stylesheet that uses the extension function
               and then formatted, the list item label widths are set based on the actual maximum
               formatted width of the labels in each list. The stylesheet constructs a test document
               containing just the list item label texts, uses the extension function to format that
               and get the area tree, and decides the maximum widths from the area tree. The document
               that is formatted mid-transform is, therefore, a different document to the one used
               to produce the final output.
            </div>
            <div class="figure e149" xml:id="right">
               <div class="title e150">Right list item label widths</div>
               <div class="mediaobject e151">
                  <div class="imageobject e152">
                     <div class="metaBox e153"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e243').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e243" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e153'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-008.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="programlisting e154" xml:space="preserve">&lt;xsl:template name="main"&gt;
               &lt;!-- Make a test document containing only the list labels.  Re-use
               example markup rather than creating FOs directly just because
               it's convenient. --&gt;
               &lt;xsl:variable name="test-doc"&gt;
               &lt;example&gt;
               &lt;xsl:for-each select="key('lists', true())"&gt;
               &lt;box id="{@id}" width="3in" height="3in"&gt;
               &lt;xsl:for-each select="item/@label"&gt;
               &lt;paragraph&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/paragraph&gt;
               &lt;/xsl:for-each&gt;
               &lt;/box&gt;
               &lt;/xsl:for-each&gt;
               &lt;/example&gt;
               &lt;/xsl:variable&gt;
               &lt;!-- Save the FO tree from $test-doc in a variable. --&gt;
               &lt;xsl:variable name="fo_tree"&gt;
               &lt;xsl:apply-templates select="$test-doc" /&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:variable name="area_tree_file"
               		select="concat($dest_dir, '/', $area_tree_filename)" /&gt;
               
               &lt;xsl:message&gt;Area tree filename = &lt;xsl:value-of select="$area_tree_file" /&gt;&lt;/xsl:message&gt;
               
               &lt;xsl:variable
               name="url"
               select="runfop:area-tree-url($fo_tree, $area_tree_file)"
               as="xs:string" /&gt;
               
               &lt;xsl:variable
               name="area-tree"
               select="document($url)"
               as="document-node()?" /&gt;
               
               &lt;xsl:variable name="overrides"&gt;
               &lt;overrides&gt;
               &lt;!-- Find the maximum label width for each list and convert to pt. --&gt;
               &lt;xsl:for-each select="key('lists', true())"&gt;
               	&lt;xsl:variable name="id" select="@id" as="xs:string" /&gt;
               	&lt;xsl:variable name="block"
               		      select="key('blocks', $id, $area-tree)[1]" /&gt;
               	&lt;override id="{$id}" label-width="{max($block//text/@ipd) div 1000}pt" /&gt;
               &lt;/xsl:for-each&gt;
               &lt;/overrides&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:apply-templates select="/"&gt;
               &lt;xsl:with-param name="overrides" select="$overrides" as="document-node()" tunnel="yes"
               /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e155">The examples so far haven't demonstrated anything that couldn't be done using two
               stylesheets in the manner of the PLOS ONE table handling.  The following example impements
               the oft-stated requirement for adjusting font size until text just fits a certain
               area.  Since that's an iterative process, it's more convenient to do that within on
               transformation rather than having to use shell scripts or Ant to run an XSLT processor
               on a preliminary stylesheet multiple times and examine the result each time.
            </div>
            <div class="figure e156" xml:id="fill">
               <div class="title e157">'font-size' adjusted so text fills box</div>
               <div class="mediaobject e158">
                  <div class="imageobject e159">
                     <div class="metaBox e160"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e253').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e253" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e160'
                              </span><span class="metaAttribute">fileref='../../../vol10/graphics/Graham01/Graham01-009.png'
                              </span><span class="metaAttribute">format='png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="programlisting e161" xml:space="preserve">&lt;!-- Initial template --&gt;
               &lt;xsl:template name="main"&gt;
               &lt;xsl:call-template name="do-box"&gt;
               &lt;xsl:with-param name="font-size" select="$font-size" as="xs:double" /&gt;
               &lt;xsl:with-param
               name="font-size.minimum" select="$font-size" as="xs:double" tunnel="yes" /&gt;
               &lt;xsl:with-param
               name="font-size.maximum" select="$font-size * 10" as="xs:double" tunnel="yes" /&gt;
               &lt;xsl:with-param name="iteration" select="1" as="xs:integer" /&gt;
               &lt;xsl:with-param name="iteration-max" select="30" as="xs:integer" tunnel="yes" /&gt;
               &lt;xsl:with-param name="tolerance" select="$tolerance" as="xs:double" tunnel="yes" /&gt;
               &lt;/xsl:call-template&gt;
               &lt;/xsl:template&gt;
               
               &lt;xsl:template name="do-box"&gt;
               &lt;xsl:param name="font-size" as="xs:double" /&gt;
               &lt;xsl:param name="font-size.minimum" as="xs:double" tunnel="yes" /&gt;
               &lt;xsl:param name="font-size.maximum" as="xs:double" tunnel="yes" /&gt;
               &lt;xsl:param name="iteration" select="1" as="xs:integer" /&gt;
               &lt;xsl:param name="iteration-max" select="5" as="xs:integer" tunnel="yes" /&gt;
               &lt;xsl:param name="tolerance" select="$tolerance" as="xs:double" tunnel="yes" /&gt;
               
               &lt;xsl:variable name="area_tree_filename_basename"
               select="replace($area_tree_filename, '\.[^.]+$', '')"
               as="xs:string" /&gt;
               &lt;xsl:variable name="area_tree_filename_suffix"
               select="tokenize($area_tree_filename, '\.')[last()]"
               as="xs:string" /&gt;
               &lt;xsl:variable name="area_tree_file"
               		select="concat($dest_dir,
               '/',
               $area_tree_filename_basename,
               '-',
               $iteration,
               '.',
               $area_tree_filename_suffix)"
               as="xs:string" /&gt;
               
               &lt;xsl:message&gt;iteration = &lt;xsl:value-of select="$iteration" /&gt;&lt;/xsl:message&gt;
               &lt;xsl:message&gt;font-size = &lt;xsl:value-of select="$font-size" /&gt;&lt;/xsl:message&gt;
               &lt;xsl:message&gt;font-size.minimum = &lt;xsl:value-of select="$font-size.minimum" /&gt;&lt;/xsl:message&gt;
               &lt;xsl:message&gt;font-size.maximum = &lt;xsl:value-of select="$font-size.maximum" /&gt;&lt;/xsl:message&gt;
               &lt;xsl:message&gt;Area tree filename = &lt;xsl:value-of select="$area_tree_file" /&gt;&lt;/xsl:message&gt;
               
               &lt;xsl:variable name="overrides"&gt;
               &lt;overrides&gt;
               &lt;!-- Set the font size. --&gt;
               &lt;xsl:for-each select="key('boxes', true())"&gt;
               	&lt;xsl:variable name="id" select="@id" as="xs:string" /&gt;
               	&lt;override id="{$id}" font-size="{$font-size}" /&gt;
               &lt;/xsl:for-each&gt;
               &lt;/overrides&gt;
               &lt;/xsl:variable&gt;
               
               &lt;!-- Save the FO tree in a variable. --&gt;
               &lt;xsl:variable name="fo_tree"&gt;
               &lt;xsl:apply-templates select="/"&gt;
               &lt;xsl:with-param name="overrides" select="$overrides" as="document-node()" tunnel="yes"
               /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:variable
               name="url"
               select="runfop:area-tree-url($fo_tree, $area_tree_file)"
               as="xs:string" /&gt;
               
               &lt;xsl:variable
               name="area-tree"
               select="document($url)"
               as="document-node()?" /&gt;
               
               &lt;xsl:variable
               name="bpd"
               select="key('blocks', key('boxes', true())[1]/@id, $area-tree)[1]/block/@bpd"
               as="xs:integer" /&gt;
               
               &lt;xsl:variable
               name="target-height"
               select="xs:double(substring-before(key('boxes', true())[1]/@height, 'pt'))"
               as="xs:double" /&gt;
               
               &lt;xsl:choose&gt;
               &lt;xsl:when test="$iteration eq $iteration-max"&gt;
               &lt;xsl:message&gt;Maximum iterations.&lt;/xsl:message&gt;
               &lt;xsl:apply-templates select="/"&gt;
               &lt;xsl:with-param
               name="overrides"
               select="$overrides"
               as="document-node()"
               tunnel="yes" /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/xsl:when&gt;
               &lt;xsl:when test="$bpd div 1000 &gt; $target-height"&gt;
               &lt;xsl:call-template name="do-box"&gt;
               &lt;xsl:with-param
               name="font-size"
               select="($font-size + $font-size.minimum) div 2"
               as="xs:double" /&gt;
               &lt;xsl:with-param
               name="font-size.maximum"
               select="$font-size"
               as="xs:double"
               tunnel="yes" /&gt;
               &lt;xsl:with-param name="iteration" select="$iteration + 1" as="xs:integer" /&gt;
               &lt;/xsl:call-template&gt;
               &lt;/xsl:when&gt;
               &lt;xsl:when test="$target-height - ($bpd div 1000) &amp;lt;
               $target-height * $tolerance div $target-height"&gt;
               &lt;xsl:message&gt;It fits.&lt;/xsl:message&gt;
               &lt;xsl:apply-templates select="/"&gt;
               &lt;xsl:with-param
               name="overrides"
               select="$overrides"
               as="document-node()"
               tunnel="yes" /&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/xsl:when&gt;
               &lt;xsl:otherwise&gt;
               &lt;xsl:call-template name="do-box"&gt;
               &lt;xsl:with-param
               name="font-size"
               select="($font-size + $font-size.maximum) div 2"
               as="xs:double" /&gt;
               &lt;xsl:with-param
               name="font-size.mimimum"
               select="$font-size"
               as="xs:double"
               tunnel="yes" /&gt;
               &lt;xsl:with-param name="iteration" select="$iteration + 1" as="xs:integer" /&gt;
               &lt;/xsl:call-template&gt;
               &lt;/xsl:otherwise&gt;
               &lt;/xsl:choose&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e162">The difficulty with the proof-of-concept extension function is that it's only a proof-of-concept
               -- getting the area tree back from the extension function is more complicated than
               it needs to be, and getting values from the area tree requires some comprehension
               of the FOP area tree XML.  If it is to be generally usable and usable with different
               XSL formatters, there should be a common area tree XML format into which vendor's
               area trees can be transformed and/or library functions for common area tree access
               operations.
            </div>
         </div><a name="AdaptSaxonCEeventmodeltoXSLFO?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e163">
            <div class="title e164">Adapt Saxon-CE event model to XSL-FO?</div>
            <div class="para e165">Using the proof-of-concept extension function, an
               XSLT stylesheet can now make decisions about what to put in the result
               based on the trial formatted size of areas, but as it's only a
               proof-of-concept, it doesn't aim as high as getting feedback from or
               modifying in-situ the area tree for the final, formatted document.
            </div>
            <div class="para e166">Once people have tried a few things with getting feedback from the XSL
               formatter and start asking their vendors for the same or better, they'll
               also be wanting an interoperable way to express what to do with that
               feedback.  For simple feedback of static area trees, which is all that is
               possible with the current proof-of-concept, the most interoperability that
               you could manage would be a common representation of area trees (with
               flexibility for vendor extensions) and, possibly, a library of XSLT
               functions to make it easier to navigate the area trees, but for "live"
               feedback, something more would be required.
            </div>
            <div class="para e167">The PPL CG has recently been looking at how Saxon-CE [SaxonCE] handles user input,
               and considering whether the same sort of pattern could be adapted to handling
               feedback from the XSL formatter.  Saxon-CE does it through template
               rules that match the element that receives the event and are in a mode
               that reflects the type of event, and similarly an XSL formatter could
               trigger on exceptional events such as overflow occurring or even on
               mundane events such as completion of a page sequence, and the templates in
               the corresponding modes could match on either FOs in the FO tree or areas
               in the area tree.
            </div>
            <div class="para e168">The following template from the "Knight's Tour" sample Saxon-CE
               application is the event handler for when the user clicks the 'Reset'
               button.  It simply writes a NO-BREAK SPACE to each square on the Knight's
               chess board
            </div>
            <div class="programlisting e169" xml:space="preserve">&lt;xsl:template match="button[@id='reset']" mode="ixsl:onclick"&gt;
               &lt;xsl:for-each select="//div[starts-with(@id, 'square')]"&gt;
               &lt;xsl:result-document href="#{@id}" method="replace-content"&gt;
               &lt;xsl:text&gt;&amp;amp;#xa0;&lt;/xsl:text&gt;
               &lt;/xsl:result-document&gt;
               &lt;/xsl:for-each&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e170">The key feature of the event handler for the purposes of this discussion
               is that it's written in plain old XSLT.  The advantage of the XSLT event
               handler for Saxon-CE users is interactivity "without dropping down into
               JavaScript" (as the Saxon-CE documentation so delicately puts it),
               but the advantage for XSL-FO users would simply be that they don't need to
               learn a new language (declarative, functional, or otherwise) to handle
               feedback.  (And the advantage for those trying to define or
               implement feedback is that they don't need to invent a whole new language to
               handle it.)
            </div>
            <div class="para e171">Applying the Saxon-CE approach to XSL-FO, the following conceptual FO
               event handler would handle a figure overflowing its available space by
               reducing its size to 80% of the current.
            </div>
            <div class="programlisting e172" xml:space="preserve">&lt;xsl:template match="BlockArea[key('fig', @id, $src-doc)]"
               mode="ppl:overflow"&gt;
               &lt;xsl:result-document href="#{@id}/area:external-graphic"
               method="replace-content"&gt;
               &lt;xsl:copy&gt;
               &lt;xsl:apply-templates select="@*"/&gt;
               &lt;xsl:attribute name="width"
               select="ppl:scale(area:external-graphic/@width,
               0.8)"/&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/xsl:copy&gt;
               &lt;/xsl:result-document&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e173">
               An extra wrinkle for XSL-FO is the question of whether event handlers
               should be specified to (a) match on, and (b) modify the FO tree or the
               area tree or both.  There are some existing requirements that can only be
               satisfied by modifying the area tree, e.g., Section 3.3, Output result of
               expression:
            </div>
            <div class="popupBox e174">
               <div class="popupLabel" onmouseover="$('#d1e280').show('1000');" onmouseout="$('#d1e280').hide('1000');">[ blockquote ]</div>
               <div id="d1e280" style="display: none;">
                  <div class="blockquote">
                     <div class="para e175">Allow users to output the result of expressions on area tree,
                        traits, markers or text content. For example to calculate the
                        subtotal of a certain page (as opposed to a running total that
                        is already supported in XSL 1.1 with table markers)
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e176">On the other hand, it will often be simpler (from the user's perspective)
               to modify an FO rather than all the areas that it generates, since a
               single FO may generate multiple areas across several columns or pages (and
               footnote areas), and its content may be reused in markers on multiple
               pages.  If, for example, the response to a page sequence taking too many
               pages is to reduce the font size in one of the multiple flows appearing on
               the page, it would be at once simple to adjust the 'font-size' property on
               the appropriate FOs in the FO tree and inaccurate to directly modify font
               sizes in the line areas in the area tree.  If the XSL formatter did the
               work based on modified FOs, it would reflow the line areas based on their
               reduced font size and make the pages again and the resulting modified
               block areas would break across pages in different places because of the
               smaller font size.  If the XSLT stylesheet did the work by modifying the
               area tree, it would have to do the same recalculating of text sizes and
               the same merging or splitting of line areas and of block areas, and all
               (probably) without the benefit of font metrics.  It might work, just, in a
               simple case with only monospace fonts, but would still be a lot of work to
               do in XSLT.
            </div>
            <div class="para e177">Adapting the Saxon-CE event model to XSL-FO is, therefore, an interesting
               possible solution to handling feedback from the XSL formatter, but there
               are still many FO-specific details that would have to be worked out.
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e178">
         <div class="title e179">Conclusion</div>
         <div class="para e180">The linear processing model of XSL 1.1 has served it will -- and, in the XSL 1.0 timeframe,
            helped it towards becoming a Recommendation -- but real world use cases have forced
            users into doing multi-pass processing and other tricks so they can make decisions
            on what to put in the formatted output based on sizes in the formatted output.  The
            XSL-FO 2.0 requirements document recognised some of these requirements, but the XPPL
            WG's charter expired without XSL-FO 2.0 being completed.  Since then, the Print and
            Page Layout Community Group at the W3C has been producing innovative ideas and solutions
            to help satisfy the user requirements for more decision making in XSL-FO processing.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e181">
         <div class="title e182">Bibliography</div>
         <div class="bibliomixed e183" xml:id="CustReq" xreflabel="CustReq">Frequently and less frequently stated requirements by print customers, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e184" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/community/ppl/wiki/CustomerRequirements</div>
         </div>
         <div class="bibliomixed e185" xml:id="DSSSL" xreflabel="DSSSL">ISO/IEC 10179:1996 Information technology - Processing languages - Document Style
            Semantics and Specification Language (DSSSL),
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e186" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://xml.coverpages.org/dsssl96-ps.zip</div> (from 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e187" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://xml.coverpages.org/dsssl.html</div>)
         </div>
         <div class="bibliomixed e188" xml:id="FOP" xreflabel="FOP">Apache™ FOP, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e189" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://xmlgraphics.apache.org/fop/</div>
         </div>
         <div class="bibliomixed e190" xml:id="FOPRunXSLTExt" xreflabel="FOPRunXSLTExt">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e191" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/community/ppl/wiki/FOPRunXSLTExt</div>
         </div>
         <div class="bibliomixed e192" xml:id="Hahn" xreflabel="Hahn">Re: Customer requirement, a critque, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e193" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://lists.w3.org/Archives/Public/public-ppl/2013Feb/0078.html</div>
         </div>
         <div class="bibliomixed e194" xml:id="JADE" xreflabel="JADE">Jade - James' DSSSL Engine, 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e195" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jclark.com/jade/</div>
         </div>
         <div class="bibliomixed e196" xml:id="PLOS" xreflabel="PLOS">What is PLOS?,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e197" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.plos.org/about/what-is-plos/</div>
         </div>
         <div class="bibliomixed e198" xml:id="PONE" xreflabel="PONE">PLOS ONE,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e199" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.plosone.org/</div>
         </div>
         <div class="bibliomixed e200" xml:id="PONEManuscript" xreflabel="PONEManuscript">PLOS ONE Manuscript Guidelines,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e201" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.plosone.org/static/guidelines</div>
         </div>
         <div class="bibliomixed e202" xml:id="PPL" xreflabel="PPL">Print and Page Layout Community Group,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e203" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/community/ppl/</div>
         </div>
         <div class="bibliomixed e204" xml:id="SaxonCE" xreflabel="SaxonCE">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e205" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.saxonica.com/ce/user-doc/1.1/index.html</div>
         </div>
         <div class="bibliomixed e206" xml:id="Speedata" xreflabel="Speedata">Fully automatic database publishing with the speedata Publisher,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e207" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/sessions/#speedata</div>
         </div>
         <div class="bibliomixed e208" xml:id="TableWrap" xreflabel="TableWrap">table-wrap, Journal Archiving and Interchange Tag Library NISO JATS version 1.0, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e209" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jats.nlm.nih.gov/archiving/tag-library/1.0/index.html?elem=table-wrap</div>
         </div>
         <div class="bibliomixed e210" xml:id="XSL11" xreflabel="XSL11">Extensible Stylesheet Language (XSL) Version 1.1,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e211" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xsl11/</div>
         </div>
         <div class="bibliomixed e212" xml:id="XSLCRTest" xreflabel="XSLCRTest">XSL CR Test Suite -- Test Coverage,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e213" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/Style/XSL/TestSuite/coverage/testcoverage.html</div>
         </div>
         <div class="bibliomixed e214" xml:id="XSLFO20-Req" xreflabel="XSLFO20-Req">Extensible Stylesheet Language (XSL) Requirements Version 2.0,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e215" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslfo20-req/</div>
         </div>
         <div class="bibliomixed e216" xml:id="XSLReq" xreflabel="XSLReq">XSL Requirements Summary,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e217" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/1998/WD-XSLReq-19980511.html</div>
         </div>
      </div>
   </div>
</div>