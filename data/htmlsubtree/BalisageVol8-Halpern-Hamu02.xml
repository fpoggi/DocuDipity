<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#%0ATCStcs:TataConsultancyServicestrashcompactorscript%0AANCHOR" name="%0ATCStcs:TataConsultancyServicestrashcompactorscript%0ATOC">
               TCS tcs: Tata Consultancy Services trash compactor script
               </a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AContext%0AANCHOR" name="%0AContext%0ATOC">
                  Context
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AAlternatives%0AANCHOR" name="%0AAlternatives%0ATOC">
                  Alternatives
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AGoals%0AANCHOR" name="%0AGoals%0ATOC">
                  Goals
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AAlgorithm%0AANCHOR" name="%0AAlgorithm%0ATOC">
                  Algorithm
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AEfficiency%0AANCHOR" name="%0AEfficiency%0ATOC">
                  Efficiency
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AParameters%0AANCHOR" name="%0AParameters%0ATOC">
                  Parameters
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0ACode%0AANCHOR" name="%0ACode%0ATOC">
                  Code
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0ADiscussion%0AANCHOR" name="%0ADiscussion%0ATOC">
                  Discussion
                  </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#%0AReferences%0AANCHOR" name="%0AReferences%0ATOC">
                  References
                  </a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Annotate with signatures.</div>
         <div class="singletermTERMS">Ancestor count.</div>
         <div class="singletermTERMS">Attribute count.</div>
         <div class="singletermTERMS">Accummulators.</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage conference,</div>
         <div class="singletermTERMS">both</div>
         <div class="singletermTERMS">Best time to trim text.</div>
         <div class="singletermTERMS">Balisage: The Markup Conference,</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
         <div class="singletermTERMS">big data</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">complete</div>
         <div class="singletermTERMS">Craft.</div>
         <div class="singletermTERMS">Curation.</div>
         <div class="singletermTERMS">Child count.</div>
         <div class="singletermTERMS">Collapse parallel structures.</div>
         <div class="singletermTERMS">current</div>
         <div class="singletermTERMS">charlie.hamu@tcs.com</div>
         <div class="singletermTERMS">Charlie</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Dale Waldt</div>
         <div class="singletermTERMS">Debbie Lapeyre</div>
         <div class="singletermTERMS">Debug signatures.</div>
         <div class="singletermTERMS">Debug marks.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Elliotte Rusty Harold</div>
         <div class="singletermTERMS">Ease over perfection.</div>
         <div class="singletermTERMS">either</div>
         <div class="singletermTERMS">End words count.</div>
         <div class="singletermTERMS">Efficiency.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">False positive.</div>
         <div class="singletermTERMS">False negative.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">Grouping using the Muenchian Method,</div>
         <div class="singletermTERMS">Good defaults.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">Halpern-Hamu</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">intersect</div>
         <div class="singletermTERMS">Ian Gorman</div>
         <div class="singletermTERMS">Intuit schema.</div>
         <div class="singletermTERMS">immediately preceding</div>
         <div class="singletermTERMS">interoperability</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">John Cowan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">key</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Log the seed.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">Mad Libs,</div>
         <div class="singletermTERMS">Murray Maloney</div>
         <div class="singletermTERMS">Mark unique elements.</div>
         <div class="singletermTERMS">Mark wrapping elements.</div>
         <div class="singletermTERMS">Mark required children.</div>
         <div class="singletermTERMS">Multiple passes vs complicated XPath.</div>
         <div class="singletermTERMS">Middle words count.</div>
         <div class="singletermTERMS">modelling</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">number</div>
         <div class="singletermTERMS">number.</div>
         <div class="singletermTERMS">N-squared comparison to previous elements.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">on deck</div>
         <div class="singletermTERMS">Obsuring XML,</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">preceding</div>
         <div class="singletermTERMS">Paul Ryan</div>
         <div class="singletermTERMS">Plausible results.</div>
         <div class="singletermTERMS">Prune unneeded elements.</div>
         <div class="singletermTERMS">Preceding-sibling count.</div>
         <div class="singletermTERMS">Pointers.</div>
         <div class="singletermTERMS">Proceedings of Extreme Markup Languages</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">quality</div>
         <div class="singletermTERMS">querying</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Randomizing XML,</div>
         <div class="singletermTERMS">Robert Stuart</div>
         <div class="singletermTERMS">Regex text trimming.</div>
         <div class="singletermTERMS">Repetition count.</div>
         <div class="singletermTERMS">Randomize.</div>
         <div class="singletermTERMS">Redo from back.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">symposium on QA and QC</div>
         <div class="singletermTERMS">section</div>
         <div class="singletermTERMS">section.</div>
         <div class="singletermTERMS">sentence</div>
         <div class="singletermTERMS">Syd Bauman</div>
         <div class="singletermTERMS">Single dial.</div>
         <div class="singletermTERMS">Self count.</div>
         <div class="singletermTERMS">Start words count.</div>
         <div class="singletermTERMS">Show deletions.</div>
         <div class="singletermTERMS">Schema information.</div>
         <div class="singletermTERMS">Senior Solutions Architect</div>
         <div class="singletermTERMS">sample documents</div>
         <div class="singletermTERMS">sampling</div>
         <div class="singletermTERMS">software-based processing</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">title,</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">tcs:signature</div>
         <div class="singletermTERMS">tcs:signatures</div>
         <div class="singletermTERMS">title.</div>
         <div class="singletermTERMS">tcs:mark</div>
         <div class="singletermTERMS">Target length.</div>
         <div class="singletermTERMS">Text abbreviation.</div>
         <div class="singletermTERMS">transforming</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">Use information from schema.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XQuery.</div>
         <div class="singletermTERMS">Xmlsh.</div>
         <div class="singletermTERMS">XSLT</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="%0ATCStcs:TataConsultancyServicestrashcompactorscript%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">
         TCS tcs: Tata Consultancy Services trash compactor script
         
      </div>
      <div class="subtitle e2">
         Design considerations in the implementation of a boil-this-corpus-down-to-a-sample-document
         tool
         
      </div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2012</div>
            <div class="confdates e6">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">
               Creation of representative sample(s) of a large document collection can be automated
               using XSLT.
               Such samples will be useful for analysis, as a preliminary document analysis step
               in vocabulary redesign
               or conversion and to guide design of storage, editing, and transformation processing.
               Design goals are: to work intuitively with default configuration and no schema, produce
               plausible output,
               and produce a range of outputs from a large representative set to a short but highly
               complex sample document.
               The technique can be conceptualized in passes: annotate structures as original or
               redundant;
               keep wrappers to accommodate original markup found lower in the hierarchy;
               retain required children and attributes; and collapse similar structures.
               Possible settings include redundancy thresholds, text compression techniques, target
               length, schema-awareness,
               schema intuitions, how much context to preserve around kept elements, and whether
               similar structures should be collapsed (overlaid).
               
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Charlie</div>
               <div class="surname e12">Halpern-Hamu</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">
                  Charlie has been working with structured text since 1991.
                  During this time, he has acted as a content and systems architect, programmer, systems
                  integrator, consultant,
                  mentor, best-practices coordinator, trainer, book editor, project lead, department
                  manager, and vice president.
                  His consulting and training work has taken him all over North America
                  as well as visits to South America, Europe, Australia and China.
                  Charlie has a PhD in Computer Science from the University of Toronto and an MBA from
                  Heriot-Watt University.
                  He's good at making complex systems easy to understand. Or so he claims.
                  
               </div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Senior Solutions Architect</div>
               <div class="orgname e17">Tata Consultancy Services</div>
            </div>
            <div class="email e18">charlie.hamu@tcs.com</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">© Copyright 2012, Tata Consultancy Services.</div>
            <div class="para e21">Disclaimer: All views expressed in the publication are of the author and Tata Consultancy
               Services (TCS) does not warrant, either expressly or implied, the accuracy, appropriateness
               of the information in the publication. TCS disclaims any responsibility for content
               error, omissions and any responsibility associated with relying on the information
               provided in the publication.
            </div>
         </div>
         <div class="keywordset e22" role="author">
            <div class="keyword e23">sample documents</div>
            <div class="keyword e24">sampling</div>
            <div class="keyword e25">big data</div>
            <div class="keyword e26">interoperability</div>
            <div class="keyword e27">quality</div>
            <div class="keyword e28">XSLT</div>
            <div class="keyword e29">modelling</div>
            <div class="keyword e30">querying</div>
            <div class="keyword e31">software-based processing</div>
            <div class="keyword e32">transforming</div>
         </div>
      </div><a name="%0AContext%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e33">
         <div class="title e34">
            Context
            
         </div>
         <div class="para e35">
            Sample documents play a critical role in the development of most XML systems.
            
         </div>
         <div class="para e36">
            But good sample documents are difficult to generate.
            There seem to be three basic approaches, each with its difficulties:
            
            <div class="orderedlist e37">
               <div class="listitem e38">
                  <div class="para e39">
                     
                     <div class="emphasis e40" role="bold">Craft.</div>
                     Artfully crafting sample documents by hand is usually a labor-intensive path
                     to an artificial-feeling result.
                     Hand-crafted samples can be especially frustrating when they go stale,
                     when even minor schema changes necessitate significant rework.
                     
                  </div>
               </div>
               <div class="listitem e41">
                  <div class="para e42">
                     
                     <div class="citation e43" linkend="Mad_Libs">
                        <div class="emphasis e44" role="bold">
                           <div class="trademark e45">Mad Libs.</div>
                        </div>
                     </div>
                     Automatically-generated samples are often so random and disconnected from reality
                     that they are difficult for humans to comprehend and use.
                     Based on all the possibilities of a schema, they include many combinations
                     that simply would not occur in real life.
                     The schema provides no guidance about the kinds of content
                     that would make sense in each element, so contents are unfamiliar nonsense.
                     
                  </div>
               </div>
               <div class="listitem e46">
                  <div class="para e47">
                     
                     <div class="emphasis e48" role="bold">Curation.</div>
                     Thoughtfully choosing some sample documents from a larger set of available documents
                     is the approach most similar to the approach presented by this paper.
                     The difficulty is that most XML corpora are like war:
                     long stretches of boredom punctuated by moments of mildly increased interest.
                     It's easy to miss those documents that have interesting, unusual markup.
                     And it's easy to miss the interesting, unusual markup even within the documents chosen.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e49">
            There is often a tension between brevity and completeness.
            It's easiest for a human to understand a shorter, simpler documents.
            Including more elements, in more contexts, requires longer, more complex documents.
            
         </div>
      </div><a name="%0AAlternatives%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e50">
         <div class="title e51">
            Alternatives
            
         </div>
         <div class="para e52">
            Before this paper was presented on Wednesday of the
            
            <div class="citation e53" linkend="Balisage">Balisage conference,</div>
            there was a discussion of approaches to creating sample documents
            at the preceding
            
            <div class="citation e54" linkend="QA-QC">symposium on QA and QC</div>
            on the Monday.
            The following alternatives were listed:
            
            <div class="itemizedlist e55">
               <div class="listitem e56">
                  <div class="para e57">
                     
                     <div class="emphasis e58" role="bold">Dale Waldt</div>
                     suggested starting with all XPaths
                     (presumably FQGI, fully qualified generic identifier, ancestry paths) in a larger
                     set,
                     and finding an example of each.
                     
                  </div>
               </div>
               <div class="listitem e59">
                  <div class="para e60">
                     
                     <div class="emphasis e61" role="bold">Paul Ryan</div>
                     said he automated the extraction of all XPaths
                     (again, presumably FQGIs) and automatically created Lorem Ipsum text.
                     
                  </div>
               </div>
               <div class="listitem e62">
                  <div class="para e63">
                     
                     <div class="emphasis e64" role="bold">Murray Maloney</div>
                     spoke of running all variations, as determined by the possibilities allowed by the
                     Schema.
                     
                  </div>
               </div>
               <div class="listitem e65">
                  <div class="para e66">
                     
                     <div class="emphasis e67" role="bold">John Cowan</div>
                     talked about how, with LexisNexis, it was easy to get a firehose blast of volumes
                     of data.
                     He talked about crafting a sample document that was actually true facts, though a
                     constructed sample.
                     
                  </div>
               </div>
               <div class="listitem e68">
                  <div class="para e69">
                     
                     <div class="emphasis e70" role="bold">Robert Stuart</div>
                     advised against real, or real-looking data,
                     having once had an intelligence agency get upset with him
                     when he to closely simulated, using public sources, the look of secret documents.
                     
                  </div>
               </div>
               <div class="listitem e71">
                  <div class="para e72">
                     
                     <div class="emphasis e73" role="bold">Syd Bauman</div>
                     said that when he needs a set of test documents to exercise a collection,
                     he typically starts by cutting out the uninteresting TEI header metadata,
                     and then keeping the first few paragraphs of each of several document.
                     When he needs to generate test data about an instance
                     he tends to need to be much pickier about which bits he keeps,
                     and, in general, he does this by hand.
                     
                  </div>
                  <div class="para e74">
                     For the cases where content could not be shared,
                     Syd also mentioned that 
                     <div class="emphasis e75" role="bold">Elliotte Rusty Harold</div>
                     had presented an XML Randomizer that worked like a neutron bomb on XML documents
                     (my inappropriate analogy), scrambling the content but leaving the structures intact.
                     
                     <div class="citation e76" linkend="Harold">[Harold]</div>
                     
                  </div>
               </div>
               <div class="listitem e77">
                  <div class="para e78">
                     
                     <div class="emphasis e79" role="bold">Debbie Lapeyre</div>
                     warned against taking the first ten pages,
                     and relayed a anecdote in which the last thousand pages were very different
                     from the first ten.
                     
                  </div>
               </div>
               <div class="listitem e80">
                  <div class="para e81">
                     
                     <div class="emphasis e82" role="bold">Ian Gorman</div>
                     described taking all available content as the universe from which to choose.
                     If I understood correctly, this is the approach automated by the current paper.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0AGoals%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e83">
         <div class="title e84">
            Goals
            
         </div>
         <div class="para e85">
            The primary goal of this project is a tool to boil large sets of XML data
            down to smaller samples.
            The samples should maintain as much as possible of the variety and complexity
            of markup patterns, and remove as much as possible of the useless repetitions.
            
         </div>
         <div class="para e86">
            Subsidiary design goals include:
            
            <div class="itemizedlist e87">
               <div class="listitem e88">
                  <div class="para e89">
                     
                     <div class="emphasis e90" role="bold">Plausible results.</div>
                     The hope is that the results will feel natural: compact, but recognizable.
                     
                  </div>
               </div>
               <div class="listitem e91">
                  <div class="para e92">
                     
                     <div class="emphasis e93" role="bold">Good defaults.</div>
                     The default parameter settings should hit some kind of sweet spot.
                     Is it presumptious to imagine that such a sweet spot exists?
                     I imagine it to be something like this:
                     one can say that the sample is
                     
                     <div class="quote e94">complete</div>
                     and that at the same time it is manageably short.
                     
                  </div>
               </div>
               <div class="listitem e95">
                  <div class="para e96">
                     
                     <div class="emphasis e97" role="bold">Single dial.</div>
                     Given the trade-offs between brevity and completeness,
                     it would be nice to have a single parameter that simultaneously adjusted
                     all the other parameters towards one extreme or the other.
                     
                  </div>
               </div>
               <div class="listitem e98">
                  <div class="para e99">
                     
                     <div class="emphasis e100" role="bold">Ease over perfection.</div>
                     If the occassional result is invalid, because of a wrong guess
                     about required elements, that's probably okay.
                     
                  </div>
               </div>
               <div class="listitem e101">
                  <div class="para e102">
                     
                     <div class="emphasis e103" role="bold">Use information from schema.</div>
                     If there is a schema available, it would be nice to take advantage of it.
                     The goal would not to be to include elements only because they exist in the schema,
                     but to avoid deleting elements that are required by the schema.
                     
                  </div>
               </div>
               <div class="listitem e104">
                  <div class="para e105">
                     
                     <div class="emphasis e106" role="bold">Intuit schema.</div>
                     My guess is that in most real-life situations,
                     required elements can be easily intuited.
                     For example, if every
                     
                     <div class="code e107">section</div>
                     contains a
                     
                     <div class="code e108">title,</div>
                     it's reasonable to guess that
                     
                     <div class="code e109">title</div>
                     is required in
                     
                     <div class="code e110">section.</div>
                     Of course this rule of thumb can fail in one of two ways:
                     
                     <div class="orderedlist e111">
                        <div class="listitem e112">
                           <div class="para e113">
                              
                              <div class="emphasis e114" role="bold">False positive.</div>
                              It could be the case that every
                              
                              <div class="code e115">section</div>
                              in a sample contains a
                              
                              <div class="code e116">title,</div>
                              but only by chance. But even in this case, there's no denying that
                              a representative sample will contain a
                              
                              <div class="code e117">title</div>
                              for every
                              
                              <div class="code e118">section.</div>
                              
                           </div>
                        </div>
                        <div class="listitem e119">
                           <div class="para e120">
                              
                              <div class="emphasis e121" role="bold">False negative.</div>
                              It could be that the content model is more complicated, that
                              
                              <div class="emphasis e122" role="ital">either</div>
                              
                              <div class="code e123">number</div>
                              or
                              
                              <div class="code e124">title</div>
                              is required on every
                              
                              <div class="code e125">section.</div>
                              As a result, the intuition will fail, and conclude
                              
                              <div class="emphasis e126" role="ital">both</div>
                              
                              <div class="code e127">number</div>
                              and
                              
                              <div class="code e128">title</div>
                              to be optional.
                              I haven't had enough real-life experience with the tool yet
                              to conclude how much trouble this will create.
                              
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0AAlgorithm%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e129">
         <div class="title e130">
            Algorithm
            
         </div>
         <div class="para e131">
            The algorithm, as implemented, involves multiple passes:
            
            <div class="orderedlist e132">
               <div class="listitem e133">
                  <div class="para e134">
                     
                     <div class="emphasis e135" role="bold">Annotate with signatures.</div>
                     This present implementation uses an attribute in a special namespace,
                     
                     <div class="code e136">tcs:signature</div>
                     to record the characteristics we're using to determine
                     what counts as the same and what counts as different.
                     This is configurable, and includes some combination of ancestry,
                     previous siblings, element name, attributes specified and child elements.
                     
                  </div>
                  <div class="para e137">
                     Because of the choice to use an attribute,
                     it's easiest to annotate only elements,
                     not attributes, processing-instructions or comments.
                     In an attempt to increase efficiency, a signature-to-element key was introduced.
                     This introduced the possibility of using the same key mechanism
                     to annotate attributes, processing instructions and comments.
                     
                  </div>
                  <div class="para e138">
                     The current implementation uses this first pass to shorten the text nodes.
                     The reasoning is that there will be less text passing through the subsequent passes.
                     This is really for ease of debugging: it actually seems to slow the process.
                     
                  </div>
               </div>
               <div class="listitem e139">
                  <div class="para e140">
                     
                     <div class="emphasis e141" role="bold">Mark unique elements.</div>
                     The next pass is to indicate a small number of each signature to keep.
                     As implemented the first one (or two or more ... configurable)
                     of each unique-signature element is kept,
                     but there's no requirement that the first elements be kept.
                     
                  </div>
               </div>
               <div class="listitem e142">
                  <div class="para e143">
                     
                     <div class="emphasis e144" role="bold">Mark wrapping elements.</div>
                     If an element is to be kept, obviously all its ancestor elements must be kept.
                     The current implementation marks these ancestors in a separate pass.
                     
                  </div>
               </div>
               <div class="listitem e145">
                  <div class="para e146">
                     
                     <div class="emphasis e147" role="bold">Mark required children.</div>
                     For all the elements that are to be kept,
                     certain child elements need to be kept, as they are required ...
                     or guessed to be.
                     
                  </div>
                  <div class="para e148">
                     In addition, this is a good time to mark inline elements
                     mixed in with the text of the elements that are being kept.
                     The reason for doing this is to maintain the sense of the retained text.
                     If not, it's likely we'll lose
                     the second and subsequent emphasized words in a sentence.
                     
                  </div>
               </div>
               <div class="listitem e149">
                  <div class="para e150">
                     
                     <div class="emphasis e151" role="bold">Prune unneeded elements.</div>
                     The final pass removes those elements that haven't been marked to be kept.
                     The current implementation keeps all atrributes
                     and also text, processing instruction and comment children of kept elements.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0AEfficiency%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e152">
         <div class="title e153">
            Efficiency
            
         </div>
         <div class="para e154">
            In the course of developing the current implementation,
            several efficiency issues were encountered.
            Not all have yet been resolved.
            
            <div class="itemizedlist e155">
               <div class="listitem e156">
                  <div class="para e157">
                     
                     <div class="emphasis e158" role="bold">Regex text trimming.</div>
                     The current implementation keeps the first few words and the last few words
                     of each text node. The regular expression processing to acheive this appears
                     to be slow. My guess is that it has to do with backtracking, and might be
                     improved by simply taking the first few words and not looking to keep the last.
                     
                  </div>
               </div>
               <div class="listitem e159">
                  <div class="para e160">
                     
                     <div class="emphasis e161" role="bold">Best time to trim text.</div>
                     In the naïve expectation that reducing the amount of text
                     to be processed by subsequent passes would be an efficiency gain,
                     the first pass does the trimming of the text nodes.
                     But only a small number of text nodes are retained in the end,
                     so it turns out to be more efficient to prune the tree first
                     before abbreviating the text nodes.
                     
                  </div>
                  <div class="para e162">
                     The truth is that the most useful results might come from untrimmed text.
                     
                  </div>
               </div>
               <div class="listitem e163">
                  <div class="para e164">
                     
                     <div class="emphasis e165" role="bold">N-squared comparison to previous elements.</div>
                     Unlike text trimming, which isn't essential to the process,
                     finding unique signatures is the purpose of the script, so it can't be skipped.
                     The first implementation of the script used a comparison of the current
                     
                     <div class="code e166">tcs:signature</div>
                     with all the
                     
                     <div class="code e167">tcs:signatures</div>
                     on the with
                     
                     <div class="code e168">preceding</div>
                     axis.
                     This obviously introduces an order
                     
                     <div class="emphasis e169" role="ital">n</div>
                     
                     <div class="superscript e170">2</div>
                     inefficiency.
                     The second attempt involved using a
                     
                     <div class="code e171">key</div>
                     to map signatures to elements,
                     and an
                     
                     <div class="code e172">intersect</div>
                     to detect if the set of similar signatures
                     includes elements that overlap with the
                     
                     <div class="code e173">preceding</div>
                     axis.
                     This is someone more efficient, but on the same order.
                     
                  </div>
                  <div class="para e174">
                     In order to work with large data sets, this needs to be resolved.
                     The current solution is to use a non-XSLT streaming pass.
                     The current implementation is not XML-aware, programmed using Perl regular expressions.
                     It could be done using a streaming XML parser,
                     but unless there are
                     
                     <div class="code e175">tcs:signature</div>
                     attributes that aren't actually markup in the documents, there will be no problem.
                     
                  </div>
               </div>
               <div class="listitem e176">
                  <div class="para e177">
                     
                     <div class="emphasis e178" role="bold">Multiple passes vs complicated XPath.</div>
                     The current implementation consists of several passes as outlined above.
                     In order to accommodate a non-XSLT streaming pass in the middle,
                     the first pass is in a separate script from the last passes.
                     It's almost certainly the case that several of these calculations
                     could be strung together in a more complicated XPath expression.
                     This might be easier to understand, or not.
                     And it might be more efficient, or not.
                     I imagine it might be elegant, in a way.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0AParameters%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e179">
         <div class="title e180">
            Parameters
            
         </div>
         <div class="para e181">
            The following parameters have been implemented:
            
            <div class="itemizedlist e182">
               <div class="listitem e183">
                  <div class="para e184">
                     
                     <div class="emphasis e185" role="bold">Ancestor count.</div>
                     How much context should be included in an element's signature?
                     Measured on a scale of zero to infinity, with 0 representing no ancestry,
                     1 representing the the parent of the current element,
                     2 representing the grandparent and parent,
                     7 presumed to be the largest number ever needed short of
                     8 which is taken to represent infinity (at a ninety-degree angle).
                     Infinity seems to be a good default,
                     as some XML processing operates on fully-qualified generic identifiers.
                     Also, it's common for deeply nested elements have a tendency
                     to stress stylesheets and other processing.
                     
                  </div>
               </div>
               <div class="listitem e186">
                  <div class="para e187">
                     
                     <div class="emphasis e188" role="bold">Preceding-sibling count.</div>
                     How many preceding siblings should be included in an element's signature?
                     A good default seems to be 1, looking only at the closest preceding sibling.
                     
                  </div>
               </div>
               <div class="listitem e189">
                  <div class="para e190">
                     
                     <div class="emphasis e191" role="bold">Self count.</div>
                     Should the element name itself be include in its own signature?
                     Surely the answer should be yes in most applications.
                     For consistency, this parameter is included, on a scale from 0 (no) to 1 (yes).
                     
                  </div>
               </div>
               <div class="listitem e192">
                  <div class="para e193">
                     
                     <div class="emphasis e194" role="bold">Attribute count.</div>
                     Should the element's specified attributes count as part of its signature?
                     Measured on a scale of 0 (no) to 8 (all of them),
                     with no sensible meaning for the numbers in between.
                     The current script has a bug in that it doesn't sort the attribute names as it should.
                     A good default seems to be to include the attributes names.
                     
                  </div>
               </div>
               <div class="listitem e195">
                  <div class="para e196">
                     
                     <div class="emphasis e197" role="bold">Child count.</div>
                     How many children should be included an element's signature?
                     Again, this parameter is measured on a scale of 0 = none to 8 = infinity.
                     The children are counted out in document order.
                     The thought here is to distinguish between a
                     
                     <div class="code e198">section</div>
                     that starts with a
                     
                     <div class="code e199">number</div>
                     from a
                     
                     <div class="code e200">section</div>
                     that starts with a
                     
                     <div class="code e201">title.</div>
                     An overlapping effect can sometimes also be achieved by using using the preceding-sibling
                     parameter:
                     including a
                     
                     <div class="code e202">section</div>
                     not on its own merits,
                     but because it contains a
                     
                     <div class="code e203">title</div>
                     that follows a
                     
                     <div class="code e204">number.</div>
                     
                  </div>
               </div>
               <div class="listitem e205">
                  <div class="para e206">
                     
                     <div class="emphasis e207" role="bold">Start words count.</div>
                     How many words should kept at the start when abbreviating a text node?
                     
                  </div>
               </div>
               <div class="listitem e208">
                  <div class="para e209">
                     
                     <div class="emphasis e210" role="bold">Middle words count.</div>
                     What is the minimum number of words to delete from the middle of a text node?
                     If there are less than this number of words in the middle, don't abbreviate.
                     
                  </div>
               </div>
               <div class="listitem e211">
                  <div class="para e212">
                     
                     <div class="emphasis e213" role="bold">End words count.</div>
                     How many words should be kept at the end when abbreviating a text node?
                     So, a text node is not abbreviated unless it contains start + middle + end words.
                     Though these parameters are still available in the full code,
                     more readable results are found more efficiently by simply taking the first
                     
                     <div class="quote e214">sentence</div>
                     of each text node.
                     This is the approach taken in the simplified code below.
                     
                  </div>
               </div>
               <div class="listitem e215">
                  <div class="para e216">
                     
                     <div class="emphasis e217" role="bold">Repetition count.</div>
                     How many times would we like to see each signature?
                     Since we may want to reduce a very large corpus to a still large sample,
                     it doesn't make sense to follow the silly pattern of the other parameters,
                     insisting that after 7 comes infinity.
                     One discovery, working with the tool,
                     is that the most effective way to get a bulkier sample
                     is to include higher values for the various context parameters.
                     This way, in addition to being simply bulkier,
                     the extra included elements will show more variety.
                     For this reason, the chosen default value is 1.
                     
                  </div>
               </div>
               <div class="listitem e218">
                  <div class="para e219">
                     
                     <div class="emphasis e220" role="bold">Show deletions.</div>
                     Should comments be left in the sample to indicate where elements have been pruned?
                     It can be helpful, when working with a smaller sample,
                     to have indication of where elements have been deleted from the larger source.
                     As implemented, the integer parameter is interpreted as a Boolean.
                     But it might make sense to interpret as a number:
                     showing some number of comments before stopping.
                     To avoid overwhelming results, the default value is 0 = no.
                     
                  </div>
               </div>
               <div class="listitem e221">
                  <div class="para e222">
                     
                     <div class="emphasis e223" role="bold">Debug signatures.</div>
                     Should the intermediate element signatures be shown in the final output?
                     Like with the parameters above and below,
                     it would make sense to interpret this value as a integer,
                     rather than as a Boolean.
                     The default value here is 0, meaning no
                     
                     <div class="code e224">tcs:signatures</div>
                     are shown.
                     
                  </div>
               </div>
               <div class="listitem e225">
                  <div class="para e226">
                     
                     <div class="emphasis e227" role="bold">Debug marks.</div>
                     Should the intermediate
                     
                     <div class="code e228">tcs:mark</div>
                     attributes be shown?
                     Again, this integer parameter might make better sense interpreted as a count,
                     rather than interpreted as a Boolean.
                     The
                     
                     <div class="code e229">tcs:mark</div>
                     attributes are added to all elements that are to be kept,
                     with the value indicating the reason.
                     Reasons include that the element had a unique signature
                     (or was within the specified repetition count),
                     that the element had a descendent that was to be kept,
                     that the element was known or guessed to be a required child of a kept element,
                     or that the element was an textual inline in the middle of kept text.
                     The default value is 0, meaning no intermediate
                     
                     <div class="code e230">tcs:mark</div>
                     attributes are shown.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e231">
            The following parameters have been designed, but not yet implemented:
            
            <div class="itemizedlist e232">
               <div class="listitem e233">
                  <div class="para e234">
                     
                     <div class="emphasis e235" role="bold">Collapse parallel structures.</div>
                     
                  </div>
               </div>
               <div class="listitem e236">
                  <div class="para e237">
                     
                     <div class="emphasis e238" role="bold">Target length.</div>
                     
                  </div>
               </div>
               <div class="listitem e239">
                  <div class="para e240">
                     
                     <div class="emphasis e241" role="bold">Schema information.</div>
                     
                  </div>
               </div>
               <div class="listitem e242">
                  <div class="para e243">
                     
                     <div class="emphasis e244" role="bold">Text abbreviation.</div>
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0ACode%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e245">
         <div class="title e246">
            Code
            
         </div>
         <div class="para e247">
            To illustrate the key concepts, a reference implementation is presented here.
            This version of the script is stripped of comments, parameters and efficiencies.
            Please contact the author for the current revision of the full script.
            
            <div class="programlisting e248" xml:space="preserve">
               &lt;?xml version='1.0' encoding='UTF-8'?&gt;
               &lt;!-- TCS = Tata Consultancy Services; tcs = trash compactor script. --&gt;
               &lt;!-- For brevity, this version is missing comments, parameters and efficiencies. --&gt;
               &lt;transform xmlns='http://www.w3.org/1999/XSL/Transform' version='2.0'
               xmlns:xs='http://www.w3.org/2001/XMLSchema'
               xmlns:tcs='mailto:charlie.hamu@tcs.com'&gt;
               &lt;template match='/'&gt;
               &lt;variable name='signed'&gt;
               &lt;apply-templates select='node()' mode='sign' /&gt;
               &lt;/variable&gt;
               &lt;variable name='marked'&gt;
               &lt;apply-templates select='$signed' mode='mark' /&gt;
               &lt;/variable&gt;
               &lt;variable name='wrapped'&gt;
               &lt;apply-templates select='$marked' mode='wrap' /&gt;
               &lt;/variable&gt;
               &lt;variable name='needed'&gt;
               &lt;apply-templates select='$wrapped' mode='need' /&gt;
               &lt;/variable&gt;
               &lt;variable name='needed-2'&gt;
               &lt;apply-templates select='$needed' mode='need' /&gt;
               &lt;/variable&gt;
               &lt;variable name='wanted'&gt;
               &lt;apply-templates select='$needed-2' mode='want' /&gt;
               &lt;/variable&gt;
               &lt;variable name='pruned'&gt;
               &lt;apply-templates select='$wanted' mode='prune' /&gt;
               &lt;/variable&gt;
               &lt;sequence select='$pruned' /&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='sign'&gt;
               &lt;copy&gt;
               &lt;attribute name='tcs:signature' select='ancestor::*/name(),
               preceding-sibling::*[1]/name(),
               name(),
               @*/name(),
               *[1]/name()' /&gt;
               &lt;copy-of select='@*' /&gt;
               &lt;apply-templates select='node()' mode='sign' /&gt;
               &lt;/copy&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='mark'&gt;
               &lt;copy&gt;
               &lt;if test='not(preceding::*[@tcs:signature = current()/@tcs:signature])'&gt;
               &lt;attribute name='tcs:mark' select='"keep"' /&gt;
               &lt;/if&gt;
               &lt;copy-of select='@*' /&gt;
               &lt;apply-templates select='node()' mode='mark' /&gt;
               &lt;/copy&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='wrap'&gt;
               &lt;copy&gt;
               &lt;if test='not(@tcs:mark) and *//@tcs:mark'&gt;
               &lt;attribute name='tcs:mark' select='"wrap"' /&gt;
               &lt;/if&gt;
               &lt;copy-of select='@*' /&gt;
               &lt;apply-templates select='node()' mode='wrap' /&gt;
               &lt;/copy&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='want'&gt;
               &lt;copy&gt;
               &lt;copy-of select='@*' /&gt;
               &lt;if test='not(@tcs:mark) and ../@tcs:mark
               and text()[normalize-space() ne ""]
               and ../text()[normalize-space() ne ""]'&gt;
               &lt;attribute name='tcs:mark' select='"want"' /&gt;
               &lt;/if&gt;
               &lt;apply-templates select='node()' mode='want' /&gt;
               &lt;/copy&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='need'&gt;
               &lt;copy&gt;
               &lt;if test='not(@tcs:mark)
               and ../@tcs:mark
               and not(preceding-sibling::*[name() eq current()/name()])
               and not(//*[name() eq current()/../name()
               and not(*[name() eq current()/name()])])'&gt;
               &lt;attribute name='tcs:mark' select='"need"' /&gt;
               &lt;/if&gt;
               &lt;copy-of select='@*' /&gt;
               &lt;apply-templates select='node()' mode='need' /&gt;
               &lt;/copy&gt;
               &lt;/template&gt;
               &lt;template match='*' mode='prune'&gt;
               &lt;if test='@tcs:mark'&gt;
               &lt;copy&gt;
               &lt;copy-of select='@* except @tcs:*' /&gt;
               &lt;apply-templates select='node()' mode='prune' /&gt;
               &lt;/copy&gt;
               &lt;/if&gt;
               &lt;/template&gt;
               &lt;template match='text()' mode='prune'&gt;
               &lt;value-of select='replace(.,"\.\s.+","...","s")' /&gt;
               &lt;/template&gt;
               &lt;template match='comment() | processing-instruction()' mode='#all'&gt;
               &lt;copy /&gt;
               &lt;/template&gt;
               &lt;/transform&gt;
            </div>
            
         </div>
      </div><a name="%0ADiscussion%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e249">
         <div class="title e250">
            Discussion
            
         </div>
         <div class="para e251">
            This paper was presented at Balisage 2012.
            
            <div class="citation e252" linkend="Balisage">[Balisage]</div>
            In the discussion after, the following points were raised by attendees.
            
            <div class="itemizedlist e253">
               <div class="listitem e254">
                  <div class="para e255">
                     
                     <div class="emphasis e256" role="bold">Pointers.</div>
                     It would be nice to link the samples, element-by-element, back to the full corpus,
                     so that you could see the full context if curious.
                     
                  </div>
               </div>
               <div class="listitem e257">
                  <div class="para e258">
                     
                     <div class="emphasis e259" role="bold">Randomize.</div>
                     Liam Quinn suggested that if you are taking a small sample from a larger set,
                     it would be nice to be be able to randomize the selection,
                     rather than just taking the first examples of each markup combination.
                     
                  </div>
               </div>
               <div class="listitem e260">
                  <div class="para e261">
                     
                     <div class="emphasis e262" role="bold">Log the seed.</div>
                     As a follow-on suggestion, Lee says to log the seed used for the random selection,
                     so that it can be recreated as required.
                     
                  </div>
               </div>
               <div class="listitem e263">
                  <div class="para e264">
                     
                     <div class="emphasis e265" role="bold">Redo from back.</div>
                     Wendell Piez observed that in order to avoid redundant elements,
                     in which for example, the first paragraph is included because we've never seen a paragraph
                     before,
                     but the second paragraph is included because it contains an inline,
                     we can run the algorithm twice: once front to back and then a second time back to
                     front.
                     
                  </div>
               </div>
               <div class="listitem e266">
                  <div class="para e267">
                     
                     <div class="emphasis e268" role="bold">XQuery.</div>
                     There seemed to be general consensus that multiple passes were the natural approach,
                     and that any attempt to collapse this into a single XPath expression or XQuery was
                     misguided.
                     
                  </div>
               </div>
               <div class="listitem e269">
                  <div class="para e270">
                     
                     <div class="emphasis e271" role="bold">Xmlsh.</div>
                     David Lee said the individual passes could be run together with xmlsh.
                     This would be especially relevant if the inefficient have-I-seen-this-before pass
                     were recast using another programming language.
                     
                  </div>
               </div>
               <div class="listitem e272">
                  <div class="para e273">
                     
                     <div class="emphasis e274" role="bold">Efficiency.</div>
                     Michael Sperberg-McQueen said that the
                     
                     <div class="emphasis e275" role="ital">n</div>
                     <div class="superscript e276">2</div>
                     inefficiency could be solved, even in XSLT 1.0, using keys and Muenchian method. 
                     <div class="citation e277" linkend="Tennison">[Tennison]</div>
                     
                  </div>
               </div>
               <div class="listitem e278">
                  <div class="para e279">
                     
                     <div class="emphasis e280" role="bold">Accummulators.</div>
                     Abel Braaksma said that XSLT 3.0 accumulators were designed to solve problems
                     just like the have-I-seen-this-before inefficiency, and took the example back to the
                     XSLT working group.
                     
                  </div>
                  <div class="para e281">
                     My initial intuition was to add the current element's signature to the accumulated
                     set
                     as the element starts. But this is too soon, as we need to know about all preceding
                     elements,
                     not including the one we're on. On the other had, updating the accumulator at the
                     end of the element
                     would be too late, as we would not have had its signature as we reviewed all of its
                     descendants.
                     The naive fix would be to somehow put the current element's signature
                     
                     <div class="quote e282">on deck</div>
                     so that it can be folded in to the accumulated list of all signatures
                     as soon we hit the start of the next element.
                     Rather than building this data structure ourselves,
                     the elegant choice seems to be to avoid the temptation
                     to add the
                     
                     <div class="emphasis e283" role="ital">current</div>
                     element's signature to the accumulated set,
                     but to rather add the
                     
                     <div class="emphasis e284" role="ital">immediately preceding</div>
                     element's signature to the accumulator.
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="%0AReferences%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e285">
         <div class="title e286">
            References
            
         </div>
         <div class="bibliomixed e287" xml:id="Balisage">
            
            <div class="emphasis e288" role="ital">Balisage: The Markup Conference,</div>
            2012 August 7-10, Hotel Europa, Montreal, Canada,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e289" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol8/contents.html" xlink:show="new" xlink:type="simple">http://balisage.net/Proceedings/vol8/contents.html</div>
            (accessed 2012 August 17).
            
         </div>
         <div class="bibliomixed e290" xml:id="Harold">
            Harold, Elliote Rusty.
            Paper:
            
            <div class="quote e291">Obsuring XML,</div>
            
            <div class="emphasis e292" role="ital">Proceedings of Extreme Markup Languages</div>
            2005 August 1-5, Montreal, Canada.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e293" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2005/Harold01/EML2005Harold01.html" xlink:show="new" xlink:type="simple">http://conferences.idealliance.org/extreme/html/2005/Harold01/EML2005Harold01.html</div>
            Presentation:
            
            <div class="quote e294">Randomizing XML,</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e295" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/slides/extreme/randomizer/" xlink:show="new" xlink:type="simple">http://cafeconleche.org/slides/extreme/randomizer</div>
            (accessed 2012 August 20).
            
         </div>
         <div class="bibliomixed e296" xml:id="Mad_Libs">
            Penguin Group (USA).
            
            <div class="quote e297">Mad Libs,</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e298" xlink:actuate="onRequest" xlink:href="http://www.madlibs.com/" xlink:show="new" xlink:type="simple">http://madlibs.com</div>
            (Accessed 2012 August 20).
            
         </div>
         <div class="bibliomixed e299" xml:id="QA-QC">
            
            <div class="emphasis e300" role="ital">International Symposium on Quality Assurance and Quality Control in XML,</div>
            2012 August 6, Hotel Europa, Montreal, Canada,
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e301" xlink:actuate="onRequest" xlink:href="http://balisage.net/QA-QC" xlink:show="new" xlink:type="simple">http://balisage.net/QA-QC</div>
            (accessed 2012 August 17).
            
         </div>
         <div class="bibliomixed e302" xml:id="Tennison">
            Tennison, Jeni.
            
            <div class="quote e303">Grouping using the Muenchian Method,</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e304" xlink:actuate="onRequest" xlink:href="http://jenitennison.com/xslt/grouping/muenchian.html" xlink:show="new" xlink:type="simple">http://jenitennison.com/xslt/grouping/muenchian.html</div>
            (accessed 2012 August 17).
            
         </div>
      </div>
   </div>
</div>