<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#ProgramminginXPath30ANCHOR" name="ProgramminginXPath30TOC">Programming in XPath 3.0</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#1IsXPath10afullprogramminglanguage?ANCHOR" name="1IsXPath10afullprogramminglanguage?TOC">1. Is XPath  1.0 a full programming language?</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#2%09IsXPath20afullprogramminglanguage?ANCHOR" name="2%09IsXPath20afullprogramminglanguage?TOC">2.	Is XPath  2.0 a full programming language?</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#3TheFunctionLibraryAuthor%E2%80%99sDilemmaANCHOR" name="3TheFunctionLibraryAuthor%E2%80%99sDilemmaTOC">3. The Function Library Author’s Dilemma</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#4NewcapabilitiesinXPath30ANCHOR" name="4NewcapabilitiesinXPath30TOC">4. New capabilities in XPath 3.0</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#41CreatingandusingananonymousfunctioninanXPath%0AexpressionHOFsANCHOR" name="41CreatingandusingananonymousfunctioninanXPath%0AexpressionHOFsTOC">4.1 Creating and using an anonymous function in an XPath
                     expression. HOFs.</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#42FunctioncompositionANCHOR" name="42FunctioncompositionTOC">4.2 Function composition</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#43PartialapplicationofafunctionANCHOR" name="43PartialapplicationofafunctionTOC">4.3 Partial application of a function</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#44ClosuresANCHOR" name="44ClosuresTOC">4.4 Closures</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#45CanAnonymousfunctionsbe%0Arecursive?ANCHOR" name="45CanAnonymousfunctionsbe%0Arecursive?TOC">4.5 Can Anonymous functions be
                     recursive?</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#46RobustRecursionANCHOR" name="46RobustRecursionTOC">4.6 Robust Recursion</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#47ProducinganewXMLdocumentor%0AelementANCHOR" name="47ProducinganewXMLdocumentor%0AelementTOC">4.7 Producing a new XML document or
                     element</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#5%09CompleteXPath30modulesandapplicationsANCHOR" name="5%09CompleteXPath30modulesandapplicationsTOC">5.	Complete XPath 3.0 modules and applications</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#6%09AnalysisANCHOR" name="6%09AnalysisTOC">6.	Analysis</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#7ConsuminganXPathfunctionlibraryfromXSLT30andXQuery31ANCHOR" name="7ConsuminganXPathfunctionlibraryfromXSLT30andXQuery31TOC">7. Consuming an XPath function library from XSLT 3.0 and XQuery 3.1</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgementANCHOR" name="AcknowledgementTOC">Acknowledgement</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Appendix:TheBSTdatatypedefinedandconsumedasamapANCHOR" name="Appendix:TheBSTdatatypedefinedandconsumedasamapTOC">Appendix: The BST data type defined and consumed as a map </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#References:ANCHOR" name="References:TOC">References:</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">argument placeholder</div>
         <div class="singletermTERMS">any</div>
         <div class="singletermTERMS">A simple function library</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bst1</div>
         <div class="singletermTERMS">bst2</div>
         <div class="singletermTERMS">Brief efficiency analysis</div>
         <div class="singletermTERMS">Binary Search Tree as defined by Wikipedia</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">current()</div>
         <div class="singletermTERMS">cast as</div>
         <div class="singletermTERMS">castable as</div>
         <div class="singletermTERMS">call site</div>
         <div class="singletermTERMS">callable units</div>
         <div class="singletermTERMS">computer science</div>
         <div class="singletermTERMS">create</div>
         <div class="singletermTERMS">Closure (computer science) -- Wikipedia</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Divide and conquer algorithm -- Wikipedia</div>
         <div class="singletermTERMS">DNovatchev@gmail.com</div>
         <div class="singletermTERMS">Dimitre</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">end date &lt;= 2012-05-15</div>
         <div class="singletermTERMS">Example</div>
         <div class="singletermTERMS">empty</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">f(x)</div>
         <div class="singletermTERMS">f(x) = h(g(x))</div>
         <div class="singletermTERMS">find-range-of-transactions</div>
         <div class="singletermTERMS">find-range-of-transactions-helper()</div>
         <div class="singletermTERMS">FunctX library by Priscilla Walmsley</div>
         <div class="singletermTERMS">Function composition -- Wikipedia</div>
         <div class="singletermTERMS">FunctX XSLT 2.0 and XQuery 1.0 Function Libraries</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">generate-id()</div>
         <div class="singletermTERMS">g(x)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">h(y)</div>
         <div class="singletermTERMS">Here is an example:</div>
         <div class="singletermTERMS">Higher-order function -- Wikipedia</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">instance of</div>
         <div class="singletermTERMS">increment()</div>
         <div class="singletermTERMS">itself</div>
         <div class="singletermTERMS">insert</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">let</div>
         <div class="singletermTERMS">Log2(N)</div>
         <div class="singletermTERMS">left</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">map</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">n!</div>
         <div class="singletermTERMS">nodeset</div>
         <div class="singletermTERMS">No way!</div>
         <div class="singletermTERMS">Novatchev</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">O(log2N)</div>
         <div class="singletermTERMS">own</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">partial application</div>
         <div class="singletermTERMS">Partial function application</div>
         <div class="singletermTERMS">Problem</div>
         <div class="singletermTERMS">print</div>
         <div class="singletermTERMS">populate</div>
         <div class="singletermTERMS">Pearls of XSLT and XPath 3.0 Design</div>
         <div class="singletermTERMS">Partial function application -- Wikipedia</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">return</div>
         <div class="singletermTERMS">returned</div>
         <div class="singletermTERMS">range/outer-context variables</div>
         <div class="singletermTERMS">Return a sequence of the following nodes</div>
         <div class="singletermTERMS">Recommendation</div>
         <div class="singletermTERMS">root</div>
         <div class="singletermTERMS">right</div>
         <div class="singletermTERMS">Recommendation for a future XPath version</div>
         <div class="singletermTERMS">Recursion (computer science) -- Wikipedia</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">seq1</div>
         <div class="singletermTERMS">seq2</div>
         <div class="singletermTERMS">start date &gt;= 2012-03-15</div>
         <div class="singletermTERMS">subroutine</div>
         <div class="singletermTERMS">sequences</div>
         <div class="singletermTERMS">sequences of items</div>
         <div class="singletermTERMS">Stack Overflow</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">tail recursion</div>
         <div class="singletermTERMS">tail call</div>
         <div class="singletermTERMS">tail position</div>
         <div class="singletermTERMS">tail-recursive</div>
         <div class="singletermTERMS">The result is:</div>
         <div class="singletermTERMS">The BST XPath code</div>
         <div class="singletermTERMS">The BST XPath code -- as an XQuery module</div>
         <div class="singletermTERMS">The Saxon XSLT/XQuery/XPath Processor</div>
         <div class="singletermTERMS">Tail call -- Wikipedia</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">use the DVC (Divide and Conquer) technique</div>
         <div class="singletermTERMS">unparsed-text()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">variables</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xs:integer</div>
         <div class="singletermTERMS">XSLT/XQuery or XPath?</div>
         <div class="singletermTERMS">XQuery and XPath Data Model 3.0</div>
         <div class="singletermTERMS">XML Path Language (XPath) Version 1.0</div>
         <div class="singletermTERMS">XML Path Language (XPath) 2.0 (Second Edition)</div>
         <div class="singletermTERMS">XML Path Language (XPath) 3.0</div>
         <div class="singletermTERMS">XSL Transformations (XSLT) Version 1.0</div>
         <div class="singletermTERMS">XSL Transformations (XSLT) Version 2.0</div>
         <div class="singletermTERMS">XSL Transformations (XSLT) Version 3.0</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="ProgramminginXPath30ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Programming in XPath 3.0</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2013</div>
            <div class="confdates e5">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">While XPath is universally considered the critical intersection of XSLT and
               XQuery, until recently it lacked some essential capabilities of a full-pledged
               programming language. 
            </div>
            <div class="para e8">Although not obvious from the W3C specifications, this paper demonstrates some of
               the new, crucial features of XPath 3.0 that make it a truly complete, standalone,
               modern XML programming language. 
            </div>
            <div class="para e9">
               Among others, the benefits of host-language-independent XPath 3.0 programming include
               
               the elimination of the need for redundant “per host language” programming and the
               ability 
               to specify XPath callable units with true copy and paste portability between different
               
               host languages, such as XSLT and XQuery.
               
            </div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Dimitre</div>
               <div class="surname e13">Novatchev</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">
                  									Dimitre Novatchev developed FXSL – the functional programming library
                  									for XSLT (1.0 and 2.0). He thrives at discovering and employing
                  									unexpected capabilities of XSLT and XPath that even their W3C creators
                  									hadn’t imagined.
                  									
               </div>
               <div class="para e16">
                  									Suggested the argument placeholder feature that is now part of XPath 3.0.
                  									
               </div>
               <div class="para e17">
                  									Member in the W3C XSLT working group in 2011 – 2013, where he contributed
                  									to the design and specification of XSLT 3.0.
                  									
               </div>
               <div class="para e18">
                  									Dimitre has answered around 5000 XSLT/XML/XPath questions on StackOverflow
                  									and many questions on the XSL-List.
                  									
               </div>
            </div>
            <div class="email e19">DNovatchev@gmail.com</div>
            <div class="affiliation e20">
               <div class="orgname e21">IMS Health / Appature</div>
            </div>
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e22" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://dnovatchev.wordpress.com</div>
         </div>
         <div class="legalnotice e23">
            <div class="para e24">Copyright © 2013 Dimitre Novatchev</div>
         </div>
      </div><a name="1IsXPath10afullprogramminglanguage?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e25">
         <div class="title e26">1. Is XPath  1.0 a full programming language?</div>
         <div class="para e27"> Does XPath 1.0[
            <div class="citation e28" linkend="XPath1.0"></div>]  have all necessary features to be
            used as a complete, self-sustained programming language? 
         </div>
         <div class="para e29">
            The facts summarized in this table show that XPath 1.0  lacks many important features
            
            of a programming language.
            
         </div>
         <div class="table e30">
            <div class="thead e31">
               <div class="tr e32">
                  <div class="th e33">Capability</div>
                  <div class="th e34">Presence</div>
                  <div class="th e35">Remarks</div>
               </div>
            </div>
            <div class="tbody e36">
               <div class="tr e37">
                  <div class="td e38">Define 
                     <div class="emphasis e39">variables</div>
                  </div>
                  <div class="td e40">No.</div>
                  <div class="td e41">Variables references can be part of XPath 1.0  expressions, 
                     but such variables must be defined by the host language 
                     (various PLs, DOM, or XSLT[
                     <div class="citation e42" linkend="XSLT1.0"></div>]).
                     
                  </div>
               </div>
               <div class="tr e43">
                  <div class="td e44">Define and use 
                     <div class="emphasis e45">range/outer-context variables</div>.
                  </div>
                  <div class="td e46">No.</div>
                  <div class="td e47">In an XSLT context the function 
                     <div class="code e48">current()</div> provides a limited capability 
                     of an outer-context variable.
                     
                  </div>
               </div>
               <div class="tr e49">
                  <div class="td e50">Define its 
                     <div class="emphasis e51">own</div> functions.
                  </div>
                  <div class="td e52">No.</div>
                  <div class="td e53">Only XPath system functions or functions defined in the host-provided context 
                     (such as 
                     <div class="code e54">generate-id()</div> ) can be referenced.
                     
                  </div>
               </div>
               <div class="tr e55">
                  <div class="td e56">Work with 
                     <div class="emphasis e57">sequences</div> of items.
                  </div>
                  <div class="td e58">No.</div>
                  <div class="td e59">Only the notion of a 
                     <div class="emphasis e60">nodeset</div> is defined. No support 
                     for sequences containing a non-node, or of nodes that can occur 
                     more than once and/or in any order.
                     
                  </div>
               </div>
               <div class="tr e61">
                  <div class="td e62">Define own 
                     <div class="emphasis e63">callable units</div>.
                  </div>
                  <div class="td e64">No.</div>
                  <div class="td e65"> </div>
               </div>
               <div class="tr e66">
                  <div class="td e67">Specify that a function should be executed on every selected node.</div>
                  <div class="td e68">No.</div>
                  <div class="td e69"> </div>
               </div>
               <div class="tr e70">
                  <div class="td e71">Strong typing.</div>
                  <div class="td e72">No.</div>
                  <div class="td e73">XPath 1.0 is a weakly-typed language.</div>
               </div>
            </div>
         </div>
         <div class="para e74"></div>
      </div><a name="2%09IsXPath20afullprogramminglanguage?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e75">
         <div class="title e76">2.	Is XPath  2.0 a full programming language?</div>
         <div class="para e77"> Does XPath 2.0[
            <div class="citation e78" linkend="XPath2.0"></div>] have all necessary features to be used as a complete,
            self-sustained programming language? 
         </div>
         <div class="para e79">
            The facts summarized in this table show that XPath 2.0, while having strong typing,
            
            the capability to define its own variables and operations on sequences, 
            still lacks some important features of a programming language, 
            such as its own callable units of execution.
            
         </div>
         <div class="table e80">
            <div class="thead e81">
               <div class="tr e82">
                  <div class="th e83">Capability</div>
                  <div class="th e84">Presence</div>
                  <div class="th e85">Remarks</div>
               </div>
            </div>
            <div class="tbody e86">
               <div class="tr e87">
                  <div class="td e88">Define 
                     <div class="emphasis e89">variables</div>.
                  </div>
                  <div class="td e90">Yes, but limited.</div>
                  <div class="td e91">Variables can be defined within an XPath 2.0 expression. 
                     It is impossible to define a variable whose value is a sequence.
                  </div>
               </div>
               <div class="tr e92">
                  <div class="td e93">Define and use 
                     <div class="emphasis e94">range/outer-context variables</div>.
                  </div>
                  <div class="td e95">Yes.</div>
                  <div class="td e96"> </div>
               </div>
               <div class="tr e97">
                  <div class="td e98">Define its 
                     <div class="emphasis e99">own</div> functions.
                  </div>
                  <div class="td e100">No.</div>
                  <div class="td e101">Only XPath system functions or functions defined in the host-provided context 
                     (such as functions defined in XSLT[
                     <div class="citation e102" linkend="XSLT2.0"></div>] or in XQuery[
                     <div class="citation e103" linkend="XQuery1.0"></div>]) can be referenced.
                  </div>
               </div>
               <div class="tr e104">
                  <div class="td e105">Work with 
                     <div class="emphasis e106">sequences</div> of items.
                  </div>
                  <div class="td e107">Yes.</div>
                  <div class="td e108">XPath 2.0 supports sequences whose items can be non-nodes, 
                     or  nodes that can occur more than once and/or in any order.
                  </div>
               </div>
               <div class="tr e109">
                  <div class="td e110">Define own 
                     <div class="emphasis e111">callable units</div>.
                  </div>
                  <div class="td e112">No.</div>
                  <div class="td e113"> </div>
               </div>
               <div class="tr e114">
                  <div class="td e115">Specify that a function should be executed on every selected node.</div>
                  <div class="td e116">Yes.</div>
                  <div class="td e117">
                     <div class="code e118">/a/b/c/string-length()</div>    is legal
                  </div>
               </div>
               <div class="tr e119">
                  <div class="td e120">Specify that a function should be executed on every item in a sequence.</div>
                  <div class="td e121">No.</div>
                  <div class="td e122">While 
                     <div class="code e123">/a/b/c/string-length()</div> is legal, it isn’t allowed to use: 
                     
                     <div class="code e124">('London', 'New York', 'Paris')/string-length()</div>
                     
                  </div>
               </div>
               <div class="tr e125">
                  <div class="td e126">Strong typing.</div>
                  <div class="td e127">Yes.</div>
                  <div class="td e128">XSD type constructors, 
                     <div class="code e129">cast as</div>,  
                     <div class="code e130">castable as</div>,  
                     <div class="code e131">instance of</div>
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="para e132"></div>
      </div><a name="3TheFunctionLibraryAuthor%E2%80%99sDilemmaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e133">
         <div class="title e134">3. The Function Library Author’s Dilemma</div>
         <div class="para e135"> There are examples of useful function libraries that have a separate version for
            XSLT2.0[
            <div class="citation e136" linkend="XSLT2.0"></div>] and a separate version for XQuery[
            <div class="citation e137" linkend="XQuery1.0"></div>]. There are other function libraries, written only for use in
            one of these two languages. A real-world example of a function library with both XSLT
            and XQuery versions is the 
            <div class="emphasis e138">FunctX library
               by Priscilla Walmsley
            </div>[
            <div class="citation e139" linkend="Walmsley"></div>]. 
         </div>
         <div class="para e140">
            While a function library author has the goal to produce his library for the widest
            possible audience, 
            writing one separate version of the library for XSLT 
            and another separate version for XQuery is problematic:
            
         </div>
         <div class="itemizedlist e141">
            <div class="listitem e142">
               <div class="para e143">
                  The time required to produce two versions of the library – for use from two different
                  languages, 
                  may be significantly (up to twice) bigger than the time for producing a single version.
                  
               </div>
            </div>
            <div class="listitem e144">
               <div class="para e145">
                  If the time necessary to produce two different versions of the library 
                  could be used for producing only one version, then more functions 
                  could be written and included in this library.
                  
               </div>
            </div>
            <div class="listitem e146">
               <div class="para e147">
                  Having two versions for the same set of functions is redundant 
                  and results in all anomalies of redundancy.
                  
               </div>
            </div>
            <div class="listitem e148">
               <div class="para e149">
                  Maintaining two different versions of the same set of functions 
                  is challenging – it is difficult to maintain the two versions in synch, 
                  and the required time to do so is significantly greater than maintaining a single
                  library.
                  
               </div>
            </div>
         </div>
         <div class="para e150">
            Due to these problems, some libraries would only have one single version. The libraries
            that have two versions
            could have included more useful functions, or could have become available sooner,
            if they had been written in a single version only.
            
         </div>
         <div class="para e151">
            “Copy and paste portability” has never been achieved with XPath 2.0 to the extent
            to be really useful, 
            because the language lacks the ability to define its own callable units 
            and because it cannot define its own variables that contain a sequence, and it isn’t
            possible to produce 
            a new XML document / node by an XPath 2.0 expression.
            
         </div>
         <div class="para e152"></div>
      </div><a name="4NewcapabilitiesinXPath30ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e153">
         <div class="title e154">4. New capabilities in XPath 3.0</div>
         <div class="para e155">
            The next table shows some of the significant new features of XPath 3.0[
            <div class="citation e156" linkend="XPath3.0"></div>]:
            
         </div>
         <div class="table e157">
            <div class="thead e158">
               <div class="tr e159">
                  <div class="th e160">Capability</div>
                  <div class="th e161">Presence</div>
                  <div class="th e162">Remarks</div>
               </div>
            </div>
            <div class="tbody e163">
               <div class="tr e164">
                  <div class="td e165">Define 
                     <div class="emphasis e166">variables</div>
                  </div>
                  <div class="td e167">Yes.</div>
                  <div class="td e168">In addition to the variable definition available in XPath 2.0, 
                     XPath 3.0 makes it possible to define in a “let clause” 
                     a variable whose value is a sequence.
                     
                  </div>
               </div>
               <div class="tr e169">
                  <div class="td e170">Define and use 
                     <div class="emphasis e171">range/outer-context variables</div>.
                  </div>
                  <div class="td e172">Yes.</div>
                  <div class="td e173">As in XPath 2.0.</div>
               </div>
               <div class="tr e174">
                  <div class="td e175">Work with 
                     <div class="emphasis e176">sequences of items</div>.
                  </div>
                  <div class="td e177">Yes.</div>
                  <div class="td e178">As in XPath 2.0.</div>
               </div>
               <div class="tr e179">
                  <div class="td e180">Define own 
                     <div class="emphasis e181">callable units</div>.
                  </div>
                  <div class="td e182">Yes.</div>
                  <div class="td e183">Inline function items.</div>
               </div>
               <div class="tr e184">
                  <div class="td e185">Specify that a function should be executed on every selected node.</div>
                  <div class="td e186">Yes.</div>
                  <div class="td e187">As in XPath 2.0.</div>
               </div>
               <div class="tr e188">
                  <div class="td e189">Specify that a function should be executed on every item in a sequence.</div>
                  <div class="td e190">Yes.</div>
                  <div class="td e191">The   
                     <div class="code e192">!</div>   (simple mapping) operator.
                  </div>
               </div>
               <div class="tr e193">
                  <div class="td e194">Strong typing.</div>
                  <div class="td e195">Yes.</div>
                  <div class="td e196">As in XPath 2.0.</div>
               </div>
               <div class="tr e197">
                  <div class="td e198">Define its 
                     <div class="emphasis e199">own</div> functions.
                  </div>
                  <div class="td e200">Yes.</div>
                  <div class="td e201">This is one of the most significant new features of XPath 3.0, 
                     based on the “function item” type as defined in the XDM[
                     <div class="citation e202" linkend="XDM3.0"></div>].  
                     Only “inline function items” (anonymous functions) can be defined. 
                     Typically, these are defined as the content of a variable, 
                     which then can be used as a function.
                     
                  </div>
               </div>
               <div class="tr e203">
                  <div class="td e204">Higher Order Functions (HOFs).</div>
                  <div class="td e205">Yes.</div>
                  <div class="td e206">A function item is a first class object. It can be passed as a parameter 
                     or returned as a result of calling a function. It is possible to express 
                     such well-known FP techniques as functional composition, partial function application,
                     
                     creation of closures.
                     
                  </div>
               </div>
               <div class="tr e207">
                  <div class="td e208">Can recursive anonymous functions be specified within an XPath expression?</div>
                  <div class="td e209">Yes.</div>
                  <div class="td e210">Shown later in this paper.</div>
               </div>
               <div class="tr e211">
                  <div class="td e212">Can robust recursion of anonymous functions be implemented?</div>
                  <div class="td e213">Yes.</div>
                  <div class="td e214">Shown later in this paper.</div>
               </div>
               <div class="tr e215">
                  <div class="td e216">Can a new XML document or node be created within an XPath expression?</div>
                  <div class="td e217">Yes.</div>
                  <div class="td e218">Shown later in this paper.</div>
               </div>
               <div class="tr e219">
                  <div class="td e220">Can new data types be created in an XPath expression?</div>
                  <div class="td e221">Yes.</div>
                  <div class="td e222">Shown later in this paper.</div>
               </div>
            </div>
         </div>
         <div class="para e223">
            In the next sections we give examples of using XPath 3.0 to specify functional composition,
            
            partial application, closures, anonymous function recursion and robust recursion.
            
            Then we provide an example of specifying a new data type – the Binary Search Tree.
            
            We show how a new XML document can be created with an XPath 3.0 expression. 
            Finally, we provide an example of a complete XML processing application written entirely
            in XPath.
            
         </div>
         <div class="para e224"></div><a name="41CreatingandusingananonymousfunctioninanXPath%0AexpressionHOFsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e225">
            <div class="title e226">4.1 Creating and using an anonymous function in an XPath
               expression. HOFs.
            </div>
            <div class="para e227"> In XPath 3.0 one can define inline (anonymous) functions and then provide
               arguments for their execution in a function call simply like this:
               
               <div class="programlisting e228" xml:space="preserve">
                  let $incr := 
                  function($n) {$n+1}
                  
                  return $incr(2)
                  
               </div>
               Or, as recommended alternative, define the same function in a strongly typed way:
               
               <div class="programlisting e229" xml:space="preserve">
                  let $incr :=
                  function($n as xs:integer) as xs:integer
                  {
                  $n +1
                  }
                  return
                  $incr(2)
                  
               </div>
               When either of these two expressions is evaluated, the result is: 
               <div class="code e230">3</div>. 
            </div>
            <div class="para e231">
               
               <div class="emphasis e232" role="bold">The remaining examples in this paper use strong
                  typing
               </div>. 
            </div>
            <div class="para e233"> The ability to define a function as a pure XPath 3.0 expression is one of the
               most important additions to the XPath Data Model (XDM)[
               <div class="citation e234" linkend="XDM3.0"></div>].
            </div>
            <div class="para e235">The function has no name and is the value of the 
               <div class="code e236">$incr</div> variable. The
               function definition has a strongly typed argument and a strongly typed result – in
               this case both the argument and the result must be of type 
               <div class="code e237">xs:integer</div>.  
            </div>
            <div class="para e238">The body of the function is an XPath expression of type
               
               <div class="code e239">xs:integer</div>
            </div>
            <div class="para e240">The scope of the function is the let clause where it is defined and the
               corresponding 
               <div class="code e241">return</div> clause. 
            </div>
            <div class="para e242">Most importantly, in XPath 3.0 one can define Higher-Order Functions (HOFs)[
               <div class="citation e243" linkend="HOF"></div>].
               By definition, a higher order function has an argument which itself is a function,
               or produces a function as its result.  
            </div>
            <div class="para e244"> Here is a complete example of defining and calling a HOF within an XPath
               expression: 
            </div>
            <div class="programlisting e245" xml:space="preserve">
               let $process :=
               function($s as xs:string, $fun as function(xs:string) as xs:string)
               as xs:string
               {
               $fun($s)
               },
               
               $lower :=
               function($s as xs:string) as xs:string
               {
               lower-case($s)
               }
               ,
               $reverse :=
               function($s as xs:string) as xs:string
               {
               codepoints-to-string(reverse(string-to-codepoints($s)))
               }
               return
               ('lower: ', $process('HELLO', $lower),
               ', reverse: ', $process('HELLO', $reverse))
               
            </div>
            <div class="para e246"> The function 
               <div class="code e247">$process()</div>takes two arguments: a string, and a function
               that takes a string and produces a string. The result returned by
               
               <div class="code e248">$process()</div>is a string. 
            </div>
            <div class="para e249"> Then, in the same 
               <div class="code e250">let</div> clause two functions are defined, each taking
               a string and producing a string: 
               <div class="code e251">$lower()</div> and 
               <div class="code e252">$reverse()</div>. 
            </div>
            <div class="para e253"> In the return clause 
               <div class="code e254">$process()</div> is called twice, with “HELLO” as the
               same first argument, and with the 
               <div class="code e255">$lower()</div> function as the second
               argument in the first call to 
               <div class="code e256">$process()</div> and 
               <div class="code e257">$reverse()</div>
               function as the second argument in the second call to 
               <div class="code e258">$process()</div>. 
            </div>
            <div class="para e259"> When the above expression is evaluated, the result is:
               
               <div class="programlisting e260" xml:space="preserve">lower:  hello , reverse:  OLLEH</div>
            </div>
         </div><a name="42FunctioncompositionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e261">
            <div class="title e262">4.2 Function composition</div>
            <div class="para e263">
               By definition, the functional composition[
               <div class="citation e264" linkend="FuncComp"></div>] of two functions 
               <div class="code e265">g(x)</div> and 
               <div class="code e266">h(y)</div>
               is a third function   
               <div class="code e267">f(x)</div>  such that   
               <div class="code e268">f(x) = h(g(x))</div>
               
            </div>
            <div class="para e269">
               We can specify a function, which takes as its parameters two other functions, 
               and produces as its result the functional composition of its two arguments:
               
               <div class="programlisting e270" xml:space="preserve">
                  $compose :=
                  function($f as function(), $g as function())
                  as function()
                  {
                  function($x as item()*)
                  {
                  $g($f($x))
                  }
                  }
                  
               </div>
               
            </div>
            <div class="para e271">
               And we can use the so defined function in the following expression:
               
               <div class="programlisting e272" xml:space="preserve">
                  let $compose :=
                  function($f as function(), $g as function())
                  as function()
                  {
                  function($x as item()*)
                  {
                  $g($f($x))
                  }
                  },
                  
                  $lower :=
                  function($s as xs:string) as xs:string
                  {
                  lower-case($s)
                  }
                  ,
                  
                  $reverse :=
                  function($s as xs:string) as xs:string
                  {
                  codepoints-to-string(reverse(string-to-codepoints($s)))
                  }
                  
                  return
                  $compose($reverse, $lower)('HELLO')
                  
               </div>
               
            </div>
            <div class="para e273">
               The result of evaluating this expression is:
               
               <div class="programlisting e274" xml:space="preserve">olleh</div>
               
            </div>
         </div><a name="43PartialapplicationofafunctionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e275">
            <div class="title e276">4.3 Partial application of a function</div>
            <div class="para e277">
               One definition of 
               <div class="emphasis e278" role="bital">partial application</div>[
               <div class="citation e279" linkend="PartApp"></div>] is the following:
            </div>
            <div class="popupBox e280">
               <div class="popupLabel" onmouseover="$('#d1e546').show('1000');" onmouseout="$('#d1e546').hide('1000');">[ blockquote ]</div>
               <div id="d1e546" style="display: none;">
                  <div class="blockquote">
                     <div class="para e281">
                        <div class="emphasis e282">“
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e283" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Partial_application" xlink:show="new" xlink:type="simple">
                              <div class="emphasis e284" role="bold">Partial function application</div>
                           </div> is the ability to take a function of many parameters 
                           and apply arguments to some of the parameters to create a new function that 
                           needs only the application of the remaining arguments to produce the equivalent 
                           of applying all arguments to the original function.”
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e285">
               XPath 3.0 has a natural way of specifying partial application.
               
               <div class="programlisting e286" xml:space="preserve">f(3, ?)</div> 
               is a new function 
               <div class="code e287">g(x)</div>, such that for all allowed values of 
               <div class="code e288">x</div> 
               the following holds:
               
               <div class="programlisting e289" xml:space="preserve">g(x) = f(3, x)</div>
               
            </div>
            <div class="para e290"> Using partial application, we can re-define the 
               <div class="code e291">increment()</div> function
               in the following way:
               
               <div class="programlisting e292" xml:space="preserve">
                  let $plus :=
                  function($m as xs:integer, $n as xs:integer) as xs:integer
                  {
                  $m + $n
                  },
                  
                  $incr :=
                  function($n as xs:integer) as xs:integer
                  {
                  $plus(1, ?)($n)
                  }
                  return 
                  $incr(2)
                  
               </div>
               When this XPath 3.0 expression is evaluated, the result is 
               <div class="code e293">3</div>. 
               
            </div>
            <div class="para e294"> In the above expression the partial application of 
               <div class="code e295">$plus()</div> on
               binding its first argument to 
               <div class="code e296">1</div> is defined simply as:
               
               <div class="programlisting e297" xml:space="preserve">$plus(1, ?) </div> 
               The ‘
               <div class="code e298">?</div>’ character is
               called 
               <div class="emphasis e299">argument placeholder</div> and is used to denote
               free (still not bound) arguments. 
            </div>
         </div><a name="44ClosuresANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e300">
            <div class="title e301">4.4 Closures</div>
            <div class="para e302">By definition “
               <div class="emphasis e303">a closure[
                  <div class="citation e304" linkend="Closure"></div>] is a function produced by
                  another function and the produced function contains data from the producing
                  function
               </div>.” 
               
            </div>
            <div class="para e305"> Here is a complete example:
               
               <div class="programlisting e306" xml:space="preserve">
                  let $greet :=
                  function($greeting as xs:string)
                  as function(xs:string) as xs:string
                  {
                  function($name as xs:string) as xs:string
                  {
                  $greeting || $name || '! '
                  }
                  },
                  $hello := $greet('Hello: ')
                  
                  return
                  ($hello ('John'), $hello ('Peter') )
                  
               </div>
               Note that the outer function 
               <div class="code e307">&nbsp;$greet()</div> returns as its result the inner
               function and injects into the body of the inner function some of its own (outer
               function’s) data –&nbsp; the value of its 
               <div class="code e308">&nbsp;$greeting</div> &nbsp;argument. 
               
            </div>
            <div class="para e309"> When the above expression is evaluated, the result is:
               
               <div class="programlisting e310" xml:space="preserve">Hello: John! Hello: Peter! </div>
               
            </div>
            <div class="para e311"> Here is another example. Let’s have this XML document: 
               <div class="programlisting e312" xml:space="preserve">                    
                  &lt;Books&gt;
                  	&lt;Book&gt;
                  		&lt;Title&gt;Six Great Ideas&lt;/Title&gt;
                  		&lt;Author&gt;Mortimer J. Adler&lt;/Author&gt;
                  	&lt;/Book&gt;
                  	&lt;Book&gt;
                  		&lt;Title&gt;The Society of Mind&lt;/Title&gt;
                  		&lt;Author&gt;Marvin Minsky&lt;/Author&gt;
                  	&lt;/Book&gt;
                  &lt;/Books&gt;
                  
               </div>
               
            </div>
            <div class="para e313"> We want to have a function that has only one argument – a book’s title and
               returns the author of the book with this title. Somehow this function should have
               the above XML document already injected in its definition:
               
               <div class="programlisting e314" xml:space="preserve">
                  let $lookup :=
                  function($books as element())
                  as function(xs:string) as xs:string?
                  {
                  function($bookTitle as xs:string) as xs:string?
                  {
                  $books/Book[Title eq $bookTitle]/Author
                  }
                  },
                  
                  $author := $lookup(/Books)
                  
                  return
                  $author('The Society of Mind')
                  
               </div>
               The wanted function (
               <div class="code e315">$author()</div>) is created by the function
               
               <div class="code e316">$lookup()</div> by injecting into it some of its own content – the top
               element of the XML document to be searched. The result is:
               
               <div class="programlisting e317" xml:space="preserve">Marvin Minsky</div>
               
            </div>
         </div><a name="45CanAnonymousfunctionsbe%0Arecursive?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e318">
            <div class="title e319">4.5 Can Anonymous functions be
               recursive?
            </div>
            <div class="para e320"> Such a question seems odd – if a recursive function[
               <div class="citation e321" linkend="Recurs"></div>] is one that calls itself by
               name, then how can an anonymous function be recursive, having no name? 
            </div>
            <div class="para e322"> This seems to be a stopping problem when trying to write XPath 3.0 inline
               function items that process long sequences or other, recursive data structures. So
               serious a problem, that some people[
               <div class="citation e323" linkend="Snelson"></div>][
               <div class="citation e324" linkend="Snelson2"></div>] even raised the question of amending
               the XPath Data Model and altering the XPath 3.0 syntax in order to allow an
               anonymous function to call itself. 
            </div>
            <div class="para e325">
               <div class="emphasis e326" role="bold">As it turns out, a natural solution exists, without the
                  need to change anything[
                  <div class="citation e327" linkend="Nova"></div>]
               </div>. 
            </div>
            <div class="para e328"> Let us take a concrete problem: Write an XPath 3.0 inline function, that given a
               positive integer 
               <div class="code e329">n</div>, produces the value of 
               <div class="code e330">n!</div> (The
               factorial of 
               <div class="code e331">n</div>). 
               
            </div>
            <div class="para e332"> As a first attempt, let us analyze this code:
               
               <div class="programlisting e333" xml:space="preserve">          let $f := function($n as xs:integer,
                  $f1 as function(xs:integer) as xs:integer
                  ) as xs:integer
                  
                  {
                  if($n eq 0)
                  then 1
                  else $n * $f1($n -1, $f1)
                  }
                  return
                  $f(5, $f)             
                  
               </div>
               What happens here?
               
            </div>
            <div class="para e334">
               An inline function cannot call itself by name, because it doesn’t have a name.
               What we still can do, though, is to pass the function as an argument to itself.
               
            </div>
            <div class="para e335"> The only special thing to notice here is how the processing is initiated:
               
               <div class="programlisting e336" xml:space="preserve">$f(5, $f)</div> calling the function and passing it to
               itself. 
               
            </div>
            <div class="para e337"> Such initiation may seem weird to a caller and is also error-prone. This is why
               we need to further improve the solution so that no weirdness remains on the surface:
               
               <div class="programlisting e338" xml:space="preserve">let $f := function($n as xs:integer,
                  $f1 as function(xs:integer,
                  function()) as xs:integer
                  ) as xs:integer
                  {
                  if($n eq 0)
                  then 1
                  else $n * $f1($n -1, $f1)
                  
                  },
                  
                  $F := function($n as xs:integer) as xs:integer
                  {
                  $f($n, $f)
                  }
                  return
                  $F(5)
               </div>
               Thus we produced an inline, anonymous function 
               <div class="code e339">$F</div>, which given an
               argument 
               <div class="code e340">$n</div>, produces
               <div class="code e341"> $n!</div>
               
            </div>
         </div><a name="46RobustRecursionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e342">
            <div class="title e343">4.6 Robust Recursion</div>
            <div class="para e344"> While the described recursion technique works well with relatively small values
               for
               <div class="code e345"> n</div>, we run into problems when 
               <div class="code e346">n</div> becomes bigger. 
            </div>
            <div class="para e347">
               
               <div class="emphasis e348" role="bold">Let’s see this based on another example – calculating the sum
                  of a sequence of numbers:
               </div>
               
               <div class="programlisting e349" xml:space="preserve">  let $f := function($nums as xs:double*,
                  $f1 as  function(xs:double*, function()) 
                  as xs:double
                  ) as xs:double
                  {
                  if(not($nums[1]))
                  then 0
                  else $nums[1] + $f1(subsequence($nums,2), $f1)
                  },
                  
                  $F := function($nums as xs:double*) as xs:double
                  {
                  $f($nums, $f)
                  }
                  return
                  $F(1 to 10)
               </div>
               This calculates correctly the sum of the numbers 
               <div class="code e350">1</div> to 
               <div class="code e351">10</div> –
               the result is: 
               <div class="programlisting e352" xml:space="preserve">55</div> However, if we try:
               
               <div class="programlisting e353" xml:space="preserve">$F(1 to 100)</div>
               the result is the following Saxon 9.4.6EE exception:
               
               <div class="programlisting e354" xml:space="preserve">
                  <div class="emphasis e355" role="bold">Error on line 22
                     Too many nested function calls. May be due to infinite recursion.
                     Transformation failed: Run-time errors were reported
                  </div>
               </div>
               
            </div>
            <div class="para e356"> So, what happens here? Most readers would have guessed by now — our old 
               <div class="emphasis e357">Stack Overflow</div> (not the site) exception. 
            </div>
            <div class="para e358"> Is there 
               <div class="emphasis e359">any</div> way to avoid this exception? 
            </div>
            <div class="para e360"> One could rely on the smartness of the XSLT processor to do this. A slight
               fraction of XSLT processors recognize a limited kind of 
               <div class="emphasis e361">tail
                  recursion
               </div> and implement it using iteration, thus avoiding recursion. 
               
            </div>
            <div class="para e362">
               
               <div class="emphasis e363" role="bold">Let us refactor the above code into a tail-recursive
                  one
               </div> (the last thing the function does is invoke a function):
               
               <div class="programlisting e364" xml:space="preserve"> let $f := function($nums as xs:double*,
                  $accum as xs:double,
                  $f1 as  
                  function(xs:double*, xs:double, function())
                  as xs:double
                  ) as xs:double
                  {
                  if(not($nums[1]))
                  then $accum
                  else $f1(subsequence($nums,2), $accum+$nums[1], $f1)
                  },
                  $F := function($nums as xs:double*) as xs:double
                  {
                  $f($nums, 0, $f)
                  }
                  return
                  $F(1 to 100)
               </div>
               
            </div>
            <div class="para e365">
               Saxon[Saxon] is well-known for carrying out tail-recursion optimization, 
               however it still raises the stack-overflow exception for the above, tail-recursive
               code. 
               Why?
               
            </div>
            <div class="para e366"> Here is the Wikipedia definition[
               <div class="citation e367" linkend="TailCall"></div>] of tail recursion: 
            </div>
            <div class="popupBox e368">
               <div class="popupLabel" onmouseover="$('#d1e762').show('1000');" onmouseout="$('#d1e762').hide('1000');">[ blockquote ]</div>
               <div id="d1e762" style="display: none;">
                  <div class="blockquote">
                     <div class="para e369">
                        <div class="emphasis e370">“In 
                           <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e371" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Computer_science" xlink:show="new" xlink:type="simple">
                              
                              <div class="emphasis e372" role="bold">computer science</div>
                           </div>, a 
                           <div class="emphasis e373" role="bold">tail call</div> is a 
                           <div class="emphasis e374" role="bold">
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e375" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Subroutine" xlink:show="new" xlink:type="simple">subroutine</div>
                              
                           </div> call that happens inside another procedure as its final action; it
                           may produce a return value which is then immediately 
                           <div class="emphasis e376" role="bold">
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e377" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Return_statement" xlink:show="new" xlink:type="simple">returned</div>
                              
                           </div> by the calling procedure. The 
                           <div class="emphasis e378" role="bold">
                              
                              <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e379" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Call_site" xlink:show="new" xlink:type="simple">call
                                 site
                              </div>
                           </div> is then said to be in 
                           <div class="emphasis e380" role="bold">tail
                              position
                           </div>, i.e. at the end of the calling procedure. If any call
                           that a subroutine performs, such that it might eventually lead to this same
                           subroutine being called again down the call chain, is in tail position, such a
                           subroutine is said to be 
                           <div class="emphasis e381" role="bold">tail-recursive</div>”
                        </div>
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e382"> At present, the XSLT/XPath processors that do recognize some kind of tail
               recursion typically do so if a function/template calls 
               <div class="emphasis e383" role="bold">itself</div> by
               name. 
            </div>
            <div class="para e384">
               There is no record that any of them handles the case when the tail call is to another
               function
               (Michael Kay, author of Saxon[
               <div class="citation e385" linkend="Saxon"></div>], shared on the Saxon mailing list that Saxon correctly 
               handles any type of tail calls (not only calls to the same named template) for templates,
               
               but doesn’t do so in the case of functions).
               
            </div>
            <div class="para e386">
               So, what can we do in this situation? One decision is to wait until some processor
               starts 
               handling any type of tail call inside functions.
               
            </div>
            <div class="para e387"> Fortunately, there is another option: 
               <div class="emphasis e388" role="bold">use the DVC (Divide
                  and Conquer) technique
               </div>[
               <div class="citation e389" linkend="DivConq"></div>] for minimizing the maximum depth of nested
               recursion calls. 
            </div>
            <div class="para e390">
               The idea is to split the sequence into subsequences (usually two) of roughly the same
               length, 
               recursively process each subsequence, and then combine the results of processing 
               each individual subsequence.
               
            </div>
            <div class="para e391">
               
               <div class="emphasis e392" role="bold">Here is the above code, re-written [
                  <div class="citation e393" linkend="Nova2"></div>] to use DVC
               </div>:
               
               <div class="programlisting e394" xml:space="preserve">let $f := function($nums as xs:double*,
                  $f1 as function(xs:double*, function())
                  as xs:double
                  ) as xs:double
                  {if(not($nums[1]))
                  then 0
                  else if(not($nums[2]))
                  then $nums[1]
                  else
                  let $half := count($nums) idiv 2
                  return
                  $f1(subsequence($nums,1, $half), $f1)
                  		             +
                  		               $f1(subsequence($nums, $half+1), $f1)
                  },
                  
                  $F := function($nums as xs:double*) as xs:double
                  {
                  $f($nums, $f)
                  }
                  return
                  $F(1 to 10000)                
               </div>
               
               
            </div>
            <div class="para e395"> Sure enough, this time we get the result without any exception being thrown:
               
               <div class="programlisting e396" xml:space="preserve">5.0005E7</div>
               
            </div>
            <div class="para e397"> Using this technique, the maximum recursion depth is 
               <div class="code e398">Log2(N)</div> — thus
               for processing a sequence with 
               <div class="code e399">1M</div> (one million elements) the maximum
               recursion depth is just 
               <div class="code e400">19</div>. 
            </div>
            <div class="para e401">
               
               <div class="emphasis e402" role="bold">Thus, the DVC technique is a tool that can be immediately used
                  to circumvent the lack of intelligence of current XPath 3.0 processors when
                  dealing with tail-call optimization
               </div>. 
            </div>
            <div class="para e403"></div>
         </div><a name="47ProducinganewXMLdocumentor%0AelementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e404">
            <div class="title e405">4.7 Producing a new XML document or
               element
            </div>
            <div class="para e406"> Can an XPath expression produce a new XML document? Say, from the Books XML
               document used before, can an XPath expression produce this XML document:
               
               <div class="programlisting e407" xml:space="preserve">&lt;Person&gt;Marvin Minsky&lt;/Person&gt;                </div>
               “
               <div class="emphasis e408" role="bold">No way!</div>” will tell you any XPath specialist.
               And they would be right for XPath 1.0 or 2.0. 
            </div>
            <div class="para e409">
               
               <div class="emphasis e410" role="bold">Remarkably, we can produce the above new XML document with the
                  following XPath 3.0 expression
               </div>:
               
               <div class="programlisting e411" xml:space="preserve">parse-xml(concat('&lt;Person&gt;', (//Author)[last()], '&lt;/Person&gt;')) </div>
            </div>
            <div class="para e412"> When this XPath 3.0 expression is evaluated, the result is:
               
               <div class="programlisting e413" xml:space="preserve"> &lt;Person&gt;Marvin Minsky&lt;/Person&gt;</div>
               
            </div>
            <div class="para e414"> To see that we have really produced a new document we evaluate this expression:
               
               <div class="programlisting e415" xml:space="preserve">parse-xml(concat('&lt;Person&gt;', (//Author)[last()], '&lt;/Person&gt;'))/*/text()</div>
               and sure enough, the result is: 
               <div class="programlisting e416" xml:space="preserve">Marvin Minsky</div>
               
            </div>
         </div>
      </div><a name="5%09CompleteXPath30modulesandapplicationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e417">
         <div class="title e418">5.	Complete XPath 3.0 modules and applications</div>
         <div class="para e419">
            We now have the necessary knowledge to produce a complete module or XML processing
            
            application within a single XPath 3.0 expression.
            
         </div>
         <div class="para e420">
            The problem we are solving in this chapter is to define a new data-type – 
            the Binary Search Tree (BST). The code is implemented entirely in XPath. 
            An advantage of an “XPath-only” definition is that it can be used (hosted) in 
            many programs—it can be hosted in XSLT programs, in XQuery programs, 
            and in any other programming language that hosts XPath. Thus “XPath-only” 
            data-type definitions or, more generally, libraries of XPath functions, 
            are highly portable and reusable.
            
         </div>
         <div class="para e421"> A BST[
            <div class="citation e422" linkend="BST"></div>] as defined here can process an XML document and represent its data as a
            binary search tree. A BST can implement “find/insert/delete a node” operations much
            more
            efficiently (with logarithmic time complexity) than in the case when the nodes are
            processed in a linear fashion. 
         </div>
         <div class="table e423">
            <div class="caption e424">
               <div class="para e425">
                  <div class="emphasis e426" role="bold">Brief efficiency analysis</div>
               </div>
            </div>
            <div class="tr e427">
               <div class="td e428">
                  
                  <div class="para e429"> It is a well-known, proven fact that find/insert/delete operations in a
                     balanced binary tree can be implemented with time complexity of
                     
                     <div class="code e430">O(log2N)</div>. 
                  </div>
                  
                  <div class="para e431"> When processing in a linear fashion two sequences of data items:
                     
                     <div class="code e432">seq1</div> and 
                     <div class="code e433">seq2</div> and if 
                     <div class="code e434">seq2</div> is
                     
                     <div class="code e435">1000000</div>(1M) times longer than 
                     <div class="code e436">seq1</div>, the time
                     for processing 
                     <div class="code e437">seq2</div> is around one million times bigger, than
                     the time for processing 
                     <div class="code e438">seq1</div>. 
                  </div>
                  
                  <div class="para e439"> Compare this to having two balanced binary search trees 
                     <div class="code e440">bst1</div>
                     and 
                     <div class="code e441">bst2</div>, where 
                     <div class="code e442">bst2</div> has 
                     <div class="code e443">1000000</div> (1M)
                     times more data items (nodes) than 
                     <div class="code e444">bst1</div> – in this case the time
                     to process 
                     <div class="code e445">bst2</div> is only 
                     <div class="code e446">19</div> times bigger than the
                     time for processing 
                     <div class="code e447">bst1</div>. 
                  </div>
                  
               </div>
            </div>
         </div>
         <div class="para e448"> In the rest of this paper we are solving this real-world problem: 
            <div class="emphasis e449" role="bold">Find all bank transactions within a given range of dates</div>. 
         </div>
         <div class="para e450">
            
            <div class="emphasis e451" role="bold">Example</div>: the following XML document contains a list of
            bank transactions (withdrawals and deposits). Each transaction is stamped with a date.
            The transactions are in no particular chronological order: 
            <div class="programlisting e452" xml:space="preserve"> &lt;Transactions&gt;
               &lt;transaction date="2012-03-01"&gt;
               &lt;withdrawal&gt;100&lt;/withdrawal&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-01-15"&gt;
               &lt;deposit&gt;200&lt;/deposit&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-05-01"&gt;
               &lt;deposit&gt;100&lt;/deposit&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-02-01"&gt;
               &lt;withdrawal&gt;50&lt;/withdrawal&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-06-01"&gt;
               &lt;deposit&gt;100&lt;/deposit&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-04-01"&gt;
               &lt;deposit&gt;100&lt;/deposit&gt;
               &lt;/transaction&gt;
               &lt;transaction date="2012-01-01"&gt;
               &lt;deposit&gt;25&lt;/deposit&gt;
               &lt;/transaction&gt;
               &lt;/Transactions&gt;            
            </div> If we could represent the above XML document as a
            binary search tree where for each node (transaction), the date of its left child
            (transaction) node is less than the (parent) node’s date and the date of its right
            child
            (transaction) node is greater than the (parent) node’s date. Then such a binary search
            tree be graphically represented as below: 
            <div class="inlinemediaobject e453">
               <div class="imageobject e454">
                  <div class="metaBox e455"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e975').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e975" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e455'
                           </span><span class="metaAttribute">fileref='../../../vol10/graphics/Novatchev01/Novatchev01-001.png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e456">
            
            <div class="emphasis e457" role="bold">Problem</div>: Find all the transactions in the range
            2012-03-15 to 2012-05-15. 
         </div>
         <div class="para e458">
            This problem can be solved efficiently now that the transactions are stored in a binary
            tree. 
            (The more balanced the binary search tree is, the more efficient is a BST-based solution.)
            
         </div>
         <div class="para e459">
            The following pseudo-code (an initial version of which and the code below was first
            produced by 
            Roger Costello [
            <div class="citation e460" linkend="Costello"></div>]) that shows how to find the wanted transactions 
            (
            <div class="code e461">start date &gt;= 2012-03-15</div>, 
            <div class="code e462">end date &lt;= 2012-05-15</div>):
            
         </div>
         <div class="para e463">
            
            <div class="emphasis e464" role="bold">Return a sequence of the following nodes</div>:
            
         </div>
         <div class="para e465">
            If the value of the root node equals the start date, then:
            
            <div class="orderedlist e466">
               <div class="listitem e467">
                  <div class="para e468">
                     The root node.
                     
                  </div>
               </div>
               <div class="listitem e469">
                  <div class="para e470">
                     The result of recursing on the right subtree.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e471">
            If the value of the root node equals the end date, then:
            
            <div class="orderedlist e472">
               <div class="listitem e473">
                  <div class="para e474">
                     The result of recursing on the left subtree.
                     
                  </div>
               </div>
               <div class="listitem e475">
                  <div class="para e476">
                     The root node.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e477">
            If the value of the root node is between the start and end date, then:
            
            <div class="orderedlist e478">
               <div class="listitem e479">
                  <div class="para e480">
                     The result of recursing on the left subtree.
                     
                  </div>
               </div>
               <div class="listitem e481">
                  <div class="para e482">
                     The root node.
                     
                  </div>
               </div>
               <div class="listitem e483">
                  <div class="para e484">
                     The result of recursing on the right subtree.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e485">
            If the value of the root node is less than the start date, then:
            
            <div class="orderedlist e486">
               <div class="listitem e487">
                  <div class="para e488">
                     The result of recursing on the right subtree,
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e489">
            If the value of the root node is greater than the end date, then:
            
            <div class="orderedlist e490">
               <div class="listitem e491">
                  <div class="para e492">
                     The result of recursing on the left subtree.
                     
                  </div>
               </div>
            </div>
            
         </div>
         <div class="table e493">
            <div class="caption e494">
               <div class="para e495">
                  <div class="emphasis e496" role="bold">XSLT/XQuery or XPath?</div>
               </div>
            </div>
            <div class="tr e497">
               <div class="td e498">
                  
                  <div class="para e499"> The code in this chapter can be implemented using XSLT or XQuery -defined
                     functions. One would favor an XPath-only solution because: 
                     <div class="itemizedlist e500">
                        <div class="listitem e501">
                           <div class="para e502">Implementation in more than one language (e.g. in both XSLT
                              and XQuery) is often required.
                           </div>
                        </div>
                        <div class="listitem e503">
                           <div class="para e504">The XPath code can be shorter and easier to understand.</div>
                        </div>
                        <div class="listitem e505">
                           <div class="para e506">The XPath solution can be injected into XSLT and/or XQuery
                              code, with simple copy and paste.
                           </div>
                        </div>
                     </div>
                     
                     <div class="emphasis e507" role="bold">Recommendation</div>: Consider producing an
                     XPath-only solution or a library of functions, especially if there is even a
                     remote possibility that the functionality would be needed in more than one
                     XML processing language.
                  </div>
                  
               </div>
            </div>
         </div>
         <div class="para e508">
            
            <div class="programlisting e509" xml:space="preserve">$find-range-of-transactions :=
               	         function( $tree as function()*,
               	                   $start-date as xs:date,
               	                   $end-date as xs:date
               	                  )
               	         {
               	             $find-range-of-transactions-helper
               	         				( $tree,
               	               	 	   $start-date,
               	                       	$end-date,
               	                       	$find-range-of-transactions-helper)
               	         }
            </div>
            The function’s name is 
            <div class="code e510">find-range-of-transactions</div>. This is a recursive
            function. As shown previously, implementing recursion using anonymous functions requires
            a “helper” function. Here is the helper function
            
            <div class="code e511">find-range-of-transactions-helper()</div>:
            
            <div class="programlisting e512" xml:space="preserve">$find-range-of-transactions-helper :=
               	        function( $tree as function()*,
               	                  $start-date as xs:date,
               	                  $end-date as xs:date,
               	                  $find-range-of-transactions-helper
               	                  )
               	                   as element(transaction)*
               	        {
               	            if (empty($tree)) then ()
               	            else
               	                if (xs:date($root($tree)/@date)  eq  $start-date) 
               then
               	                     (
               	                        $root($tree),
               	                        $find-range-of-transactions-helper
               	                        	  ( $right($tree),
               	                                $start-date,
               	                                $end-date,
               	                                $find-range-of-transactions-helper)
               	                     )
               	                    else  if (xs:date($root($tree)/@date)  eq  $end-date) 
               then
               	                          (
               	                             $find-range-of-transactions-helper
               	                             	  ( $left($tree),
               	                                     $start-date,
               	                                     $end-date,
               	                                     $find-range-of-transactions-helper),
               	                             $root($tree)
               	                          )
               	                        else
               	                            if ((xs:date($root($tree)/@date)  gt  $start-date)
               	                              and
               	                                (xs:date($root($tree)/@date)  lt  $end-date)) then
               	                              (
               	                                  $find-range-of-transactions-helper
               	                                   	 ( $left($tree),
               	                                      	$start-date,
               	                                      	$end-date,
               	                                      	$find-range-of-transactions-helper),
               	                                  $root($tree),
               	                                  $find-range-of-transactions-helper
               	                                 	   ( $right($tree),
               	                                   	   $start-date,
               	                                   	   $end-date,
               	                                   	   $find-range-of-transactions-helper)
               	                              )
               	                            else
               	                                if (xs:date($root($tree)/@date)  lt  $start-date)
               then
               	                                  (
               	                                      $find-range-of-transactions-helper
               	                                      	  ( $right($tree),
               	                                       	   $start-date,
               	                                       	   $end-date,
               	                                       	   $find-range-of-transactions-helper)
               	                                  )
               	                                else
               	                                    if (xs:date($root($tree)/@date)  gt  $end-date)
               then
               	                                      (
               	                                           $find-range-of-transactions-helper
               	                                          	   ( $left($tree),
               	                                           	    $start-date,
               	                                           	    $end-date,
               	                                           	    $find-range-of-transactions-helper)
               	                                      )
               	                                    else ()
               	         }
            </div>
            
         </div>
         <div class="para e513"> As tree-nodes are inserted into the binary tree, a comparison is made between the
            tree-node being inserted and the tree’s root node. How should the comparison be done?
            That depends on the data-type of the items stored in a tree. Consequently, the “insert
            function” must be provided an appropriate “comparator function.” For our bank
            transactions example, the comparison is done based on the date attribute. Here is
            an
            appropriate comparator function:
            
            <div class="programlisting e514" xml:space="preserve">$transaction-less-than-comparator :=
               	 function($arg1 as element(transaction),
               	          $arg2 as element(transaction)
               	          ) as xs:boolean
               	   {
               	      xs:date($arg1/@date)  lt   xs:date($arg2/@date)
               	   }    
            </div>
            
         </div>
         <div class="para e515">
            The value of the variable is an anonymous function. The function takes two arguments
            – 
            both transaction  elements – and returns true if the date of  the first transaction
            is less 
            than the date of  the second transaction.
            
         </div>
         <div class="para e516">
            In this paper we define a binary search tree is a set of these functions:
            
            <div class="orderedlist e517">
               <div class="listitem e518">
                  <div class="para e519">
                     
                     <div class="emphasis e520" role="bold">create</div>: create an empty tree.
                  </div>
               </div>
               <div class="listitem e521">
                  <div class="para e522">
                     
                     <div class="emphasis e523" role="bold">root</div>: return the value of the root
                     node.
                  </div>
               </div>
               <div class="listitem e524">
                  <div class="para e525">
                     
                     <div class="emphasis e526" role="bold">left</div>: return the left subtree.
                  </div>
               </div>
               <div class="listitem e527">
                  <div class="para e528">
                     
                     <div class="emphasis e529" role="bold">right</div>: return the right subtree.
                  </div>
               </div>
               <div class="listitem e530">
                  <div class="para e531">
                     
                     <div class="emphasis e532" role="bold">empty</div>: return true if the tree is empty,
                     false otherwise.
                  </div>
               </div>
               <div class="listitem e533">
                  <div class="para e534">
                     
                     <div class="emphasis e535" role="bold">insert</div>: insert an item into the tree, with
                     comparison done using a comparator (see above).
                  </div>
               </div>
               <div class="listitem e536">
                  <div class="para e537">
                     
                     <div class="emphasis e538" role="bold">print</div>: serialize the tree as XML
                     document.
                  </div>
               </div>
               <div class="listitem e539">
                  <div class="para e540">
                     
                     <div class="emphasis e541" role="bold">populate</div>: create a BST from a sequence of
                     items.
                  </div>
               </div>
            </div>
            Additionaly, one can define other useful functions on a BST, such as node deletion[
            <div class="citation e542" linkend="Nova3"></div>].
            
         </div>
         <div class="para e543"> Below is the complete XPath code for both the BST type definition and the functions
            that use this data-type to actually solve the problem of finding all the bank
            transactions between a given start date and a given end date.
            
            <div class="programlisting e544" xml:space="preserve">let
               (:
               The purpose of create is to return an empty tree.
               
               It returns a sequence of functions, 
               - the first function represents the root of a tree, 
               - the second function represents the left subtree, 
               - and the third function represents the right subtree. 
               The value of each function is an empty sequence.
               :) 
               $create := (
               function() { () }      (: root :),
               function() { () }      (: left :),
               function() { () }      (: right :) 
               ),
               
               
               (:
               empty() returns a boolean value,
               indicating whether $tree is empty.
               
               $tree is empty in either of these two cases:
               1. $tree is the empty sequence (it doesn't contain any functions). 
               2. $tree contains a sequence of three functions, but the first 
               function - representing the root - is empty (i.e., if you invoke the 
               first function it returns the empty sequence). 
               :)
               $empty := function($tree as function()*)
               {
               empty($tree) or empty($tree[1]())
               },
               
               
               (:
               root()returns the value of the root node. 
               
               This function takes one argument, $tree. Since $tree 
               is represented by a sequence of functions, returning the 
               value of the root node actually means returning the value of   
               the function that corresponds to the root node.
               
               If $tree is empty then the empty sequence is returned. Otherwise 
               the *value* of executing the first function in $tree  is returned (recall 
               that a tree is represented by a sequence of functions, the first 
               function representing the root of the tree).
               
               Note: $tree[1] is the first function whereas
               $tree[1]() is the *value* of executing the first function.
               :)
               $root := function($tree as function()*)
               {
               if ($empty($tree)) 
               then ()
               else $tree[1]()
               },
               
               
               (:
               left()returns the left subtree. 
               
               This function takes one argument, $tree. Since $tree is represented 
               by a sequence of functions, returning the left subtree  
               actually means returning the value of executing the function that corresponds 
               to the left subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise 
               the *value* of executing the second function in $tree is returned (recall 
               that a tree is represented by a sequence of functions, the second 
               function representing the left subtree).
               
               Note: $tree[2] is the second function whereas
               $tree[2]() is the *value* of executing the second function.
               :)
               $left := function($tree as function()*)
               {
               if ($empty($tree)) then ()
               else 
               if ($empty($tree[2])) then ()
               else $tree[2]()
               },
               
               
               (:
               right() returns the right subtree. 
               
               This function takes one argument, $tree. Since $tree is represented 
               by a sequence of functions, returning the right subtree actually 
               means returning the value of executing the function that corresponds to the
               right subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise 
               the *value* of executing the third function in $tree is returned (recall 
               that a tree is represented by a sequence of functions, the third 
               function representing the right subtree).
               :)
               $right := function($tree as function()*)
               {
               if ($empty($tree)) then ()
               else 
               if ($empty($tree[3])) then ()
               else $tree[3]()
               },
               
               
               (:
               As tree-nodes are inserted into a BST, a comparison is made between 
               the value being inserted and the value in the tree's root node. How should 
               the comparison be done? That depends on the type of the data contained in a tree-node.
               Comparing two integers is different than comparing two tree fragments.
               So, the insert function must be provided with an appropriate comparator. For 
               the case of bank transactions, a date comparison is needed.
               Here is an appropriate comparator function:
               :)
               $transaction-less-than-comparator :=
               	        function( $arg1  as element(transaction),
               	                  $arg2  as element(transaction)
               	                 ) as xs:boolean
               	        {
               	              xs:date($arg1/@date) lt xs:date($arg2/@date)
               	        },
               
               
               $numeric-less-than-comparator :=
               	         function( $arg1 as xs:decimal,
               	                   $arg2 as xs:decimal
               	                  ) as xs:boolean
               	         {
               	               $arg1  lt   $arg2
               	         },
               
               
               (:
               insert() takes a $tree (BST) and a $item and produces a new BST that is the result
               
               of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
               Insertions or deletions are never done “in place” – instead a new BST is produced.
               
               
               The new node is inserted at:
               - if $tree is empty then as root node.
               - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
               - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)
               
               Here are the steps taken if $tree is empty:
               - $item specified to be the result of  the  root function. That is, the root function,
               
               if invoked, it returns $item. 
               - A left function is created such that, if invoked, will return an empty subtree.
               - A right function is created such that, if invoked, will return an empty subtree.
               
               The insert function is recursive. Recursion with anonymous functions requires
               a helper function as discussed before.
               :)
               $insert-helper :=
               	         function( $tree as function()*,
               	                   $item as item(),
               	                   $less-than-comparator as function(item(), item()) as xs:boolean,
               	                   $insert-helper
               	                   )
               	         {
               	         if ($empty($tree)) then
               	               (
               	                     function() {$item}     (: root :),
               	                     function() {()}        (: left :),
               	                     function() {()}        (: right :)
               	               )
               	          else if ($less-than-comparator($item, $root($tree))) then
               	               (
               	                     function() {$root($tree)}                           	(: root
               :),
               
               	                     function() {$insert-helper( $left($tree),
               	                                                 $item,
               	                                                 $less-than-comparator,
               	                                                 $insert-helper)
               	                                }   				                         (: left :),
               
               	                     function() {$right($tree)}                          	(: right
               :)
               	                )
               	          else
               	               (
               	                     function() {$root($tree)}                          	 (: root
               :),
               	                     function() {$left($tree)}                           	(: left
               :),
               
               	                     function() {$insert-helper( $right($tree),
               	                                                 $item,
               	                                                 $less-than-comparator,
               	                                                 $insert-helper)
               	                                }      				                      (: right :)
               	                )
               	         },
               
               
               $insert :=
               	         function ( $tree as function()*,
               	                    $item as item(),
               	                    $less-than-comparator as function(item(), item()) as xs:boolean
               	                    )
               	         {
               	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
               	         },
               
               
               (:
               print() produces an XML document that represents the BST $tree. 
               
               The XML document produced by  print()  consists of:
               1. A root element that represents the value of executing the root function.
               2. A left element that represents the value of print() on the left subtree
               (note the recursive definition).
               3. A right element that represents the value of print() on the right subtree
               (note the recursive definition).
               
               The $print-helper function produces the markup
               as a string and then the $printer function converts
               this string into an XML document by calling the  parse-xml() function.
               :)
               $print-helper :=
               	         function ( $tree as function()*,
               	                    $print-helper
               	                    ) 
               	                     as xs:string?
               	         {
               	              if (not($empty($tree))) then
               	              concat('&lt;tree&gt;',
               	                       '&lt;root&gt;',
               	                          $root($tree),
               	                       '&lt;/root&gt;',
               	                        '&lt;left&gt;',
               	                          $print-helper($left($tree),$print-helper),
               	                        '&lt;/left&gt;',
               	                        '&lt;right&gt;',
               	                          $print-helper($right($tree),$print-helper),
               	                        '&lt;/right&gt;',
               	                     '&lt;/tree&gt;'
               	                      )
               	             else ()
               	          },
               
               
               $print := function ($tree as function()*)
               {parse-xml($print-helper($tree, $print-helper))/*},
               
               
               (:
               populate() produces a new tree from its BST argument $tree by inserting
               the value of the head() of the sequence $items onto $tree and then inserting 
               the tail() of the sequence $items onto the result. 
               :)
               $populate-helper :=
               	         function ( $tree as function()*,
               	                    $items as item()*,
               	                    $less-than-comparator as function(item(), item()) as xs:boolean,
               	                    $populate-helper
               	                    )
               	         {
               	             if (empty($items)) then $tree
               	             else
               	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
               	                                    $items[position() gt 1],
               	                                    $less-than-comparator,
               	                                    $populate-helper
               	                                    )
               	         },
               
               
               $populate :=
               	         function( $tree as function()*,
               	                   $items as item()*,
               	                   $less-than-comparator as function(item(), item()) as xs:boolean
               	                   )
               	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)},
               
               
               (:
               Finally, the solution of the original problem. 
               Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15. 
               :)
               $find-range-of-transactions-helper :=
               	        function( $tree as function()*,
               	                  $start-date as xs:date,
               	                  $end-date as xs:date,
               	                  $find-range-of-transactions-helper
               	                )
               	                as element(transaction)*
               	        {
               	            if (empty($tree)) then ()
               	            else
               	                if (xs:date($root($tree)/@date) eq $start-date) then
               	                     (
               	                            $root($tree),
               	                            $find-range-of-transactions-helper
               	                        		        ( $right($tree),
               	                                   	   $start-date,
               	                                      	$end-date,
               	                                     	 $find-range-of-transactions-helper)
               	                     )
               	                    else
               	                        if (xs:date($root($tree)/@date) eq $end-date) then
               	                          (
               	                                 $find-range-of-transactions-helper
               	                             	            ( $left($tree),
               	                                       	    $start-date,
               	                                      	     $end-date,
               	                                       	    $find-range-of-transactions-helper),
               	                                 $root($tree)
               	                          )
               	                        else
               	                            if ((xs:date($root($tree)/@date) gt $start-date)
               	                               and
               	                                (xs:date($root($tree)/@date) lt $end-date)) then
               	                             (
               	                                   $find-range-of-transactions-helper
               	                                   		( $left($tree),
               	                                      	   $start-date,
               	                                      	   $end-date,
               	                                      	   $find-range-of-transactions-helper),
               	                                   $root($tree),
               	                                   $find-range-of-transactions-helper
               	                                 		( $right($tree),
               	                                   	    $start-date,
               	                                   	    $end-date,
               	                                   	    $find-range-of-transactions-helper)
               	                             )
               	                            else
               	                                if (xs:date($root($tree)/@date) lt $start-date) then
               	                                 (
               	                                    $find-range-of-transactions-helper
               	                                      ( $right($tree),
               	                                        $start-date,
               	                                        $end-date,
               	                                        $find-range-of-transactions-helper)
               	                                 )
               	                                else
               	                                    if (xs:date($root($tree)/@date) gt $end-date)
               then
               	                                     (
               	                                        $find-range-of-transactions-helper
               	                                          ( $left($tree),
               	                                            $start-date,
               	                                            $end-date,
               	                                            $find-range-of-transactions-helper)
               	                                     )
               	                                    else ()
               	         },
               
               
               $find-range-of-transactions :=
               	         function($tree as function()*,
               	                  $start-date as xs:date,
               	                  $end-date as xs:date
               	                  )
               	         {
               	             $find-range-of-transactions-helper
               	         	  ( $tree,
               	                 $start-date,
               	                 $end-date,
               	                 $find-range-of-transactions-helper)
               	         }
               
               
               (:  At last, we finalize this big, outermost *let* clause with a *return* clause 
               that expresses the intent of the users of the BST data-type.
               We want to get all transactions in the period:
               15th March 2012 to 15th May 2012.
               :)
               
               return (
               $find-range-of-transactions
               ( $populate((), //transaction, $transaction-less-than-comparator),
               xs:date('2012-03-15'), 
               xs:date('2012-05-15')
               )
               )
            </div>
            
         </div>
      </div><a name="6%09AnalysisANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e545">
         <div class="title e546">6.	Analysis</div>
         <div class="para e547">
            
            <div class="emphasis e548" role="bold">This example shows how a new data-type, or generally a library of
               functions can be defined in an XPath 3.0 expression and then used by a client in the
               same XPath expression
            </div>: 
            <div class="itemizedlist e549">
               <div class="listitem e550">
                  <div class="para e551">The definitions of the library functions are in the “let clause”.</div>
               </div>
               <div class="listitem e552">
                  <div class="para e553">The expressions that use these library functions are in the “return
                     clause”.
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e554">
            
            <div class="emphasis e555" role="bold">We also experienced some inconvenience and that helped us specify
               a wish-list for a future version of XPath
            </div>: 
            <div class="orderedlist e556">
               <div class="listitem e557">
                  <div class="para e558"> Our example contains one huge let-return expression. For better
                     modularity it would have been nice to place all the binary search tree
                     functions (create, left, right, insert, etc.) into their own “module” which
                     could then be “imported” by the bank transaction functions. Unfortunately,
                     XPath does not support this. 
                     <div class="emphasis e559" role="bold">Recommendation for a
                        future XPath version
                     </div>: 
                     <div class="emphasis e560">Support XPath
                        expression files and an import clause to collect such expressions from
                        files in a desired new, client XPath program
                     </div>. 
                  </div>
               </div>
               <div class="listitem e561">
                  <div class="para e562"> Our example implemented binary search trees as a sequence of functions.
                     While this works okay, it would be much more precise and elegant if XPath
                     had a “tuple type” so that a tree could be simply defined as a tuple: tree
                     is a tuple (root, left, right). 
                     <div class="emphasis e563" role="bold">Recommendation for a
                        future XPath version
                     </div>: 
                     <div class="emphasis e564">Support a tuple
                        type, so that the result type of various functions (such as the creation
                        of a tree) can be more precisely specified than just a sequence of
                        function items
                     </div>. 
                  </div>
               </div>
               <div class="listitem e565">
                  <div class="para e566">
                     The Map data-type could further boost the expressiveness of XPath, 
                     making the language even more convenient. The Map data-type is already 
                     part of the latest published working draft of XSLT 3.0 [
                     <div class="citation e567" linkend="XSLT3.0"></div>] and has been warmly 
                     accepted by the XML developers community.
                     
                  </div>
               </div>
               <div class="listitem e568">
                  <div class="para e569">
                     Introducing generics would further strengthen the expressive power and preciseness
                     of XPath. 
                     
                  </div>
               </div>
            </div>
            
         </div>
      </div><a name="7ConsuminganXPathfunctionlibraryfromXSLT30andXQuery31ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e570">
         <div class="title e571">7. Consuming an XPath function library from XSLT 3.0 and XQuery 3.1</div>
         <div class="para e572">
            It is possible in XSLT 3.0 to conveniently consume an XPath function library
            directly from a text file.
            
         </div>
         <div class="para e573">
            
            <div class="emphasis e574" role="bold">Here is an example:</div>
            
         </div>
         <div class="para e575">
            
            <div class="emphasis e576" role="bold">A simple function library</div> (file SimpleLibraryAsMap.xpath):
            
         </div>
         <div class="para e577">
            
            <div class="programlisting e578" xml:space="preserve">
               let
               $incr := function($n as xs:integer)
               {$n +1},
               $mult := function($m as xs:integer, $n as xs:integer)
               {$m * $n},
               $decr := function($n as xs:integer)
               {$n -1},
               $idiv := function($m as xs:integer, $n as xs:integer)
               {$m idiv $n}
               
               	  (: Provide the function libary  as a map:)
               return
               map {
               'incr'     := $incr,
               'mult'     := $mult,
               'decr'     := $decr,
               'idiv'     := $idiv
               }  
            </div>
            
         </div>
         <div class="para e579">
            
            <div class="emphasis e580" role="bold">XSLT transformation that uses this function library</div>:
            
         </div>
         <div class="para e581">
            
            <div class="programlisting e582" xml:space="preserve">
               &lt;xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               &lt;xsl:output omit-xml-declaration="yes" indent="yes"/&gt;
               
               &lt;xsl:template match="/"&gt;
               
               &lt;!-- The Function Library --&gt;
               &lt;xsl:variable name="vMath" as="map(*)"&gt;
               &lt;xsl:evaluate xpath="unparsed-text('SimpleLibraryAsMap.xpath')"/&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:sequence select="'incr(3) = ', $vMath('incr')(3)"/&gt;
               &lt;/xsl:template&gt;
               &lt;/xsl:stylesheet&gt;         
            </div>
            
         </div>
         <div class="para e583">
            <div class="emphasis e584" role="bold">The result is:</div> "incr(3) =  4"
         </div>
         <div class="para e585">The "importing" of the library is done via the simple and powerful combination
            of the standard XPath 3.0 function 
            <div class="emphasis e586">unparsed-text()</div> and the new XSLT 3.0 instruction
            
            <div class="emphasis e587">&lt;xsl:evaluate&gt;</div>
            
         </div>
         <div class="para e588">
            
            <div class="emphasis e589" role="bold">Consuming the function library from a map-cognizant XQuery processor is even simpler</div>
            -- we just need to
            wrap the library as/into an XQuery module and then import this module in the consuming
            XQuery.
            
         </div>
         <div class="para e590"></div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e591">
         <div class="title e592">Conclusion</div>
         <div class="para e593">
            The powerful new capabilities in XPath 3.0 such as HOFs,  inline functions, functional
            composition, 
            partial application and closures, indirect and robust anonymous function recursion,
            
            own sequence-type variables and the ability to create new XML documents / nodes, turn
            XPath 
            into a full-pledged, complete, modern XML programming language: the first to truly
            implement 
            useful copy-paste code portability between XSLT and XQuery. 
            
         </div>
         <div class="para e594">
            This gives the XML programmer the ability to write an application once and reuse it
            many times
            – standalone or included into code written in many other languages. 
            
         </div>
         <div class="para e595">
            Function library author’s productivity is significantly increased, redundancy is eliminated,
            maintenance of dual sets of functions is no longer a problem.
            
         </div>
         <div class="para e596">
            A few finishing touches are needed such as adding tuples, generics 
            and modularity support – either by the W3C or by proactive programmers.
            
         </div>
         <div class="para e597"></div>
      </div><a name="AcknowledgementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e598">
         <div class="title e599">Acknowledgement</div>
         <div class="para e600">Many thanks to Roger Costello, without whose work this paper would hardly be possible.</div>
         <div class="para e601"></div>
      </div><a name="Appendix:TheBSTdatatypedefinedandconsumedasamapANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e602">
         <div class="title e603">Appendix: The BST data type defined and consumed as a map </div>
         <div class="para e604">Here we show an easy way to consume from both XSLT and XQuery
            the BST function library residing at its own file
         </div>
         <div class="para e605">
            <div class="emphasis e606" role="bold">The BST XPath code</div> (XPathFunctionLibrary.xpath)
            -- see how a 
            <div class="emphasis e607">map</div> is created in the return clause:
         </div>
         <div class="para e608">
            
            <div class="programlisting e609" xml:space="preserve">
               let
               (:
               The purpose of create is to return an empty tree.
               
               It returns a sequence of functions,
               - the first function represents the root of a tree,
               - the second function represents the left subtree,
               - and the third function represents the right subtree.
               The value of each function is an empty sequence.
               :)
               $create := (
               function() { () }      (: root :),
               function() { () }      (: left :),
               function() { () }      (: right :)
               ),
               
               
               (:
               empty() returns a boolean value,
               indicating whether $tree is empty.
               
               $tree is empty in either of these two cases:
               1. $tree is the empty sequence (it doesn't contain any functions).
               2. $tree contains a sequence of three functions, but the first
               function - representing the root - is empty (i.e., if you invoke the
               first function it returns the empty sequence).
               :)
               $empty := function($tree as function(*)*)
               {
               empty($tree) or empty($tree[1]())
               },
               
               
               (:
               root()returns the value of the root node.
               
               This function takes one argument, $tree. Since $tree
               is represented by a sequence of functions, returning the
               value of the root node actually means returning the value of
               the function that corresponds to the root node.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the first function in $tree  is returned (recall
               that a tree is represented by a sequence of functions, the first
               function representing the root of the tree).
               
               Note: $tree[1] is the first function whereas
               $tree[1]() is the *value* of executing the first function.
               :)
               $root := function($tree as function(*)*)
               {
               if ($empty($tree))
               then ()
               else $tree[1]()
               },
               
               
               (:
               left()returns the left subtree.
               
               This function takes one argument, $tree. Since $tree is represented
               by a sequence of functions, returning the left subtree
               actually means returning the value of executing the function that corresponds
               to the left subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the second function in $tree is returned (recall
               that a tree is represented by a sequence of functions, the second
               function representing the left subtree).
               
               Note: $tree[2] is the second function whereas
               $tree[2]() is the *value* of executing the second function.
               :)
               $left := function($tree as function(*)*)
               {
               if ($empty($tree)) then ()
               else
               if ($empty($tree[2])) then ()
               else $tree[2]()
               },
               
               
               (:
               right() returns the right subtree.
               
               This function takes one argument, $tree. Since $tree is represented
               by a sequence of functions, returning the right subtree actually
               means returning the value of executing the function that corresponds to the
               right subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the third function in $tree is returned (recall
               that a tree is represented by a sequence of functions, the third
               function representing the right subtree).
               :)
               $right := function($tree as function(*)*)
               {
               if ($empty($tree)) then ()
               else
               if ($empty($tree[3])) then ()
               else $tree[3]()
               },
               
               
               $numeric-less-than-comparator :=
               	         function( $arg1 as xs:decimal,
               	                           $arg2 as xs:decimal
               	                         ) as xs:boolean
               	         {
               	               $arg1  lt   $arg2
               	         },
               
               
               (:
               insert() takes a $tree (BST) and a $item and produces a new BST that is the result
               of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
               Insertions or deletions are never done “in place” – instead a new BST is produced.
               
               The new node is inserted at:
               - if $tree is empty then as root node.
               - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
               - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)
               
               Here are the steps taken if $tree is empty:
               - $item specified to be the result of  the  root function. That is, the root function,
               if invoked, it returns $item.
               - A left function is created such that, if invoked, will return an empty subtree.
               - A right function is created such that, if invoked, will return an empty subtree.
               
               The insert function is recursive. Recursion with anonymous functions requires
               a helper function as discussed before.
               :)
               $insert-helper :=
               	         function( $tree as function(*)*,
               	                          $item as item(),
               	                          $less-than-comparator as function(item(), item()) as xs:boolean,
               	                          $insert-helper
               	                         )
               	         {
               	         if ($empty($tree)) then
               	               (
               	                     function() {$item}     (: root :),
               	                     function() {()}            (: left :),
               	                     function() {()}            (: right :)
               	               )
               	          else if ($less-than-comparator($item, $root($tree))) then
               	               (
               	                     function() {$root($tree)}                           	(: root
               :),
               
               	                     function() {$insert-helper( $left($tree),
               	                                                                     $item,
               	                                                                     $less-than-comparator,
               	                                                                     $insert-helper)
               	                                        }   				(: left :),
               
               	                     function() {$right($tree)}                          	(: right
               :)
               	                )
               	          else
               	               (
               	                     function() {$root($tree)}                          	(: root
               :),
               	                     function() {$left($tree)}                           	(: left
               :),
               
               	                     function() {$insert-helper( $right($tree),
               	                                                                     $item,
               	                                                                     $less-than-comparator,
               	                                                                     $insert-helper)
               	                                          }      				  (: right :)
               	                )
               	         },
               
               
               $insert :=
               	         function ( $tree as function(*)*,
               	                           $item as item(),
               	                           $less-than-comparator as function(item(), item()) as xs:boolean
               	                         )
               	         {
               	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
               	         },
               
               
               (:
               print() produces an XML document that represents the BST $tree.
               
               The XML document produced by  print()  consists of:
               1. A root element that represents the value of executing the root function.
               2. A left element that represents the value of print() on the left subtree
               (note the recursive definition).
               3. A right element that represents the value of print() on the right subtree
               (note the recursive definition).
               
               The $print-helper function produces the markup
               as a string and then the $printer function converts
               this string into an XML document by calling the  parse-xml() function.
               :)
               $print-helper :=
               	         function ( $tree as function(*)*,
               	                           $print-helper
               	                          )
               	                          as xs:string?
               	         {
               	         if (not($empty($tree))) then
               	                 concat('&lt;tree&gt;',
               	                                    '&lt;root&gt;',
               	                                          $root($tree),
               	                                    '&lt;/root&gt;',
               	                                    '&lt;left&gt;',
               	                                          $print-helper($left($tree),$print-helper),
               	                                    '&lt;/left&gt;',
               	                                    '&lt;right&gt;',
               	                                          $print-helper($right($tree),$print-helper),
               	                                    '&lt;/right&gt;',
               	                            '&lt;/tree&gt;'
               	                           )
               	          else ()
               	          },
               
               
               $print := function ($tree as function(*)*)
               {parse-xml($print-helper($tree, $print-helper))/*},
               
               
               (:
               populate() produces a new tree from its BST argument $tree by inserting
               the value of the head() of the sequence $items onto $tree and then inserting
               the tail() of the sequence $items onto the result.
               :)
               $populate-helper :=
               	         function ( $tree as function(*)*,
               	                           $items as item()*,
               	                           $less-than-comparator as function(item(), item()) as xs:boolean,
               	                           $populate-helper
               	                         )
               	         {
               	             if (empty($items)) then $tree
               	             else
               	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
               	                                                    $items[position() gt 1],
               	                                                    $less-than-comparator,
               	                                                    $populate-helper
               	                                                  )
               	         },
               
               
               $populate :=
               	         function( $tree as function(*)*,
               	                           $items as item()*,
               	                           $less-than-comparator as function(item(), item()) as xs:boolean
               	                         )
               	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)}
               
               	  (: Finally, make the function libary :)
               	 return
               map {'create'   := $create,
               'empty'    := $empty,
               
               'root'     := $root,
               'left'     := $left,
               'right'    := $right,
               
               'insert'   := $insert,
               
               'populate' := $populate,
               'print'    := $print,
               
               'numeric-less-than-comparator'     := $numeric-less-than-comparator
               }        
            </div>
            
         </div>
         <div class="para e610">
            <div class="emphasis e611" role="bold">Here is the XSLT consuming code, that solves the bank
               transactions problem
            </div>: 
         </div>
         <div class="para e612">
            
            <div class="programlisting e613" xml:space="preserve">
               &lt;xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               &lt;xsl:output omit-xml-declaration="yes" indent="yes"/&gt;
               
               
               &lt;xsl:template match="node()|@*"&gt;
               
               &lt;!-- The Tree Function Library --&gt;
               &lt;xsl:variable name="vTree" as="map(*)"&gt;
               &lt;xsl:evaluate xpath="unparsed-text('XPathFunctionLibrary.xpath')"/&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:sequence select=
               "
               (:
               Finally, the solution of the original problem.
               Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15.
               :)
               let $find-range-of-transactions-helper :=
               	        function( $tree as function(*)*,
               	                          $start-date as xs:date,
               	                          $end-date as xs:date,
               	                          $find-range-of-transactions-helper
               	                )
               	                as element(transaction)*
               	        {
               	            if (empty($tree)) then ()
               	            else
               	                if (xs:date($vTree('root')($tree)/@date) eq $start-date) then
               	                     (
               	                            $vTree('root')($tree),
               	                            $find-range-of-transactions-helper
               	                        		        ($vTree('right')($tree),
               	                                   	 $start-date,
               	                                     $end-date,
               	                                     $find-range-of-transactions-helper)
               	                     )
               	                    else
               	                        if (xs:date($vTree('root')($tree)/@date) eq $end-date) then
               	                          (
               	                                 $find-range-of-transactions-helper
               	                             	            ($vTree('left')($tree),
               	                                       	   $start-date,
               	                                      	   $end-date,
               	                                       	   $find-range-of-transactions-helper),
               	                                 $vTree('root')($tree)
               	                          )
               	                        else
               	                            if (
               	                                (xs:date($vTree('root')($tree)/@date) gt $start-date)
               	                                 and
               	                                (xs:date($vTree('root')($tree)/@date) lt $end-date))
               then
               	                             (
               	                                   $find-range-of-transactions-helper
               	                                   		($vTree('left')($tree),
               	                                       $start-date,
               	                                       $end-date,
               	                                       $find-range-of-transactions-helper),
               	                                   $vTree('root')($tree),
               	                                   $find-range-of-transactions-helper
               	                                 		($vTree('right')($tree),
               	                                   	 $start-date,
               	                                   	 $end-date,
               	                                   	 $find-range-of-transactions-helper)
               	                             )
               	                            else
               	                                if (xs:date($vTree('root')($tree)/@date) lt $start-date)
               then
               	                                 (
               	                                    $find-range-of-transactions-helper
               	                                      	               ($vTree('right')($tree),
               	                                       	                $start-date,
               	                                       	                $end-date,
               	                                       	                $find-range-of-transactions-helper)
               	                                 )
               	                                else
               	                                    if (xs:date($vTree('root')($tree)/@date) gt $end-date)
               then
               	                                     (
               	                                        $find-range-of-transactions-helper
               	            ($vTree('left')($tree),
               	             $start-date,
               	             $end-date,
               	             $find-range-of-transactions-helper)
               	                                     )
               	                                    else ()
               	         },
               
               
               $find-range-of-transactions :=
               	         function($tree as function(*)*,
               	                          $start-date as xs:date,
               	                          $end-date as xs:date
               	                         )
               	         {
               	             $find-range-of-transactions-helper
               	         		       ( $tree,
               	               	         $start-date,
               	                       	         $end-date,
               	                       	         $find-range-of-transactions-helper)
               	         },
               
               (:
               As tree-nodes are inserted into a BST, a comparison is made between
               the value being inserted and the value in the tree's root node. How should
               the comparison be done? That depends on the type of the data contained in a tree-node.
               Comparing two integers is different than comparing two tree fragments.
               So, the insert function must be provided with an appropriate comparator. For
               the case of bank transactions, a date comparison is needed.
               Here is an appropriate comparator function:
               :)
               $transaction-less-than-comparator :=
               	        function( $arg1  as element(transaction),
               	                          $arg2  as element(transaction)
               	                        ) as xs:boolean
               	        {
               	              xs:date($arg1/@date) lt xs:date($arg2/@date)
               	        }
               
               
               
               (:  At last, we finalize this big, outermost *let* clause with a *return* clause
               that expresses the intent of the users of the BST data-type.
               We want to get all transactions in the period:
               15th March 2012 to 15th May 2012.
               :)
               
               return (
               $find-range-of-transactions
               ($vTree('populate')
               ((), //transaction, $transaction-less-than-comparator),
               xs:date('2012-03-15'),
               xs:date('2012-05-15')
               )
               )   "/&gt;
               &lt;/xsl:template&gt;
               &lt;/xsl:stylesheet&gt;        
            </div>
            
         </div>
         <div class="para e614">
            <div class="emphasis e615" role="bold">The BST XPath code -- as an XQuery module</div> (XPathFunctionLibrary.xpath)
            -- see how a 
            <div class="emphasis e616">map</div> is created in the return clause:
         </div>
         <div class="para e617">
            
            <div class="programlisting e618" xml:space="preserve">
               module namespace BST = "BST";
               
               declare variable $BST:vTree :=
               
               let
               (:
               The purpose of create is to return an empty tree.
               
               It returns a sequence of functions,
               - the first function represents the root of a tree,
               - the second function represents the left subtree,
               - and the third function represents the right subtree.
               The value of each function is an empty sequence.
               :)
               $create := (
               function() { () }      (: root :),
               function() { () }      (: left :),
               function() { () }      (: right :)
               ),
               
               
               (:
               empty() returns a boolean value,
               indicating whether $tree is empty.
               
               $tree is empty in either of these two cases:
               1. $tree is the empty sequence (it doesn't contain any functions).
               2. $tree contains a sequence of three functions, but the first
               function - representing the root - is empty (i.e., if you invoke the
               first function it returns the empty sequence).
               :)
               $empty := function($tree as function(*)*)
               {
               empty($tree) or empty($tree[1]())
               },
               
               
               (:
               root()returns the value of the root node.
               
               This function takes one argument, $tree. Since $tree
               is represented by a sequence of functions, returning the
               value of the root node actually means returning the value of
               the function that corresponds to the root node.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the first function in $tree  is returned (recall
               that a tree is represented by a sequence of functions, the first
               function representing the root of the tree).
               
               Note: $tree[1] is the first function whereas
               $tree[1]() is the *value* of executing the first function.
               :)
               $root := function($tree as function(*)*)
               {
               if ($empty($tree))
               then ()
               else $tree[1]()
               },
               
               
               (:
               left()returns the left subtree.
               
               This function takes one argument, $tree. Since $tree is represented
               by a sequence of functions, returning the left subtree
               actually means returning the value of executing the function that corresponds
               to the left subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the second function in $tree is returned (recall
               that a tree is represented by a sequence of functions, the second
               function representing the left subtree).
               
               Note: $tree[2] is the second function whereas
               $tree[2]() is the *value* of executing the second function.
               :)
               $left := function($tree as function(*)*)
               {
               if ($empty($tree)) then ()
               else
               if ($empty($tree[2])) then ()
               else $tree[2]()
               },
               
               
               (:
               right() returns the right subtree.
               
               This function takes one argument, $tree. Since $tree is represented
               by a sequence of functions, returning the right subtree actually
               means returning the value of executing the function that corresponds to the
               right subtree.
               
               If $tree is empty then the empty sequence is returned. Otherwise
               the *value* of executing the third function in $tree is returned (recall
               that a tree is represented by a sequence of functions, the third
               function representing the right subtree).
               :)
               $right := function($tree as function(*)*)
               {
               if ($empty($tree)) then ()
               else
               if ($empty($tree[3])) then ()
               else $tree[3]()
               },
               
               
               $numeric-less-than-comparator :=
               	         function( $arg1 as xs:decimal,
               	                           $arg2 as xs:decimal
               	                         ) as xs:boolean
               	         {
               	               $arg1  lt   $arg2
               	         },
               
               
               (:
               insert() takes a $tree (BST) and a $item and produces a new BST that is the result
               of inserting $item as a tree-node in $tree.  A BST is a persistent (functional) data-type.
               Insertions or deletions are never done “in place” – instead a new BST is produced.
               
               The new node is inserted at:
               - if $tree is empty then as root node.
               - if the value of $item is less than the value of  the root node then
               the new tree-node is inserted into the left subtree (note the recursive definition)
               - else the new tree-node is inserted into the right subtree (again note the recursive
               definition)
               
               Here are the steps taken if $tree is empty:
               - $item specified to be the result of  the  root function. That is, the root function,
               if invoked, it returns $item.
               - A left function is created such that, if invoked, will return an empty subtree.
               - A right function is created such that, if invoked, will return an empty subtree.
               
               The insert function is recursive. Recursion with anonymous functions requires
               a helper function as discussed before.
               :)
               $insert-helper :=
               	         function( $tree as function(*)*,
               	                          $item as item(),
               	                          $less-than-comparator as function(item(), item()) as xs:boolean,
               	                          $insert-helper
               	                         )
               	         {
               	         if ($empty($tree)) then
               	               (
               	                     function() {$item}     (: root :),
               	                     function() {()}            (: left :),
               	                     function() {()}            (: right :)
               	               )
               	          else if ($less-than-comparator($item, $root($tree))) then
               	               (
               	                     function() {$root($tree)}                           	(: root
               :),
               
               	                     function() {$insert-helper( $left($tree),
               	                                                                     $item,
               	                                                                     $less-than-comparator,
               	                                                                     $insert-helper)
               	                                        }   				(: left :),
               
               	                     function() {$right($tree)}                          	(: right
               :)
               	                )
               	          else
               	               (
               	                     function() {$root($tree)}                          	(: root
               :),
               	                     function() {$left($tree)}                           	(: left
               :),
               
               	                     function() {$insert-helper( $right($tree),
               	                                                                     $item,
               	                                                                     $less-than-comparator,
               	                                                                     $insert-helper)
               	                                          }      				  (: right :)
               	                )
               	         },
               
               
               $insert :=
               	         function ( $tree as function(*)*,
               	                           $item as item(),
               	                           $less-than-comparator as function(item(), item()) as xs:boolean
               	                         )
               	         {
               	               $insert-helper($tree, $item, $less-than-comparator, $insert-helper)
               	         },
               
               
               (:
               print() produces an XML document that represents the BST $tree.
               
               The XML document produced by  print()  consists of:
               1. A root element that represents the value of executing the root function.
               2. A left element that represents the value of print() on the left subtree
               (note the recursive definition).
               3. A right element that represents the value of print() on the right subtree
               (note the recursive definition).
               
               The $print-helper function produces the markup
               as a string and then the $printer function converts
               this string into an XML document by calling the  parse-xml() function.
               :)
               $print-helper :=
               	         function ( $tree as function(*)*,
               	                           $print-helper
               	                          )
               	                          as xs:string?
               	         {
               	         if (not($empty($tree))) then
               	                 concat('&lt;tree&gt;',
               	                                    '&lt;root&gt;',
               	                                          $root($tree),
               	                                    '&lt;/root&gt;',
               	                                    '&lt;left&gt;',
               	                                          $print-helper($left($tree),$print-helper),
               	                                    '&lt;/left&gt;',
               	                                    '&lt;right&gt;',
               	                                          $print-helper($right($tree),$print-helper),
               	                                    '&lt;/right&gt;',
               	                            '&lt;/tree&gt;'
               	                           )
               	          else ()
               	          },
               
               
               $print := function ($tree as function(*)*)
               {parse-xml($print-helper($tree, $print-helper))/*},
               
               
               (:
               populate() produces a new tree from its BST argument $tree by inserting
               the value of the head() of the sequence $items onto $tree and then inserting
               the tail() of the sequence $items onto the result.
               :)
               $populate-helper :=
               	         function ( $tree as function(*)*,
               	                           $items as item()*,
               	                           $less-than-comparator as function(item(), item()) as xs:boolean,
               	                           $populate-helper
               	                         )
               	         {
               	             if (empty($items)) then $tree
               	             else
               	                  $populate-helper( $insert($tree, $items[1], $less-than-comparator),
               	                                                    $items[position() gt 1],
               	                                                    $less-than-comparator,
               	                                                    $populate-helper
               	                                                  )
               	         },
               
               
               $populate :=
               	         function( $tree as function(*)*,
               	                           $items as item()*,
               	                           $less-than-comparator as function(item(), item()) as xs:boolean
               	                         )
               	         {$populate-helper($tree, $items, $less-than-comparator, $populate-helper)}
               
               	  (: Finally, make the function libary :)
               	 return
               map {'create'   := $create,
               'empty'    := $empty,
               
               'root'     := $root,
               'left'     := $left,
               'right'    := $right,
               
               'insert'   := $insert,
               
               'populate' := $populate,
               'print'    := $print,
               
               'numeric-less-than-comparator'     := $numeric-less-than-comparator
               }
               ;        
            </div>
            
         </div>
         <div class="para e619">
            <div class="emphasis e620" role="bold">Here is the XQuery consuming code, that solves the bank
               transactions problem
            </div>: 
         </div>
         <div class="para e621">
            
            <div class="programlisting e622" xml:space="preserve">
               import module namespace bst="BST" at "XPathFunctionLibrary.xpath";
               
               declare variable $vDoc := doc('transactions.xml');
               
               
               (: The Tree Function Library :)
               (:
               Finally, the solution of the original problem.
               Task: find all the bank transactions in the range 2012-03-15 to 2012-05-15.
               :)
               let $find-range-of-transactions-helper :=
               	        function( $tree as function(*)*,
               	                          $start-date as xs:date,
               	                          $end-date as xs:date,
               	                          $find-range-of-transactions-helper
               	                )
               	                as element(transaction)*
               	        {
               	            if (empty($tree)) then ()
               	            else
               	                if (xs:date($bst:vTree('root')($tree)/@date) eq $start-date) then
               	                     (
               	                            $bst:vTree('root')($tree),
               	                            $find-range-of-transactions-helper
               	                        		        ($bst:vTree('right')($tree),
               	                                   	 $start-date,
               	                                     $end-date,
               	                                     $find-range-of-transactions-helper)
               	                     )
               	                    else
               	                        if (xs:date($bst:vTree('root')($tree)/@date) eq $end-date)
               then
               	                          (
               	                                 $find-range-of-transactions-helper
               	                             	            ($bst:vTree('left')($tree),
               	                                       	   $start-date,
               	                                      	   $end-date,
               	                                       	   $find-range-of-transactions-helper),
               	                                 $bst:vTree('root')($tree)
               	                          )
               	                        else
               	                            if (
               	                                (xs:date($bst:vTree('root')($tree)/@date) gt $start-date)
               	                                 and
               	                                (xs:date($bst:vTree('root')($tree)/@date) lt $end-date))
               then
               	                             (
               	                                   $find-range-of-transactions-helper
               	                                   		($bst:vTree('left')($tree),
               	                                       $start-date,
               	                                       $end-date,
               	                                       $find-range-of-transactions-helper),
               	                                   $bst:vTree('root')($tree),
               	                                   $find-range-of-transactions-helper
               	                                 		($bst:vTree('right')($tree),
               	                                   	 $start-date,
               	                                   	 $end-date,
               	                                   	 $find-range-of-transactions-helper)
               	                             )
               	                            else
               	                                if (xs:date($bst:vTree('root')($tree)/@date) lt $start-date)
               then
               	                                 (
               	                                    $find-range-of-transactions-helper
               	                                      	               ($bst:vTree('right')($tree),
               	                                       	                $start-date,
               	                                       	                $end-date,
               	                                       	                $find-range-of-transactions-helper)
               	                                 )
               	                                else
               	                                    if (xs:date($bst:vTree('root')($tree)/@date)
               gt $end-date) then
               	                                     (
               	                                        $find-range-of-transactions-helper
               	            ($bst:vTree('left')($tree),
               	             $start-date,
               	             $end-date,
               	             $find-range-of-transactions-helper)
               	                                     )
               	                                    else ()
               	         },
               
               
               $find-range-of-transactions :=
               	         function($tree as function(*)*,
               	                          $start-date as xs:date,
               	                          $end-date as xs:date
               	                         )
               	         {
               	             $find-range-of-transactions-helper
               	         		       ( $tree,
               	               	         $start-date,
               	                       	         $end-date,
               	                       	         $find-range-of-transactions-helper)
               	         },
               
               (:
               As tree-nodes are inserted into a BST, a comparison is made between
               the value being inserted and the value in the tree's root node. How should
               the comparison be done? That depends on the type of the data contained in a tree-node.
               Comparing two integers is different than comparing two tree fragments.
               So, the insert function must be provided with an appropriate comparator. For
               the case of bank transactions, a date comparison is needed.
               Here is an appropriate comparator function:
               :)
               $transaction-less-than-comparator :=
               	        function( $arg1  as element(transaction),
               	                          $arg2  as element(transaction)
               	                        ) as xs:boolean
               	        {
               	              xs:date($arg1/@date) lt xs:date($arg2/@date)
               	        }
               
               
               
               (:  At last, we finalize this big, outermost *let* clause with a *return* clause
               that expresses the intent of the users of the BST data-type.
               We want to get all transactions in the period:
               15th March 2012 to 15th May 2012.
               :)
               
               return (
               $find-range-of-transactions
               ($bst:vTree('populate')
               ((), $vDoc//transaction, $transaction-less-than-comparator),
               xs:date('2012-03-15'),
               xs:date('2012-05-15')
               )
               )        
            </div>
            
         </div>
      </div><a name="References:ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e623">
         <div class="title e624">References:</div>
         <div class="bibliomixed e625" xml:id="BST">
            
            <div class="emphasis e626">Binary Search Tree as defined by Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e627" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Binary_search_tree" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Binary_search_tree
            </div>
            
         </div>
         <div class="bibliomixed e628" xml:id="Closure">
            
            <div class="emphasis e629">Closure (computer science) -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e630" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Binary_search_tree" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Binary_search_tree
            </div>
            
         </div>
         <div class="bibliomixed e631" xml:id="Costello">
            
            <div class="emphasis e632">Pearls of XSLT and XPath 3.0 Design</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e633" xlink:actuate="onRequest" xlink:href="http://www.xfront.com/Pearls-of-XSLT-and-XPath-3-0-Design.pdf" xlink:show="new" xlink:type="simple">
               http://www.xfront.com/Pearls-of-XSLT-and-XPath-3-0-Design.pdf
            </div>
            
         </div>
         <div class="bibliomixed e634" xml:id="DivConq">
            
            <div class="emphasis e635">Divide and conquer algorithm -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e636" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm
            </div>
            
         </div>
         <div class="bibliomixed e637" xml:id="FuncComp">
            
            <div class="emphasis e638">Function composition -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e639" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Function_composition" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Function_composition
            </div>
            
         </div>
         <div class="bibliomixed e640" xml:id="Nova">
            
            <div class="emphasis e641">Recursion with anonymous (inline) functions in XPath 3.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e642" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2012/10/15/recursion-with-anonymous-inline-functions-in-xpath-3-0-2/" xlink:show="new" xlink:type="simple">
               http://dnovatchev.wordpress.com/2012/10/15/recursion-with-anonymous-inline-functions-in-xpath-3-0-2/
            </div>
            
         </div>
         <div class="bibliomixed e643" xml:id="HOF">
            
            <div class="emphasis e644">Higher-order function -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e645" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Higher-order_function" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Higher-order_function
            </div>
            
         </div>
         <div class="bibliomixed e646" xml:id="Nova2">
            
            <div class="emphasis e647">Recursion with anonymous (inline) functions in XPath 3.0 — Part II</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e648" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2013/04/08/recursion-with-anonymous-inline-functions-in-xpath-3-0-part-ii/" xlink:show="new" xlink:type="simple">
               http://dnovatchev.wordpress.com/2013/04/08/recursion-with-anonymous-inline-functions-in-xpath-3-0-part-ii/
            </div>
            
         </div>
         <div class="bibliomixed e649" xml:id="Nova3">
            
            <div class="emphasis e650">The Binary Search Tree Data Structure–having fun with XPath 3.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e651" xlink:actuate="onRequest" xlink:href="http://dnovatchev.wordpress.com/2012/01/09/the-binary-search-tree-data-structurehaving-fun-with-xpath-3-0/" xlink:show="new" xlink:type="simple">
               http://dnovatchev.wordpress.com/2012/01/09/the-binary-search-tree-data-structurehaving-fun-with-xpath-3-0/
            </div>
            
         </div>
         <div class="bibliomixed e652" xml:id="PartApp">
            
            <div class="emphasis e653">Partial function application -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e654" xlink:actuate="onRequest" xlink:href="http://rosettacode.org/wiki/Partial_function_application" xlink:show="new" xlink:type="simple">
               http://rosettacode.org/wiki/Partial_function_application
            </div>
            
         </div>
         <div class="bibliomixed e655" xml:id="Recurs">
            
            <div class="emphasis e656">Recursion (computer science) -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e657" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms
            </div>
            
         </div>
         <div class="bibliomixed e658" xml:id="Saxon">
            
            <div class="emphasis e659">The Saxon XSLT/XQuery/XPath Processor</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e660" xlink:actuate="onRequest" xlink:href="http://www.saxonica.com" xlink:show="new" xlink:type="simple">
               http://www.saxonica.com
            </div>
            
         </div>
         <div class="bibliomixed e661" xml:id="Snelson">
            
            <div class="emphasis e662">Adding Recursive Inline Functions to XQuery 1.1 and XPath 2.1</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e663" xlink:actuate="onRequest" xlink:href="http://john.snelson.org.uk/adding-recursive-inline-function-to-xquery-11" xlink:show="new" xlink:type="simple">
               http://john.snelson.org.uk/adding-recursive-inline-function-to-xquery-11
            </div>
            
         </div>
         <div class="bibliomixed e664" xml:id="Snelson2">
            
            <div class="emphasis e665">W3C Bugzilla: Bug 8662 - [XQ31ReqUC] Requirement: Recursive inline functions </div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e666" xlink:actuate="onRequest" xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=8662" xlink:show="new" xlink:type="simple">
               https://www.w3.org/Bugs/Public/show_bug.cgi?id=8662
            </div>
            
         </div>
         <div class="bibliomixed e667" xml:id="TailCall">
            
            <div class="emphasis e668">Tail call -- Wikipedia</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e669" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Tail_call" xlink:show="new" xlink:type="simple">
               http://en.wikipedia.org/wiki/Tail_call
            </div>
            
         </div>
         <div class="bibliomixed e670" xml:id="Walmsley">
            
            <div class="emphasis e671">FunctX XSLT 2.0 and XQuery 1.0 Function Libraries</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e672" xlink:actuate="onRequest" xlink:href="http://www.functx.com/" xlink:show="new" xlink:type="simple">
               http://www.functx.com/
            </div>
            
         </div>
         <div class="bibliomixed e673" xml:id="XDM3.0">
            
            <div class="emphasis e674">XQuery and XPath Data Model 3.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e675" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xpath-datamodel-30/
            </div>
            
         </div>
         <div class="bibliomixed e676" xml:id="XPath1.0">
            
            <div class="emphasis e677">XML Path Language (XPath) Version 1.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e678" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xpath/
            </div>
            
         </div>
         <div class="bibliomixed e679" xml:id="XPath2.0">
            
            <div class="emphasis e680">XML Path Language (XPath) 2.0 (Second Edition)</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e681" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath20/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xpath20/
            </div>
            
         </div>
         <div class="bibliomixed e682" xml:id="XPath3.0">
            
            <div class="emphasis e683">XML Path Language (XPath) 3.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e684" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xpath-30/
            </div>
            
         </div>
         <div class="bibliomixed e685" xml:id="XSLT1.0">
            
            <div class="emphasis e686">XSL Transformations (XSLT) Version 1.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e687" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xslt
            </div>
            
         </div>
         <div class="bibliomixed e688" xml:id="XSLT2.0">
            
            <div class="emphasis e689">XSL Transformations (XSLT) Version 2.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e690" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt20/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xslt20/
            </div>
            
         </div>
         <div class="bibliomixed e691" xml:id="XSLT3.0">
            
            <div class="emphasis e692">XSL Transformations (XSLT) Version 3.0</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e693" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-30/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xslt-30/
            </div>
            
         </div>
         <div class="bibliomixed e694" xml:id="XQuery1.0">
            
            <div class="emphasis e695">XQuery 1.0: An XML Query Language (Second Edition)</div>, 
            at: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e696" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple">
               http://www.w3.org/TR/xquery/
            </div>
            
         </div>
      </div>
   </div>
</div>