<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#gXMLaNewApproachtoCultivatingXMLTreesinJavaANCHOR" name="gXMLaNewApproachtoCultivatingXMLTreesinJavaTOC">gXML, a New Approach to Cultivating XML Trees in Java</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheProblem(s)withXMLTreeAPIsinJavaANCHOR" name="TheProblem(s)withXMLTreeAPIsinJavaTOC">The Problem(s) with XML Tree APIs in Java</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#gXMLDesignConsiderationsANCHOR" name="gXMLDesignConsiderationsTOC">gXML Design Considerations</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheHandle/BodyPatternANCHOR" name="TheHandle/BodyPatternTOC">The Handle/Body Pattern</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#The'G'in'XML'ANCHOR" name="The'G'in'XML'TOC">The 'G' in 'XML'</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheXQueryDataModelANCHOR" name="TheXQueryDataModelTOC">The XQuery Data Model</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheImmutableApproachANCHOR" name="TheImmutableApproachTOC">The Immutable Approach</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ThegXMLCoreANCHOR" name="ThegXMLCoreTOC">The gXML Core</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UntypedImmutableANCHOR" name="UntypedImmutableTOC">Untyped, Immutable</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MutabilityANCHOR" name="MutabilityTOC">Mutability</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaAwarenessANCHOR" name="SchemaAwarenessTOC">Schema Awareness</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BuildingBridgeswithgXMLANCHOR" name="BuildingBridgeswithgXMLTOC">Building Bridges with gXML</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UntypedImmutableANCHOR" name="UntypedImmutableTOC">Untyped, Immutable</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MutabilityANCHOR" name="MutabilityTOC">Mutability</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaAwarenessANCHOR" name="SchemaAwarenessTOC">Schema Awareness</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#BridgeTrafficANCHOR" name="BridgeTrafficTOC">Bridge Traffic</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ProcessingXMLwithgXMLANCHOR" name="ProcessingXMLwithgXMLTOC">Processing XML with gXML</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StatefulANCHOR" name="StatefulTOC">Stateful</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StatelessANCHOR" name="StatelessTOC">Stateless</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DevelopingandRefactoringANCHOR" name="DevelopingandRefactoringTOC">Developing and Refactoring</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NewDevelopmentANCHOR" name="NewDevelopmentTOC">New Development</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Refactoring:ProcessingMutableTreesANCHOR" name="Refactoring:ProcessingMutableTreesTOC">Refactoring: Processing Mutable Trees</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#Refactoring:ProcessingImmutableTreesANCHOR" name="Refactoring:ProcessingImmutableTreesTOC">Refactoring: Processing Immutable Trees</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AdvancingtheStateoftheArtANCHOR" name="AdvancingtheStateoftheArtTOC">Advancing the State of the Art</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#gXMLSolution(s)ANCHOR" name="gXMLSolution(s)TOC">gXML Solution(s)</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#gXML:SourceANCHOR" name="gXML:SourceTOC">gXML: Source</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Attribute</div>
         <div class="singletermTERMS">AtomBridge</div>
         <div class="singletermTERMS">attribute()</div>
         <div class="singletermTERMS">AxisNavigator</div>
         <div class="singletermTERMS">Axiom 1.2.8 API</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
         <div class="singletermTERMS">alewis@tibco.com</div>
         <div class="singletermTERMS">Amelia</div>
         <div class="singletermTERMS">AxiOM</div>
         <div class="singletermTERMS">A.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">boolean moveToFirstChildElement()</div>
         <div class="singletermTERMS">bridgekit</div>
         <div class="singletermTERMS">bridgetest</div>
         <div class="singletermTERMS">Bookmark&lt;N&gt;</div>
         <div class="singletermTERMS">Bridge</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Comment</div>
         <div class="singletermTERMS">Cursor</div>
         <div class="singletermTERMS">Cursor&lt;N&gt; newCursor(N context)</div>
         <div class="singletermTERMS">ContentHandler</div>
         <div class="singletermTERMS">CursorOnModel</div>
         <div class="singletermTERMS">CursorOnTypedModel</div>
         <div class="singletermTERMS">Cursor&lt;N&gt;</div>
         <div class="singletermTERMS">convert</div>
         <div class="singletermTERMS">Converter</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Document</div>
         <div class="singletermTERMS">DocumentHandler</div>
         <div class="singletermTERMS">DocumentHandler&lt;N&gt;</div>
         <div class="singletermTERMS">DefaultDocumentHandler&lt;N&gt;</div>
         <div class="singletermTERMS">Design Patterns</div>
         <div class="singletermTERMS">does not</div>
         <div class="singletermTERMS">Document Object Model Technical Reports</div>
         <div class="singletermTERMS">DOM4J Introduction</div>
         <div class="singletermTERMS">Document Object Model</div>
         <div class="singletermTERMS">DOM</div>
         <div class="singletermTERMS">DOM4J</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Element</div>
         <div class="singletermTERMS">eric@tibco.com</div>
         <div class="singletermTERMS">Eric</div>
         <div class="singletermTERMS">E.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">FragmentBuilder</div>
         <div class="singletermTERMS">FragmentBuilder&lt;N&gt;</div>
         <div class="singletermTERMS">Facade</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getNamespaceURI(N)</div>
         <div class="singletermTERMS">getLocalName(N)</div>
         <div class="singletermTERMS">getStringValue(N)</div>
         <div class="singletermTERMS">getNodeKind(N)</div>
         <div class="singletermTERMS">getMutableContext()</div>
         <div class="singletermTERMS">getTypedContext()</div>
         <div class="singletermTERMS">GenericProcessor&lt;Node&gt;</div>
         <div class="singletermTERMS">GenericProcessor&lt;XmlNode&gt;</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">Handle/Body</div>
         <div class="singletermTERMS">Handle/Body design pattern</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">Iterable</div>
         <div class="singletermTERMS">input-output</div>
         <div class="singletermTERMS">interoperability</div>
         <div class="singletermTERMS">is-a</div>
         <div class="singletermTERMS">ipso facto</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">java.util.List&lt;QName&gt;</div>
         <div class="singletermTERMS">Jaxen</div>
         <div class="singletermTERMS">JDOM v1.1.1 API Specification</div>
         <div class="singletermTERMS">JDOM</div>
         <div class="singletermTERMS">Johnson</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Lava Flow</div>
         <div class="singletermTERMS">Lava Flow anti-pattern</div>
         <div class="singletermTERMS">Lewis</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">Model</div>
         <div class="singletermTERMS">Model&lt;N&gt; getModel()</div>
         <div class="singletermTERMS">MutableContext</div>
         <div class="singletermTERMS">MutableModel</div>
         <div class="singletermTERMS">MutableCursor</div>
         <div class="singletermTERMS">MetaBridge</div>
         <div class="singletermTERMS">multiplicity</div>
         <div class="singletermTERMS">much</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">Namespace</div>
         <div class="singletermTERMS">N getFirstChildElement(N context)</div>
         <div class="singletermTERMS">NodeSource</div>
         <div class="singletermTERMS">NodeFactory</div>
         <div class="singletermTERMS">Node</div>
         <div class="singletermTERMS">N process(N, Model&lt;N&gt;)</div>
         <div class="singletermTERMS">null</div>
         <div class="singletermTERMS">N, Model&lt;N&gt;</div>
         <div class="singletermTERMS">NodeInformer</div>
         <div class="singletermTERMS">NodeNavigator</div>
         <div class="singletermTERMS">Namespaces in XML</div>
         <div class="singletermTERMS">Nota bene</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">Namespaces in XML 1.0 (Second Edition)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">Object</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">ProcessingInstruction</div>
         <div class="singletermTERMS">ProcessingContext</div>
         <div class="singletermTERMS">ProcessingContextFactory</div>
         <div class="singletermTERMS">processor</div>
         <div class="singletermTERMS">Processing XML with Java</div>
         <div class="singletermTERMS">Principal Architect</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">String getStringValue(N context)</div>
         <div class="singletermTERMS">String getStringValue()</div>
         <div class="singletermTERMS">SequenceBuilder</div>
         <div class="singletermTERMS">SmSchema</div>
         <div class="singletermTERMS">startElement()</div>
         <div class="singletermTERMS">StaticConverter</div>
         <div class="singletermTERMS">stream()</div>
         <div class="singletermTERMS">Singleton</div>
         <div class="singletermTERMS">Senior Architect</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">Text</div>
         <div class="singletermTERMS">TypedContext</div>
         <div class="singletermTERMS">TypedModel</div>
         <div class="singletermTERMS">TypedCursor</div>
         <div class="singletermTERMS">text()</div>
         <div class="singletermTERMS">three to ten times the space</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">untyped atomic</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">variability</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XmlNode</div>
         <div class="singletermTERMS">XmlAtom</div>
         <div class="singletermTERMS">XmlAtomBridge</div>
         <div class="singletermTERMS">xpath.impl</div>
         <div class="singletermTERMS">xpath</div>
         <div class="singletermTERMS">XT</div>
         <div class="singletermTERMS">XML Infoset</div>
         <div class="singletermTERMS">Xalan-Java</div>
         <div class="singletermTERMS">XalanDTM</div>
         <div class="singletermTERMS">XML Information Set (Second Edition)</div>
         <div class="singletermTERMS">XML Path Language (XPath), Version 1.0</div>
         <div class="singletermTERMS">XML Schema Part 1: Structures Second Edition</div>
         <div class="singletermTERMS">XML Schema Part 2: Datatypes Second Edition</div>
         <div class="singletermTERMS">XOM 1.2.5</div>
         <div class="singletermTERMS">XQuery 1.0 and XPath 2.0 Data Model (XDM)</div>
         <div class="singletermTERMS">XSL Transformations (XSLT), Version 1.0</div>
         <div class="singletermTERMS">XT</div>
         <div class="singletermTERMS">XQuery Data Model</div>
         <div class="singletermTERMS">XOM</div>
         <div class="singletermTERMS">XPath</div>
         <div class="singletermTERMS">XML Infoset</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="gXMLaNewApproachtoCultivatingXMLTreesinJavaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="Bal2010Lewi0417">
      <div class="title e1">gXML, a New Approach to Cultivating XML Trees in Java</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2010</div>
            <div class="confdates e5">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">A number of issues facing the use of XML tree models in Java
               are enumerated: multiplicity, interoperability, variability,
               and weight.  The gXML API, following the 
               <div class="emphasis e8">Handle/Body</div>
               design pattern and conforming to the XQuery Data Model specification
               
               <div class="xref e9" linkend="XDM"></div>, is
               proposed as a solution to these problems, and as a platform for
               advancing the state of the art for XML in Java.  gXML is not
               a new tree model, but a unified API and model following a
               rigorous, external specification, which can be used with any
               tree model for which a "bridge" has been developed.  Applications
               and processors targeting the gXML API may then use any supported
               tree model, as appropriate for the task.
            </div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Amelia</div>
               <div class="othername e13">A.</div>
               <div class="surname e14">Lewis</div>
            </div>
            <div class="personblurb e15">
               <div class="para e16">Amelia Lewis is a senior architect with the TIBCO/Extensibility
                  division of TIBCO Software Inc.  Her primary focus, since 2000,
                  has been XML technologies, inside and outside TIBCO.  She has
                  been active in a variety of XML-related specifications efforts
                  and developer-oriented XML mailing lists; she has extensive
                  experience with implementation of a variety of XML technologies,
                  using most of the tree models mentioned in this paper.
               </div>
            </div>
            <div class="affiliation e17">
               <div class="jobtitle e18">Senior Architect</div>
               <div class="orgname e19">TIBCO Software Inc.</div>
            </div>
            <div class="email e20">alewis@tibco.com</div>
         </div>
         <div class="author e21">
            <div class="personname e22">
               <div class="firstname e23">Eric</div>
               <div class="othername e24">E.</div>
               <div class="surname e25">Johnson</div>
            </div>
            <div class="personblurb e26">
               <div class="para e27">Eric Johnson is a principal architect at TIBCO Software Inc. Eric joined TIBCO
                  in 2000, a part of TIBCO's acquisition of Extensibility, an XML tools company.
                  While Eric now works in a variety of areas, including governance, build
                  architecture, and various standards including SOAP/JMS, SCA, and OSGi, he has
                  also maintained a strong interest in improving the core technologies that
                  TIBCO uses, especially those related to XML.
               </div>
            </div>
            <div class="affiliation e28">
               <div class="jobtitle e29">Principal Architect</div>
               <div class="orgname e30">TIBCO Software Inc.</div>
            </div>
            <div class="email e31">eric@tibco.com</div>
         </div>
         <div class="legalnotice e32">
            <div class="para e33">Copyright © 2010 TIBCO Software Inc.  All rights reserved.</div>
         </div>
         <div class="keywordset e34" role="author">
            <div class="keyword e35">XQuery Data Model</div>
            <div class="keyword e36">Handle/Body design pattern</div>
            <div class="keyword e37">Document Object Model</div>
            <div class="keyword e38">DOM</div>
            <div class="keyword e39">JDOM</div>
            <div class="keyword e40">DOM4J</div>
            <div class="keyword e41">AxiOM</div>
            <div class="keyword e42">XOM</div>
            <div class="keyword e43">XPath</div>
            <div class="keyword e44">XML Infoset</div>
         </div>
      </div>
      <div class="note e45" xml:id="acknowledgements">
         <div class="title e46">Acknowledgements</div>
         <div class="para e47">This paper describes concepts and source code originally
            developed by David G. Holmes, formerly of TIBCO Software Inc., without
            whose innovation and energy neither the paper nor the material that it
            describes would be possible.  David was the senior architect responsible
            for driving the development (over several iterations) of the gXML
            code base, and the original advocate of opening the source.
         </div>
      </div><a name="TheProblem(s)withXMLTreeAPIsinJavaANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e48" xml:id="introduction">
         <div class="title e49">The Problem(s) with XML Tree APIs in Java</div>
         <div class="para e50">Java was one of the first major programming languages with support for
            XML. It was one of the targets for the Interface Definition Language modules
            that were developed as the basis of the Document Object Model 
            <div class="xref e51" linkend="DOM"></div>. Early adoption helped to prove the capabilities of both XML
            and of Java, but as might be expected, early adoption also has its drawbacks.
            A number of developers using XML in Java have noted these problems. For
            instance, Dennis Sosnoski compared a number of tree models in a two-part
            investigation in 2001 and 2002 (see "XML and Java technologies: Document
            models, Part 1: Performance" 
            <div class="xref e52" linkend="DMPerf"></div> and "XML and Java
            technologies: Java Document Model Usage" 
            <div class="xref e53" linkend="DMUse"></div>). More
            recently, Elliotte Harold documented "What's Wrong with XML APIs" 
            <div class="xref e54" linkend="WhatsWrong"></div> as part of the development of the XOM 
            <div class="xref e55" linkend="XOM"></div> API. This analysis falls into that tradition, though it does not agree
            wholly with the previous analyses. We identify four classes of problem with
            existing tree model APIs.
         </div>
         <div class="para e56">The first problem is 
            <div class="emphasis e57">multiplicity</div>. For a variety of
            reasons, Java developers have not, on the whole, been enthusiastic partisans
            of the DOM. Alternatives were proposed early; Xalan 
            <div class="xref e58" linkend="Xalan"></div>,
            one of the major early XSLT processors, defined its own internal XML tree
            model (the Data Table Model 
            <div class="xref e59" linkend="XalanDTM"></div>) in preference to
            using the DOM. At present, there are at least five well-known tree models for
            XML in Java: DOM 
            <div class="xref e60" linkend="DOM"></div>, JDOM 
            <div class="xref e61" linkend="JDOM"></div>, DOM4J
            
            <div class="xref e62" linkend="DOM4J"></div>, XOM 
            <div class="xref e63" linkend="XOM"></div>, and AxiOM 
            <div class="xref e64" linkend="AxiOM"></div>, as well as an unknown number of proprietary APIs to the
            same purpose (the authors of this paper know of at least six such private
            APIs). Applications and processors written for one of these models are
            generally not usable with other models.
         </div>
         <div class="para e65">The second problem is 
            <div class="emphasis e66">interoperability</div>. The first
            tree model to appear on the scene has had a first mover advantage. Subsequent
            tree model designs have intended to address the shortcomings of the DOM, but
            not to interoperate with it (note that both DOM4J and AxiOM later added
            optional DOM interface implementations to address this
            problem—accepting the disadvantages of the DOM in order to achieve
            compatibility in this mode). Knowledge of the tricks and optimizations
            appropriate to one model do not transfer to other tree models. Though the
            successor models have all positioned themselves as better solutions than the
            DOM, they have not been adopted as widely. This is most likely due to the
            DOM's first mover advantage, and the consequent network effect: although other
            models may have technical advantages that make them more suitable than the DOM
            for a given application, in order to use those new models efficiently within
            the JVM, all parts of the application need to use the same tree model.
            Developers must solve a cruel equation in which the marginal benefits of
            switching from the DOM are typically low, whereas the marginal costs are
            always high. The alternatives seem to be to write multiple code paths to
            achieve the same purpose (with different tree models), or to wrap each node of
            each tree model in an application-specific abstraction. Some projects, such as
            Woden 
            <div class="xref e67" linkend="Woden"></div> and Jaxen 
            <div class="xref e68" linkend="Jaxen"></div>, have taken one
            or the other of these approaches in preference to adopting the DOM as the sole
            programming model.
         </div>
         <div class="para e69">The DOM, as the first XML tree model for Java, established the universe of
            discussion for design of tree models. Development of the DOM preceded the
            
            <div class="emphasis e70">Namespaces in XML</div> 
            <div class="xref e71" linkend="XMLNS"></div> and
            
            <div class="emphasis e72">XML Infoset</div> 
            <div class="xref e73" linkend="Infoset"></div> specifications.
            For backward compatibility, the DOM could never enforce these specifications,
            though it could enable them. Further development of the DOM may be
            characterized as too closely approaching the 
            <div class="emphasis e74">Lava Flow</div>
            
            <div class="xref e75" linkend="LavaFlow"></div> anti-pattern. Indeed, the DOM exposes fifteen
            "basic" abstractions (node types), compared to eleven in the Infoset, and
            seven in the XDM. Successor APIs have generally targeted the Infoset, but with
            widely varying interpretations. This is the problem of 
            <div class="emphasis e76">
               variability
            </div>. Each model exposes different property sets. The
            boundaries between lexical, syntactic, and semantic are drawn at different
            points. One consequence of this variability is that it is difficult or awkward
            to add support for specifications "higher in the stack." For instance, XPath
            1.0 
            <div class="xref e77" linkend="XPath1"></div> and XSLT 1.0 
            <div class="xref e78" linkend="XSLT1"></div> work
            perfectly adequately as external tools (one per tree model, or by generalizing
            the concept of "Node" to "Object"), and some models have built-in support (at
            least for XPath). XML Schema support (see 
            <div class="xref e79" linkend="WXS1"></div> and 
            <div class="xref e80" linkend="WXS2"></div>) is rarely found—a DOM Level 3 module supports it,
            but in a fashion that is not noted for ease of use, and the module is not
            widely implemented. Similar situations exist for specifications such as XQuery
            1.0, XPath 2.0, and XSLT 2.0. Even SOAP/XMLP is arguably under-supported.
            AxiOM, after all, is an entire XML tree model built largely so that the SOAP
            abstractions could be represented cleanly as extensions.
         </div>
         <div class="para e81">Finally, the problem of 
            <div class="emphasis e82">weight</div> plagues most of
            these tree models. The DOM itself is notoriously heavyweight, typically occupying
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e83" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/books/xmljava/chapters/ch09s05.html" xlink:show="new" xlink:type="simple">three to ten times the space</div>, in memory, that the—already
            verbose—XML occupies as a character stream, according to Harold's
            
            <div class="emphasis e84">Processing XML with Java</div> 
            <div class="xref e85" linkend="XMLInJava"></div>.
            Sucessor models have done better in this area. Dennis Sosnoski's evaluation,
            "Document Models Part 1: Performance" 
            <div class="xref e86" linkend="DMPerf"></div>, though dated,
            provides an excellent illustration of this problem. A large part of the
            problem lies in the unrestricted mutability of these models. All of the
            prominent XML tree models for Java must restrict programming to serial,
            synchronous access. A mutable tree model is effectively a mutable collection,
            so any changes made to it by a single writer may have disastrous effects upon
            multiple readers. Issues of weight cannot easily be addressed by storing the
            bulk of the document on disk, or by concurrent processing, because the
            document may be modified during processing.
         </div>
         <div class="para e87">There are alternatives: applications and processors with higher
            performance requirements are often written to abstractions that do not model
            XML as a tree, such as SAX, StAX, or XML data binding (in its various
            flavors). Sosnoski's article discusses some of these alternatives; Harold's
            presentation also notes both advantages and disadvantages. The chief drawback
            to these approaches is that they expose paradigms which are not as easily or
            intuitively understood as the tree model, which are more of a challenge for
            some developers. A tree model is preferred. A single model for navigation and
            interrogation seems best. To date, attempts to create this single model have
            proven suboptimal in most environments.
         </div>
      </div><a name="gXMLDesignConsiderationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e88" xml:id="gxml-overview">
         <div class="title e89">gXML Design Considerations</div>
         <div class="para e90">gXML is a new API for analyzing, creating, and manipulating XML in Java.
            It embodies the XQuery Data Model, and is consequently a tree-oriented API,
            but it does not introduce a new tree model comparable to existing models.
            Instead, it is intended to run over existing tree models, and to permit the
            introduction of new, specialized models optimized for a particular purpose.
            Its design rests on four pillars: the 
            <div class="emphasis e91">Handle/Body</div> design
            pattern, Java generics, the XQuery Data Model, and immutability for XML
            processing as a paradigm.  These four principles answer the four problems
            outlined above.
         </div><a name="TheHandle/BodyPatternANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e92" xml:id="gxml-handle-body">
            <div class="title e93">The Handle/Body Pattern</div>
            <div class="para e94">gXML makes extensive use of the 
               <div class="emphasis e95">Handle/Body</div> pattern
               (called the 
               <div class="emphasis e96">Bridge</div> pattern in 
               <div class="emphasis e97">Design
                  Patterns
               </div> 
               <div class="xref e98" linkend="GOF"></div>). This pattern provides a
               well-defined set of operations over an abstraction (the handle), which may
               then be adapted to specific implementations (the body). For gXML, the primary
               "handles" are the Model or Cursor, the Processing Context, the Node Factory in
               the mutable API, and the type (Meta) and typed-value (Atom) Bridges in the
               schema-aware API.
            </div>
            <div class="para e99">When presenting gXML to a new audience, one of the most common stumbling
               points is the distinction between 
               <div class="emphasis e100">Handle/Body</div> and
               
               <div class="emphasis e101">Wrapper</div> (called 
               <div class="emphasis e102">Facade</div> in
               
               <div class="emphasis e103">Design Patterns</div>). gXML 
               <div class="emphasis e104">does not</div> wrap
               every node in the tree. Applications and processors are presented with one new
               abstraction, represented by a single instance (a
               
               <div class="emphasis e105">Singleton</div> for model, or a single instance per tree for
               cursor). gXML adds very little weight to the existing tree model, compared to
               the significant additional weight added by the necessity to wrap every node in
               a tree. Although there is a cost (in memory and performance) to using the
               handles rather than directly manipulating the bodies, the benefits (in
               flexibility and capability) are more nearly commensurate: in exchange for a
               memory/performance impact measured in low single-digit percentages (for most tree
               model APIs), an application or processor gains the ability to manipulate all
               supported tree model APIs (currently three; more are anticipated).
            </div>
            <div class="para e106">There are a number of attractive consequences of using
               this design pattern. First, since applications and processors need not write
               separate code paths for different tree models, these models can be injected
               very late, even at runtime. That suggests that they can be compared, based on
               the application's or processor's requirements, and the tree model best suited
               to the problem at hand preferred. It also suggests that application and
               processor developers might have a sounder foundation to suggest improvements
               to developers of the models. Second, by bringing peace to these warring
               models, by allowing developers to choose a model based on technical merits
               
               <div class="emphasis e107">without</div> considering the importance of the network effect
               for the DOM, gXML also enables the creation of "niche" tree models for XML, models
               designed and optimized for particular use cases. In other words, by always
               using these handles for access, special-purpose bodies become more practical.
               These topics will be revisited in 
               <div class="xref e108" linkend="advancing-the-state-of-the-art"></div>, below.
            </div>
            <div class="para e109">gXML's use of the 
               <div class="emphasis e110">Handle/Body</div> pattern for XML tree
               models might be compared to the similar pattern used for database drivers in
               the Java Database Connection (JDBC) API. Each bridge may be viewed as
               equivalent to a vendor-specific driver.
            </div>
         </div><a name="The'G'in'XML'ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e111" xml:id="gxml-in">
            <div class="title e112">The 'G' in 'XML'</div>
            <div class="para e113">gXML makes extensive use of Java generics. First, it defines two common
               parameters, N and A. N is the "node" handle; A is the "atom" or "atomic value"
               handle. Furthermore, gXML makes extensive use of Java's built-in generics;
               APIs that accept or return collections typically use 
               <div class="code e114">Iterable</div> in
               their signatures (as opposed to counts, specialized objects with
               pseudo-iterators, single-use iterators, or arrays).
            </div>
            <div class="para e115">The use of generics is the primary answer, in gXML, to the problem of
               interoperability. By defining these parameters, particularly the &lt;N&gt;ode
               handle, each of the tree models can be viewed and manipulated through the lens
               of the XQuery Data Model. One notable consequence is that the enormous network
               effect created by the existence of parsers, processors, and applications that
               understand no model but the DOM, regardless of its fitness for their domain of
               operation, no longer matters to developers of gXML-based processors and
               applications. gXML includes a DOM bridge; it is thereby able to leverage that
               network effect. Every bridge added, adds to the network effect—though
               not, as a rule, for a single document: conversion from model to model remains
               expensive.
            </div>
         </div><a name="TheXQueryDataModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e116" xml:id="gxml-xdm">
            <div class="title e117">The XQuery Data Model</div>
            <div class="para e118">Perhaps the most important driver for the development of gXML was the
               desire to have a Java API that embodied the XQuery Data Model.  The XDM is
               more rigorous than its predecessor, the XML Infoset specification (which
               was driven in part from a need to model existing APIs, including DOM, SAX,
               XPath, and Namespaces in XML).  It is conceptually complete, and defined in
               a context that permits type definition, navigation operations, and more
               advanced functions.  This rigorous, well-defined specification was adopted
               as the basis for the API, and represents gXML's answer to the problem of
               variability.  Is a property or concept in the XDM specification?  Then it
               should be in the gXML API.  If it is not in the specification, then either
               it should not be exposed in the API, or it should be compatible with the
               well-specified API. For instance, the entire mutable API was added as an
               extension; XQuery does not define operations that modify trees.
            </div>
            <div class="para e119">Another important reason to adopt the XQuery Data Model is that it
               provides the first well-integrated access to XML Schema information
               (one might argue that XQuery and XSLT2 provide the "missing language" for
               the XML Schema type system).  A great deal of XML processing has no need to
               concern itself with validation, typing, and particularly with the post-Schema
               validation infoset; those applications and processors that need it, however,
               need it very badly.  gXML defines a common model for XML Schema, compatible
               with the XDM's definition and use of XML Schema types and typed values, as a
               standard extension.
            </div>
            <div class="para e120">gXML is not the only model to provide support for XML Schema, but the
               schema-aware extensions in gXML can be implemented for any tree model, and are
               exposed via APIs that are clearly related to (usually extensions of) the core
               gXML APIs. In other words, by addressing the problem of variability via
               adherence to and conformance with the XQuery Data Model Specification, gXML
               enables the development of a "next wave" of XML processing technologies, based
               on XPath 2.0, XSLT 2.0, and XQuery 1.0 (including the new generation of
               XQuery-conformant databases).
            </div>
         </div><a name="TheImmutableApproachANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e121" xml:id="gxml-immutable">
            <div class="title e122">The Immutable Approach</div>
            <div class="para e123">In the experience of the developers of gXML, most of the nodes in any
               given XML instance document are never modified. These nodes need not be
               mutable—but because some nodes are modified in the common paradigm of
               XML processing, all nodes must be defined to be mutable. The core gXML API
               dispenses with mutability. Instead, it promotes a paradigm in which a received
               or generated XML document is an input, and the XML supplied to other processes
               (in the same VM, on the same machine, or somewhere else on the network) is a
               transformation of the input. This approach addresses the problem of weight. In
               combination with the enabling of custom, potentially domain-specific XML tree
               models accessed via a gXML bridge, the immutable paradigm (over an immutable
               tree model) can achieve optimizations not possible for a tree model in which
               the existence of mutability militates against caching, compaction, and
               deferred loading. It is not possible, at this point, to quantify the potential
               performance benefits rigorously because the pure-immutable model remains
               hypothetical (other priorities have taken precedence). Here we
               speculate.
            </div>
            <div class="para e124">Such a hypothetical immutable model would not need to guard against
               modification of a document in one thread while another thread reads it.  It
               would provide guarantees that would permit processing of large documents to
               be parallelized; an immutable, late-loading model might be able to provide
               access to XML documents of a size infeasible for mutable models.  A certain
               number of these optimizations are available even for bridges over mutable
               models; if the convention encourages immutability, then processors can define
               their operations only when the convention is adhered to, warning users that
               breaking the convention may lead to undefined (and incorrect) results.
            </div>
            <div class="para e125">Immutability enables performance enhancements—for instance,
               models in memory which occupy a fraction of the size of the XML as a character
               stream rather than a multiple of its size; concurrent processing of XML
               documents; storage of the bulk of a document on disk with indexing and a very
               light footprint in memory. We've noticed unanticipated potential as well: if
               there is no requirement to modify the document in memory, then a gXML bridge
               may reasonably be defined over any structured hierarchical data format
               analagous to XML: JSON, CSV, a file system, a MIME multipart message. Perhaps
               more strikingly, immutable models can potentially cross the VM boundary, via
               JNI to other languages, into hardware accelerators, and so on.
            </div>
         </div>
      </div><a name="ThegXMLCoreANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e126" xml:id="gxml-apis">
         <div class="title e127">The gXML Core</div>
         <div class="para e128">The gXML API is designed for rapid understanding.  The core API can be
            described as a collection of five interfaces. In practice, more interfaces
            are available, but understanding these five is necessary and sufficient to
            understand and use the gXML base API.  These abstractions adhere to the
            design principle of immutability, and do not introduce any dependency upon
            XML Schema.
         </div>
         <div class="para e129">The core API is completed with two extensions.  The mutable extension
            adds mutability by adding methods to the base interfaces, or by adding new
            interfaces.  The schema-aware extension adds schema awareness, again by adding
            methods to base interfaces, or by adding new interfaces; the schema-aware
            extension also introduces the "atom" parameter.
         </div><a name="UntypedImmutableANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e130" xml:id="api-base">
            <div class="title e131">Untyped, Immutable</div>
            <div class="para e132">The heart of the gXML API is an abstraction called 
               <div class="xref e133" linkend="Model"></div>. 
               <div class="code e134">Model</div> is stateless; each bridge implements it. The methods on
               
               <div class="code e135">Model</div> permit interrogation of XQuery Data Model properties
               (
               <div class="code e136">getNamespaceURI(N)</div>, 
               <div class="code e137">getLocalName(N)</div>,
               
               <div class="code e138">getStringValue(N)</div>, 
               <div class="code e139">getNodeKind(N)</div>, etc.), and
               provide XQuery/XPath navigation (child, descendant, ancestor, sibling,
               attribute, namespace axes). Since this abstraction is stateless, each method's
               first parameter is a context node, the node for which information is
               requested, or from which navigation begins. The XQuery Data Model defines
               seven node types: 
               <div class="code e140">Document</div>, 
               <div class="code e141">Element</div>,
               
               <div class="code e142">Text</div>, 
               <div class="code e143">Attribute</div>, 
               <div class="code e144">Namespace</div>,
               
               <div class="code e145">Comment</div>, and 
               <div class="code e146">ProcessingInstruction</div>. Returns from
               each method vary by node type, in conformance with the Data Model
               specification, but the API does not distinguish node types (the argument or
               return value is &lt;N&gt;, not &lt;? extends N&gt;). The 
               <div class="xref e147" linkend="gxml-code"></div> documents this interface.
            </div>
            <div class="para e148">For convenience, a very similar API, with minimal (positional) state is
               also defined: 
               <div class="code e149">Cursor</div>. 
               <div class="code e150">Cursor</div> provides a common
               idiom, maintaining its positional state within the target tree, which is
               frequently encountered in processing XML. Where 
               <div class="code e151">Model</div>'s
               navigation APIs typically return a node (
               <div class="code e152">N getFirstChildElement(N
                  context)
               </div>), 
               <div class="code e153">Cursor</div>'s corresponding APIs return true or
               false and change the 
               <div class="code e154">Cursor</div>'s state (
               <div class="code e155">boolean
                  moveToFirstChildElement()
               </div>). Where 
               <div class="code e156">Model</div>'s property
               accessors require a context node (
               <div class="code e157">String getStringValue(N
                  context)
               </div>), 
               <div class="code e158">Cursor</div>'s use its current state (
               <div class="code e159">String
                  getStringValue()
               </div>). The design intent is that anything that may be
               accomplished with a 
               <div class="code e160">Model</div> may also be accomplished with a
               
               <div class="code e161">Cursor</div>. Note that 
               <div class="code e162">Cursor</div> is not forward-only.
            </div>
            <div class="para e163">When processing XML, some applications can make use of gXML with nothing
               more than 
               <div class="code e164">Model</div> or 
               <div class="code e165">Cursor</div>. More advanced uses might
               need the third primary abstraction in the core gXML API, the
               
               <div class="code e166">ProcessingContext</div>. A processing context is precisely what it
               claims to be: a specialized (for the target tree model), stateful abstraction
               which provides uniform access to the collection of abstractions which together
               make up a bridge. 
               <div class="code e167">Model</div>, 
               <div class="code e168">Cursor</div>, and
               
               <div class="code e169">ProcessingContext</div> are all parameterized only by &lt;N&gt;ode. The
               
               <div class="code e170">TypedContext</div> extension introduces the &lt;A&gt;tom parameter.
            </div>
            <div class="para e171">
               <div class="code e172">ProcessingContext</div> provides 
               <div class="code e173">Model&lt;N&gt;
                  getModel()
               </div> and 
               <div class="code e174">Cursor&lt;N&gt; newCursor(N context)</div> methods,
               an accessor for the (singleton) 
               <div class="code e175">Model</div> and a factory for the
               
               <div class="code e176">Cursor</div>. Several additional accessors, functions, and factory
               methods are available from the context: it is the source for the mutable and
               typed context extensions (
               <div class="code e177">getMutableContext()</div> and
               
               <div class="code e178">getTypedContext()</div>), and for 
               <div class="code e179">DocumentHandler</div> and
               
               <div class="code e180">FragmentBuilder</div>; it can report whether candidate objects are
               compatible with the bridge's specialization of &lt;N&gt;ode; it includes a
               mechanism to permit feature-based extension. For greatest generality,
               applications should access a bridge via its processing context. An optional
               
               <div class="code e181">ProcessingContextFactory</div> interface is also included in the API,
               but experience suggests that provision of instances of the factory is an
               impediment to the target design pattern, dependency injection. That is,
               applications ought to instantiate the factory interface themselves, consistent
               with the injection mechanism or API which they use.
            </div>
            <div class="para e182">The processing context provides access to 
               <div class="code e183">DocumentHandler</div>,
               which in turn provides methods to parse from and serialize to streams, readers
               and writers. 
               <div class="code e184">ProcessingContext</div> is also a factory for
               
               <div class="code e185">FragmentBuilder</div>, which 
               <div class="emphasis e186">is-a</div>
               
               <div class="code e187">ContentHandler</div> (for the XDM, not the SAX interface of the same
               name) and 
               <div class="emphasis e188">is-a</div> 
               <div class="code e189">NodeSource</div>.
               
               <div class="code e190">FragmentBuilder</div> is used to programmatically build trees or tree
               fragments in memory, parallel to parsing a document into memory via the
               document handler's various parse methods. 
               <div class="code e191">Model</div> and
               
               <div class="code e192">Cursor</div> also accept a 
               <div class="code e193">ContentHandler</div> argument to
               stream or write themselves. In short, these abstractions provide a range
               of input/output operations for XML using a particular bridge. 
            </div>
            <div class="para e194">These five abstractions make up the core of the gXML API. There are
               other, supporting abstractions, some of which become more significant in
               particular contexts. An untyped, immutable bridge implementation (minimally)
               provides implementations for these five abstractions over a given tree
               model.
            </div>
         </div><a name="MutabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e195" xml:id="api-mutable">
            <div class="title e196">Mutability</div>
            <div class="para e197">gXML provides two standard extensions in the core
               
               <div class="code e198">ProcessingContext</div> to permit bridges to signal support for
               optional functionality. The first extension permits mutability. Immutability
               provides important benefits for XML processing, but all currently-available
               tree models are mutable, and nearly all processors and applications expect
               mutability. To ease migration, 
               <div class="code e199">ProcessingContext</div> provides a
               method, 
               <div class="code e200">getMutableContext()</div> which permits the bridge to signal
               that it supports mutability, by returning an implementation of the
               
               <div class="code e201">MutableContext</div> extension. A mutable context, in turn, provides
               access to 
               <div class="code e202">MutableModel</div> and 
               <div class="code e203">MutableCursor</div>, each of
               which extend the corresponding immutable interfaces (adding methods to add and
               remove nodes, and to change the content of a document or element node), and also
               provides access to a 
               <div class="code e204">NodeFactory</div> implementation which permits the
               creation of nodes in memory, independent of any tree (within the limits of the
               underlying tree model).
            </div>
            <div class="para e205">
               <div class="emphasis e206">Nota bene</div>: the mutable interfaces, unlike other
               abstractions in gXML, are not attempts to implement a portion of the XQuery
               Data Model in Java. The XQuery Data Model (and, in fact, XQuery 1.0, XSLT 2.0,
               and XPath 2.0) do not provide specification of property mutators.
               Consequently, this portion of the API has been designed to be roughly
               compatible with the XDM, as an extension, and to be roughly compatible with
               the corresponding mutable APIs in dominant tree models. However, once XQuery
               produces its "update" mechanism, this portion of the API is unlikely to prove
               conformant.
            </div>
         </div><a name="SchemaAwarenessANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e207" xml:id="api-sa">
            <div class="title e208">Schema Awareness</div>
            <div class="para e209">The 
               <div class="code e210">TypedContext</div> extension parallels the
               
               <div class="code e211">MutableContext</div> extension. It provides the XDM-defined
               schema-aware properties and manipulations. Most notably, the typed context
               introduces an additional parameter, the &lt;A&gt;tom handle. The base and mutable
               interfaces deal only with string values for text node and attribute content
               (in XDM terms, actually 
               <div class="emphasis e212">untyped atomic</div>). The XQuery Data
               Model defines the concept of "atom", which corresponds to a typed value or
               list of typed values. Atoms are inherently sequences of atoms (a single atom
               is a one-element list); "sequence" is also introduced in the schema-aware API,
               but unlike atom, is not represented by an independent common parameter.
            </div>
            <div class="para e213">
               <div class="code e214">TypedContext</div> is more complex than
               
               <div class="code e215">MutableContext</div>. As a mutable context provides access to mutable
               models and cursors, a typed context provides an accessor for a
               
               <div class="code e216">TypedModel</div> and is a factory for 
               <div class="code e217">TypedCursor</div>, which
               are extensions of the base 
               <div class="code e218">Model</div> and 
               <div class="code e219">Cursor</div>, adding
               methods to access the type-name and typed-value properties. As the base
               processing context can identify &lt;N&gt;odes, so the typed context can identify
               &lt;A&gt;toms. 
               <div class="code e220">TypedContext</div> enhances the base
               
               <div class="code e221">FragmentBuilder</div> as a type- and atom-aware
               
               <div class="code e222">SequenceBuilder</div>. To handle typed values,
               
               <div class="code e223">TypedContext</div> provides an accessor for the
               
               <div class="code e224">AtomBridge</div>, which in turn provides facilities to create, compile,
               cast, convert (to Java native types), and query atoms, in a fashion consistent
               with the XDM.
            </div>
            <div class="para e225">
               <div class="code e226">TypedContext</div> also provides access to the
               
               <div class="code e227">MetaBridge</div>, which primarily serves to map the names of types to
               their corresponding implmentations in the (included) XML Schema model.
               
               <div class="code e228">TypedContext</div> makes use of this bridge itself, because it extends
               the core schema model interface, 
               <div class="code e229">SmSchema</div>. 
               <div class="code e230">SmSchema</div>
               permits definition and declaration of custom types, registry of types, and
               lookup of types. In other words, the typed context provides a cache of types
               (supplied via parsing of schemas or programmatically) which are being used in
               the processing of a collection of XML documents. This is actually the origin
               of the concept and term "processing context," though it now exists for the
               untyped API as well.
            </div>
         </div>
      </div><a name="BuildingBridgeswithgXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e231" xml:id="gxml-bridges">
         <div class="title e232">Building Bridges with gXML</div>
         <div class="para e233">For greatest utility, gXML ought to have bridges on every tree model for
            XML in Java. The authors have not been able to accomplish this themselves, but
            can demonstrate that creating additional bridges is a straightforward
            task.
         </div>
         <div class="para e234">The three bridges included in the gXML source tree provide examples of
            the finished product. The development process is easily described. Note,
            however, that most tree models present unique challenges when adapted to the
            XQuery Data Model; our experience suggests that most development time is
            consumed by handling these impedance mismatches.
         </div><a name="UntypedImmutableANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e235" xml:id="gxml-base">
            <div class="title e236">Untyped, Immutable</div>
            <div class="para e237">What needs to be done to create a new base bridge (untyped, immutable)
               for an as-yet unsupported tree model? There are five steps:
            </div>
            <div class="orderedlist e238">
               <div class="listitem e239">
                  <div class="para e240">Implement 
                     <div class="code e241">ProcessingContext</div> and 
                     <div class="code e242">Model</div>.
                     Decide what the &lt;N&gt; (node) abstraction must be.
                  </div>
                  <div class="para e243">For instance: the DOM defines &lt;N&gt; as
                     
                     <div class="code e244">Node</div>. AxiOM defines it as 
                     <div class="code e245">Object</div>
                     (AxiOM does not have a single base interface that marks all node types).  The Cx bridge
                     proof-of-concept uses 
                     <div class="code e246">XmlNode</div>.
                  </div>
               </div>
               <div class="listitem e247">
                  <div class="para e248">Use the 
                     <div class="code e249">bridgekit</div> module to get a simple,
                     generic implementation of 
                     <div class="code e250">Cursor</div> (over the custom 
                     <div class="code e251">Model</div>).
                  </div>
                  <div class="para e252">The 
                     <div class="code e253">bridgekit</div> module is a collection of utilities intended
                     to help bridge developers.  It includes, for instance, an implementation of the XML
                     Schema model (
                     <div class="code e254">SmSchema</div>) and the 
                     <div class="code e255">XmlAtom</div> typed-value implementation,
                     as well as the 
                     <div class="code e256">CursorOnModel</div> helper used here.
                  </div>
               </div>
               <div class="listitem e257">
                  <div class="para e258">Implement 
                     <div class="code e259">FragmentBuilder</div>.
                  </div>
                  <div class="para e260">The 
                     <div class="code e261">FragmentBuilder</div> interface has five methods for creating
                     Text, Attribute, Namespace, Comment, and Processing Instruction node types, and an
                     additional two each (start and end) for the container node types, Element and Document.
                  </div>
               </div>
               <div class="listitem e262">
                  <div class="para e263">Use the generic implementation of 
                     <div class="code e264">DocumentHandler</div>
                     from the 
                     <div class="code e265">input-output</div> processor.
                  </div>
                  <div class="para e266">The generic 
                     <div class="code e267">DocumentHandler</div> in the 
                     <div class="code e268">input-output</div>
                     module is not terribly mature or robust, but can do the job for an initial implementation.
                  </div>
               </div>
               <div class="listitem e269">
                  <div class="para e270">Use the 
                     <div class="code e271">bridgetest</div> module to verify equivalence with
                     existing bridges.
                  </div>
                  <div class="para e272">The 
                     <div class="code e273">bridgetest</div> module is designed to make implementation
                     easy; enabling each test requires only that the bridge implement the single abstract
                     method, which returns the bridge's implementation of 
                     <div class="code e274">ProcessingContext</div> (from
                     which all other abstractions can be reached).  Adding a test implementation is thus
                     mostly
                     a mechanical task.
                  </div>
               </div>
            </div>
            <div class="para e275">This is all that's required. For this minimum,
               
               <div class="code e276">getMutableContext()</div> and 
               <div class="code e277">getTypedContext()</div> (on
               
               <div class="code e278">ProcessingContext</div>) should both return null, indicating no
               support.
            </div>
         </div><a name="MutabilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e279" xml:id="gxml-mutable">
            <div class="title e280">Mutability</div>
            <div class="para e281">To add support for mutability:</div>
            <div class="orderedlist e282">
               <div class="listitem e283">
                  <div class="para e284">Implement 
                     <div class="code e285">MutableContext</div> and return it from
                     
                     <div class="code e286">ProcessingContext</div> instead of null.
                  </div>
                  <div class="para e287">
                     <div class="code e288">MutableModel</div> provides access the 
                     <div class="code e289">NodeFactory</div>,
                     
                     <div class="code e290">MutableModel</div>, and 
                     <div class="code e291">MutableCursor</div> implementations.
                  </div>
               </div>
               <div class="listitem e292">
                  <div class="para e293">Implement 
                     <div class="code e294">MutableModel</div> as an extension of the
                     base 
                     <div class="code e295">Model</div> from above.
                  </div>
                  <div class="para e296">
                     <div class="code e297">MutableModel</div> adds methods to set attributes and namespaces,
                     to add, remove, and replace children.
                  </div>
               </div>
               <div class="listitem e298">
                  <div class="para e299">Use the 
                     <div class="code e300">bridgekit</div> module to base the bridge's
                     
                     <div class="code e301">MutableCursor</div> on its 
                     <div class="code e302">MutableModel</div>.
                  </div>
                  <div class="para e303">The 
                     <div class="code e304">bridgekit</div> implementations are reasonable starting
                     points, though optimization is likely to require a custom implementation.
                  </div>
               </div>
               <div class="listitem e305">
                  <div class="para e306">Implement 
                     <div class="code e307">NodeFactory</div>.
                  </div>
                  <div class="para e308">
                     <div class="code e309">NodeFactory</div> contains methods to create each node type,
                     where 
                     <div class="code e310">MutableModel</div> establishes the relationships between nodes.
                  </div>
               </div>
               <div class="listitem e311">
                  <div class="para e312">Add tests from the 
                     <div class="code e313">bridgetest</div> module.
                  </div>
                  <div class="para e314">In this case, there's only one, at present.</div>
               </div>
            </div>
            <div class="para e315">This is admittedly easier to describe than to accomplish.  Approaches
               to mutability among tree models vary 
               <div class="emphasis e316">much</div> more widely
               than approaches to navigation and analysis.
            </div>
            <div class="para e317">On the other hand, gXML's approach to mutability is more restricted than
               most current tree APIs. The gXML mutable API does 
               <div class="emphasis e318">not</div>
               support changing the value of a text or attribute node, for instance. Leaf
               nodes remain immutable; container nodes (document and element) are mutable in
               content (contained nodes) only.
            </div>
         </div><a name="SchemaAwarenessANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e319" xml:id="gxml-sa">
            <div class="title e320">Schema Awareness</div>
            <div class="para e321">To add support for schema-awareness:</div>
            <div class="orderedlist e322">
               <div class="listitem e323">
                  <div class="para e324">Implement 
                     <div class="code e325">TypedContext</div> and return it from
                     
                     <div class="code e326">ProcessingContext</div> instead of null; note that 
                     <div class="code e327">TypedContext</div>
                     
                     <div class="emphasis e328">is-a</div> 
                     <div class="code e329">SmSchema</div>. Decide what the &lt;A&gt; (atom)
                     abstraction must be.
                  </div>
                  <div class="para e330">Current implementations all define &lt;A&gt; as 
                     <div class="code e331">XmlAtom</div>.
                     This is not required.
                  </div>
               </div>
               <div class="listitem e332">
                  <div class="para e333">Implement 
                     <div class="code e334">TypedModel</div> as an extension of the
                     base 
                     <div class="code e335">Model</div> from above.
                  </div>
                  <div class="para e336">The 
                     <div class="code e337">TypedModel</div> interface adds only five methods to
                     
                     <div class="code e338">Model</div>, all related to the introduction of type names and typed values.
                     Actually ensuring that the type annotations and typed values are associated with the
                     nodes in the tree is one of the most challenging tasks in implementation.
                  </div>
               </div>
               <div class="listitem e339">
                  <div class="para e340">Use the 
                     <div class="code e341">bridgekit</div> module to base the bridge's
                     
                     <div class="code e342">TypedCursor</div> on its 
                     <div class="code e343">TypedModel</div>.
                  </div>
                  <div class="para e344">
                     <div class="code e345">CursorOnTypedModel</div> extends 
                     <div class="code e346">CursorOnModel</div>
                     as expected.
                  </div>
               </div>
               <div class="listitem e347">
                  <div class="para e348">Implement or reuse from the 
                     <div class="code e349">bridgekit</div> module
                     an 
                     <div class="code e350">AtomBridge</div> (typed value support).
                  </div>
                  <div class="para e351">If the chosen &lt;A&gt;tom is 
                     <div class="code e352">XmlAtom</div>, the 
                     <div class="code e353">XmlAtomBridge</div>
                     already exists.
                  </div>
               </div>
               <div class="listitem e354">
                  <div class="para e355">Implement or reuse from the 
                     <div class="code e356">bridgekit</div> module a
                     
                     <div class="code e357">MetaBridge</div> (type support).
                  </div>
                  <div class="para e358">Again, if the &lt;A&gt;tom is 
                     <div class="code e359">XmlAtom</div>, a 
                     <div class="code e360">MetaBridge</div>
                     exists in the 
                     <div class="code e361">bridgekit</div>.
                  </div>
               </div>
               <div class="listitem e362">
                  <div class="para e363">Implement 
                     <div class="code e364">SequenceBuilder</div> as an extension of
                     the 
                     <div class="code e365">FragmentBuilder</div> from above.
                  </div>
                  <div class="para e366">
                     <div class="code e367">SequenceBuilder</div> adds overrides for the 
                     <div class="code e368">attribute()</div>, 
                     
                     <div class="code e369">startElement()</div>, and 
                     <div class="code e370">text()</div> methods (adding type names and
                     typed values), plus methods to create an atom and to start and end a sequence.
                  </div>
               </div>
               <div class="listitem e371">
                  <div class="para e372">Add the typed tests from the 
                     <div class="code e373">bridgetest</div> module.
                  </div>
                  <div class="para e374">As with the standard tests, these are easy to implement, following the
                     same pattern.
                  </div>
               </div>
            </div>
            <div class="para e375">For schema awareness, the most straightforward approach is going to be
               reusing the generic implementations found in the 
               <div class="code e376">bridgekit</div>
               module, but better results may be achieved by customizing the code. This is an
               area requiring further experience before establishing guidelines for best
               practices.
            </div>
         </div><a name="BridgeTrafficANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e377" xml:id="gxml-using">
            <div class="title e378">Bridge Traffic</div>
            <div class="para e379">Using bridges is a little less amenable to slideshow style lists, but
               the principles remain straightforward. When using gXML, it is important to
               understand "dependency inversion": bridges should be injected, if at all
               possible, rather than directly instantiated. It is possible to design an
               application or processor that can react to input by directly instantiating the
               needed bridge, but it's best to reduce the number of places that contain
               reference to the tree model packages to as few as possible. One class is
               ideal; it is then responsible for providing a processing context for a given
               bridge on demand.
            </div>
            <div class="para e380">Most applications will spend most of their time with the
               
               <div class="code e381">Model</div> or 
               <div class="code e382">Cursor</div>) interfaces, which
               permit navigation and interrogation. Methods provide access to names, values,
               and other characteristics (XQuery Data Model properties) of the node, and
               permit navigation in a variety of ways to target nodes.  An appendix shows
               the content of the 
               <div class="xref e383" linkend="Model"></div> interface.
               
               <div class="code e384">FragmentBuilder</div> (for construction in memory) and
               
               <div class="code e385">DocumentHandler</div> (for parsing and serializing) are likely to be
               important. Existing applications or developers wedded to the concept of
               mutability are likely to make use of the APIs in the mutable model (or cursor)
               and the 
               <div class="code e386">NodeFactory</div>. Applications or processors needing W3C XML
               Schema support (common inside the enterprise, for instance) are likely to make
               extensive use of 
               <div class="code e387">TypedContext</div>, particularly as a schema cache and
               for access to typed models and cursors.
            </div>
            <div class="para e388">At present, gXML has bridges, in varying states of maturity, for the DOM
               (level 3 support currently required), for AxiOM (LLOM only; support for typed
               context rather weak), and for a reference bridge called Cx (a clean, if naive,
               reimplementation of the XQuery Data Model from scratch, and a gXML bridge over
               that implementation). The DOM was chosen because of its ubiquity; AxiOM because
               the web services area is a target for gXML proselytizers; Cx exists primarily
               to demonstrate that the shared idiosyncracies of DOM and AxiOM (there are a
               few) are not fundamental to gXML.
            </div>
         </div>
      </div><a name="ProcessingXMLwithgXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e389" xml:id="gxml-processing">
         <div class="title e390">Processing XML with gXML</div>
         <div class="para e391">gXML provides an extensive API for bridges, which not only provides the
            entry point for applications and processors, but also makes the development of
            new bridges easy to describe. In sharp contrast, no interface, no contract, is
            specified for XML processors designed for use with gXML. While some processors
            might reasonably be defined to have a method with the signature: 
            <div class="code e392">N
               process(N, Model&lt;N&gt;)
            </div>, for others this is entirely inappropriate.
            Even for processors that might reasonably "process" a node, their function is
            more clearly expressed if they "transform" or "extract" or "enhance", or
            otherwise mark their "processing" by its specific name, not the more general
            one.
         </div>
         <div class="para e393">So, what is a gXML processor? As the gXML team uses the term, a
            processor is a code library that performs some specific, well-described
            function over XML. Most processors can be described with a single word or
            phrase: "serializer," "parser," "converter," "validator," "transformer,"
            "signer," and so on. A processor is distinguished from an "application," which
            may create (generate), destroy (consume), modify, and otherwise manipulate XML
            in multiple steps. Where a processor contributes special functionality to the
            performance of a goal, the application oversees and orchestrates achievement
            of the goal from receipt to completion. To further distinguish, a bridge
            provides the abstraction over which the applications and processors operate,
            including the model, input/output, and a context that associates related
            tree-specific functions.
         </div><a name="StatefulANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e394" xml:id="stateful-processing">
            <div class="title e395">Stateful</div>
            <div class="para e396">gXML processors may be divided, for purposes of discussion, into two
               classes: stateful and stateless. Here, "state" refers to the processor's need
               to maintain state in the form of any of the parameters specialized by a
               particular bridge implementation (&lt;N&gt; and &lt;A&gt;), disregarding maintenance
               of state unrelated to gXML parameters. A stateful processor is ideally written
               generically, but certain of its component classes will themselves be
               parameterized with one or both of the node and atom handles. Consequently, at
               instantiation, a given instance of a processor is tied, 
               <div class="emphasis e397">ipso
                  facto
               </div>, to a particular bridge implementation. Like
               
               <div class="code e398">java.util.List&lt;QName&gt;</div>, a generic processor taking only &lt;N&gt;
               as a parameter would have to be specialized as
               
               <div class="code e399">GenericProcessor&lt;Node&gt;</div> for use with the DOM bridge; the same
               class would be separately instantiated for use with the Cx bridge as
               
               <div class="code e400">GenericProcessor&lt;XmlNode&gt;</div>. Stateful processors typically
               contain one or more member fields whose type is specified as a parameter (or
               which is a parameterized class, such as an instance of
               
               <div class="code e401">Cursor&lt;N&gt;</div> or 
               <div class="code e402">Bookmark&lt;N&gt;</div>).
            </div>
            <div class="para e403">For example, an input-output module is included in the gXML source tree.
               This module includes a stateful processor implementing
               
               <div class="code e404">DocumentHandler&lt;N&gt;</div>. This 
               <div class="code e405">DocumentHandler</div> contains
               a member field which is a 
               <div class="code e406">FragmentBuilder&lt;N&gt;</div> supplied by the
               bridge's 
               <div class="code e407">ProcessingContext</div>. This is a good example of the
               stateful style: at instantiation, each
               
               <div class="code e408">DefaultDocumentHandler&lt;N&gt;</div> is specialized for the bridge's
               definition of &lt;N&gt;, associating this handler instance with a particular
               bridge (in fact, associating it with a single instance of the bridge's
               implementation of 
               <div class="code e409">ProcessingContext</div>). This processor's "process"
               methods are defined by the 
               <div class="code e410">DocumentHandler</div> interface, found in
               the core API.
            </div>
         </div><a name="StatelessANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e411" xml:id="stateless-processing">
            <div class="title e412">Stateless</div>
            <div class="para e413">An alternate style of implementation is the stateless processor. If no class
               in the processor needs to retain state typed as or with a gXML parameter, then the
               processor may be used by declaring the necessary parameters on a method, and
               supplying the necessary disambiguation as arguments to the method. For
               instance, a stateless processor might expose the method:
            </div>
            <div class="programlisting e414" xml:space="preserve">
               &lt;N&gt; N nearestAncestor(Iterable&lt;N&gt; context, Model&lt;N&gt; model)
               
            </div>
            <div class="para e415">The arguments to the method are both parameterized: the context provides
               a collection of nodes; the model provides the tool to interrogate each of the
               nodes in the supplied context (this hypothetical example finds the nearest
               common ancestor of all the nodes supplied in the list, or 
               <div class="code e416">null</div> if
               no such common ancestor exists).
            </div>
            <div class="para e417">An extremely simple example of a stateless processor may be found in the
               
               <div class="code e418">convert</div> module, in the gXML source tree. It's so simple that it's debatable
               whether it's a processor, or simply an instantiation of an idiom.
               
               <div class="code e419">StaticConverter</div> has a single, static method, with the
               signature:
            </div>
            <div class="programlisting e420" xml:space="preserve">
               &lt;Nsrc, Ntrg&gt; Ntrg convert(Cursor&lt;Nsrc&gt; cursor, FragmentBuilder&lt;Ntrg&gt; builder)
               
            </div>
            <div class="para e421">It does what it says on the tin: using the supplied 
               <div class="code e422">Cursor</div>
               and 
               <div class="code e423">FragmentBuilder</div>, from one or two different bridges, it
               converts from one tree model representation to another (strictly speaking,
               this is a transforming copy, rather than a conversion; also, if the
               
               <div class="code e424">Cursor</div> and 
               <div class="code e425">FragmentBuilder</div> are supplied by the same bridge,
               this is simply a copy).
            </div>
            <div class="para e426">A more complex example may be found in the same module: 
               <div class="code e427">Converter</div> mixes
               the stateful and stateless styles.  It is instantiated with a (source)
               processing context; it is then able, on request, to convert to any supplied
               target processing context—retaining type information, if possible (if
               both source and target bridges advertise themselves as schema-aware, it uses
               
               <div class="code e428">SequenceBuilder</div> and the 
               <div class="code e429">TypedModel</div>'s atom-aware
               
               <div class="code e430">stream()</div> method in preference to the untyped 
               <div class="code e431">FragmentBuilder</div>
               and 
               <div class="code e432">Model</div>).
            </div>
         </div><a name="DevelopingandRefactoringANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e433" xml:id="other-processing" xreflabel="Refactoring Processors">
            <div class="title e434">Developing and Refactoring</div>
            <div class="para e435">The gXML source tree contains, in addition to the processors mentioned
               above, an XPath 1.0 processor, a schema parser, and a schema validator. The
               XPath processor is stateless; the schema processors (unsurprisingly) stateful.
               Processors for XPath 2.0, XSLT 2.0, and XQuery 1.0 have also been explored,
               although this code is not included in the distribution.
            </div>
            <div class="para e436">During the development of the API, in early 2009, the Apache Woden
               project (1.0M8) was refactored as a proof of concept. This effort was based on an
               earlier revision of the API; the refactoring was extensive, taking advantage
               of the immutable paradigm. Woden was chosen as an example because it contained
               an example of multi-tree abstraction: wrapper classes permit Woden to
               parse and analyze WSDL supplied either as AxiOM or as DOM trees. The project
               required about a month, but the result seemed a dramatic validation of of gXML
               principles and design: the lines of code (LOC) count was reduced by about 15%,
               inconsistencies in the handling of DOM versus AxiOM were eliminated, and
               supported models grew from two to five (including DOM, AxiOM, the Cx reference
               model, a proprietary internal model, and an experimental model based on EXI).
               There is no guarantee of such an LOC count reduction, of course; results will
               depend upon the original source.
            </div>
            <div class="para e437">As part of the preparation for release as open source, a similar effort
               was undertaken to refactor the Apache XML Security project in early 2010. This
               was a more cautious effort, adopting as a guideline that no externally used API
               should change. Instead, the existing interfaces were enhanced with a gXML code
               path. In addition to preservation of backward compatibility in the API, this
               refactoring did not attempt a wholesale restatement of the security problem in
               immutable context, but relied extensively upon 
               <div class="code e438">MutableContext</div> and
               the capabilities supported therein. This effort is ongoing, and does not
               appear to promise a reduction in code size, given its goals. It has provided
               the team with an excellent test case for the mutable APIs (and even
               demonstrated missing XDM-defined functionality in the core APIs) which have
               been used to improve both areas. Nonetheless, it appears to validate the
               concept of cautious, compatibility-maintaining refactoring; the refactored
               API appears able to pass the same tests that the original DOM-based API passed.
            </div>
            <div class="para e439">The experience from these (and other) proofs of concept, refactoring
               existing XML processors and developing new processors, leads to some tentative
               conclusions about the efforts involved and the possible development patterns.
               We note that because all current tree models incorporate mutability without
               questioning its utility, most processors approach problems of XML manipulation
               as a tree mutation.
            </div><a name="NewDevelopmentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e440" xml:id="ProcessorNew">
               <div class="title e441">New Development</div>
               <div class="para e442">The time required for development of a new processor varies depending
                  upon the complexity of the processing. In our experience, adopting the
                  immutable paradigm can actually simplify development, though it requires an
                  effort to state the problem as a transformation rather than as a mutation.
                  Processors developed for gXML take no more, and often less time to develop
                  (and debug) than processors over a single tree model. When designed for
                  immutability, the resulting processor often shows excellent performance
                  characteristics, without requiring significant attention to this area.
               </div>
               <div class="para e443">Examples are included in the distribution, in the 
                  <div class="code e444">processor</div>
                  module and its children: 
                  <div class="code e445">input-output</div>, 
                  <div class="code e446">convert</div>,
                  
                  <div class="code e447">w3c.xs</div> (schema parsing), and 
                  <div class="code e448">w3c.xs.validation</div>.
               </div>
            </div><a name="Refactoring:ProcessingMutableTreesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e449" xml:id="ProcessorOldMutable">
               <div class="title e450">Refactoring: Processing Mutable Trees</div>
               <div class="para e451">Existing processors—such as the Apache XML Security
                  example—that have already released are apt to wish to maintain existing
                  customer bases. The approach to take, in this case, seems to be to produce an
                  extended, parallel API: where the existing API takes a 
                  <div class="code e452">Node</div>,
                  provide an override that accepts (for example) 
                  <div class="code e453">N, Model&lt;N&gt;</div>, or
                  (if changing the state of the supplied argument is acceptable)
                  
                  <div class="code e454">Cursor&lt;N&gt;</div>.  Then change the original DOM-based function so that
                  it merely calls the new gXML-based method.  This approach increases the size
                  of the code base, but preserves the logic of the API, validation via the
                  existing test suite, and compatibility with existing clients.
               </div>
               <div class="para e455">Firm estimates depend upon the size and complexity of the code base,
                  but experience seems to demonstrate that once the principles are understood,
                  much of the refactoring proceeds in a nearly mechanical fashion. The primary
                  advantage to this form of refactoring is the addition of support for all
                  defined gXML bridges (or all bridges that support mutability); this in turn
                  may permit customers to choose models better suited for a particular problem
                  domain.  In the XML Security case, the refactoring produces the ability to
                  use the processor with AxiOM (in the current state of the art; potentially
                  with other tree models as those are developed as well).
               </div>
            </div><a name="Refactoring:ProcessingImmutableTreesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e456" xml:id="ProcessorOldImmutable">
               <div class="title e457">Refactoring: Processing Immutable Trees</div>
               <div class="para e458">Refactoring an XML processor for immutable operation is more
                  challenging. The general principle is that instead of considering the problem
                  as one of modifying a tree, the problem is stated as a transforming copy. The
                  XML document is an input; other inputs guide the processing; the output is a
                  new XML document (the original is then typically discarded, or sometimes
                  archived). Our experience addressed Apache Woden, in part because the project
                  was then recently graduated from incubation (that is, it had just made a
                  public 1.0 release), so preservation of API compatibility was deemed less
                  critical; widespread adoption had not yet occurred. Another example is the
                  
                  <div class="code e459">xpath.impl</div> processor, based on the 
                  <div class="code e460">xpath</div> API module;
                  these modules were both created by refactoring a portion of James Clark's and
                  Bill Lindsey's 
                  <div class="code e461">XT</div> 
                  <div class="xref e462" linkend="XT"></div>. XPath has no need for
                  mutability, obviously; stating the XPath processing problem in immutable
                  context is trivial.
               </div>
               <div class="para e463">This approach typically changes the logic of processing as well as
                  changing the public API; developers may find that the code that "enhances"
                  (mutates) a tree with information must be localized. That is, instead of
                  receiving, analyzing, modifying, analyzing further, etc., the process is
                  receiving, analyzing, generating/transforming, analyzing further. Creation of
                  new documents is potentially expensive; this is apt to lead developers to
                  minimize occurrences of the event. Awareness of this issue, in our experience,
                  led to code that was more straightforward, easier to understand, and better
                  encapsulated. Note
                  also that a refactoring of a publicly released API might proceed first by
                  preserving API compatibility, and later providing an alternate, transformative
                  code path that parallels the modification path.
               </div>
            </div>
         </div>
      </div><a name="AdvancingtheStateoftheArtANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e464" xml:id="advancing-the-state-of-the-art" xreflabel="Advancing the State of the Art">
         <div class="title e465">Advancing the State of the Art</div>
         <div class="para e466">The gXML team believes that this API presents an exciting opportunity to
            change the paradigms for XML processing in Java, and to enable a host of
            additional opportunities for advancing the state of the art. We have discussed
            the API, bridges, and processors in some detail, above. Now, let's examine the
            further opportunities that gXML enables.
         </div>
         <div class="para e467">Because gXML encourages the practice of dependency inversion, of
            injecting a particular tree model (bridge) at runtime, it effectively
            bypasses—even leverages, by inclusion of a bridge for the DOM in the
            distribution—the DOM network effect that has presented Java developers
            of XML processors and applications with a Hobson's choice: choose a tree model
            which is technically superior or less awkward to program against but lose
            interoperability with the vast majority of existing processors and
            applications, or choose the DOM with its peculiarities and quirks and
            limitations but gain interoperability with the wider XML ecosystem. Developers
            of alternative Java XML tree models will (we hope) welcome this, and
            contribute bridges. Moreover, by permitting this late binding of the tree
            model, gXML enables use-case specific comparisons of models to each other.
            This capability for comparison, without losing interoperability, may lead to
            wider adoption of one or more of the successor models, in one application
            domain or across domains. Further, given the ability to compare two models in
            such a way, application and processor developers can provide clear test cases
            demonstrating issues, which developers of the tree model may find more
            compelling, more deserving of attention, than is currently the case when any
            comparison must first develop a custom framework/harness.
         </div>
         <div class="para e468">By enabling injection of the model, gXML also potentially permits the
            development of domain-specific tree models, optimized for particular use
            cases. Such "niche" models are actively discouraged in the current state of
            the art: they lead in the direction of private code, difficult to learn and
            difficult to maintain. AxiOM provides an example of a domain-specific model
            that has survived the process of marginalization; one might argue that it has
            done so in part through its strong association with the high-profile project
            Apache Axis 2. Other domains such as strongly typed XML, large XML
            processing, and XML in constrained memory environments come to mind as
            potential targets. Customization and optimization are possible both for the
            underlying tree model, and for the bridge implementation. There is no
            restriction against implementing multiple bridges for a single underlying tree
            model—since the pattern is injection, two significantly different
            bridge implementations over the same underlying tree model may be used by a
            single application. Here again, there are significant opportunities for domain
            optimization, in this case by optimizing the bridge implementation rather than
            changing the underlying tree model.
         </div>
         <div class="para e469">gXML's championing of the immutable paradigm for XML processing carries
            powerful potentials for performance enhancements. We cannot, at this point,
            quantify these benefits (they may even be chimerical), but we have seen
            immutability adopted in other areas specifically in order to improve
            performance. Immutability provides guarantees that enable concurrent
            processing, an increasingly common requirement for applications and processors
            that must scale to handle large volumes of traffic. With a custom tree model
            (even an immutable implementation of the DOM, potentially), the notorious
            impact of XML on memory can potentially be reduced. For applications and
            processors that already address multiple tree models, significant reductions
            in code size may accompany improved performance and consistency. Our
            experience suggests that restating problems as transformation rather than
            mutation tends to lead to cleaner, better-encapsulated, and typically more
            performant code.
         </div>
         <div class="para e470">One particular area in which gXML holds enormous promise is in the
            processing of "large XML". This is, in a way, the same problem as processing
            XML with "constrained memory;" whether one identifies the XML as too-large, or
            memory as too-small, the problem is the same. How can XML be processed if it
            is too large to fit at once into memory? The obvious answer is a custom tree
            model, but this answer immediately presents the developer with the DOM "Hobson's
            choice" outlined above. gXML removes that issue; a processor or application
            programmed against the gXML API can inject a simple, mature tree model for
            most processing, or a custom, stored-to-disk, low-memory tree model when the
            size of the target document exceeds a specified threshold.
         </div>
         <div class="para e471">Developers of technologies that compete with XML as descriptions of
            structured, hierarchical data may have no interest in presenting their formats
            as XML (may even resent the suggestion), but there are advantages to doing so:
            the XML programming environment is a large one, populated with numerous
            processors and applications. A bridge over other such data
            formats—JSON, for a high-profile example—could provide that
            format with the capabilities of the entire suite of XML tools (with the
            reservation that there is apt to be an impedance mismatch of some degree, that
            the bridge will attempt to minimize). This is most interesting when gXML is
            used with the immutable paradigm; modifying these alternative structured
            hierarchical data formats as well as analyzing them is a more difficult
            problem and likely to have a higher degree of impedance mismatch.
         </div>
         <div class="para e472">Again particularly with respect to immutable processing, gXML offers an
            opportunity to pass XML across the virtual machine/Java Native Interface
            boundary. The XQuery Data Model defines the operations and properties that are
            possible with (g)XML; there is no impediment to producing a
            specification-compliant API in other languages, whether they are hosted in the
            VM (Scala, Jython) or outside it (C++, Perl, Lua). This in turn suggests
            possibilities for enabling most-efficient processing, for enabling scripting
            in domain-specific languages, and so on.
         </div>
         <div class="para e473">Perhaps most significantly, from the point of view of the gXML
            development team: in recent years a number of new specifications have appeared
            that offer exciting opportunities for advancing the state of the art of XML
            processing. In Java, adoption of these technologies—XQuery, XSLT2, XML
            databases—has been slowed by the lack of support in dominant models,
            and the limited extensibility possible. Even XML Schema has seen relatively
            little adoption/development outside the enterprise; gXML includes a schema
            model to address that issue. More importantly, the XQuery Data Model seems to
            offer a well-thought foundation for the next ten years of development in
            XML-related technologies. gXML proposes to embody that model for Java, while
            providing compatibility with the existing tree models, enabling a unification
            of processing while promoting differentiation, specialization, and
            customization of models.
         </div>
      </div><a name="gXMLSolution(s)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e474" xml:id="conclusion">
         <div class="title e475">gXML Solution(s)</div>
         <div class="para e476">We submit that gXML addresses the problems that its design set out to
            address, and that have plagued a large population of developers. It resolves
            the problem of multiple, competing tree models in Java, leverages the network
            effect of the dominant Java tree model for XML (and in fact shares that
            network effect with any other tree model over which a gXML bridge is
            available), and permits comparison of and late (even runtime) selection of a
            model best suited to the task. In the process, it begins to resolve the
            problems of interoperability. It is based on a well-defined, rigorous
            specification (the XQuery Data Model), which appears to be the best foundation
            for the next generation of XML technologies. It introduces and promotes the
            immutable paradigm for XML processing, and permits or encourages the
            development of models able to fulfill the promise of that paradigm.
         </div>
         <div class="para e477">gXML represents about five man-years of development, in its current
            state. Its corporate sponsor has contributed it to open source because its
            value can be directly correlated with its adoption. More bridges: more value
            (to the contributing corporation and to everyone using gXML). More processors:
            more value. For more code, though, we need help. Get involved! Try the code.
            Our experience has been that it has immediate benefits, even for isolated
            applications and processors. See a bug? Contribute a patch! Intrigued by the
            promise gXML offers? Become a committer!
         </div>
         <div class="para e478">Based on the previous ten years, introduction of so significant a shift
            in APIs and paradigms in the Java world will need to last at least ten years.
            The APIs developed ten years ago, viewed in hindsight, show what seem to be
            obvious lacunae or missed focus. Are there such gaps and blind spots in gXML?
            Take a look; if we're missing something, tell us now, and help us to address
            it.
         </div>
         <div class="para e479">Interested in the opportunities, but not in refining the core APIs? Want
            to provide an XQuery Data Model over a different, currently unsupported tree
            model (even over a non-XML structured data model)? Write a bridge. Our
            experience suggests that investment for a new bridge is about one
            programmer-month, for complete, but unoptimized functionality. Refinements
            depend upon the underlying tree model; those that are closer in concept to the
            XQuery Data Model tend to be easier to improve, while those further away
            (particularly if they don't conform to XML Infoset) provide more challenges.
            If developers involved in JDOM, DOM4J, or XOM are reading this, we hope to
            have intrigued you enough that you'll contribute (or provide independently) a
            bridge implementation for those models. What about a bridge for JSON? CSV?
            Could the new, XQuery-conformant crop of XML databases expose programming
            interfaces as bridges or as processors?
         </div>
         <div class="para e480">Interested in a particular application of XML? Can it be conceived as an
            XML processor? Development investment for a gXML processor varies pretty
            widely, depending upon the complexity of the processing to be done. For
            instance, the schema validation module included in the gXML source represents
            perhaps six months of work; the conversion processor (because it really does
            nothing more than embody an idiom already supported in the gXML core APIs)
            required no more than a week. XQuery or XSLT 2.0 processors would represent
            significant time investments. The field is vast, though, so it is impossible
            to characterize (either in time or complexity) everything in it.
         </div>
         <div class="para e481">Are we missing an obvious opportunity? Tell us about it. Or ... do it,
            and show us up. Our primary hope, in releasing the code and this paper, is to
            generate some excitement about the possibilities we believe to be inherent in
            the gXML refactoring of XML in Java. Get excited; this could change the
            game.
         </div>
      </div><a name="gXML:SourceANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="appendix e482" xml:id="gxml-code">
         <div class="title e483">gXML: Source</div>
         <div class="para e484">As previously noted, the core of the gXML paradigm is an abstraction
            called 
            <div class="code e485">Model</div>.  Because this is an example of the 
            <div class="emphasis e486">Handle/Body</div>
            design pattern (and is stateless), only one instance of 
            <div class="code e487">Model</div> is
            needed for navigation and investigation for any and all instances of the
            XML tree model for which the particular 
            <div class="code e488">Model</div> is specialized.
            Consequently, it seems worthwhile to show the content of the 
            <div class="code e489">Model</div>
            abstraction.  Comments have been removed.
         </div>
         <div class="para e490">
            <div class="code e491">Model</div> is composed from three interfaces, reflecting three different
            forms of information that might be obtained from an XQuery Data Model: 
            <div class="code e492">NodeInformer</div>
            reports information about the content/state of a particular node in context; 
            <div class="code e493">NodeNavigator</div>
            permits one to obtain a different node given a particular starting node; 
            <div class="code e494">AxisNavigator</div>
            supplies iteration over the standard XPath/XQuery axes, starting from a particular
            origin node.
         </div>
         <div class="programlisting e495" xml:id="Model" xml:space="preserve" xreflabel="Model">
            public interface Model&lt;N&gt;
            extends Comparator&lt;N&gt;, NodeInformer&lt;N&gt;, NodeNavigator&lt;N&gt;, AxisNavigator&lt;N&gt; {
            void stream(N node, boolean copyNamespaces, ContentHandler handler) throws GxmlException;
            }
            
            public interface NodeInformer&lt;N&gt; {
            Iterable&lt;QName&gt; getAttributeNames(N node, boolean orderCanonical);
            
            String getAttributeStringValue(N parent, String namespaceURI, String localName);
            
            URI getBaseURI(N node);
            
            URI getDocumentURI(N node);
            
            String getLocalName(N node);
            
            Iterable&lt;NamespaceBinding&gt; getNamespaceBindings(N node);
            
            String getNamespaceForPrefix(N node, String prefix);
            
            Iterable&lt;String&gt; getNamespaceNames(N node, boolean orderCanonical);
            
            String getNamespaceURI(N node);
            
            Object getNodeId(N node);
            
            NodeKind getNodeKind(N node);
            
            String getPrefix(N node);
            
            String getStringValue(N node);
            
            boolean hasAttributes(N node);
            
            boolean hasChildren(N node);
            
            boolean hasNamespaces(N node);
            
            boolean hasNextSibling(N node);
            
            boolean hasParent(N node);
            
            boolean hasPreviousSibling(N node);
            
            boolean isAttribute(N node);
            
            boolean isElement(N node);
            
            boolean isId(N node);
            
            boolean isIdRefs(N node);
            
            boolean isNamespace(N node);
            
            boolean isText(N node);
            
            boolean matches(N node, NodeKind nodeKind, String namespaceURI, String localName);
            
            boolean matches(N node, String namespaceURI, String localName);
            }
            
            public interface NodeNavigator&lt;N&gt; {
            N getAttribute(N node, String namespaceURI, String localName);
            
            N getElementById(N context, String id);
            
            N getFirstChild(N origin);
            
            N getFirstChildElement(N node);
            
            N getFirstChildElementByName(N node, String namespaceURI, String localName);
            
            N getLastChild(N node);
            
            N getNextSibling(N node);
            
            N getNextSiblingElement(N node);
            
            N getNextSiblingElementByName(N node, String namespaceURI, String localName);
            
            N getParent(N origin);
            
            N getPreviousSibling(N node);
            
            N getRoot(N node);
            }
            
            public interface AxisNavigator&lt;N&gt; {
            Iterable&lt;N&gt; getAncestorAxis(N node);
            
            Iterable&lt;N&gt; getAncestorOrSelfAxis(N node);
            
            Iterable&lt;N&gt; getAttributeAxis(N node, boolean inherit);
            
            Iterable&lt;N&gt; getChildAxis(N node);
            
            Iterable&lt;N&gt; getChildElements(N node);
            
            Iterable&lt;N&gt; getChildElementsByName(N node, String namespaceURI, String localName);
            
            Iterable&lt;N&gt; getDescendantAxis(N node);
            
            Iterable&lt;N&gt; getDescendantOrSelfAxis(N node);
            
            Iterable&lt;N&gt; getFollowingAxis(N node);
            
            Iterable&lt;N&gt; getFollowingSiblingAxis(N node);
            
            Iterable&lt;N&gt; getNamespaceAxis(N node, boolean inherit);
            
            Iterable&lt;N&gt; getPrecedingAxis(N node);
            
            Iterable&lt;N&gt; getPrecedingSiblingAxis(N node);
            }
            
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e496">
         <div class="title e497">References</div>
         <div class="bibliomixed e498" xml:id="AxiOM">
            <div class="emphasis e499">Axiom 1.2.8 API</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e500" xlink:actuate="onRequest" xlink:href="http://ws.apache.org/commons/axiom/apidocs/index.html" xlink:show="new" xlink:type="simple">http://ws.apache.org/commons/axiom/apidocs/index.html</div>
         </div>
         <div class="bibliomixed e501" xml:id="LavaFlow">Brown W., R. Malveau, H. McCormick, T. Mowbray, and S. W. Thomas.
            
            <div class="emphasis e502">Lava Flow anti-pattern</div> (Dec. 1999)
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e503" xlink:actuate="onRequest" xlink:href="http://www.antipatterns.com/lavaflow.htm" xlink:show="new" xlink:type="simple">http://www.antipatterns.com/lavaflow.htm</div>
         </div>
         <div class="bibliomixed e504" xml:id="DOM">
            <div class="emphasis e505">Document Object Model Technical Reports</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e506" xlink:actuate="onRequest" xlink:href="http://www.w3.org/DOM/DOMTR" xlink:show="new" xlink:type="simple">http://www.w3.org/DOM/DOMTR</div>
         </div>
         <div class="bibliomixed e507" xml:id="DOM4J">
            <div class="emphasis e508">DOM4J Introduction</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e509" xlink:actuate="onRequest" xlink:href="http://dom4j.sourceforge.net/" xlink:show="new" xlink:type="simple">http://dom4j.sourceforge.net/</div>
         </div>
         <div class="bibliomixed e510" xml:id="XML">
            
            <div class="emphasis e511">Extensible Markup Language (XML) 1.0 (Fifth Edition)</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e512" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml/</div>
         </div>
         <div class="bibliomixed e513" xml:id="GOF">Gamma, E., R. Helm, R. Johnson, and J. Vlissides.
            
            <div class="emphasis e514">Design Patterns: Elements of Reusable Object-Oriented Software</div>
            Addison-Wesley, 1995.
         </div>
         <div class="bibliomixed e515" xml:id="XMLInJava">Harold, E. 
            <div class="emphasis e516">Processing XML with Java</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e517" xlink:actuate="onRequest" xlink:href="http://www.cafeconleche.org/books/xmljava/" xlink:show="new" xlink:type="simple">http://www.cafeconleche.org/books/xmljava/</div>
         </div>
         <div class="bibliomixed e518" xml:id="WhatsWrong">Harold, E.  "What's Wrong with XML APIs (and how to fix them)"
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e519" xlink:actuate="onRequest" xlink:href="http://www.xom.nu/whatswrong/whatswrong.html" xlink:show="new" xlink:type="simple">http://www.xom.nu/whatswrong/whatswrong.html</div>
         </div>
         <div class="bibliomixed e520" xml:id="Jaxen">
            <div class="emphasis e521">Jaxen</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e522" xlink:actuate="onRequest" xlink:href="http://jaxen.org/" xlink:show="new" xlink:type="simple">http://jaxen.org/</div>
         </div>
         <div class="bibliomixed e523" xml:id="JDOM">
            <div class="emphasis e524">JDOM v1.1.1 API Specification</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e525" xlink:actuate="onRequest" xlink:href="http://www.jdom.org/docs/apidocs/" xlink:show="new" xlink:type="simple">http://www.jdom.org/docs/apidocs/</div>
         </div>
         <div class="bibliomixed e526" xml:id="XMLNS">
            <div class="emphasis e527">Namespaces in XML 1.0 (Second Edition)</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e528" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-names" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml-names</div>
         </div>
         <div class="bibliomixed e529" xml:id="DMPerf">Sosnoski, D. "XML and Java technologies: Document models, Part 1: Performance"
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e530" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-injava/index.html" xlink:show="new" xlink:type="simple">http://www.ibm.com/developerworks/xml/library/x-injava/index.html</div>
         </div>
         <div class="bibliomixed e531" xml:id="DMUse">Sosnoski, D.  "XML and Java technologies: Java document model usage"
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e532" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-injava2/" xlink:show="new" xlink:type="simple">http://www.ibm.com/developerworks/xml/library/x-injava2/</div>
         </div>
         <div class="bibliomixed e533" xml:id="Woden">
            <div class="emphasis e534">Welcome to Woden</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e535" xlink:actuate="onRequest" xlink:href="http://ws.apache.org/woden/" xlink:show="new" xlink:type="simple">http://ws.apache.org/woden/</div>
         </div>
         <div class="bibliomixed e536" xml:id="Xalan">
            <div class="emphasis e537">Xalan-Java</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e538" xlink:actuate="onRequest" xlink:href="http://xml.apache.org/xalan-j/index.html" xlink:show="new" xlink:type="simple">http://xml.apache.org/xalan-j/index.html</div>
         </div>
         <div class="bibliomixed e539" xml:id="XalanDTM">
            <div class="emphasis e540">XalanDTM</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e541" xlink:actuate="onRequest" xlink:href="http://xml.apache.org/xalan-j/dtm.html" xlink:show="new" xlink:type="simple">http://xml.apache.org/xalan-j/dtm.html</div>
         </div>
         <div class="bibliomixed e542" xml:id="Infoset">
            <div class="emphasis e543">XML Information Set (Second Edition)</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e544" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml-infoset" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xml-infoset</div>
         </div>
         <div class="bibliomixed e545" xml:id="XPath1">
            <div class="emphasis e546">XML Path Language (XPath), Version 1.0</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e547" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath/</div>
         </div>
         <div class="bibliomixed e548" xml:id="WXS1">
            <div class="emphasis e549">XML Schema Part 1: Structures Second Edition</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e550" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-1/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-1/</div>
         </div>
         <div class="bibliomixed e551" xml:id="WXS2">
            <div class="emphasis e552">XML Schema Part 2: Datatypes Second Edition</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e553" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-2/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-2/</div>
         </div>
         <div class="bibliomixed e554" xml:id="XOM">
            <div class="emphasis e555">XOM 1.2.5</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e556" xlink:actuate="onRequest" xlink:href="http://www.xom.nu/apidocs/" xlink:show="new" xlink:type="simple">http://www.xom.nu/apidocs/</div>
         </div>
         <div class="bibliomixed e557" xml:id="XDM">
            <div class="emphasis e558">XQuery 1.0 and XPath 2.0 Data Model (XDM)</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e559" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel/</div>
         </div>
         <div class="bibliomixed e560" xml:id="XSLT1">
            <div class="emphasis e561">XSL Transformations (XSLT), Version 1.0</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e562" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt</div>
         </div>
         <div class="bibliomixed e563" xml:id="XT">
            <div class="emphasis e564">XT</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e565" xlink:actuate="onRequest" xlink:href="http://www.blnz.com/xt/index.html" xlink:show="new" xlink:type="simple">http://www.blnz.com/xt/index.html</div>
         </div>
      </div>
   </div>
</div>