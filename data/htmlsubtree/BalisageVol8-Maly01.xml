<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#UtilizingnewcapabilitiesofXMLlanguagestoverifyintegrityconstraintsANCHOR" name="UtilizingnewcapabilitiesofXMLlanguagestoverifyintegrityconstraintsTOC">Utilizing new capabilities of XML languages to verify integrity constraints</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#OutlineANCHOR" name="OutlineTOC">Outline</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OCLConstraintsANCHOR" name="OCLConstraintsTOC">OCL Constraints</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IteratorexpressionsANCHOR" name="IteratorexpressionsTOC">Iterator expressions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IteratorsviageneratedfunctionsANCHOR" name="IteratorsviageneratedfunctionsTOC">Iterators via generated functions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IteratorsviadynamicevaluationANCHOR" name="IteratorsviadynamicevaluationTOC">Iterators via dynamic evaluation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#HigherorderfunctionsANCHOR" name="HigherorderfunctionsTOC">Higher-order functions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#LocalvariablesANCHOR" name="LocalvariablesTOC">Local variables</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TuplesasmapsANCHOR" name="TuplesasmapsTOC">Tuples as maps</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DifferentkindsofcollectionsnestedcollectionsANCHOR" name="DifferentkindsofcollectionsnestedcollectionsTOC">Different kinds of collections, nested collections</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ErrorrecoveryANCHOR" name="ErrorrecoveryTOC">Error recovery</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC">Implementation</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ExpressionrewritingandsyntacticsugarANCHOR" name="ExpressionrewritingandsyntacticsugarTOC">Expression rewriting and syntactic sugar</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgementANCHOR" name="AcknowledgementTOC">Acknowledgement</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">acc-init</div>
         <div class="singletermTERMS">acc</div>
         <div class="singletermTERMS">accumulator</div>
         <div class="singletermTERMS">acc or (body)</div>
         <div class="singletermTERMS">age</div>
         <div class="singletermTERMS">at(i)</div>
         <div class="singletermTERMS">asserts</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">body</div>
         <div class="singletermTERMS">base</div>
         <div class="singletermTERMS">body expression</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">closure</div>
         <div class="singletermTERMS">c-&gt;forAll(v1,v2|v1 &lt;&gt; v2)</div>
         <div class="singletermTERMS">c-&gt;forAll(v1|c-&gt;forall(v2|v1&lt;&gt;v2))</div>
         <div class="singletermTERMS">Collection(Tuple(first: T1, second: T2))</div>
         <div class="singletermTERMS">c1</div>
         <div class="singletermTERMS">c2</div>
         <div class="singletermTERMS">collect</div>
         <div class="singletermTERMS">customer detail</div>
         <div class="singletermTERMS">Customer</div>
         <div class="singletermTERMS">child_N</div>
         <div class="singletermTERMS">choice_N</div>
         <div class="singletermTERMS">contexts</div>
         <div class="singletermTERMS">called</div>
         <div class="singletermTERMS">Cartesian product</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">Data &amp; Knowledge Engineering</div>
         <div class="singletermTERMS">Database Systems</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">exists(it|{body})</div>
         <div class="singletermTERMS">exists</div>
         <div class="singletermTERMS">evaluate</div>
         <div class="singletermTERMS">existsN</div>
         <div class="singletermTERMS">employees</div>
         <div class="singletermTERMS">every/satisfies</div>
         <div class="singletermTERMS">error-recovery instructions</div>
         <div class="singletermTERMS">Extreme Markup Languages 2006</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">forAll</div>
         <div class="singletermTERMS">for</div>
         <div class="singletermTERMS">function-arity</div>
         <div class="singletermTERMS">functionItemCall</div>
         <div class="singletermTERMS">firstName</div>
         <div class="singletermTERMS">false</div>
         <div class="singletermTERMS">function(item(), item()*) as item()*</div>
         <div class="singletermTERMS">function(item()) as xs:boolean</div>
         <div class="singletermTERMS">FM'99 Formal Methods</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getIndices</div>
         <div class="singletermTERMS">global</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">https://github.com/jpcs/rbtree.xq</div>
         <div class="singletermTERMS">higher-order functions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">indexOf</div>
         <div class="singletermTERMS">index-of</div>
         <div class="singletermTERMS">iterate</div>
         <div class="singletermTERMS">iterate(it; acc=false| {acc or {body}})</div>
         <div class="singletermTERMS">implies</div>
         <div class="singletermTERMS">iteration</div>
         <div class="singletermTERMS">if</div>
         <div class="singletermTERMS">is</div>
         <div class="singletermTERMS">iterates</div>
         <div class="singletermTERMS">invalid</div>
         <div class="singletermTERMS">invariants</div>
         <div class="singletermTERMS">Integrity Constraint</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">Journal of Systems and Software</div>
         <div class="singletermTERMS">Jakub</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">let</div>
         <div class="singletermTERMS">let/return</div>
         <div class="singletermTERMS">lastName</div>
         <div class="singletermTERMS">local</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">m.start = self.start</div>
         <div class="singletermTERMS">Mazeiar Salehie's OCL Tutorial.</div>
         <div class="singletermTERMS">maps</div>
         <div class="singletermTERMS">matches-&gt;exists(m:Match | m.start.equals(start))</div>
         <div class="singletermTERMS">maly@ksi.mff.cuni.cz</div>
         <div class="singletermTERMS">Martin</div>
         <div class="singletermTERMS">Malý</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
         <div class="singletermTERMS">newAcc</div>
         <div class="singletermTERMS">name</div>
         <div class="singletermTERMS">null</div>
         <div class="singletermTERMS">necasky@ksi.mff.cuni.cz</div>
         <div class="singletermTERMS">Nečaský</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">oclX:iterate</div>
         <div class="singletermTERMS">or</div>
         <div class="singletermTERMS">oclX:exists</div>
         <div class="singletermTERMS">oclIsInvalid</div>
         <div class="singletermTERMS">oclIsUndefined</div>
         <div class="singletermTERMS">oclIsInvalid(1 / 0)</div>
         <div class="singletermTERMS">oclX:oclIsInvalid(function() { 1 / 0 })</div>
         <div class="singletermTERMS">of e-commerce</div>
         <div class="singletermTERMS">OclX</div>
         <div class="singletermTERMS">OCL</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">p1</div>
         <div class="singletermTERMS">p2</div>
         <div class="singletermTERMS">product</div>
         <div class="singletermTERMS">parent</div>
         <div class="singletermTERMS">platform-independent level</div>
         <div class="singletermTERMS">platform-specific level</div>
         <div class="singletermTERMS">PIM schema</div>
         <div class="singletermTERMS">PSM schema</div>
         <div class="singletermTERMS">purchase order</div>
         <div class="singletermTERMS">product catalogue</div>
         <div class="singletermTERMS">parent</div>
         <div class="singletermTERMS">Project</div>
         <div class="singletermTERMS">project</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">self.start</div>
         <div class="singletermTERMS">self.matches.day</div>
         <div class="singletermTERMS">self</div>
         <div class="singletermTERMS">select</div>
         <div class="singletermTERMS">salary</div>
         <div class="singletermTERMS">schema in a platform-independent model</div>
         <div class="singletermTERMS">schema in a platform-specific model</div>
         <div class="singletermTERMS">start &lt;= end</div>
         <div class="singletermTERMS">self.start &lt;= self.end</div>
         <div class="singletermTERMS">set_N</div>
         <div class="singletermTERMS">seq_N</div>
         <div class="singletermTERMS">Select</div>
         <div class="singletermTERMS">Set difference</div>
         <div class="singletermTERMS">Schematron</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">t.firstName</div>
         <div class="singletermTERMS">true</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">Union</div>
         <div class="singletermTERMS">UML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">value-of</div>
         <div class="singletermTERMS">Validation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:iterate</div>
         <div class="singletermTERMS">xsl:evaluate</div>
         <div class="singletermTERMS">xsl:with-param</div>
         <div class="singletermTERMS">xsl:try</div>
         <div class="singletermTERMS">xsl:catch</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="UtilizingnewcapabilitiesofXMLlanguagestoverifyintegrityconstraintsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Utilizing new capabilities of XML languages to verify integrity constraints</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2012</div>
            <div class="confdates e5">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">In this work, we show how integrity constraints expressed using Object Constraint
               Language (OCL) can be verified using XML technologies - Schematron, XPath/XQuery and
               XSLT -
               and using Model Driven Architecture (MDA) principles. Some constructs typical for
               OCL
               constraints are different from the methods used in XPath/XQuery expressions. That
               is why for
               translating some OCL expressions, the standard XML toolset must be extended. We introduce
               such extension for the 2.0 versions of the languages, but with the new features and
               constructs proposed in drafts for XSLT 3.0, XPath 3.0 and XQuery 3.0, the transition
               from
               OCL is much more seamless and transparent. Higher-order functions, maps, error-recovery
               instructions etc. provide us with necessary power to translate a general OCL expression
               and
               we discuss in detail their potential. 
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Jakub</div>
               <div class="surname e11">Malý</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Jakub Malý is a Ph.D. student at Charles University in Prague, Czech Republic. 
                  His research areas involve conceptual modeling of XML data, integrity constraints,
                  evolution and adaptation 
                  of XML applications.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="orgname e15">XML and Web Engineering Research Group, Faculty of Mathematics and Physics, Charles
                  University, Prague, Czech Republic
               </div>
            </div>
            <div class="email e16">maly@ksi.mff.cuni.cz</div>
         </div>
         <div class="author e17">
            <div class="personname e18">
               <div class="firstname e19">Martin</div>
               <div class="surname e20">Nečaský</div>
            </div>
            <div class="personblurb e21">
               <div class="para e22">Martin Nečaský is an assistant professor at Charles University in Prague, Czech Republic.
                  
                  His research areas involve XML data design, integration, evolution and linked open
                  data. 
               </div>
            </div>
            <div class="affiliation e23">
               <div class="orgname e24">XML and Web Engineering Research Group, Faculty of Mathematics and Physics, Charles
                  University, Prague, Czech Republic
               </div>
            </div>
            <div class="email e25">necasky@ksi.mff.cuni.cz</div>
         </div>
         <div class="legalnotice e26">
            <div class="para e27">Copyright © 2012 by the authors. Used with permission.</div>
         </div>
         <div class="keywordset e28" role="author">
            <div class="keyword e29">Schematron</div>
            <div class="keyword e30">Integrity Constraint</div>
            <div class="keyword e31">OCL</div>
            <div class="keyword e32">UML</div>
            <div class="keyword e33">Validation</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e34">
         <div class="title e35">Introduction</div>
         <div class="para e36">Unified Modeling Language (UML) has proved to be a powerful language for modeling
            software
            systems. Modeling is an important activity in the software development process. It
            is a good
            way of how to abstract from technical details of a software system and concentrate
            on
            structural, semantic and functional aspects of the system.
            In connection with UML, a methodology called Model-Driven Architecture (MDA) has been
            established. It proposes to start modeling a system at an abstract 
            <div class="emphasis e37" role="ital">platform-independent level</div> stripped from technical details and then specify the
            model with more technical details at a 
            <div class="emphasis e38" role="ital">platform-specific
               level
            </div>. From this level, actual executable code can be then generated (ideally)
            automatically. In practice, the step from the platform-specific model (PSM) to executable
            code
            requires usually some level of the designer's interaction, but nonetheless, the presence
            of
            the layered model is a significant improvement both during initial formation of the
            implementation and it's management in the future. 
         </div>
         <div class="para e39">In our previous work (
            <div class="xref e40" linkend="necasky12a"></div>, 
            <div class="xref e41" linkend="necasky12b"></div>), we have
            shown how beneficial it can be to interconnect the world of UML and MDA with the world
            of
            designing XML schemas. Our premise was the fact that complex software systems are
            often
            modeled with UML diagrams at the platform-independent level. In particular, a UML
            class
            diagram is suitable for modeling a conceptual schema of the application domain. Such
            schema is
            called 
            <div class="emphasis e42" role="ital">schema in a platform-independent model</div> or simply
            
            <div class="emphasis e43" role="ital">PIM schema</div> in MDA terminology. The term model means a
            modeling language (the language of UML class diagrams in our case). Our method allows
            to
            exploit the existing PIM schema to design XML schemas in the system. Each XML schema
            is
            modeled as so called 
            <div class="emphasis e44" role="ital">schema in a platform-specific model</div> or
            simply 
            <div class="emphasis e45" role="ital">PSM schema</div>. A PSM schema is, again, a UML class
            diagram. It represents a part of the PIM schema and shapes it to the form of the aimed
            XML
            schema. From the PSM schema, the XML schema expressed in a selected language (we currently
            support XML Schema) can be derived automatically. We have implemented the method in
            our CASE
            tool 
            <div class="emphasis e46" role="ital">
               <div class="xref e47" linkend="exolutio"></div>
            </div>. 
         </div>
         <div class="para e48">One advantage of such approach is that an XML schema designer takes an existing PIM
            schema
            and derives from it a PSM schema of the aimed XML schema. This is much easier then
            writing the
            XML schema manually even when the designer uses an XML schema visualization tool.
            Another
            advantage of using a PIM schema is that it prevents from inconsitencies between the
            XML schema
            and the conceptual schema. 
         </div>
         <div class="para e49">Several UML/XML schema mapping approaches were proposed so far (
            <div class="xref e50" linkend="pagano09"></div>, 
            <div class="xref e51" linkend="bauman09"></div>), the advantage of our approach is hidden in the fact that a
            software system usually does not presume only one XML schema, but a whole family of
            XML
            schemas each representing a selected part of the application domain (e.g. in the domain
            of
            
            <div class="emphasis e52">of e-commerce</div>, the system might contain following XML schemas:
            
            <div class="emphasis e53" role="ital">purchase order</div>, 
            <div class="emphasis e54" role="ital">product
               catalogue
            </div> or 
            <div class="emphasis e55" role="ital">customer detail</div>). Moreover, several
            different XML schemas may overlap and share some part of the reality but may represent
            it
            differently (e.g., the concept of 
            <div class="emphasis e56" role="ital">Customer</div> in 
            <div class="emphasis e57">of
               e-commerce
            </div> is shared by different XML schemas which represent it with different
            XML structures). Using our approach, the reality is modeled only once in the PIM schema
            and
            its different representations in different XML schemas are derived from the PIM schema
            as PSM
            schemas. When the designer examines a particular PSM schema, he can always track any
            used
            concept back to the common model and thanks to this fact never looses the "big picture".
            The
            management of a family of schemas is thus more efficient and error-proof. Moreover,
            our
            approach makes the XML schemas better readable - anyone can look up what real-world
            concepts
            modeled in the conceptual schema are represented with a selected part of a particular
            XML
            schema and, vice versa, how a selected real-world concept is represented in which
            XML schemas. 
         </div>
         <div class="para e58">In this work, we extend our previous work towards modeling complex integrity constraints
            (ICs). ICs are a substantial part of every software system, equally important as a
            conceptual
            schema. However, most of them cannot be expressed with UML class diagrams and, therefore,
            Object Constraint Language (OCL, see 
            <div class="xref e59" linkend="ocl"></div>) was introduced for this purpose.
            OCL is a formal language which can be used to declare ICs over a UML model. The ICs
            are in a
            form of logical expressions and can check constraints such as "employee, who is a
            division
            manager, must have a collage degree" or "the store manager can get a bonus only when
            the
            profits have grow at least 10% compared to last year" (the following section contains
            more
            examples of integrity constraints and how they are expressed fromally in OCL) . Usaing
            OCL has
            two main benefits in comparison to the natural language: 
            <div class="orderedlist e60">
               <div class="listitem e61">
                  <div class="para e62">unlike natural language, the formal expression is exact and unambiguous,</div>
               </div>
               <div class="listitem e63">
                  <div class="para e64">an expression in a formal modeling language can be used to generate code that
                     verifies the validity of the IC in actual data or running program.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e65">The authors of Dresden OCL toolkit (see 
            <div class="xref e66" linkend="dresden"></div>) have demonstrated how
            OCL ICs can be checked at runtime in Java (by translating OCL into Java code and adding
            triggers that verify the constraints when objects are changed) and also in relational
            databases (by translation of OCL expression into SQL statements, which allow to select
            records
            violating the IC). 
         </div>
         <div class="para e67">When a system uses XML (e.g. for message exchange in communication or storing data),
            the
            ICs should be checked in the XML data and using XML technologies. In this work, we
            show how
            OCL ICs can be checked at runtime in XML documents using Schematron. The result of
            our
            research can be again profitably used by XML schema designers in cases when a PIM
            schema
            complemented with OCL ICs. Together with modeling the XML schemas as PSM schemas derived
            from
            the PIM schema, the designers can also easily convert OCL ICs from the PIM schema
            to the PSM
            schemas.  
         </div>
         <div class="para e68">Having OCL ICs expressed at the platform-independent level the question is how they
            can be
            translated to the platform-specific level and from here to the XML schema level. The
            conversion to the platform-specific level is not covered in this paper. Just let us
            note that
            we have already implemented several methods for this conversion in our tool eXolutio
            but we do
            not describe them in this paper. Instead, we focus on the actual conversion of OCL
            ICs
            expressed at the platform-specific level to their suitable XML conterpart, which are
            Schematron schemas. 
            <div class="xref e69" linkend="fig-levels"></div> shows an overall architecture of the system. 
         </div>
         <div class="figure e70" xml:id="fig-levels">
            <div class="title e71">eXolutio - architecture overview</div>
            <div class="mediaobject e72">
               <div class="imageobject e73">
                  <div class="metaBox e74"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e141').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e141" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e74'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Maly01/Maly01-001.png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e75">Schematron is a rule-based XML schema language based on XPath expressions. It is often
            used as a complement of grammar based schema languages (such as XML Schema, Relax
            NG or DTD),
            which define a proper vocabulary and validate the structure of the XML document, to
            check data
            and co-occurrence constraints - it serves a similar purpose, as does OCL in UML. Because
            the
            approach used in OCL to build expressions is rather different than the space of expression
            provided by XPath, it is necessary to extend XPath to provide comparable expressive
            power. We
            implemented the required extensions in our XSLT functions library called 
            <div class="emphasis e76" role="ital">OclX</div>. Since Schematron validation is usually implemented as several steps of
            XSLT processing, our extension will not require modification of the existing Schematron
            validation tools, except referencing OclX library. We will examine different approaches,
            how
            the required functions can be implemented, and show how several of the new constructs
            (such as
            
            <div class="emphasis e77" role="ital">higher-order functions</div>, 
            <div class="emphasis e78" role="ital">maps</div>, or 
            <div class="emphasis e79" role="ital">error-recovery instructions</div>) proposed
            in the 3.0 drafts of XPath, XQuery and XSLT can serve our goal. 
         </div><a name="OutlineANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e80">
            <div class="title e81">Outline</div>
            <div class="para e82">The rest of this work is organized as follows: 
               <div class="xref e83" linkend="sec-constraints"></div> gives
               brief introduction to OCL and shows examples demonstrating its expressive power. 
               <div class="xref e84" linkend="sec-iterator"></div> lists possibilities of translating iterator expressions, 
               <div class="xref e85" linkend="sec-tuples"></div> elaborates on tuples, 
               <div class="xref e86" linkend="sec-collections"></div> on other
               types of collections than sequences. In 
               <div class="xref e87" linkend="sec-errors"></div>, we describe, how
               semantics of OCL error handling can be achieved. 
               <div class="xref e88" linkend="sec-implementation"></div>
               describes the implementation of OclX in our tool and the use of XProc for validation.
               In
               
               <div class="xref e89" linkend="sec-sugar"></div>, we outline possibilities of rewriting certain classes of
               expressions. In 
               <div class="xref e90" linkend="sec-conclusion"></div>, we conclude.
            </div>
         </div>
      </div><a name="OCLConstraintsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e91" xml:id="sec-constraints">
         <div class="title e92">OCL Constraints</div>
         <div class="para e93">In this section, we will show on several examples the usage of OCL constraints. </div>
         <div class="para e94">
            <div class="xref e95" linkend="fig-pim"></div> shows a sample platform-independent schema of a chess leagues
            information system. 
            <div class="popupBox e96">
               <div class="popupLabel" onmouseover="$('#d1e187').show('1000');" onmouseout="$('#d1e187').hide('1000');">[ footnote ]</div>
               <div id="d1e187" style="display: none;">
                  <div class="footnote">
                     <div class="para e97">Examples for this paper are based on 
                        <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e98" xlink:actuate="onRequest" xlink:href="http://www.stargroup.uwaterloo.ca/~ltahvild/courses/ECE493-T5/tutorials/Tutorial-Feb16-OCL.pdf" xlink:show="new" xlink:type="simple">Mazeiar Salehie's OCL Tutorial.</div>
                        
                     </div>
                  </div>
               </div>
            </div>. 
         </div>
         <div class="figure e99" xml:id="fig-pim">
            <div class="title e100">A sample platform-indpendent schema</div>
            <div class="mediaobject e101">
               <div class="imageobject e102">
                  <div class="metaBox e103"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e199').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e199" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e103'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Maly01/Maly01-002.png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e104">
            
            <div class="xref e105" linkend="fig-pim-ocl"></div> shows some constraints defined for the PIM schema. We will not
            elaborate the syntax of OCL in detail in this paper. Briefly: OCL script consists
            of
            declaration of blocks of integrity constraints, each block starts with the selection
            of
            context class and contains one or more invariants for this class. The invariants are
            logical
            expression refereing to the concepts defined in the PIM schema. Standard OCL does
            not allow to
            specify an error message describing the violated constraint. However, this is a valued
            feature
            of Schematron which we did not want to lose. That is why we extended OCL to allow
            an optional
            message after each invariant definition. The message can contain subexpression, as
            is shown in
            IC PIM1. 
         </div>
         <div class="figure e106" xml:id="fig-pim-ocl">
            <div class="title e107">PIM ICs for chess leagues</div>
            <div class="programlisting e108" xml:space="preserve">context Tournament
               /* PIM1 */
               inv: 
               <div class="emphasis e109" role="bold">start &lt;= end</div>
               message: 
               <div class="emphasis e110" role="ital">'Dates inconsistent {start} is grater than {end} in {name}'</div>
               /* which is an abbreviation for: */ 
               inv: 
               <div class="emphasis e111" role="bold">self.start &lt;= self.end</div>
               /* PIM2 */
               inv: 
               <div class="emphasis e112" role="bold">matches-&gt;forAll(m:Match | m.start &gt;= start and m.end &lt;= end)</div>
               message: 
               <div class="emphasis e113" role="ital">'All matches in a tournament occur within the tournament’s time frame'</div>
               /* PIM2 in the previus is in fact an abbreviation for: */
               inv: 
               <div class="emphasis e114" role="bold">self.matches-&gt;forAll(m:Match | m.start &gt;= self.start and m.end &lt;= self.end)</div>
               /* PIM3 */
               inv: 
               <div class="emphasis e115" role="bold">matches-&gt;forAll(m | m.players-&gt;forAll(mp | mp.tournaments-&gt;includes(self)))</div>
               message: 
               <div class="emphasis e116" role="ital">'A match can only involve players who are accepted in the tournament'</div>
               /* PIM4 */
               inv: 
               <div class="emphasis e117" role="bold">matches-&gt;exists(m:Match | m.start.equals(start))</div>
               message: 
               <div class="emphasis e118" role="ital">'Each tournament conducts at least one match on the first day'</div>
            </div>
         </div>
         <div class="para e119"> From this schema, two platform-specific schemas (
            <div class="xref e120" linkend="fig-psm1"></div>, 
            <div class="xref e121" linkend="fig-psm2"></div>) were created, each using the classes from 
            <div class="xref e122" linkend="fig-pim"></div>,
            but each for a different type of XML documents used in the system. XSDs obtained from
            the PSM
            schemas are shown alongside the figures. 
         </div>
         <div class="figure e123" xml:id="fig-psm1">
            <div class="title e124">A sample platform-specific schema modeling a type of XML documents for Matches and
               Players involved in a Tournament
            </div>
            <div class="informaltable e125" frame="void" rules="none">
               <div class="tr e126">
                  <div class="td e127">
                     
                     <div class="mediaobject e128">
                        <div class="imageobject e129">
                           <div class="metaBox e130"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e256').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e256" class="metaSource" style="display:none;">                
                                 &lt;imagedata<span class="metaAttribute">class='e130'
                                    </span><span class="metaAttribute">fileref='../../../vol8/graphics/Maly01/Maly01-003.png'
                                    </span><span class="metaAttribute">format='png'
                                    </span>
                                 &gt;
                                 
                              </div>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="td e131">
                     
                     <div class="programlisting e132" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
                        &lt;xs:element name="tournament" type="Tournament" /&gt;
                        &lt;xs:complexType name="Tournament"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="name" type="xs:string" /&gt;
                        &lt;xs:element name="start" type="xs:dateTime" /&gt;
                        &lt;xs:element name="end" type="xs:dateTime" /&gt;
                        &lt;xs:element name="matches" type="Matches" /&gt;
                        &lt;xs:element name="participatingPlayers" type="Players" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:complexType name="Matches"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="day" type="Day" maxOccurs="unbounded" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:complexType name="Players"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="player" type="Player" maxOccurs="unbounded" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:complexType name="Player"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="name" type="xs:string" /&gt;
                        &lt;xs:element name="email" type="xs:string" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        ...
                        &lt;/xs:schema&gt;
                     </div>
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="figure e133" xml:id="fig-psm2">
            <div class="title e134">A sample platform-specific schema modeling a type of XML documents for Tournament
               Qualification
            </div>
            <div class="informaltable e135" frame="void" rules="none">
               <div class="tr e136">
                  <div class="td e137">
                     
                     <div class="mediaobject e138">
                        <div class="imageobject e139">
                           <div class="metaBox e140"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e273').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e273" class="metaSource" style="display:none;">                
                                 &lt;imagedata<span class="metaAttribute">class='e140'
                                    </span><span class="metaAttribute">fileref='../../../vol8/graphics/Maly01/Maly01-004.png'
                                    </span><span class="metaAttribute">format='png'
                                    </span>
                                 &gt;
                                 
                              </div>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="td e141">
                     
                     <div class="programlisting e142" xml:space="preserve">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
                        &lt;xs:element name="tournaments" type="Tournaments" /&gt;
                        &lt;xs:complexType name="Tournaments"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="tournament" type="Tournament" 
                        minOccurs="0" maxOccurs="unbounded" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:complexType name="Tournament"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="name" type="xs:string" /&gt;
                        ...
                        &lt;xs:element name="qualification" type="Qualification" /&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:complexType name="Qualification"&gt;    
                        &lt;xs:attributeGroup ref="OpenTournament-att-opt" /&gt;
                        &lt;xs:attributeGroup ref="League-att-opt" /&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:attributeGroup name="OpenTournament-att-opt"&gt;
                        &lt;xs:attribute name="open" type="xs:boolean" use="optional" /&gt;
                        &lt;/xs:attributeGroup&gt;
                        &lt;xs:attributeGroup name="League-att-opt"&gt;
                        &lt;xs:attribute name="leagueName" type="xs:string" use="optional" /&gt;
                        &lt;/xs:attributeGroup&gt;
                        &lt;/xs:schema&gt;
                     </div>
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="para e143">
            <div class="xref e144" linkend="fig-psm-ocl"></div> shows, how the constraints from 
            <div class="xref e145" linkend="fig-pim-ocl"></div> can be applied in the PSM schemas, where they are relevant. For the purposes of using
            OCL
            at the PSM layer, we added additional ways of navigation (to those defined in the
            standard) -
            
            <div class="emphasis e146" role="ital">parent</div> and 
            <div class="emphasis e147" role="ital">child_N</div>,
            
            <div class="emphasis e148" role="ital">choice_N</div>, 
            <div class="emphasis e149" role="ital">set_N</div>,
            
            <div class="emphasis e150" role="ital">seq_N</div> (navigate to the n-th child, choice set or sequence
            in the content model of a class). 
         </div>
         <div class="para e151">It is also possible to add additional constraints, which do not have a counterpart
            PIM
            constraint, for each PSM schema (e.g. constraint PSM5). In this paper, we will not
            show, how
            the relevant constraints are chosen for each PSM schema, but we will focus on how
            they can be
            verified in XML documents. (MARTIN: Tady ale zhruba rozved, jake jsou vyhody toho,
            ze to je na
            PIMu. Tj. odpovedi na otazku, proc si to nemuzu rovnou vyjadrit na PSM urovni?) 
         </div>
         <div class="figure e152" xml:id="fig-psm-ocl">
            <div class="title e153">PSM ICs for chess leagues</div>
            <div class="programlisting e154" xml:space="preserve">/*** Match schedule schema constraints ***/
               context Tournament
               /* PSM1 */
               inv: 
               <div class="emphasis e155" role="bold">start &lt;= end</div>
               /* which is an abbreviation for: */ 
               inv: 
               <div class="emphasis e156" role="bold">self.start &lt;= self.end</div>
               message: 
               <div class="emphasis e157" role="ital">'Dates inconsistent, {start} is greater than {end} in {name}'</div>
               /* PSM2 */
               inv: 
               <div class="emphasis e158" role="bold">matches.day.match-&gt;forAll(m:Match | m.start.after(start) and m.end.before(end))</div>
               /* abbreviation for: */
               inv: 
               <div class="emphasis e159" role="bold">self.matches.day-&gt;collect(d:Day | d.match)-&gt;
                  forAll(m:Match | m.start.after(self.start) and m.end.before(self.end))
               </div>
               message: 
               <div class="emphasis e160" role="ital">'All matches in a tournament occur within the tournament\'s time frame'</div>
               context Match
               /* PSM3: */
               inv: 
               <div class="emphasis e161" role="bold">matchPlayers.player-&gt;forAll(p | p.parent.parent.parent.parent.parent.
                  participatingPlayers.player-&gt;exists(px | px.name = p.name))
               </div>
               message: 
               <div class="emphasis e162" role="ital">'A match can only involve players who are accepted in the tournament'</div>
               context Tournament
               /* PSM4 */
               inv: 
               <div class="emphasis e163" role="bold">matches.day.match-&gt;exists(m:Match | m.start.trunc() = start.trunc())</div>
               message: 
               <div class="emphasis e164" role="ital">'Each tournament conducts at least one match on the first day of the tournament'</div>
               /*** Tournaments schedule schema constraints ***/
               context Tournament
               /* PSM5 */
               inv: 
               <div class="emphasis e165" role="bold">qualification.choice_1.child_1.open = true or
                  qualification.choice_1.child_2.leagueName &lt;&gt; null
               </div>
               message: 
               <div class="emphasis e166" role="ital">'Tournament must be either open tournament or belong to a league'</div>
            </div>
         </div>
         <div class="para e167">From the nature of the excerpt 
            <div class="xref e168" linkend="fig-psm-ocl"></div>, it can be seen that
            
            <div class="emphasis e169" role="ital">contexts</div> and 
            <div class="emphasis e170" role="ital">invariants</div> in
            OCL play the same role as rules' 
            <div class="emphasis e171" role="ital">contexts</div> and 
            <div class="emphasis e172" role="ital">asserts</div> in Schematron. The core of the transition from OCL to
            Schematron thus lies in translating OCL expressions into XPath tests, preserving the
            semantics. Some expressions (e.g. literals, if-then-else, variables, arithmetic, string
            and
            boolean operations, some collection operations) may be mapped directly to a corresponding
            XPath expression or function. 
         </div>
         <div class="para e173">For some operations, a corresponding function does not exists or has a different semantics
            (e.g. OCL 
            <div class="code e174">indexOf</div> behaves just like XPath 
            <div class="code e175">index-of</div> when the searched
            item occurs at most once in the searched sequence, but XPath version returns indexes
            of all
            occurrences, when there are more). For these cases, we created a set of functions
            in OclX
            library preserving the semantics. 
         </div>
         <div class="para e176">Feature-call expressions are a fundamental part of OCL - starting at a variable, they
            allow traversing the UML model along associations and accessing attributes. These
            are mapped
            to path expressions of XPath, which traverse the XML document. E.g. expressions
            
            <div class="code e177">self.start</div> or 
            <div class="code e178">self.matches.day</div> can be expressed as
            
            <div class="code e179">$self/start</div> and 
            <div class="code e180">$self/matches/day</div> respectively. 
         </div>
         <div class="para e181">In the following sections, we will be dealing with those OCL constructs that cannot
            be
            expressed trivially - iterator expressions, tuples and nested sequences. We will also
            analyse
            the differences in error recovery in both languages. 
         </div>
      </div><a name="IteratorexpressionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e182" xml:id="sec-iterator">
         <div class="title e183">Iterator expressions</div>
         <div class="para e184">In the examples above, a construct distinctive for OCL is used several times. It is
            the
            so-called iterator expression. An iterator expression is a certain kind of a function.
            It is always
            called on a collection object. It does not have ordinary parameters, instead each
            usage
            declares the iterator variable(s) it will use and a 
            <div class="emphasis e185" role="ital">body
               expression
            </div>. OCL standard library contains several predefined iterator
            expressions, the fundamental being 
            <div class="code e186">iterate</div>. Its most general form is: 
         </div>
         <div class="programlisting e187" xml:space="preserve"> iterate(i; acc = {acc-init} | {body}) </div>
         <div class="para e188"> The semantics of the expression is as follows: 
            <div class="orderedlist e189">
               <div class="listitem e190">
                  <div class="para e191">Expression 
                     <div class="code e192">acc-init</div> is evaluated (in the actual context, i.e. it may
                     reference any variables valid in the calling expression). The result is assigned to
                     variable 
                     <div class="code e193">acc</div>, which, from now on, functions as an accumulator.
                  </div>
               </div>
               <div class="listitem e194">
                  <div class="para e195">For each member of the source collection (for which iterate is called), the member
                     is assigned to variable 
                     <div class="code e196">i</div>. Variables 
                     <div class="code e197">i</div> and 
                     <div class="code e198">acc</div>
                     (containing the value of accumulator from the previous iteration) are added to the
                     context. 
                  </div>
               </div>
               <div class="listitem e199">
                  <div class="para e200">Expression 
                     <div class="code e201">body</div> is evaluated (the context now contains the variables
                     
                     <div class="code e202">i</div> and 
                     <div class="code e203">acc</div>. The result is assigned to variable
                     
                     <div class="code e204">acc</div> and will be used in the next iteration.
                  </div>
               </div>
               <div class="listitem e205">
                  <div class="para e206">After the last iteration, the value in the accumulator is returned as a result.
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="para e207">There are several facts regarding iterator expressions: 
            <div class="orderedlist e208">
               <div class="listitem e209">
                  <div class="para e210">There are two fundamental iterator operations - 
                     <div class="code e211">closure</div> and
                     
                     <div class="code e212">iterate</div>. From these two, 
                     <div class="code e213">iterate</div> is not very often used
                     directly by the designers working with OCL. More often, another, more specific, iterator
                     expression is used. The importance of iterate lies in the fact that all other iterator
                     (with the exception of 
                     <div class="code e214">closure</div>) expressions (and a majority of collection
                     operations) can be defined in terms of the fundamental operation 
                     <div class="code e215">iterate</div>.
                     E.g. operation 
                     <div class="code e216">exists(it|{body})</div> is defined as 
                     <div class="code e217">iterate(it; acc=false|
                        {acc or {body}})
                     </div>. 
                  </div>
               </div>
               <div class="listitem e218">
                  <div class="para e219">Iterator expressions 
                     <div class="code e220">forAll</div> and 
                     <div class="code e221">exists</div> (serving as
                     quantifiers) together with 
                     <div class="code e222">not</div> and 
                     <div class="code e223">implies</div> make OCL
                     expressions at least as powerful as first order logic . Operation 
                     <div class="code e224">closure</div>
                     increases the expressive power with the possibility to compute transitive closures.
                     Operation 
                     <div class="code e225">iterate</div> allows to compute primitively recursive functions (for
                     more on the expressive power, see 
                     <div class="xref e226" linkend="Mandel99"></div>.
                  </div>
               </div>
               <div class="listitem e227">
                  <div class="para e228">Multiple iteration variables, such as in 
                     <div class="code e229">c-&gt;forAll(v1,v2|v1 &lt;&gt; v2)</div>,
                     are allowed for some expressions, but that is just a syntactic shortcut for nested
                     calls
                     (i.e. 
                     <div class="code e230">c-&gt;forAll(v1|c-&gt;forall(v2|v1&lt;&gt;v2))</div>). 
                  </div>
               </div>
               <div class="listitem e231">
                  <div class="para e232">Collection operations define additional variables to 
                     <div class="code e233">self</div>, which is
                     
                     <div class="emphasis e234" role="ital">global</div> in the scope of the invariant, and these
                     variables (iterators and accumulator) are 
                     <div class="emphasis e235" role="ital">local</div> (they
                     are valid in the subexpression only).
                  </div>
               </div>
            </div>
         </div>
         <div class="para e236">When we want to translate OCL ICs for XML, property 1 guarantees that showing how
            to
            express 
            <div class="code e237">iterate</div> and 
            <div class="code e238">closure</div> proves that other iterator expressions
            can be expressed as well, because they can be defined using these two (although the
            actual
            implementation would be often more efficient when implemented directly). Property
            3 relieves
            us of the necessity of considering expressions with multiple iterators. Property 4
            requires
            the translation to abide the rules for context and scope of variables. Every expression
            can
            refer to the global variable 
            <div class="code e239">self</div> and possibly other global variables declared
            explicitly by the user. Iterator expressions define local variables. 
         </div>
         <div class="para e240">There is no construct similar to iterator expression in XPath, which is used by
            Schematron. In some special cases, 
            <div class="code e241">iterate</div> can be translated to XPath
            
            <div class="code e242">for</div> expression, but not in general - whereas 
            <div class="code e243">iterate</div> can in each
            iteration refer to the result of the previous iterations (through 
            <div class="code e244">acc</div> variable),
            in XPath 
            <div class="code e245">for</div>, computations of every iteration are strictly separated. Thus, XPath
            must be extended to fully support iterator expressions and in this section, we will
            show
            several approaches, how it can be achieved. Since "iterate" is a name of a construct
            in OCL, a
            name of its implementation in our library OclX and also a name of an XSLT instruction,
            we will
            distinguish them by using 
            <div class="code e246">iterate</div> for the OCL construct,
            
            <div class="code e247">oclX:iterate</div> for its implementation in OclX and by refering to the XSLT
            instruction as to 
            <div class="code e248">xsl:iterate</div>. 
         </div><a name="IteratorsviageneratedfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e249">
            <div class="title e250">Iterators via generated functions</div>
            <div class="para e251">The principle of using accumulators in recursive calls is a routine practice in XSLT.
               The expression from the integrity constraint PSM4 from 
               <div class="xref e252" linkend="fig-psm-ocl"></div> can be
               rewritten into an XPath expression and an accompanying XSLT function as follows: 
            </div>
            <div class="figure e253" xml:id="xslt-exists-gen">
               <div class="title e254">Usage of 
                  <div class="code e255">exists</div> translated to an XSLT function
               </div>
               <div class="programlisting e256" xml:space="preserve">&lt;xsl:value-of select="oclX:iterate(matches/day/match, false(), 1, 
                  count(matches/day/match), current())" /&gt;
                  
                  &lt;xsl:function name="oclX:iterate"&gt;
                  &lt;xsl:param name="collection" as="item()*" /&gt;
                  &lt;xsl:param name="acc" as="xs:boolean" /&gt;	
                  &lt;xsl:param name="iteration" as="xs:integer" /&gt;
                  &lt;xsl:param name="total-iterations" as="xs:integer"/&gt;
                  &lt;xsl:param name="self" as="item()" /&gt;
                  
                  &lt;xsl:choose&gt;
                  &lt;xsl:when test="$iteration &amp;lt;= $total-iterations"&gt;
                  &lt;xsl:variable name="m" select="$collection[$iteration]" /&gt;
                  &lt;xsl:variable name="newAcc" as="xs:boolean"&gt;
                  &lt;xsl:sequence select="$acc or ($m/start eq $self/start)" /&gt;
                  &lt;/xsl:variable&gt;
                  &lt;xsl:value-of select="oclX:iterate($collection, $newAcc, 
                  $iteration + 1, $total-iterations, $self)" /&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;
                  &lt;xsl:value-of select="$accumulator" /&gt;
                  &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                  &lt;/xsl:function&gt;
               </div>
            </div>
            <div class="para e257">The context of the expression (valid variables) is passed as parameters
               (
               <div class="code e258">accumulator</div>, 
               <div class="code e259">self</div> and 
               <div class="code e260">iteration</div>). The value of
               accumulator is computed using the combination of the two expressions: expression from
               the
               definition of 
               <div class="code e261">exists</div> function (
               <div class="code e262">acc or (body)</div>) and from the actual
               call of the function (
               <div class="code e263">m.start = self.start</div>), which is substituted for
               
               <div class="code e264">body</div>. 
            </div>
            <div class="para e265">In this way, it is possible to translate every iterator expression (
               <div class="code e266">closure</div>
               function can be expressed similarly). The negative side is that for each usage (call)
               of an
               iterator expression, a separate function has to be generated and each Schematron schema
               must
               be equipped with a specific set of functions that handle iterator expressions. The
               generated
               functions for the same iterator expression (e.g. 
               <div class="code e267">exists</div>) would differ very
               little (in the case of exists, only in the second argument of 
               <div class="code e268">or</div> computing the
               value of 
               <div class="code e269">newAcc</div>). Our aim is to create a set of universal functions directly
               corresponding to general iterator expresions, but for that, we will need some features
               beyond the 2.0 versions of XPath and XSLT. 
            </div>
         </div><a name="IteratorsviadynamicevaluationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e270">
            <div class="title e271">Iterators via dynamic evaluation</div>
            <div class="para e272">Function in 
               <div class="xref e273" linkend="xslt-exists-gen"></div> can be looked upon as a template. As we
               have pointed out in the previous paragraph, the generated functions for all iterator
               expressions (except 
               <div class="code e274">closure</div>) would differ very little - only in the line
               computing the next value of the accumulator. Moreover, the functions generated for
               different
               calls of the same predefined iterator (e.g. all calls of 
               <div class="code e275">exists</div>) would differ
               even less - only in the 
               <div class="code e276">body</div> (
               <div class="code e277">$m/start eq $self/start</div> in the
               example). Thus, the whole generated function can be looked upon as a sort of template.
               If
               only it were possible to create such "templated function", we would be able to use
               the same
               template for all calls, parameterized by 
               <div class="code e278">body</div> .
            </div>
            <div class="para e279">One way to achieve this is by using dynamic evaluation. Each iterator expression can
               then be mapped to a call of the same function, for which 
               <div class="code e280">body</div> is passed as a
               string. The value of 
               <div class="code e281">body</div> is then computed dynamically. 
               <div class="xref e282" linkend="xslt-iterate-dynamic"></div> shows an implementation of 
               <div class="code e283">iterate</div> using
               dynamic evaluation.
            </div>
            <div class="figure e284" xml:id="xslt-iterate-dynamic">
               <div class="title e285">Generic 
                  <div class="code e286">oclX:iterate</div> function implemented using dynamic
                  evaluation
               </div>
               <div class="programlisting e287" xml:space="preserve">&lt;xsl:function name="oclX:iterate" as="item()*"&gt;
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
                  &lt;xsl:param name="acc-init" as="xs:string"/&gt;
                  &lt;xsl:param name="body" as="xs:string" /&gt;
                  &lt;xsl:param name="self" as="xs:item()"/&gt;    
                  
                  &lt;xsl:variable name="accumulatorInitialValue" as="item()*"&gt;
                  
                  <div class="emphasis e288" role="bold">&lt;xsl:sequence select="dyn:evaluate($acc-init)"/&gt;</div>
                  &lt;/xsl:variable&gt;
                  
                  &lt;xsl:sequence select="oclXin:iterate-rec($collection, $iterationVar, $accumulatorVar,
                  
                  $accumulatorInitialValue, $body, 1, count($collection))"
                  /&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;xsl:function name="oclXin:iterate-rec" as="item()*"&gt;
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
                  &lt;xsl:param name="accumulatorVar" as="xs:string"/&gt;
                  &lt;xsl:param name="acc" as="item()*"/&gt;
                  &lt;xsl:param name="body" as="xs:string"/&gt;
                  &lt;xsl:param name="iteration" as="xs:integer"/&gt;
                  &lt;xsl:param name="totalIterations" as="xs:integer"/&gt;
                  &lt;xsl:param name="self" as="xs:item()"/&gt;     
                  
                  &lt;xsl:choose&gt;
                  &lt;xsl:when test="$iteration = $totalIterations + 1"&gt;
                  &lt;!-- return accumulated value --&gt;
                  &lt;xsl:sequence select="$acc"/&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;
                  &lt;-- iterator value for this iteration --&gt;
                  &lt;xsl:variable name="m" as select="$collection[$iteration]" /&gt;
                  &lt;xsl:variable name="newAcc" as="item()*"&gt;
                  
                  <div class="emphasis e289" role="bold">&lt;xsl:sequence select="dyn:evaluate($body)"/&gt;</div>
                  &lt;/xsl:variable&gt;
                  &lt;!-- call recursively --&gt;
                  &lt;xsl:sequence
                  select="oclXin:iterate-rec($collection, $iterationVar, $accumulatorVar, 
                  $newAcc, $body, $iteration + 1, $totalIterations, $self)" /&gt;
                  &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                  &lt;/xsl:function&gt;
               </div>
            </div>
            <div class="para e290">Dynamic evaluation is a feature not present in standardized XSLT 2.0, but exists both
               in
               the form of cross-processor portable external libraries (such as 
               <div class="xref e291" linkend="exslt"></div>) or
               vendor-specific extensions (e.g. in 
               <div class="xref e292" linkend="saxon"></div>). Unfortunately, the semantics
               of dynamic evaluation is not consistent in these cases, e.g. EXSLT allows to use free
               variables in the evaluated expression (e.g. 
               <div class="code e293">self</div>, 
               <div class="code e294">m</div> and
               
               <div class="code e295">acc</div> in the example) and they are bound to values defined in the context where
               the function is called. On the other hand, in Saxon, all free variables are bound
               to the
               parameters passed to the call of 
               <div class="code e296">evaluate</div> (as a consequence to this design
               decision, the names of the free variables are coerced to be 
               <div class="code e297">p1</div>, 
               <div class="code e298">p2</div>
               etc. and there is a limit on the maximal amount of free variables allowed).
            </div>
            <div class="para e299">W3C answered the call for dynamic evaluation in the draft of XSLT 3.0 and introduced
               a
               new instruction - 
               <div class="code e300">xsl:evaluate</div>. The semantics is closer to the one used by
               Saxon, values of free variables are assigned using 
               <div class="code e301">xsl:with-param</div> instructions
               (the names of the parameters are in this case up to the user to decide). As it turns
               out,
               there is no perfect solution with dynamic evaluation, because there are these obstacles:
               
               <div class="orderedlist e302">
                  <div class="listitem e303">
                     <div class="para e304">There is no upper limit on the amount of both free and bound variables the user
                        can use in an OCL expression. 
                     </div>
                  </div>
                  <div class="listitem e305">
                     <div class="para e306">The names of the variables are also selected by the user. </div>
                  </div>
               </div>
            </div>
            <div class="para e307">The first one renders Saxon, with its limit on the number of free variables, not general
               enough. All three approaches also share the same problem - the names of free variables
               are
               either coerced (Saxon) or they are defined statically (EXSLT, 
               <div class="code e308">xsl:evaluate</div>). If
               
               <div class="code e309">xsl:evaluate</div> allowed dynamic naming of the parameters, the following call
               would be usable (the excerpt replaces the definition of 
               <div class="code e310">newAcc</div> in the template
               from 
               <div class="xref e311" linkend="xslt-iterate-dynamic"></div>: 
               <div class="programlisting e312" xml:space="preserve">&lt;xsl:evaluate xpath="$body"&gt;
                  &lt;xsl:with-param name="
                  <div class="emphasis e313" role="bold">{accumulatorVar}</div>" select="$acc" /&gt;
                  &lt;xsl:with-param name="
                  <div class="emphasis e314" role="bold">{iterationVar}</div>" select="$collection[$iteration]" /&gt;
                  &lt;xsl:with-param name="self" select="$self" /&gt;
                  &lt;/xsl:evaluate&gt;
               </div>
            </div>
            <div class="para e315">Yet, even this solution works only when there are only three allowed free variables
               in
               
               <div class="code e316">body</div> expression - accumulator, iterator, and self. 
            </div>
            <div class="para e317">
               <div class="xref e318" linkend="xslt-exists-dynamic"></div> shows, how 
               <div class="code e319">exists</div> iterator expression
               can be implemented (as function 
               <div class="code e320">oclX:exists</div>) according to its specification in
               the terms of 
               <div class="code e321">iterate</div> (implemented as function 
               <div class="code e322">oclX:iterate</div>, 
               <div class="xref e323" linkend="xslt-iterate-dynamic"></div>).  The 
               <div class="code e324">body</div> expression is combined with the
               expression defining exists iterator expression (
               <div class="code e325">acc or (body)</div>) using simple
               string manipulation. 
            </div>
            <div class="figure e326" xml:id="xslt-exists-dynamic">
               <div class="title e327">Generic 
                  <div class="code e328">exists</div> function implemented via call of
                  
                  <div class="code e329">iterate</div>
               </div>
               <div class="programlisting e330" xml:space="preserve">&lt;xsl:function name="oclX:exists" as="xs:boolean"&gt;
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="iterationVar" as="xs:string"/&gt;
                  &lt;xsl:param name="body" as="xs:string" /&gt;
                  &lt;xsl:param name="self" /&gt; 
                  
                  &lt;xsl:sequence select="oclX:iterate($collection, $iterationVar, 'acc', 
                  'false()', concat('$acc or (', $body ,')'), $self)"  &gt;&lt;/xsl:sequence&gt;
                  &lt;/xsl:function&gt;
               </div>
            </div>
            <div class="para e331">To conclude this discourse, we implemented a version of OclX library which uses dynamic
               evaluation. We used the extension function provided by Saxon. We solved the second
               problem
               by passing the values of all free variables in one value (a sequence of values) and
               replacing the references of free variables by expression indexing the sequence before
               the
               expression is evaluated. This solution works with XSLT 2.0 (+ Saxon extension). Passing
               more
               values in one sequence is a problem of itself, because empty values and values, which
               are
               sequences themselves, have to be encoded (more about this in section 
               <div class="xref e332" linkend="sec-tuples"></div>, the approach used there can also be applied for the encoding
               problem here). However, XSLT 3.0 offers another approach to tackle iterator expressions
               and
               free variables satisfactorily and elegantly, and those are higher-order functions.
            </div>
         </div><a name="HigherorderfunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e333">
            <div class="title e334">Higher-order functions</div>
            <div class="para e335">The drafts of XPath 3.0 and XQuery 3.0 define a new kind of item in the common data
               model - function item. Funciton item is an item, that can be 
               <div class="emphasis e336" role="ital">called</div>. This makes functions in XPath and XQuery first-class citizens that can
               be results of expressions and passed as arguments to function calls, making XPath/XQuery
               full-fledged functional languages (technique for using higher-order functions also
               in XSLT
               2.0 was shown in 
               <div class="xref e337" linkend="novatchev06"></div>, but that is far from native). A prototype
               implementation of HOF is available in 
               <div class="xref e338" linkend="saxon"></div> since version 9.3.
            </div>
            <div class="para e339">The OCL iterator expressions can be viewed as functions, which expect another function
               as their parameter - i.e. higher-order functions
               <div class="popupBox e340">
                  <div class="popupLabel" onmouseover="$('#d1e773').show('1000');" onmouseout="$('#d1e773').hide('1000');">[ footnote ]</div>
                  <div id="d1e773" style="display: none;">
                     <div class="footnote">
                        <div class="para e341">Yet OCL does not have the full power of functional languages, since it does not
                           allow functions to be results of expressions.
                        </div>
                     </div>
                  </div>
               </div>. In 
               <div class="code e342">iterate</div> expression, 
               <div class="code e343">body</div> can be looked upon as a
               parameter, which expects a function. 
               <div class="xref e344" linkend="xslt-iterate-hof"></div> shows how
               
               <div class="code e345">iterate</div> is implemented in OclX. We also used the new instruction -
               
               <div class="code e346">xsl:iterate</div> - which is also proposed in the XSLT 3.0 draft and has a very
               similar semantics to its OCL namesake. 
            </div>
            <div class="figure e347" xml:id="xslt-iterate-hof">
               <div class="title e348">Implementation of 
                  <div class="code e349">iterate</div> as a higher-order function
                  
                  <div class="code e350">oclX:iterate</div>
               </div>
               <div class="programlisting e351" xml:space="preserve">&lt;xsl:function name="oclX:iterate" as="item()*"&gt;        
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="accInit" as="item()*"/&gt;
                  &lt;xsl:param name="body" as="
                  <div class="emphasis e352" role="bold">function(item(), item()*) as item()*</div>"/&gt;
                  
                  &lt;xsl:iterate select="1 to count($collection)"&gt;      
                  &lt;xsl:param name="acc" select="$accInit" as="item()*" /&gt;
                  &lt;xsl:next-iteration&gt;
                  &lt;xsl:with-param name="acc" select="
                  <div class="emphasis e353" role="bold">$body($collection[current()], $acc)</div>" /&gt;
                  &lt;/xsl:next-iteration&gt;      
                  &lt;xsl:on-completion&gt;
                  &lt;xsl:sequence select="$acc" /&gt;
                  &lt;/xsl:on-completion&gt;
                  &lt;/xsl:iterate&gt;    
                  &lt;/xsl:function&gt;
               </div>
            </div>
            <div class="para e354">The function's 
               <div class="code e355">body</div> parameter expects a function with two bound variables,
               the first one representing the accumulator, the second one the member of the iterated
               collection for this iteration. Also, the definition of function 
               <div class="code e356">oclX:exists</div> in
               
               <div class="xref e357" linkend="xslt-exists-hof"></div> shows that this definition is general enough to be used
               to define other functions in its terms. The implementation of 
               <div class="code e358">closure</div> is
               similar to that of 
               <div class="code e359">iterate</div>, only it uses recursion. 
            </div>
            <div class="figure e360" xml:id="xslt-exists-hof">
               <div class="title e361">Implementation of 
                  <div class="code e362">exists</div> as a higher-order function
                  
                  <div class="code e363">oclX:exists</div> calling 
                  <div class="code e364">oclX:iterate</div>
               </div>
               <div class="programlisting e365" xml:space="preserve">&lt;xsl:function name="oclX:exists" as="xs:boolean"&gt;    
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="body" as="
                  <div class="emphasis e366" role="bold">function(item()) as xs:boolean</div>"/&gt;    
                  
                  &lt;xsl:sequence select="
                  <div class="emphasis e367" role="bold">oclX:iterate($collection, false(), 
                     function($it, $acc) { $acc or ($body($it)) })
                  </div>" /&gt;   
                  &lt;/xsl:function&gt;
               </div>
            </div>
            <div class="para e368">Now let us compare the higher-order function approach to the dynamic evaluation
               approach. As in OCL, there is no limit on the number of free variables in XPath function
               items, so the mapping is seamless in this respect. Furthermore, the semantics of free
               variables in a higher-order function is that their values are obtained from the context
               at the
               place of the call - the same semantics OCL uses for free variables. 
            </div>
            <div class="para e369">As an icing on the cake, we can utilize the reflection function
               
               <div class="code e370">function-arity</div> (supported for function items) to allow iterator expressions
               with more than one iterators directly (not via replacing them by nested calls). 
               <div class="xref e371" linkend="xslt-existsN-hof"></div> shows a multiple-iterator version of 
               <div class="code e372">exists</div>
               (which is one of the few iterator expressions, which allows multiple iterators by
               OCL
               specification). We use two helper functions: 
               <div class="code e373">getIndices</div> (which returns the n-th
               number in a system with a given 
               <div class="code e374">base</div> in the form of a zero-filled sequence) and
               
               <div class="code e375">functionItemCall</div>, which assigns the values to the iterators and calls the
               higher-order function. However, we are forced to fix the maximum amount of iterators
               allowed, because a call of function item requires a fixed amount of parameters (of
               course,
               we could prolong the last 
               <div class="code e376">if</div> as we like). 
            </div>
            <div class="figure e377" xml:id="xslt-existsN-hof">
               <div class="title e378">Implementation of 
                  <div class="code e379">existsN</div> - multiple iterators
               </div>
               <div class="programlisting e380" xml:space="preserve">&lt;xsl:function name="oclX:existsN" as="xs:boolean"&gt;    
                  &lt;xsl:param name="collection" as="item()*"/&gt;
                  &lt;xsl:param name="body" as="function(*)"/&gt;
                  &lt;xsl:variable name="iteratorCount" select="function-arity($body)" as="xs:integer"
                  /&gt;
                  
                  &lt;xsl:iterate select="1 to xs:integer(math:pow(count($collection), $iteratorCount))"&gt;
                  
                  &lt;xsl:param name="satisfied" as="xs:boolean" select="true()" /&gt;  
                  &lt;xsl:variable name="indices" select="
                  oclXin:getIndices(. - 1, count($collection), $iteratorCount, ())"/&gt;
                  &lt;xsl:variable name="forThis" select="oclXin:functionItemCall(
                  $body, $iteratorCount, $indices, $collection)" as="xs:boolean" /&gt;  
                  &lt;xsl:choose&gt;
                  &lt;xsl:when test="$forThis eq true()"&gt;
                  &lt;xsl:break&gt;
                  &lt;xsl:sequence select="true()"/&gt;
                  &lt;/xsl:break&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;
                  &lt;xsl:next-iteration&gt;
                  &lt;xsl:with-param name="satisfied" select="$satisfied or $forThis" /&gt;  
                  &lt;/xsl:next-iteration&gt;    
                  &lt;/xsl:otherwise&gt;  
                  &lt;/xsl:choose&gt;  
                  &lt;xsl:on-completion&gt;
                  &lt;xsl:sequence select="$satisfied" /&gt;
                  &lt;/xsl:on-completion&gt;
                  &lt;/xsl:iterate&gt;
                  &lt;/xsl:function&gt;  
                  
                  &lt;xsl:function name="oclXin:getIndices" as="xs:integer*"&gt;
                  &lt;xsl:param name="scalar" as="xs:integer" /&gt; 
                  &lt;xsl:param name="base" as="xs:integer" /&gt;
                  &lt;xsl:param name="length" as="xs:integer" /&gt;
                  &lt;xsl:param name="result" as="xs:integer*" /&gt;
                  &lt;xsl:choose&gt;      
                  &lt;xsl:when test="$scalar eq 0"&gt;
                  &lt;xsl:sequence select="
                  (for $i in 1 to ($length - count($result)) return 0), $result" /&gt;
                  &lt;/xsl:when&gt;
                  &lt;xsl:otherwise&gt;
                  &lt;xsl:variable name="mod" select="$scalar mod $base"/&gt;
                  &lt;xsl:sequence select="            
                  oclXin:getIndices(xs:integer($scalar div $base), $base, $length, 
                  (($mod), $result))" /&gt;
                  &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                  &lt;/xsl:function&gt;
                  
                  &lt;xsl:function name="oclXin:functionItemCall"&gt;
                  &lt;xsl:param name="function" as="function(*)" /&gt;
                  &lt;xsl:param name="arity" as="xs:integer" /&gt;
                  &lt;xsl:param name="indices" as="xs:integer*" /&gt;
                  &lt;xsl:param name="a" as="item()*" /&gt;
                  
                  &lt;xsl:sequence select="if ($arity eq 1) then $function($a[$indices[1] + 1])
                  else if ($arity eq 2) then $function($a[$indices[1] + 1], $a[$indices[2] + 1])
                  else if ($arity eq 3) then $function($a[$indices[1] + 1], $a[$indices[2] + 1], 
                  $a[$indices[3] + 1])
                  else error(QName('http://eXolutio.com/oclX/functional/error', 'oclXer:E001'), 
                  'A maximum of three different iterators are allowed. ')" /&gt;      
                  &lt;/xsl:function&gt;
               </div>
            </div>
         </div><a name="LocalvariablesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e381">
            <div class="title e382">Local variables</div>
            <div class="para e383">The issue of local variables is closely related to iterator expressions, because they
               are one of the two ways how local variables can be defined. Apart from iterator expressions
               (which define local variables implicitly), OCL also contains 
               <div class="code e384">let</div> expression,
               which defines a variable valid in the scope of the expression. The semantics of local
               variables is similar to that of XPath - the value is assigned in the moment of declaration
               and does not change from that place on. 
            </div>
            <div class="para e385">In XPath 2.0, the same effect can be achieved using 
               <div class="code e386">for</div>, but only when the
               value of the local variable is not a collection (
               <div class="code e387">for</div> would only perform one
               cycle). In other cases, we must descend to inlining the value (since it is immutable).
               Alternatively, when the variable is defined in the scope of the invariant (making
               it global
               variable for the whole invariant), it can be translated into XSLT variable definition.
               
            </div>
            <div class="para e388">XPath 3.0 again makes the translation easier, because it allows 
               <div class="code e389">let/return</div>
               expressions, with semantics eqivalent to OCL 
               <div class="code e390">let</div>. 
            </div>
         </div>
      </div><a name="TuplesasmapsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e391" xml:id="sec-tuples">
         <div class="title e392">Tuples as maps</div>
         <div class="para e393">In this section we propose how to deal with tuples (anonymous types) from OCL.</div>
         <div class="para e394">OCL allows the designer to combine values in expressions into tuples. Tuples can be
            considered an anonymous type, which has a finite number of named parts. An example
            of a tuple
            may be 
            <div class="code e395">Tuple { firstName = 'Jakub', lastName = 'Malý', age = 26 }</div>. The values of
            the parts may be of arbitrary type, including collections and other tuples. The names
            of parts
            (
            <div class="code e396">firstName</div>, 
            <div class="code e397">lastName</div>, 
            <div class="code e398">age</div> in the example) must be
            unique and are used to access the parts of the tuple in the expressions, similarly
            to
            attributes of classes, i.e. it is possible to write 
            <div class="code e399">employees-&gt;collect( e | Tuple { name
               = e.name, salary = e.salary })-&gt;select( t | t.salary &gt; 2000)
            </div>, the result of this
            expression would be a collection of tuples. 
         </div>
         <div class="para e400">There is a noteworthy property coming with the possibility to create tuples: together
            with
            tuples, OCL was equipped with the operation 
            <div class="code e401">product</div>, defined as follows: 
         </div>
         <div class="programlisting e402" xml:space="preserve">
            product(c1:Collection(T1), c2:Collection(T2)) = 
            self-&gt;iterate(e1; acc = Set{} |
            c2-&gt;iterate (e2; acc2 = acc | acc2-&gt;including(
            Tuple{first = e1, second = e2}) 
            ) 
            )
         </div>
         <div class="para e403">The result of 
            <div class="code e404">product</div> is a collection of type 
            <div class="code e405">Collection(Tuple(first:
               T1, second: T2))
            </div>, which contains all possible pairs where the first compound comes
            from collection 
            <div class="code e406">c1</div> and the second collection 
            <div class="code e407">c2</div>. This operation thus
            finalizes the suite of equivalents of the constructs required for a language to be
            relationally complete (see 
            <div class="xref e408" linkend="Codd72"></div>):
            <div class="itemizedlist e409">
               <div class="listitem e410">
                  <div class="para e411">
                     <div class="emphasis e412" role="ital">Select</div> - can be expressed using 
                     <div class="code e413">select</div>
                     iterator expression,
                  </div>
               </div>
               <div class="listitem e414">
                  <div class="para e415">
                     <div class="emphasis e416" role="ital">Project</div> - can be expressed using
                     
                     <div class="code e417">collect</div> iterator expression that creates a tuple with the projected
                     attributes (see the 
                     <div class="code e418">employees</div> example above, which, in fact, performs
                     projection to attributes 
                     <div class="code e419">name</div> and 
                     <div class="code e420">salary</div>) ,
                  </div>
               </div>
               <div class="listitem e421">
                  <div class="para e422">
                     <div class="emphasis e423" role="ital">Union</div> - OCL has union operation as well,
                  </div>
               </div>
               <div class="listitem e424">
                  <div class="para e425">
                     <div class="emphasis e426" role="ital">Set difference</div> - OCL has operation '
                     <div class="code e427">-</div>'
                     working on sets,
                  </div>
               </div>
               <div class="listitem e428">
                  <div class="para e429">
                     <div class="emphasis e430" role="ital">Cartesian product</div> - can be expressed using
                     
                     <div class="code e431">product</div>,
                  </div>
               </div>
               <div class="listitem e432">
                  <div class="para e433">
                     <div class="emphasis e434" role="ital">(Rename)</div> - can be expressed using
                     
                     <div class="code e435">collect</div> in the same manner as 
                     <div class="emphasis e436" role="ital">project</div>
                     operation. 
                  </div>
               </div>
            </div>
         </div>
         <div class="para e437">Thus, not only tuples can be used to write more concise expressions, but, together
            with
            the operation product, they increase the expressive power of the language to relational
            completeness. 
         </div>
         <div class="para e438">As far as XPath 2.0 is concerned, there exists no construct that could be naturally
            used
            to represent tuples, they can only be partially simulated. One possibility is to use
            sequences, where each item in the sequence corresponds to one part of the tuple, i.e.
            
            <div class="code e439">Tuple { firstName = 'Jakub', lastName = 'Malý', age = 26 }</div> would be represented
            as a sequence 
            <div class="code e440">('Jakub', 'Malý', 26)</div>. 
         </div>
         <div class="para e441">But this solution is not completely satisfactory from the following reasons: 
            <div class="orderedlist e442">
               <div class="listitem e443">
                  <div class="para e444">We loose "safety" and clarity in the expression, because we have to write
                     
                     <div class="code e445">$t[1]</div> to represent the OCL expression 
                     <div class="code e446">t.firstName</div>.
                  </div>
               </div>
               <div class="listitem e447">
                  <div class="para e448">When some part is missing (which is in OCL indicated by 
                     <div class="code e449">null</div> value), we
                     have to use some placeholder value to keep the length of the sequence constant (e.g.
                     
                     <div class="code e450">('null', 'null', 26)</div>).
                  </div>
               </div>
               <div class="listitem e451">
                  <div class="para e452">A part of a tuple in OCL can be of any type, including other tuples and collections.
                     Here, this approach fails utterly, because all sequences are flattened in XPath. This
                     also makes implementing 
                     <div class="code e453">product</div> operation impossible, because it should
                     return a collection of tuples, i.e. a collection of sequences. 
                  </div>
               </div>
            </div>
         </div>
         <div class="para e454">Instead of representing tuples using sequences, an alternative would be to represent
            them
            using temporary documents, for example: 
         </div>
         <div class="programlisting e455" xml:space="preserve">      &lt;Tuple&gt;
            &lt;firstName&gt;Jakub&lt;/firstName&gt;
            &lt;lastName&gt;Malý&lt;/lastName&gt;
            &lt;age&gt;26&lt;/age&gt;
            &lt;/Tuple&gt;
         </div>
         <div class="para e456">This approach would overcome the first issue (
            <div class="code e457">t.firstName</div> would be
            represented as 
            <div class="code e458">$t/firstName</div>), the second issue (an empty element could represent
            a missing part) and also the third issue (nesting is no problem here and collections
            could be
            encoded into trees as well). However, it brings two problems of its own: 
            <div class="orderedlist e459">
               <div class="listitem e460">
                  <div class="para e461">The value which is about to become a part of a tuple, is copied to a temporary XML
                     document. This would not hurt so much with atomic values, but would be a significant
                     overhead, when the value was a node or a sequence of nodes in the input document (whole
                     subtree would be copied in this case).
                  </div>
               </div>
               <div class="listitem e462">
                  <div class="para e463">When a node is copied into the temporary document, its position in the document is
                     lost, it would not be possible to navigate outside its subtree (e.g. using
                     
                     <div class="code e464">parent</div> axis) and operations relying on node identity (such as the
                     
                     <div class="code e465">is</div> operator) would give unexpected results when applied on nodes from the
                     input tree and from the temporary tree. 
                  </div>
               </div>
            </div>
         </div>
         <div class="para e466">To conclude, restrictions inherent in XPath 2.0 data model prevent from satisfactory
            representation of tuples with semantics corresponding to OCL.
         </div>
         <div class="para e467">However, the possibility of extending the XPath/XQuery model with another item type
            - map
            - is being discussed and a prototype implementation is now available in 
            <div class="xref e468" linkend="saxon"></div> (an alternative is to use XQuery implementation of maps using function items instead
            of map
            items, for details see 
            <div class="xref e469" linkend="snelson11"></div>). The map type requires atomic values for
            keys and allow items of any type as values. These properties of map type make it a
            great
            candidate for representing tuples, thus, we decided to create a version of OclX which
            supports
            tuples represented as maps. Strings containing the name of a tuple part can be used
            as keys
            (and the names of parts must be distinct in an OCL tuple as well). The tuple from
            the example
            would be represented as 
            <div class="code e470">map{'firstName' := 'Jakub', 'lastName' := 'Malý', 'age' :=
               26}
            </div>, expression 
            <div class="code e471">t.firstName</div> would be represented as
            
            <div class="code e472">$t('firstName')</div>. A value in a map can also be another map or sequence, which is
            consistent with semantics of OCL tuples. Operation 
            <div class="code e473">product</div> can be defined either
            by translating the definition from specification (using two nested 
            <div class="code e474">iterates</div>) or
            via a much more succinct expression:
         </div>
         <div class="programlisting e475" xml:space="preserve">   for $e1 in $collection1 return for $e2 in $collection2 
            return map{'first' := $e1, 'second' := $e2}
         </div>
      </div><a name="DifferentkindsofcollectionsnestedcollectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e476" xml:id="sec-collections">
         <div class="title e477">Different kinds of collections, nested collections</div>
         <div class="para e478">OCL defines an abstract type Collection and 4 different types of collections - Set,
            OrderedSet, Bag (in other languages sometimes called multiset) and Sequence. A member
            of any
            collection can be an arbitrary value, including another collection. 
         </div>
         <div class="para e479">We treat all collections as sequences in OclX, yet it would be possible to represent
            the
            other kinds of collections using maps (or sequences as well). 
         </div>
         <div class="para e480">Nested collections are a foreign concept to XPath data model. The disadvantages of
            encoding collections into temporary documents were discussed in section 
            <div class="xref e481" linkend="sec-tuples"></div>.
         </div>
         <div class="para e482">With the introduction of maps, there is a, rather ugly, way of encoding nested sequences
            -
            thanks to the possibility of using maps as values 
            <div class="emphasis e483" role="ital">and</div> members
            of sequences. A nested sequence ((1,2),(3),()) could be encoded to 
            <div class="code e484">map{'s' := (map{'s'
               := (1,2)}, map{'s' := (3)}, map{'s' := ()})}
            </div>, the expression returning number two
            would be written as 
            <div class="code e485">(map{'s' := (map{'s' := (1,2)}, map{'s' := (3)}, map{'s' :=
               ()})})('s')[1]('s')[2]
            </div>. Using this approach also requires the functions which
            concatenate sequences not to use XPath operator 
            <div class="code e486">,</div>, because it flattens the
            resulting sequence.
         </div>
         <div class="para e487">The double indexing (first to get the value from the map, second for getting the desired
            member of the sequence) can seem confusing, but it can be in fact hidden behind a
            library
            function 
            <div class="code e488">at(i)</div> (which OCL uses instead of the operator 
            <div class="code e489">[i]</div> to get an
            i-th member of a sequence). The wordy and a bit unclear way of creating a nested sequence
            appears in those expression that create nested sequences using literals. This, however,
            could
            be eliminated by using preprocessing of the schemas before evaluating the expressions
            (adding
            another step to Schematron pipeline). 
         </div>
      </div><a name="ErrorrecoveryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e490" xml:id="sec-errors">
         <div class="title e491">Error recovery</div>
         <div class="para e492">OCL as a language has a direct approach to "run-time" errors or exceptions. Errors
            in
            computation cause the result of the expression to be 
            <div class="code e493">invalid</div> - a sole instance of
            type OclInvalid. It conforms to all other types and any further computation with
            
            <div class="code e494">invalid</div> results in 
            <div class="code e495">invalid</div> - except for operation
            
            <div class="code e496">oclIsInvalid</div>
            <div class="popupBox e497">
               <div class="popupLabel" onmouseover="$('#d1e1142').show('1000');" onmouseout="$('#d1e1142').hide('1000');">[ footnote ]</div>
               <div id="d1e1142" style="display: none;">
                  <div class="footnote">
                     <div class="para e498">To be accurate, another operation - 
                        <div class="code e499">oclIsUndefined</div> - behaves equally to
                        
                        <div class="code e500">oclIsInvalid</div> when the argument is 
                        <div class="code e501">invalid</div>, but it also returns
                        true, when the result of the computation is 
                        <div class="code e502">null</div>. 
                     </div>
                  </div>
               </div>
            </div>, which returns 
            <div class="code e503">true</div>, when the computations results in
            
            <div class="code e504">invalid</div> and 
            <div class="code e505">false</div> otherwise. This operation thus provides the
            only, very coarse-grained error checking (there are no error codes or exception types)
            available in OCL. Unlike OCL computation, XPath/XSLT 2.0 processor halts when it encounters
            a
            dynamic error and there is no equivalent of 
            <div class="code e506">oclIsInvalid</div>. It is also not possible
            to instruct it to jump to the validation of the next IC when a validation of an IC
            fails. 
         </div>
         <div class="para e507">XSLT 3.0, however, introduces new instructions - 
            <div class="code e508">xsl:try</div> and
            
            <div class="code e509">xsl:catch</div> - which provide means of recovery from dynamic errors. With these
            instructions, it is possible to implement oclIsInvalid as listed in 
            <div class="xref e510" linkend="xslt-invalid"></div>. We, again, utilize higher-order functions capabilities - the
            expression is evaluated in a function call wrapped in try/catch. OCL expression
            
            <div class="code e511">oclIsInvalid(1 / 0)</div> can be translated to 
            <div class="code e512">oclX:oclIsInvalid(function() { 1
               / 0 })
            </div>. Optionally, our validation pipeline (fully introduced in 
            <div class="xref e513" linkend="sec-implementation"></div>) allows to safe-guard the evaluation of each expression using
            try/catch, so that the validation of another constraint may continue if a runtime
            error occurs
            and it is not contained by 
            <div class="code e514">oclIsInvalid</div>. 
         </div>
         <div class="figure e515" xml:id="xslt-invalid">
            <div class="title e516">Implementation of 
               <div class="code e517">oclIsInvalid</div> using
               
               <div class="code e518">xsl:try</div>/
               <div class="code e519">xsl:catch</div>
            </div>
            <div class="programlisting e520" xml:space="preserve">&lt;xsl:function name="oclX:oclIsInvalid" as="xs:boolean"&gt;
               &lt;xsl:param name="func" as="function() as item()*" /&gt;
               
               &lt;!-- evaluate func and forget the result, return false --&gt; 
               &lt;xsl:try select="let $result := $func() return false()"&gt;
               &lt;xsl:catch&gt;
               &lt;xsl:if test="$debug"&gt;
               &lt;xsl:message select="'Runtime error making the result ''invalid''. '"/&gt;
               &lt;xsl:message select="'  - code: ' || $err:code"/&gt;
               &lt;xsl:message select="'  - description: ' || $err:description"/&gt;
               &lt;xsl:message select="'  - value: ' || $err:value"/&gt;
               &lt;/xsl:if&gt;
               &lt;!-- if function call fails, return true --&gt;
               &lt;xsl:sequence select="true()" /&gt;
               &lt;/xsl:catch&gt;
               &lt;/xsl:try&gt;    
               &lt;/xsl:function&gt;
            </div>
         </div>
      </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e521" xml:id="sec-implementation">
         <div class="title e522">Implementation</div>
         <div class="para e523">We implemented the work presented in this paper into our XML schema modeling tool
            
            <div class="xref e524" linkend="exolutio"></div>, the workflow is depicted in 
            <div class="xref e525" linkend="fig-pipeline"></div>. The
            tool incorporates a UML and OCL editor for both PIM and PSM schemas and implements
            algorithm
            for suggesting/translation of relevant constraints from PIM to PSM (steps 1-3, not
            covered in
            this paper) and translation from OCL (4) to Schematron schemas. The user may choose
            between
            schema-aware and non-schema-aware (which add data conversion for extracting typed
            values from
            the XML document) schema and between implementation of iterator expressions using
            dynamic
            evaluation or higher-order functions. The generated schema can be then used to validate
            an XML
            document. XProc pipeline is then used to perform the validation. It first executes
            the
            transformation steps from standard Schematron pipeline (5.), adds includes for OclX
            library
            (6.) and then validates the document (7.) with the resulting XSLT. The pipeline expects
            the
            schema (5.) and validated document (8.) on its input ports and writes validation result
            - a
            SVRL document - to its output port (9). 
         </div>
         <div class="figure e526" xml:id="fig-pipeline">
            <div class="title e527">Schematron and OclX pipeline</div>
            <div class="mediaobject e528">
               <div class="imageobject e529">
                  <div class="metaBox e530"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1220').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1220" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e530'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Maly01/Maly01-005.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='600'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e531">The tool itself (incl. examples), OclX library and the XProc pipeline are all available
            for free download on the tools website. Finally, 
            <div class="xref e532" linkend="fig-schematron"></div> depicts the
            translation of integrity constraints from the examples in 
            <div class="xref e533" linkend="fig-psm-ocl"></div>
            (schema-aware, iterators via higher-order functions). The error messages defined in
            OCL
            translated into schematron error messages and their subexpressions into 
            <div class="code e534">value-of</div>
            instructions (see translation of PSM1). 
         </div>
         <div class="figure e535" xml:id="fig-schematron">
            <div class="title e536">Generated Schematron schemas</div>
            <div class="programlisting e537" xml:space="preserve">&lt;!-- Match schedule schema --&gt;
               &lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
               &lt;sch:pattern&gt;
               &lt;sch:rule context="/tournament"&gt;
               &lt;!-- PSM1 --&gt;   
               &lt;sch:assert test="start le end"&gt;
               Dates inconsistent, &lt;sch:value-of select="$self/start" /&gt; 
               is greater than &lt;sch:value-of select="$self/end" /&gt; 
               in &lt;sch:value-of select="$self/name" /&gt;
               &lt;/sch:assert&gt;
               &lt;!-- PSM2 --&gt;   
               &lt;sch:assert test="oclX:forAll(oclX:collect($self/matches/day, function($d) { $d/match
               }), 
               function($m) { $m/start ge $self/start and $m/end le $self/end })"&gt;
               All matches in a tournament occur within the tournament's time frame
               &lt;/sch:assert&gt; 
               &lt;!-- PSM4 --&gt;
               &lt;sch:assert test="oclX:exists(
               oclX:collect(matches/day, function($d) { $d/match }), 
               function($m) { oclDate:trunc($m/start) eq oclDate:trunc($self/start) })"&gt;
               Each tournament conducts at least one match on the first day of the tournament
               &lt;/sch:assert&gt;
               &lt;/sch:rule&gt;
               &lt;!-- PSM3 --&gt;
               &lt;sch:rule context="/tournament/matches/day/match"&gt;
               &lt;sch:assert test="oclX:forAll($self/matchPlayers/player, 
               function($p) { oclX:exists($p/../../../../../participatingPlayers/player, 
               function($px) { $px/name eq $p/name }) })"&gt;
               A match can only involve players who are accepted in the tournament
               &lt;/sch:assert&gt;
               &lt;/sch:rule&gt;
               &lt;/sch:pattern&gt;
               &lt;/sch:schema&gt;
               
               &lt;!-- Tournaments schedule schema --&gt;
               &lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron"&gt;
               &lt;sch:pattern&gt;
               &lt;!-- PSM5: either open tournament or belongs to some league --&gt;
               &lt;sch:assert test="qualification/@open eq true() or exists(qualification/@leagueName)"&gt;
               Tournament must be either open tournament or belong to a league
               &lt;/sch:assert&gt;
               &lt;/sch:pattern&gt;
               &lt;/sch:schema&gt;
            </div>
         </div>
      </div><a name="ExpressionrewritingandsyntacticsugarANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e538" xml:id="sec-sugar">
         <div class="title e539">Expression rewriting and syntactic sugar</div>
         <div class="para e540">In many cases, iterator expressions and functions, can be expressed using a native
            XPath
            construct, e.g. 
            <div class="code e541">forAll</div> can be expressed as 
            <div class="code e542">every/satisfies</div>, select
            by application of a filter etc. The current version of the algorithm does not provide
            any of
            such rewritings, but in the following work, we plan to examine the possibilities of
            such
            rewritings and offer them to the user, where applicable. 
         </div>
         <div class="para e543">OCL expressions have a useful property that they can be read from left to right thanks
            to the arrow notation 
            <div class="code e544">'-&gt;'</div> for collections and dot
            
            <div class="code e545">'.'</div> for calling operations . When translated to XPath, the
            readability decreases (the object before the arrow/dot corresponds to the first parameter
            of
            the function. Also, the notation of higher-order functions in XPath is not so transparent.
            If
            desirable, it would be possible to preserve OCL notation even for Schematron schemas
            (and
            change it to usual XPath notation in another preprocessing step). 
         </div>
         <div class="para e546">A valued feature of Schematron is the possibility to specify human-friendly error
            messages
            for violated integrity constraints. However, OCL does not provide such functionality
            in the
            current version of the standard (2.3.1). Since custom error messages were strongly
            advocated
            (e.g. in 
            <div class="xref e547" linkend="malaika09"></div>), we extended recognized OCL grammar to allow
            specification of error messages. 
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e548" xml:id="sec-conclusion">
         <div class="title e549">Conclusion</div>
         <div class="para e550">In this paper, we inquired into the possibility of using OCL for modeling integrity
            constraints over XML data. We have discussed several ways of how non-trivial OCL expressions
            can be expressed using XPath with our proposed extension in a form of a XSLT function
            library
            OclX. The library itself contains a useful set of functions, which can be used on
            their own
            and provide a handy toolset with considerable expressive power. However, the main
            contribution
            is the possibility to check OCL integrity constraints in XML data. Our approach allows
            using
            the integrity constraints defined in the UML model also for XML, which supports consistency
            of
            the system as a whole (the constraints do not have to be rewritten by hand and managed
            manually after each change). It helps to bridge the gap between the platform-independent
            conceptual model and its applicability at runtime.
         </div>
         <div class="para e551">Since translated OclX constraints are, in structure, very simlar to OCL constraints,
            they
            will be easy to comprehend even for a modeller less familiar with XML technologies.
            
         </div>
         <div class="para e552">In the future, we want to thoroughly examine the possibilities of rewriting the
            expressions in order to use native XPath constructs to express iterator expressions
            where
            possible and allow the user to choose from several ways of expressing a certain constraint.
            As
            another part the future work, we plan to extend our approach for schema evolution
            and document
            adaptation (see 
            <div class="xref e553" linkend="maly11"></div>) by utilizing OCL integrity constraints. 
         </div>
      </div><a name="AcknowledgementANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e554">
         <div class="title e555">Acknowledgement</div>
         <div class="para e556">This work was supported by GAČR grant no. P202/10/0573.</div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e557">
         <div class="title e558">Bibliography</div>
         <div class="bibliomixed e559" xml:id="ocl" xreflabel="OCL specification">OCL Specification, version 2.3.1.
            Object Management Group (OMG). January 2012. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e560" xlink:actuate="onRequest" xlink:href="http://www.omg.org/spec/OCL/2.3.1/" xlink:show="new" xlink:type="simple">http://www.omg.org/spec/OCL/2.3.1/</div>
            
         </div>
         <div class="bibliomixed e561" xml:id="dresden" xreflabel="Dresden OCL">Software Technology Group at Technische Universität Dresden. 
            Dresden OCL - OCL support for your modeling language 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e562" xlink:actuate="onRequest" xlink:href="http://www.dresden-ocl.org/" xlink:show="new" xlink:type="simple">http://www.dresden-ocl.org/</div>
            
         </div>
         <div class="bibliomixed e563" xml:id="pagano09" xreflabel="Pagano 2009">Pagano, Dennis, and Anne
            Brüggemann-Klein. Engineering Document Applications — From UML Models to XML Schemas.
            In 
            <div class="emphasis e564" role="ital">Proceedings of Balisage: The Markup Conference 2009</div>. Balisage Series on
            Markup Technologies, vol. 3 (2009).  
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e565" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Bruggemann-Klein01/BalisageVol3-Bruggemann-Klein01.html" xlink:show="new" xlink:type="simple"> http://www.balisage.net/Proceedings/vol3/html/Bruggemann-Klein01/BalisageVol3-Bruggemann-Klein01.html</div> doi:
            <div class="biblioid doi e566">10.4242/BalisageVol3.Bruggemann-Klein01</div>.
            
         </div>
         <div class="bibliomixed e567" xml:id="bauman09" xreflabel="Bauman 2009">Bauman, Bruce Todd. “Prying Apart
            Semantics and Implementation: Generating XML Schemata directly from ontologically
            sound
            conceptual models.” 
            In 
            <div class="emphasis e568" role="ital">In Proceedings of Balisage: The Markup Conference
               2009
            </div>. Balisage Series on Markup Technologies, vol. 3 (2009).
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e569" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol3/html/Bauman01/BalisageVol3-Bauman01.html</div>. doi:
            <div class="biblioid doi e570">10.4242/BalisageVol3.Bauman01</div>. 
            
         </div>
         <div class="bibliomixed e571" xml:id="necasky12a" xreflabel="Nečaský 2012A">Martin Nečaský, Jakub Klímek, Jakub
            Malý, Irena Mlýnková, Evolution and change management of XML-based systems, 
            <div class="emphasis e572" role="ital">Journal
               of Systems and Software
            </div>, vol 85. 2012, ISSN 0164-1212,
            doi:
            <div class="biblioid doi e573">10.1016/j.jss.2011.09.038</div>. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e574" xlink:actuate="onRequest" xlink:href="http://www.sciencedirect.com/science/article/pii/S0164121211002524" xlink:show="new" xlink:type="simple">http://www.sciencedirect.com/science/article/pii/S0164121211002524</div>      
            
         </div>
         <div class="bibliomixed e575" xml:id="necasky12b" xreflabel="Nečaský 2012B">Martin Nečaský, Irena Mlýnková, Jakub Klímek, Jakub
            Malý, When conceptual model meets grammar: A dual approach to XML data modeling, 
            <div class="emphasis e576" role="ital">Data 
               &amp; Knowledge Engineering
            </div>, vol 72. 2012, ISSN 0169-023X,
            doi:
            <div class="biblioid doi e577">10.1016/j.datak.2011.09.002</div>. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e578" xlink:actuate="onRequest" xlink:href="http://www.sciencedirect.com/science/article/pii/S0169023X1100125X" xlink:show="new" xlink:type="simple">http://www.sciencedirect.com/science/article/pii/S0169023X1100125X</div>      
            
         </div>
         <div class="bibliomixed e579" xml:id="Mandel99" xreflabel="Mandel 1999">L. Mandel, M. Cengarle. On the
            Expressive Power of OCL. In 
            <div class="emphasis e580" role="ital">FM'99 Formal Methods</div>, volume 1708 of LNCS.
            Springer Berlin / Heidelberg, 1999.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e581" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=730476" xlink:show="new" xlink:type="simple">http://dl.acm.org/citation.cfm?id=730476</div>
            
         </div>
         <div class="bibliomixed e582" xml:id="saxon" xreflabel="Saxon">Saxonica. Saxon - the XSLT processor. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e583" xlink:actuate="onRequest" xlink:href="http://saxonica.com/" xlink:show="new" xlink:type="simple">http://saxonica.com/</div>
            
         </div>
         <div class="bibliomixed e584" xml:id="exslt" xreflabel="EXSLT">C. Stewart, C. Bayes, J. Fuller, U. Ogbuji, D. Pawson, J. Tennison.
            EXSLT - community initiative to provide extensions to XSLT.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e585" xlink:actuate="onRequest" xlink:href="http://www.exslt.org/" xlink:show="new" xlink:type="simple">http://www.exslt.org/</div>
            
         </div>
         <div class="bibliomixed e586" xml:id="novatchev06" xreflabel="Novatchev 2006">Dimitre Novatchev. Higher-Order Functional Programming with XSLT 2.0 and FXSL. In
            
            
            <div class="emphasis e587" role="ital">Extreme Markup Languages 2006</div>, Montréal, Québeck. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e588" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2006/Novatchev01/EML2006Novatchev01.html" xlink:show="new" xlink:type="simple">
               http://conferences.idealliance.org/extreme/html/2006/Novatchev01/EML2006Novatchev01.html
               
            </div>
            
         </div>
         <div class="bibliomixed e589" xml:id="snelson11" xreflabel="Snelson 2011">J. Snelson. An implementation of a red/black tree built using XQuery 3.0 
            higher order functions, and an associative map library built on top of it. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e590" xlink:actuate="onRequest" xlink:href="https://github.com/jpcs/rbtree.xq" xlink:show="new" xlink:type="simple">https://github.com/jpcs/rbtree.xq</div>
            
         </div>
         <div class="bibliomixed e591" xml:id="maly11" xreflabel="Maly 2011">J. Malý, I. Mlýnková, M. Nečaský. XML Data Transformations as Schema Evolves. 
            
            <div class="emphasis e592" role="ital">Proceedings of ADBIS 2011: Advances in databases and infromation systems</div>.
            September 2011. Lecture Notes in Computer Science. Springer. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e593" xlink:actuate="onRequest" xlink:href="http://dl.acm.org/citation.cfm?id=2041783" xlink:show="new" xlink:type="simple">http://dl.acm.org/citation.cfm?id=2041783</div>
            
         </div>
         <div class="bibliomixed e594" xml:id="exolutio" xreflabel="eXolutio">eXolutio - a Tool for Conceptual Modeling of XML.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e595" xlink:actuate="onRequest" xlink:href="http://exolutio.com/" xlink:show="new" xlink:type="simple">http://eXolutio.com</div>
            
         </div>
         <div class="bibliomixed e596" xml:id="malaika09" xreflabel="Malaika 2009">S. Malaika, Ch. Pichler. Enforce basic document structure with XML
            constraint checking. IBM. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e597" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/library/x-consthealth/index.html" xlink:show="new" xlink:type="simple">http://www.ibm.com/developerworks/library/x-consthealth/index.html</div>
            
         </div>
         <div class="bibliomixed e598" xml:id="Codd72" xreflabel="Codd 1972">E. F. Codd. Relational Completeness of Data Base Sublanguages. In: 
            <div class="emphasis e599" role="ital">Database Systems</div>, Prentice Hall and IBM Research Report RJ 987, San
            Jose, California, 1972. 
         </div>
      </div>
   </div>
</div>