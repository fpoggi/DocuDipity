<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TransformingschemasANCHOR" name="TransformingschemasTOC">Transforming schemas</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#1IntroductionANCHOR" name="1IntroductionTOC">1. Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#2ElementRenamingandtheRenamingAttributeANCHOR" name="2ElementRenamingandtheRenamingAttributeTOC">2. Element Renaming and the Renaming Attribute</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#3AttributeDefaultingANCHOR" name="3AttributeDefaultingTOC">3. Attribute Defaulting</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#4ElementReorderingANCHOR" name="4ElementReorderingTOC">4. Element Reordering</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#5OccurrencesANCHOR" name="5OccurrencesTOC">5. Occurrences</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#6CharacterContentANCHOR" name="6CharacterContentTOC">6. Character Content</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#7MixedContentANCHOR" name="7MixedContentTOC">7. Mixed Content</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#8AttributeMappingANCHOR" name="8AttributeMappingTOC">8. Attribute Mapping</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">Architectural forms</div>
         <div class="singletermTERMS">architectural engine</div>
         <div class="singletermTERMS">attribute defaulting</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
         <div class="singletermTERMS">Architectural forms</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">bar</div>
         <div class="singletermTERMS">baz</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">cowan@ccil.org</div>
         <div class="singletermTERMS">Cowan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">estrofa</div>
         <div class="singletermTERMS">em</div>
         <div class="singletermTERMS">element renaming</div>
         <div class="singletermTERMS">Examplotron</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">foo</div>
         <div class="singletermTERMS">first</div>
         <div class="singletermTERMS">firstline</div>
         <div class="singletermTERMS">foo?</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">html</div>
         <div class="singletermTERMS">href</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">index</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">John</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">line</div>
         <div class="singletermTERMS">limerick</div>
         <div class="singletermTERMS">last</div>
         <div class="singletermTERMS">link</div>
         <div class="singletermTERMS">label</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">MAPTOKEN</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">people</div>
         <div class="singletermTERMS">person</div>
         <div class="singletermTERMS">poem</div>
         <div class="singletermTERMS">purpose</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
         <div class="singletermTERMS">quote</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">renaming attribute</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">stanza</div>
         <div class="singletermTERMS">Sitzfleisch</div>
         <div class="singletermTERMS">source document</div>
         <div class="singletermTERMS">source schema</div>
         <div class="singletermTERMS">SGML Extended Facilities</div>
         <div class="singletermTERMS">Senior Content Architect</div>
         <div class="singletermTERMS">Schema-driven transformation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">transformation engine</div>
         <div class="singletermTERMS">target document</div>
         <div class="singletermTERMS">target schema</div>
         <div class="singletermTERMS">transformation name</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TransformingschemasANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Transforming schemas</div>
      <div class="subtitle e2">Architectural Forms for the 21st Century</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2013</div>
            <div class="confdates e6">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">The traditional approach to transforming XML documents is a three-step pipeline: validate,
               transform, validate.  The SGML feature called architectural forms combined enhancements
               to DTDs with annotations in source documents to allow a valid SGML document to be
               automatically transformed into another SGML document valid against a different DTD.
               This permitted document creators to conform to a general document architecture without
               having to constrain their own documents to every detail of a specific schema.  In
               the XML world, however, the emphasis has been on the creation of comprehensive schemas
               rather than easy transformation, and the ideas behind architectural forms have mostly
               been lost.  This paper attempts to explain how to restore those ideas to XML practice.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">John</div>
               <div class="surname e12">Cowan</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">John Cowan works for LexisNexis, which he likes to call "$EMPLOYER". On his 2011 tax
                  returns, he listed his occupation as "ontologist" . He pushed both XML 1.1 and XML
                  1.0 Fifth Edition through the W3C XML Core Working Group, of which he somehow remains
                  a member. He also hangs out on numerous mailing lists and blogs, masquerading on the
                  A forum as the expert on B and and on the B forum as the expert on A. His friends
                  say that he knows at least something about almost everything; his enemies, that he
                  knows far too much about far too much.
               </div>
            </div>
            <div class="affiliation e15">
               <div class="jobtitle e16">Senior Content Architect</div>
               <div class="orgname e17">LexisNexis</div>
            </div>
            <div class="email e18">cowan@ccil.org</div>
         </div>
         <div class="legalnotice e19">
            <div class="para e20">Copyright © 2013 by John Cowan</div>
         </div>
         <div class="keywordset e21" role="author">
            <div class="keyword e22">Architectural forms</div>
            <div class="keyword e23">Examplotron</div>
            <div class="keyword e24">Schema-driven transformation</div>
         </div>
      </div><a name="1IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e25">
         <div class="title e26">1. Introduction</div>
         <div class="para e27">The traditional approach to transforming XML documents is a three-step pipeline: validate,
            transform, validate.  (Sometimes, of course, one or both of the validation steps is
            omitted.)  
            <div class="emphasis e28" role="ital">Architectural forms</div>, a feature first of the SGML-based hypermedia standard HyTime and then of SGML itself,
            made use of a combination of enhancements to DTDs and annotations in source documents
            to allow a two-step pipeline for certain simple transformations.  In this pipeline,
            a valid SGML document could be automatically transformed using a specialized SGML
            parser, called an 
            <div class="emphasis e29" role="ital">architectural engine</div> (AE), into another SGML document valid against a more general DTD known as the meta-DTD.
            This permitted document creators to conform to a general document architecture without
            having to constrain their own documents to every detail of a specific schema.
         </div>
         <div class="para e30">However, DTDs have not seen wide uptake in the XML world, and the few XML architectural
            engines that have been built have conformed more to the letter than to the spirit
            of architectural forms.  The emphasis has been on the creation of comprehensive and
            complex schemas which attempt simultaneously to serve local needs and the needs of
            interchange.  Such schemas are usually arrived at by difficult, lengthy, and highly
            political negotiations between interested parties, with victory often going to the
            participants with the greatest weight of 
            <div class="emphasis e31" role="ital">Sitzfleisch</div> rather than the best ideas.
         </div>
         <div class="para e32">This paper describes an attempt to return to those thrilling days of yesteryear by
            providing a modern equivalent of SGML architectural engines. In principle any grammar-based
            schema language such as XML Schema or RELAX NG would be suitable for the methods outlined
            here.  However, the software development (still very much a work in progress as of
            this writing) is using the much simpler Examplotron schema language.  Examplotron
            is not well-known or much used in the XML environment, but I believe it to be extremely
            suitable to the stripped-down MicroXML environment in which I am now primarily interested.
            Since most people don't know Examplotron, I have written the paper to be accessible
            to anyone who can read simple DTD declarations.
         </div>
         <div class="para e33">In this paper, I will speak of the 
            <div class="emphasis e34" role="ital">source document</div>, which is the input to a schema-based 
            <div class="emphasis e35" role="ital">transformation engine</div> (TE), and of the 
            <div class="emphasis e36" role="ital">target document</div>, which is a TE's output.  Additional inputs are the 
            <div class="emphasis e37" role="ital">source schema</div> and the 
            <div class="emphasis e38" role="ital">target schema</div>.  In this paper the schemas are expressed as DTD fragments, but in actual use they
            will be Examplotron 0.8 schemas.  In addition, we may supply the TE with the 
            <div class="emphasis e39" role="ital">transformation name</div> of the particular transformation to be performed on the source, possibly one of many
            such transformations.  For clarity's sake, I will speak as if the various transformations
            are made one by one, but except for attribute defaulting they are all made simultaneously.
            For example, if all elements named 
            <div class="code e40">foo</div> are to be renamed 
            <div class="code e41">bar</div>, and all elements named 
            <div class="code e42">bar</div> are to be renamed 
            <div class="code e43">baz</div>, that does 
            <div class="emphasis e44" role="ital">not</div> mean that both 
            <div class="code e45">foo</div> and 
            <div class="code e46">bar</div> elements wind up being named 
            <div class="code e47">baz</div>.
         </div>
      </div><a name="2ElementRenamingandtheRenamingAttributeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e48">
         <div class="title e49">2. Element Renaming and the Renaming Attribute</div>
         <div class="para e50">The first and simplest kind of transformation to be performed is 
            <div class="emphasis e51" role="ital">element renaming</div>.  A TE does this by looking at each element of the source document for an attribute
            whose name is the same as the transformation name supplied to the TE.  This attribute
            is called the 
            <div class="emphasis e52" role="ital">renaming attribute</div>.
         </div>
         <div class="para e53">For example, suppose we have the following source document:
            
            <div class="programlisting e54" xml:space="preserve">
               &lt;limerick&gt;
               &lt;title&gt;Relativity&lt;/title&gt;
               &lt;a&gt;There was a young lady named Bright&lt;/a&gt;
               &lt;a&gt;Who could travel much faster than light.&lt;/a&gt;
               &lt;b&gt;She set out one day&lt;/b&gt;
               &lt;b&gt;In a relative way&lt;/b&gt;
               &lt;a&gt;And returned the previous night.&lt;/a&gt;
               &lt;/limerick&gt;
               
            </div>
            If we wish to transform it from its limerick-specific schema to a more general stanza
            schema, we might add a renaming attribute named 
            <div class="code e55">stanza</div> to every element, like this:
            
            <div class="programlisting e56" xml:space="preserve">
               &lt;limerick stanza="stanza"&gt;
               &lt;title stanza="title"&gt;Relativity&lt;/title&gt;
               &lt;a stanza="line"&gt;There was a young lady named Bright&lt;/a&gt;
               &lt;a stanza="line"&gt;Who could travel much faster than light.&lt;/a&gt;
               &lt;b stanza="line"&gt;She set out one day&lt;/b&gt;
               &lt;b stanza="line"&gt;In a relative way&lt;/b&gt;
               &lt;a stanza="line"&gt;And returned the previous night.&lt;/a&gt;
               &lt;/limerick&gt;
               
            </div>
            Running a TE on the above document, specifying 
            <div class="code e57">stanza</div> as the transformation name, would produce the following target document:
            
            <div class="programlisting e58" xml:space="preserve">
               &lt;stanza&gt;
               &lt;title&gt;Relativity&lt;/title&gt;
               &lt;line&gt;There was a young lady named Bright&lt;/line&gt;
               &lt;line&gt;Who could travel much faster than light.&lt;/line&gt;
               &lt;line&gt;She set out one day&lt;/line&gt;
               &lt;line&gt;In a relative way&lt;/line&gt;
               &lt;line&gt;And returned the previous night.&lt;/line&gt;
               &lt;/stanza&gt;
               
            </div>
            Note that all occurrences of the renaming attribute have been removed from the target
            document.
            
         </div>
         <div class="para e59">What happens if an element doesn't have a renaming attribute?  The answer is that
            the element is dropped in its entirety.  For example, suppose we did not have a 
            <div class="code e60">stanza</div> attribute on the source document's 
            <div class="code e61">title</div> element. In that case, the target document would contain only a 
            <div class="code e62">stanza</div> element with five 
            <div class="code e63">line</div> child elements.
         </div>
         <div class="para e64">If you don't provide a TE with a transformation name, there is no renaming attribute,
            and rather than dropping all the elements, none of them are renamed. However, the
            target document may still differ from the source document in other ways.
         </div>
         <div class="note e65">
            <div class="para e66">The concept of renaming attributes comes from AEs; however, AEs do not require the
               name of the renaming attribute to be the same as the transformation name, and have
               different and more flexible rules about processing elements without renaming attributes.
            </div>
         </div>
      </div><a name="3AttributeDefaultingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e67">
         <div class="title e68">3. Attribute Defaulting</div>
         <div class="para e69">This business of adding renaming attributes directly to the source document is irritating,
            and may be impossible if we aren't able to change the source document.  Instead, we
            can take advantage of 
            <div class="emphasis e70" role="ital">attribute defaulting</div> by specifying a source schema.  Consider the following DTD fragment: 
            
            <div class="programlisting e71" xml:space="preserve">
               &lt;!ATTLIST limerick stanza "stanza"&gt;
               &lt;!ATTLIST title stanza "title"&gt;
               &lt;!ATTLIST a stanza "line"&gt;
               &lt;!ATTLIST b stanza "line"&gt;
               
            </div>
            This says that in the 
            <div class="code e72">limerick</div> element, if no 
            <div class="code e73">stanza</div> attribute is supplied, its value is assumed to be 
            <div class="code e74">stanza</div>.  Likewise, for the 
            <div class="code e75">title</div> element, the default value of the 
            <div class="code e76">stanza</div> attribute is 
            <div class="code e77">title</div>, and for the 
            <div class="code e78">a</div> and 
            <div class="code e79">b</div> elements, it is 
            <div class="code e80">line</div>.  Now we no longer have to alter our original limerick document when we want to transform
            it.  If we specify the transformation name as 
            <div class="code e81">stanza</div>, we will get the same target document that we saw in the previous section.
         </div>
         <div class="para e82">What is more, we can provide more than one renaming attribute in the same source schema.
            Suppose we add the following declarations to the above source schema:
            
            <div class="programlisting e83" xml:space="preserve">
               &lt;!ATTLIST limerick estrofa "estrofa"&gt;
               &lt;!ATTLIST title estrofa "título"
               &lt;!ATTLIST a estrofa "línea"&gt;
               &lt;!ATTLIST b estrofa "línea"&gt;
               
            </div>
            If we specify the transformation name as 
            <div class="code e84">estrofa</div> rather than 
            <div class="code e85">stanza</div>, we will generate a target document whose element names are in Spanish rather than
            English.  However, the TE cannot automatically remove the defaulted 
            <div class="code e86">stanza</div> attribute when doing an 
            <div class="code e87">estrofa</div> transformation, nor vice versa, because it does not know which attributes might be
            used as renaming attributes in a different transformation run. In order to suppress
            them, we must provide the TE with a list of renaming attributes that are 
            <div class="emphasis e88" role="ital">not</div> being used for the current transformation, so that they can be suppressed from the
            target document.  In the rest of this paper we will assume that this list has been
            provided.
         </div>
         <div class="para e89">Attribute defaulting is not restricted to renaming attributes. If any attribute is
            given a default value by the source schema but does not appear in the source document,
            it will be created, and by default will appear in the target document.  Attribute
            defaulting is done in advance of all other transformations; a default attribute may
            have its name or value changed by a later transformation.
         </div>
         <div class="note e90">
            <div class="para e91">Attribute defaulting is inherent to DTD processing.  The version of Examplotron used
               by TEs, Examplotron 0.8, allows the specification of default values for attributes,
               and in fact for elements too.
            </div>
         </div>
      </div><a name="4ElementReorderingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e92">
         <div class="title e93">4. Element Reordering</div>
         <div class="para e94">So far, we haven't had to deal with child elements appearing in a different order
            in the source and target documents.  However, this can often happen when the source
            document is data-oriented rather than content-oriented.  In order to know how to reorder
            child elements, we must provide the TE with  a target schema.  Here's a simple target
            schema specifying a document containing people's names:
            
            <div class="programlisting e95" xml:space="preserve">
               &lt;!ELEMENT people (person*)&gt;
               &lt;!ELEMENT person (last, first)&gt;
               
            </div>
            In this schema, we see that a 
            <div class="code e96">people</div> element contains zero or more 
            <div class="code e97">person</div> elements and nothing else, and that each 
            <div class="code e98">person</div> element contains 
            <div class="code e99">last</div> and 
            <div class="code e100">first</div> elements in that order. 
         </div>
         <div class="para e101">Now here's a source document:
            
            <div class="programlisting e102" xml:space="preserve">
               &lt;people&gt;
               &lt;person&gt;
               &lt;first&gt;John&lt;/first&gt;
               &lt;last&gt;Cowan&lt;/last&gt;
               &lt;/person&gt;
               &lt;person&gt;
               &lt;first&gt;Dorian&lt;/first&gt;
               &lt;last&gt;Cowan&lt;/last&gt;
               &lt;/person&gt;
               &lt;/people&gt;
               
            </div>
            Suppose we pass this source document and the target schema to a TE without specifying
            a transformation name.  In that case, there is no renaming attribute, and so no element
            renaming is done.  However, since the order of child elements for the 
            <div class="code e103">person</div> element in the source document is not valid according to the target schema, they
            will be reordered so as to be valid in the target document, producing this:
            
            <div class="programlisting e104" xml:space="preserve">
               &lt;people&gt;
               &lt;person&gt;
               &lt;last&gt;Cowan&lt;/last&gt;
               &lt;first&gt;John&lt;/first&gt;
               &lt;/person&gt;
               &lt;person&gt;
               &lt;last&gt;Cowan&lt;/last&gt;
               &lt;first&gt;Dorian&lt;/first&gt;
               &lt;/person&gt;
               &lt;/people&gt;
               
            </div>
            
         </div>
         <div class="note e105">
            <div class="para e106">AEs do not perform element reordering.</div>
         </div>
      </div><a name="5OccurrencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e107">
         <div class="title e108">5. Occurrences</div>
         <div class="para e109">Both source and target schemas can specify how many occurrences a child
            element can have within its parent element.  In DTDs, we can repeat the element name
            to specify a fixed number of occurrences, as in this source schema for our limerick
            document:
            
            <div class="programlisting e110" xml:space="preserve">
               &lt;!ELEMENT limerick (title, a, a, b, b, a)&gt;
               &lt;!ATTLIST limerick index "poem"&gt;
               &lt;!ATTLIST a index "firstline"&gt;
               
            </div>
         </div>
         <div class="para e111">Now suppose we run a TE, passing it the transformation name 
            <div class="code e112">index</div>, our original limerick document, the above source schema, and the following target
            schema:
            
            <div class="programlisting e113" xml:space="preserve">
               &lt;!ELEMENT poem (firstline)&gt;
               
            </div>
            The renaming attribute 
            <div class="code e114">index</div> will rename the 
            <div class="code e115">limerick</div> element to 
            <div class="code e116">poem</div> and the three 
            <div class="code e117">a</div> elements to 
            <div class="code e118">firstline</div>, dropping the 
            <div class="code e119">title</div> and 
            <div class="code e120">b</div> elements altogether.  But since the target schema permits only a single 
            <div class="code e121">firstline</div> element in each 
            <div class="code e122">poem</div> element, the second and third 
            <div class="code e123">firstline</div> elements will also be dropped, producing the following target document:
            
            <div class="programlisting e124" xml:space="preserve">
               &lt;poem&gt;
               &lt;firstline&gt;There was a young lady named Bright&lt;/firstline&gt;
               &lt;/poem&gt;
               
            </div> This is suitable for inclusion in an index of first lines.
            
         </div>
         <div class="para e125"> On the other hand, if the target schema requires more occurrences
            of an element than the source schema provides, sufficient elements are
            created following the mapped elements. For an example of that process, consider this
            source document with explicit renaming attributes:
            
            <div class="programlisting e126" xml:space="preserve">
               &lt;couplet limerick="limerick"&gt;
               &lt;line limerick="a"&gt;Go and tell the Spartans, passerby,&lt;/line&gt;
               &lt;line limerick="b"&gt;That here, obedient to their laws, we lie.&lt;/line&gt;
               &lt;/couplet&gt;
               
            </div>
            What happens if we transform this into a limerick using the limerick schema as the
            target schema?  (There is nothing inherent in a schema that says whether it is a source
            or a target, only in how it is provided to a TE.)  Limericks have to have a title
            and five lines, but we have only two lines here, one mapped (for some unknown reason)
            to an 
            <div class="code e127">a</div> element and one to a 
            <div class="code e128">b</div> element.  Consequently, we get this target document:
            
            <div class="programlisting e129" xml:space="preserve">
               &lt;limerick&gt;
               &lt;title/&gt;
               &lt;a&gt;Go and tell the Spartans, passerby,&lt;/a&gt;
               &lt;a/&gt;
               &lt;b&gt;That here, obedient to their laws, we lie.&lt;/b&gt;
               &lt;b/&gt;
               &lt;a/&gt;
               &lt;/limerick&gt;
               
            </div>Not very useful or pretty, perhaps, but certainly valid.
         </div>
         <div class="para e130">In this paper, newly created elements are shown as empty.  However, if the Examplotron
            schema provides a default value for them, it will be used.
         </div>
         <div class="para e131">When specifying the content model of an element in a source or target schema, we can
            follow the name of a child element with 
            <div class="code e132">*</div> to mean "zero or more occurrences", as shown in the declaration of the 
            <div class="code e133">people</div> element.  In the same way, 
            <div class="code e134">?</div> means "zero or one occurrences" and 
            <div class="code e135">+</div> means "one or more occurrences".  All these indicators are respected by a TE.  So
            if two 
            <div class="code e136">foo</div> child elements appear in the source document, but the target schema specifies 
            <div class="code e137">foo?</div>, then the second one will be dropped.  A TE cannot construct transformations based
            on more complex content models like 
            <div class="code e138">((a,b)+)</div>, in which the occurrence indicator follows a sequence of child element names, except
            as noted under the discussion of mixed content.
         </div>
         <div class="para e139">However, technically ambiguous content models like 
            <div class="code e140">(line, line?, line?)</div>, meaning from one to three 
            <div class="code e141">line</div> elements, which are illegal in DTDs, are supported in Examplotron schemas as well
            as by a TE.
         </div>
         <div class="note e142">
            <div class="para e143">AEs neither drop unwanted elements nor create new ones, but report validation errors
               instead.
            </div>
         </div>
      </div><a name="6CharacterContentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e144">
         <div class="title e145">6. Character Content</div>
         <div class="para e146">So far, the source and target schemas we have seen have been incomplete, because not
            all the elements used in the documents have been mentioned in the schemas.  In particular,
            declarations for the elements whose only permitted content is characters, such as
            
            <div class="code e147">a</div>, 
            <div class="code e148">firstline</div>, and 
            <div class="code e149">title</div> have been left out.  Here's a complete version of the limerick source schema with
            all three renaming attributes provided:
            
            <div class="programlisting e150" xml:space="preserve">
               &lt;!ELEMENT limerick (title, a, a, b, b, a)&gt;
               &lt;!ATTLIST limerick stanza "stanza"&gt;
               &lt;!ATTLIST limerick estrofa "estrofa"&gt;
               &lt;!ATTLIST limerick index "poem"&gt;
               &lt;!ELEMENT title #PCDATA&gt;
               &lt;!ATTLIST title stanza "title"&gt;
               &lt;!ATTLIST title estrofa "título"
               &lt;!ELEMENT a #PCDATA&gt;
               &lt;!ATTLIST a stanza "line"&gt;
               &lt;!ATTLIST a estrofa "línea"&gt;
               &lt;!ATTLIST a index "firstline"&gt;
               &lt;!ELEMENT b #PCDATA&gt;
               &lt;!ATTLIST b stanza "line"&gt;
               &lt;!ATTLIST b estrofa "línea"&gt;
               
            </div>
            And here is an erroneous target schema for stanza documents:
            
            <div class="programlisting e151" xml:space="preserve">
               &lt;!ELEMENT stanza (title, line*)&gt;
               &lt;!ELEMENT title #PCDATA&gt;
               &lt;!ELEMENT line EMPTY&gt;
               
            </div>
         </div>
         <div class="para e152">Let's see what happens if we do a 
            <div class="code e153">stanza</div> transformation using that target schema.  We get this target document:
            
            <div class="programlisting e154" xml:space="preserve">
               &lt;stanza&gt;
               &lt;title&gt;Relativity&lt;/title&gt;
               &lt;line/&gt;
               &lt;line/&gt;
               &lt;line/&gt;
               &lt;line/&gt;
               &lt;line/&gt;
               &lt;/stanza&gt;
               
            </div>
            Because the target schema specified the 
            <div class="code e155">line</div> element as empty (no child elements or character content), the TE threw away the
            character content.  Again, probably not very useful, but again certainly valid.
         </div>
         <div class="para e156">Reordering and occurrence control are really two aspects of the same thing, and they
            can both happen to the same children of an element at the same time.  Here is a not-very-realistic
            example.  Given the source document
            
            <div class="programlisting e157" xml:space="preserve">
               &lt;root&gt;
               &lt;a id="a1"/&gt;
               &lt;b id="b1"/&gt;
               &lt;a id="a2"/&gt;
               &lt;b id="b2"/&gt;
               &lt;a id="a3"/&gt;
               &lt;/root&gt;
               
            </div>
            and the target schema
            
            <div class="programlisting e158" xml:space="preserve">
               &lt;!ELEMENT root (a, a, b, b, b&gt;)&gt;
               
            </div>
            the target document will be
            
            <div class="programlisting e159" xml:space="preserve">
               &lt;root&gt;
               &lt;a id="a1"/&gt;
               &lt;a id="a2"/&gt;
               &lt;b id="b1"/&gt;
               &lt;b id="b2"/&gt;
               &lt;b/&gt;
               &lt;/root&gt;
               
            </div>
            That is, the 
            <div class="code e160">a</div> elements have been reordered before the 
            <div class="code e161">b</div> elements, the third 
            <div class="code e162">a</div> element has been dropped as unwanted, and a third 
            <div class="code e163">b</div> element has been created.
         </div>
         <div class="note e164">
            <div class="para e165">AEs allow greater control of what happens to character content when an element containing
               it is dropped from the target document: it may be discarded or included as part of
               the parent element.  TEs always discard it unless the parent element's content model
               is specified as mixed content.
            </div>
         </div>
      </div><a name="7MixedContentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e166">
         <div class="title e167">7. Mixed Content</div>
         <div class="para e168">An element has mixed content when its content includes both child elements and characters.
            Consider this limerick:
            
            <div class="programlisting e169" xml:space="preserve">
               &lt;limerick&gt;
               &lt;title&gt;Memory&lt;/title&gt;
               &lt;a&gt;There was an old man of Khartoum&lt;/a&gt;
               &lt;a&gt;Who kept two black sheep in his room.&lt;/a&gt;
               &lt;b&gt;&lt;quote&gt;"They remind me,"&lt;/quote&gt; he said,&lt;/b&gt;
               &lt;b&gt;&lt;quote&gt;"Of two friends who are dead,&lt;/quote&gt;&lt;/b&gt;
               &lt;a&gt;&lt;quote&gt;But I &lt;em&gt;cannot&lt;/em&gt; remember of whom."&lt;/quote&gt;&lt;/a&gt;
               &lt;/limerick&gt;
               
            </div>  Because of the 
            <div class="code e170">quote</div> and 
            <div class="code e171">em</div> elements, this document isn't valid against our latest limerick schema.  Let's add
            the following declarations to our limerick schema, replacing the existing declarations
            for the 
            <div class="code e172">a</div> and 
            <div class="code e173">b</div> elements:
            
            <div class="programlisting e174" xml:space="preserve">
               &lt;!ELEMENT emphasis (#PCDATA|quote|em)*&gt;
               &lt;!ELEMENT quote (#PCDATA|quote|em)*&gt;
               &lt;!ELEMENT a (#PCDATA|quote|em)*&gt;
               &lt;!ELEMENT b (#PCDATA|quote|em)*&gt;
               
            </div>
            The meaning of these element declarations is that the specified child elements (
            <div class="code e175">quote</div> and 
            <div class="code e176">em</div> in this case) may appear in any order, any number of times, interleaved with the
            character content if any.  This is the only kind of mixed content that DTDs support.
            Examplotron permits more restrictive sorts of mixed content, but a TE cannot handle
            them.  If we do a 
            <div class="code e177">stanza</div> transformation, then because the 
            <div class="code e178">a</div> and 
            <div class="code e179">b</div> elements are declared to have mixed content, instead of simply dropping the 
            <div class="code e180">quote</div> and 
            <div class="code e181">em</div> elements along with their content as you might expect, their content is preserved.
            The result, then, is the same as if no quotation or emphasis markup had appeared in
            the source document.
         </div>
         <div class="para e182">What would happen if the target schema for stanzas allowed 
            <div class="code e183">em</div> elements but not 
            <div class="code e184">quote</div> elements?  Then the final line's content would become:
            
            <div class="programlisting e185" xml:space="preserve">
               &lt;line&gt;But I &lt;em&gt;cannot&lt;/em&gt; remember of whom.&lt;/line&gt;
               
            </div>
         </div>
         <div class="para e186">By definition, reordering is never done on mixed content.  It is the presence of mixed
            content in the source schema, not in the target schema, that triggers this style of
            processing, although you usually want to specify mixed content in both schemas.
         </div>
         <div class="para e187">In summary, the content models that a TE supports are mixed content, character-only
            content, empty content, and element content consisting of a simple sequence of child
            element names, possibly decorated with occurrence indicators.  All other content models
            are unsupported for transformation, though they are permitted for validation.
         </div>
      </div><a name="8AttributeMappingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e188">
         <div class="title e189">8. Attribute Mapping</div>
         <div class="para e190">So far, the value of a renaming attribute has been a single token, an element name.
            But if the renaming attribute contains multiple tokens separated by whitespace, the
            first token is the element name for element mapping, and the rest of the tokens are
            pairs of equivalent source and target attribute names.  For example, here's a 
            <div class="code e191">link</div> element that contains a renaming attribute to map it to an HTML 
            <div class="code e192">a</div> element:
            
            <div class="programlisting e193" xml:space="preserve">
               &lt;link target="http://examplotron.com"
               html="a target href"&gt;
               Examplotron
               &lt;/link&gt;
               
            </div>
            
            Running a TE on this source document and providing 
            <div class="code e194">html</div> as the transformation name produces this target document:
            
            <div class="programlisting e195" xml:space="preserve">
               &lt;a href="http://examplotron.com"&gt;
               Examplotron
               &lt;/a&gt;
               
            </div>
         </div>
         <div class="para e196">TEs support three special cases of attribute mapping.  If the target attribute name
            is replaced by 
            <div class="code e197">#NONE</div>, then the source attribute will be omitted from the target document.  If the source
            attribute is 
            <div class="code e198">#CONTENT</div>, then the target attribute's value does not come from any source attribute, but from
            the character content of the element; likewise, if the target attribute is 
            <div class="code e199">#CONTENT</div>, then the source attribute is removed and its value is used as character content
            of the target element.  Here's an example of all three special cases.  The source
            element
            
            <div class="programlisting e200" xml:space="preserve">
               &lt;url purpose="linkage" label="Examplotron"
               html="a purpose #NONE label #CONTENT #CONTENT href"&gt;
               http://examplotron.org
               &lt;/url&gt;
               
            </div> is transformed by dropping the 
            <div class="code e201">purpose</div> attribute, putting the character content 
            <div class="code e202">http://examplotron.org</div> into the 
            <div class="code e203">href</div> attribute, and putting the value of the 
            <div class="code e204">label</div> attribute into the character content of the target element (an 
            <div class="code e205">a</div> element), thus producing the same result (modulo whitespace) as the transformation
            of the 
            <div class="code e206">link</div> element did.
         </div>
         <div class="para e207">As a further extension to attribute mapping, if a source/target attribute name pair
            is followed by the token #
            <div class="code e208">MAPTOKEN</div>, it is then followed by a source token and a target token.  The source attribute
            value is then divided into tokens by whitespace, and if the source token appears in
            it, it is replaced by the target token.  There may be any number of such triples of
            
            <div class="code e209">#MAPTOKEN</div>, source token, target token following a source/target attribute pair.
         </div>
         <div class="note e210">
            <div class="para e211">This mechanism is usable but crude, and should eventually be replaced by something
               less hacky.  In AEs the source/target attribute pairs and mapping-token triples are
               in a separate attribute from the renaming attribute.
            </div>
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e212">
         <div class="title e213">Bibliography</div>
         <div class="bibliomixed e214">International Organization for Standards.   
            <div class="emphasis e215" role="ital">SGML Extended Facilities</div>, normative annex A to ISO/IEC 10744.  "A.3 Architectural Form Definition Requirements
            (AFDR)." [online]. © 1992, 1997 [cited 12 July 2013].  
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e216" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.pms.ifi.lmu.de/mitarbeiter/ohlbach/multimedia/HYTIME/ISO/clause-A.3.html</div>.
         </div>
         <div class="bibliomixed e217">van der Vlist, Eric. "Examplotron" [online]. © 2003 [cited 12 July 2013].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e218" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.examplotron.org</div>.
         </div>
      </div>
   </div>
</div>