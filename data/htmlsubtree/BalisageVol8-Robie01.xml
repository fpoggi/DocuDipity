<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#XQueryXSLTandJSONANCHOR" name="XQueryXSLTandJSONTOC">XQuery, XSLT and JSON</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheWebin2012:HTML5JavaScriptandJSONANCHOR" name="TheWebin2012:HTML5JavaScriptandJSONTOC">The Web in 2012: HTML5, JavaScript, and JSON</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MapsandArraysamissingpieceinXQueryandXSLTANCHOR" name="MapsandArraysamissingpieceinXQueryandXSLTTOC">Maps and Arrays, a missing piece in XQuery and XSLT</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheXSLT30MapsProposalANCHOR" name="TheXSLT30MapsProposalTOC">The XSLT 3.0 Maps Proposal</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#JSONiq:ExtendingXQuerywithMapsandArraysANCHOR" name="JSONiq:ExtendingXQuerywithMapsandArraysTOC">JSONiq: Extending XQuery with Maps and Arrays</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ComparingtheXSLT30MapsProposaltoJSONiqANCHOR" name="ComparingtheXSLT30MapsProposaltoJSONiqTOC">Comparing the XSLT 3.0 Maps Proposal to JSONiq</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ArraysandSequencesANCHOR" name="ArraysandSequencesTOC">Arrays and Sequences</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MovingForwardANCHOR" name="MovingForwardTOC">Moving Forward</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">array</div>
         <div class="singletermTERMS">Apache Hadoop: Pig Documentation.</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">boolean</div>
         <div class="singletermTERMS">BSON</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">collection("sales")</div>
         <div class="singletermTERMS">collection("products")</div>
         <div class="singletermTERMS">collection("stores")</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">date-time</div>
         <div class="singletermTERMS">date</div>
         <div class="singletermTERMS">Deprecating XML</div>
         <div class="singletermTERMS">Data Types and Conventions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">except</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">function($key as xs:anyAtomicValue) as item()*</div>
         <div class="singletermTERMS">fn:deep-equal</div>
         <div class="singletermTERMS">function($key as xs:string) as item()?</div>
         <div class="singletermTERMS">function(xs:integer) as item()?</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">https://github.com/jpcs/rbtree.xq/</div>
         <div class="singletermTERMS">HQL Tutorial</div>
         <div class="singletermTERMS">Hive Language Manual.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">ItemType</div>
         <div class="singletermTERMS">is</div>
         <div class="singletermTERMS">intersect</div>
         <div class="singletermTERMS">integer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">json-item</div>
         <div class="singletermTERMS">json:null</div>
         <div class="singletermTERMS">JSONItemTest</div>
         <div class="singletermTERMS">jn:null()</div>
         <div class="singletermTERMS">JSON and XML</div>
         <div class="singletermTERMS">JSON: The Fat-Free Alternative to XML.</div>
         <div class="singletermTERMS">JSONT: Transforming JSON.</div>
         <div class="singletermTERMS">JSONiq: Use Cases.</div>
         <div class="singletermTERMS">jonathan.robie@emc.com</div>
         <div class="singletermTERMS">Jonathan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">MapType</div>
         <div class="singletermTERMS">map(xs:integer, element(employee))</div>
         <div class="singletermTERMS">map:get($map, $key)</div>
         <div class="singletermTERMS">map:new</div>
         <div class="singletermTERMS">map:remove</div>
         <div class="singletermTERMS">map:new()</div>
         <div class="singletermTERMS">map{ }</div>
         <div class="singletermTERMS">map{0:="Sunntig",1:="Määntig"}</div>
         <div class="singletermTERMS">map{0:="Sunntig",1:="Määntig",2:="Ziischtig"}</div>
         <div class="singletermTERMS">map{0:="Sunday",1:="Määntig",2:="Dienstag"</div>
         <div class="singletermTERMS">map{"count":2}</div>
         <div class="singletermTERMS">map{0:="Sunntig",2:="Ziischtig"}</div>
         <div class="singletermTERMS">map{"x":=1e0,"y":=map{1:=3e0,2:=4e0,3:=5e0}}</div>
         <div class="singletermTERMS">map{1:="a", 2:="b", 3:=()}</div>
         <div class="singletermTERMS">members()</div>
         <div class="singletermTERMS">Mongo Query Language: Advanced Queries.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">node</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">object</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">parse-JSON</div>
         <div class="singletermTERMS">parse-json('{"x":1, "y":[3,4,5]}')</div>
         <div class="singletermTERMS">parse-json()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">Robie</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">serialize-JSON</div>
         <div class="singletermTERMS">structured-item</div>
         <div class="singletermTERMS">string</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">time</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">union</div>
         <div class="singletermTERMS">universal data format</div>
         <div class="singletermTERMS">universal hub format</div>
         <div class="singletermTERMS">UnQL: Unstructured Query Language.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:iterate</div>
         <div class="singletermTERMS">XML, Java, and the future of the Web</div>
         <div class="singletermTERMS">XML vs the Web</div>
         <div class="singletermTERMS">XSL Transformations (XSLT) Version 3.0.</div>
         <div class="singletermTERMS">XQuery 3.0: An XML Query Language.</div>
         <div class="singletermTERMS">XML Path Language (XPath) 3.0.</div>
         <div class="singletermTERMS">XQuery and XPath Data Model 3.0</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">Yahoo Query Language</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="XQueryXSLTandJSONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">XQuery, XSLT and JSON</div>
      <div class="subtitle e2">Adapting the XML stack for a world of XML, HTML, JSON and JavaScript</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2012</div>
            <div class="confdates e6">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">XML and JSON have become the dominant formats for
               exchanging data on the Internet, and applications frequently
               need to send and receive data in many different JSON-based or
               XML-based formats, consuming or producing data in JSON, XML, or
               HTML. JSON has not yet developed an application stack as mature
               as the XML application stack; for instance, there is still no
               standard query language, transformation language, or schema
               language. 
               
               And the XML application stack has not yet evolved to
               easily process JSON.
            </div>
            <div class="para e9">There are several areas where the XML stack should evolve
               to better support developers who work with JSON together with
               XML, and the features needed to support JSON in XQuery and XSLT
               also provide data structures that simplify writing queries and
               transformations, and allow more efficient processing of
               intermediate results when processing XML. As JSON becomes
               increasingly common in databases, and is exchanged among
               servers, these same kinds of tools may even become important in
               environments that use only JSON.
            </div>
            <div class="para e10">This paper focuses on queries and transformations, looking
               at JSON support in several NoSQL databases, the JSONiq proposal
               (which adds JSON objects and arrays to XQuery), and the XSLT
               maps proposal (which adds maps that can represent JSON objects
               and arrays).
               
               At the time of writing, the W3C XML Query Working Group and the
               W3C XSL Working Group are considering several proposals for
               supporting JSON.  
               
               The Working Groups expect to agree on a common solution that can
               be used in both XSLT and XQuery.
            </div>
         </div>
         <div class="author e11">
            <div class="personname e12">
               <div class="firstname e13">Jonathan</div>
               <div class="surname e14">Robie</div>
            </div>
            <div class="personblurb e15">
               <div class="para e16"></div>
            </div>
            <div class="email e17">jonathan.robie@emc.com</div>
         </div>
         <div class="legalnotice e18">
            <div class="para e19">Creative Commons attribution 3.0 unported (
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e20" xlink:actuate="onRequest" xlink:href="http://www.creativecommons.org/licenses/by/3.0/" xlink:show="new" xlink:type="simple">http://creativecommons.org/licenses/by/3.0/</div>)
            </div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e21">
         <div class="title e22">Introduction</div>
         <div class="para e23">In the early days of XML, many in the XML community saw it
            as a universal format that would be used to represent most kinds
            of data exchanged among programs, allowing many different kinds of
            information to be processed in the same way.
         </div>
         <div class="popupBox e24">
            <div class="popupLabel" onmouseover="$('#d1e40').show('1000');" onmouseout="$('#d1e40').hide('1000');">[ blockquote ]</div>
            <div id="d1e40" style="display: none;">
               <div class="blockquote">
                  <div class="para e25">XML provides a way to label information from diverse
                     data sources including structured and semi-structured
                     documents, relational databases, and object
                     repositories.
                  </div>
                  <div class="para e26">The Extensible Markup Language, XML, is having a
                     profoundly unifying effect on diverse forms of
                     information. For the first time, XML provides an information
                     interchange format that is editable, easily parsed, and
                     capable of representing nearly any kind of structured or
                     semi-structured information.
                  </div>
                  <div class="attribution e27">
                     <div class="citation e28">"Quilt: An XML Query Language for Heterogeneous Data Sources", 2000.</div>
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="para e29">But less than a decade after XML 1.0 became a W3C
            Recommendation, some people were concluding that XML was not the
            best way to exchange traditional program data on the
            Internet.
         </div>
         <div class="popupBox e30">
            <div class="popupLabel" onmouseover="$('#d1e51').show('1000');" onmouseout="$('#d1e51').hide('1000');">[ blockquote ]</div>
            <div id="d1e51" style="display: none;">
               <div class="blockquote">
                  <div class="para e31">Unfortunately, XML is not well suited to
                     data-interchange, much as a wrench is not well-suited to
                     driving nails. It carries a lot of baggage, and it doesn't
                     match the data model of most programming languages. When
                     most programmers saw XML for the first time, they were
                     shocked at how ugly and inefficient it was. It turns out
                     that that first reaction was the correct one. There is
                     another text notation that has all of the advantages of XML,
                     but is much better suited to data-interchange. That notation
                     is JavaScript Object Notation (JSON).
                  </div>
                  <div class="para e32">JSON is a better data exchange format. XML is a better
                     document exchange format. Use the right tool for the right
                     job.
                  </div>
                  <div class="attribution e33">
                     <div class="citation e34">"JSON: The Fat-Free Alternative to XML", 2006.</div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e35">In many environments, XML and HTML are used to represent
            documents, and JSON is used for traditional data exchange. As more
            and more data is exchanged, stored, and queried as JSON, XML tools
            need to evolve to allow JSON and XML to be processed together.
            
            And adding support for JSON is useful even for XML data, because
            JSON's data structures are sorely missing in both XSLT and XQuery,
            and can simplify many transformations and queries.
         </div>
         <div class="para e36">This paper explores how an XML stack can be adapted to support
            a world of HTML5, JavaScript, and JSON, then explores two existing
            proposals that provide support for JSON: (1) the XSLT 3.0 maps
            proposal, which adds maps to XSLT and provides functions to convert
            JSON to and from these maps, and (2) JSONiq, which extends XQuery to
            add JSON objects and arrays. After that, a comparison of the two
            proposals is given, along with some thoughts about the issues that
            should be resolved as the W3C XSL Working Group and the W3C XML
            Query Working Group seek to develop a common proposal.
         </div>
         <div class="para e37">This talk represents the views of the author, not those of
            EMC Corporation, the W3C, or the XML Working Group. Most of these
            views were formed in conversation with Dana Florescu, Michael Kay,
            Ghislain Fourney, John Snelson, Mary Holstege, Matthias Brantner,
            Till Westmann, Andrew Eisenberg, and others whose views continue
            to inform me.
         </div>
      </div><a name="TheWebin2012:HTML5JavaScriptandJSONANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e38">
         <div class="title e39">The Web in 2012: HTML5, JavaScript, and JSON</div>
         <div class="para e40">The XML community has long argued that programs should
            exchange both documents and program data using text-based data
            formats that are readable, platform-neutral, based on open
            standards, separate presentation from content, and are
            optimized for data reuse and long-term storage of data. This
            argument has largely been won. However, XML is only one of
            several formats that are being used for this purpose.
         </div>
         <div class="para e41">In the early days of XML, many spoke of it as a
            
            <div class="quote e42">universal data format</div>, or a 
            <div class="quote e43">universal
               hub format
            </div>, and some hoped that XHTML would finally
            unify the Web, with XML as the foundation. But XHTML was not
            well supported by some browsers, and was never widely accepted
            as a replacement for HTML 4. Instead, the HTML community has
            moved strongly in the direction of HTML5.
            
            Even for data exchange, many JavaScript programmers decided
            that XML was too difficult to use in JavaScript programs,
            opting for JSON instead. While XML won the argument that data
            should be exchanged using text-based formats with the
            characteristics listed above, we now have three dominant
            formats: HTML, XML, and JSON. They are frequently used
            together. Few tools are designed to work equally well with all
            three formats, but many developers are expected to.
         </div>
         <div class="para e44">In recent years, the Web has been moving strongly in the
            direction of HTML5, JavaScript, and JSON
            and a new generation of databases, designed for distributed
            processing of massive amounts of data, uses JSON as the native
            data model. Ironically, JSON is now widely used for the
            very use cases highlighted in Jon Bosak's 1997 paper,
            
            <div class="quote e45">XML, Java, and the future of the Web</div>, which was
            written to promote XML. JSON was designed as a programming
            language-independent representation of typical programming
            language data structures, and in many languages, a simple
            library call can convert JSON to programming language
            structures, or programming language structures to JSON.  For
            this kind of data, JSON programming is dramatically simpler
            than XML programming, except when you need queries,
            transformations, or schema validation.
         </div>
         <div class="para e46">But JSON does not exist in a vacuum, and it frequently
            needs to be used together with mixed content, typically
            represented as HTML or XML. A single application may often use
            several Web interfaces, some XML-based, others JSON-based, and
            combine data from the two, creating results in various
            formats. And even as XML becomes less common in Web
            interfaces, it continues to be important for documents and for
            managing and generating content on the server, to be combined
            with other data and exchanged in other formats. XML tools are
            particularly powerful for complex data integration tasks
            involving heterogeneous data, and they can handle HTML well,
            but they need to be extended to better support JSON. This will
            benefit both the JSON and XML communities.
         </div>
         <div class="para e47">XML has a mature tool stack that does not yet exist for
            JSON, including schema languages, XSLT, and XQuery. Many XML
            developers find these tools sorely missing when they work with
            JSON, but it's not clear that the JSON community feels a strong
            need for most of these tools. Many query languages have been
            developed for JSON, a few schema languages and transformation
            languages have also been developed, but have not been widely
            used.
         </div>
         <div class="para e48">Using schemas to enforce contracts is just as relevant for JSON as
            it is for XML, but there is little enthusiasm in the JSON
            community for schema languages, especially complex schema
            languages. JSON Schema, perhaps the most widely used JSON schema
            language, provided validation, and also added "formats", which
            allow for validation of simple types such as
            
            <div class="code e49">date-time</div>, 
            <div class="code e50">date</div>, 
            <div class="code e51">time</div>,
            etc. JSON Schema is supported by several tools, and was written up
            as an IETF draft, but the draft expired in 2011.
            
            As a result, there is no standard way to support schema validation
            or validation of these data types in JSON. That makes it difficult
            for JSON interfaces to support declarative contracts via schemas.
         </div>
         <div class="para e52">The JSON community generally believes that JSON frequently
            needs to be transformed to and from other formats, especially HTML
            and XML, but JSONT, a lightweight XSLT-like transformation
            language designed in 2006, does not seem to have gained much
            traction, nor have any of the alternatives that have emerged. This
            may be partly because JavaScript and many scripting languages are
            fairly powerful for many common simple transformations. A number
            of libraries and other approaches have emerged for using XSLT to
            transform JSON, and are popular in the XML community among those
            who also work with JSON; it is too early to tell how widely they
            will be adopted in the JSON community.
         </div>
         <div class="para e53">Because NoSQL databases that use JSON as their native data
            model have gained significant traction in recent years, JSON query
            languages have gained much more traction, but no standard JSON
            query language has emerged. Standards are not as deeply embedded
            in JSON culture as they are in XML culture, and it is more
            difficult to gain agreement on a standard across the industry.
            
            A variety of approaches to querying JSON are used, including
            template-based queries (e.g. Mongo Query Language), SQL-like query
            languages (e.g. UnQL, HiveQL, YQL), procedural data flow languages
            (e.g. Pig Latin), functional data flow languages (e.g. Jaql), and
            simply using MapReduce libraries from conventional programming
            languages (e.g. Google BigTable).
            
         </div>
         <div class="para e54">To support queries, these languages often extend JSON with
            additional data types, such as date, object id, binary data,
            regular expression, or more specific numeric types such as int32,
            int64, or double.
            
         </div>
         <div class="para e55">The following queries illustrate the range of query
            languages that are used for querying JSON.
            <div class="popupBox e56">
               <div class="popupLabel" onmouseover="$('#d1e106').show('1000');" onmouseout="$('#d1e106').hide('1000');">[ footnote ]</div>
               <div id="d1e106" style="display: none;">
                  <div class="footnote">
                     <div class="para e57">A
                        detailed comparison of these languages is beyond the scope of
                        this paper.
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="itemizedlist e58">
            <div class="title e59">Queries in JSON Query Languages</div>
            <div class="listitem e60">
               <div class="para e61">Mongo Query Language: a template-based language for search/retrieval
                  <div class="popupBox e62">
                     <div class="popupLabel" onmouseover="$('#d1e116').show('1000');" onmouseout="$('#d1e116').hide('1000');">[ footnote ]</div>
                     <div id="d1e116" style="display: none;">
                        <div class="footnote">
                           <div class="para e63">Example taken from 
                              <div class="xref e64" linkend="MQL"></div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="programlisting e65" xml:space="preserve">
                  // select * from things where x=3 and y="foo"
                  db.things.find( { x : 3, y : "foo" } );
                  
                  // select * where j&lt;&gt; 3 and k&gt;10
                  db.things.find({j: {$ne: 3}, k: {$gt: 10} });
                  
                  // select * where a=1 or b=2 
                  db.foo.find( { $or : [ { a : 1 } , { b : 2 } ] } )
                  
               </div>
            </div>
            <div class="listitem e66">
               <div class="para e67">UNQL: a SQL-based language
                  <div class="popupBox e68">
                     <div class="popupLabel" onmouseover="$('#d1e126').show('1000');" onmouseout="$('#d1e126').hide('1000');">[ footnote ]</div>
                     <div id="d1e126" style="display: none;">
                        <div class="footnote">
                           <div class="para e69">Example taken from 
                              <div class="xref e70" linkend="UnQL"></div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="programlisting e71" xml:space="preserve">
                  // An UPSERT:  Incrementing a counter on a webpage.
                  UPDATE abc SET abc.n=abc.n+1 WHERE abc.page=="/page/one"
                  ELSE INSERT {page:"/page/one", n: 1, create_time: 1234567};
                  SELECT FROM abc;
                  
               </div>
            </div>
            <div class="listitem e72">
               <div class="para e73">Pig Latin: a data flow language
                  <div class="popupBox e74">
                     <div class="popupLabel" onmouseover="$('#d1e136').show('1000');" onmouseout="$('#d1e136').hide('1000');">[ footnote ]</div>
                     <div id="d1e136" style="display: none;">
                        <div class="footnote">
                           <div class="para e75">Example taken from 
                              <div class="xref e76" linkend="Pig"></div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="programlisting e77" xml:space="preserve">
                  VISITS = load '/visits' as (user, url, time);
                  USER_VISITS = group VISITS by user;
                  USER_COUNTS = foreach USER_VISITS generate group as user, COUNT(VISITS) as numvisits;
                  ALL_COUNTS = group USER_COUNTS all;
                  AVG_COUNT = foreach ALL_COUNTS generate AVG(USER_COUNTS.numvisits);
                  
                  dump AVG_COUNT;
                  
               </div>
            </div>
            <div class="listitem e78">
               <div class="para e79">HiveQL: a SQL-based data flow language
                  <div class="popupBox e80">
                     <div class="popupLabel" onmouseover="$('#d1e146').show('1000');" onmouseout="$('#d1e146').hide('1000');">[ footnote ]</div>
                     <div id="d1e146" style="display: none;">
                        <div class="footnote">
                           <div class="para e81">Example taken from 
                              <div class="xref e82" linkend="Hive"></div>.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="programlisting e83" xml:space="preserve">
                  INSERT OVERWRITE TABLE pv_gender_sum
                  SELECT pv_users.gender, count (DISTINCT pv_users.userid)
                  FROM pv_users
                  GROUP BY pv_users.gender;
                  
               </div>
            </div>
            <div class="listitem e84">
               <div class="para e85">Jaql: a functional data flow language
                  <div class="popupBox e86">
                     <div class="popupLabel" onmouseover="$('#d1e156').show('1000');" onmouseout="$('#d1e156').hide('1000');">[ footnote ]</div>
                     <div id="d1e156" style="display: none;">
                        <div class="footnote">
                           <div class="para e87">Example taken from 
                              <div class="xref e88" linkend="Jaql"></div>.
                           </div>
                        </div>
                     </div>
                  </div>.
               </div>
               <div class="programlisting e89" xml:space="preserve">
                  import myrecord;
                  countFields = fn(records) (
                  records
                  -&gt; transform myrecord::names($)
                  -&gt; expand
                  -&gt; group by fName = $ as occurrences
                  into { name: fName, num: count(occurrences) }
                  );
                  read(hdfs("docs.dat"))
                  -&gt; countFields()
                  -&gt; write(hdfs("fields.dat"));
                  
               </div>
            </div>
         </div>
      </div><a name="MapsandArraysamissingpieceinXQueryandXSLTANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e90">
         <div class="title e91">Maps and Arrays, a missing piece in XQuery and XSLT</div>
         <div class="para e92">Maps and arrays, under various names, are available in most
            modern programming languages, but until recently, they were
            absent from both XQuery and XSLT. This came from a basic design
            decision: XML is the complex data structure in these languages,
            and we felt that no other complex data structure was
            needed. While this worked well for most things, it made some
            kinds of queries and transformations needlessly complex for users
            to write, and complicated the design of the languages.
         </div>
         <div class="para e93">Maps and arrays are simple data structures, much simpler
            than XML, and adding them to XQuery and XSLT does not greatly
            change the complexity of the two languages. And maps and arrays
            add significant new features to both languages:
         </div>
         <div class="itemizedlist e94">
            <div class="listitem e95">
               <div class="para e96">Lightweight data structures that do not have
                  the overhead associated with namespace processing, element
                  construction, order preservation, or whitespace processing
                  rules.
               </div>
            </div>
            <div class="listitem e97">
               <div class="para e98">Data structures that can associate additional
                  data with an node, without losing the original identity of the
                  node. This is particularly helpful in function parameters and
                  returns. (Element construction in XQuery and XSLT loses the
                  original identity of the items used to construct the
                  element.)
               </div>
            </div>
            <div class="listitem e99">
               <div class="para e100">Nested arrays that can represent multiple
                  sequences returned from a function, mathematical matrices,
                  sparse matrices, etc.
               </div>
            </div>
            <div class="listitem e101">
               <div class="para e102">Data structures that can be used to describe
                  intermediate results of XQuery expressions, such as the tuple
                  stream in FLWOR expressions. (The notation used to describe the
                  tuple stream in the current XQuery specification could easily
                  be changed to maps.)
               </div>
            </div>
         </div>
         <div class="para e103">All of these things can be simulated with XML, but doing so
            introduces conceptual overhead for those who write queries or
            transformations, and system overhead that can affect the
            efficiency of queries.
         </div>
         <div class="para e104">If producing modified copies of a map is easy and
            efficient, maps add another useful feature: complex data
            structures that can track information encountered during a query
            or transformation. For instance, a reporting application can keep
            running totals and summaries by creating new map instances to
            reflect changing information.
         </div>
      </div><a name="TheXSLT30MapsProposalANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e105">
         <div class="title e106">The XSLT 3.0 Maps Proposal</div>
         <div class="para e107">The XSLT 3.0 maps proposal, which is new in the July 2012
            Working Draft of XSLT, was motivated by streaming use cases,
            which require complex data structures that can be used to
            remember what has been seen in the document, and also provides
            support for JSON.  It extends the type system, data model, and
            syntax of XPath 3.0 to support maps, which are represented as
            function items in the data model.
            <div class="popupBox e108">
               <div class="popupLabel" onmouseover="$('#d1e193').show('1000');" onmouseout="$('#d1e193').hide('1000');">[ footnote ]</div>
               <div id="d1e193" style="display: none;">
                  <div class="footnote">
                     <div class="para e109">Because XPath 3.0 is jointly owned with the XML Query
                        Working Group, the two Working Groups have committed to work
                        together to create a joint proposal, but this is not yet
                        reflected in any public document.
                     </div>
                  </div>
               </div>
            </div>
            
            It does not provide explicit support for arrays, but supports
            similar functionality using maps with integer-valued keys.
         </div>
         <div class="para e110">The XSLT proposal extends the syntax of XPath's
            
            <div class="code e111">ItemType</div> to allow support map types.
         </div>
         <div class="programlisting e112" xml:space="preserve">MapType ::= 'map' '(' ( '*' | (AtomicOrUnionType ',' SequenceType) ')'</div>
         <div class="para e113">For instance, 
            <div class="code e114">MapType</div> can be used to specify the type of a function parameter. Here is the signature of
            a function that uses a map to specify parsing options.
         </div>
         <div class="programlisting e115" xml:space="preserve">parse-json($json-text  as xs:string, 
            $options as map(*)) as item()?
         </div>
         <div class="para e116">There is no way to declare the type of a map, and the type
            of a map depends on its current contents. For instance,
            
            <div class="code e117">map(xs:integer, element(employee))</div> matches a map if
            all the keys in the map are integers and all the values are
            employee elements. If a new entry with a different key type or
            value type is added, the type of the map changes.
         </div>
         <div class="para e118">The maps proposal adds a new kind of primary expression to
            XPath in order to construct a map.
         </div>
         <div class="programlisting e119" xml:space="preserve">MapExpr := "map" "{" (KeyExpr ":=" ValueExpr ("," KeyExpr ":=" ValueExpr )*)? "}"
            KeyExpr := ExprSingle
            ValueExpr := ExprSingle
         </div>
         <div class="para e120">Here is an example of a map expression: 
            <div class="popupBox e121">
               <div class="popupLabel" onmouseover="$('#d1e222').show('1000');" onmouseout="$('#d1e222').hide('1000');">[ footnote ]</div>
               <div id="d1e222" style="display: none;">
                  <div class="footnote">
                     <div class="para e122">Most
                        examples in this section are taken from 
                        <div class="xref e123" linkend="xslt30"></div>.
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="programlisting e124" xml:space="preserve">
            map {
            "Su" := "Sunday",
            "Mo" := "Monday",
            "Tu" := "Tuesday",
            "We" := "Wednesday",
            "Th" := "Thursday",
            "Fr" := "Friday",
            "Sa" := "Saturday
            }   
         </div>
         <div class="para e125">The following map uses integer-valued keys, and is analogous to an array.</div>
         <div class="programlisting e126" xml:space="preserve">
            map {
            0 := "Sonntag", 
            1 := "Montag", 
            2 := "Dienstag", 
            3 := "Mittwoch", 
            4 := "Donnerstag", 
            5 := "Freitag", 
            6 := "Samstag"
            }
            
         </div>
         <div class="para e127">In the XSLT 3.0 maps proposal, a map is a function from
            keys to associated values, and is represented as a function
            item. The function 
            <div class="code e128">map:get($map, $key)</div> returns the
            value associated with a given key.
            
            The function signature for a map is 
            <div class="code e129">function($key as
               xs:anyAtomicValue) as item()*
            </div>, and calling a map function
            returns the value for that key (thus, 
            <div class="code e130">$map($key)</div> is
            a synonym for 
            <div class="code e131">map:get($map, $key)</div>. If
            
            <div class="code e132">$map</div> is bound to the map shown above, the following
            expressions are equivalent, they each evaluate to "Tuesday".
         </div>
         <div class="programlisting e133" xml:space="preserve">map:get($map,"Tu")</div>
         <div class="programlisting e134" xml:space="preserve">$map("Tu")</div>
         <div class="para e135">Maps have no identity; the contents of two maps can be
            compared, but there is no way to distinguish two maps with the
            same content.
         </div>
         <div class="para e136">All values in XSLT are immutable, but functions are
            provided to create new maps that differ from an existing map by
            removing an entry, adding an entry, or changing the value of an
            entry.
         </div>
         <div class="para e137">The following table provides a brief synopsis of the
            functions provided for maps.
            
         </div>
         <div class="table e138">
            <div class="caption e139">
               <div class="para e140">Map functions in the XSLT 3.0 maps
                  proposal
               </div>
            </div>
            <div class="tbody e141">
               <div class="tr e142">
                  <div class="td e143">map:new</div>
                  <div class="td e144">Creates a new map: either an empty
                     	 map, or a map that combines entries from a number of existing
                     	 maps. Allows a collation to be specified.
                  </div>
               </div>
               <div class="tr e145">
                  <div class="td e146">map:entry</div>
                  <div class="td e147">Creates a map that contains a
                     	 single key/value pair. Useful for creating maps with
                     	 
                     <div class="code e148">map:new</div>
                  </div>
               </div>
               <div class="tr e149">
                  <div class="td e150">map:get</div>
                  <div class="td e151">Returns the value associated with a key.</div>
               </div>
               <div class="tr e152">
                  <div class="td e153">map:keys</div>
                  <div class="td e154">Returns the keys found in a map.</div>
               </div>
               <div class="tr e155">
                  <div class="td e156">map:contains</div>
                  <div class="td e157">Tests whether a supplied map contains an entry for a given key.</div>
               </div>
               <div class="tr e158">
                  <div class="td e159">map:remove</div>
                  <div class="td e160">Constructs a new map by removing an entry from an existing map.</div>
               </div>
               <div class="tr e161">
                  <div class="td e162">map:collation</div>
                  <div class="td e163">Returns the URI of a given map's collation.</div>
               </div>
               <div class="tr e164">
                  <div class="td e165">fn:deep-equal2</div>
                  <div class="td e166">Determines whether two
                     	 sequences are deep-equal to each other; this function extends
                     	 
                     <div class="code e167">fn:deep-equal</div> to support sequences that contain
                     	 maps.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e168">The 
            <div class="code e169">map:new</div> function is used to create new
            maps from existing ones by specifying a sequence of maps. The
            newly created map contains every key/value pair that occurs in
            one of these maps; if a given key occurs in more than one map,
            its value in the newly created map is taken from the last map
            that contains a value for this key. The following examples show how 
            <div class="code e170">map:new</div> and 
            <div class="code e171">map:remove</div> are used to create modified versions of maps.
         </div>
         <div class="itemizedlist e172">
            <div class="listitem e173">
               <div class="para e174">
                  <div class="code e175">map:new()</div> returns 
                  <div class="code e176">map{ }</div>
               </div>
            </div>
            <div class="listitem e177">
               <div class="para e178">
                  <div class="code e179">map:new((map:entry(0, "Sunntig"), map:entry(1, "Määntig")))</div> returns 
                  <div class="code e180">map{0:="Sunntig",1:="Määntig"}</div>
               </div>
            </div>
            <div class="listitem e181">
               <div class="para e182">
                  <div class="code e183">map:new((map{0:="Sunntig"},map{1:="Määntig",2:="Ziischtig"}))</div> returns 
                  <div class="code e184">map{0:="Sunntig",1:="Määntig",2:="Ziischtig"}</div>
               </div>
            </div>
            <div class="listitem e185">
               <div class="para e186">
                  <div class="code e187">map:new(map{0:="Sunntig",1:="Määntig",2:="Ziischtig"},map{0:="Sunday",2:="Dienstag"))</div> returns 
                  <div class="code e188">map{0:="Sunday",1:="Määntig",2:="Dienstag"</div>
               </div>
            </div>
            <div class="listitem e189">
               <div class="para e190">
                  <div class="code e191">let $m:=map{"count":=1} return map:new("count":$m("count")+1)</div> returns 
                  <div class="code e192">map{"count":2}</div>
               </div>
            </div>
            <div class="listitem e193">
               <div class="para e194">
                  <div class="code e195">map:remove(map{0:="Sunntig",1:="Määntig",2:="Ziischtig"}, 1)</div> returns 
                  <div class="code e196">map{0:="Sunntig",2:="Ziischtig"}</div>
               </div>
            </div>
         </div>
         <div class="para e197">The following example, taken from the XSLT 3.0 Working Draft, uses maps and 
            <div class="code e198">xsl:iterate</div> to find the highest earning employee in each department, in a single streaming pass
            of a document containing employee records.
         </div>
         <div class="programlisting e199" xml:space="preserve">
            &lt;xsl:stream href="employees.xml"&gt;
            &lt;xsl:iterate select="*/employee"&gt;
            &lt;xsl:param name="highest-earners" 
            as="map(xs:string, element(employee))" 
            select="map:new()"/&gt;
            &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
            &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="highest-earners"
            select="let $existing := $highest-earners($this/department)
            return if ($existing/salary gt $this/salary)
            then $highest-earners
            else map:new($highest-earners, 
            map:entry($this/department, $this))"/&gt;
            &lt;/xsl:next-iteration&gt;
            &lt;xsl:on-completion&gt;
            &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
            &lt;department name="{.}"&gt;
            &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
            &lt;/department&gt;
            &lt;/xsl:for-each&gt;
            &lt;/xsl:on-completion&gt;
            &lt;/xsl:iterate&gt;
            &lt;/xsl:stream&gt;
         </div>
         <div class="para e200">The XSLT maps proposal also adds two functions,
            
            <div class="code e201">parse-JSON</div> and 
            <div class="code e202">serialize-JSON</div>, that
            convert between serialized JSON and XSLT
            maps. 
            <div class="code e203">parse-JSON</div> converts JSON arrays are converted
            to maps with integer-valued keys.
            
         </div>
         <div class="itemizedlist e204">
            <div class="listitem e205">
               <div class="para e206">
                  <div class="code e207">parse-json('{"x":1, "y":[3,4,5]}')</div> returns 
                  <div class="code e208">map{"x":=1e0,"y":=map{1:=3e0,2:=4e0,3:=5e0}}</div>.
               </div>
            </div>
            <div class="listitem e209">
               <div class="para e210">
                  <div class="code e211">let $m := parse-json('{"x":1, "y":[3,4,5]}') return $m("y")(2)</div> returns 
                  <div class="code e212">4e0</div>.
               </div>
            </div>
         </div>
      </div><a name="JSONiq:ExtendingXQuerywithMapsandArraysANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e213">
         <div class="title e214">JSONiq: Extending XQuery with Maps and Arrays</div>
         <div class="para e215">The JSONiq proposal extends XQuery to add support for
            JSON. It was primarily motivated by the need for a JSON query
            language, and the need for a single language that can query JSON,
            XML, and HTML. JSONiq extends the type system, data model, and
            syntax of XQuery to support JSON objects
            <div class="popupBox e216">
               <div class="popupLabel" onmouseover="$('#d1e406').show('1000');" onmouseout="$('#d1e406').hide('1000');">[ footnote ]</div>
               <div id="d1e406" style="display: none;">
                  <div class="footnote">
                     <div class="para e217">JSON
                        calls maps objects, as does JavaScript. In this paper, the term
                        object always refers to a map, rather than the objects used in
                        the object oriented paradigm.
                     </div>
                  </div>
               </div>
            </div> and
            arrays. JSONiq defines two profiles: one is a strict superset of
            XQuery that adds support for JSON, the other is a pure JSON query
            language with no XML constructs.
         </div>
         <div class="para e218">The following diagram shows JSONiq extensions to the data
            model in green.
         </div>
         <div class="figure e219" xml:id="jdm">
            <div class="title e220">JSONiq Data Model</div>
            <div class="mediaobject e221">
               <div class="imageobject e222">
                  <div class="metaBox e223"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e417').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e417" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e223'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Robie01/Robie01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='60%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e224">
               <div class="para e225">
                  <div class="code e226">object</div> represents a JSON object, 
                  <div class="code e227">array</div> represents a JSON array.  Both are derived from 
                  <div class="code e228">json-item</div>. 
                  <div class="code e229">structured-item</div> is an abstract base class for both 
                  <div class="code e230">node</div> and 
                  <div class="code e231">json-item</div>.
               </div>
               <div class="para e232">
                  <div class="code e233">json:null</div> is an atomic data type that represents JSON nulls.
               </div>
            </div>
         </div>
         <div class="para e234">Like XDM 3.0 nodes, a JSON item has identity, and it can
            be serialized. However, the identity of a JSON item is used only
            to support updates. Like XSLT maps, the contents of JSON items
            can be compared, but there is no way to distinguish two items
            with the same content.
         </div>
         <div class="para e235">JSONiq extends the syntax of XPath's 
            <div class="code e236">ItemType</div>
            to support the types of JSON items.
         </div>
         <div class="programlisting e237" xml:space="preserve">
            StructuredItemTest ::= "structured-item" "(" ")"
            JSONItemTest ::= "json-item" "(" ")"
            JSONObjectTest ::= "object" "(" ")"
            JSONArrayTest ::= "array" "(" ")"
            
         </div>
         <div class="para e238">For instance, a 
            <div class="code e239">JSONItemTest</div> can be used to declare the type of a function parameter or return.
         </div>
         <div class="programlisting e240" xml:space="preserve">declare function local:summary($o as object()) as array()
            {
            };
         </div>
         <div class="para e241">JSONiq adds primary expressions to construct objects and arrays.</div>
         <div class="programlisting e242" xml:space="preserve">
            ObjectConstructor ::=  "{" PairConstructor ("," PairConstructor)* "}"      
            PairConstructor ::=  ExprSingle ":" ExprSingle
            ArrayConstructor ::=  "[" Expr? "]"
            
         </div>
         <div class="para e243">Here is an example of a JSON object that contains an array.</div>
         <div class="programlisting e244" xml:space="preserve">{
            "name" : "Sarah",
            "age" : 13,
            "gender" : "female",
            "friends" : [ "Jim", "Mary", "Jennifer"]
            }    
         </div>
         <div class="para e245">Arrays can nest.</div>
         <div class="programlisting e246" xml:space="preserve">
            [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
            ]
            
         </div>
         <div class="para e247">Both objects and arrays compose with existing XQuery expressions; for instance, the
            following example uses an XQuery range expression to construct an array containing
            five integers:
         </div>
         <div class="programlisting e248" xml:space="preserve">[ 1 to 5 ]</div>
         <div class="para e249">Here is the result of the above query:</div>
         <div class="programlisting e250" xml:space="preserve">[ 1, 2, 3, 4, 5 ]</div>
         <div class="para e251">The following example constructs an object from the values in a sequence:</div>
         <div class="programlisting e252" xml:space="preserve">
            {
            for $d at $i in ("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
            )
            return $d : $i
            }
            
         </div>
         <div class="para e253">Here is the result of the above query:</div>
         <div class="programlisting e254" xml:space="preserve">
            {
            "Sunday"    : 1,
            "Monday"    : 2,
            "Tuesday"   : 3, 
            "Wednesday" : 4,
            "Thursday"  : 5,
            "Friday"    : 6,
            "Saturday"  : 7
            }
            
         </div>
         <div class="para e255">In JSONiq, an array contains a sequence of items, and an
            array is itself an item. JSONiq also supports JSON nulls. In the
            following array constructor, 
            <div class="code e256">jn:null()</div> creates a
            null value.
         </div>
         <div class="programlisting e257" xml:space="preserve">[1, "string", jn:null(), &lt;four/&gt;, ["nested", "array"]</div>
         <div class="para e258">Navigation in objects and arrays is done using "selectors",
            which use function call syntax as in the XSLT 3.0 maps proposal.
            An object selector has the function type 
            <div class="code e259">function($key as
               xs:string) as item()?
            </div>. An object selector returns the
            value associated with a given key, as in the following
            example.
         </div>
         <div class="programlisting e260" xml:space="preserve">
            let $map := { "eyes" : "blue", "hair" : "fuchsia" }
            return $map("eyes")
            
         </div>
         <div class="para e261">The result of the above query is "blue".</div>
         <div class="para e262">An array selector matches the function type
            
            <div class="code e263">function(xs:integer) as item()?</div>. An array selector
            returns the value found at a given position, as in the following
            example:
         </div>
         <div class="programlisting e264" xml:space="preserve">
            let $wd := ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            return $wd(1)
            
         </div>
         <div class="para e265">The result of the above query is "Sunday".</div>
         <div class="para e266">JSONiq also supports member selectors on sequences. If 
            <div class="code e267">$s</div> is a sequence, then 
            <div class="code e268">$s($param)</div> is translated to:
         </div>
         <div class="programlisting e269" xml:space="preserve">for $item in $s return $item($param)</div>
         <div class="para e270">The following example, taken from the 
            <div class="xref e271" linkend="jsoniq-uc"></div>,
            queries sales data, then groups it to show sales by category
            within each state.
         </div>
         <div class="para e272">
            <div class="code e273">collection("sales")</div> contains the following data:
         </div>
         <div class="programlisting e274" xml:space="preserve">
            { "product" : "broiler", "store number" : 1, "quantity" : 20  },
            { "product" : "toaster", "store number" : 2, "quantity" : 100 },
            { "product" : "toaster", "store number" : 2, "quantity" : 50 },
            { "product" : "toaster", "store number" : 3, "quantity" : 50 },
            { "product" : "blender", "store number" : 3, "quantity" : 100 },
            { "product" : "blender", "store number" : 3, "quantity" : 150 },
            { "product" : "socks", "store number" : 1, "quantity" : 500 },
            { "product" : "socks", "store number" : 2, "quantity" : 10 },
            { "product" : "shirt", "store number" : 3, "quantity" : 10 }
            
         </div>
         <div class="para e275">
            <div class="code e276">collection("products")</div> contains the following data:
         </div>
         <div class="programlisting e277" xml:space="preserve">
            { "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
            { "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
            { "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
            { "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
            { "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }
            
         </div>
         <div class="para e278">
            <div class="code e279">collection("stores")</div> contains the following data:
         </div>
         <div class="programlisting e280" xml:space="preserve">
            { "store number" : 1, "state" : CA },
            { "store number" : 2, "state" : CA },
            { "store number" : 3, "state" : MA },
            { "store number" : 4, "state" : MA }
            
         </div>
         <div class="para e281">The following query groups by state, then by category, then lists individual products
            and the sales associated with each.
         </div>
         <div class="programlisting e282" xml:space="preserve">
            {
            for $store in collection("stores")
            let $state := $store("state")
            group by $state
            return {
            $state : {
            for $product in collection("products")
            let $category := $product("category")
            group by $category
            return {
            $category : {
            for $sales in collection("sales")
            where $sales("store number") = $store("store number")
            and $sales("product") = $product("name")
            let $pname := $sales("product")
            group by $pname
            return $pname : sum( $sales("quantity") )
            }
            }
            }
            }
            }
            
         </div>
         <div class="para e283">Here is the result of the above query.</div>
         <div class="programlisting e284" xml:space="preserve">
            {
            "CA" : {
            "clothes" : {
            "socks" :  510
            },
            "kitchen" : {
            "broiler" : 20,
            "toaster" : 150
            }
            },
            "MA" : {
            "clothes" : {
            "shirt" : 10
            },
            "kitchen" : {
            "blender" : 250,
            "toaster" : 50
            }
            }
            }
            
         </div>
         <div class="para e285">Beyond what has been discussed in this section, JSONiq adds functions for parsing
            and serializing JSON, a syntax for JSON updates, a function library for managing objects
            and arrays, and rules for combining XML and JSON. See 
            <div class="xref e286" linkend="jsoniq"></div> for further information.
         </div>
      </div><a name="ComparingtheXSLT30MapsProposaltoJSONiqANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e287">
         <div class="title e288">Comparing the XSLT 3.0 Maps Proposal to JSONiq</div>
         <div class="para e289">The XSLT 3.0 Maps proposal and JSONiq have similar
            functionality. They each extend the XPath 3.0 type system, data
            model, and syntax, but they do it in incompatible ways. The XSL
            Working Group and XML Query Working Group expect to agree on a
            common solution that can be used in both XSLT and XQuery. This
            section explores some of the similarities and differences between
            the two proposals.
         </div>
         <div class="para e290">XSLT maps are extremely similar to JSONiq objects, but they
            do differ in a variety of ways. The following list summarizes
            these differences.
         </div>
         <div class="orderedlist e291">
            <div class="title e292">Maps</div>
            <div class="listitem e293">
               <div class="para e294">In the XSLT 3.0 maps proposal, maps are
                  functions. In JSONiq, they are structured items, similar to XML
                  nodes, with accessors defined in the data model. Both proposals
                  use function notation to find the value associated with a key;
                  in JSONiq this is done by overloading the function call syntax
                  for objects and arrays.
               </div>
               <div class="para e295">If maps are modeled as functions, the properties of maps
                  still need to be clearly described in the data model, much as
                  they are for elements and attributes, for the sake of
                  implementations. If maps are modeled as data, the language
                  description needs to explain the use of function call syntax,
                  or a different approach must be used to find the value
                  associated with a key.
               </div>
            </div>
            <div class="listitem e296">
               <div class="para e297">In the XSLT 3.0 maps proposal, a map can be
                  passed as a parameter where a function is expected. In JSONiq,
                  a map must first be wrapped in an inline function, which can be
                  passed as a parameter where a function is
                  expected.
               </div>
            </div>
            <div class="listitem e298">
               <div class="para e299">The XSLT 3.0 maps proposal makes it easy to
                  create a new copy of a map that is modified by adding an entry,
                  changing the value of an entry, or removing an entry. This is
                  not as easy in JSONiq. JSONiq provides operations to update the
                  contents of a map in place. This is not possible in XSLT (which
                  does not have updates).
               </div>
               <div class="para e300">Maps should support both models. Updates are needed for
                  conventional database operations, modified copies are needed
                  for XSLT and for XQuery implementatinos that do not provide
                  updates.
               </div>
            </div>
            <div class="listitem e301">
               <div class="para e302">In the XSLT 3.0 maps proposal, maps have no
                  identity. In JSONiq, maps have identity, but it is used only to
                  support updates. (XSLT does not have updates, and does not need
                  this functionality). To reduce complexity and simplify query
                  optimization, neither proposal allows XPath operations that
                  expose the identity of maps, such as 
                  <div class="code e303">is</div>,
                  
                  <div class="code e304">&lt;&lt;=</div>, 
                  <div class="code e305">&gt;&gt;</div>,
                  
                  <div class="code e306">union</div>, 
                  <div class="code e307">intersect</div>, and
                  
                  <div class="code e308">except</div> operators.
               </div>
            </div>
            <div class="listitem e309">
               <div class="para e310">In the XSLT 3.0 maps proposal, the value of a
                  map entry is an arbitrary sequence. In JSONiq, the value of a
                  map entry is a single item; if the value is a sequence, it is
                  placed in an array, as it would be in JSON.
               </div>
            </div>
            <div class="listitem e311">
               <div class="para e312">In the XSLT 3.0 maps proposal, a key can have
                  any atomic type, and the keys in a given map may have different
                  types, which need not be mutually comparable (e.g. one map may
                  have keys of type 
                  <div class="code e313">integer</div>, 
                  <div class="code e314">string</div>,
                  and 
                  <div class="code e315">boolean</div>). The type of a map depends on the
                  types of its keys and values at any given time. In JSONiq, a
                  key is always a string, as it is in JSON.
               </div>
            </div>
            <div class="listitem e316">
               <div class="para e317">In the XSLT 3.0 maps proposal, keys are
                  compared using the default collation, and a map can be given a
                  collation, so that keys considered equivalent in a given
                  language can be made equivalent. In JSONiq, all maps use the
                  Unicode codepoint collation to ensure that they are compared
                  the same way in all environments.
               </div>
            </div>
            <div class="listitem e318">
               <div class="para e319">JSONiq maps use a constructor syntax that
                  closely resembles the syntax of JSON maps in the same way that
                  XQuery direct element constructors resemble XML elements. The
                  XSLT 3.0 maps proposal uses a syntax more like computed element
                  constructors, introducing a constructor with a keyword, and
                  uses 
                  <div class="code e320">:=</div> as a delimiter between name/value pairs,
                  instead of the 
                  <div class="code e321">:</div> delimiter used by
                  JSON.
               </div>
            </div>
         </div>
         <div class="para e322">JSONiq has arrays, the XSLT 3.0 proposal does not. This is
            perhaps the most significant difference between the two
            proposals. The XSLT 3.0 proposal uses maps to represent JSON
            arrays; for instance, the 
            <div class="code e323">parse-json()</div> function
            converts the JSON text 
            <div class="code e324">["a", "b", null]</div> to the map
            
            <div class="code e325">map{1:="a", 2:="b", 3:=()}</div>, and does not support
            arrays in XPath per se. If a transformation creates a new copy of
            the map, removing one of the entries, the positions of the other
            entries are not adjusted; for example, consider the following
            expression:
         </div>
         <div class="programlisting e326" xml:space="preserve">
            let $j := parse-json('["a", "b", null]')
            return map:remove($j, 2)
            
         </div>
         <div class="para e327">This expression evaluates to a map with entries in position
            1 and 3, but not in 2:
         </div>
         <div class="programlisting e328" xml:space="preserve">map{1:="a", 3:=()}</div>
         <div class="para e329">JSONiq does not have this problem; deleting an item from an
            array moves all subsequent items one position to the left.
         </div>
         <div class="para e330">Beyond the differences mentioned above, the main
            differences involve the functions associated with maps and arrays
            in the two proposals.
         </div>
      </div><a name="ArraysandSequencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e331">
         <div class="title e332">Arrays and Sequences</div>
         <div class="para e333">In JSONiq, an array is a single item, which allows an array
            to be a member of an array. In the XSLT 3.0 maps proposal, a map
            is used to simulate an array. In either case, an array is an item
            that can occur in a sequence, and items are retrieved using
            function call syntax (e.g. 
            <div class="code e334">$a(1)</div>), not the subscript
            operator (e.g. 
            <div class="code e335">$a[1]</div>). Functions, operators, and
            expressions that operate on sequences all treat an array as a
            single item. For instance, the following expression returns a
            single item:
         </div>
         <div class="programlisting e336" xml:space="preserve">for $i in [1, 2, 3]
            return $i
         </div>
         <div class="para e337">The result of the above query is the array 
            <div class="code e338">[1, 2,
               3]
            </div>, not the sequence 
            <div class="code e339">1, 2, 3</div>. JSONiq provides
            the 
            <div class="code e340">members()</div> function to convert an array to a
            sequence:
         </div>
         <div class="programlisting e341" xml:space="preserve">for $i in members([1, 2, 3])
            return $i
         </div>
         <div class="para e342">The result of the above expression is 
            <div class="code e343">1, 2,
               3
            </div>.
         </div>
         <div class="para e344">In the same way, the expression 
            <div class="code e345">[1, 2][1]</div> is
            not equivalent to the expression 
            <div class="code e346">[1, 2](1)</div>. The array
            selector 
            <div class="code e347">(1)</div> returns the first member of the
            sequence, which is 
            <div class="code e348">1</div>. The positional predicate
            
            <div class="code e349">[1]</div> returns the first item of the sequence. In XPath,
            an item is identical to a singleton sequence containing that item,
            so 
            <div class="code e350">[1, 2][1]</div> is equivalent to 
            <div class="code e351">([1,
               2])[1]
            </div>, which returns the first item in the sequence:
            
            <div class="code e352">[1, 2]</div>.
         </div>
         <div class="para e353">Some people would like most functions, operators, and
            expressions to treat arrays and sequences in the same
            way. However, the semantics of sequences is fundamental to the
            design of XQuery, XPath, and XSLT, and sequences have semantics
            that are quite different from arrays. For instance, in these
            languages a single item is indistinguishable from a sequence
            containing a single item, most languages clearly distinguish an
            array containing a single item from an item. Similarly, sequences
            do not nest, and are automatically flattened. Arrays nest, and are
            not flattened. Because sequences and arrays have significantly
            different semantics, it is not clear whether it is possible to
            make functions, operators, and expressions treat them the same way
            without introducing inconsistencies. The two Working Groups should
            explore this question.
         </div>
      </div><a name="MovingForwardANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e354">
         <div class="title e355">Moving Forward</div>
         <div class="para e356">If support for JSON is added to both XSLT and XQuery,
            developers can query or transform XML, HTML, and JSON to produce
            XML, HTML, or JSON. The XSLT 3.0 Maps proposal and JSONiq are more
            similar than different, and should be combined, retaining the best
            features of each. The XSL and XML Query Working Groups have
            started this effort. This paper has attempted to sketch the
            differences between the two proposals, and suggest some ways that
            they can be combined. This will be helpful to XML developers who
            also need to process JSON, but also to XML developers who need
            simple, lightweight data structures that preserve identity, and to
            the Working Groups as we design extensions to our
            languages.
         </div>
         <div class="para e357">It is too early to say how interesting this work will become
            to the JSON community. As JSON moves beyond the browser into
            databases and enterprise data exchange, the lack of a mature
            application stack like the XML application stack becomes more
            painful, but the JSON community is extremely reluctant to embrace
            the complexity of XML Schema and other aspects of the XML
            application stack. At this point, the strongest interest seems to
            be in query languages. For the JSON-only community, JSONiq has a
            profile that removes support for XML, resulting in a much smaller,
            simpler language that supports only JSON. Standard support for a
            broader set of datatypes would also be extremely helpful for JSON
            developers, who routinely work with dates, URLs, and other
            datatypes that are not directly supported in JSON, as would a
            simple schema language.  Because of the strong desire for
            simplicity in the JSON community, it is unlikely that they will
            simply adopt the XML application stack without modification, but
            the JSON community may benefit by learning from the work that has
            already been done by their XML cousins.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e358">
         <div class="title e359">Bibliography</div>
         <div class="bibliomixed e360" xml:id="json-ff1" xreflabel="JSON: The Fat-Free Alternative to XML">
            Douglas Crockford
            
            <div class="emphasis e361" role="ital">JSON: The Fat-Free Alternative to XML.</div> 
            [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e362" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.json.org/xml.html</div>, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e363" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.json.org/fatfree.html</div>
         </div>
         <div class="bibliomixed e364" xml:id="jsont" xreflabel="JSONT">
            Stefan Goessner.
            
            <div class="emphasis e365" role="ital">JSONT: Transforming JSON.</div> 
            [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e366" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://goessner.net/articles/jsont/</div>
         </div>
         <div class="bibliomixed e367" xml:id="jsoniq" xreflabel="JSONiq">
            Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westman.
            
            <div class="emphasis e368" role="ital">JSONiq: XQuery for JSON, JSON for XQuery. (Language Specification).</div> 
            [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e369" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jsoniq.org/docs/spec/</div>
         </div>
         <div class="bibliomixed e370" xml:id="jsoniq-uc" xreflabel="JSONiq Use Cases">Jonathan Robie, Matthias Brantner, Daniela Florescu, Ghislain Fourny, Till Westman.
            
            
            <div class="emphasis e371" role="ital">JSONiq: Use Cases.</div> [online]. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e372" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jsoniq.org/docs/use-cases/</div>
         </div>
         <div class="bibliomixed e373" xml:id="xslt30" xreflabel="XSLT 3.0 July 2012 Working Draft">Michael Kay.
            
            <div class="emphasis e374" role="ital">XSL Transformations (XSLT) Version 3.0.</div> 
            W3C Working Draft 10 July 2012 [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e375" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2012/WD-xslt-30-20120710/</div>.
         </div>
         <div class="bibliomixed e376" xml:id="xquery30" xreflabel="XQuery 3.0">Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson.
            
            <div class="emphasis e377" role="ital">XQuery 3.0: An XML Query Language.</div> 
            W3C Working Draft 13 December 2011. [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e378" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery-30/</div>.
         </div>
         <div class="bibliomixed e379" xml:id="xpath30" xreflabel="XPath 3.0">Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson.
            
            <div class="emphasis e380" role="ital">XML Path Language (XPath) 3.0.</div> 
            W3C Working Draft 13 December 2011. [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e381" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-30/</div>.
         </div>
         <div class="bibliomixed e382" xml:id="xdm30" xreflabel="XDM 3.0">Norman Walsh, Anders Berglund, John Snelson.
            
            <div class="emphasis e383" role="ital">XQuery and XPath Data Model 3.0</div> 
            W3C Working Draft 13 December 2011. [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e384" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel-30/</div>.
         </div>
         <div class="bibliomixed e385" xml:id="quilt" xreflabel="Quilt">Don Chamberlin, Jonathan Robie, Daniela Florescu
            
            <div class="emphasis e386" role="ital">Quilt: An XML Query Language for Heterogeneous Data Sources</div> 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e387" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.pdf</div>.
         </div>
         <div class="bibliomixed e388" xml:id="xml.why" xreflabel="Bosak 1997">Jon Bosak. "XML, Java, and the future of the Web". [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e389" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">ftp://sunsite.unc.edu/pub/sun-info/standards/xml/why/xmlapps.html</div>
            
         </div>
         <div class="bibliomixed e390" xml:id="jclark" xreflabel="XML vs the Web">
            <div class="quote e391">XML vs the Web</div>, James Clark. [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e392" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://blog.jclark.com/2010/11/xml-vs-web_24.html</div>
         </div>
         <div class="bibliomixed e393" xml:id="normwalsh" xreflabel="Deprecating XML">
            <div class="quote e394">Deprecating XML</div>, Norman Walsh. [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e395" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://norman.walsh.name/2010/11/17/deprecatingXML</div>
         </div>
         <div class="bibliomixed e396" xml:id="timbray" xreflabel="JSON and XML">
            <div class="quote e397">JSON and XML</div>, Tim Bray. [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e398" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.tbray.org/ongoing/When/200x/2006/12/21/JSON</div>
         </div>
         <div class="bibliomixed e399" xml:id="MQL" xreflabel="Mongo Query Language">
            <div class="quote e400">Mongo Query Language: Advanced Queries.</div>
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e401" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.mongodb.org/display/DOCS/Advanced+Queries</div>. 
            <div class="quote e402">Data Types and Conventions</div>, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e403" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.mongodb.org/display/DOCS/Data+Types+and+Conventions</div>. 
            <div class="quote e404">BSON</div>, 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e405" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.mongodb.org/display/DOCS/BSON</div>.
         </div>
         <div class="bibliomixed e406" xml:id="UnQL" xreflabel="UnQL">
            <div class="quote e407">UnQL: Unstructured Query Language.</div>
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e408" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.unqlspec.org/display/UnQL/Home</div>.
         </div>
         <div class="bibliomixed e409" xml:id="HQL" xreflabel="HQL Tutorial">
            <div class="quote e410">HQL Tutorial</div>,
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e411" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://dev.wavemaker.com/wiki/bin/Dev/HqlTutorial</div>
         </div>
         <div class="bibliomixed e412" xml:id="YQL" xreflabel="Yahoo Query Language">
            <div class="quote e413">Yahoo Query Language</div>,
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e414" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://developer.yahoo.com/yql/</div>
         </div>
         <div class="bibliomixed e415" xml:id="Hive" xreflabel="Hive">
            <div class="quote e416">Hive Language Manual.</div>
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e417" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://cwiki.apache.org/confluence/display/Hive/LanguageManual</div>
         </div>
         <div class="bibliomixed e418" xml:id="Pig" xreflabel="Pig">
            <div class="quote e419">Apache Hadoop: Pig Documentation.</div>
            [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e420" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://pig.apache.org/docs/r0.7.0/index.html</div>
         </div>
         <div class="bibliomixed e421" xml:id="Jaql" xreflabel="Jaql">Kevin S. Beyer, Mohamed Eltabakh, Vuk Ercegovac, Rainer Gemulla, Carl-Christian Kanne,
            Fatma Ozcan, Andrey Balmin, Eugene J. Shekita.
            <div class="quote e422">Jaql: A Scripting Language for Large Scale Semistructured Data
               Analysis.
            </div> 
            [online]
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e423" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.mpi-inf.mpg.de/~rgemulla/publications/beyer11jaql.pdf</div>
         </div>
         <div class="bibliomixed e424" xml:id="json-schema" xreflabel="JSON Schema">K. Zyp, G. Court.
            <div class="quote e425">A JSON Media Type for Describing the Structure and Meaning of JSON Documents.</div>
            IETF Internet-Draft [online]
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e426" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://tools.ietf.org/html/draft-zyp-json-schema-03</div>
         </div>
         <div class="bibliomixed e427" xml:id="jsonpath" xreflabel="JSON Path">JSON Path. Part of MarkLogic Corona. [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e428" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://github.com/marklogic/Corona/wiki/JSON-Path</div>
         </div>
         <div class="bibliomixed e429" xml:id="rbtree" xreflabel="rbtree">John Snelson. rbtree.  [online] 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e430" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://github.com/jpcs/rbtree.xq/</div>
         </div>
         <div class="bibliomixed e431" xml:id="cosql" xreflabel="cosql">Erik Meijer, Gavin Bierman. 
            <div class="quote e432">A co-Relational Model of Data for Large Shared Data Banks.</div> ACM Queue, March 2011, volume 9, number 3. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e433" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://queue.acm.org/detail.cfm?id=1961297</div>
         </div>
      </div>
   </div>
</div>