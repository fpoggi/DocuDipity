<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TheApacheQpidXMLExchangeANCHOR" name="TheApacheQpidXMLExchangeTOC">The Apache Qpid XML Exchange</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AdvancedMessageQueueingProtocolANCHOR" name="AdvancedMessageQueueingProtocolTOC">Advanced Message Queueing Protocol</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ProgrammingAMQPApplicationswithApacheQpidANCHOR" name="ProgrammingAMQPApplicationswithApacheQpidTOC">Programming AMQP Applications with Apache Qpid</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TheApacheQpidXMLExchangeANCHOR" name="TheApacheQpidXMLExchangeTOC">The Apache Qpid XML Exchange</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ASimpleExampleANCHOR" name="ASimpleExampleTOC">A Simple Example</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AWeatherAlertANCHOR" name="AWeatherAlertTOC">A Weather Alert</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#QueryingMessagePropertiesANCHOR" name="QueryingMessagePropertiesTOC">Querying Message Properties</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XMLMessagingintheREST/SOAP/ESBLandscapeANCHOR" name="XMLMessagingintheREST/SOAP/ESBLandscapeTOC">XML Messaging in the REST/SOAP/ESB Landscape</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SummaryANCHOR" name="SummaryTOC">Summary</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">An XQuery Servlet for RESTful Data Services</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">binding</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">direct exchange</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">exchange</div>
         <div class="singletermTERMS">Emerging Technologies</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">fanout exchange</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">jonathan.robie@redhat.com</div>
         <div class="singletermTERMS">Jonathan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">message producer</div>
         <div class="singletermTERMS">message</div>
         <div class="singletermTERMS">message queue</div>
         <div class="singletermTERMS">message consumer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">routing key</div>
         <div class="singletermTERMS">Robie</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">topic exchange</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML, Java, and the future of the Web</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TheApacheQpidXMLExchangeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">The Apache Qpid XML Exchange</div>
      <div class="subtitle e2">High speed, reliable enterprise messaging using open standards and open source</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2008</div>
            <div class="confdates e6">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">XML is widely used for messaging applications.  Message-oriented
               Middleware (MOM) is a natural fit for XML messaging, but it has been
               plagued by a lack of standards. Each vendor's system uses its own
               proprietary protocols, so clients from one system generally can not
               communicate with servers from another system.  Developers who are
               drawn to XML because it is simple, open, interoperable, language
               independent, and platform independent often use REST for messaging
               because it shares the same virtues. When XML developers need
               high-performance, guaranteed delivery, transactions, security,
               management, asynchronous notification, or direct support for common
               messaging paradigms like point-to-point, broadcast, request/response, and publish/subscribe,
               they have been forced to sacrifice some of the virtues that drew them
               to XML in the first place.  Java JMS is an API, defined only for Java,
               and it does not define a wire protocol that would allow applications
               running on different platforms or written in different languages to
               interoperate. SOAP and Web Services offer interoperability if the same
               underlying protocols are used and if the same WSI-protocol is used by
               all parties, but at the cost of more complexity than a MOM system. And
               as the basic components of enterprise messaging have been added piece
               by piece to the original specifications, Web Services have become
               complex, defined in a large number of overlapping specifications,
               without a coherent and simple architecture.
               
            </div>
            <div class="para e9">The new Advanced Message Queueing Protocol (AMQP) is an open, language
               independent, platform  independent standard for  enterprise messaging.
               It provides  precisely the coherent  and simple architecture  that has
               been missing for sophisticated  messaging applications.
               Red Hat Enterprise MRG includes a multi-language, multi-platform, open
               source implementation of AMQP. We develop the messaging component as
               part of the upstream Apache Qpid project. In order to meet the needs
               of XML messaging systems, we contributed the Apache Qpid XML Exchange,
               which provides XQuery-based routing for XML content and message
               properties.  Together, AMQP, Apache Qpid, and the Qpid XML Exchange
               provide a solid foundation for mission critical XML messaging
               applications.
               
            </div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Jonathan</div>
               <div class="surname e13">Robie</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">Jonathan Robie designed and implemented the Apache Qpid XML
                  Exchange. He is a member of the Emerging Technologies team at Red Hat.
                  Jonathan is one of the inventors of XQuery, and is an editor of XQuery
                  1.1 and several other XQuery specifications. He received an Infoworld
                  Innovator 2005 award for his work on XQuery.
               </div>
               <div class="para e16">Before joining Red Hat, Jonathan was the Program Manager for
                  DataDirect XQuery, and he has also worked on the architectural team
                  for three XML databases: Software AG's Tamino, Texcel, and POET's CMS.
                  He has also been an editor for specifications on the W3C XML Schema
                  and Document Object Model Working Groups.
               </div>
            </div>
            <div class="email e17">jonathan.robie@redhat.com</div>
            <div class="affiliation e18">
               <div class="jobtitle e19">Emerging Technologies</div>
               <div class="orgname e20">Red Hat</div>
            </div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright © 2008 by the author.  Used with
               permission.
            </div>
         </div>
      </div>
      <div class="para e23">Modern software systems are often composed of many separate
         programs working together. In simple cases, there may be a few
         programs running on one computer; in more ambitious systems, many
         programs may be running on various hardware and operating systems on
         machines scattered across the world.
         
         These programs may be developed in a variety of languages, including
         both traditional programming languages and scripting languages, and
         they may include legacy programs written long before there was a need
         to communicate with other programs.
         
         Programs may be distributed across an organization, or span the
         boundaries of an organization to include key trading partners,
         suppliers, and consumers. These programs need to share data, and many
         of these programs represent that data as XML. From the very beginning,
         XML was designed to make it easier for programs to exchange data,
         independent of the languages, platforms, and underlying systems 
         <div class="xref e24" linkend="Bosak"></div>, and it has been widely used as a way to exchange
         data with existing proprietary systems.  But XML defines only the data
         format, not the mechanism for exchanging documents among
         programs.
      </div>
      <div class="para e25">In many systems, the requirement is to support message transfer,
         allowing one program to send a message that can be received by one or
         more other programs. These messages may be simple notifications, or
         part of a request/response, publish/subscribe, or similar
         pattern. Message-oriented middleware (MOM) provides direct support for
         sending and receiving messages, hiding the details of network
         communication, and providing guaranteed delivery, high performance,
         transactions, and a variety of other features.
         Most MOM systems support asynchronous messaging between programs,
         typically sending messages to message queues that store a message
         until it is retrieved, even if the receiving program is busy or not
         connected. These systems are often described using an email analogy -
         a program can address a message and send it, or receive the messages
         addressed to it.
         Other MOM systems use multicast or broadcast messaging instead of or
         in addition to asynchronous messaging.
         
      </div>
      <div class="para e26">Unfortunately, message-oriented Middleware has been plagued by a
         lack of standards. Each vendor's system uses its own proprietary
         protocols, so clients from one system generally can not communicate
         with servers from another system. For Java programs, most systems
         support the Java JMS API, but this is only an API, and does not define
         a standard protocol that would allow communication across systems.
         
         The Advanced Message Queuing Protocol (AMQP) 
         <div class="xref e27" linkend="AMQP"></div>
         was developed by a consortium of companies 
         <div class="popupBox e28">
            <div class="popupLabel" onmouseover="$('#d1e50').show('1000');" onmouseout="$('#d1e50').hide('1000');">[ footnote ]</div>
            <div id="d1e50" style="display: none;">
               <div class="footnote">
                  <div class="para e29">Cisco
                     Systems, Credit Suisse, Deutsche Börse Systems, Envoy Technologies,
                     Inc., Goldman Sachs, IONA Technologies PLC, iMatix Corporation sprl.,
                     JPMorgan Chase Bank Inc. N.A, Novell, Rabbit Technologies Ltd., Red
                     Hat, Inc., TWIST Process Innovations ltd, and 29West
                     Inc.
                  </div>
               </div>
            </div>
         </div> to be an open standard for enterprise level
         messaging. It is licensed to allow implementation on a perpetual,
         worldwide, royalty-free basis, and will be submitted to a recognized
         standards body.
         <div class="popupBox e30">
            <div class="popupLabel" onmouseover="$('#d1e54').show('1000');" onmouseout="$('#d1e54').hide('1000');">[ footnote ]</div>
            <div id="d1e54" style="display: none;">
               <div class="footnote">
                  <div class="para e31">At the time of writing, it is not
                     possible to be more specific about the standards
                     submission.
                  </div>
               </div>
            </div>
         </div>
         
         AMQP supports most common messaging idioms, including
         request/response, point-to-point, publish/subscribe, and broadcast. It
         has security, reliability, transactions, and other basic enterprise
         messaging features built in.
         
         AMQP defines a network protocol, which specifies what client
         applications and message servers must send over the wire to
         interoperate with each other. It also defines a protocol model, which
         specifies the semantics an AMQP implementation must obey to be
         interoperable with other implementations.  AMQP is already being used
         in production systems, where it is serving very high message volumes;
         for example, one bank has a worldwide deployment that delivers over
         100 million messages per day in a 7 hour trading window in its Tokyo
         hub.
      </div>
      <div class="para e32">Red Hat Enterprise MRG 
         <div class="xref e33" linkend="MRG"></div> includes a multi-language,
         multi-platform implementation of AMQP that provides enterprise level
         messaging with guaranteed delivery, transaction management, queuing,
         distribution, security, management and heterogeneous multi-platform
         support. Client APIs include C++, Java, Python and C# for .NET. A JMS
         API is also provided for JMS environments.  We develop the AMQP
         implementation as part of the upstream Apache Qpid project 
         <div class="xref e34" linkend="Qpid"></div>.
         
      </div>
      <div class="para e35">The Apache Qpid XML Exchange is a messaging exchange
         specifically designed for reliable, high performance XML messaging. In
         the XML Exchange, message routing is specified in the broker (not in
         the application), using XQuery, based on the content of XML messages,
         message properties, or both. Queries can be as simple or as complex as
         needed.
         
         Clients can determine which documents they are interested in without
         changing the applications that publish XML documents.
         
         The Qpid XML Exchange was developed by Red Hat and contributed to the
         Apache Qpid project.
         
      </div>
      <div class="para e36">
         This article discusses the AMQP protocol, shows how to write a basic
         messaging application in Apache Qpid, then shows how to write
         messaging applications using the Qpid XML Exchange, using XQuery to
         specify which messages should be routed to a queue. Finally, we make a
         brief comparison between the technologies presented in this paper and
         alternative technologies like REST, SOAP and Web Services, Java JMS,
         ESB, and ebXML.
         
      </div><a name="AdvancedMessageQueueingProtocolANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e37">
         <div class="title e38">Advanced Message Queueing Protocol</div>
         <div class="subtitle e39">The AMQP Model</div>
         <div class="para e40">In the AMQP model, message producers write to exchanges, exchanges
            route messages to queues, and message consumers read from queues. AMQP
            allows modular architectures that cleanly separate the concerns of
            each module; for instance, a message producer can write to an exchange
            without knowing which queues its messages will be routed to, and a
            message consumer can read from its queues without knowing anything
            about the message producer or the exchange to which the message was
            written.
            
         </div>
         <div class="para e41">Here are the basic components of the AMQP model:</div>
         <div class="itemizedlist e42">
            <div class="listitem e43">
               <div class="para e44">A 
                  <div class="emphasis e45" role="ital">message producer</div> is a program that
                  writes messages to an exchange. To do this, it creates a
                  
                  <div class="emphasis e46" role="ital">message</div>, fills it with content, gives the
                  message a 
                  <div class="emphasis e47" role="ital">routing key</div>
                  <div class="popupBox e48">
                     <div class="popupLabel" onmouseover="$('#d1e89').show('1000');" onmouseout="$('#d1e89').hide('1000');">[ footnote ]</div>
                     <div id="d1e89" style="display: none;">
                        <div class="footnote">
                           <div class="para e49">For one
                              kind of exchange, the fanout exchange, a routing key is
                              optional
                           </div>
                        </div>
                     </div>
                  </div>, and sends it to an exchange. The routing
                  key is simply a string that the exchange can use to determine to which
                  queues the message should be delivered
                  <div class="popupBox e50">
                     <div class="popupLabel" onmouseover="$('#d1e93').show('1000');" onmouseout="$('#d1e93').hide('1000');">[ footnote ]</div>
                     <div id="d1e93" style="display: none;">
                        <div class="footnote">
                           <div class="para e51">The way the
                              routing key is used depends on the exchange type, and is discussed
                              later in this chapter
                           </div>
                        </div>
                     </div>
                  </div>. 
               </div>
            </div>
            <div class="listitem e52">
               <div class="para e53">An 
                  <div class="emphasis e54" role="ital">exchange</div> accepts messages from message producers and routes them to
                  message queues if the message meets the criteria expressed in a
                  binding.
               </div>
            </div>
            <div class="listitem e55">
               <div class="para e56">A 
                  <div class="emphasis e57" role="ital">binding</div> defines the relationship between an exchange and a
                  message queue, specifying which messages should be routed to a given
                  queue. For instance, a binding might state that all messages with a
                  given routing key should be sent to a particular queue. If a queue is
                  not bound to an exchange, it does not receive any messages from that
                  exchange.
               </div>
            </div>
            <div class="listitem e58">
               <div class="para e59">A 
                  <div class="emphasis e60" role="ital">message queue</div> holds messages and delivers them to the message
                  consumers that subscribe to the queue. A message queue may be durable,
                  which means that the queue is never lost; even if the messaging broker
                  were to suffer a hardware failure, the queue would be restored when
                  the broker is restarted. A message queue may be exclusive, which means
                  only one client can use it. A message queue may also be auto-delete,
                  which means that the queue will disappear from the server when the
                  last client unsubscribes from the queue.
               </div>
            </div>
            <div class="listitem e61">
               <div class="para e62">A 
                  <div class="emphasis e63" role="ital">message consumer</div> is a program
                  that reads messages from a message queue. A message consumer can
                  create, subscribe to, share, use, or destroy message queues and their
                  bindings (as long as it has have permission to do so).
                  
               </div>
            </div>
         </div>
         <div class="para e64">Before delivering a message, the message producer can influence
            message handling characteristics by setting various message properties
            in the message; for instance, one property determines whether the
            message is durable. If a broker supports persistence, it guarantees
            durable messages are never lost; even if the messaging broker were to
            suffer a hardware failure, all durable messages would be delivered
            when the broker is restarted. Another property can be used to specify
            message priority; the broker gives higher priority messages precedence
            over lower priority messages.  A message producer can use transactions
            to ensure that a group of messages are all received. In a transaction,
            messages and acknowledgements acknowledgements are batched together,
            and all messages in the transaction succeed or fail as a unit.
         </div>
         <div class="para e65">The exact way that a message is routed depends on the exchange
            type. Here are the main exchange types in AMQP:
         </div>
         <div class="itemizedlist e66">
            <div class="listitem e67">
               <div class="para e68">A 
                  <div class="emphasis e69" role="ital">fanout exchange</div> routes messages to every queue
                  bound to the exchange, ignoring the routing key.
               </div>
            </div>
            <div class="listitem e70">
               <div class="para e71">A 
                  <div class="emphasis e72" role="ital">direct exchange</div> routes a message only if
                  a queue's binding key is the same as the message's routing key.
               </div>
            </div>
            <div class="listitem e73">
               <div class="para e74">A 
                  <div class="emphasis e75" role="ital">topic exchange</div> is similar to a Direct exchange, but it supports
                  multipart keys that contain multiple words separated by the “.”
                  delimiter; for instance, a message producer can create messages with
                  routing keys like usa.news, usa.weather, europe.news, and
                  europe.weather. Binding keys can include wildcard characters: a “#”
                  matches one or more words, a “*” matches a single word. Typical
                  bindings use binding keys like #.news (all news items), usa.# (all
                  items in the USA), or usa.weather (all usa weather items).
               </div>
            </div>
         </div>
         <div class="para e76">Any of the standard exchange types we have discussed in this
            paragraph can be used for exchanging any kind of data, including
            XML. Routing decisions are based on the exchange type and the routing
            key only; none of these exhange types allow routing based on the
            content of a message, and none has any direct support for XML.
            
            The XML Exchange, which is the subject of this paper, is a custom
            exchange type that lets programs use XQuery to specify routing for XML
            messages. Before we discuss the XML Exchange, we will look at the code
            needed for a simple and conventional AMQP program written in Python.
            
         </div>
      </div><a name="ProgrammingAMQPApplicationswithApacheQpidANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e77">
         <div class="title e78">Programming AMQP Applications with Apache Qpid</div>
         <div class="para e79">
            This section shows how to write a basic AMQP application using Apache
            Qpid.  The examples in this section are written in Python and use the
            direct exchange.  Like the other native AMQP exchanges, the direct
            exchange works well for sending XML messages as long as routing
            decisions are not made based on the content of the messages.
            Applications that need to do routing based on the XML content of a
            message use the XML exchange, which is presented in the following
            section.
            
         </div>
         <div class="para e80">This application is composed of two programs:</div>
         <div class="itemizedlist e81">
            <div class="listitem e82">
               <div class="para e83">A 
                  <div class="emphasis e84" role="ital">message producer</div> that sends
                  messages to an exchange (which routes messages to the appropriate
                  message queue).
               </div>
            </div>
            <div class="listitem e85">
               <div class="para e86">A 
                  <div class="emphasis e87" role="ital">message consumer</div> that creates
                  a message queue, binds the queue to the exchange, then reads messages
                  that are sent to its queue.
               </div>
            </div>
         </div>
         <div class="para e88">
            In this application, messages are published to the direct exchange using the key
            "routing_key". The first step is to establish a binding on the server to route
            these messages to a queue called "message_queue":
            
         </div>
         <div class="programlisting e89" xml:space="preserve">
            session.queue_declare(queue="message_queue")
            session.exchange_bind(exchange="amq.direct", queue="message_queue", 
            routing_key="routing_key")
            
         </div>
         <div class="para e90">Before these lines can be invoked, the client must log in to the
            server and create a session. Here is a complete program that uses the
            above two lines to declare a queue:
         </div>
         <div class="programlisting e91" xml:space="preserve">import qpid
            from qpid.client import Client
            from qpid.content import Content
            from qpid.queue import Empty
            
            #----- Initialization ----------------------------
            
            #  Set parameters for login
            
            host="127.0.0.1"
            port=5672
            amqp_spec="/usr/share/amqp/amqp.0-10-preview.xml"
            user="guest"
            password="guest"
            
            #  Create a client and log in to the server.
            
            client = Client(host, port, qpid.spec.load(amqp_spec))
            client.start({"LOGIN": user, "PASSWORD": password})
            
            session = client.session()
            session.session_open()
            
            #----- Main Body of Program-----------------------
            
            session.queue_declare(queue="message_queue")
            session.exchange_bind(exchange="amq.direct", queue="message_queue", 
            routing_key="routing_key")
            
            #----- Cleanup -----------------------------------
            
            # Close the session before exiting so there are no open threads.
            
            session.session_close()
            
         </div>
         <div class="para e92">The following code publishes 10 messages to the direct exchange
            using "routing_key" as the routing key. To create a full program,
            simply replace the two lines in the main body of the previous example
            with the following lines:
         </div>
         <div class="programlisting e93" xml:space="preserve">
            for i in range(10):
            message = Content("message " + str(i))
            message["routing_key"] = "routing_key"
            session.message_transfer(destination="amq.direct", content=message)
            
         </div>
         <div class="para e94">Now let's write a program that reads messages from the message queue.
            First, the client creates a local queue into which messages will
            be read from the server, subscribes to the message queue on the
            server, and activates the local queue to start receiving messages. It then reads messages
            off the queue and prints them::
         </div>
         <div class="programlisting e95" xml:space="preserve">
            local_queue_name = "local_queue"
            local_queue = session.incoming(local_queue_name)
            
            session.message_subscribe(queue="message_queue", destination=local_queue_name)
            local_queue.start()
            
            final = "That's all, folks!"   # In a message body, signals the last message
            content = ""           # Content of the last message read
            
            message = None
            while content != final:
            message = local_queue.get(timeout=10)
            content = message.body
            session.message_accept(RangedSet(message.id)) # acknowledge message receipt
            print content
            
         </div>
         <div class="para e96">This section introduced basic Apache Qpid messaging using a
            direct exchange in python. For a more complete tutorial on Apache
            Qpid, including point-to-point, broadcast, request-response, and
            publish-subscribe applications, with persistence and transactions, in
            Java JMS, C++, and Python, see the MRG Messaging Tutorial 
            <div class="xref e97" linkend="MRGTutorial"></div>.
            
         </div>
      </div><a name="TheApacheQpidXMLExchangeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e98">
         <div class="title e99">The Apache Qpid XML Exchange</div>
         <div class="para e100">
            The Qpid XML Exchange adds two basic capabilities to Apache Qpid: it
            can route XML messages based on message content, and it can do more
            sophisticated queries based on message properties. In both cases,
            queries are expressed in XQuery.
         </div>
         <div class="para e101">For a Qpid programmer, the main difference between an XML
            Exchange and any other exchange is the message binding. In the XML
            Exchange, an XQuery is provided to indicate which documents should be
            routed for a given binding.
         </div><a name="ASimpleExampleANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e102">
            <div class="title e103">A Simple Example</div>
            <div class="para e104">The following code declares an XML
               exchange and uses an XQuery to specify that all messages with
               odd-numbered ids should be routed to a queue named "message_queue":
            </div>
            <div class="programlisting e105" xml:space="preserve">
               session.exchange_declare(exchange="xml", type="xml")
               session.queue_declare(queue="message_queue")
               
               binding = {}
               binding["xquery"] = "./message/id mod 2 = 1"
               
               session.exchange_bind(exchange="xml", queue="message_queue", 
               routing_key="routing_key", args=binding)
               
            </div>
            <div class="para e106">A publisher can write XML messages to this message queue with no
               knowledge of the query, it needs only the name of the XML exchange so
               it can specify the destination:
            </div>
            <div class="programlisting e107" xml:space="preserve">
               for i in range(10):
               message = Content("&lt;message&gt;&lt;id&gt;" + i + "&lt;/id&gt;&lt;/message&gt;"))
               message["routing_key"] = "routing_key"
               session.message_transfer(destination="xml", content=message)
               
            </div>
            <div class="para e108">A consumer needs no knowledge of the publisher or the XML
               Exchange, it simply reads messages from its queue, as shown in the
               previous section.
            </div>
         </div><a name="AWeatherAlertANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e109">
            <div class="title e110">A Weather Alert</div>
            <div class="subtitle e111">Time to go Sailing!</div>
            <div class="para e112">Now let's explore an application that uses the XML Exchange in a
               publish/subscribe application using weather observations from the
               National Oceanic and Atmospheric Administration's National Weather
               Service 
               <div class="xref e113" linkend="NWS"></div>.  In this application, each
               individual can set up a persistent queue, to which alerts are sent,
               and identify weather conditions that should trigger an alert. For
               instance, I like to sail small sailboats, and I live in Durham, NC, so
               I might ask for a weather alert whenever it is really good weather for
               sailing.
            </div>
            <div class="para e114">This example is composed of two programs:</div>
            <div class="itemizedlist e115">
               <div class="listitem e116">
                  <div class="para e117">A 
                     <div class="emphasis e118" role="ital">message producer</div> that sends
                     weather notifications in XML to an exchange (which routes messages to
                     the appropriate message queues).
                  </div>
               </div>
               <div class="listitem e119">
                  <div class="para e120">A 
                     <div class="emphasis e121" role="ital">message consumer</div> that creates
                     a message queue, binds the queue to the XML exchange using an XQuery
                     to indicate messages it wants to receive, then reads messages that are
                     sent to its queue.
                  </div>
               </div>
            </div>
            <div class="para e122">In this application, a producer posts messages to an XML
               exchange named "weather" in the National Weather Service's standard
               XML format. Here is one message in that format:
            </div>
            <div class="programlisting e123" xml:space="preserve">
               &lt;current_observation version="1.0"
               xsi:noNamespaceSchemaLocation="http://www.weather.gov/data/current_obscurrent_observation.xsd"&gt;
               &lt;credit&gt;NOAA's National Weather Service&lt;/credit&gt;
               &lt;credit_URL&gt;http://weather.gov/&lt;/credit_URL&gt;
               &lt;image&gt;
               &lt;url&gt;http://weather.gov/images/xml_logo.gif&lt;/url&gt;
               &lt;title&gt;NOAA's National Weather Service&lt;/title&gt;
               &lt;link&gt;http://weather.gov&lt;/link&gt;
               &lt;/image&gt;
               &lt;suggested_pickup&gt;15 minutes after the hour&lt;/suggested_pickup&gt;
               &lt;suggested_pickup_period&gt;60&lt;/suggested_pickup_period&gt;
               &lt;location&gt;Raleigh-Durham International Airport, NC&lt;/location&gt;
               &lt;station_id&gt;KRDU&lt;/station_id&gt;
               &lt;latitude&gt;35.88&lt;/latitude&gt;
               &lt;longitude&gt;-78.78&lt;/longitude&gt;
               &lt;observation_time&gt;Last Updated on Apr 21, 2:51 pm EDT&lt;/observation_time&gt;
               &lt;observation_time_rfc822&gt;Mon, 21 Apr 2008 14:51:00 -0400 EDT&lt;/observation_time_rfc822&gt;
               &lt;weather&gt;Mostly Cloudy&lt;/weather&gt;
               &lt;temperature_string&gt;67 F (19 C)&lt;/temperature_string&gt;
               &lt;temp_f&gt;67&lt;/temp_f&gt;
               &lt;temp_c&gt;19&lt;/temp_c&gt;
               &lt;relative_humidity&gt;57&lt;/relative_humidity&gt;
               &lt;wind_string&gt;Variable at 7 MPH&lt;/wind_string&gt;
               &lt;wind_dir&gt;Variable&lt;/wind_dir&gt;
               &lt;wind_degrees&gt;999&lt;/wind_degrees&gt;
               &lt;wind_mph&gt;6.9&lt;/wind_mph&gt;
               &lt;wind_gust_mph&gt;NA&lt;/wind_gust_mph&gt;
               &lt;pressure_string&gt;29.95" (1014.0 mb)&lt;/pressure_string&gt;
               &lt;pressure_mb&gt;1014.0&lt;/pressure_mb&gt;
               &lt;pressure_in&gt;29.95&lt;/pressure_in&gt;
               &lt;dewpoint_string&gt;51 F (11 C)&lt;/dewpoint_string&gt;
               &lt;dewpoint_f&gt;51&lt;/dewpoint_f&gt;
               &lt;dewpoint_c&gt;11&lt;/dewpoint_c&gt;
               &lt;heat_index_string&gt;NA&lt;/heat_index_string&gt;
               &lt;heat_index_f&gt;NA&lt;/heat_index_f&gt;
               &lt;heat_index_c&gt;NA&lt;/heat_index_c&gt;
               &lt;windchill_string&gt;NA&lt;/windchill_string&gt;
               &lt;windchill_f&gt;NA&lt;/windchill_f&gt;
               &lt;windchill_c&gt;NA&lt;/windchill_c&gt;
               &lt;visibility_mi&gt;10.00&lt;/visibility_mi&gt;
               &lt;icon_url_base&gt;http://weather.gov/weather/images/fcicons/&lt;/icon_url_base&gt;
               &lt;icon_url_name&gt;bkn.jpg&lt;/icon_url_name&gt;
               &lt;two_day_history_url&gt;http://www.weather.gov/data/obhistory/KRDU.html&lt;/two_day_history_url&gt;
               &lt;ob_url&gt;http://www.nws.noaa.gov/data/METAR/KRDU.1.txt&lt;/ob_url&gt;
               &lt;disclaimer_url&gt;http://weather.gov/disclaimer.html&lt;/disclaimer_url&gt;
               &lt;copyright_url&gt;http://weather.gov/disclaimer.html&lt;/copyright_url&gt;
               &lt;privacy_policy_url&gt;http://weather.gov/notice.html&lt;/privacy_policy_url&gt;
               &lt;/current_observation&gt;
               
            </div>
            <div class="para e124">The message consumer is an application that allows me to
               subscribe to this weather feed, specifying conditions for my alerts
               based on the data available in such a message. On my little sailboats,
               I especially like to sail when the local weather is at least 60
               degrees Fahrenheit, the wind is between 7 and 15 miles per hour, and
               the temperature is at least 10 degrees above the dewpoint (so it is
               unlikely to rain). The application would have a GUI to allow me to
               specify these kinds of conditions, and would generate an XQuery for
               the XML binding. Here is a query that expresses these
               conditions:
            </div>
            <div class="programlisting e125" xml:space="preserve">
               let $obs := ./current_observation
               return $obs/station_id = 'KRDU'
               and $obs/wind_mph &gt;= 7
               and $obs/wind_mph &lt;= 20
               and $obs/temp_f &gt; 60
               and $obs/temp_f - $obs/dewpoint_f &gt;= 10
               
            </div>
            <div class="para e126">Of course, this is very individual. My friend Jim has a 40 foot
               sailboat in Clearwater, and his sailboat just starts to get moving at
               speeds that would be very challenging in my little sailboat. So he
               might specify very different values for wind speeds. And I have other
               friends whose weather-related interests have nothing to do with
               sailing - perhaps someone would simply like an alert when it looks
               like it will rain. Each of us can declare an exclusive queue with a
               binding that expresses which messages we are interested in, as
               illustrated in the following code:
            </div>
            <div class="programlisting e127" xml:space="preserve">
               # Use a UUID as the name of the queue
               # to guarantee a unique queue name
               uuid = uuid()
               session.queue_declare(queue=uuid, exclusive=True)
               
               binding = {}
               binding["xquery"] = """
               let $obs := ./current_observation
               return $obs/station_id = 'KRDU'
               and $obs/wind_mph &gt;= 7
               and $obs/wind_mph &lt;= 20
               and $obs/temp_f &gt; 60
               and $obs/temp_f - $obs/dewpoint_f &gt;= 10"""
               
               session.exchange_bind(exchange="xml", queue="message_queue", 
               routing_key="routing_key", args=binding)
               
            </div>
         </div><a name="QueryingMessagePropertiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e128">
            <div class="title e129">Querying Message Properties</div>
            <div class="para e130">When the data used by clients is flat, and clients are
               interested in the same properties, a message producer can bind these
               properties to a message so they can be accessed without parsing the
               message content, which may be faster, since the message content need
               not be parsed. When used in this way, the XML Exchange operates much
               like Java JMS selectors.
            </div>
            <div class="para e131">In the XQuery used for binding, message properties are bound as
               external variables of type string. The query must declare these
               external variables before using them.  The XML Exchange binds the
               message properties to the corresponding variables before the query is
               invoked. Here is the query from the previous example expressed using
               message properties instead of XML message content:
            </div>
            <div class="programlisting e132" xml:space="preserve">
               declare variable $station_id as xs:string external;
               declare variable $wind_mph as xs:string external;
               declare variable $temp_mph as xs:string external;
               $station_id = 'KRDU'
               and xs:decimal($wind_mph) &gt;= 7
               and xs:decimal($wind_mph) &lt;= 20
               and xs:decimal($temp_f) &gt; 60
               and xs:decimal($temp_f) - xs:decimal($dewpoint_f) &gt;= 10
               
            </div>
            <div class="para e133">Properties and XML content can both be used in the same
               query. In the following query, the station identifier is read from the
               message content, but the wind speed and temperature are read from
               message properties:
            </div>
            <div class="programlisting e134" xml:space="preserve">
               declare variable $wind_mph as xs:string external;
               declare variable $temp_mph as xs:string external;
               ./current_observation/station_id = 'KRDU'
               and xs:decimal($wind_mph) &gt;= 7
               and xs:decimal($wind_mph) &lt;= 20
               and xs:decimal($temp_f) &gt; 60
               and xs:decimal($temp_f) - xs:decimal($dewpoint_f) &gt;= 10
               
            </div>
         </div><a name="XMLMessagingintheREST/SOAP/ESBLandscapeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e135">
            <div class="title e136">XML Messaging in the REST/SOAP/ESB Landscape</div>
            <div class="para e137">XML applications already have a bewildering number of choices
               for exchanging data. Many applications already use REST 
               <div class="xref e138" linkend="Fielding"></div>, SOAP 
               <div class="xref e139" linkend="Soap1"></div> 
               <div class="xref e140" linkend="Soap2"></div>, ebXML 
               <div class="xref e141" linkend="ebXML"></div>, Enterprise Service
               Buses 
               <div class="xref e142" linkend="ESBWiki"></div>, Java JMS Messaging 
               <div class="xref e143" linkend="JMS"></div>, or any one of the dozens of other available choices
               now available. Each of these sytems has advantages and disadvantages,
               and a thorough comparison to these systems is beyond the scope of this
               paper. This section attempts to point out some of the fundamental
               design characteristics of AMQP and the XML Exchange to make it easier
               for readers to make their own comparisons.
            </div>
            <div class="para e144">Like REST, AMQP is simple
               <div class="popupBox e145">
                  <div class="popupLabel" onmouseover="$('#d1e277').show('1000');" onmouseout="$('#d1e277').hide('1000');">[ footnote ]</div>
                  <div id="d1e277" style="display: none;">
                     <div class="footnote">
                        <div class="para e146">Though not as simple as
                           REST!
                        </div>
                     </div>
                  </div>
               </div>, open, platform independent, and programming
               language independent. However, REST is designed only for client/server
               request/response interaction, and because it relies on HTTP, it is a
               synchronous protocol. AMQP supports request/response together with
               other common patterns such as point-to-point, broadcast, and
               publish-subscribe, which allows it to define communication among
               messaging clients, not just communication to a server. AMQP is an
               asynchronous protocol, which is much more suitable for
               high-performance systems, though synchronous patterns are also
               supported in the Qpid APis.
            </div>
            <div class="para e147">Java JMS provides broad support for these kinds of messaging
               patterns, but it is a Java API, with no support for other languages,
               and it does not define an interoperable protocol, allowing each
               implementation choose how to exchange data. As a result, Java JMS does
               not provide interoperability across languages or across messaging
               systems.
            </div>
            <div class="para e148">SOAP and Web Services support many of the same messaging
               patterns as AMQP, are language and platform independent, and can also
               be used to achieve interoperable messaging if all parties agree on the
               communication protocol and on a given WS-I profile. AMQP is smaller in
               scope and more narrowly focused on messaging per se; it is designed to
               be as simple as possible while still providing robust and complete
               support for messaging. An AMQP server would probably be an excellent
               basis for implementing a SOAP server. Unlike SOAP, AMQP message
               headers and basic routing information are not contained in XML. This
               allows more efficient processing, since XML parsing is slow compared
               to the speed with which routing decisions are made in high-performance
               messaging systems, and it also cleanly separates message content from
               envelope information.
               <div class="popupBox e149">
                  <div class="popupLabel" onmouseover="$('#d1e285').show('1000');" onmouseout="$('#d1e285').hide('1000');">[ footnote ]</div>
                  <div id="d1e285" style="display: none;">
                     <div class="footnote">
                        <div class="para e150">Message properties can be read
                           from messages in applications that want this information. An
                           application could easily model them as XML.
                        </div>
                     </div>
                  </div>
               </div> Another
               difference is that XML is just one of the formats supported by AMQP,
               and messages can be in any desired format (but the XML Exchange was
               designed for XML messages). Another advantage of AMQP is that there is
               just one specification, and only one way to claim conformance, so
               interoperability does not require agreeing on specific protocols. This
               is simpler and more interoperable than the SOAP family of
               specifications 
               <div class="xref e151" linkend="WSActivity"></div> 
               <div class="xref e152" linkend="Oasis"></div>
               
               <div class="xref e153" linkend="WS-I"></div>, which specify basic messaging functionality in
               a variety of unrelated and overlapping specifications, from different
               organizations, while other organizations specify profiles that can be
               used for interoperability.
            </div>
            <div class="para e154">Much of what was said in the previous paragraph also applies to
               ebXML. AMQP would be an excellent technology for implementing ebXML
               messaging, and can be used as a bridging technology between ebXML
               systems and other systems. But AMQP does not attempt to address
               anything beyond messaging.
            </div>
            <div class="para e155">Similarly, an Enterprise Service Bus generally refers to a more
               complex system build on top of an enterprise messaging system. AMQP is
               such an enterprise messaging system. But XML-based routing is a
               prominent feature in some ESB systems, and the XML Exchange provides
               this feature, inegrated into an AMQP server.
            </div>
         </div><a name="SummaryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e156">
            <div class="title e157">Summary</div>
            <div class="para e158">AMQP provides a coherent, simple architecture for high
               performance, reliable messaging that is interoperable across
               implementations and supports most common messaging paradigms. Apache
               Qpid is a multi-platform, multi-language implementation of AMQP.
               
               The Qpid XML Exchange provides XML-based routing in an AMQP server,
               using XQuery to express routing criteria based on message content and
               message properties.
               
               Together, they provide the simplicity of REST
               together with the broad support for enterprise messaging that SOAP
               aspires to achieve. They provide a solid foundation for mission
               critical XML messaging applications, and vastly simplify the task of
               writing XML messaging software.
            </div>
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e159">
         <div class="title e160">Bibliography</div>
         <div class="bibliomixed e161" xml:id="Bosak">
            
            <div class="quote e162">XML, Java, and the future of the Web</div> Jon Bosak, Sun Microsystems. Last revised 1997.03.10.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e163" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ibiblio.org/pub/sun-info/standards/xml/why/xmlapps.htm</div>
            
         </div>
         <div class="bibliomixed e164" xml:id="Fielding">
            
            <div class="quote e165">Architectural Styles and the Design of Network-based Software
               Architectures
            </div>. Roy Thomas Fielding, 2000. DISSERTATION submitted in partial satisfaction of the
            requirements for the degree of DOCTOR OF PHILOSOPHY
            in Information and Computer Science. University of California, Irvine.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e166" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</div>
            
         </div>
         <div class="bibliomixed e167" xml:id="Vinoski">
            "Advanced Message Queuing Protocol", Steve Vinoski. IEEE Internet Computing, vol.
            10, no. 6, 2006, pp. 87-89.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e168" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://steve.vinoski.net/pdf/IEEE-Advanced_Message_Queuing_Protocol.pdf</div>. doi: 
            <div class="biblioid doi e169">10.1109/MIC.2006.116</div>
            
         </div>
         <div class="bibliomixed e170" xml:id="AMQP">
            AMQP: A General-Purpose Middleware Standard.  Copyright Cisco Systems,
            Credit Suisse, Deutsche Börse Systems, Envoy Technologies,
            Inc.,Goldman Sachs, IONA Technologies PLC, iMatix Corporation
            sprl., JPMorgan Chase Bank Inc. N.A, Novell, Rabbit Technologies Ltd.,
            Red Hat, Inc., TWIST Process Innovations ltd, and 29West Inc. 2006.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e171" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://jira.amqp.org/confluence/download/attachments/720900/amqp.0-10.pdf?version=1</div>
            
         </div>
         <div class="bibliomixed e172" xml:id="Qpid">
            Apache Qpid Project.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e173" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://cwiki.apache.org/qpid/</div>
            
         </div>
         <div class="bibliomixed e174" xml:id="MRG">
            Red Hat Enterprise MRG. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e175" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.redhat.com/mrg/</div>.
            
         </div>
         <div class="bibliomixed e176" xml:id="MRGTutorial">
            Red Hat Enterprise MRG: MRG Messaging Tutorial. Available from 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e177" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.redhat.com/mrg/resources/</div>.
            
         </div>
         <div class="bibliomixed e178" xml:id="XQueryREST">
            
            <div class="quote e179">An XQuery Servlet for RESTful Data Services</div>,
            Jonathan Robie.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e180" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://2006.xmlconference.org/proceedings/87/presentation.html</div>
            
         </div>
         <div class="bibliomixed e181" xml:id="Soap1">
            SOAP Version 1.2 Part 1: Messaging Framework (Second Edition).
            W3C Recommendation 27 April 2007.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e182" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2007/REC-soap12-part1-20070427/</div>
            
         </div>
         <div class="bibliomixed e183" xml:id="Soap2">
            SOAP Version 1.2 Part 2: Adjuncts (Second Edition).
            W3C Recommendation 27 April 2007.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e184" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2007/REC-soap12-part2-20070427/</div>
            
         </div>
         <div class="bibliomixed e185" xml:id="WSActivity">
            W3C Web Services Activity.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e186" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/2002/ws/</div>
            Currently lists 15 W3C Recommendations for Web Services.
            
         </div>
         <div class="bibliomixed e187" xml:id="Oasis">
            OASIS. A full list of committees can be found at
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e188" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.oasis-open.org/committees/</div>.
            
         </div>
         <div class="bibliomixed e189" xml:id="WS-I">
            Web Services Interoperability
            Organization. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e190" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://wsi-org</div>. Currently lists the
            following profiles for interoperability: Basic Profile, Simple Soap
            Binding Profile, Basic Security Profile, Reliable Secure Profile,
            Kerberos Token Profile, REL Token Profile 1.0, SAML Token Profile.
            
         </div>
         <div class="bibliomixed e191" xml:id="NWS">
            National Weather Service, current observations in XML.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e192" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.nws.noaa.gov/data/current_obs/</div>
            
         </div>
         <div class="bibliomixed e193" xml:id="JMS">
            Java JMS. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e194" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://java.sun.com/products/jms/</div>
            
         </div>
         <div class="bibliomixed e195" xml:id="ebXML">
            ebXML: Enabling a Global Electronic Market.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e196" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ebxml.org/</div>
            
         </div>
         <div class="bibliomixed e197" xml:id="ESBWiki">
            Enterprise service bus.
            From Wikipedia, the free encyclopedia.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e198" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://en.wikipedia.org/wiki/Enterprise_service_bus</div>
            
         </div>
      </div>
   </div>
</div>