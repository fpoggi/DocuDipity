<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#MydocumentobjectmodelcandomorethanyoursANCHOR" name="MydocumentobjectmodelcandomorethanyoursTOC">My document object model can do more than yours</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#NodenamesANCHOR" name="NodenamesTOC">Node names</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MultipledocumenttypenodesandmultipledocumentelementsANCHOR" name="MultipledocumenttypenodesandmultipledocumentelementsTOC">Multiple document type nodes and multiple document elements</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#SequenceNodeTypeANCHOR" name="SequenceNodeTypeTOC">Sequence Node Type</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TypedvalueNodeTypeANCHOR" name="TypedvalueNodeTypeTOC">Typed-value Node Type</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#NamedaxesANCHOR" name="NamedaxesTOC">Named axes</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ParsingandserializingANCHOR" name="ParsingandserializingTOC">Parsing and serializing</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 6 - 9, 2013</div>
         <div class="singletermTERMS">alain.couthures@agencexml.com</div>
         <div class="singletermTERMS">Alain</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Couthures</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">DOM Level 3 Core W3C Recommendation 4 April 2004</div>
         <div class="singletermTERMS">Document Object Model - Attr</div>
         <div class="singletermTERMS">DOM4 W3C Working Draft 6 December 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">https://developer.mozilla.org/en/docs/DOM/Attr</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Linked CSV Unofficial Draft 08 March 2013</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">Network (CODASYL) Data Model</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">Toward χίμαιραλ/superset 8 August 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="MydocumentobjectmodelcandomorethanyoursANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">My document object model can do more than yours</div>
      <div class="subtitle e2">Extending the DOM for data manipulation</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2013</div>
            <div class="confdates e6">August 6 - 9, 2013</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">Document object models, specifically the browser DOM, were
               designed to represent HTML and XML documents. Languages such as XPath
               were designed to access and traverse the DOM of HTML and XML documents.
               But suppose we wanted to bring the power and convenience of XML
               technologies like XPath to new data types. Could we extend the DOM to
               support CSV files? JSON? ZIP files? Yes we can! This paper explores a
               number of ways in which the DOM can be made to do more. We can loosen
               restrictions, describe new sequence types, and even define new XPath
               axes to make the DOM better and more useful.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Alain</div>
               <div class="surname e12">Couthures</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Alain Couthures is the project leader for XSLTForms which is a
                  client-side XForms implementation based on XSLT and Javascript. He is
                  an Invited Expert in the W3C Forms Working Group.
               </div>
            </div>
            <div class="email e15">alain.couthures@agencexml.com</div>
         </div>
         <div class="legalnotice e16">
            <div class="para e17">This work is made available under a Creative Commons Attribution 3.0 License (
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e18" xlink:actuate="onRequest" xlink:href="http://creativecommons.org/licenses/by/3.0/" xlink:show="new" xlink:type="simple">http://creativecommons.org/licenses/by/3.0/</div>).
            </div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e19">
         <div class="title e20">Introduction</div>
         <div class="para e21">XML is well-known for two major uses: documents and data exchange.
            Actually, any XML "document" can also be considered as a small consistent
            database. As an example, an invoice requires many tables to be described
            while one XML document is enough for this.
         </div>
         <div class="para e22">For small amount of data, an XML "document" is usually parsed in
            memory and the DOM API is a common library to manipulate its contents
            within browsers or in Microsoft environments (MSXML, .Net) or in PHP. DOM
            Level 1 was quite limited and was designed for HTML. DOM became
            namespace-aware with DOM2. The latest version of DOM is Level 3 and it has
            be published in 2004. There is a quite recent working draft for DOM4 (6
            December 2012).
         </div>
         <div class="para e23">There are many critics about the DOM API, probably because it is
            clearly a low-level interface and because complexifying it for full XML
            support was out of interest for HTML-only fans. The DOM structure is also
            not fully appropriate for building an XPath engine (presence of CDATA and
            entities nodes and lack of namespaces nodes) as defined in XDM.
         </div>
         <div class="para e24">As a matter of fact, DOM3 has not been fully implemented in browsers
            and DOM4 might loose vital functionnalities for building an XPath engine
            with it, such as attributes not been nodes anymore.
         </div>
         <div class="para e25">XForms 1.0, and later XForms 1.1, has been designed for editing XML
            instances with a browser when embedded in an HTML page. XForms is based on
            XPath and any XForms implementation requires extra features about nodes
            such as properties ("validity", "relevant", "read-only", ...) which cannot
            be found in native DOM implementations in browsers. There are also extra
            XPath functions, such as "instance()", "index()", "event()", defined in
            XForms specifications while XPath engines in browser cannot be extended.
            That is why XSLTForms, a client-side XForms implementation, has its own
            XPath engine written in Javascript and that is why its ancestor project,
            AJAXForms, had even also its own DOM implementation. It was chosen to use
            native XML storage in XSLTForms for performance and for eprouved
            compliance when serializing XML instances with multiple namespaces. Today,
            this has to be reconsidered.
         </div>
         <div class="para e26">XForms 2.0 is not limited to XML editing. At least, CSV and JSON are
            also supported. The question for an XForms implementer is how to integrate
            these notations at low level for keeping XPath use at authors'
            level.
         </div>
         <div class="para e27">CSV format might seem to be an old format but it is still used in
            many import/export functions of applications. For relational databases, a
            CSV file is a natural table content.
         </div>
         <div class="para e28">Mapping JSON in XML and preserving XPath expressions readability is
            not easy. Many attempts have already been done but there is not yet an
            agreement about one in particular for each different situation.
         </div>
         <div class="para e29">This paper is describing that, with few extensions, CSV and JSON can
            be loaded in an extended DOM structure so an XPath engine can manipulate
            them immediately.
         </div>
         <div class="para e30">There are yet more challenging notations or file formats which can
            be of interest for authors. Typically, applications with a light server
            side or offline applications want to manipulate files, not just data in
            exchange notation. Many of them are binary formats and they can now be
            manipulated within browsers with Javascript. The most common ones are
            text-processing documents or spreadsheets in a ZIP package.
         </div>
         <div class="para e31">Possibilities are numerous. For XQuery implementors and developers,
            XQuery instructions might also be parsed into a DOM structure as if there
            was an XQueryX source. Programming languages are defined according to a
            grammar and a grammar is similar to an XML Schema for text sources. For
            Apache administrators, httpd.conf file and log files have a format which
            can be loaded into a DOM structure. There are also emerging notations
            which are simpler or richer than XML and they can surely be parsed and
            stored in an extended DOM structure.
         </div>
         <div class="para e32">A bigger challenge is to use a DOM structure not only for a tree or
            a forest of trees (such as a document with multiple document elements) but
            for graphs. A navigational approach can be obtained with named axes: the
            data designer can specify different sets of children for a node, each one
            being assigned a name.
         </div>
         <div class="para e33">A non-planar structure is even possible within a DOM structure, the
            difficulties being about internal ids to be used when parsing and
            serializing. But this is already done by developers with workarounds and a
            way to standardize this would be appreciated.
         </div>
      </div><a name="NodenamesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e34">
         <div class="title e35">Node names</div>
         <div class="para e36">Most data engines (such as relational databases, CSV, JSON,...)
            don't have restrictions for names: any character is possible and an
            enclosing delimiter is used in the corresponding query languages to ensure
            there will be no mismatch. For example, MySQL uses the back-quote
            character, MS-Access uses square brackets. Names without restrictions are
            clearly more user-friendly. XML 1.1 extended possibilities for names but
            was not implemented much...
         </div>
         <div class="para e37">For the DOM, a name is stored within a string: there is no
            restriction for names due to the DOM structure.
         </div>
         <div class="para e38">Quote, apostrophe, brackets, angular brackets, parenthesis are
            already used in XML and XPath. So, the back-quote character is a good
            candidate for this purpose:
         </div>
         <div class="programlisting e39" xml:space="preserve">`+` is now a valid node name in XPath</div>
         <div class="para e40">Encoding within a name is still required in XML and XPath for
            special characters (new line, quotes,...). Those characters can easily be
            escaped as entities.
         </div>
         <div class="programlisting e41" xml:space="preserve">`&amp;amp;` stands for an ampersand character
            `&amp;#10;` stands for a newline character
         </div>
      </div><a name="MultipledocumenttypenodesandmultipledocumentelementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e42">
         <div class="title e43">Multiple document type nodes and multiple document elements</div>
         <div class="para e44">Multiple document type nodes can be very useful within a ZIP package
            because each ZIP component might have its own document properties (media
            type, encoding, ...).
         </div>
         <div class="para e45">Multiple document elements is a pertinent feature for many formats
            for which serializers don't guarantee that the end of the contents has be
            reached. This is even an advantage to allow data to be added at the end
            without breaking a well-formed rule. Is it still interesting to always
            double check that all data has been received?
         </div>
         <div class="para e46">Those two extensions do not require the DOM structure to be
            modified. They impact the parser and the serializer. Methods of the DOM
            API, such as appendChild and so on, have to accept them.
         </div>
         <div class="para e47">For JSON:</div>
         <div class="programlisting e48" xml:space="preserve">{a: "Hello", b: "World"}
            
            becomes
            
            document( 
            element("a",
            text("Hello")
            ),
            element("b",
            text("World")
            )
            )
         </div>
      </div><a name="SequenceNodeTypeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e49">
         <div class="title e50">Sequence Node Type</div>
         <div class="para e51">Manipulation of an ordered set of data is possible in many formats.
            For example, JSON allows "arrays" which can be embedded.
         </div>
         <div class="para e52">There is a known trick when converting a named JSON array into XML:
            just iterate as many elements with the array name. Luckily, even the
            bracket notation is similar in XPath because of the shortcut for
            "[position() = n]". But there are also anonymous arrays in JSON, empty
            arrays and arrays with a unique item. So, this trick is not enough and
            extra meta data becomes mandatory.
         </div>
         <div class="para e53">Support of a new node type is enough to deal with ordered sets. This
            could be named "Sequence Node Type" because of sequences defined in XPath,
            even if XPath does not allow embedded sequences.
         </div>
         <div class="para e54">A sequence node can be seen as an element without a name and without
            attributes. Instead of defining such a new node type, it could also be
            considered to allow elements without a name but this would interfere
            within XPath expressions with a selector such as '*'.
         </div>
         <div class="para e55">It could also be compared to a document fragment being stored with
            the structure instead of just being a temporary embedding node. It would
            then be necessary to add a parameter to each method accepting a document
            fragment to specify whether the document fragment node should be dropped
            or not.
         </div>
         <div class="para e56">Since a sequence node type is corresponding to a specific need, it
            is better to define a new node type.
         </div>
         <div class="programlisting e57" xml:space="preserve">["a", "b"] becomes
            document( sequence( text("a"), text("b") ) )
         </div>
         <div class="para e58">It is more problematic to choose a notation in XPath for such
            nodes:
         </div>
         <div class="itemizedlist e59">
            <div class="listitem e60">
               <div class="para e61">"sequence()" such as in "text()"?</div>
            </div>
            <div class="listitem e62">
               <div class="para e63">"#" or "(-)" as a shortcut?</div>
            </div>
         </div>
         <div class="programlisting e64" xml:space="preserve">"#/text()[1]" returns "a" for ["a", "b"]</div>
      </div><a name="TypedvalueNodeTypeANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e65">
         <div class="title e66">Typed-value Node Type</div>
         <div class="para e67">In DOM3, just elements and attributes can have a data type as
            property and nodes with effective values are only text nodes.
         </div>
         <div class="para e68">This is not enough for JSON because stand-alone values are possible.
            The following JSON expressions are valid:
         </div>
         <div class="programlisting e69" xml:space="preserve">[1, true]
            
            null
            
            2.154E-7
            
            ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
         </div>
         <div class="para e70">Every value in JSON has a data type and JSON allows numbers,
            strings, booleans and null. From the Javascript point of view, because
            JSON data is directly evaluated, JSON can even contain expressions: for
            example,date object creations are possible.
         </div>
         <div class="para e71">In CSV, no type is specified and, commonly, a spreadsheet processor
            will try to associate the most fitting type for each value. Import tools
            help users to manually force a type for a column.
         </div>
         <div class="para e72">But, because the number of header lines is not limited to just one
            line, it is also a possible trick to associate a type to each CSV column
            within the header (when column names are unknown, an empty line can be
            used). For example:
         </div>
         <div class="programlisting e73" xml:space="preserve">
            xs:anyURI,xs:gYear,xs:positiveInteger
            http://en.wikipedia.org/wiki/Afghanistan,1960,9616353
            http://en.wikipedia.org/wiki/Afghanistan,1961,9799379
            http://en.wikipedia.org/wiki/Afghanistan,1962,9989846
            http://en.wikipedia.org/wiki/Afghanistan,1963,10188299
         </div>
         <div class="para e74">As a consequence, for a DOM structure to be used to store JSON or
            CSV data, the text node type is not enough and a new node type has to be
            defined for a typed value.
         </div>
         <div class="programlisting e75" xml:space="preserve">42 becomes
            value("xsd:decimal", 42)
         </div>
         <div class="programlisting e76" xml:space="preserve">{ a: 42, b: "Hello"} becomes
            document( element("a", value("xsd:decimal", 42) ), element("b", value("xsd:string",
            "Hello") ) )
         </div>
         <div class="para e77">This has not to be limited to XSD types and really binary types (not
            xsd:hexBinary nor xsd:base64Binary) are required in different situations
            such as ZIP packages with embedded images like in, for example, OpenXML
            files (.xlsx, .docx,...).
         </div>
      </div><a name="NamedaxesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e78">
         <div class="title e79">Named axes</div>
         <div class="para e80">Attributes can be considered as low-level elements but there are
            advantages at using them because they are clearly separated from children
            nodes. As a consequence, whether they are present or not, they do not
            interfere when calling XPath nodeset functions upon children. For XPath,
            attributes are accessed with a dedicated axis ("attribute::", with "@" as
            the well-known shorcut). So, in a sense, there are possibly two distinct
            sub-trees under an element.
         </div>
         <div class="programlisting e81" xml:space="preserve">&lt;person firstname="Paul" lastname="Verdier" &gt;
            &lt;address&gt;17 rue de Rivoli&lt;/address&gt;
            &lt;address&gt;75001 Paris&lt;/address&gt;
            &lt;address&gt;France&lt;/address&gt;
            &lt;/person&gt;
            
            could also be serialized as
            
            &lt;person&gt;
            &lt;attribute::firstname&gt;Paul&lt;/attribute::firstname&gt;
            &lt;attribute::lastname&gt;Verdier&lt;/attribute::lastname&gt;
            &lt;address&gt;17 rue de Rivoli&lt;/address&gt;
            &lt;address&gt;75001 Paris&lt;/address&gt;
            &lt;address&gt;France&lt;/address&gt;
            &lt;/person&gt;
         </div>
         <div class="para e82">Allowing developers to define named axes means that an element can
            have multiple children in a specific context which might also be seen as a
            relationship. The name for the axis is the name of the relationship. The
            resulting structure can be compared to the navigational CODASYL database
            model.
         </div>
         <div class="para e83">This point is not at all difficult to implement (a map of arrays for
            children instead of a unique array) and a corresponding syntax for XPath
            can easily be defined ("child(axis-name)::" for example).
         </div>
         <div class="para e84">For XML-like serialization, the list of axes could precede the name
            of an element child:
         </div>
         <div class="programlisting e85" xml:space="preserve">&lt;product&gt;
            &lt;designer::person&gt;Peter&lt;/designer::person&gt;
            &lt;user::person&gt;Jack&lt;/user::person&gt;
            &lt;user::person&gt;Emily&lt;/user::person&gt;
            &lt;/product&gt;
         </div>
         <div class="para e86">When multiple parents are allowed, the structure looks like in the
            network CODASYL database model.
         </div>
         <div class="para e87">A use case for XML developers is embedding in the same document data
            and specific data types declarations (in the same approach, fonts can be
            embedded within a PDF file). This is possible with the data document
            element and the schema document element being at the top level.
         </div>
         <div class="para e88">Serialization is more clumsy with a network data model: a child
            element cannot be serialized under each parent element. A specific
            notation can be used to list links such as in multipart messages. This
            will be less human-friendly but XML documents are not often generated
            manually and serialization might be seen as just a way to exchange a
            database.
         </div>
         <div class="para e89">For example:</div>
         <div class="programlisting e90" xml:space="preserve">&lt;person&gt;
            &lt;attribute::email&gt;
            &lt;attribute::xsi:type xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xlink="http://www.w3.org/1999/xlink"
            xlink:href="#email_type"/&gt;
            paul.verdier@rivoli.fr
            &lt;/attribute::email&gt;
            &lt;/person&gt;
            &lt;xs:simpleType xmlns:xs="http://www.w3.org/2001/XMLSchema" id="email_type"&gt;
            &lt;xs:restriction base="xsd:string"&gt;
            &lt;xs:pattern value="(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})"/&gt;
            &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
         </div>
      </div><a name="ParsingandserializingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e91">
         <div class="title e92">Parsing and serializing</div>
         <div class="para e93">Currently, with the Javascript DOMParser class, only XML and,
            eventually HTML and SVG documents can be parsed in a browser and the
            corresponding mediatype is to be provided as a parameter for the
            parseFromString() method.
         </div>
         <div class="para e94">Extending support for other media types such as "text/csv" and
            "application/json" allows CSV and JSON being loaded in a DOM structure.
            XSLTForms now supports CSV/XML and JSON/XML conversions written in
            Javascript.
         </div>
         <div class="para e95">For other formats, a third parameter can be the grammar to be used
            to generate the corresponding tree.
         </div>
         <div class="para e96">Because data cannot always be stored as a string (binary data, for
            example), another method has also to be defined, such as
            parseFromUint32Array. This allows media types such as "application/zip"
            for ZIP packages to be supported. This has already been prototyped in
            XSLTForms with the zip_inflate and zip_deflate Javascript functions
            written by Masanao Izumo (
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e97" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.onicos.com/staff/iz/amuse/javascript/expert/</div>)
            and there is no performance issue with standard MS-Excel or MS-Word
            files.
         </div>
         <div class="para e98">When serializing, some links could be internal links. It could be
            possible to add id attributes when required but another mechanism should
            be provided, a sort of internal ids such as keys in XSLT, with its
            specific notation such as internal:key.
         </div>
         <div class="para e99">Of course, exceptions will be fired because not all DOM structures
            can be serialized in any format. There might be different workarounds to
            serialize a DOM structure in a different media type without data
            loss.
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e100">
         <div class="title e101">Conclusion</div>
         <div class="para e102">Trees are everywhere and they can even store links to represent
            graphs. XML notation is a convenient way to serialize not-so-limited trees
            but people can consider that it is too verbeous. The real point is the
            power in data description and data manipulation.
         </div>
         <div class="para e103">The DOM structure is already used by browsers as an XML Data Model.
            Extending the DOM for non-XML data manipulation is not really difficult
            and XPath is not heavily affected. The resulting structure can support
            plenty of existing data formats. Because it is a low level component,
            upper layers can immediately benefit of it without significant
            modifications.
         </div>
         <div class="para e104">XSLTForms is directly concerned by an extended DOM implementation
            written in Javascript. It is a good opportunity to easily prototype and
            test new features. This implementation is currently in development and it
            already has its own name: "Fleur".
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e105">
         <div class="title e106">Bibliography</div>
         <div class="bibliomixed e107" xml:id="dom3core" xreflabel="DOM Level 3 Core">W3C. 
            <div class="emphasis e108" role="ital">DOM Level 3 Core W3C Recommendation 4 April 2004</div>
            [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e109" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/DOM-Level-3-Core/core.html</div>
         </div>
         <div class="bibliomixed e110" xml:id="linked-csv" xreflabel="Linked CSV">Jeni Tennison,
            Open Data Institute. 
            <div class="emphasis e111" role="ital">Linked CSV Unofficial Draft 08
               March 2013
            </div> [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e112" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://jenit.github.io/linked-csv/</div>
         </div>
         <div class="bibliomixed e113" xml:id="superset" xreflabel="superset">Eric van der
            Vlist. 
            <div class="emphasis e114" role="ital">Toward χίμαιραλ/superset 8 August
               2012
            </div> [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e115" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://eric.van-der-vlist.com/blog/2012/08/08/toward-%CF%87%CE%AF%CE%BC%CE%B1%CE%B9%CF%81%CE%B1%CE%BBsuperset/</div>
         </div>
         <div class="bibliomixed e116" xml:id="embracing-json" xreflabel="Embracing JSON">Eric van der
            Vlist. 
            <div class="emphasis e117" role="ital">Embracing JSON? Of course, but how? 10
               February 2013
            </div> [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e118" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://archive.xmlprague.cz/2013/presentations/Embracing_JSON/presentation.html#/start</div>
         </div>
         <div class="bibliomixed e119" xml:id="dom-attr" xreflabel="Document Object Model - Attr">Mozilla Developer Network 
            <div class="emphasis e120" role="ital">Document
               Object Model - Attr
            </div> [online]. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e121" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">https://developer.mozilla.org/en/docs/DOM/Attr</div>
         </div>
         <div class="bibliomixed e122" xml:id="dom4" xreflabel="DOM4">W3C. 
            <div class="emphasis e123" role="ital">DOM4 W3C Working Draft 6 December 2012</div> [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e124" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/dom/</div>
         </div>
         <div class="bibliomixed e125" xml:id="codasyl" xreflabel="CODASYL">Nick Scherbakov.
            
            <div class="emphasis e126" role="ital">Network (CODASYL) Data Model</div> [online].
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e127" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://coronet.iicm.edu/is/scripts/lesson03.pdf</div>
         </div>
      </div>
   </div>
</div>