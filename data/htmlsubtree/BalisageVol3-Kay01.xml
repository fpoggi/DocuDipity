<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#YouPullI%E2%80%99llPush:onthePolarityofPipelinesANCHOR" name="YouPullI%E2%80%99llPush:onthePolarityofPipelinesTOC">You Pull, I’ll Push: on the Polarity of Pipelines</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Pipelines:anIntroductionANCHOR" name="Pipelines:anIntroductionTOC">Pipelines: an Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PipelineswithinaQueryorStylesheetANCHOR" name="PipelineswithinaQueryorStylesheetTOC">Pipelines within a Query or Stylesheet</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#PipelineswithinanXSLTorXQueryprocessorANCHOR" name="PipelineswithinanXSLTorXQueryprocessorTOC">Pipelines within an XSLT or XQuery processor</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PushvspullparsingANCHOR" name="PushvspullparsingTOC">Push vs. pull parsing</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BranchingandMergingANCHOR" name="BranchingandMergingTOC">Branching and Merging</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PipelineGranularityANCHOR" name="PipelineGranularityTOC">Pipeline Granularity</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#HybridGranularityANCHOR" name="HybridGranularityTOC">Hybrid Granularity</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#WhenpushmeetspullANCHOR" name="WhenpushmeetspullTOC">When push meets pull</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CoroutinesANCHOR" name="CoroutinesTOC">Coroutines</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#JacksonStructuredProgrammingandtheConceptofInversionANCHOR" name="JacksonStructuredProgrammingandtheConceptofInversionTOC">Jackson Structured Programming and the Concept of Inversion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#InversioninXSLTANCHOR" name="InversioninXSLTTOC">Inversion in XSLT</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InvertingasinglephasestylesheetANCHOR" name="InvertingasinglephasestylesheetTOC">Inverting a single-phase stylesheet</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InvertingamultiphasestylesheetANCHOR" name="InvertingamultiphasestylesheetTOC">Inverting a multi-phase stylesheet</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Mustitbepushedorcanitbepulled?ANCHOR" name="Mustitbepushedorcanitbepulled?TOC">Must it be pushed, or can it be pulled?</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">applyTemplate()</div>
         <div class="singletermTERMS">applyTemplatesState</div>
         <div class="singletermTERMS">August 11 - 14, 2009</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">boundary clash</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2009</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">CharacterMapExpander</div>
         <div class="singletermTERMS">CDATAFilter</div>
         <div class="singletermTERMS">cdata-section-elements</div>
         <div class="singletermTERMS">compose</div>
         <div class="singletermTERMS">children.next()</div>
         <div class="singletermTERMS">changes in polarity</div>
         <div class="singletermTERMS">continuation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">deep-equal()</div>
         <div class="singletermTERMS">doc()</div>
         <div class="singletermTERMS">decompose</div>
         <div class="singletermTERMS">doc('big.xml')//unit</div>
         <div class="singletermTERMS">Director</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">endElement</div>
         <div class="singletermTERMS">Emitter</div>
         <div class="singletermTERMS">endElement()</div>
         <div class="singletermTERMS">events</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">following-sibling</div>
         <div class="singletermTERMS">fulcrum</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">generator</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">href</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">Indenter</div>
         <div class="singletermTERMS">interleaving clash</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">Jackson Structured Programming</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Kay</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">MetaTagAdjuster</div>
         <div class="singletermTERMS">mike@saxonica.com</div>
         <div class="singletermTERMS">Michael</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">nextEvent()</div>
         <div class="singletermTERMS">next()</div>
         <div class="singletermTERMS">node-set()</div>
         <div class="singletermTERMS">NOTE</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">order by</div>
         <div class="singletermTERMS">Or: When pull comes to shove...</div>
         <div class="singletermTERMS">ordering clash</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">parent</div>
         <div class="singletermTERMS">phase1output</div>
         <div class="singletermTERMS">Pipelines</div>
         <div class="singletermTERMS">Push</div>
         <div class="singletermTERMS">Pull</div>
         <div class="singletermTERMS">Program Inversion</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">read</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">startElement</div>
         <div class="singletermTERMS">SEQ[PRED]</div>
         <div class="singletermTERMS">startElement()</div>
         <div class="singletermTERMS">structure clash</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">UncommittedEmitter</div>
         <div class="singletermTERMS">UnicodeNormalizer</div>
         <div class="singletermTERMS">URIEscaper</div>
         <div class="singletermTERMS">unit</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:apply-templates</div>
         <div class="singletermTERMS">xsl:character-map</div>
         <div class="singletermTERMS">XML10ContentChecker</div>
         <div class="singletermTERMS">xsl:output</div>
         <div class="singletermTERMS">xs:unique</div>
         <div class="singletermTERMS">xs:key</div>
         <div class="singletermTERMS">xs:keyref</div>
         <div class="singletermTERMS">XMLEventReader</div>
         <div class="singletermTERMS">XMLEvent</div>
         <div class="singletermTERMS">xsl:element</div>
         <div class="singletermTERMS">xsl:copy</div>
         <div class="singletermTERMS">xsl:choose</div>
         <div class="singletermTERMS">xsl:for-each</div>
         <div class="singletermTERMS">xsl:for-each-group</div>
         <div class="singletermTERMS">xsl:merge</div>
         <div class="singletermTERMS">XSLT Programmer's Reference</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">yield</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="YouPullI%E2%80%99llPush:onthePolarityofPipelinesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">You Pull, I’ll Push: on the Polarity of Pipelines</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2009</div>
            <div class="confdates e5">August 11 - 14, 2009</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Pipelines provide an excellent way of structuring XML applications, simplifying complex
               processing tasks and enabling the reuse of generic components, using a variety of
               technologies.
               Efficient pipelines often pass data from one stage to the next as a sequence of 
               
               <div class="emphasis e8" role="ital">events</div>, representing the structure of the tree as a by notifying
               
               <div class="code e9">startElement</div>, 
               <div class="code e10">endElement</div> and similar transitions.
            </div>
            <div class="para e11">The control flow in a pipeline can either run with the data flow (push polarity) or
               against
               the flow (pull polarity). Performance problems occur when components with different
               polarity need
               to be integrated into the same pipeline: traditionally this problem is handled either
               by buffering
               the data in memory (leading to scalability problems as well as loss of latency), or
               by using
               multiple threads, which introduces coordination overheads.
            </div>
            <div class="para e12">This paper looks at a different way of managing polarity conflicts, by applying the
               concepts
               of program inversion developed during the days of batch magnetic tape data processing.
               It specifically
               examines how this concept can be applied to the compilation of XSLT stylesheets, both
               single and multi-phase.
            </div>
         </div>
         <div class="author e13">
            <div class="personname e14">
               <div class="firstname e15">Michael</div>
               <div class="surname e16">Kay</div>
            </div>
            <div class="personblurb e17">
               <div class="para e18">Michael Kay is the editor of the W3C XSLT specification, and is a member of the XQuery
                  and XML Schema Working Groups. He is the developer of the Saxon XSLT, XQuery, and
                  XML Schema processor.
                  He is the author of 
                  <div class="quote e19">XSLT Programmer's Reference</div> (now in its fourth edition) and a contributor
                  to many other books.
               </div>
               <div class="para e20">He is a member of the Advisory Board for Balisage 2009, and Chair of the associated
                  Symposium
                  on Processing XML Efficiently.
               </div>
            </div>
            <div class="affiliation e21">
               <div class="jobtitle e22">Director</div>
               <div class="orgname e23">Saxonica Limited</div>
            </div>
            <div class="email e24">mike@saxonica.com</div>
         </div>
         <div class="legalnotice e25">
            <div class="para e26">Copyright © 2009 Michael Kay.</div>
         </div>
         <div class="keywordset e27" role="author">
            <div class="keyword e28">XML</div>
            <div class="keyword e29">Pipelines</div>
            <div class="keyword e30">Push</div>
            <div class="keyword e31">Pull</div>
            <div class="keyword e32">Jackson Structured Programming</div>
            <div class="keyword e33">Program Inversion</div>
         </div>
      </div><a name="Pipelines:anIntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e34">
         <div class="title e35">Pipelines: an Introduction</div>
         <div class="para e36">It has been known for a long time [see for example 
            
            <div class="xref e37" linkend="Thompson2001"></div>, 
            <div class="xref e38" linkend="McGrath2002"></div>, 
            <div class="xref e39" linkend="McGrath2004"></div>]
            that processing of XML documents can conveniently be
            organized in the form of a pipeline. In such a pipeline, the work is divided into
            a sequence of
            steps, each of which takes an XML document as input, and produces another XML document
            as output.
            Constructing an application in the form of a pipeline has many advantages, the main
            ones being
            (a) that the code of each step in the pipeline is kept very simple; (b) that it is
            very
            easy to assemble an application from a set of components, thus maximizing the potential
            for
            component reuse, and (c) there is no requirement that each step in a pipeline should
            use
            the same technology; it's easy to mix XSLT, XQuery, Java and so on in different stages.
         </div>
         <div class="para e40">A number of products are available to assist with the development and management
            of pipeline-based applications, examples being Orbeon [
            <div class="xref e41" linkend="orbeon"></div>] and 
            Apache Cocoon [
            <div class="xref e42" linkend="cocoon"></div>]. More recently W3C
            has developed a standard language, XProc [
            <div class="xref e43" linkend="xproc"></div>], for the definition of pipelines.
         </div>
         <div class="para e44">One of the benefits of structuring an application using pipelines is that different
            technologies
            can be used to implement each step within a pipeline. This maximizes component reusability,
            since
            the ability to make use of an existing component is not dependent on the choice of
            technology used
            to implement the component. This only works, of course, if there are some kind of
            standards for plugging
            heterogeneous components together.
         </div>
         <div class="para e45">Ideally, components will be able to pass information to each other without the overhead
            of
            serializing the data as lexical XML and then reparsing it. Equally, they will be able
            to pass information
            without buffering the entire document in memory. This suggests that in an optimal
            interface, the
            data will be passed between components as a stream of events (for example, 
            <div class="code e46">startElement</div>,
            
            <div class="code e47">endElement</div>, etc).
         </div>
         <div class="para e48">The question then arises, how should the components of a pipeline be written? One
            can envisage
            three styles:
         </div>
         <div class="itemizedlist e49">
            <div class="listitem e50">
               <div class="para e51">Each component is written as a complete program that reads XML from its input
                  and writes XML to its output. We will call this a main-loop component, because in
                  general it contains
                  a program loop containing read and write instructions.
               </div>
            </div>
            <div class="listitem e52">
               <div class="para e53">A component may be written to be called repeatedly by the component that supplies
                  its 
                  input, once for each item of input. This is an event-driven style of programming,
                  and we will call
                  this a push component.
               </div>
            </div>
            <div class="listitem e54">
               <div class="para e55">A component may be written to be called repeatedly by the component that consumes
                  
                  its output. That is, the component is called whenever some more data is required.
                  We will call
                  this a pull component.
               </div>
            </div>
         </div>
         <div class="para e56">These three styles of component are illustrated in Figure 1.</div>
         <div class="figure e57" xml:id="fig1">
            <div class="mediaobject e58">
               <div class="imageobject e59">
                  <div class="metaBox e60"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e109').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e109" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e60'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e61">
                  <div class="para e62">Fig 1. Three styles of pipeline component. The arrows indicate the direction of control
                     flow;
                     the direction of data flow is in all cases from left to right.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e63">A push filter is a component of a pipeline that is invoked repeatedly by its upstream
            neighbour
            (the supplier of its input), and that in turn makes multiple calls to its downstream
            neighbour
            (the consumer of its output). Similarly, a pull filter is a component that is invoked
            repeatedly by
            its downstream neighbour (the consumer of its output), and that in turn makes repeated
            requests for data
            from its upstream neighbour (the supplier of its input).
         </div>
         <div class="para e64">Each of these styles has advantages and disadvantages, from the points of view of
            the developer
            of the component and the user of the component. When it comes
            to constructing a pipeline, however, we probably have to face the fact that we will
            sooner or later
            want to integrate components that have been written in different styles: main-loop
            components, 
            push components, and pull components; one aim of this paper is to address the integration
            challenges 
            this poses.
         </div><a name="PipelineswithinaQueryorStylesheetANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e65">
            <div class="title e66">Pipelines within a Query or Stylesheet</div>
            <div class="para e67">The concepts described in this paper can be applied at various levels of the system.
               One can
               consider a pipeline in which each component is a complete XSLT or XQuery transformation.
               Or
               one can consider a pipeline of operations contained within a single stylesheet or
               query: this often
               manifests itself as a multi-phase transformation whose logic looks something like
               this:
            </div>
            <div class="programlisting e68" xml:space="preserve">
               &lt;xsl:variable name="x"&gt;
               &lt;temp&gt;
               &lt;xsl:apply-templates select="/" mode="phase-1"/&gt;
               &lt;/temp&gt;
               &lt;/xsl:variable&gt;
               &lt;xsl:variable name="y"&gt;
               &lt;tump&gt;
               &lt;xsl:apply-templates select="$x" mode="phase-2"/&gt;
               &lt;/tump&gt;
               &lt;/xsl:variable&gt;
               &lt;xsl:template name="entry"&gt;
               &lt;xsl:apply-templates select="$y" mode="phase-3"/&gt;
               &lt;/xsl:template&gt;
               
            </div>
            <div class="para e69">We can think of this as a sequence of three “push” components if we adopt the XSLT
               1.0 paradigm
               which describes literal result elements, 
               <div class="code e70">xsl:apply-templates</div>, and other instructions that
               create new nodes as “writing to the result tree”. The terminology has changed in XSLT
               2.0; such
               instructions are now described as constructing a node and returning it to its caller.
               That is, the language
               has changed between the two releases from talking about a push model to talking about
               a pull model. 
               By and large this is only a matter of presentation. But the 1.0
               model is probably closer to the way many implementations are likely to work internally.
            </div>
            <div class="para e71">An internal pipeline within a single XQuery has a more pull-like feel to it. The equivalent
               might
               be:
            </div>
            <div class="programlisting e72" xml:space="preserve">
               declare function f:phase-1($d as document-node()) {
               &lt;temp&gt;{f:process($d)}&lt;/temp&gt;
               }
               
               declare function f:phase-2($x as element(temp)) {
               &lt;tump&gt;{f:manipulate($x)}&lt;/tump&gt;
               } 
               
               declare function f:phase-3($y as element(tump)) {
               &lt;html&gt;{f:render($y)}&lt;/html&gt;
               } 
               
               f:phase-3(f:phase-2(f:phase-1(/)))
               
            </div>
            <div class="para e73">The “pull” nature of this pipeline arises from the use of function calls as the composition
               mechanism; the control logic starts from the last stage in the pipeline, and each
               stage invokes
               its predecessor by means of a function call.
            </div>
            <div class="para e74">However, because XSLT and XQuery are both declarative languages, this user view (or
               specification view)
               of how the languages work might not always match the internal reality. The underlying
               XSLT engine
               might compile “pull” code from an 
               <div class="code e75">xsl:apply-templates</div> instruction, or might compile
               “push” code from a function call. This flexibility, which we shall examine in more
               detail later,
               turns out to be one of the major benefits of writing in a declarative language.
            </div>
         </div><a name="PipelineswithinanXSLTorXQueryprocessorANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e76">
            <div class="title e77">Pipelines within an XSLT or XQuery processor</div>
            <div class="para e78">We can also look at pipelines as implemented internally within an XSLT or XQuery processor,
               or within other components such as XML parsers, validators, and serializers. The serializer
               is the component
               responsible for converting a tree representation of an XML document into lexical XML
               markup; it is controlled
               by a number of user-settable properties as described in [
               <div class="xref e79" linkend="serialization"></div>]. The serializer in Saxon, for
               example [see 
               <div class="xref e80" linkend="saxon"></div>] and [
               <div class="xref e81" linkend="Kay2001"></div>] is implemented internally as a 
               pipeline containing one or more of the following components:
            </div>
            <div class="itemizedlist e82">
               <div class="listitem e83">
                  <div class="para e84">An 
                     <div class="code e85">UncommittedEmitter</div>, which decides dynamically whether the output
                     method is XML, XHTML, or HTML, and constructs the rest of the pipeline accordingly
                  </div>
               </div>
               <div class="listitem e86">
                  <div class="para e87">A 
                     <div class="code e88">CharacterMapExpander</div>, which handles any 
                     <div class="code e89">xsl:character-map</div>
                     declarations in the stylesheet
                  </div>
               </div>
               <div class="listitem e90">
                  <div class="para e91">A 
                     <div class="code e92">UnicodeNormalizer</div>, which converts character sequences into
                     composed or decomposed Unicode Normal Form
                  </div>
               </div>
               <div class="listitem e93">
                  <div class="para e94">A 
                     <div class="code e95">URIEscaper</div> which performs percent-encoding of HTML URI-valued
                     attributes such as 
                     <div class="code e96">href</div>
                  </div>
               </div>
               <div class="listitem e97">
                  <div class="para e98">A 
                     <div class="code e99">MetaTagAdjuster</div> which adds, deletes, or modifies 
                     <div class="code e100">&lt;meta&gt;</div>
                     elements appearing within the 
                     <div class="code e101">&lt;head&gt;</div> element of an HTML or XHTML document
                  </div>
               </div>
               <div class="listitem e102">
                  <div class="para e103">A 
                     <div class="code e104">CDATAFilter</div>, which wraps selected text nodes in CDATA sections
                  </div>
               </div>
               <div class="listitem e105">
                  <div class="para e106">An 
                     <div class="code e107">XML10ContentChecker</div> which checks that the output
                     contains only characters allowed by XML 1.0 (used only in the case where XML 1.1 input
                     is permitted
                     but XML 1.0 output is required)
                  </div>
               </div>
               <div class="listitem e108">
                  <div class="para e109">An 
                     <div class="code e110">Indenter</div>, customized to XML, HTML, or XHTML, which adds newlines
                     and indentation
                  </div>
               </div>
               <div class="listitem e111">
                  <div class="para e112">An 
                     <div class="code e113">Emitter</div>, customized to XML, HTML, XHTML, or text, which acts as the
                     final stage of the pipeline, emitting a sequence of characters.
                  </div>
               </div>
            </div>
            <div class="para e114">Note that for a given task, the actual serialization pipeline will often contain very
               few
               of these components: if the 
               <div class="code e115">cdata-section-elements</div> attribute of the 
               <div class="code e116">xsl:output</div>
               declaration is absent, for example, there will be no 
               <div class="code e117">CDATAFilter</div> on the pipeline.
               Moreover, the pipeline may contain components not in the above list: Saxon provides
               an interface
               allowing the serialization pipeline to be customized with additional user-defined
               components.
            </div>
            <div class="para e118">Does this design perform well? In some respects, it is not optimized; for example
               it would be
               possible to implement character map expansion and Unicode normalization in a single
               “for each character” loop
               with fewer instructions than when they are done in separate loops. However, for most
               workloads this
               is more than compensated by the fact that there are no “per event” or “per character”
               tests for
               optional operations that are not actually needed. Much of the logic is carried out
               at pipeline 
               configuration time; if the 
               <div class="code e119">CDATAFilter</div> is not included in the pipeline, then there
               will be no once-per-node test to say “should this text node be formatted as a CDATA
               section?” So
               the net effect is that the user pays no price for facilities that are not used.
            </div>
            <div class="para e120">In Saxon, the serializer is implemented as a push pipeline: each component uses a
               SAX-like
               interface to pass XML events to the next stage in the pipeline. This seems a natural
               design given
               that the serializer is writing output, and is thus providing a “write” service to
               its ultimate client
               (which might be the XSLT transformation engine, or a user application). 
            </div>
            <div class="para e121">Another internal pipeline within Saxon is the schema validation pipeline, used to
               validate
               instance documents against the rules defined in an XSD Schema [
               <div class="xref e122" linkend="xsd"></div>]. This again consists
               of a number of components, which in this case are assembled even more dynamically;
               every time a
               start tag is encountered, a new component is added to the pipeline to validate the
               contents of that
               element, and this component is then removed from the pipeline when the matching end
               tag is found.
               Also, if an element defines one or more identity constraints (
               <div class="code e123">xs:unique</div>, 
               <div class="code e124">xs:key</div>,
               and 
               <div class="code e125">xs:keyref</div>), then a “watch” component is added to the pipeline to watch for elements
               that match the select expression of the constraint; when such an element is encountered,
               a further
               “watch” is added to detect and act on elements and attributes that match one of the
               field expressions
               of the constraint. This illustrates one of the benefits of using a push pipeline:
               it is very easy
               for such a pipeline to branch, so that one component pushes a single event to many
               listeners. In this
               case the multiple listeners represent, for example, the multiple fields that can appear
               in a single
               identity constraint, or the multiple identity constraints that can exist for a single
               element declaration
               in a schema. Such branching is not possible in a pull pipeline, for obvious reasons.
            </div>
         </div>
      </div><a name="PushvspullparsingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e126">
         <div class="title e127">Push vs. pull parsing</div>
         <div class="para e128">For some people, the terms “push” and “pull” are associated primarily with styles
            of XML parsing.
            In particular, with a push parser API like SAX, the main control loop is in the parser,
            and the user
            application is invoked to notify significant events such as start and end tags. With
            a pull parser API 
            like StAX, the main control loop is in the user application, which repeatedly requests
            the next event 
            by calling the parser.
            
         </div>
         <div class="para e129">This usage of the terms “push” and “pull” is simply a special case of the way we use
            the terms in this paper, for
            the case of a pipeline that has two stages only, the XML parser and the user application.
         </div>
         <div class="para e130">It is probably true that both the SAX and StAX APIs have been designed rather too
            closely for this
            particular use case (the interface between parsers and user-written applications)
            rather than for the
            more general requirement of communication between arbitrary steps in a pipeline. In
            this paper, however,
            we are concerned with general principles and not with the specific design of these
            two APIs. (StAX, in fact,
            offers two different pull APIs with different trade-offs between functionality and
            speed, and indeed, it also
            bundles in two complementary push APIs as well.)
         </div>
         <div class="para e131">At the parsing level, the debate between advocates of push and pull parsing APIs hinges
            primarily on usability, not performance.
            There are some performance differences, but they are fairly marginal. For example,
            with a pull API it is easier
            for the consumer of the data to skip parts of the document (for example, when a start
            tag has been notified
            it can skip to the matching end tag), which has the potential to reduce the cost of
            processing the unwanted
            data. Many of the performance issues relate to how many times character strings are
            moved from one buffer
            to another, and such factors depend on the fine detail of the API design rather than
            on whether it is a push
            or pull interface.
         </div>
         <div class="para e132">As regards usability, pull parsing does appear to be more attractive to many users.
            I believe this
            is primarily because programmers like to be in control: writing the code that owns
            the main control loop is
            easier than writing event-driven code. It means, for example, that much of the current
            state is maintained
            on the stack provided automatically by the programming language, rather than needing
            to be maintained manually
            on a stack implemented by the user application.
         </div>
         <div class="para e133">Unfortunately, in a multi-stage pipeline this advantage tends to disappear. Typically
            only one 
            component in the pipeline can own the main control loop: the others will either be
            push filters or pull filters.  
            
         </div>
         <div class="para e134">A difference between pull and push parsing becomes noticeable when the correspondence
            between input and output events is not one-to-one. 
            A push filter can easily generate zero, one, or more output events in response
            to each input event. The same effect can be achieved in a pull filter, but it requires
            more intricate management
            of state information between calls. For this reason, my experience is that while a
            pull parser API is attractive
            when the application can then be written as a single control loop, writing a pipeline
            consisting entirely of
            pull filters is trickier than writing an equivalent push pipeline.
         </div>
      </div><a name="BranchingandMergingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e135">
         <div class="title e136">Branching and Merging</div>
         <div class="para e137">A significant difference between pull and push pipelines is this: a push component
            can readily 
            send its output to more than one destination, whereas a pull component can readily
            read data from more than
            one source. This is illustrated in Figures 2 and 3. 
            By its nature, a push pipeline cannot handle multiple streamed inputs, nor can a pull
            pipeline
            handle multiple streamed outputs.
         </div>
         <div class="figure e138" xml:id="fig2">
            <div class="mediaobject e139">
               <div class="imageobject e140">
                  <div class="metaBox e141"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e274').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e274" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e141'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e142">
                  <div class="para e143">Fig 2. Branching in a push pipeline. A component can write to several destinations.</div>
               </div>
            </div>
         </div>
         <div class="figure e144" xml:id="fig3">
            <div class="mediaobject e145">
               <div class="imageobject e146">
                  <div class="metaBox e147"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e281').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e281" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e147'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-003.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e148">
                  <div class="para e149">Fig 3. Merging in a pull pipeline. A component can read from several sources.</div>
               </div>
            </div>
         </div>
         <div class="para e150">As already mentioned, a situation where branching is useful is in evaluating uniqueness
            constraints
            during schema validation. At any given point during a streamed validation of an instance
            document, any
            number of uniqueness constraints can be active. These might have the same scope (employee
            number and social
            security number must both be unique over all employees) or they might have different
            scope (promotion date
            must be unique within an employee history). In Saxon's schema validator, every time
            a new uniqueness constraint
            comes into scope, a uniqueness monitor for that constraint is activated; all parsing
            events are distributed
            to all active uniqueness monitors. This design is only possible with a push pipeline.
         </div>
         <div class="para e151">A situation where merging might be useful is in implementing the XPath 2.0 
            <div class="code e152">deep-equal()</div>
            function. One can envisage implementing this by means of a streaming pass over both
            inputs (especially, say, in the
            case where both operands are calls to the 
            <div class="code e153">doc()</div> function, the intent being to compare two 
            complete XML documents).
            Any significant difference between the two event streams would then cause the function
            to return false. This
            is only possible with a pull pipeline. Because Saxon's architecture is predominantly
            push-based, it does not
            offer a streaming implementation of the 
            <div class="code e154">deep-equal()</div> function — instead it requires both operands to
            exist as trees in memory.
         </div>
      </div><a name="PipelineGranularityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e155">
         <div class="title e156">Pipeline Granularity</div>
         <div class="para e157">In the serialization and validation pipelines discussed above, the calls from
            one component to the next are at the level of an “event”. This is similar to a SAX
            event (start element,
            end element, text node, comment node) and so on, except that in Saxon, the internal
            push interface treats
            each attribute as a separate event notified after the start tag; namespaces are also
            notified as events,
            representing a namespace declaration or undeclaration. A pull pipeline can also operate
            at the same
            granularity: in the StAX 
            <div class="code e158">XMLEventReader</div> interface, a call on 
            <div class="code e159">nextEvent()</div>
            returns an 
            <div class="code e160">XMLEvent</div> object, which again represents a parsing event such as StartElement,
            EndElement, Characters, or Comment. As with SAX, the attributes are delivered as part
            of the
            StartElement event.
         </div>
         <div class="para e161">Saxon's XPath engine, by contrast, makes extensive use of pipelines in which the unit
            of
            data transfer is not a parsing event, but an XPath item (that is, a node or atomic
            value).
            Many XPath operations, especially in XPath 2.0, take sequences of items as
            their input and deliver sequences of items as their result. An obvious example is
            a filter
            expression 
            <div class="code e162">SEQ[PRED]</div>, where the output sequence is that subset of the input items that satisfy some
            predicate. This kind of list processing is well established in functional programming
            languages,
            and to deliver acceptable performance it is always implemented using pipelines, to
            avoid
            allocating memory to intermediate results. Pipelining also benefits execution through
            “early exit”:
            an operator only needs to read as much of its input as is needed to deliver a result.
            
            Typically each expression in the expression tree is
            represented at run-time by an iterator which delivers the results an item at a time
            in response to
            a call (such as 
            <div class="code e163">next()</div>) from the consumer of the data; the implementation of this iterator
            in turn makes calls on 
            <div class="code e164">next()</div> to get data from the iterators representing its subexpressions.
         </div>
         <div class="para e165">A pull pipeline works well here because in general,
            an XPath expression takes input sequences from several subexpressions but delivers
            a single sequence
            as its result. For example, the union operator (assuming its inputs are do not need
            to be sorted into
            document order, which is usually the case) can be implemented by an iterator that
            switches between reading from
            its two input streams, never looking ahead more than one item for either.
         </div>
         <div class="para e166">Push processing can also be useful at the item level, however. An example is a recursive
            function
            that operates over a sequence:
         </div>
         <div class="programlisting e167" xml:space="preserve">
            &lt;xsl:function name="f:compute-running-total" as="element(transaction-with-balance)*"&gt;
            &lt;xsl:param name="input" as="element(transaction)*"/&gt;
            &lt;xsl:param name="current-balance" as="xs:decimal"/&gt;
            &lt;xsl:if test="exists($input)"&gt;
            &lt;transaction-with-balance amount="{$input[1]/@amount}" balance="{$current-balance
            + $amount}"/&gt;
            &lt;xsl:sequence select="f:compute-running-total(remove($input, 1), $current-balance
            + $amount}"/&gt;
            &lt;/xsl:if&gt;
            &lt;/xsl:function&gt;
            
         </div>
         <div class="para e168">A push implementation of this function will typically write each computed element
            to the output
            destination as soon as it is constructed. A pull implementation, unless optimized,
            is likely to construct successive
            sequences of length 1, 2, 3,,, n, with a great deal of copying of intermediate results.
            Furthermore, a push
            implementation can benefit more easily from tail call optimization, whereby on a recursive
            call the stackframe
            of the calling function is reused for the called function, avoiding stack overflow
            when processing a lengthy
            input sequence.
         </div>
         <div class="para e169">Saxon is capable of evaluating this function in either push or pull polarity. As a
            general rule in Saxon,
            tree construction operations (such as 
            <div class="code e170">xsl:element</div>) work in push polarity; XPath operations that navigate through
            an input document work in pull polarity; and flow of control constructs such as function
            calls or conditional expressions
            can work in either direction, generally choosing the polarity of their parent instruction
            by preference.
         </div>
         <div class="para e171">As well as pipelines that operate at the event level or the item level, XQuery in
            particular can take
            advantage of pipelines in which the unit of data is a tuple. This underpins the semantics
            of XQuery FLWOR
            expressions. Currently in Saxon there is only one instance of a pipeline involving
            tuples, which is needed
            to support certain unusual cases of the 
            <div class="code e172">order by</div> clause in a FLWOR expression. In future, however,
            tuples will need to be implemented more deeply in the infrastructure as they are essential
            to the support
            of new facilities in XQuery 1.1 such as grouping and windowing.
         </div><a name="HybridGranularityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e173">
            <div class="title e174">Hybrid Granularity</div>
            <div class="para e175">The Saxon push interface allows both parsing events and complete items to be sent
               down the pipeline.
               This arises naturally from an XSLT instruction such as:
            </div>
            <div class="programlisting e176" xml:space="preserve">
               &lt;xsl:element name="x"&gt;
               &lt;xsl:attribute name="a" select="1"/&gt;
               &lt;xsl:sequence select="doc('abc.xml')"/&gt;
               &lt;/xsl:element&gt;
               
            </div>
            <div class="para e177">The values passed down the pipeline by this instruction are a start-element event,
               an attribute event,
               a document node, and an end-element event. This is a hybrid sequence containing both
               “composed” nodes (the
               document node), and “decomposed” events representing nodes (the start and end element
               events); the attribute
               node fits into both categories.
            </div>
            <div class="para e178">Saxon provides two pipeline filters called 
               <div class="code e179">compose</div> and 
               <div class="code e180">decompose</div>. When added
               to a push pipeline, the 
               <div class="code e181">compose</div> filter acts as a tree builder: a sequence of start-element and 
               end-element events is converted into a tree, which is then passed on down the pipeline
               as a single composed node.
               The 
               <div class="code e182">decompose</div> filter does the reverse: if it receives a document or element node, it decomposes
               this
               into a sequence of parse events. The decision whether to compose a sequence or decompose
               it is delayed until
               it is known what the recipient of the data intends to do with it: if the eventual
               recipient is a serializer, then
               decomposed form is preferred, while if it is a tree builder, on an operation that
               requires a “real tree” as input,
               then composed form is needed.
            </div>
         </div>
      </div><a name="WhenpushmeetspullANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e183">
         <div class="title e184">When push meets pull</div>
         <div class="para e185">
            <div class="emphasis e186" role="ital">Or: When pull comes to shove...</div>
         </div>
         <div class="para e187">The preceding discussion establishes that there are places where it makes more sense
            to do pull
            processing, and places where push is more sensible. But we have also seen that changing
            polarity
            can cause a noticeable performance cost. So what happens when a push pipeline meets
            a pull pipeline?
         </div>
         <div class="para e188">To make this more concrete, a simple design approach for an XSLT 1.0 processor is
            as follows:
         </div>
         <div class="orderedlist e189">
            <div class="listitem e190">
               <div class="para e191">The source document is built as a tree in memory, typically by a two-stage pipeline
                  consisting
                  of a push parser and a tree-builder, perhaps with intermediate filters to perform
                  operations such as
                  DTD or schema validation, or XInclude processing.
               </div>
            </div>
            <div class="listitem e192">
               <div class="para e193">Path expressions in the XSLT stylesheet are evaluated using a pull pipeline in which
                  the values passed down the pipeline are (references to) nodes in the source tree.
               </div>
            </div>
            <div class="listitem e194">
               <div class="para e195">Instructions in the XSLT stylesheet that construct nodes in the result tree are evaluated
                  
                  by sending decomposed events (start-element, end-element, etc). If the result tree
                  is serialized,
                  these events can pass directly to the serializer, which itself is implemented as a
                  push component, eliminating
                  the need to construct the result tree physically in memory.
               </div>
            </div>
         </div>
         <div class="para e196">So we have a push stage, then a pull stage, then another push stage, as illustrated
            in Figure 4.
         </div>
         <div class="figure e197" xml:id="fig4">
            <div class="mediaobject e198">
               <div class="imageobject e199">
                  <div class="metaBox e200"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e389').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e389" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e200'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-004.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e201">
                  <div class="para e202">Fig 4. Typical structure of an XSLT 1.0 processor.</div>
               </div>
            </div>
         </div>
         <div class="para e203">Between the parsing pipeline that processes the source tree and the XPath evaluation
            pipeline that reads
            it, there is a polarity change from push to pull, and this is typically handled by
            allocating memory to hold
            the complete tree. That is, the pipeline is interrupted; there is a need for a reservoir
            of memory with
            sufficient capacity to hold the entire source tree. At the same time, there is a latency
            impact, because the
            second pipeline stage typically cannot start operation until the first has finished.
         </div>
         <div class="para e204">A similar conflict typically arises in a straightforward implementation of intra-stylesheet
            pipelines
            based on temporary trees in XSLT 2.0 (or in XSLT 1.0 with the 
            <div class="code e205">node-set()</div> extension). The chances
            are that a variable holding a temporary tree will actually be materialized in memory
            — constructed as the final
            destination of a push pipeline — to be read by a pull pipeline that only starts operation
            once the tree writing
            has finished. Contrast this with a variable that simply holds a sequence of existing
            nodes or atomic values,
            where the process that creates the sequence and the process that reads it can often
            be pipelined together,
            avoiding the need to physically materialize the variable's value.
         </div>
         <div class="para e206">By contrast, passing data from a pull pipeline to a push pipeline is no problem. In
            between there is
            a component that owns the control loop, reading data from the pull side, and writing
            it to the push side.
         </div>
         <div class="para e207">Once pipelines become more complex, the turbulence caused by push/pull conflicts can
            have
            a significant effect on performance. The flow is interrupted every time such buffering
            occurs, and this does affect both
            memory usage and latency. A recent paper [
            <div class="xref e208" linkend="Kay2008"></div>] explores the effect of changing certain pull/push decisions
            within the Saxon XQuery processor. This examines the behaviour of a particular query
            in the XMark benchmark:
         </div>
         <div class="itemizedlist e209">
            <div class="listitem e210">
               <div class="para e211">Using default execution with push polarity, the query takes 1926ms</div>
            </div>
            <div class="listitem e212">
               <div class="para e213">Forcing the query to run with pull polarity, execution time increases to 3496ms,
                  because of the need to buffer the result tree before serialization.
               </div>
            </div>
            <div class="listitem e214">
               <div class="para e215">Running the query as a whole with push polarity, but using pull polarity for the
                  FLWOR expression that computes the content of the main result element gives a run-time
                  of 2720ms
               </div>
            </div>
         </div>
         <div class="para e216">The conclusion to be drawn from these results is not that push is better than pull
            or vice versa, but
            that 
            <div class="emphasis e217" role="ital">changes in polarity</div> as the data passes down the pipeline are
            expensive and need to be avoided.
         </div>
         <div class="para e218">
            <div class="emphasis e219" role="ital">The problem is probably worse in XQuery than in XSLT. XSLT has two sublanguages: the
               XSLT
               instruction set, and the XPath expression language. It makes sense for XPath expressions
               to pull, and for
               XSLT instructions to push. Because the two sublanguages are independent and don't
               compose very well, this
               generates relatively few conflicts. By contrast, XQuery is a single language where
               these constructs are
               fully composable, and using the same evaluation strategy is therefore likely to lead
               to more turbulence.
            </div>
         </div>
         <div class="para e220">There is an alternative way to graft a push pipeline to a pull pipeline. Rather than
            allocating
            memory to hold the accumulated data, it is possible to operate the two in separate
            threads. With two threads there can
            be two control loops. Data written by the push thread can be placed in a cyclic buffer,
            from which the pull
            thread can read it, as illustrated in Figure 5.
         </div>
         <div class="figure e221" xml:id="fig5">
            <div class="mediaobject e222">
               <div class="imageobject e223">
                  <div class="metaBox e224"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e430').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e430" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e224'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-005.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='90%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e225">
                  <div class="para e226">Fig 5. Using a cyclic buffer to resolve a push-pull conflict.</div>
               </div>
            </div>
         </div>
         <div class="para e227">Saxon uses this technique to support the limited kind of streamed processing available
            in Saxon-SA 9.1
            and earlier releases [see 
            <div class="xref e228" linkend="saxon-streaming"></div>]. Although this offers limited functionality, it has proved a boon to those users
            who
            need to handle source documents in the gigabyte range, stretching the capacity of
            available real memory.
            The idea here is that the result of an expression such as 
            <div class="code e229">doc('big.xml')//unit</div> can be
            delivered (piped) as a sequence of 
            <div class="code e230">unit</div> elements, each of which is a small subtree
            of the original large document. Many transformations (as noted by [
            <div class="xref e231" linkend="McGrath2004"></div>] have the 
            characteristic that the transformation can be effected by dividing the source documents
            into a sequence of
            small trees rooted at what McGrath calls a 
            <div class="emphasis e232" role="ital">fulcrum</div> element, applying a transformation to each of these subtrees,
            and then combining the results back into a single result tree; this construct is explicitly
            geared to
            this kind of transformation. To satisfy the semantics of the language, it is only
            possible to do this
            if the expression appears in a context where the subtree is copied, for example 
            
            <div class="code e233">&lt;xsl:copy-of select="doc('big.xml')//unit"/&gt;</div>. This is because without the copying,
            the recipient of the data would be allowed to navigate away from the 
            <div class="code e234">unit</div> element using
            XPath axes such as 
            <div class="code e235">parent</div> or 
            <div class="code e236">following-sibling</div>. With a copy, the 
            <div class="code e237">unit</div>
            element becomes a standalone (parentless) element, so any attempt at such navigation
            returns nothing.
            Of course there is no real copying going on here: it's just that the system behaves
            as if it built a large
            tree containing the whole source document, and then copied small parts of it to be
            processed one at a time.
         </div>
         <div class="para e238">The subset of XPath that Saxon allows to be used in this streaming mode is quite restrictive.
            It is
            based originally on the subset defined in the XML Schema specification for the definition
            of
            uniqueness and referential integrity constraints. It only allows downward selection.
            Unlike Saxon's usual strategy
            for XPath evaluation, this streaming subset of XPath is evaluated in push polarity:
            a SAX parser is used to parse
            the source document, and the resulting events are then passed through a series of
            push filters whose effect
            is to reduce the document to a sequence of elements representing the parts selected
            by the path expression (the fulcrum elements).
            The remaining events then go to a tree builder which builds each element subtree in
            turn as a real tree in memory;
            the sequence of nodes representing the fulcrum elements are then pushed into a cyclic
            buffer where
            they are read by the pull pipeline (in a separate thread) that consumes the data and
            transforms it using 
            further XSLT instructions.
         </div>
         <div class="para e239">It would be possible to avoid this two-thread approach by reimplementing the first
            stage as a pull
            pipeline, starting with a pull parser (StAX), and then filtering the parsing events
            in pull polarity. There
            are several reasons this has not been done. Firstly, the code was originally written
            to work within Saxon's
            schema validator (which works in push polarity), and it would be costly to rewrite
            it. Secondly, as
            already discussed, writing pull-based filters is probably more difficult than writing
            push-based
            filters. Finally, all other processes that can take place on the parsing pipeline,
            for example schema validation,
            would also need to be rewritten to operate in pull polarity, and this is simply not
            a practical proposition.
            Nevertheless, it needs to be recognized that the current design is an engineering
            compromise. But as such
            it is convenient to the purpose of this paper, because it exemplifies the fact that
            when you want to reuse
            streaming components, you will sometimes find that some of them have the wrong polarity.
         </div>
      </div><a name="CoroutinesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e240">
         <div class="title e241">Coroutines</div>
         <div class="para e242">Handling the push-pull conflict using multiple threads, as discussed in the previous
            section,
            is actually overkill. Threads offer two significant features: each thread has its
            own execution stack
            to maintain state, and each thread can be independently scheduled. We need the first
            feature, we don't need 
            the second. Or to put it another way, we don't really need threads at all: we need
            coroutines. (In fact,
            we can probably make do with the restricted kind of coroutine sometimes called a 
            
            <div class="emphasis e243" role="ital">generator</div>; but the terminology in this area varies). 
         </div>
         <div class="para e244">The key idea here is that two components can each be written as a loop, maintaining
            whatever
            data they wish in local variables within the loop. One component issues 
            <div class="code e245">write</div> calls
            within its loop to push data out; the other issues 
            <div class="code e246">read</div> calls within its loop to pull data in.
            When the writer issues its write request, control passes to the reader at the point
            where it issued its read 
            request; and when the reader issues its read request, control passes back to the writer
            so that it can
            compute its next output and write it.
         </div>
         <div class="para e247">Of course, this extends to a pipeline with more than two components. It also extends
            to a branching
            pipeline in which one component writes several output streams for consumption by different
            readers.
            And to a merging pipeline, in which one component reads from several input streams
            supplied by different
            writers. Essentially it means that as far as the programmer is concerned, there are
            no push or pull components
            any more: every component owns its own control loop. This, as we have seen, should
            simplify the programming
            of the component, and it should also improve reusability, since components are no
            longer restricted to operate
            in either a push or pull pipeline: they can work in both.
         </div>
         <div class="para e248">
            <div class="emphasis e249" role="ital">How come this doesn't lead to deadlocks? The answer is that you can't have
               a general graph of coroutines reading and writing to each other, as you can with threads.
               The coroutines are
               not true peers; there has to be a hierarchic control relationship represented by the
               way in which they
               are originally invoked.
            </div>
         </div>
         <div class="para e250">Unfortunately this concept, to be usable in practice, requires support from the programming
            language
            and compiler, which is rarely forthcoming in modern programming languages, though
            the 
            <div class="code e251">yield</div>
            construct found in Javascript and C# comes close.
         </div>
         <div class="para e252">However, XSLT is a programming language, and we are in control of its compiler, so
            this raises the
            question of whether user-level intra-stylesheet pipelines can indeed be implemented
            as coroutines.
            Specifically, can we generate code from XSLT templates such that the XSLT code that
            writes data to
            a temporary tree runs as a coroutine alongside the XSLT code that reads data from
            the temporary tree?
            In principle, one of the major benefits of having a stateless declarative language
            like XSLT is that
            the implemented execution model can diverge dramatically from the structure of the
            code as seen by its 
            author.
         </div>
         <div class="para e253">Clearly this is only going to work if the temporary tree is processed
            in a sequential manner. This caveat eliminates many cases: it reflects the fact that
            a push-pull
            conflict is not the only reason that pipelines break down; they also break because
            of ordering conflicts
            (data needs to be sorted), or because, in the case of a pull pipeline, data cannot
            be supplied to more than
            one client in a streamed manner. But if we work on the assumption, for the moment,
            that we can identify
            an XSLT process that reads a temporary tree in a sequential manner (we'll come back
            to this later), then in principle
            we should be able to run this as a coroutine alongside the process that writes the
            tree, without buffering
            the tree in memory.
         </div>
         <div class="para e254">At this point, it will be useful to rediscover the concept of program inversion, an
            idea
            from the days of sequential data processing using magnetic tape, that was designed
            
            specifically to tackle this problem.
         </div>
      </div><a name="JacksonStructuredProgrammingandtheConceptofInversionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e255">
         <div class="title e256">Jackson Structured Programming and the Concept of Inversion</div>
         <div class="para e257">Michael Jackson (not the singer) developed the method of program construction known
            as JSP (Jackson Structured Programming) initially as a way of designing the batch
            processing
            systems of the 1960s and early 1970s, characterised by their use of sequential 
            data files stored on open-reel magnetic tapes. The method is fully described in a
            1975 book
            [
            <div class="xref e258" linkend="Jackson1975"></div>], but most readers will find it easier to consult a 
            retrospective analysis written by Jackson in 2001 [
            <div class="xref e259" linkend="Jackson2001"></div>]
         </div>
         <div class="para e260">The files used in these systems were generally organized as a hierarchy (for example,
            customers, orders, then order lines) and were processed sequentially. There was insufficient
            main memory to hold more than a fraction of the file contents: a reel of magnetic
            tape held typically
            20Mb, while 128Kb of main memory was considered generous. So processing consisted
            of reading one or more
            tapes sequentially, typically a master file and a transaction file containing details
            of changes,
            merging the data from the multiple inputs, and then writing the output
            to another tape.
         </div>
         <div class="para e261">The essential principle of JSP was the idea that the structure of the program should
            mirror
            the structure of the data. JSP used a graphical notation to represent hierarchic structure
            embodying
            the basic elements of sequence, choice, and iteration, and this same notation was
            used to represent the
            structure both of the data and of the resulting program. The notation is illustrated
            in Figure 6.
            In his retrospective, Jackson acknowledges
            that the ideas he was advocating had a great deal in common with parallel developments
            in compiler-writing;
            his graphical notation was essentially a BNF schema for data files, and his program
            structure similar to 
            that of a recursive descent parser derived from that grammar. But of course no-one
            saw it that way at 
            the time: compiler technology was still in its infancy.
         </div>
         <div class="figure e262" xml:id="fig6">
            <div class="mediaobject e263">
               <div class="imageobject e264">
                  <div class="metaBox e265"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e517').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e517" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e265'
                           </span><span class="metaAttribute">fileref='../../../vol3/graphics/Kay01/Kay01-006.png'
                           </span><span class="metaAttribute">format='png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
               <div class="caption e266">
                  <div class="para e267">Fig 6. Jackson notation for sequence, iteration, and choice.</div>
               </div>
            </div>
         </div>
         <div class="para e268">So, what happens when the structure of the output file does not correspond in a simple
            way
            to the structure of the input? This is known as a 
            <div class="emphasis e269" role="ital">structure clash</div>.
            Jackson identified three kinds of structure clash:
         </div>
         <div class="itemizedlist e270">
            <div class="listitem e271">
               <div class="para e272">An 
                  <div class="emphasis e273" role="ital">interleaving clash</div>, typically involving
                  transformation of a single input sequence (all employees, say) into multiple output
                  sequences (employees by department)
               </div>
            </div>
            <div class="listitem e274">
               <div class="para e275">An 
                  <div class="emphasis e276" role="ital">ordering clash</div>, involving sorting the data
                  into a different order
               </div>
            </div>
            <div class="listitem e277">
               <div class="para e278">A 
                  <div class="emphasis e279" role="ital">boundary clash</div>, involving constructing
                  a new hierarchy for the existing records without changing their order (in the language
                  of the markup world,
                  this is the problem of parallel hierarchies running through the same data, with one
                  hierarchy being
                  primary in the input and a different hierarchy being primary in the output). 
               </div>
            </div>
         </div>
         <div class="para e280">Of these, the one that caused most problems in program design was the boundary clash,
            and
            Jackson's approach to solving it was to split the process into two phases, a flattening
            phase that
            eliminates the first hierarchy, followed by a grouping phase that imposes the second
            hierarchy.
            So we see that the notion of the pipeline as a mechanism for breaking down the processing
            of hierarchic data
            has a long pedigree.
         </div>
         <div class="para e281">In the world of magnetic tape, the problem was that the output of one phase of processing
            was typically
            written to tape, to be read again by the next phase. Since writing 20Mb of data to
            a tape could take an hour,
            this clearly created a problem, and this is where the idea of inversion comes into
            the picture.
         </div>
         <div class="para e282">Jackson recognized that the intermediate file could be eliminated if, instead of the
            second phase
            of processing owning its own control loop, it were rearranged to be called by the
            first program every time
            another record became available. JSP refers to this rearrangement as an inversion.
            Crucially, Jackson
            recognized that this did not necessarily mean that the second phase had to be written
            in what we would
            now call a “push” style: inversion was a mechanical transformation of a program text
            that could be performed
            by a compiler. Jackson went on to produce a COBOL preprocessor that automated this
            task.
         </div>
         <div class="para e283">Again there is a similarity with compiler technology. A bottom-up parser is an inversion
            of the
            top-down parser for the same grammar; whereas the top-down parser has the structure
            Jackson would advocate,
            mirroring the structure of the input file, the bottom-up equivalent is event-driven.
            The challenge in writing
            a correct bottom-up (push) parser for a complex grammar is considerable, because of
            the difficulty of
            maintaining state between calls; but the task can be automated given a high-level
            description of the
            grammar to be processed.
         </div>
         <div class="para e284">The relationship between a conversational application and a transactional one is another
            example
            of an inversion. A conversational application owns the control loop and issues write
            requests to talk to the
            user, and read requests to get their replies. This relies on the application retaining
            state in main memory (or
            paged out to secondary store) while waiting for user responses, which severely limits
            concurrency.
            A transactional application, whether written according to the conventions of a traditional
            mainframe TP 
            monitor or according to the more modern architecture of the web, is event-based: a
            message from the user
            activates the application, which has to retrieve the state of the conversation from
            some holding place,
            process the message, and then save the state again before replying to the user.
         </div>
         <div class="para e285">The UK mainframe manufacturer
            ICL developed a very successful fourth-generation application development environment
            under the name
            RADS (it was subsequently marketed as QuickBuild) [
            <div class="xref e286" linkend="Brown1981"></div>, 
            <div class="xref e287" linkend="Cosh1981"></div>]. 
            QuickBuild was designed according to JSP principles. 
            Interactive applications were written in a conversational style (as if they owned
            the control loop), and
            were then automatically compiled into transactional code - again, an automated inversion.
            A similar
            idea can also be seen in the scripting language used by the Cocoon framework [
            <div class="xref e288" linkend="cocoon-flow"></div>].
         </div>
         <div class="para e289">In all these examples, the user achieves the benefits that come from writing the application
            as a controlling application (maintainability, readability, reusability) combining
            these with the
            improvements in system performance that come from using a push-based control model.
         </div>
         <div class="para e290">How does inversion actually work? Essentially, whereever the application issues a
            read request
            for more data, this needs to be translated into instructions that save the state (including
            the reentry point),
            and exit. Then a new entry point needs to be created for the module, to be invoked
            when data becomes available,
            which restores the state and resumes execution at the correct entry point. Typically
            the state here means
            the data on the stack, together with the reentry point (or program counter). 
            This state is sometimes known as a 
            <div class="emphasis e291" role="ital">continuation</div>;
            some modern programming languages, even if they do not compile inverted code automatically,
            offer continuations
            as a way of achieving a similar effect by hand. The 
            <div class="code e292">yield</div> construct in C# is an example.
         </div>
         <div class="para e293">Inversion does not depend on a program being written in a declarative language like
            XSLT with
            no immutable variables. But it becomes a lot easier to analyze the language to determine
            what parts of the state
            are significant, and to avoid saving and restoring unnecessary parts of the state,
            if the language is
            sufficiently high level. The essential requirement is not that variables are immutable,
            but that it
            is clear from static analysis which variables need to be preserved as part of the
            state. In the case
            of XSLT, the term “variables” here includes the dynamic execution context: that is,
            the context item,
            position, and size, as well as more obscure context variables such as the current
            grouping key and current
            mode. The next section explores inversion of XSLT programs in more detail.
         </div>
      </div><a name="InversioninXSLTANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e294">
         <div class="title e295">Inversion in XSLT</div>
         <div class="para e296">Let's look at inversion in XSLT. Specifically, let's take a simple stylesheet and
            see how it can
            be compiled in such a way that it is driven by push events coming from the XML parser,
            and in turn
            drives the serializer by issuing similar push events. Such a stylesheet would be fully
            streamable,
            allowing execution without building either the source tree or the result tree in memory.
         </div>
         <div class="para e297">Clearly not all stylesheets are fully streamable in this way, and it's not the intent
            in this
            paper to try to define exactly what conditions a stylesheet must satisfy in order
            to be streamable.
            The XSL Working Group in W3C is currently working on this problem, and hopefully will
            publish its first
            results soon after the Balisage 2009 conference. The focus here is on a different
            problem:
            having determined the code is streamable in principle, how do we actually arrange
            the execution to
            perform streaming?
         </div><a name="InvertingasinglephasestylesheetANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e298">
            <div class="title e299">Inverting a single-phase stylesheet</div>
            <div class="para e300">We'll start with a single-phase stylesheet, one that is self-evidently streamable
               in that the push
               events needed to construct the result tree are a subsequence of the push events representing
               the source tree. 
               Hopefully if we can establish that a single-phase streamable
               stylesheet can be inverted, it should then be possible to see how multiple streamable
               phases can be
               pipelined together without allocating memory for buffering intermediate results.
            </div>
            <div class="para e301">Here is a simple stylesheet that deletes all the 
               <div class="code e302">NOTE</div> elements from a source
               document, wherever they appear.
            </div>
            <div class="programlisting e303" xml:space="preserve">
               &lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
               
               &lt;xsl:template match="*"&gt;
               &lt;xsl:copy&gt;
               &lt;xsl:copy-of select="@*"/&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/xsl:copy&gt;
               &lt;/xsl:template&gt;
               
               &lt;xsl:template match="NOTE"/&gt;
               
               &lt;/xsl:stylesheet&gt;
            </div>
            <div class="para e304">XSLT 2.0 describes the semantics of this code in terms of functional composition:
               
               
               <div class="code e305">xsl:apply-templates</div> is an expression that returns a result (which in this case will
               always be a sequence of elements); this sequence is then used as an operand of the
               containing
               instruction (
               <div class="code e306">xsl:copy</div>), which copies these elements, adding a new parent element to
               construct a larger tree at each stage of processing.
            </div>
            <div class="para e307">In practice, however, the execution model is likely to be closer to the way XSLT 1.0
               
               describes the semantics. The 1.0 specification talks of instructions writing nodes
               to the result tree:
               that is, of data being pushed to the next stage in the pipeline. It's easy to visualize
               the start
               and end tags of the 
               <div class="code e308">xsl:copy</div> instruction as if they were separate sub-instructions, one 
               pushing a 
               <div class="code e309">startElement</div> event to the result, the other pushing a matching 
               
               <div class="code e310">endElement</div> event.
            </div>
            <div class="para e311">One can see this effect at work in Saxon's XQuery compiler. Saxon-SA has the capability
               to compile
               XQuery to Java source code, which makes the execution strategy rather visible. Given
               this query:
            </div>
            <div class="programlisting e312" xml:space="preserve">
               &lt;e&gt;
               &lt;date&gt;{current-dateTime()}&lt;/date&gt;
               &lt;/e&gt; 
            </div>
            <div class="para e313">the resulting Java code (simplified only very slightly for comprehension) is:</div>
            <div class="programlisting e314" xml:space="preserve">
               public void process(final XPathContext context) throws XPathException {
               SequenceReceiver out = context.getReceiver();
               out.startElement(name_e, type_untyped);
               out.startElement(name_date, type_untyped);
               out.append(context.getCurrentDateTime());
               out.endElement();
               out.endElement();
               }
            </div>
            <div class="para e315">This query, of course, reads no data: it was chosen deliberately to show how the construction
               of the result tree is optimized away. Although Saxon's XSLT processor does not have
               the ability to generate
               Java code, the execution model of the interpreter follows the same pattern. If it
               did generate code, the
               code for the identity template in our example stylesheet would look something like
               this (this is idealized
               code; it leaves out messy details such as maintaining the context position):
            </div>
            <div class="programlisting e316" xml:space="preserve">
               public void template1234(final XPathContext context) throws XPathException {
               SequenceReceiver out = context.getReceiver();
               NodeInfo current = context.getCurrentNode();
               out.startElement(current.getNodeName(), type_untyped);
               Iterator attributes = current.iterateAxis(Axis.ATTRIBUTE);
               while (attributes.hasNext()) {
               NodeInfo attr = attributes.next();
               out.attribute(attr.getNodeName(), attr.getStringValue());
               }
               XPathContext context2 = context.newContext();
               Iterator children = current.iterateAxis(Axis.ATTRIBUTE);
               while (children.hasNext()) {
               NodeInfo child = children.next();
               applyTemplates(child, context2);
               }
               out.endElement();
               }      
               
            </div>
            <div class="para e317">We can see that this code is written in the form of a control loop. It reads its input
               using
               imperatives such as 
               <div class="code e318">children.next()</div> (and, indirectly, via 
               <div class="code e319">applyTemplate()</div>),
               and it writes its output using imperatives such as 
               <div class="code e320">startElement()</div> and 
               <div class="code e321">endElement()</div>.
               To make this code streamable with respect to the input from the parser, we need to
               invert it. It will 
               end up looking something like the code for the Saxon schema validator. This maintains
               a stack of
               element handlers, one for each currently open element; if an element is being processed
               by a template
               rule, then the element handler would be a class with methods 
               <div class="code e322">startElement()</div> and 
               
               <div class="code e323">endElement()</div> which for the identity template would look something like this:
            </div>
            <div class="programlisting e324" xml:space="preserve">
               public State startElement(final XPathContext context) throws XPathException {
               SequenceReceiver out = context.getReceiver();
               NodeInfo current = context.getCurrentNode();
               out.startElement(current.getNodeName(), type_untyped);
               return applyTemplatesState ;
               }
               
               public void endElement(final XPathContext context) throws XPathException {
               SequenceReceiver out = context.getReceiver();
               out.endElement();
               }        
               
            </div>
            <div class="para e325">The object 
               <div class="code e326">applyTemplatesState</div> is the 
               <div class="emphasis e327" role="ital">continuation</div>,
               the data that tells the despatcher what to do next: in this case, to select template
               rules to process
               the events representing children of this element, adding those templates to the stack
               of state information.
            </div>
            <div class="para e328">The inversion of a template will not always be as simple as this, of course. In general
               on exit from
               the 
               <div class="code e329">startElement()</div> call, all information about current variables and the current context
               needs to be saved on a stack, and restored from the stack when 
               <div class="code e330">endElement()</div> is called.
               If the template contains an 
               <div class="code e331">xsl:choose</div> instruction, the retained state information will need
               to remember which branch of the choice is active, and so on.
            </div>
            <div class="para e332">If the template uses 
               <div class="code e333">xsl:for-each</div> to process the children of the context node,
               the simplest way to handle this is probably by rewriting the 
               <div class="code e334">xsl:for-each</div> as a call
               on 
               <div class="code e335">xsl:apply-templates</div> in some singular mode, passing all the in-scope variables as parameters.
               This reduces the number of cases that need to be handled by the inversion logic. Other
               more complex constructs
               such as 
               <div class="code e336">xsl:for-each-group</div>, however, still need individual treatment if they are to be made
               amenable to streaming.
            </div>
         </div><a name="InvertingamultiphasestylesheetANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e337">
            <div class="title e338">Inverting a multi-phase stylesheet</div>
            <div class="para e339">A multi-phase stylesheet typically uses a temporary tree (or sequence) in a variable
               to hold the intermediate results that form the output of one phase and the input to
               the next.
               Ideally each phase will use a different mode:
            </div>
            <div class="programlisting e340" xml:space="preserve">
               &lt;xsl:variable name="phase1output"&gt;
               &lt;xsl:apply-template select="/" mode="m1"/&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:variable name="phase2output"&gt;
               &lt;xsl:apply-templates select="$phase1output" mode="m2"/&gt;
               &lt;/xsl:variable&gt;
               
               &lt;xsl:template match="/"&gt;
               &lt;xsl:apply-templates select="$phase2output" mode="m3"/&gt;
               &lt;/xsl:template&gt;
               
            </div>
            <div class="para e341">Provided it can be established that the processing of a temporary tree such as
               
               <div class="code e342">phase1output</div> is streamable (which, as we have said, is beyond the scope of this
               paper), there is essentially no additional difficulty in pipelining the different
               phases
               together in such a way that the intermediate results are not buffered in memory. Phase
               1 writes
               to 
               <div class="code e343">phase1output</div> by pushing events; the inverted code for phase 2 is immediately activated
               to process these events as they occur.
            </div>
         </div><a name="Mustitbepushedorcanitbepulled?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e344">
            <div class="title e345">Must it be pushed, or can it be pulled?</div>
            <div class="para e346">The previous sections describe how XSLT code, considered as a control loop, can be
               inverted
               with respect to its input, so that it acts as a push filter, processing events originating
               from the
               previous phase of processing.
            </div>
            <div class="para e347">It's reasonable to ask whether one could not equally well invert the code with respect
               to its
               output, so that it acts as a pull filter, responding to requests for more data originating
               from
               the subsequent phase of processing, that is, from the consumer of its output.
            </div>
            <div class="para e348">The answer is that this is also possible, though I have not explored this avenue in
               as much
               detail: because the Saxon serializer and schema validators work only in push polarity,
               there is a strong
               tendency to use push polarity for everything else as well.
            </div>
            <div class="para e349">We have already seen that the key difference between push and polarity is that a push
               component can send data to multiple recipients, whereas a pull component can read
               data from multiple
               sources. XSLT in its current form has few constructs that requires the ability to
               stream input from multiple sources in parallel (the example of the 
               <div class="code e350">deep-equal()</div> function
               was a little contrived). An 
               <div class="code e351">xsl:merge</div> instruction is under consideration
               for XSLT 2.1, and one can see how this would benefit from streamed processing in pull
               polarity.
               Meanwhile it should be evident how the ability of push pipelines to branch to multiple
               destinations could be
               exploited in cases where one component in a pipeline writes temporary data to a variable,
               and
               two separate components both read from this variable. If both these components are
               streamable, there
               is no reason why the fact that the variable has more than one reader should result
               in it being
               buffered in memory; the events generated by the component that writes to the variable
               can be broadcast
               to all the readers of the variable, provided that each of them is streamable with
               respect to that
               variable.
               
            </div>
            <div class="para e352">So, inversion into pull polarity is possible, but inversion to push code seems to
               have
               more practical utility at present.
            </div>
         </div>
      </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e353">
         <div class="title e354">Conclusions</div>
         <div class="para e355">Pipelines have been recognized for many years as a good way to structure XML applications,
            and the emergence of XProc as a standard language for describing pipelines can only
            encourage this.
            For performance, the stages of a pipeline should communicate by means of streams of
            events.
            Traditionally, this can be done either by writing components with pull polarity (the
            consumer calls
            the supplier when data is required), or by components with push polarity (the supplier
            calls the consumer
            when data is available). Performance problems arise when components with different
            polarity are mixed
            within the same pipeline.
         </div>
         <div class="para e356">This is seen within the internal pipelining of an XSLT processor. The scaleability
            of XSLT is limited
            because most processors build the source tree in memory. This is sometimes needed
            because the transformation
            accesses the data not in its original order; but in many cases the tree is built only
            because of the polarity
            clash that exists between the push operation used by the XML parser and validator,
            and the pull operation
            used by the XPath processor when navigating the tree. Many XSLT processors avoid building
            the result tree
            in memory, and this is because there is no polarity clash: the XSLT instruction evaluation
            and the result tree
            serialization both operate with push polarity.
         </div>
         <div class="para e357">This problem is not new. Jackson tackled it when designing batch processing systems
            using magnetic tape.
            He formalized the concepts of structure clashes that prevent streamed operation, and
            he developed the idea
            of program inversion as a way of automatically transforming a pull program to a push
            program or vice versa.
            What this paper has attempted to do is to demonstrate that the same ideas can be applied
            to the XML-based
            pipeline systems of today. As the usage of XML increases and more and more users find
            themselves applying
            languages like XSLT and XQuery to multi-gigabyte datasets, a technology that can remove
            the problems
            caused by pipeline polarity clashes has great potential.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e358">
         <div class="title e359">Bibliography</div>
         <div class="bibliomixed e360" xml:id="cocoon" xreflabel="Cocoon">Apache Cocoon. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e361" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://cocoon.apache.org/</div>
         </div>
         <div class="bibliomixed e362" xml:id="cocoon-flow" xreflabel="Cocoon Flow">Advanced Control Flow: Cocoon and continuations. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e363" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://cocoon.apache.org/2.1/userdocs/flow/how-does-it-work.html</div>
         </div>
         <div class="bibliomixed e364" xml:id="Brown1981" xreflabel="Brown1981">A. P. G. Brown, H. G. Cosh, and D. J. L Gradwell.
            Database Processing in RADS - Rapid Application Development System. In Proc 1st British
            National Conf.
            on Databases (BNCOD-1), Cambridge, 1981
         </div>
         <div class="bibliomixed e365" xml:id="Cosh1981" xreflabel="Cosh1981">H. G. Cosh, A. P. G. Brown, and D. J. L Gradwell.
            RADS - ICL's Rapid Application Development System. In Proc 3rd Conf of European Cooperation
            in Informatics,
            Munich, 1981. Springer, ISBN 3-540-10855-8
         </div>
         <div class="bibliomixed e366" xml:id="Jackson1975" xreflabel="Jackson1975">Michael A Jackson.
            Principles of Program Design. Academic Press, 1975
         </div>
         <div class="bibliomixed e367" xml:id="Jackson2001" xreflabel="Jackson2001">Michael A. Jackson. 
            JSP in Perspective. sd&amp;m Pioneers' Conference, Bonn, June 2001.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e368" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://mcs.open.ac.uk/mj665/JSPPers1.pdf</div>
         </div>
         <div class="bibliomixed e369" xml:id="Kay2001" xreflabel="Kay2001">Michael Kay. Saxon: Anatomy of an XSLT Processor. IBM DeveloperWorks, Feb 2001.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e370" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ibm.com/developerworks/library/x-xslt2/</div>
         </div>
         <div class="bibliomixed e371" xml:id="Kay2008" xreflabel="Kay2008">Michael Kay. Ten Reasons why Saxon XQuery is Fast. 
            IEEE Data Engineering Bulletin, 31(4):65-, Dec 2008.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e372" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://sites.computer.org/debull/A08dec/saxonica.pdf</div>
         </div>
         <div class="bibliomixed e373" xml:id="McGrath2002" xreflabel="McGrath2002">Sean McGrath. 
            XPipe — A Pipeline Based Approach To XML Processing, Proc. XML Europe 2002, Barcelona,
            Spain, May 2002.
         </div>
         <div class="bibliomixed e374" xml:id="McGrath2004" xreflabel="McGrath2004">Sean McGrath. 
            Performing impossible feats of XML processing with pipelining, Proc XML Open 2004,
            
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e375" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://seanmcgrath.blogspot.com/pipelines.ppt</div> (Microsoft Powerpoint)
         </div>
         <div class="bibliomixed e376" xml:id="orbeon" xreflabel="Orbeon">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e377" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.orbeon.com/</div>
         </div>
         <div class="bibliomixed e378" xml:id="saxon" xreflabel="Saxon">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e379" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.saxonica.com/</div>
         </div>
         <div class="bibliomixed e380" xml:id="saxon-streaming" xreflabel="Saxon Streaming">Streaming of Large Documents (in the Saxon documentation).
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e381" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.saxonica.com/documentation/sourcedocs/serial.html</div>
         </div>
         <div class="bibliomixed e382" xml:id="serialization" xreflabel="W3C Serialization">Scott Boag et al, eds. XSLT 2.0 and XQuery 1.0 Serialization.
            W3C Recommendation, 23 January 2007.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e383" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-xquery-serialization/</div>
         </div>
         <div class="bibliomixed e384" xml:id="Thompson2001" xreflabel="Thompson2001">Henry S. Thompson. 
            The XML Meta-Architecture. Presented at XML DevCon, London, Feb 2001. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e385" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.ltg.ed.ac.uk/~ht/XML_MetaArchitecture.html</div>
         </div>
         <div class="bibliomixed e386" xml:id="xproc" xreflabel="W3C XProc">Norman Walsh, Alex Milowski, and Henry S. Thompson, eds. 
            XProc: An XML Pipeline Language. W3C Candidate Recommendation, 26 November 2008.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e387" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xproc/</div>
         </div>
         <div class="bibliomixed e388" xml:id="xsd" xreflabel="W3C XML Schema">Henry S. Thompson et al, eds. 
            XML Schema Part1: Structures. 2nd Edition. W3C Recommendation, 28 October 2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e389" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xproc/</div>
         </div>
      </div>
   </div>
</div>