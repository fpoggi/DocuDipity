<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#TypeIntrospectioninXQueryANCHOR" name="TypeIntrospectioninXQueryTOC">Type Introspection in XQuery</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#TypesasValuesANCHOR" name="TypesasValuesTOC">Types as Values</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TypeTestsforTypeValuesANCHOR" name="TypeTestsforTypeValuesTOC">Type Tests for Type Values</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ObtainingTypeValuesANCHOR" name="ObtainingTypeValuesTOC">Obtaining Type Values</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FunctionsandOperatorsonTypeValuesANCHOR" name="FunctionsandOperatorsonTypeValuesTOC">Functions and Operators on Type Values</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TypeValuesasFunctionsANCHOR" name="TypeValuesasFunctionsTOC">Type Values as Functions</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ComponentAccessorsANCHOR" name="ComponentAccessorsTOC">Component Accessors</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#OtherSchemaComponentValuesANCHOR" name="OtherSchemaComponentValuesTOC">Other Schema Component Values</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FacetsANCHOR" name="FacetsTOC">Facets</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ElementandAttributeDeclarationsANCHOR" name="ElementandAttributeDeclarationsTOC">Element and Attribute Declarations</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationConsiderationsANCHOR" name="ImplementationConsiderationsTOC">Implementation Considerations</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#FutureDirectionsANCHOR" name="FutureDirectionsTOC">Future Directions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MoreAccessorsFunctionsandOperatorsANCHOR" name="MoreAccessorsFunctionsandOperatorsTOC">More Accessors, Functions, and Operators</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RelationshiptoSchemaComponentPathsANCHOR" name="RelationshiptoSchemaComponentPathsTOC">Relationship to Schema Component Paths</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#SummaryandConclusionsANCHOR" name="SummaryandConclusionsTOC">Summary and Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReferencesANCHOR" name="ReferencesTOC">References</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">attribute-decl() or attribute-decl(*)</div>
         <div class="singletermTERMS">attribute-decl(q:name)</div>
         <div class="singletermTERMS">annotation::</div>
         <div class="singletermTERMS">anonymous</div>
         <div class="singletermTERMS">Apocalypse 12: Objects; number 12 version 8.</div>
         <div class="singletermTERMS">August 7 - 10, 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2012</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">cast as</div>
         <div class="singletermTERMS">castable as</div>
         <div class="singletermTERMS">Class</div>
         <div class="singletermTERMS">component()</div>
         <div class="singletermTERMS">complex-type()</div>
         <div class="singletermTERMS">complex-type(*)</div>
         <div class="singletermTERMS">complex-type(q:name)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">dynamic_cast</div>
         <div class="singletermTERMS">deep-equal</div>
         <div class="singletermTERMS">document-node</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">equals</div>
         <div class="singletermTERMS">element-decl() or element-decl(*)</div>
         <div class="singletermTERMS">element-decl(q:name)</div>
         <div class="singletermTERMS">element</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">fn:subsequence</div>
         <div class="singletermTERMS">fn:string</div>
         <div class="singletermTERMS">fn:boolean</div>
         <div class="singletermTERMS">fn:not</div>
         <div class="singletermTERMS">fn:deep-equal</div>
         <div class="singletermTERMS">fn:data</div>
         <div class="singletermTERMS">facet() or facet(*)</div>
         <div class="singletermTERMS">facet(q:name)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
         <div class="singletermTERMS">Holstege</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">instanceof</div>
         <div class="singletermTERMS">isa</div>
         <div class="singletermTERMS">instance of</div>
         <div class="singletermTERMS">Introspective C++</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">model::</div>
         <div class="singletermTERMS">my:special-stuff</div>
         <div class="singletermTERMS">Meta Programming and Reflection in PHP</div>
         <div class="singletermTERMS">mary.holstege@marklogic.com</div>
         <div class="singletermTERMS">Mary</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">outer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">p:outer</div>
         <div class="singletermTERMS">p:inner</div>
         <div class="singletermTERMS">p:second</div>
         <div class="singletermTERMS">p:duplicate</div>
         <div class="singletermTERMS">Principal Engineer</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">run-plugin</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">simple-type()</div>
         <div class="singletermTERMS">simple-type(*)</div>
         <div class="singletermTERMS">simple-type(q:name)</div>
         <div class="singletermTERMS">sc</div>
         <div class="singletermTERMS">sc:type([$context as item()]) as type()?</div>
         <div class="singletermTERMS">sc:simple-type</div>
         <div class="singletermTERMS">sc:complex-type</div>
         <div class="singletermTERMS">sc:type</div>
         <div class="singletermTERMS">subtype of</div>
         <div class="singletermTERMS">sc:type-named($qname as xs:QName) as type()</div>
         <div class="singletermTERMS">sc:name([$context as component()]) as xs:QName?</div>
         <div class="singletermTERMS">sc:base-type([$context as component()]) as type()</div>
         <div class="singletermTERMS">sc:facets</div>
         <div class="singletermTERMS">sc:name</div>
         <div class="singletermTERMS">sc:facets([$context as item()]) as facet()*</div>
         <div class="singletermTERMS">sc:element-decl</div>
         <div class="singletermTERMS">sc:attribute-decl</div>
         <div class="singletermTERMS">sc:term([$context as component()]) as term()</div>
         <div class="singletermTERMS">sc:annotations</div>
         <div class="singletermTERMS">schemaElement::</div>
         <div class="singletermTERMS">schemaAttribute::</div>
         <div class="singletermTERMS">sequence</div>
         <div class="singletermTERMS">sc:schema</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">treat as</div>
         <div class="singletermTERMS">typeswitch</div>
         <div class="singletermTERMS">type()</div>
         <div class="singletermTERMS">type(*)</div>
         <div class="singletermTERMS">type(q:name)</div>
         <div class="singletermTERMS">type::</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">The ANSI C++ Standard (ISO/IEC 14882)</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">validate as</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xs:untyped</div>
         <div class="singletermTERMS">xs:untypedAtomic</div>
         <div class="singletermTERMS">xs:anyType</div>
         <div class="singletermTERMS">xs:annotation</div>
         <div class="singletermTERMS">XPath and XQuery Functions and Operators 3.0</div>
         <div class="singletermTERMS">XQuery 3.0: An XML Query Language</div>
         <div class="singletermTERMS">XQuery and XPath Data Model 3.0</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="TypeIntrospectioninXQueryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Type Introspection in XQuery</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2012</div>
            <div class="confdates e5">August 7 - 10, 2012</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Type introspection gives a program the ability to determine the
               type of object at runtime and manipulate the type of the object as an object
               in its own right. It can be used as a basis for generic and flexible services,
               meta-programming, runtime adaptation, and data exploration and discovery. This
               paper explores providing some type introspection capabilities to XQuery,
               looking at some design and implementation issues, and demonstrating the
               application of type introspection in various ways.
               
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Mary</div>
               <div class="surname e11">Holstege</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Mary Holstege is Principal Engineer at MarkLogic
                  Corporation.  She has worked as a software engineer in and around markup
                  technologies for over 20 years.  She is a member of the W3C XML Schema and XML
                  Query working groups, and an editor of the W3C XML Schema Component Designators
                  and the XML Query Full Text specifications.  Mary Holstege holds a Ph.D. from
                  Stanford University in Computer Science, for a thesis on document
                  representation.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Principal Engineer</div>
               <div class="orgname e16">MarkLogic Corporation</div>
            </div>
            <div class="email e17">mary.holstege@marklogic.com</div>
         </div>
         <div class="legalnotice e18">
            <div class="para e19">Copyright Â© 2012 Mary Holstege</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e20">
         <div class="title e21">Introduction</div>
         <div class="para e22">Type introspection gives a program the ability to determine the
            type of data item at runtime and manipulate the type as a data item in
            its own right. It allows the creation of more generic and flexible
            data-processing frameworks, and allows operations to be constructed in a
            more data-driven way. Type introspection also enables data exploration and
            discovery. This paper explores one way of providing type introspection
            capabilities to XQuery, looks at some design and implementation issues, and
            shows the application of type introspection in various ways.
            
         </div>
         <div class="para e23">It may seem odd to talk about type introspection in the context of
            XQuery, given that it is not an object-oriented language, and meta-classes and
            type introspection are object-oriented concepts. However, XQuery does have the
            concept of a type hierarchy with subtypes and supertypes. Instance variables
            can be statically identified as being of one type, while being
            dynamically instances of some subtype. Instead of
            classic objects and base types, XQuery has XML nodes and base (atomic) types.
            Adding structural type introspection to XQuery brings powerful
            meta-programming patterns to XML.
            
         </div>
         <div class="para e24">Many programming languages offer some kind of reflection or
            introspection. These terms are frequently used somewhat
            interchangeably. Gabriel 
            et al 
            <div class="citation e25" linkend="clos"></div> define reflection as "the ability of a program
            to manipulate as data something representing the state of the program during
            its own execution", and divide it into two parts: introspection and
            effectuation. Introspection is the observational aspect of reflection;
            effectuation is the active aspect, the making of changes to the program state. 
            Singh 
            <div class="citation e26" linkend="introc"></div> usefully distinguishes between
            type identification, structural introspection, and behavioural introspection.
            Type identification allows a program to determine whether an object is an
            instance of a particular class (or type). Structural introspection provides the
            programmatic means to examine attributes of the class, such as its
            base class and members. Behavioural introspection allows for the examination of
            the runtime operations of a program. In this paper, we are concerned with type
            introspection, and so we will not address behavioural introspection further.
            
         </div>
         <div class="para e27">Some form of type identification is common
            to many programming languages. For example, the Java or PHP
            
            <div class="code e28">instanceof</div>, the C++ 
            <div class="code e29">dynamic_cast</div>, the Perl
            
            <div class="code e30">isa</div> all provide for type identification, where 
            the reference type is named statically and must be known at compile time.
            XQuery 
            <div class="citation e31" linkend="xq30"></div> provides for this form of type
            identification too, through the 
            <div class="code e32">instance of</div> keyword pair.
            
         </div>
         <div class="figure e33" xml:id="fig_type_id">
            <div class="title e34">Type Identification Examples</div>
            <div class="programlisting e35" xml:space="preserve">
               /* C++ example */
               QName* name = dynamic_cast&lt;QName*&gt;(&amp;value);
               if (name != 0) {
               cout &lt;&lt; name-&gt;namespaceURI();
               }
               
               /* Java example */
               if (value instanceof QName) {
               QName qn = (QName)value;
               System.out.println(qn.namespaceURI());
               }
               
               (: XQuery example :)
               if ($value instance of xs:QName) {
               fn:namespace-uri-from-QName($value)
               }
               
            </div>
            <div class="caption e36">
               <div class="para e37">Examples of type identification in several languages.</div>
            </div>
         </div>
         <div class="para e38">XQuery allows for named types to be applied in several ways:
            through the use of the 
            <div class="code e39">instance of</div>, 
            <div class="code e40">cast as</div>, 
            
            <div class="code e41">treat as</div>, and (in XQuery 3.0) 
            <div class="code e42">validate as</div>
            constructs, and through the use of sequence type matching in 
            
            <div class="code e43">typeswitch</div> and argument or variable binding constructs. A program
            can use the constructs to ensure that data is properly typed in accordance with
            the assumptions of processing and dispatch to the appropriate processing for
            the type. 
         </div>
         <div class="para e44">Consider, for example, writing some code to analyze dates in
            documents of various kinds, where the documents may use different kinds of
            dates. Suppose further the documents come in a variety of forms and we do not
            necessarily have schemas for every document, although we do have schemas
            defining each date format. If a document has a schema, then a
            
            <div class="code e45">typeswitch</div> or 
            <div class="code e46">instance of</div> test could be used to
            determine which analysis function to apply, and type sequence matching could be
            used to ensure that the analysis code is applied properly to ensure
            correctness. In other cases 
            <div class="code e47">castable as</div> and 
            <div class="code e48">cast as</div>
            can be used to perform this job.
            
            <div class="xref e49" linkend="fig_dateex_1"></div> shows a fragment of XQuery dispatching to the
            appropriate analysis code along these lines.
         </div>
         <div class="figure e50" xml:id="fig_dateex_1">
            <div class="title e51">XQuery Type-Based Dispatch</div>
            <div class="programlisting e52" xml:space="preserve">
               import module iso="http://example.com/dates/iso";
               import module vat="http://example.com/dates/vatican";
               ...
               
               declare function my:process-date($date) 
               {
               if ($date castable as iso:date) 
               then iso:process-date($date cast as iso:date)
               else if ($date castable as vat:date)
               then vat:process-date($date cast as vat:date)
               (: etc. one for each format :)
               ...
               };  
               
            </div>
            <div class="caption e53">
               <div class="para e54">XQuery fragment for dispatching based on hard-coded type
                  tests and functions.
               </div>
            </div>
         </div>
         <div class="para e55">
            In all the XQuery constructs, the type must be a named type,
            and its properties cannot be inspected, compared, or reapplied. In particular,
            any annotations or facets associated with the type are not accessible to the
            program directly. One cannot ask
            for the type of one item and use it in any way to construct a new instance of
            that type. The code must explicitly reference the names of any types it needs.
            
         </div>
         <div class="para e56">Many languages also provide for structural introspection as well as
            type identification. Java's 
            <div class="code e57">Class</div> class and the reflection API
            
            <div class="citation e58" linkend="java"></div> and Perl 6's 
            <div class="citation e59" linkend="perl"></div> class traits
            and methods allow for structural reflection.
            Use of a meta-class in this way is the common pattern
            for providing structural introspection. It generally also allows for more
            dynamic type introspection, as well as dynamic instance construction.
            XQuery does not provide for this kind of type introspection. The rest of this
            paper explores adding structural type introspection to XQuery.
            
         </div>
         <div class="figure e60" xml:id="fig_struct_intro">
            <div class="title e61">Structural Introspection Examples</div>
            <div class="programlisting e62" xml:space="preserve">
               Class myClass = value.class;
               Class paramTypes[] new Class[1];
               paramTypes[0] = String.TYPE;
               Constructor ct = myClass.getConstructor(paramTypes);
               Object args[] = new Object[1];
               args[0] = new String("Hello World");
               Object newObject ct.newInstance(args);
               
            </div>
            <div class="caption e63">
               <div class="para e64">Example of Java structural introspection. We get the class
                  of a particular value, find a constructor that takes a string argument, and
                  construct a new instance of the class.
               </div>
            </div>
         </div>
         <div class="para e65">XQuery 3.0 introduces a couple of new features that interact well
            with type introspection: function items and the simple mapping operator
            (represented with the ! character). Function items allow functions to be
            treated as values, assigned to variables, and passed as arguments to
            functions. As we will see below, in some cases we will treat types as function
            items for some purposes. Beyond that, however, putting function names in schema
            annotations makes it possible to write generic data-driven processing
            frameworks, by using the introspection API to obtain the name of the function
            to perform some particular operation, and the function lookup and function
            application features to execute that operation. The simple mapping operator
            allows for mapping of non-node values in streamlined path-like
            expressions. Many of the examples that follow use one or the other of these
            constructs. Expressions involving the simple mapping operator could be
            rewritten in other ways, but use of function items cannot be readily
            replaced in an XQuery 1.0 setting. I will point out alternatives where they
            exist. 
            
         </div>
      </div><a name="TypesasValuesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e66">
         <div class="title e67">Types as Values</div>
         <div class="para e68">Where should XQuery meta-classes fit into the existing classes in
            the type hierarchy? What do the classes look like?
            XQuery has a complex type system, integrating simple and complex types from
            XML Schema 
            <div class="citation e69" linkend="xsd11dt"></div>, node kinds from the XQuery and XPath
            data model 
            <div class="citation e70" linkend="xq30dm"></div>, as well as special item
            types such as function items. 
            
         </div>
         <div class="figure e71" xml:id="fig_xq30">
            <div class="title e72">XQuery 3.0 Type Hierarchy</div>
            <div class="mediaobject e73">
               <div class="imageobject e74">
                  <div class="metaBox e75"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e147').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e147" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e75'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Holstege01/Holstege01-001.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='75%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e76">
               <div class="para e77">The diagram shows the main branches in the XQuery 3.0 type
                  hierarchy. Diamonds represent abstract types.  See the XPath data model 
                  <div class="citation e78" linkend="xq30dm"></div> for more details.
               </div>
            </div>
         </div>
         <div class="para e79">XML Schema 
            <div class="citation e80" linkend="xsd11st"></div> defines a complex set of
            schema component types. Each schema component has its own collection of
            properties, some of which are components themselves. For example, among the
            properties on a simple type definition are its name, a base type definition, a
            primitive type definition, an indicator of constraints on deriving new
            subtypes, whether it is a list or union type, and a variety of facets
            indicating additional constraints such as the maximum permitted value.
            
         </div>
         <div class="para e81">For our purposes, adding richer type introspection to XQuery
            amounts to creating values that represent schema components and providing
            mechanisms for accessing those components and their their properties.
            
         </div>
         <div class="para e82">Values representing types have some similarities with nodes
            and function items. Like nodes, schema components are complex objects with many
            properties, such as names. However, most of the accessors for nodes do not
            apply to schema components and most operations on nodes do not apply to schema
            components. In XQuery, every simple type also creates an implicit constructor
            function. In this sense, simple types act as function items. We could perhaps 
            make type values a kind of function item. However, type values are different
            from function items in every other way, and other schema components are not
            like functions at all. Values representing key schema components will be placed
            in the XQuery type hierarchy as a new kind of item. 
            
         </div>
         <div class="para e83">
            There are two kinds of type definition component: simple type definitions and
            complex type definitions. Corresponding to each of these components is a
            component value, one for simple type definitions and one for complex type
            definitions. Since the distinction
            between a simple type and a complex type matters in some cases (values can
            only be cast to simple types, for example), but not in others (when we don't
            know whether a particular element has a simple type definition or a complex
            type definition, but we want to know its name, regardless), we introduce a
            superclass "type definition" that encompasses both simple type definitions and
            complex type definitions. 
            
         </div>
         <div class="figure e84" xml:id="fig_type">
            <div class="title e85">Type Values</div>
            <div class="mediaobject e86">
               <div class="imageobject e87">
                  <div class="metaBox e88"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e169').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e169" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e88'
                           </span><span class="metaAttribute">fileref='../../../vol8/graphics/Holstege01/Holstege01-002.png'
                           </span><span class="metaAttribute">format='png'
                           </span><span class="metaAttribute">width='75%'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e89">
               <div class="para e90">Type values as component values, a new kind of item()</div>
            </div>
         </div>
         <div class="para e91">Integrating these new value types into XQuery involves:
            
            <div class="itemizedlist e92">
               <div class="listitem e93">
                  <div class="para e94">Defining sequence type tests</div>
               </div>
               <div class="listitem e95">
                  <div class="para e96">Defining the means to obtain type values from other values</div>
               </div>
               <div class="listitem e97">
                  <div class="para e98">Determining how existing functions and operators apply to type values</div>
               </div>
               <div class="listitem e99">
                  <div class="para e100">Defining useful functions and operators over type values</div>
               </div>
               <div class="listitem e101">
                  <div class="para e102">Defining accessors on type values</div>
               </div>
            </div>
            
         </div>
         <div class="para e103">Let's look at each of these steps in turn.</div><a name="TypeTestsforTypeValuesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e104">
            <div class="title e105">Type Tests for Type Values</div>
            <div class="para e106">For each kind of component value there is a sequence type test that
               matches values of that kind. Since types might have names, sequence type tests
               for type values can have a QName and will match if either the type has that
               name or it has a base type that matches.
               
            </div>
            <div class="figure e107" xml:id="fig_type_tests">
               <div class="title e108">Sequence Type Tests: Types</div>
               <div class="variablelist e109">
                  <div class="varlistentry e110">
                     <div class="term e111">
                        <div class="code e112">component()</div>
                     </div>
                     <div class="listitem e113">
                        <div class="para e114">Matches any component value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e115">
                     <div class="term e116">
                        <div class="code e117">type()</div> or 
                        <div class="code e118">type(*)</div>
                     </div>
                     <div class="listitem e119">
                        <div class="para e120">Matches any type component value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e121">
                     <div class="term e122">
                        <div class="code e123">type(q:name)</div>
                     </div>
                     <div class="listitem e124">
                        <div class="para e125">Matches any type component whose name matches the
                           given QName, or which is a subtype of a component with that type.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e126">
                     <div class="term e127">
                        <div class="code e128">simple-type()</div> or 
                        <div class="code e129">simple-type(*)</div>
                     </div>
                     <div class="listitem e130">
                        <div class="para e131">Matches any simple type component value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e132">
                     <div class="term e133">
                        <div class="code e134">simple-type(q:name)</div>
                     </div>
                     <div class="listitem e135">
                        <div class="para e136">Matches any simple type component whose name matches the
                           given QName, or which is a subtype of a component with that type.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e137">
                     <div class="term e138">
                        <div class="code e139">complex-type()</div> or 
                        <div class="code e140">complex-type(*)</div>
                     </div>
                     <div class="listitem e141">
                        <div class="para e142">Matches any complex type component value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e143">
                     <div class="term e144">
                        <div class="code e145">complex-type(q:name)</div>
                     </div>
                     <div class="listitem e146">
                        <div class="para e147">Matches any complex type component whose name matches the
                           given QName, or which is a subtype of a component with that type.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div><a name="ObtainingTypeValuesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e148">
            <div class="title e149">Obtaining Type Values</div>
            <div class="para e150">Linkage functions get component values from various kinds of
               items. They are defined over all kinds of items, returning the empty sequence
               if necessary. These functions all take any item as a parameter and have a
               zero-argument form that applies to the context item. This is a small usability
               feature, but makes such expressions as
               
               <div class="code e151">/root/child/sc:simple-type()</div> possible.
               
            </div>
            <div class="para e152">In this paper, the schema component linkage and accessor functions
               are all defined as being in the namespace bound to the prefix 
               <div class="code e153">sc</div>
               which the examples assume to be predefined. The specific namespace chosen is
               not important. The experimental implementation used
               
               <div class="code e154">http://marklogic.com/xdmp/schema-components</div>. 
               
            </div>
            <div class="figure e155" xml:id="fig_linkage_api">
               <div class="title e156">Accessors Linking from Items to Component Values</div>
               <div class="variablelist e157">
                  <div class="varlistentry e158">
                     <div class="term e159">
                        <div class="code e160">sc:type([$context as item()]) as type()?</div>
                     </div>
                     <div class="listitem e161">
                        <div class="para e162">Get the type of the item as a value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e163">
                     <div class="term e164">
                        <div class="code e165">sc:simple-type([$context as item()]) as simple-type()?</div>
                     </div>
                     <div class="listitem e166">
                        <div class="para e167">Get the simple type of the item as a value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e168">
                     <div class="term e169">
                        <div class="code e170">sc:complex-type([$context as item()]) as complex-type()?</div>
                     </div>
                     <div class="listitem e171">
                        <div class="para e172">Get the complex type of the item as a value.</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e173">XQuery introduces an interesting wrinkle that is not found in most
               other programming language type systems: some data may be untyped. The special
               types 
               <div class="code e174">xs:untyped</div> and 
               <div class="code e175">xs:untypedAtomic</div> represent such
               untyped complex and simple content.
               
            </div>
            <div class="para e176">For atomic values that are instances of a particular simple type,
               the 
               <div class="code e177">sc:simple-type</div> linkage function returns that simple type as a
               component value. If the atomic type is untyped, then a simple type definition value
               for 
               <div class="code e178">xs:untypedAtomic</div> is returned. The accessor
               
               <div class="code e179">sc:simple-type</div> operates on attribute nodes in a similar fashion.
               The operation on element nodes is similar, except that if
               the element is an instance of a complex type, 
               <div class="code e180">sc:simple-type</div>
               returns the empty sequence. For other kinds of items, the empty sequence is returned.
               
            </div>
            <div class="para e181">The linkage function 
               <div class="code e182">sc:complex-type</div> works analogously
               like 
               <div class="code e183">sc:simple-type</div> except atomic values and attributes can never
               be instances of a complex type, so 
               <div class="code e184">sc:complex-type</div> is only useful
               for element nodes. If an element node is an instance of a specific
               complex type, the value will be that complex type as a component value. If the
               element node is untyped, 
               <div class="code e185">xs:untyped</div> will be returned as a complex type
               component value. When an element is an instance of a simple type,
               
               <div class="code e186">sc:complex-type</div> returns 
               <div class="code e187">xs:anyType</div> as a complex type component
               value. For other items, the empty sequence is returned.
               
            </div>
            <div class="para e188">The 
               <div class="code e189">sc:type</div> accessor combines certain aspects of the
               
               <div class="code e190">sc:simple-type</div> and 
               <div class="code e191">sc:complex-type</div> accessors. It
               returns a type definition of the appropriate kind. For untyped element nodes,
               
               <div class="code e192">xs:anyType</div> is returned as a type definition value.
               
            </div>
         </div><a name="FunctionsandOperatorsonTypeValuesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e193">
            <div class="title e194">Functions and Operators on Type Values</div>
            <div class="para e195">Obtaining types as values is well and good, but what can we do with
               them other than perform sequence type tests on them? At a minimum, equality
               operators should work on these values: 
               <div class="code e196">equals</div>, 
               <div class="code e197">=</div>, and
               
               <div class="code e198">!=</div>. It is also useful to be able to test whether one type is a
               subtype of another. 
               
            </div>
            <div class="figure e199" xml:id="fig_operator_api">
               <div class="title e200">Operators</div>
               <div class="variablelist e201">
                  <div class="varlistentry e202">
                     <div class="term e203">
                        <div class="code e204">equals</div>, 
                        <div class="code e205">=</div>, 
                        <div class="code e206">!=</div>
                     </div>
                     <div class="listitem e207">
                        <div class="para e208">Test component equality.</div>
                     </div>
                  </div>
                  <div class="varlistentry e209">
                     <div class="term e210">
                        <div class="code e211">subtype of</div>
                     </div>
                     <div class="listitem e212">
                        <div class="para e213">Returns true if the first type is a subtype of the second.</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="programlisting e214" xml:space="preserve">
               declare function my:spaceship-operator ($t1 as type(), $t2 as type()) 
               {
               if ($t1 subtype of $t2) then -1
               else if ($t1 = $t2) then 0
               else if ($t1 subtype of $t2) then 1
               else xs:double("NaN")
               };
               
            </div>
            <div class="para e215">XQuery 
               <div class="citation e216" linkend="xqfo30"></div> defines a large number of
               functions. However, only a few 
               apply to all items. The sequence functions, such as 
               <div class="code e217">fn:subsequence</div>
               can work on sequences of component values with no problem. 
               The general functions 
               <div class="code e218">fn:string</div>,
               
               <div class="code e219">fn:boolean</div> and 
               <div class="code e220">fn:not</div> don't really apply and will
               raise errors if applied to component values.
            </div>
            <div class="para e221">If we have equality on type component values, then not only can we
               define 
               <div class="code e222">fn:deep-equal</div> over them, we can define 
               
               <div class="code e223">fn:deep-equal</div> with them. 
               <div class="xref e224" linkend="fig_deepeq1"></div> shows a
               version of 
               <div class="code e225">deep-equal</div> that is stronger than that defined by
               XQuery: it requires type equality as well as structural equality.
               
            </div>
            <div class="figure e226" xml:id="fig_deepeq1">
               <div class="title e227">Implementing deep-equal with Type Values</div>
               <div class="programlisting e228" xml:space="preserve">
                  declare function my:deep-equal ($p1 as item()*, $p2 as item()*, $coll as xs:string)
                  
                  as xs:boolean
                  {
                  let $c1 := count($p1)
                  let $c2 := count($p2)
                  return
                  if ($c1 != $c2) then false()
                  else if ($c1 != 1) then 
                  every $i1 at $i in $p1 satisfies my:deep-equal($i1, $p2[$i], $coll)
                  else if (exists(sc:simple-type($p1)) and exists(sc:simple-type($p2))) then
                  sc:simple-type($p1) eq sc:simple-type($p2) and
                  if (($p1 instance of xs:string) and ($p2 instance of xs:string))
                  then compare($p1, $p2, $coll) eq 0
                  else
                  try {
                  let $v := $p1 eq $p2
                  return ($p1 eq $p1) or (($p1 ne $p1) and ($p2 ne $p2)) (: NaN :)
                  } catch  * {
                  false()
                  }
                  else typeswitch ($p1)
                  case document-node() return 
                  (typeswitch ($p2) 
                  case document-node() return true() default return false()) and
                  my:deep-equal($p1/(*|text()), $p2/(*|text()), $coll)
                  case element() return
                  (typeswitch ($p2) 
                  case element() return true() default return false()) and
                  node-name($p1) eq node-name($p2) and
                  exists(sc:type($p1)) and exists(sc:type($p2)) and 
                  sc:type($p1) eq sc:type($p2) and
                  my:deep-equal( for $a1 in $p1/@* order by name($a1), 
                  for $a2 in $p1/@* order by name($a2), $coll ) and
                  if (exists(sc:simple-type($p1)))
                  then my:deep-equal(data($p1), data($p2), $coll)
                  else my:deep-equal($p1/(*|text()), $p2/(*|text()), $coll)
                  case attribute() return
                  (typeswitch ($p2) 
                  case attribute() return true() default return false()) and
                  node-name($p1) eq node-name($p2) and 
                  my:deep-equal(data($p1),data($p2),$coll)
                  case processing-instruction() return
                  (typeswitch ($p2) 
                  case processing-instruction() return true() default return false()) and
                  node-name($p1) eq node-name($p2) and 
                  compare(string($p1), string($p2), $coll)
                  case namespace-node() return
                  (typeswitch ($p2) 
                  case namespace-node() return true() default return false()) and
                  my:deep-equal(node-name($p1), node-name($p2), $coll) and
                  compare( string($p1), string($p2), $coll ) eq 0
                  case text() return
                  (typeswitch ($p2) case text() return true() default return false()) and
                  compare( string($p1), string($p2), $coll ) eq 0
                  case comment() return 
                  (typeswitch ($p2) case comment() return true() default return false()) and 
                  compare(string($p1), string($p2), $coll)
                  case function() return error("err:FOTY0015")
                  case component() return $p1 eq $p2
                  default return false()
                  };
                  
               </div>
            </div>
            <div class="para e229">Once types are available as values, they can be returned in place
               of type names to perform introspection on functions, for example.
            </div>
            <div class="figure e230" xml:id="fig_misc_api">
               <div class="title e231">Miscellaneous Introspection Functions</div>
               <div class="variablelist e232">
                  <div class="varlistentry e233">
                     <div class="term e234">
                        <div class="code e235">sc:type-named($qname as xs:QName) as type()</div>
                     </div>
                     <div class="listitem e236">
                        <div class="para e237">Return a type value for type with the given name, if
                           any. Raises an undefined type error otherwise.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e238">
                     <div class="term e239">
                        <div class="code e240">sc:function-return-type([$f as function(*)]) as type()</div>
                     </div>
                     <div class="listitem e241">
                        <div class="para e242">Return a type value for the declared return type of
                           the given function.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e243">
                     <div class="term e244">
                        <div class="code e245">sc:function-parameter-type([$f as function(*)],[$argNum as numeric]) as type()</div>
                     </div>
                     <div class="listitem e246">
                        <div class="para e247">Return a type value for the declared type of
                           indicated parameter of the given function. Raises an error if there is no such parameter.
                        </div>
                     </div>
                  </div>
               </div>
            </div><a name="TypeValuesasFunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e248">
               <div class="title e249">Type Values as Functions</div>
               <div class="para e250">In XQuery, there is a constructor function for each in-scope (named)
                  atomic type derived from a primitive type, whether the type is user-defined or
                  built-in. This excludes list and union types. Given that we have a schema
                  component value in our hands, there is no particular reason to require the type
                  to have a name, or even be atomic. Indeed, if one generalizes the concept of
                  the "constructor" function to mean obtaining a typed value of the given type
                  or raising an error if that is not possible, there is no particular reason 
                  not to define functions for complex types as as well, where the "constructor"
                  function for a complex type validates an item against that type. The
                  only types where this doesn't make sense is the "untyped" types
                  (
                  <div class="code e251">xs:untyped</div> and 
                  <div class="code e252">xs:untypedAtomic</div>), which can be
                  applied as no-ops. A function can be defined to perform this typed-value
                  fabrication operation:
                  
               </div>
               <div class="figure e253" xml:id="fig_type_apply">
                  <div class="title e254">Types as functions</div>
                  <div class="variablelist e255">
                     <div class="varlistentry e256">
                        <div class="term e257">
                           <div class="code e258">sc:type-apply($t as type(), $item as item()*) as item()*</div>
                        </div>
                        <div class="listitem e259">
                           <div class="para e260">Apply the type to the item, to obtain a typed value
                              or an error.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="figure e261" xml:id="fig_type_function_alt">
                  <div class="title e262">Example of applying a Type</div>
                  <div class="programlisting e263" xml:space="preserve">
                     declare function local:check($old as item(), $new as item())
                     {
                     let $f := $old/sc:type()
                     return sc:type-apply($f,$new)
                     };
                     
                     local:check(doc("config.xml")/config/language, "en"),
                     local:check(doc("config.xml")/config/encoding, "utf-8")
                     
                  </div>
               </div>
               <div class="para e264">With the XQuery 3.0 data model, we can go further, as function
                  items are defined as values. Then we can just treat types as function items and
                  apply them directly, as shown in 
                  <div class="xref e265" linkend="fig_type_function"></div>. Note that
                  this might be an 
                  <div class="emphasis e266">anonymous</div> type just as well as a named
                  type, unlike the type identification features that are part of standard XQuery.
                  
               </div>
               <div class="figure e267" xml:id="fig_type_function">
                  <div class="title e268">Example of applying a type as an XQuery 3.0 function item</div>
                  <div class="programlisting e269" xml:space="preserve">
                     declare function local:check($old as item(), $new as item())
                     {
                     let $f := $old/sc:type()
                     return $f($new)
                     };
                     
                     local:check(doc("config.xml")/config/language, "en"),
                     local:check(doc("config.xml")/config/encoding, "utf-8")
                     
                  </div>
               </div>
               <div class="para e270">Combined with some of the introspection functions, we can get even
                  more powerful and flexible effects. The function 
                  <div class="code e271">run-plugin</div> can
                  guarantee that a plugin function executed for some particular piece of the
                  framework has the expected type, without having to know a priori what that type
                  is. 
                  
               </div>
               <div class="figure e272" xml:id="fig_fn_ex">
                  <div class="title e273">Using Type Introspection in Plugin Framework</div>
                  <div class="programlisting e274" xml:space="preserve">
                     declare my:run-plugin($config as element(), $plugin as function(*), $args as item()*)
                     {   
                     let $expected := sc:type-named(data($config))
                     if (sc:return-type($plugin) = $expected)
                     $plugin($args)
                     else 
                     $expected($plugin($args))
                     };
                     
                  </div>
               </div>
            </div><a name="ComponentAccessorsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e275">
               <div class="title e276">Component Accessors</div>
               <div class="para e277">For true meta-programming, being able to access some of the details
                  of the type components is important. Schema components are complex and have many
                  interconnections and properties. Attempting to provide a clean API to access
                  all these properties is beyond the scope of this paper. We will content
                  ourselves with defining a few basic accessors.
                  
               </div>
               <div class="para e278">Component accessors work analogously to accessors for nodes in the
                  data model: they apply to all component types, returning the
                  empty sequence where necessary. As with the linkage functions, these functions
                  have a zero-argument form that applies to the context item. This will make
                  chaining them together a little more usable.
                  
               </div>
               <div class="figure e279" xml:id="fig_accessor_api">
                  <div class="title e280">Basic Component Accessors</div>
                  <div class="variablelist e281">
                     <div class="varlistentry e282">
                        <div class="term e283">
                           <div class="code e284">sc:name([$context as component()]) as xs:QName?</div>
                        </div>
                        <div class="listitem e285">
                           <div class="para e286">Return the name of the component, if any.</div>
                        </div>
                     </div>
                     <div class="varlistentry e287">
                        <div class="term e288">
                           <div class="code e289">sc:annotations([$context as component()]) as element()*</div>
                        </div>
                        <div class="listitem e290">
                           <div class="para e291">Return annotations on the component as a sequence
                              of 
                              <div class="code e292">xs:annotation</div> element information items.
                           </div>
                        </div>
                     </div>
                     <div class="varlistentry e293">
                        <div class="term e294">
                           <div class="code e295">sc:base-type([$context as component()]) as type()</div>
                        </div>
                        <div class="listitem e296">
                           <div class="para e297">Return the base type of the component, if any.</div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e298">Getting at schema annotations from instances has many applications. 
                  For example, schema annotations can be used to define business rules, widget bindings
                  for
                  generic UI generation, associating help text with input components, defining
                  special indexing for certain content, defining XML mapping rules, and so on. 
                  
               </div>
               <div class="figure e299" xml:id="fig_ann_ex">
                  <div class="title e300">Some Schema Annotations</div>
                  <div class="programlisting e301" xml:space="preserve">
                     &lt;xs:simpleType name="address"&gt;
                     &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     A numeric internet address.
                     &lt;/xs:documentation&gt;
                     &lt;/xs:annotation&gt;
                     &lt;xs:restriction base="xs:token"&gt;
                     &lt;xs:pattern value="[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"/&gt;
                     &lt;/xs:restriction&gt;
                     &lt;/xs:simpleType&gt;
                     
                     &lt;xs:element name="address" type="address"&gt;
                     &lt;xs:annotation&gt;
                     &lt;xs:documentation&gt;
                     The server socket bind numeric internet address.
                     &lt;/xs:documentation&gt;
                     &lt;xs:appinfo&gt;
                     &lt;admin:default&gt;"0.0.0.0"&lt;/admin:default&gt;
                     &lt;admin:cold-restart/&gt;
                     &lt;admin:help xmlns="http://www.w3.org/1999/xhtml"&gt;
                     &lt;span class="help-text"&gt;&lt;span style="color:#800000"&gt;address&lt;/span&gt; 
                     specifies the IP address for the App Server.&lt;/span&gt;
                     &lt;/admin:help&gt;
                     &lt;/xs:appinfo&gt;
                     &lt;/xs:annotation&gt;
                     &lt;/xs:element&gt;
                     
                     
                  </div>
                  <div class="caption e302">
                     <div class="para e303">Schema annotations from a real product.</div>
                  </div>
               </div>
               <div class="para e304">One key difference between XML types and classes in an
                  object-oriented programming language is that classes have methods as well as
                  data. Combining function items with annotation accessors can bring methods to
                  XML types as well, in a way.
               </div>
               <div class="figure e305" xml:id="fig_oo_xq">
                  <div class="title e306">Function Items Named in Annotations as Methods</div>
                  <div class="para e307">The schema:</div>
                  <div class="programlisting e308" xml:space="preserve">
                     &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                     xmlns:record="http://example.com/meta/records"
                     xmlns:base="http://example.com/meta"
                     targetNamespace="http://example.com/meta/records"
                     elementFormDefault="qualified"&gt;
                     
                     &lt;xs:import namespace="http://example.com/meta"
                     schemaLocation="meta.xsd"/&gt;
                     
                     &lt;xs:simpleType name="studio"&gt;
                     &lt;xs:annotation&gt;
                     &lt;xs:appinfo&gt;
                     &lt;base:input-handler&gt;record:normalize-studio&lt;/base:input-handler&gt;
                     &lt;base:formatter&gt;record:format-studio&lt;/base:formatter&gt;
                     &lt;/xs:appinfo&gt;
                     &lt;/xs:annotation&gt;
                     &lt;xs:restriction base="xs:string"/&gt;
                     &lt;/xs:simpleType&gt;
                     
                     &lt;xs:complexType name="record-metadata"&gt;
                     &lt;xs:complexContent&gt;
                     &lt;xs:extension base="base:metadata"&gt;
                     &lt;xs:sequence&gt;
                     &lt;xs:element ref="studio" type="studio"/&gt;
                     &lt;/xs:sequence&gt;
                     &lt;xs:extension&gt;
                     &lt;/xs:complexContent&gt;
                     &lt;/xs:complexType&gt;
                     
                  </div>
                  <div class="para e309">Formatter function using metadata "methods":</div>
                  <div class="programlisting e310" xml:space="preserve">
                     declare function base:format-metadata ($metadata as element())
                     {
                     for $meta in $metadata/*
                     let $methods := $meta/sc:element-decl()!sc:annotations()/xs:appinfo
                     let $formatter := function-lookup($methods/base:formatter, 1)
                     return $formatter($meta)
                     };
                     
                  </div>
               </div>
            </div>
         </div>
      </div><a name="OtherSchemaComponentValuesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e311">
         <div class="title e312">Other Schema Component Values</div><a name="FacetsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e313">
            <div class="title e314">Facets</div>
            <div class="para e315">Accessing facet information is important for working with simple
               types. 
               <div class="xref e316" linkend="fig_facet_decls"></div> summarizes the additional type tests
               and accessors for working with facets. The 
               <div class="code e317">sc:facets</div> accessor
               returns sequences of facet component values when applied to simple type
               components; it returns the empty sequence otherwise. The accessors already
               defined apply to facet component values as well. The 
               <div class="code e318">sc:name</div>
               accessor returns the name of the element used to define the facet
               (e.g. xs:enumeration for the enumeration facet), and the standard accessor
               
               <div class="code e319">fn:data</div> returns the value of the facet.
            </div>
            <div class="figure e320" xml:id="fig_facet_decls">
               <div class="title e321">Additions for Facet Values</div>
               <div class="variablelist e322">
                  <div class="varlistentry e323">
                     <div class="term e324">
                        <div class="code e325">facet() or facet(*)</div>
                     </div>
                     <div class="listitem e326">
                        <div class="para e327">Type test matching any facet value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e328">
                     <div class="term e329">
                        <div class="code e330">facet(q:name)</div>
                     </div>
                     <div class="listitem e331">
                        <div class="para e332">Type test matching any facet value whose name
                           matches the given QName. For example, a pattern facet matches 'facet(xs:pattern)'.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e333">
                     <div class="term e334">
                        <div class="code e335">sc:facets([$context as item()]) as facet()*</div>
                     </div>
                     <div class="listitem e336">
                        <div class="para e337">Get all the facets of the item, if any. Only simple
                           types have facets.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e338">Let's return to the date example from the introduction 
               (
               <div class="xref e339" linkend="fig_dateex_1"></div>). With access to types and their facets, as
               well as function lookup and function application, we can create a generic
               framework for processing dates without having to hardcode any type or function
               names. A fragment of this framework is shown in 
               
               <div class="xref e340" linkend="fig_dateex_2"></div>.
            </div>
            <div class="figure e341" xml:id="fig_dateex_2">
               <div class="title e342">Generic XQuery Type-Based Dispatch</div>
               <div class="programlisting e343" xml:space="preserve">
                  ...
                  declare function my:process-date($date)
                  {
                  for $date-type in fn:collection("templates")/date/sc:simple-type() 
                  let $date-pattern := sc:facets($date-type)[. instance of facet(xs:pattern)]
                  let $process-func := 
                  fn:function-lookup(fn:data(sc:annotations($date-type)//my:date-func), 1)
                  where fn:exists($date-pattern) and
                  fn:exists($process-func) and
                  fn:matches($date, fn:data($date-pattern))
                  return $process-func($date-type($date))
                  };
                  
                  
               </div>
               <div class="caption e344">
                  <div class="para e345">XQuery fragment using schema annotations and function
                     lookup to create a generic date-processing framework.
                  </div>
               </div>
            </div>
         </div><a name="ElementandAttributeDeclarationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e346">
            <div class="title e347">Element and Attribute Declarations</div>
            <div class="para e348">As the example in 
               <div class="xref e349" linkend="fig_ann_ex"></div> shows, 
               it is frequently more natural to obtain the annotations from element and
               attribute declarations rather than from the types associated with those
               declarations, Annotations often have more to do with the use of a type in a
               particular context than with the type itself. Adding accessors to obtain element and
               attribute
               declarations from element and attribute nodes, and defining the component
               accessors over these new component types allows for these use cases. 
               
               <div class="xref e350" linkend="fig_decls"></div> summarizes the additional type tests and
               accessors for working with element and attribute declarations. The
               
               <div class="code e351">sc:element-decl</div> and 
               <div class="code e352">sc:attribute-decl</div> 
               accessors return component values when applied to element and attribute nodes,
               respectively; otherwise they return empty sequence. In addition, the accessors
               already defined apply to these new declaration component values as well. The
               
               <div class="code e353">sc:type</div>, 
               <div class="code e354">sc:complex-type</div>, and
               
               <div class="code e355">sc:simple-type</div> accessors return the type associated with the declaration.
               
            </div>
            <div class="figure e356" xml:id="fig_decls">
               <div class="title e357">Additions for Element and Attribute Declaration Values</div>
               <div class="variablelist e358">
                  <div class="varlistentry e359">
                     <div class="term e360">
                        <div class="code e361">element-decl() or element-decl(*)</div>
                     </div>
                     <div class="listitem e362">
                        <div class="para e363">Type test matching any element declaration value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e364">
                     <div class="term e365">
                        <div class="code e366">element-decl(q:name)</div>
                     </div>
                     <div class="listitem e367">
                        <div class="para e368">Type test matching any element declaration value
                           whose name matches the given QName, or which is in the substitution group with
                           an element with the given QName as its head.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e369">
                     <div class="term e370">
                        <div class="code e371">attribute-decl() or attribute-decl(*)</div>
                     </div>
                     <div class="listitem e372">
                        <div class="para e373">Type test matching any attribute declaration value.</div>
                     </div>
                  </div>
                  <div class="varlistentry e374">
                     <div class="term e375">
                        <div class="code e376">attribute-decl(q:name)</div>
                     </div>
                     <div class="listitem e377">
                        <div class="para e378">Type test matching any attribute declaration value
                           whose name matches the given QName.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e379">
                     <div class="term e380">
                        <div class="code e381">sc:element-decl([$context as item()]) as element-decl()?</div>
                     </div>
                     <div class="listitem e382">
                        <div class="para e383">Get the element declaration of the item, if any.</div>
                     </div>
                  </div>
                  <div class="varlistentry e384">
                     <div class="term e385">
                        <div class="code e386">sc:attribute-decl([$context as item()]) as attribute-decl()?</div>
                     </div>
                     <div class="listitem e387">
                        <div class="para e388">Get the attribute declaration of the item, if any.</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e389">Fitting element declaration values into the type hierarchy leads us
               to go still further: element declarations are but one kind of term in a content
               model, along with wildcards and model groups. Given that we already have
               element declaration values, it makes sense to expose the content model of a
               type in general. Given that we already have attribute declaration values, it
               makes sense to expose the attributes declared on a complex type.
            </div>
            <div class="para e390">The XML Schema component model creates some complexity in this area
               and we need to decide how to expose the information in the a usable way.
               That model makes a distinction between particles and terms,
               where the particle carries occurrence information.
               It also makes an analogous distinction between attribute uses and attribute
               declarations, where attribute uses carry value constraints. Attribute uses and
               particles also can be used to carry local context-specific annotations. 
               
            </div>
            <div class="figure e391" xml:id="fig_decl_accessor">
               <div class="title e392">More Accessors</div>
               <div class="variablelist e393">
                  <div class="varlistentry e394">
                     <div class="term e395">
                        <div class="code e396">sc:particles([$context as component()]) as particle()*</div>
                     </div>
                     <div class="listitem e397">
                        <div class="para e398">Return the particles within a model group or complex
                           type's content type as values.
                        </div>
                     </div>
                  </div>
                  <div class="varlistentry e399">
                     <div class="term e400">
                        <div class="code e401">sc:term([$context as component()]) as term()</div>
                     </div>
                     <div class="listitem e402">
                        <div class="para e403">Get the term for a particle.</div>
                     </div>
                  </div>
                  <div class="varlistentry e404">
                     <div class="term e405">
                        <div class="code e406">sc:attributes([$context as component()]) as attribute-use()*</div>
                     </div>
                     <div class="listitem e407">
                        <div class="para e408">Return the attributes uses from a complex type.</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e409">In addition to the new accessors listed in 
               <div class="xref e410" linkend="fig_decls"></div>, 
               the 
               <div class="code e411">sc:attribute-decl</div> accessor applies to attribute use component
               values.
               
            </div>
            <div class="figure e412" xml:id="fig_comp_hier">
               <div class="title e413">Declaration and Particle Values</div>
               <div class="mediaobject e414">
                  <div class="imageobject e415">
                     <div class="metaBox e416"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e743').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e743" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e416'
                              </span><span class="metaAttribute">fileref='../../../vol8/graphics/Holstege01/Holstege01-003.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='75%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </div><a name="ImplementationConsiderationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e417">
         <div class="title e418">Implementation Considerations</div>
         <div class="para e419">It is difficult to generalize about different
            implementations of a language. Overall implementing the accessors, type
            tests and operators discussed here on top of an existing XQuery implementation
            was not difficult. 
            
         </div>
         <div class="para e420">XQuery is notoriously sensitive to syntactic extensions.
            The use of functional syntax made the integration with an existing
            XQuery lexer and parser more straight-forward than it would have been if new
            syntactic constructs had been required. The new sequence type tests and the
            
            <div class="code e421">subtype of</div> operator did require additions to the lexer and parser
            rules. The 
            <div class="code e422">subtype of</div> operator was added as an additional kind of
            comparison expression; the new sequence type tests were added in parallel to
            XPath kind tests. Adding the component kind tests required the same kind of
            special handling already required for other names that appear in a similar
            context, such as 
            <div class="code e423">element</div> or 
            <div class="code e424">document-node</div>.
            
         </div>
         <div class="para e425">The values themselves were implemented as classes providing
            faÃades over existing data structures used to implement XML Schema
            components. These data structures were already present to support validation
            and type assignment. An implementation that lacked such data structures would
            clearly find exposing types as values more challenging. It is unclear, however,
            whether a direct reflection of the schema component model is the right
            approach. It may be better to step back and design a cleaner API, and provide
            values over that model instead. Such a strategy would bring a higher
            implementation burden. 
            
         </div>
         <div class="para e426">Applying types as functions depended on a prior foundation
            of XQuery 3.0 function items, and would be much more difficult to accomplish
            without that foundation. Given that foundation, applying simple types as
            functions is trivial, and applying complex types as functions only slightly
            more so. The existing infrastructure to support schema validation was a
            necessary prerequisite to applying complex types as functions, however.
         </div>
         <div class="para e427">The most challenging part of the implementation was
            providing access to annotations. The existing data structures did not preserve
            annotations as data model instances, as they were irrelevant for validation and
            type assignment and there was no existing API that provided access to the
            schema components. A surprising amount of work needed to be
            done in order to preserve annotations and expose them as nodes.
         </div>
         <div class="para e428">Finally, the experimental implementation actually did allow schema
            component values to be added as children to data model instances, primarily for
            debugging purposes. Adding a schema component value as a child added it as the
            XML Schema serialization. In addition, 
            <div class="code e429">fn:string</div> was also
            implemented over these values to provide a terse representation of them, again,
            for debugging purposes. About half the implementation code went into these
            debugging APIs.
            
         </div>
      </div><a name="FutureDirectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e430">
         <div class="title e431">Future Directions</div><a name="MoreAccessorsFunctionsandOperatorsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e432">
            <div class="title e433">More Accessors, Functions, and Operators</div>
            <div class="para e434">This paper has focused mainly on exposing types as values in
               XQuery with a few basic accessors, with some forays into some related
               schema components. Some meta-programming techniques rely on being able to
               examine the full richness of the schema component model â terms,
               particles, attribute uses, schema component affiliations, abstractness, and so
               on. The program to provide such full access is similar to what was outlined
               here: define type tests for the component, define linkage functions or
               accessors to get to that component, define accessors to get at the component
               properties, and define whatever other useful functions and operators seem
               appropriate. 
               
            </div>
            <div class="para e435">More extensive additions to the syntax of XQuery to allow
               variables to be used as the operand of 
               <div class="code e436">instance of</div> and 
               <div class="code e437">cast
                  as
               </div> expressions would improve usability further:
            </div>
            <div class="programlisting e438" xml:space="preserve">
               declare function my:filter-by-type($t as type(), $nodes as node()*)
               {
               for $n in $nodes where $n instance of $t return $n
               };
               
            </div>
         </div><a name="RelationshiptoSchemaComponentPathsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e439">
            <div class="title e440">Relationship to Schema Component Paths</div>
            <div class="para e441">Once we embark on the program of providing full access to all the
               schema components and their properties, the use of schema component paths
               arises. Schema component paths define an
               XPath-like syntax for describing and navigating W3C XML Schema 
               <div class="citation e442" linkend="xsd11st"></div> component models. Abbreviated syntax is defined
               for some path steps, and certain axes that skip over intermediate components
               can provide effective ways of navigating through content models, or selecting
               multiple components with a since path.
               
            </div>
            <div class="para e443">Schema component paths navigate through the schema component graph
               of an assembled schema. As with XPath, each step in the path consists of an
               axis combined with some kind of test and perhaps with a predicate. In schema
               component paths, the test is a name test (possibly a wildcarded name test, and
               possibly a test for an anonymous component), and the only predicate defined is
               a positional predicate (selecting the Nth of like components). There are no
               accessors for non-component properties: the axes act as accessor for component
               properties, just like in XPath. About two dozen axes are defined, for each of
               the component-to-component relationships in the graph. For example, the
               
               <div class="code e444">annotation::</div> axis corresponds to the 
               <div class="code e445">sc:annotations</div>
               accessor.
               
            </div>
            <div class="figure e446" xml:id="fig_scp1">
               <div class="title e447">Some Schema Component Paths</div>
               <div class="programlisting e448" xml:space="preserve">
                  /schemaElement::p:outer/type::0/schemaAttribute::p:inner
                  /p:outer/~0/@p:inner
                  /type::p:second/model::sequence/schemaElement::p:duplicate[2]/type::*
                  /~p:second/model::sequence/p:duplicate[2]/~*
                  
               </div>
            </div>
            <div class="para e449">
               <div class="xref e450" linkend="fig_scp1"></div> shows some schema component paths
               rooted at the component for the schema as a whole. The first path starts 
               at the root of the assembled schema (
               <div class="code e451">/</div>). It then traverses the
               schemaElement axis (
               <div class="code e452">schemaElement::</div>) with a name test
               (
               <div class="code e453">p:outer</div>), selecting a global 
               element declaration with the name 
               <div class="code e454">outer</div>. The path continues
               through the type axis (
               <div class="code e455">type::</div>) with a name test (
               <div class="code e456">0</div>)
               that in this case matches a type definition with no name (
               <div class="code e457">0</div> being
               the indicator for this case). The path to this point will select the locally
               declared anonymous type of the element declaration 'outer'. Finally the path
               concludes by traversing the schemaAttribute axis
               (
               <div class="code e458">schemaAttribute::</div>) with a name test (
               <div class="code e459">p:inner</div>), 
               selecting an attribute declaration whose name is 'inner' within the anonymous
               type definition. As a whole then, this path selects a particular attribute
               declaration of a particular element declaration. The second path means the same
               thing, but uses abbreviated syntax.
               
            </div>
            <div class="para e460">The third path again starts at the root of the assembled schema
               (
               <div class="code e461">/</div>). This time it traverses through the type axis
               (
               <div class="code e462">type::</div>) with a name test (
               <div class="code e463">p:second</div>), thus selecting
               a global type definition with the name 'second'. The path then traverses the
               model axis (
               <div class="code e464">model::</div>) with a name test (
               <div class="code e465">sequence</div>),
               thus selecting the model group in the content model of the type, 
               but only if it is a sequence. The path continues along the schemaElement axis
               (
               <div class="code e466">schemaElement::</div>) with a name test (
               <div class="code e467">p:duplicate</div>) and
               a positional constraint (
               <div class="code e468">[2]</div>), thus selecting an element
               declaration within the sequence that has a name of 'duplicate', but referring
               to the second such element within the content model. Finally, the path
               traverses the type axis (
               <div class="code e469">type::</div>) with a 
               wildcard (
               <div class="code e470">*</div>), selecting the type of the given element declaration,
               whatever it might be. The fourth path means the same thing, but uses
               abbreviated syntax. 
               
            </div>
            <div class="para e471">How does this compare to the accessors we have
               defined above?
            </div>
            <div class="para e472">The accessors operate not on components but on
               XQuery values. For example, 
               <div class="code e473">sc:element-decl</div> applies to nodes.
               Some accessors, such as 
               <div class="code e474">sc:type</div>, apply to component values
               also, and so behave somewhat like the schema component axes. 
               To get the full range of axes available in schema component paths, it would be
               necessary to define an accessor function corresponding to each axis, and allow
               it to apply to component values. To get the effect of the name tests, XPath
               predicates must be applied to the results of the accessor. Some accessors
               return simple properties of the components, such as its name. Schema component
               paths do not provide for access to the non-component properties. Finally,
               schema component paths use the slash (
               <div class="code e475">/</div>) as a syntactic separator
               between steps. Since schema components are not nodes, XQuery forbids using them
               inside a path (although they can be the last step of a path). A FLWOR
               expression, nested function call, or the XQuery 3.0 simple mapping operator
               (
               <div class="code e476">!</div>) must be used instead. 
               
            </div>
            <div class="table e477" border="5" frame="border" rules="rows">
               <div class="caption e478">
                  <div class="para e479">Summary of Comparison of Schema Component Accessors and Schema Component Paths</div>
               </div>
               <div class="tr e480">
                  <div class="th e481">Schema Component Paths</div>
                  <div class="th e482">Schema Component Accessors</div>
               </div>
               <div class="tr e483">
                  <div class="td e484">operate on schema components</div>
                  <div class="td e485">operate on XQuery values</div>
               </div>
               <div class="tr e486">
                  <div class="td e487">apply to schema in isolation</div>
                  <div class="td e488">can link between date model
                     items and schema component values
                  </div>
               </div>
               <div class="tr e489">
                  <div class="td e490">start at particular schema component, either root of schema or contextually supplied
                     schema component
                  </div>
                  <div class="td e491">apply to particular item(), not rooted at top of schema</div>
               </div>
               <div class="tr e492">
                  <div class="td e493">path step selects component-valued component properties only</div>
                  <div class="td e494">acccessor selects various kinds of properties</div>
               </div>
               <div class="tr e495">
                  <div class="td e496">steps combine axis with name test directly</div>
                  <div class="td e497">component or name test separate from accessor</div>
               </div>
               <div class="tr e498">
                  <div class="td e499">steps combined with slash</div>
                  <div class="td e500">chains of accessors cannot be
                     combined with slash: must nest function calls, use FLWOR expressions, or use
                     XQuery 3.0 simple mapping operator instead
                  </div>
               </div>
               <div class="tr e501">
                  <div class="td e502">path syntax and semantics similar to XPath, but is not XPath</div>
                  <div class="td e503">syntax and semantics are standard XPath</div>
               </div>
            </div>
            <div class="para e504">Since schema component accessors do not apply to schemas in
               isolation, it is not possible to construct XQuery expressions that are exactly
               equivalent to the schema component paths given previously. However, we can give
               some expressions that are roughly equivalent, to give some sense of how they
               compare.
               
            </div>
            <div class="figure e505" xml:id="fig_scp_equiv">
               <div class="title e506">Rough Equivalents to Schema Component Paths</div>
               <div class="programlisting e507" xml:space="preserve">
                  $context/sc:schema()!
                  sc:element-decl()[sc:name(.)=xs:QName('p:outer')]!
                  sc:type()[empty(sc:name(.))]!
                  sc:attribute-decl()[sc:name(.)=xs:QName('p:inner')]
                  
                  $context/sc:schema()!
                  sc:type()[sc:name(.)=xs:QName('p:second')]!
                  sc:particles()[
                  typeswitch (sc:term(.)) 
                  case model-group(xs:sequence) return true()
                  default return false()]!
                  sc:particles()[
                  typeswitch (sc:term(.)) 
                  case particle(p:duplicate) return true() 
                  default return false()][2]!
                  sc:type()
                  
               </div>
            </div>
            <div class="para e508">
               <div class="xref e509" linkend="fig_scp_equiv"></div> shows XQuery expressions using the
               accessors that are roughly equivalent to the schema component paths shown in
               
               <div class="xref e510" linkend="fig_scp1"></div>. These
               expressions have to be grounded on some XQuery item (
               <div class="code e511">$context</div>),
               and it was necessary to invent a new accessor to link to the root of the
               assembled schema governing the type information for that item
               (
               <div class="code e512">sc:schema</div>). 
               
            </div>
            <div class="para e513">Schema component paths clearly express traversal
               through a schema component graph more compactly than the accessor and linkage
               functions do, in that they combine the accessor and the type test in one path
               step. In addition, schema component paths generally elide the distinction
               between terms and particles, which the chained accessors do not.
               
            </div>
            <div class="para e514">On the other hand, schema component paths do not provide a complete
               answer, however. They do not provide access to non-component
               information, nor do they bridge the boundary between schema components and
               nodes or other item types. 
               
            </div>
            <div class="para e515">We could imagine allowing schema component paths to mix directly
               with normal XPath paths to provide that linkage. Then a path such as 
               
               <div class="code e516">/book/chapter/title/type::*/annotation::*/xs:appinfo/my:special-stuff/@my:type</div>
               would switch back and forth between XPaths and schema component paths. Under
               this scheme the type axis in the fourth step of the path would start a relative
               schema component path with some component as the default. In this case,
               the context is the element declaration component for the 
               <div class="code e517">title</div>
               element. 
               
            </div>
            <div class="para e518">Mixing schema component paths with normal XPaths directly in this
               way is apt to be very confusing, however. The rules governing the slash are
               very different. In addition, abbreviated schema component paths in this mixed
               context confuses interpretation tremendously. Is the 
               <div class="code e519">@my:type</div> at
               the end of the path a normal attribute node on the
               
               <div class="code e520">my:special-stuff</div> element or is it an attribute declaration?
               Careful specification of the switching rules may eliminate ambiguities,
               but it won't eliminate confusion for humans reading and writing such
               paths. The similarity of schema component paths to XPaths that helps make them
               more intuitive in isolation causes difficulty when used in the same context as
               XPath. This confusion also makes implementation more difficult: higher levels
               of analysis would be required to determine what kinds of operations are
               allowable, or to optimize node paths properly.
               
            </div>
            <div class="para e521">Keeping schema component paths and XPaths clearly separated
               provides the power of both, without the confusion. Wrapping schema component
               paths within some kind of scoping expression and providing the rich set of
               accessor functions seems the best way to achieve this.
               
            </div>
            <div class="figure e522" xml:id="fig_scd_type">
               <div class="title e523">Example Integration of Schema Component Paths and Type Values</div>
               <div class="programlisting e524" xml:space="preserve">
                  /book/chapter/title/sc:element-decl() ! 
                  scp {type::*/annotation::*}/
                  xs:appinfo/my:special-stuff/@my:type
                  
               </div>
               <div class="caption e525">
                  <div class="para e526">Schema component paths are wrapped inside special
                     syntactic for to keep them clearly separated from normal XPaths.
                  </div>
               </div>
            </div>
            <div class="para e527">In summary, both schema component paths and the XQuery linkage and
               accessor functions both have their place. Schema component paths are suited to
               navigating through schema component graphs or pointing to specific schema
               components for schema analysis or reporting. The accessor functions are more
               useful to exposing the schema information relevant to a particular XQuery item
               in the context of some operations over data.
               
            </div>
         </div>
      </div><a name="SummaryandConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e528">
         <div class="title e529">Summary and Conclusions</div>
         <div class="para e530">This paper has explored adding schema types as values into XQuery,
            providing some measure of structural type introspection. In an XQuery context,
            a type is an XML Schema type, and to provide even basic structural type
            introspection requires pulling in quite a bit of the complexity of the XML
            schema component model. Nevertheless, implementation need not be too
            challenging, and only modest changes to the XQuery data model and existing 
            syntax are required. It is possible to take an incremental approach to adding additional
            capabilities, but even some basic abilities can provide significant 
            coding power and flexibility. 
            
         </div>
         <div class="para e531">Schema component paths can be used in combination with linkage
            function if they are integrated with care, to avoid confusion. Schema component
            paths satisfy use cases where deep analysis of the schema is required, while
            simple accessor and linkage functions work well for getting at basic metadata
            about the types of the data being operated on.
            
         </div>
      </div><a name="ReferencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e532">
         <div class="title e533">References</div>
         <div class="bibliomixed e534" xml:id="cplus" xreflabel="C++">
            American National Standards Institute, 1430 Broadway, New York, NY 10018, USA.
            
            <div class="emphasis e535">The ANSI C++ Standard (ISO/IEC 14882)</div>, 2002.
            
         </div>
         <div class="bibliomixed e536" xml:id="clos" xreflabel="Gabriel91">
            Richard P. Gabriel, Jon L. White, and Daniel G. Bobrow. 
            
            <div class="emphasis e537">Clos: Integrating Object-Oriented and Functional Programming.</div>
            Communications of the ACM, 34(9):29â38, 1991. doi:
            <div class="biblioid doi e538">10.1145/114669.114671</div>.
            
         </div>
         <div class="bibliomixed e539" xml:id="php" xreflabel="Gabrysiak">
            Gregor Gabrysiak, Stefan Marr, and Falko Menge. 
            
            <div class="emphasis e540">Meta Programming and Reflection in PHP</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e541" xlink:actuate="onRequest" xlink:href="http://instantsvc.sourceforge.net/docs/metaprogramming-and-reflection-with-php-paper.pdf" xlink:show="new" xlink:type="simple">http://instantsvc.sourceforge.net/docs/metaprogramming-and-reflection-with-php-paper.pdf</div>
            Accessed 2012-03-29.
            
         </div>
         <div class="bibliomixed e542" xml:id="xsd11st" xreflabel="XSD11.1">
            W3C: Shudi (Sandy) Gao é«æ®é, C.M. Sperberg-McQueen, and 
            Henry S. Thompson, editors.  
            
            <div class="emphasis e543">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures </div>.
            W3C, April 2012. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e544" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-11-1/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-11-1/</div>
            
         </div>
         <div class="bibliomixed e545" xml:id="scds" xreflabel="SCD">
            W3C: Mary Holstege and Asir S. Vedamuthu, editors.
            
            <div class="emphasis e546">W3C XML Schema Definition Language (XSD): Component Designators.</div>
            Candidate Recommendation. W3C, January 2010.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e547" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/</div>
            
         </div>
         <div class="bibliomixed e548" xml:id="xqfo30" xreflabel="F&amp;O30">
            W3C: Michael Kay, editor.
            
            <div class="emphasis e549">XPath and XQuery Functions and Operators 3.0</div>
            Last Call Working Draft. W3C, December 2011.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e550" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-functions-30/</div>
            
         </div>
         <div class="bibliomixed e551" xml:id="java" xreflabel="Java">
            Oracle Corporation.
            
            <div class="emphasis e552">Java TM Platform Standard Ed. 7 API Documentation.</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e553" xlink:actuate="onRequest" xlink:href="http://docs.oracle.com/javase/7/docs/api/index.html" xlink:show="new" xlink:type="simple">http://docs.oracle.com/javase/7/docs/api/index.html</div>.
            Accessed 2012-04-01.
            
         </div>
         <div class="bibliomixed e554" xml:id="xsd11dt" xreflabel="XSD11.2">
            W3C: David Peterson, Shudi (Sandy) Gao é«æ®é, Ashok Malhotra,
            C.M. Sperberg-McQueen, and Henry S. Thompson, editors.  
            
            <div class="emphasis e555">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes.</div>
            W3C. April 2012.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e556" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-2/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema11-2/</div>
            	
         </div>
         <div class="bibliomixed e557" xml:id="xq30" xreflabel="XQuery30">
            W3C: Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, editors.
            
            <div class="emphasis e558">XQuery 3.0: An XML Query Language</div>
            Last Call Working Draft. W3C, December 2011.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e559" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xquery-30/</div>
            
         </div>
         <div class="bibliomixed e560" xml:id="introc" xreflabel="Singh04">
            Hermanpreet Singh.
            
            <div class="emphasis e561">Introspective C++</div>.
            Masters Thesis, Virginia Polytechnic Institute, 2004.
            
         </div>
         <div class="bibliomixed e562" xml:id="perl" xreflabel="Perl6">
            Larry Wall.
            
            <div class="emphasis e563">Apocalypse 12: Objects; number 12 version 8.</div>
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e564" xlink:actuate="onRequest" xlink:href="http://www.perl6.org/archive/doc/design/apo/A12.html" xlink:show="new" xlink:type="simple">http://www.perl6.org/archive/doc/design/apo/A12.html</div>
            May 2006. Accessed 2012-04-01.
            
         </div>
         <div class="bibliomixed e565" xml:id="xq30dm" xreflabel="DM30">
            W3C: Norman Walsh, Anders Berglund, and John Snelson, editors.
            
            <div class="emphasis e566">XQuery and XPath Data Model 3.0</div>
            Last Call Working Draft. W3C, December 2011.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e567" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath-datamodel-30/</div>
            
         </div>
      </div>
   </div>
</div>