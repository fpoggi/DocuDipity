<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#RefiningtheTaxonomyofXMLSchemaLanguagesAnewApproachforCategorizingXMLSchema%0ALanguagesinTermsofProcessingComplexityANCHOR" name="RefiningtheTaxonomyofXMLSchemaLanguagesAnewApproachforCategorizingXMLSchema%0ALanguagesinTermsofProcessingComplexityTOC">Refining the Taxonomy of XML Schema Languages. A new Approach for Categorizing XML
               Schema
               Languages in Terms of Processing Complexity</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#XMLandFormalLanguageTheoryANCHOR" name="XMLandFormalLanguageTheoryTOC">XML and Formal Language Theory</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#FormalLanguageTheoryandXMLANCHOR" name="FormalLanguageTheoryandXMLTOC">Formal Language Theory and XML</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RefiningtheTaxonomyofXMLSchemaLanguagesANCHOR" name="RefiningtheTaxonomyofXMLSchemaLanguagesTOC">Refining the Taxonomy of XML Schema Languages</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IntroductiontotheFormalConceptsANCHOR" name="IntroductiontotheFormalConceptsTOC">Introduction to the Formal Concepts</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#AnExampleGrammarANCHOR" name="AnExampleGrammarTOC">An Example Grammar</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TheExampleGrammarRealizedbyaDTD(LocalTreeGrammar)ANCHOR" name="TheExampleGrammarRealizedbyaDTD(LocalTreeGrammar)TOC">The Example Grammar Realized by a DTD (Local Tree Grammar)</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TheExampleGrammarRealizedbyanXSD(SingleTypeTreeGrammar)ANCHOR" name="TheExampleGrammarRealizedbyanXSD(SingleTypeTreeGrammar)TOC">The Example Grammar Realized by an XSD (Single Type Tree Grammar)</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#TheExampleGrammarRealizedbyaRELAXNGGrammar(RegularTreeGrammar)ANCHOR" name="TheExampleGrammarRealizedbyaRELAXNGGrammar(RegularTreeGrammar)TOC">The Example Grammar Realized by a RELAX NG Grammar (Regular Tree Grammar)</a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DeterminismandLocalAmbiguityANCHOR" name="DeterminismandLocalAmbiguityTOC">Determinism and Local Ambiguity</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeterminismAlgorithmsandLocalAmbiguitiesANCHOR" name="DeterminismAlgorithmsandLocalAmbiguitiesTOC">Determinism, Algorithms and Local Ambiguities</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DeterministicContentModelsANCHOR" name="DeterministicContentModelsTOC">Deterministic Content Models</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TheMurataHierarchyasHierarchyofLocalityConditionsANCHOR" name="TheMurataHierarchyasHierarchyofLocalityConditionsTOC">The Murata Hierarchy as Hierarchy of Locality Conditions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StructureandGlobalAmbiguityANCHOR" name="StructureandGlobalAmbiguityTOC">Structure and Global Ambiguity</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RestrainedCompetitionGrammarsandVariantsANCHOR" name="RestrainedCompetitionGrammarsandVariantsTOC">Restrained Competition Grammars and Variants</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InherentlyAmbiguousLanguagesANCHOR" name="InherentlyAmbiguousLanguagesTOC">Inherently Ambiguous Languages</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#UnambiguousLanguagesANCHOR" name="UnambiguousLanguagesTOC">Unambiguous Languages</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ApplicationandFutureResearchANCHOR" name="ApplicationandFutureResearchTOC">Application and Future Research</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">author</div>
         <div class="singletermTERMS">assert</div>
         <div class="singletermTERMS">a formal language for expressing schemas</div>
         <div class="singletermTERMS">a*b*a*</div>
         <div class="singletermTERMS">A → a(ABC|CBA)</div>
         <div class="singletermTERMS">A (C)</div>
         <div class="singletermTERMS">A → a(C)</div>
         <div class="singletermTERMS">A → a(BC|B'C')</div>
         <div class="singletermTERMS">A → a(BC|CB)</div>
         <div class="singletermTERMS">A → a(B) B → b(C) C → a(D) D → c(ε)</div>
         <div class="singletermTERMS">A URCG cannot be ambiguous.</div>
         <div class="singletermTERMS">a(b,c)</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">business rules</div>
         <div class="singletermTERMS">B → a(D)</div>
         <div class="singletermTERMS">B'</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Content Assembly Mechanism</div>
         <div class="singletermTERMS">constraint-based</div>
         <div class="singletermTERMS">Constraint Language in XML</div>
         <div class="singletermTERMS">C (A)</div>
         <div class="singletermTERMS">C → b(r)</div>
         <div class="singletermTERMS">C'</div>
         <div class="singletermTERMS">competition sets</div>
         <div class="singletermTERMS">Conjecture 1</div>
         <div class="singletermTERMS">Christian</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">document type descriptions</div>
         <div class="singletermTERMS">Definition 1</div>
         <div class="singletermTERMS">Definition 2</div>
         <div class="singletermTERMS">Definition 3</div>
         <div class="singletermTERMS">Definition 4</div>
         <div class="singletermTERMS">Definition 5</div>
         <div class="singletermTERMS">Definition 6</div>
         <div class="singletermTERMS">Definition 7</div>
         <div class="singletermTERMS">Definition 8</div>
         <div class="singletermTERMS">D → b(r')</div>
         <div class="singletermTERMS">Definition 9</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">EMPTY</div>
         <div class="singletermTERMS">element.section</div>
         <div class="singletermTERMS">extended context-free grammars</div>
         <div class="singletermTERMS">extended context-free grammar</div>
         <div class="singletermTERMS">Element Declarations Consistent</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">Formal Language Theory</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">grammar-based schema languages</div>
         <div class="singletermTERMS">generalized restrained competition grammar</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">ID</div>
         <div class="singletermTERMS">IDREF</div>
         <div class="singletermTERMS">id</div>
         <div class="singletermTERMS">I(e) is a start symbol when e is the root of t,</div>
         <div class="singletermTERMS">I(e) is A,</div>
         <div class="singletermTERMS">itself</div>
         <div class="singletermTERMS">inherently ambiguous</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">local tree grammars</div>
         <div class="singletermTERMS">L(E)</div>
         <div class="singletermTERMS">local tree grammar</div>
         <div class="singletermTERMS">L(A)≠L(B)</div>
         <div class="singletermTERMS">L(A)∩ L(B)≠ ∅</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">Maik</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">noNamespaceSchemaLocation</div>
         <div class="singletermTERMS">n-1</div>
         <div class="singletermTERMS">Namespace-based Validation Dispatching Language</div>
         <div class="singletermTERMS">n+1</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">openContent</div>
         <div class="singletermTERMS">O-assignment</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">para</div>
         <div class="singletermTERMS">Proposition 1</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">rule-based</div>
         <div class="singletermTERMS">regular tree grammars</div>
         <div class="singletermTERMS">restrained competition grammar</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">section</div>
         <div class="singletermTERMS">sectOrPara</div>
         <div class="singletermTERMS">schema-valid</div>
         <div class="singletermTERMS">schema languages</div>
         <div class="singletermTERMS">single-type tree grammars</div>
         <div class="singletermTERMS">s ∈ E</div>
         <div class="singletermTERMS">single type tree grammar</div>
         <div class="singletermTERMS">similar</div>
         <div class="singletermTERMS">S → a(AB|BA)</div>
         <div class="singletermTERMS">S → a(AC|BD) A → b(C) B → b(D) C → c(ε) D → d(ε)</div>
         <div class="singletermTERMS">specialized DTDs</div>
         <div class="singletermTERMS">Schema Languages</div>
         <div class="singletermTERMS">Stührenberg</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">text</div>
         <div class="singletermTERMS">title</div>
         <div class="singletermTERMS">textType</div>
         <div class="singletermTERMS">type</div>
         <div class="singletermTERMS">tree grammars</div>
         <div class="singletermTERMS">the label of e is a,</div>
         <div class="singletermTERMS">terminals</div>
         <div class="singletermTERMS">Theorem 1</div>
         <div class="singletermTERMS">Theorem 2</div>
         <div class="singletermTERMS">Theorem 3</div>
         <div class="singletermTERMS">Theorem 4</div>
         <div class="singletermTERMS">Theorem 5</div>
         <div class="singletermTERMS">Theorem 6</div>
         <div class="singletermTERMS">There are GRCGs which are ambiguous.</div>
         <div class="singletermTERMS">Theorem 7</div>
         <div class="singletermTERMS">Theorem 8</div>
         <div class="singletermTERMS">Theorem 9</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">unambiguous restrained competition grammars</div>
         <div class="singletermTERMS">unique subtree grammar</div>
         <div class="singletermTERMS">Unique Particle Attribution</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">validity</div>
         <div class="singletermTERMS">valid</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xref</div>
         <div class="singletermTERMS">xsi:type</div>
         <div class="singletermTERMS">xs:key</div>
         <div class="singletermTERMS">xs:assert</div>
         <div class="singletermTERMS">X__</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="RefiningtheTaxonomyofXMLSchemaLanguagesAnewApproachforCategorizingXMLSchema%0ALanguagesinTermsofProcessingComplexityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">Refining the Taxonomy of XML Schema Languages. A new Approach for Categorizing XML
         Schema
         Languages in Terms of Processing Complexity
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2010</div>
            <div class="confdates e5">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">This paper presents a refined taxonomy of XML schema languages based on the work by
               
               <div class="xref e8" linkend="Murata2005"></div>. It can be seen as first building block for a more elaborate
               formal analysis of XML and its accompanied specifications, in this case: XML schema
               languages such as DTD, XSD and RELAX NG.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Maik</div>
               <div class="surname e12">Stührenberg</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Maik Stührenberg studied Computational Linguistics at Bielefeld University. After
                  working for four years as research assistant at Giessen University in different
                  text-technological projects, he is now a Ph. D. student and research assistant at
                  Bielefeld University. His main research interests include XML schema languages and
                  specifications for structuring and querying multi-dimensional annotated data.
               </div>
            </div>
         </div>
         <div class="author e15">
            <div class="personname e16">
               <div class="firstname e17">Christian</div>
               <div class="surname e18">Wurm</div>
            </div>
            <div class="personblurb e19">
               <div class="para e20">Christian Wurm is a Ph. D. student in Computational and Mathematical Linguistics at
                  Bielefeld University in the Cognitive Interaction Technology – Center of Excellence
                  (CITEC) at Bielefeld University.
               </div>
            </div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright © 2010 by the authors.  Used with
               permission.
            </div>
         </div>
         <div class="keywordset e23" role="author">
            <div class="keyword e24">XML</div>
            <div class="keyword e25">Formal Language Theory</div>
            <div class="keyword e26">Schema Languages</div>
         </div>
      </div>
      <div class="note e27">
         <div class="para e28">The authors would like to thank both the reviewers for their constructive comments
            and our
            colleagues Marcus Kracht and Jens Michaelis who provided additional insightful remarks.
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e29">
         <div class="title e30">Introduction</div>
         <div class="para e31">In this paper, we continue the fruitful research that has been performed on XML and
            formal language theory (see 
            <div class="xref e32" linkend="sec.xml_formal"></div>). As there is a close
            correspondence between schema languages and a hierarchy of tree languages discussed
            by 
            <div class="xref e33" linkend="Murata2005"></div>, and to which we will refer as the Murata hierarchy, formal language
            theory has been very useful to determine and describe the expressiveness and computability
            of
            different XML schema languages. From the point of view of formal language theory (ignoring
            things such as user-friendliness or software support, amongst others), the question
            which
            grammar formalism is most apt for defining a document grammar for a given XML markup
            language
            is determined by a trade-off between expressiveness on one side and processing complexity
            on
            the other side. The more expressive a grammar formalism is, the more resources we
            need for
            processing the corresponding languages, and the more likely are they to fall prey
            to
            ambiguity.
         </div>
         <div class="para e34">Expressiveness thus always comes at a cost; it is, however, not always quite clear
            at
            which cost. To make these things more clear is one goal of this paper. We will look
            at some
            well-known classes of formal grammars/languages that are relevant for XML, and scrutinize
            their expressivity and processing cost. Pursuing this approach, we will see that there
            are
            some other interesting and relevant classes, which have not been formally established
            yet to
            the best of our knowledge, and which we will define in the sequel. These classes partly
            refine, partly complement the hierarchy of 
            <div class="xref e35" linkend="Murata2005"></div>, and, as we will see,
            are partly already tacitly in use. Our main focus will not be on (non-)determinism
            in content
            models, that is, on properties of regular expressions; rather we will focus on determinism
            in
            tree structures, and try to formally clarify the relation between determinism and
            expressivity, as well as between locally and globally ambiguous grammars/trees. On
            the way, we
            provide some new results for the problem of ambiguity not only of grammars, but also
            of
            languages: as we will see, there are languages for which there is no unambiguous grammar,
            and
            not yet a class of grammars which generate all and only the languages for which there
            is an
            unambiguous grammar.
         </div>
         <div class="para e36">In contrast to other comparative analysis of XML schema languages, such as 
            <div class="xref e37" linkend="Lee2000"></div> or 
            <div class="xref e38" linkend="Ansari2009"></div>, the main research goal of our paper is
            thus a more elaborate and fine-grained theoretical approach based on work that has
            been
            already undertaken (see 
            <div class="xref e39" linkend="sec.xml_formal"></div>). The application examples shown in
            this paper (especially the ones given in 
            <div class="xref e40" linkend="sec.murata.locality"></div>) are clearly
            for demonstration purposes and do not necessarily introduce new findings.
         </div>
      </div><a name="XMLandFormalLanguageTheoryANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e41">
         <div class="title e42">XML and Formal Language Theory</div>
         <div class="para e43">The history of document grammars begins long before XML's success: in 
            <div class="xref e44" linkend="Goldfarb1978"></div> the first published formal 
            <div class="emphasis e45" role="ital">document type
               descriptions
            </div> can be found, while 1986 SGML Document Type Definition (DTD, 
            <div class="xref e46" linkend="SGML"></div>) were established, followed by XML's DTD (
            <div class="xref e47" linkend="XML10"></div>) and
            other XML schema languages that were created during XML's ongoing success. This time
            line
            begins even earlier, in 1955, when Noam Chomsky published his theory on formal grammar
            (
            <div class="xref e48" linkend="Chomsky1955"></div>, 
            <div class="xref e49" linkend="Chomsky1956"></div>).
         </div>
         <div class="para e50">One of the several benefits of XML markup languages is the possibility to use a schema
            (a
            document grammar) to assure not only 
            <div class="emphasis e51" role="ital">well-formedness</div>, but
            also 
            <div class="emphasis e52" role="ital">validity</div> of an instance of a given markup language. The
            XML specification defines well-formedness as follows: 
            <div class="popupBox e53">
               <div class="popupLabel" onmouseover="$('#d1e96').show('1000');" onmouseout="$('#d1e96').hide('1000');">[ blockquote ]</div>
               <div id="d1e96" style="display: none;">
                  <div class="blockquote">
                     <div class="para e54">A textual object is a well-formed XML document if: </div>
                     <div class="orderedlist e55">
                        <div class="listitem e56">
                           <div class="para e57">Taken as a whole, it matches the production labeled document.</div>
                        </div>
                        <div class="listitem e58">
                           <div class="para e59">It meets all the well-formedness constraints given in this specification.</div>
                        </div>
                        <div class="listitem e60">
                           <div class="para e61">Each of the parsed entities which is referenced directly or indirectly within the
                              document is well-formed.
                           </div>
                        </div>
                     </div>
                     <div class="attribution e62">
                        <div class="xref e63" linkend="XML"></div>, Section 2.1 "Well-Formed XML Documents"
                     </div>
                  </div>
               </div>
            </div> A valid instance in addition declares conformance and actually conforms to the
            rules of a schema of a given markup language. Or, in a more general way: 
            <div class="popupBox e64">
               <div class="popupLabel" onmouseover="$('#d1e113').show('1000');" onmouseout="$('#d1e113').hide('1000');">[ blockquote ]</div>
               <div id="d1e113" style="display: none;">
                  <div class="blockquote">
                     <div class="para e65">The intention or purpose of validation is to subject a document or data set to a test,
                        to determine whether it conforms to a given set of external criteria.
                     </div>
                     <div class="attribution e66">
                        <div class="xref e67" linkend="Piez2001"></div>, p. 144
                     </div>
                  </div>
               </div>
            </div> A validating parser takes an instance document (and the corresponding schema) as
            input and produces a validation report, 
            <div class="quote e68">which includes at least a return code reporting
               whether [t]he document is valid and an optional Post Schema Validation Infoset (PSVI),
               updating the original document's infoset (the information obtained from the XML document
               by
               the parser) with additional information (default values, datatypes, etc.)
            </div> (
            <div class="xref e69" linkend="vanderVlist2001"></div>). During this process different levels of validation may be
            checked, depending on the XML schema language used: validation of the instance's structure
            (i.e., the markup), datatyping (i.e., the content of individual leaf nodes), integrity
            (in
            terms of links, either between nodes within a document or between documents). In addition,
            other tests, usually called 
            <div class="emphasis e70" role="ital">business rules</div> may apply as well
            (see 
            <div class="xref e71" linkend="vanderVlist2001"></div>). While one may differentiate between the terms
            
            <div class="emphasis e72" role="ital">valid</div> (as defined by the XML specification and therefore
            only referring to validity according to a Document Type Definition) and 
            <div class="emphasis e73" role="ital">schema-valid</div> (i.e., valid according to one of the externally defined XML schema
            languages) we will use the former term throughout this paper as equal term for depicting
            the
            feature of confirmation to a given set of external criteria regardless of the schema
            language
            used. Furthermore, we will only discuss validation mechanisms through schema languages,
            therefore, technologies such as the 
            <div class="emphasis e74" role="ital">Content Assembly
               Mechanism
            </div> (CAM, see 
            <div class="xref e75" linkend="Carey2009"></div>) or meta-validation techniques
            such as 
            <div class="emphasis e76" role="ital">Namespace-based Validation Dispatching Language</div>
            (
            <div class="xref e77" linkend="NVDL"></div>) are not observed any further. Since we will focus on 
            <div class="emphasis e78" role="ital">grammar-based schema languages</div>, 
            <div class="emphasis e79" role="ital">rule-based</div>
            <div class="popupBox e80">
               <div class="popupLabel" onmouseover="$('#d1e153').show('1000');" onmouseout="$('#d1e153').hide('1000');">[ footnote ]</div>
               <div id="d1e153" style="display: none;">
                  <div class="footnote">
                     <div class="para e81">For a short discussion if Schematron is a rules language (or rule-based language)
                        see
                        
                        <div class="xref e82" linkend="Jeliffe2009"></div>.
                        
                     </div>
                  </div>
               </div>
            </div> (or 
            <div class="emphasis e83" role="ital">constraint-based</div>) 
            <div class="emphasis e84" role="ital">schema languages</div> such as 
            <div class="xref e85" linkend="Schematron"></div>, the 
            <div class="emphasis e86" role="ital">Constraint Language in XML</div> (CLiX, 
            <div class="xref e87" linkend="CLiX"></div>) or 
            <div class="xref e88" linkend="Moeller2005"></div> will not be observed either.
            <div class="popupBox e89">
               <div class="popupLabel" onmouseover="$('#d1e176').show('1000');" onmouseout="$('#d1e176').hide('1000');">[ footnote ]</div>
               <div id="d1e176" style="display: none;">
                  <div class="footnote">
                     <div class="para e90">For a different discussion on the topic of expressing constraints see 
                        <div class="xref e91" linkend="Bauman2008"></div>.
                     </div>
                  </div>
               </div>
            </div> For clarification reasons we follow the definitions of 
            <div class="xref e92" linkend="Costello2008"></div>:
            <div class="popupBox e93">
               <div class="popupLabel" onmouseover="$('#d1e184').show('1000');" onmouseout="$('#d1e184').hide('1000');">[ blockquote ]</div>
               <div id="d1e184" style="display: none;">
                  <div class="blockquote">
                     <div class="para e94">A grammar-based schema language specifies the structure and contents of elements and
                        attributes in an XML instance document. For example, a grammar-based schema language
                        can
                        specify the presence and order of elements in an XML instance document, the number
                        of
                        occurrences of each element, and the contents and datatype of each element and attribute.
                        A rule-based schema language specifies the relationships that must hold between the
                        elements and attributes in an XML instance document. For example, a rule-based schema
                        language can specify that the value of certain elements must conform to a rule or
                        algorithm.
                     </div>
                     <div class="attribution e95">
                        <div class="xref e96" linkend="Costello2008"></div>
                     </div>
                  </div>
               </div>
            </div>
            
         </div>
         <div class="para e97">When someone starts developing a new XML-based markup language sooner or later the
            question about a formalism to define the corresponding document grammar arises, since
            there is
            a variety of schema (definition) languages available. While a schema can be considered
            as a
            formal definition of a grammar of the XML-based markup language (e.g. as a set of
            rules or
            criteria), the schema language is 
            <div class="quote e98">a formal language for expressing schemas</div>
            (
            <div class="xref e99" linkend="Moeller2006"></div>). Usually, choosing a schema language depends on several
            factors such as familiarity with a given formalism or support provided by the chosen
            authoring
            software or processing tools such as 
            <div class="xref e100" linkend="XSLT2"></div> or 
            <div class="xref e101" linkend="XQuery"></div>.
            These factors are very specific for one's own needs and environment and we will not
            give any
            advice regarding these topics. However, what we want to demonstrate in this paper
            are the
            differences in terms of expressiveness and computability between the three most used
            XML
            schema languages, starting with XML's inherent Document Type Definition (DTD, see
            
            <div class="xref e102" linkend="XML10"></div>), based on SGML's DTD (see 
            <div class="xref e103" linkend="SGML"></div>, 
            <div class="xref e104" linkend="Goldfarb1991"></div>, 
            <div class="xref e105" linkend="Maler1995"></div>) where a non-XML syntax is used
            <div class="popupBox e106">
               <div class="popupLabel" onmouseover="$('#d1e210').show('1000');" onmouseout="$('#d1e210').hide('1000');">[ footnote ]</div>
               <div id="d1e210" style="display: none;">
                  <div class="footnote">
                     <div class="para e107">We will not discuss any proposals for extended DTDs such as 
                        <div class="xref e108" linkend="Buck2000"></div>, 
                        <div class="xref e109" linkend="Papakonstantinou2000"></div>, 
                        <div class="xref e110" linkend="Vitali2003"></div>
                        
                        <div class="xref e111" linkend="Balmin2004"></div> or 
                        <div class="xref e112" linkend="Fiorello2004"></div> since these play only minor
                        roles in the wild, if any.
                     </div>
                  </div>
               </div>
            </div>, over W3C's XML Schema Description Language (
            <div class="xref e113" linkend="XMLSchema2004"></div>,
            
            <div class="xref e114" linkend="XMLSchema2004a"></div>, 
            <div class="xref e115" linkend="XMLSchema2004b"></div>) and the formal language
            theory based RELAX NG (see 
            <div class="xref e116" linkend="RELAX"></div>, 
            <div class="xref e117" linkend="vanderVlist2003"></div>, 
            <div class="xref e118" linkend="RELAX2nd"></div> as a successor to both RELAX (
            <div class="xref e119" linkend="RELAXCore"></div>) and TREX
            (
            <div class="xref e120" linkend="Clark2001"></div>).
         </div>
      </div><a name="FormalLanguageTheoryandXMLANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e121" xml:id="sec.xml_formal">
         <div class="title e122">Formal Language Theory and XML</div>
         <div class="para e123">Although the formal model of an XML instance is always a single rooted tree, the different
            schema languages that can be used to define and constrain instances can be differentiated
            according to their expressiveness and – in a further step – according to their
            computability, which may be interesting when dealing with a task such as programming
            a
            validating parser. Different authors have dealt with the relationship between XML
            applications
            and formal languages, for example 
            <div class="xref e124" linkend="Brueggemann-Klein1992"></div>, 
            <div class="xref e125" linkend="Brueggemann-Klein1993"></div>, 
            <div class="xref e126" linkend="Brueggemann-Klein1997"></div>, 
            <div class="xref e127" linkend="Hopcroft2000"></div>, 
            <div class="xref e128" linkend="Rizzi2001"></div>, 
            <div class="xref e129" linkend="Mani2001"></div>, 
            <div class="xref e130" linkend="Murata2001"></div>, 
            <div class="xref e131" linkend="Brueggemann-Klein2002"></div>, 
            <div class="xref e132" linkend="Sperberg-McQueen2003"></div>, 
            <div class="xref e133" linkend="Klarlund2003"></div>, 
            <div class="xref e134" linkend="Brueggemann-Klein2004"></div>, 
            <div class="xref e135" linkend="Murata2005"></div>, 
            <div class="xref e136" linkend="Martens2005"></div>, 
            <div class="xref e137" linkend="Kilpeläinen2007"></div>, 
            <div class="xref e138" linkend="Comon2008"></div>, 
            <div class="xref e139" linkend="Martens2009"></div>, and 
            <div class="xref e140" linkend="Gelade2009"></div>. Often, a formal specification of
            XML's inherent 
            <div class="code e141">ID</div>/
            <div class="code e142">IDREF</div> mechanism is omitted; however, 
            <div class="xref e143" linkend="Abiteboul2000"></div>, p. 33 claim that these references can be used to describe graphs
            rather than trees, since they allow for multidominance structures. (see 
            <div class="xref e144" linkend="Stuehrenberg2009"></div> for a practical implementation of using
            
            <div class="code e145">ID</div>/
            <div class="code e146">IDREF</div> for realizing graph structures within XML's tree model).
            
            <div class="xref e147" linkend="Kracht2010"></div> uses modal logic to provide a semantics for XML-documents, and
            to characterize XML markup and search and retrieval mechanisms such as XPath. Other
            work
            leaves the formal model of XML and deals with graph structures that can be described
            by either
            XML or XML-like markup languages (see 
            <div class="xref e148" linkend="Marcoux2008"></div> for a graph
            characterization of TexMECS and other overlapping markup formalisms), but in this
            paper we
            will concentrate on schema languages that describe well-formed (that is tree-like)
            XML-documents. 
         </div>
         <div class="para e149">Typically, DTDs are characterized as 
            <div class="emphasis e150" role="ital">extended context-free
               grammars
            </div> (see 
            <div class="xref e151" linkend="Hopcroft2000"></div> and 
            <div class="xref e152" linkend="Rizzi2001"></div>),
            that is, on the right-hand-side of a production rule regular expressions are allowed.
            This
            means for the declaration of an element that its allowed content is described by a
            regular
            expression using other element names (i.e., referring to other or the very same globally
            declared elements) or reserved keywords such as 
            <div class="code e153">#PCDATA</div> or 
            <div class="code e154">EMPTY</div>. In
            current work, especially 
            <div class="xref e155" linkend="Murata2005"></div> and 
            <div class="xref e156" linkend="Moeller2006"></div>, a
            family of 
            <div class="emphasis e157" role="ital">tree grammars</div> is used to model XML schema
            languages; for example, DTDs are defined as 
            <div class="emphasis e158" role="ital">local tree
               grammars
            </div> which can be considered strongly equivalent to CFGs, with the only
            difference that they allow non-finitary branching: 
            <div class="popupBox e159">
               <div class="popupLabel" onmouseover="$('#d1e330').show('1000');" onmouseout="$('#d1e330').hide('1000');">[ blockquote ]</div>
               <div id="d1e330" style="display: none;">
                  <div class="blockquote">
                     <div class="para e160">Ignoring the attributes for a moment, there is a simple but elegant connection between
                        DTDs and context-free grammars, namely, each DTD corresponds to an 
                        <div class="emphasis e161" role="ital">extended context-free grammar</div>, where productions may have regular
                        expressions on their right-hand side. Then, an XML document is valid with respect
                        to the
                        DTD precisely when its associated tree is a correct derivation tree for that
                        grammar.
                     </div>
                     <div class="attribution e162">
                        <div class="xref e163" linkend="Klarlund2003"></div>, p. 13
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="para e164">In addition to using local tree grammars for characterizing DTDs, 
            <div class="xref e165" linkend="Murata2005"></div> construe a taxonomy of XML schema languages. The authors introduce
            
            <div class="emphasis e166" role="ital">single-type tree grammars</div>, as characterizing XML Schema,
            and use 
            <div class="emphasis e167" role="ital">regular tree grammars</div> to characterize RELAX NG.
            Although this work is quite extensive, the formal analysis can be further improved
            by
            clarifying some propositions. Given the (still growing) importance of XML and the
            broad range
            of tasks it is used for, stronger theoretical background seems to be the best way
            to find new
            applications. Before we present our results, we have to introduce the formal concepts
            we are
            working with.
         </div>
      </div><a name="RefiningtheTaxonomyofXMLSchemaLanguagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e168">
         <div class="title e169">Refining the Taxonomy of XML Schema Languages</div><a name="IntroductiontotheFormalConceptsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e170">
            <div class="title e171">Introduction to the Formal Concepts</div>
            <div class="para e172">In this paper, we will mainly use tree grammars. Since the use of tree grammars is
               well
               established in the XML community, we will just shortly provide the necessary definitions;
               for a more explicit treatment and motivation, we defer the reader to 
               <div class="xref e173" linkend="Gecseg1997"></div> or 
               <div class="xref e174" linkend="Murata2005"></div>.
            </div>
            <div class="para e175">
               <div class="emphasis e176" role="bold">Definition 1 </div>
               
               <div class="emphasis e177" role="ital">A regular tree grammar (RTG) is a 4-tuple (N,T,S,P), where N is a
                  finite set of nonterminals, T is a finite set of terminals, S is a set of start symbols,
                  which form a subset of N, P is a set of production rules, which have the form: A →
                  a(r), where A ∈ N, a ∈ T, and r is a regular expression over elements of N. We
                  call A the left hand side of a rule, a the terminal or label which is introduced by
                  the
                  rule, and r its content model.
               </div>
            </div>
            <div class="para e178"> We generally use uppercase letters for nonterminals, and lower-case letters for
               terminals. Note that this grammar generates trees, not strings, and that the nonterminals
               do
               not remain the labels of the (non-leaf) nodes they introduce, but are substituted
               by the
               terminal labels. The class of languages generated by RTGs is called the regular tree
               languages (RTLs). This is the most general class of languages we will consider here;
               and we
               now introduce various restrictions on this class of grammars, as they are defined
               by 
               <div class="xref e179" linkend="Murata2005"></div>. 
            </div>
            <div class="para e180">
               <div class="emphasis e181" role="bold">Definition 2</div>
               
               <div class="emphasis e182" role="ital">We call two rules of a RTG competing, if they introduce the same
                  terminal nodes, but have different left hand sides. Thus, A → a(r) and B →
                  a(r') are competing. 
               </div>
            </div>
            <div class="para e183">In general, in an RTG we can merge any two rules which have the same left-hand side
               and
               introduce the same terminal, by merging their content models, because for any two
               regular
               expressions we can easily form a single expression which denotes is the union of both.
               Therefore, we will generally assume that in our grammars any two rules with same left-hand
               side and same terminal do not exist. As a consequence, the concept of competing rules
               is the
               crucial point if we deal with determinism and ambiguity. For the same reason, we can
               speak
               of competing nonterminals almost in the same way as of competing rules: competing
               nonterminals are the left-hand sides of competing rules; a grammar has competing
               nonterminals exactly if it has competing rules, and exactly as many as.
            </div>
            <div class="para e184">
               <div class="emphasis e185" role="bold">Definition 3</div>
               
               <div class="emphasis e186" role="ital">A local tree grammar (LTG) is an RTG with no competing
                  rules.
               </div>
            </div>
            <div class="para e187">In an LTG, we have thus a one-to-one correspondence of nonterminals and terminals,
               which
               makes them very similar to context-free grammars (though not identical, since regular
               content models allow for non-finitary branching).
            </div>
            <div class="para e188">
               <div class="emphasis e189" role="bold">Definition 4</div>
               
               <div class="emphasis e190" role="ital">A single type tree grammar (STG) is an RTG, where competing
                  nonterminals must not occur in the same content model.
               </div>
            </div>
            <div class="para e191">As 
               <div class="xref e192" linkend="Murata2005"></div> point out, LTGs roughly correspond to DTDs, STGs
               correspond to XML Schema, and RTGs correspond to Relax NG. Note that this correspondence
               is
               established by only regarding the "core" syntactic features of the schema languages,
               that is
               XML's inherent reference mechanism is not taken into account. These are thus the most
               important grammar types for XML. 
               <div class="xref e193" linkend="Murata2005"></div> still add another type:
            </div>
            <div class="para e194">
               <div class="emphasis e195" role="bold">Definition 5</div>
               
               <div class="emphasis e196" role="ital">A restrained competition grammar (RCG) is an RTG, where competing
                  nonterminals must not occur in the same content model and with the same prefix of
                  nonterminals; we thus disallow rules with identical left-hand side, terminals, and
                  content
                  models of the form (Γ A Δ) and (Γ B Δ'), where A and B are competing
                  nonterminals, and where uppercase Greek letters refer to possibly empty sequences
                  of
                  nonterminals.
               </div>
            </div>
            <div class="para e197">Notably, the restriction concerns only the left context of the competing nonterminals.
               Of course, there exists a parallel definition for the right context. The problem is
               that
               both definitions lack some generalization, as they both generate different classes
               of
               languages, and there is no inclusion in either direction. If we, however, generalize
               the
               restriction of competition to both the left and the right context (which weakens the
               overall
               restriction on the grammar), some problems arise. We will discuss possible generalizations
               later on.
            </div>
            <div class="para e198">It is easily seen that there is a hierarchy of proper inclusion of the grammar types
               presented: LTGs are always STGs, which are always RCGs, which are always RTGs, whereas
               the
               converse does not hold.
            </div>
            <div class="para e199">We furthermore define an interpretation of a given tree against a given grammar as
               follows:
            </div>
            <div class="para e200">
               <div class="emphasis e201" role="bold">Definition 6 </div>
               
               <div class="emphasis e202" role="ital">An interpretation I of a
                  tree t against a grammar G is a mapping from each node label of t, denoted by e, to
                  a
                  nonterminal N of the grammar, such that
               </div>
            </div>
            <div class="itemizedlist e203">
               <div class="listitem e204">
                  <div class="para e205">
                     <div class="emphasis e206" role="ital">I(e) is a start symbol when e is the root of
                        t,
                     </div>
                  </div>
               </div>
               <div class="listitem e207">
                  <div class="para e208">
                     <div class="emphasis e209" role="ital">for each e and its daughter nodes e
                        <div class="subscript e210">0</div>,
                        e
                        <div class="subscript e211">1</div>,...,e
                        <div class="subscript e212">n</div>, there is a production rule
                        A → a(r) in G, such that
                     </div>
                  </div>
                  <div class="itemizedlist e213">
                     <div class="listitem e214">
                        <div class="para e215">
                           <div class="emphasis e216" role="ital">I(e) is A,</div>
                        </div>
                     </div>
                     <div class="listitem e217">
                        <div class="para e218">
                           <div class="emphasis e219" role="ital">the label of e is a,</div>
                        </div>
                     </div>
                     <div class="listitem e220">
                        <div class="para e221">
                           <div class="emphasis e222" role="ital">I(e
                              <div class="subscript e223">0</div>),
                              I(e
                              <div class="subscript e224">1</div>),...,I(e
                              <div class="subscript e225">n</div>) matches
                              r.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e226">As is easily seen, with this definition, the ease of interpretation directly interacts
               with the Murata hierarchy. We will continue in this vein. To keep things clear, it
               is
               crucial to distinguish between the label of a node and its interpretation: the label
               of a
               node corresponds to its terminal in the production rule (recall that tree grammars
               directly
               generate trees, not strings via trees as CFGs), and it is immediately visible in the
               tree.
               By the interpretation of a node in turn we denote the nonterminal by which the node
               label
               has been produced. This nonterminal is not visible and has to be inferred. In addition,
               we
               have to distinguish between rule and rule instantiation: since content models are
               regular
               expressions over nonterminals, they denote sets of sequences of nonterminals, and
               one member
               of this set is an instantiation. An additional problem arises in interaction with
               the fact
               that there is no necessary one-to-one correspondence of nonterminals and terminals
               (i.e.,
               labels); a possible consequence is that the same sequence of labels can be produced
               by
               different instantiations of a content model (we will exhaustively discuss this source
               of
               ambiguity later on).
            </div>
            <div class="para e227">So far, we have introduced the main concepts which are well-known in the literature,
               and
               which we are going to use and elaborate in this paper.
            </div>
         </div><a name="AnExampleGrammarANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e228">
            <div class="title e229">An Example Grammar</div>
            <div class="para e230">We will use the following example to demonstrate some of our findings. We want to
               define
               a document grammar for a text. The text may contain an optional title, followed by
               either at
               least a single section or a single paragraph. An optional author entity (possibly
               decoded
               using an attribute) may contain information about the text's author. Inside a section
               an
               optional title followed by other (sub-)sections or paragraphs are allowed. The title
               consists of raw text while a paragraph may contain raw text or a reference to other
               paragraphs, since these may have an optional identifier (using XML's 
               <div class="code e231">ID</div>
               type).
            </div>
            <div class="para e232">If we try to express these constraints more formally we might end up with a grammar
               similar to the one shown in 
               <div class="xref e233" linkend="fig.grammar"></div>. Again, nonterminals are printed
               in capital letters, while node labels or terminals are printed in small letters. Note,
               that
               in this formulation elements, attributes and raw text are defined as terminals.
            </div>
            <div class="figure e234" xml:id="fig.grammar">
               <div class="title e235">An example grammar</div>
               <div class="programlisting e236" xml:space="preserve">
                  <div class="emphasis e237" role="ital">S → text(author,Title? (Section|Para))
                     Section → section(Title? (Section|Para))
                     Title → title(#pcdata)
                     Para → para(id, #pcdata|Xref)
                     Xref → xref(href,ε) 
                  </div>
               </div>
            </div><a name="TheExampleGrammarRealizedbyaDTD(LocalTreeGrammar)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e238">
               <div class="title e239">The Example Grammar Realized by a DTD (Local Tree Grammar)</div>
               <div class="para e240">Following 
                  <div class="xref e241" linkend="Murata2005"></div>, DTDs can be classified as local tree grammars.
                  A possible realization for our example grammar can be seen in 
                  <div class="xref e242" linkend="lst.dtd"></div>.
               </div>
               <div class="figure e243" xml:id="lst.dtd">
                  <div class="title e244">DTD realization of the example grammar</div>
                  <div class="programlisting e245" xml:space="preserve">&lt;!ELEMENT text (title?, (section | para)+)&gt;
                     &lt;!ATTLIST text author CDATA #IMPLIED&gt;
                     &lt;!ELEMENT title (#PCDATA)&gt;
                     &lt;!ELEMENT section (title?, (section | para)+)&gt;
                     &lt;!ELEMENT para (#PCDATA | xref)*&gt;
                     &lt;!ATTLIST para id ID #IMPLIED&gt;
                     &lt;!ELEMENT xref EMPTY&gt;
                     &lt;!ATTLIST xref href IDREF #REQUIRED&gt;
                  </div>
               </div>
               <div class="para e246">Since local tree grammars and DTDs only support globally declared elements (and
                  locally declared attributes), the content models of the 
                  <div class="code e247">text</div> and the
                  
                  <div class="code e248">section</div> element share references to the same three elements
                  (
                  <div class="code e249">title</div>, 
                  <div class="code e250">section</div> and 
                  <div class="code e251">para</div>) and contain both a
                  sequence and a choice together with the occurrence indicators 
                  <div class="code e252">+</div> (at least one
                  occurrence) and 
                  <div class="code e253">?</div> (optional). The content model of the 
                  <div class="code e254">para</div>
                  element contains mixed content, that is both raw text and the 
                  <div class="code e255">xref</div> element
                  are allowed as children. Since DTDs force the use of the choice group (
                  <div class="code e256">|</div>) and
                  the trailing asterisk (
                  <div class="code e257">*</div>) as occurrence indicator, there is no other way to
                  define this specific content model using this schema language.
               </div>
               <div class="para e258">Note that DTDs do not support any type mechanism. 
                  <div class="xref e259" linkend="Buck2000"></div>, 
                  <div class="xref e260" linkend="Papakonstantinou2000"></div>, 
                  <div class="xref e261" linkend="Balmin2004"></div> and 
                  <div class="xref e262" linkend="Martens2006"></div> suppose the extension of DTDs by adding types, while DTD++,
                  proposed by 
                  <div class="xref e263" linkend="Vitali2003"></div> adds namespace awareness on top, and DTD++ 2.0
                  (see 
                  <div class="xref e264" linkend="Fiorello2004"></div>) even supports co-constraints.
               </div>
            </div><a name="TheExampleGrammarRealizedbyanXSD(SingleTypeTreeGrammar)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e265">
               <div class="title e266">The Example Grammar Realized by an XSD (Single Type Tree Grammar)</div>
               <div class="para e267">An XML schema description (i.e., a single type tree grammar) of the same document
                  grammar may look like the one in 
                  <div class="xref e268" linkend="lst.xsd"></div>.
               </div>
               <div class="figure e269" xml:id="lst.xsd">
                  <div class="title e270">XSD realization of the example grammar</div>
                  <div class="programlisting e271" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                     &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
                     &lt;xs:element name="text"&gt;
                     &lt;xs:complexType&gt;
                     &lt;xs:complexContent&gt;
                     &lt;xs:extension base="textType"&gt;
                     &lt;xs:attribute name="author" type="xs:string" use="optional"/&gt;
                     &lt;/xs:extension&gt;
                     &lt;/xs:complexContent&gt;
                     &lt;/xs:complexType&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:element name="title" type="xs:string"/&gt;
                     &lt;xs:element name="section" type="textType"/&gt;
                     &lt;xs:element name="para"&gt;
                     &lt;xs:complexType mixed="true"&gt;
                     &lt;xs:sequence&gt;
                     &lt;xs:element name="xref" minOccurs="0"&gt;
                     &lt;xs:complexType&gt;
                     &lt;xs:attribute name="href" type="xs:IDREF" use="required"/&gt;
                     &lt;/xs:complexType&gt;
                     &lt;/xs:element&gt;
                     &lt;/xs:sequence&gt;
                     &lt;xs:attribute ref="id" use="optional"/&gt;
                     &lt;/xs:complexType&gt;
                     &lt;/xs:element&gt;
                     &lt;xs:attribute name="id" type="xs:ID"/&gt;
                     &lt;xs:complexType name="textType"&gt;
                     &lt;xs:sequence&gt;
                     &lt;xs:element ref="title" minOccurs="0"/&gt;
                     &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
                     &lt;/xs:sequence&gt;
                     &lt;/xs:complexType&gt;
                     &lt;xs:group name="sectOrPara"&gt;
                     &lt;xs:choice&gt;
                     &lt;xs:element ref="section"/&gt;
                     &lt;xs:element ref="para"/&gt;
                     &lt;/xs:choice&gt;
                     &lt;/xs:group&gt;
                     &lt;/xs:schema&gt;
                  </div>
               </div>
               <div class="para e272">Note that this XML schema description is only one possible realization out of a
                  variety of different XML schema descriptions that would fit our needs. Although it
                  may be
                  not very human-readable, it was designed to show some features that are supported
                  by XSD.
                  The 
                  <div class="code e273">text</div> element is derived by extension of the globally declared complexType
                  
                  <div class="code e274">textType</div> which itself refers to the globally declared model group
                  
                  <div class="code e275">sectOrPara</div>. The schema contains both locally and globally declared
                  attributes (
                  <div class="code e276">author</div> vs. 
                  <div class="code e277">id</div>) and elements (
                  <div class="code e278">xref</div> as an
                  example for a locally declared element). Apart from that, XSD supports 
                  <div class="xref e279" linkend="XMLNS"></div> which are not shown in the example above. As 
                  <div class="xref e280" linkend="Martens2006"></div> has already pointed out, that the actual extra expressive power
                  of XSDs over DTDs can only be used to a very limited extent due to the 
                  <div class="emphasis e281" role="ital">Element Declarations Consistent</div> (EDC) constraint (see 
                  <div class="xref e282" linkend="XMLSchema2004a"></div>, Section 3.8.6).
               </div>
            </div><a name="TheExampleGrammarRealizedbyaRELAXNGGrammar(RegularTreeGrammar)ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e283">
               <div class="title e284">The Example Grammar Realized by a RELAX NG Grammar (Regular Tree Grammar)</div>
               <div class="para e285">RELAX NG can be classified as regular tree grammar according to 
                  <div class="xref e286" linkend="Murata2005"></div>. A possible realization with RELAX NG is shown in 
                  <div class="xref e287" linkend="lst.relaxng"></div>.
               </div>
               <div class="figure e288" xml:id="lst.relaxng">
                  <div class="title e289">RELAX NG realization of the example grammar</div>
                  <div class="programlisting e290" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                     &lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
                     datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
                     &lt;start&gt;
                     &lt;element name="text"&gt;
                     &lt;optional&gt;
                     &lt;attribute name="author"/&gt;
                     &lt;/optional&gt;
                     &lt;choice&gt;
                     &lt;optional&gt;
                     &lt;group&gt;
                     &lt;ref name="element.title"/&gt;
                     &lt;ref name="element.section"/&gt;
                     &lt;/group&gt;
                     &lt;/optional&gt;
                     &lt;optional&gt;
                     &lt;group&gt;
                     &lt;ref name="element.title"/&gt;
                     &lt;ref name="element.para"/&gt;
                     &lt;/group&gt;
                     &lt;/optional&gt;
                     &lt;/choice&gt;
                     &lt;/element&gt;
                     &lt;/start&gt;
                     &lt;define name="element.title"&gt;
                     &lt;element name="title"&gt;
                     &lt;text/&gt;
                     &lt;/element&gt;
                     &lt;/define&gt;
                     &lt;define name="element.section"&gt;
                     &lt;element name="section"&gt;
                     &lt;optional&gt;
                     &lt;ref name="element.title"/&gt;
                     &lt;/optional&gt;
                     &lt;ref name="sectOrPara"/&gt;
                     &lt;/element&gt;
                     &lt;/define&gt;
                     &lt;define name="element.para"&gt;
                     &lt;element name="para"&gt;
                     &lt;optional&gt;
                     &lt;attribute name="id"&gt;
                     &lt;data type="ID"/&gt;
                     &lt;/attribute&gt;
                     &lt;/optional&gt;
                     &lt;zeroOrMore&gt;
                     &lt;choice&gt;
                     &lt;text/&gt;
                     &lt;element name="xref"&gt;
                     &lt;attribute name="href"&gt;
                     &lt;data type="IDREF"/&gt;
                     &lt;/attribute&gt;
                     &lt;empty/&gt;
                     &lt;/element&gt;
                     &lt;/choice&gt;
                     &lt;/zeroOrMore&gt;
                     &lt;/element&gt;
                     &lt;/define&gt;
                     &lt;define name="sectOrPara"&gt;
                     &lt;group&gt;
                     &lt;oneOrMore&gt;
                     &lt;choice&gt;
                     &lt;ref name="element.section"/&gt;
                     &lt;ref name="element.para"/&gt;
                     &lt;/choice&gt;
                     &lt;/oneOrMore&gt;
                     &lt;/group&gt;
                     &lt;/define&gt;
                     &lt;/grammar&gt;
                  </div>
               </div>
               <div class="para e291">Compared to DTD or XSD, RELAX NG is based both on the mathematical theory of regular
                  expressions and the concept of hedge grammars (
                  <div class="xref e292" linkend="vanderVlist2003"></div> and 
                  <div class="xref e293" linkend="Murata2005"></div>). As an XML schema language, RELAX NG has some advantages over
                  other schema languages: while in DTDs and XSD mixed content models may contain child
                  elements and text nodes in any arbitrary order, RELAX NG allows for ordering of the
                  element child nodes (see 
                  <div class="xref e294" linkend="vanderVlist2003"></div>, p. 57f.). Co-occurrence
                  constraints can be used to specify the content model of an item according to the value
                  of
                  another item, allowing non-deterministic content models which cannot be realized in
                  DTD or
                  XSD (see 
                  <div class="xref e295" linkend="vanderVlist2003"></div>, p. 62f, and 
                  <div class="xref e296" linkend="sec.determinism"></div>
                  for a discussion). In general, a co-occurrence constraint (or co-constraint as they
                  are
                  called by 
                  <div class="xref e297" linkend="Pawson2007"></div>) may 
                  <div class="quote e298">be a constraint over multiple items,
                     not just two items
                  </div> and 
                  <div class="quote e299">may exist between XML structure components
                     (elements, attributes) as well as between data values
                  </div>. One may differentiate
                  between element-to-element, element-to-attribute, or attribute-attribute co-occurrence
                  constraint, based on the items involved.
               </div>
               <div class="para e300"> In addition, SGML's interleave operator 
                  <div class="code e301">&amp;</div> (see 
                  <div class="xref e302" linkend="Goldfarb1991"></div>, p. 291) that is missing in XML DTD and XSD can be used in
                  RELAX NG as well, although this adds nothing to its expressive power. In contrast
                  to the
                  two other schema languages discussed in this paper, RELAX NG does not support default
                  values (which are supported for attributes in DTD and for attributes and elements
                  in XSD).
                  While both DTD and XSD support XML references via
                  
                  <div class="code e303">ID</div>/
                  <div class="code e304">IDREF</div>(
                  <div class="code e305">S</div>) attribute types, RELAX NG has no
                  included datatype library; however, as seen in the example grammar, it is possible
                  to
                  include the datatype library of 
                  <div class="xref e306" linkend="XMLSchema2004b"></div>.
               </div>
               <div class="para e307">The document instance given in 
                  <div class="xref e308" linkend="lst.instance"></div> would be valid according
                  to all of the above defined document grammars (the example shows validation against
                  the
                  XML schema, adding a Doctype declaration and removing the
                  
                  <div class="code e309">noNamespaceSchemaLocation</div> attribute of the root element would result in a
                  valid instance according to the DTD. Note that RELAX NG does not contain a standard
                  way to
                  associate a RELAX NG schema to an XML instance since it was designed as part of the
                  ISO
                  DSDL framework (in this framework, the 
                  <div class="xref e310" linkend="NVDL"></div> should be used as general
                  external mechanism for validating instances).
               </div>
               <div class="figure e311" xml:id="lst.instance">
                  <div class="title e312">Valid XML instance</div>
                  <div class="programlisting e313" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                     &lt;text xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:noNamespaceSchemaLocation="text.xsd" author="maik"&gt;
                     &lt;title&gt;A simple title&lt;/title&gt;
                     &lt;section&gt;
                     &lt;title&gt;A section title&lt;/title&gt;
                     &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
                     &lt;section&gt;
                     &lt;title&gt;A subsection title&lt;/title&gt;
                     &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
                     &lt;/section&gt;
                     &lt;/section&gt;
                     &lt;/text&gt;
                  </div>
               </div>
            </div>
         </div>
      </div><a name="DeterminismandLocalAmbiguityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e314">
         <div class="title e315">Determinism and Local Ambiguity</div>
         <div class="para e316">Determinism is a important property for XML Documents, schema languages and
            interpretation. If a grammar is deterministic, parsing will be much more efficient,
            since in
            general we do not have to keep in mind any information, do not have to backtrack,
            do not need
            any non-local information in case we search, etc.
            <div class="popupBox e317">
               <div class="popupLabel" onmouseover="$('#d1e666').show('1000');" onmouseout="$('#d1e666').hide('1000');">[ footnote ]</div>
               <div id="d1e666" style="display: none;">
                  <div class="footnote">
                     <div class="para e318">
                        <div class="xref e319" linkend="Murata2005"></div> present an algorithm using tree-automata that allows for
                        efficient parsing of regular tree grammars.
                     </div>
                  </div>
               </div>
            </div> The concept of determinism is closely related to the concept of local ambiguity:
            if there is no local ambiguity, then at every point in the parsing process we know
            the
            structure (in this case: interpretation) of what we have seen so far, because there
            is
            only one possible local analysis. If there is some local ambiguity, non-determinism
            arises: we
            cannot assign a unique interpretation locally, for we would need information which
            is not
            available yet, and we need to apply some heuristics.
         </div><a name="DeterminismAlgorithmsandLocalAmbiguitiesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e320" xml:id="sec.determinism">
            <div class="title e321">Determinism, Algorithms and Local Ambiguities</div>
            <div class="para e322">In this section we will review the concept of determinism, as opposed to local ambiguity
               of a grammar. As introductory issue, we show that determinism does not only depend
               on the
               grammar we use, but also on the algorithm. In regular tree languages, there can be
               no
               one-dimensional concept of determinism, as there is for regular string languages.
               Note that
               this is more than a metaphor, since we can perceive of regular string languages as
               one-dimensional structures; in order to talk about trees or the strings formed by
               their
               leaves, we need at least two dimensions (see 
               <div class="xref e323" linkend="Rogers2003"></div>). In the
               remainder, we will show how different grammar types provide determinism for all, some
               particular class of, or no algorithms.
            </div>
         </div><a name="DeterministicContentModelsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e324">
            <div class="title e325">Deterministic Content Models</div>
            <div class="para e326">Firstly, we consider the concept of deterministic content models. This draws on the
               notion of deterministic (or 1-unambiguous) regular expressions (DREs), thoroughly
               surveyed
               by 
               <div class="xref e327" linkend="Brueggemann-Klein1997"></div>
               <div class="popupBox e328">
                  <div class="popupLabel" onmouseover="$('#d1e684').show('1000');" onmouseout="$('#d1e684').hide('1000');">[ footnote ]</div>
                  <div id="d1e684" style="display: none;">
                     <div class="footnote">
                        <div class="para e329">See 
                           <div class="xref e330" linkend="Mani2001"></div> for a discussion of the pros and cons of
                           1-unambiguous content models in XML schema languages.
                        </div>
                     </div>
                  </div>
               </div>. Assume we have a string 
               <div class="emphasis e331" role="ital">s</div> which is denoted by
               some regular expression 
               <div class="emphasis e332" role="ital">E</div>. Assume furthermore we build our
               expressions with letters from an alphabet 
               <div class="emphasis e333" role="ital">Π</div>, which is
               identical to the alphabet 
               <div class="emphasis e334" role="ital">Σ</div>, except for the fact that
               we have additional indices for the letters (taken here from the set of natural numbers).
               If
               we build an expression from 
               <div class="emphasis e335" role="ital">Π</div>, we have to make sure
               that every index must occur at most once in it. Constructors for regular expressions
               are as
               usual, and indices are passed on to the letters of the strings the expression denotes.
               We
               say that a letter in 
               <div class="emphasis e336" role="ital">s</div> instantiates a letter in 
               <div class="emphasis e337" role="ital">E</div>, if the following holds:
            </div>
            <div class="para e338">
               
               <div class="emphasis e339" role="bold">Definition 7</div>
               
               <div class="emphasis e340" role="ital">A letter a
                  <div class="subscript e341">i</div> in s instantiates a letter
                  a
                  <div class="subscript e342">j</div> from E, if i = j.
               </div>
            </div>
            <div class="para e343">The index ensures that for every string an expression denotes, there is a unique
               surjective mapping from letters in 
               <div class="emphasis e344" role="ital">s</div> to letters in
               
               <div class="emphasis e345" role="ital">E</div>. We now define a mapping 
               <div class="emphasis e346" role="ital">♮</div> on strings over 
               <div class="emphasis e347" role="ital">Π</div> to strings
               over 
               <div class="emphasis e348" role="ital">Σ</div>, such that 
               <div class="emphasis e349" role="ital">
                  ♮(x
                  <div class="subscript e350">i</div>):= x,
                  ♮(xs):=♮(x)♮(s)
               </div>, where 
               <div class="emphasis e351" role="ital"> s</div>
               is a string and 
               <div class="emphasis e352" role="ital">x</div> a letter (the first of the string). This
               homomorphism simply deletes the indices and leaves anything else untouched. Note that
               for a
               unique string 
               <div class="emphasis e353" role="ital">♮s</div>, and a given expression 
               <div class="emphasis e354" role="ital">E</div>, there might be several 
               <div class="emphasis e355" role="ital">s ∈
                  E
               </div>, such that their mapping under 
               <div class="emphasis e356" role="ital">♮</div> is
               identical. In this case we say that a letter in 
               <div class="emphasis e357" role="ital">s</div> might
               instantiate several letters in 
               <div class="emphasis e358" role="ital">E</div>. A deterministic regular
               expression over 
               <div class="emphasis e359" role="ital">Π</div> is then defined as follows:
            </div>
            <div class="para e360">
               
               <div class="emphasis e361" role="bold">Definition 8</div>
               
               <div class="emphasis e362" role="ital">E is deterministic or one-unambiguous, if for all strings u, v, w over
                  Π, and all letters x, y in Π, the following holds: if uxv and uyw ∈ L(E),
                  and x ≠ y, then also ♮ x ≠ ♮ y
               </div>.
            </div>
            <div class="para e363"> This means that we can skip the indices, and we still know which letter in 
               <div class="emphasis e364" role="ital">E</div> is instantiated by any letter in 
               <div class="emphasis e365" role="ital">s</div>, simply from knowing its left context. Formally, this means that the mapping
               ♮ is reversible. A regular language is deterministic if it is denoted by a
               deterministic regular expression. A simple example of a non-deterministic expression
               is the
               expression 
               <div class="emphasis e366" role="ital">a*b*a*</div>, as we can easily check for the string
               
               <div class="emphasis e367" role="ital">a</div>, which might be the instantiation of either of the two
               
               <div class="emphasis e368" role="ital">a</div>s.
            </div>
            <div class="para e369">As a consequence for processing, quite informally, we can state that reading 
               <div class="emphasis e370" role="ital">s</div> ∈ 
               <div class="emphasis e371" role="ital">L(E)</div> from the left to
               the right, where 
               <div class="emphasis e372" role="ital">E</div> is a DRE, at any point in 
               <div class="emphasis e373" role="ital">s</div>, we know at which point in 
               <div class="emphasis e374" role="ital">E </div> we
               find ourselves. In automata theory, DREs correspond to deterministic Glushkov
               automata.
            </div>
            <div class="para e375">There is however a problem if we apply this concept to content models in regular tree
               grammars: in regular expressions, we can see from a letter in the string which type
               of
               letter in the expression it instantiates (thus, we have a unique letter in 
               <div class="emphasis e376" role="ital">Σ</div>, though not in 
               <div class="emphasis e377" role="ital">Π</div>). We
               can thus deduce from a letter in the string a letter in the expression, though not
               a letter
               instantiation, if the expression is not deterministic. We cannot, however, deduce
               from a
               given tree node label a unique type of nonterminal: if we have competing rules, different
               nonterminals introduce identical labels; and we still have to keep them apart. Thus,
               if the
               content model of nonterminals itself is deterministic, this is of little use if we
               cannot
               infer from a given label the unique nonterminal it belongs to.
            </div>
            <div class="para e378">By way of example, consider the following grammar rule:</div>
            <div class="para e379">
               <div class="emphasis e380" role="ital">A → a(ABC|CBA)</div>
            </div>
            <div class="para e381"> Its content model is surely deterministic. However, if 
               <div class="emphasis e382" role="ital">A</div> and 
               <div class="emphasis e383" role="ital">C</div> are competing rules (have identical
               labels), this is of little use. We have to check each subtree until we have its unique
               interpretation. This means, in the worst case, we have to check both subtrees (as
               we will
               see, this is the case in which the trees generated by 
               <div class="emphasis e384" role="ital">A (C)</div>
               form a subset of the trees generated by 
               <div class="emphasis e385" role="ital">C (A)</div>).
            </div>
            <div class="para e386">The obvious reason for the fact that this concept of determinism comes short is that
               it
               originates in one-dimensional strings. As our trees are two dimensional, we can define
               determinism only with respect to directions in which our analysis proceeds. The main
               difference is, of course, the one between top-down and bottom-up processing. In this
               paper
               we will not consider the difference between depth-first and breadth-first parsing,
               though
               this is surely worthwhile.
            </div>
            <div class="para e387">In the next subsection, we will reformulate and complete the Murata hierarchy in a
               way,
               that makes clear which kind of determinism is facilitated by which kind of grammar.
               In the
               sequel, we will disregard the one-dimensional problem of non-deterministic content
               models,
               since they have been thoroughly analyzed, and we have nothing to add (see 
               <div class="xref e388" linkend="Brueggemann-Klein1997"></div>). At this point, our interest is the second dimension:
               importantly, this means that talking about determinism, we implicitly always add:
               provided
               that content models are deterministic in the above sense. We thus exclude all problems
               which
               may arise from regular expressions.
            </div>
         </div><a name="TheMurataHierarchyasHierarchyofLocalityConditionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e389" xml:id="sec.murata.locality">
            <div class="title e390">The Murata Hierarchy as Hierarchy of Locality Conditions</div>
            <div class="para e391">As our main concern will be the formal properties of the grammar types, as they affect
               processing, we will firstly reformulate the hierarchy. This reformulation aims at
               making
               clear which information we need in order to uniquely interpret a local node or
               subtree.
            </div>
            <div class="orderedlist e392" numeration="arabic">
               <div class="listitem e393">
                  <div class="para e394">In a 
                     <div class="emphasis e395" role="bold">local tree grammar</div>, for any node 
                     <div class="emphasis e396" role="ital">a</div> in any context, we know its unique interpretation. This is
                     obvious, since for any node label, there is only one single rule which generates it,
                     by
                     the very definition of a local tree grammar. As a consequence, parsing is deterministic
                     for any algorithm (provided we have deterministic content models), and the problem
                     of
                     giving a certain node of a given tree its interpretation is solvable in a constant
                     amount of steps.
                  </div>
               </div>
               <div class="listitem e397">
                  <div class="para e398">In a 
                     <div class="emphasis e399" role="bold">single type tree grammar</div>, for any node label
                     
                     <div class="emphasis e400" role="ital">a</div> in any context, we can determine its unique
                     interpretation if we know the interpretation of its mother node. This follows directly
                     from the definition: if we know the interpretation of a node's mother node (rules
                     correspond to interpretations), we know its content model. Within a content model
                     there
                     must not occur any competing nonterminals.
                  </div>
                  <div class="para e401">Note, however, that it is not sufficient to know the mother nodes label. We can
                     easily construct an example to show this: we have two competing rules, 
                     <div class="emphasis e402" role="ital">A → a(C)</div> and 
                     <div class="emphasis e403" role="ital">B →
                        a(D)
                     </div>, whose nonterminals do not occur in the same content model of any
                     rule. 
                  </div>
                  <div class="para e404">Furthermore, we have the two rules 
                     <div class="emphasis e405" role="ital">C → b(r)</div>
                     and 
                     <div class="emphasis e406" role="ital">D → b(r')</div>. Then both nodes, as introduced by
                     
                     <div class="emphasis e407" role="ital">C</div> and 
                     <div class="emphasis e408" role="ital">D</div>, have label
                     
                     <div class="emphasis e409" role="ital">b</div>, their mother nodes both have the label 
                     <div class="emphasis e410" role="ital">a</div>, despite they have different interpretations.
                  </div>
                  <div class="para e411">For processing, this has an immediate consequence: a top down parser will at any
                     point immediately know the interpretation of any node, whereas if we start
                     interpretation from the bottom, in the worst case we will have to go up to the root
                     in
                     order to get the correct interpretation. The matter of providing the interpretation
                     of a
                     given node is nonetheless a linear search problem, since for a given tree and a given
                     node, it is sufficient to go a path from the root to that node.
                  </div>
               </div>
               <div class="listitem e412">
                  <div class="para e413"> In a 
                     <div class="emphasis e414" role="bold">restrained competition grammar</div> (RCG), in
                     order to give a node its unique interpretation, we must have the interpretation of
                     its
                     mother node, and check its left siblings, in case it has any. Note that from how we
                     defined RCGs, it follows that we only need the label of the siblings, not their
                     interpretation: because any two competing nonterminals within a single content model
                     are
                     distinguished by a unique prefix, this prefix itself must not consist of competing
                     nonterminals only, and neither must it be empty. This keeps the grammar unambiguous,
                     and
                     easy to process. However, it makes some restrictions we do not necessarily want to
                     make:
                     maybe the unique interpretation of a label should not depend on a left sibling, but
                     on a
                     right sibling. For example, in RCGs we cannot have competing nonterminals as leftmost
                     symbols in a content-model, but as rightmost, given some left context. This causes
                     an
                     asymmetry which seems quite arbitrary. Of course we can equally define the asymmetric
                     counterpart of RCG, checking for unique suffixes instead of prefixes; but care is
                     to be
                     taken: since we have to fix the type for the class of languages (i.e., document
                     grammars) we define, we have the same problem. If we generalize the concept to both
                     unique suffix and prefix, some problems arise, which can however be remedied. 
                  </div>
               </div>
               <div class="listitem e415">
                  <div class="para e416">We now define a 
                     <div class="emphasis e417" role="bold">generalized restrained competition
                        grammar
                     </div> (GRCG), as follows: 
                  </div>
                  <div class="para e418">In a GRCG, for any two competing nonterminals 
                     <div class="emphasis e419" role="ital">A</div> and
                     
                     <div class="emphasis e420" role="ital">B</div> within a single content model 
                     <div class="emphasis e421" role="ital">r</div>, one of (
                     <div class="emphasis e422" role="ital">Γ A Δ</div>) and
                     (
                     <div class="emphasis e423" role="ital">Γ B Δ</div>) fails to match 
                     <div class="emphasis e424" role="ital">r</div> (Greek variables range over possible empty sequences of
                     nonterminals).
                  </div>
                  <div class="para e425">We now have generalized the restriction from the left (right, respectively) to the
                     entire context. Note that we have relaxed the overall restriction on the grammar,
                     by
                     making the restriction on content models more specific (indeed, this type properly
                     includes the RCGs). 
                  </div>
                  <div class="para e426"> This little relaxation however causes a vast increase in processing complexity:
                     because now, in order to give its unique interpretation to any node 
                     <div class="emphasis e427" role="ital">a</div> in any context, in the worst case one needs to know the
                     interpretation of its mother, the interpretation of its siblings, and the interpretation
                     of its subtrees as well. And even then, GRCGs might still be ambiguous, allowing more
                     than one interpretation for a entire single tree. 
                  </div>
                  <div class="para e428">This needs some explanation. The first point is easy to see: that we need to know
                     the interpretation of the mother node follows a fortiori from the preceding argument
                     (single type grammars are properly included in restrained competition grammars). But
                     this is insufficient, since competing nonterminals may occur within the same content
                     model. We have to match all the sister labels to the nonterminals of the content model
                     of the mothers interpretation in order to get a unique interpretation (according to
                     the
                     definition). 
                  </div>
                  <div class="para e429">Note, however, that we need the interpretation of the sister nodes; it is not
                     sufficient to have their labels. This we can easily verify with the following grammar
                     rule: 
                     <div class="emphasis e430" role="ital">A → a(BC|B'C')</div>, where 
                     <div class="emphasis e431" role="ital">B</div> and 
                     <div class="emphasis e432" role="ital">B'</div> and 
                     <div class="emphasis e433" role="ital">C</div> and 
                     <div class="emphasis e434" role="ital">C'</div> are competing rules, introduce
                     the labels 
                     <div class="emphasis e435" role="ital">b</div> and 
                     <div class="emphasis e436" role="ital">c</div>,
                     respectively.
                  </div>
                  <div class="para e437">This satisfies all conditions on GRCGs. In order to get the correct interpretation
                     for the labels 
                     <div class="emphasis e438" role="ital">b</div> and 
                     <div class="emphasis e439" role="ital">c</div>, it is not sufficient to know the sister node's label, but its
                     interpretation. 
                  </div>
                  <div class="para e440">Things can thus get even worse, if we consider the case where the interpretation of
                     a sister node depends on the interpretation of the node under consideration 
                     <div class="emphasis e441" role="ital">itself</div>. Look at the following example rule: 
                     <div class="emphasis e442" role="ital">A → a(BC|CB)</div>, where 
                     <div class="emphasis e443" role="ital">B</div>
                     and 
                     <div class="emphasis e444" role="ital">C</div> are competing rules.
                  </div>
                  <div class="para e445">Obviously, they are both uniquely determined by their neighbor within the content
                     model of 
                     <div class="emphasis e446" role="ital">A</div> (
                     <div class="emphasis e447" role="ital">A</div> may only
                     occur with 
                     <div class="emphasis e448" role="ital">B</div> to its left or its right, and vice versa).
                     However, as they carry the same labels, it is insufficient to determine either of
                     them
                     if we just check the label of its sister (since it is identical). Furthermore, we
                     might
                     have the case where it is impossible to interpret one of the subtrees, without its
                     sisters interpretation (e.g., if one of the competing nonterminals generates a subset
                     of
                     the trees generated by the other).
                  </div>
                  <div class="para e449">We will consider this case more thoroughly in the next section, showing that there
                     are globally ambiguous GRCGs, and that for every language that can be generated by
                     an
                     RTG, there is also a GRCG grammar that generates the same language. 
                  </div>
                  <div class="para e450">From the point of view of processing, we see that in GRCGs, expressive power comes
                     at a high cost: neither a bottom-up nor a top-down parser is capable of assigning
                     a
                     unique interpretation locally, and maybe not even globally. The problem of giving
                     a
                     given node its unique interpretation might thus be an exponential search problem,
                     and in
                     the worst case not even decidable. We will therefore introduce a subtype of GRCG,
                     which
                     we will call unambiguous RCG. This type is properly included in the class of GRCG
                     grammars, and includes properly the class of STGs as well as RCGs, as can be seen
                     easily.
                  </div>
               </div>
               <div class="listitem e451">
                  <div class="para e452">We now introduce 
                     <div class="emphasis e453" role="bold">unambiguous restrained competition
                        grammars
                     </div> (URCGs). What we want to eliminate is ambiguity, which can be
                     caused by the fact that in a GRCG, we might have entire competing contexts, or the
                     interpretation of the context of a label in a content-model might depend on the
                     interpretation of the label itself. In the resulting grammar, it should be possible
                     to
                     yield the unique interpretation of a node from the interpretation of its mother and
                     the
                     labels (not interpretations) of its sisters.
                  </div>
                  <div class="para e454">We characterize the grammar type in the following terms: We introduce an alphabet
                     of
                     meta-variables 
                     <div class="emphasis e455" role="ital">O</div>, which we use in the following way: 
                  </div>
                  <div class="para e456">We form a set of all sets of nonterminals from 
                     <div class="emphasis e457" role="ital">N</div>
                     which compete with each other; we call these sets the 
                     <div class="emphasis e458" role="ital">competition
                        sets
                     </div> (which are possibly singletons). We are interested in the sets where
                     every nonterminal occurs in exactly one competition set, such that the whole set forms
                     a
                     partition of 
                     <div class="emphasis e459" role="ital">N</div>. For every such partition we iterate the
                     following procedure: To every competition set, we assign a single symbol from 
                     <div class="emphasis e460" role="ital">O</div>. We call this an 
                     <div class="emphasis e461" role="ital">O-assignment</div>. Then, for all content models, we check for all nonterminals,
                     whether the content models still satisfy the GRCG condition, if we replace all other
                     nonterminals by the symbols from 
                     <div class="emphasis e462" role="ital">O</div> they are assigned
                     to. In case there is more than one overall assignment, that is, a single nonterminal
                     belongs to more than one competition set, we have to iterate this for every possible
                     assignment. If for every assignment, nonterminal and content model, the resulting
                     grammar is a GRCG, then the original grammar is a URCG.
                  </div>
                  <div class="para e463">Note that the assignments are only introduced for this evaluation procedure. We will
                     call contexts which are identical under the 
                     <div class="emphasis e464" role="ital">O-assignment</div>
                     
                     <div class="emphasis e465" role="bold">similar</div>. We define accordingly a URCG as a grammar
                     where competing nonterminals must not occur in the same content model and in similar
                     contexts (this obviously subsumes identical contexts). It is easy to see that now
                     we
                     have made sure that competing nonterminals must not occur within the same contexts
                     of
                     labels (as opposed to nonterminals).
                  </div>
                  <div class="para e466">Thus, a URCG is a GRCG where for every node we find its unique interpretation if we
                     have the interpretation of the mother node and the labels of its sister nodes. In
                     particular, we can interpret any node without having to recur to its sister node's
                     interpretation: the content model 
                     <div class="emphasis e467" role="ital">(BC|CB)</div>, where
                     
                     <div class="emphasis e468" role="ital">B</div> and 
                     <div class="emphasis e469" role="ital">C</div> are
                     competing nonterminals, does not satisfy the condition, because both 
                     <div class="emphasis e470" role="ital">B</div> and 
                     <div class="emphasis e471" role="ital">C</div> occur in the context
                     
                     <div class="emphasis e472" role="ital">__X</div> or 
                     <div class="emphasis e473" role="ital">X__</div>,
                     respectively, where 
                     <div class="emphasis e474" role="ital">X</div> is the 
                     <div class="emphasis e475" role="ital">O-assignment</div> for both. 
                  </div>
                  <div class="para e476">This kind of grammar is useful for the following reason: there is no global
                     ambiguity in it (as we have deleted the only source of ambiguity, that interpretations
                     of labels may depend on each other); and it is the strongest of the non-ambiguous
                     grammar types we have considered. However, it is not capable of generating every
                     language which is not inherently ambiguous, as we will show later. Note, that in order
                     to provide the unique interpretation of a node, we still might have to check all of
                     its
                     sister nodes, but it is sufficient to check the labels.
                  </div>
                  <div class="para e477">It is easily seen that URCGs properly include RCGs, as both left and right context
                     can count as distinctive (we will make this more precise later on). As we will also
                     see
                     further down, there are languages which can be generated by GRCGs, but not by URCGs.
                     This will follow from the fact that actually every RTL can be generated by a GRCG,
                     but
                     there are languages for which there are no unambiguous grammars, and, obviously, URCGs
                     are always unambiguous.
                  </div>
                  <div class="para e478">Interestingly, the search problem for URCGs is still linear, since we only need to
                     go down the path from the root to a given node, and in addition check finitely many
                     sister labels (note that while regular expressions allow for arbitrary branching,
                     the
                     branching of a given tree is, of course, always finite).
                  </div>
                  <div class="para e479">An example of a URCG could be the use of attribute based co-occurrence constraints
                     or attribute-element constraints in the following RELAX NG declaration. We extend
                     our
                     example grammar by adding a 
                     <div class="code e480">type</div> information to the 
                     <div class="code e481">section</div>
                     element. If the type is set to the value "global" other 
                     <div class="code e482">section</div>
                     child elements are allowed as part of the content model, if its value is set to
                     "sub" only 
                     <div class="code e483">para</div> child elements are allowed (see 
                     <div class="xref e484" linkend="lst.grammar.rng.extd"></div>). 
                     <div class="figure e485" xml:id="lst.grammar.rng.extd">
                        <div class="title e486">Extended RELAX NG grammar</div>
                        <div class="programlisting e487" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                           &lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
                           xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
                           datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
                           &lt;start&gt;
                           &lt;element name="text"&gt;
                           &lt;optional&gt;
                           &lt;attribute name="author"/&gt;
                           &lt;/optional&gt;
                           &lt;optional&gt;
                           &lt;ref name="element.title"/&gt;
                           &lt;/optional&gt;
                           &lt;oneOrMore&gt;
                           &lt;choice&gt;
                           &lt;ref name="element.section"/&gt;
                           &lt;ref name="element.para"/&gt;
                           &lt;/choice&gt;
                           &lt;/oneOrMore&gt;
                           &lt;/element&gt;
                           &lt;/start&gt;
                           &lt;define name="element.section"&gt;
                           &lt;choice&gt;
                           &lt;oneOrMore&gt;
                           &lt;element name="section"&gt;
                           &lt;optional&gt;
                           &lt;ref name="element.title"/&gt;
                           &lt;/optional&gt;
                           &lt;optional&gt;
                           &lt;attribute name="type"&gt;
                           &lt;value&gt;global&lt;/value&gt;
                           &lt;/attribute&gt;
                           &lt;/optional&gt;
                           &lt;oneOrMore&gt;
                           &lt;choice&gt;
                           &lt;ref name="element.section"/&gt;
                           &lt;ref name="element.para"/&gt;
                           &lt;/choice&gt;
                           &lt;/oneOrMore&gt;
                           &lt;/element&gt;
                           &lt;/oneOrMore&gt;
                           &lt;oneOrMore&gt;
                           &lt;element name="section"&gt;
                           &lt;optional&gt;
                           &lt;ref name="element.title"/&gt;
                           &lt;/optional&gt;
                           &lt;optional&gt;
                           &lt;attribute name="type"&gt;
                           &lt;value&gt;sub&lt;/value&gt;
                           &lt;/attribute&gt;
                           &lt;/optional&gt;
                           &lt;ref name="element.para"/&gt;
                           &lt;/element&gt;
                           &lt;/oneOrMore&gt;
                           &lt;/choice&gt;
                           &lt;/define&gt;
                           &lt;define name="element.title"&gt;
                           &lt;element name="title"&gt;
                           &lt;text/&gt;
                           &lt;/element&gt;
                           &lt;/define&gt;
                           &lt;define name="element.para"&gt;
                           &lt;element name="para"&gt;
                           &lt;interleave&gt;
                           &lt;optional&gt;
                           &lt;attribute name="id"
                           datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
                           &lt;data type="ID"/&gt;
                           &lt;/attribute&gt;
                           &lt;/optional&gt;
                           &lt;optional&gt;
                           &lt;element name="xref"&gt;
                           &lt;attribute name="href"
                           datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
                           &lt;data type="IDREF"/&gt;
                           &lt;/attribute&gt;
                           &lt;/element&gt;
                           &lt;/optional&gt;
                           &lt;text/&gt;
                           &lt;/interleave&gt;
                           &lt;/element&gt;
                           &lt;/define&gt;
                           &lt;/grammar&gt;
                           
                        </div>
                     </div>
                     
                  </div>
                  <div class="para e488">The interesting part is the definition of the 
                     <div class="code e489">element.section</div> pattern.
                     It allows for two different elements named "section" with different content
                     models according to the value of the optional 
                     <div class="code e490">type</div> attribute. The result is
                     that the instance shown in 
                     <div class="xref e491" linkend="lst.instance.rng.ex1"></div> is valid according to
                     this RELAX NG grammar while the one shown in 
                     <div class="xref e492" linkend="lst.instance.rng.ex2"></div> is
                     not.
                  </div>
                  <div class="figure e493" xml:id="lst.instance.rng.ex1">
                     <div class="title e494">Valid XML instance according to the extended RELAX NG grammar</div>
                     <div class="programlisting e495" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                        &lt;text author="ms"&gt;
                        &lt;title&gt;A simple title&lt;/title&gt;
                        &lt;section type="global"&gt;
                        &lt;title&gt;A section title&lt;/title&gt;
                        &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
                        &lt;section type="sub"&gt;
                        &lt;title&gt;A subsection title&lt;/title&gt;
                        &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
                        &lt;/section&gt;
                        &lt;/section&gt;
                        &lt;/text&gt;
                        
                     </div>
                  </div>
                  <div class="note e496">
                     <div class="para e497">Without any 
                        <div class="code e498">type</div> attribute the instance shown in 
                        <div class="xref e499" linkend="lst.instance.rng.ex1"></div> would still be valid.
                     </div>
                  </div>
                  <div class="figure e500" xml:id="lst.instance.rng.ex2">
                     <div class="title e501">Invalid XML instance according to the extended RELAX NG grammar</div>
                     <div class="programlisting e502" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                        &lt;text author="ms"&gt;
                        &lt;title&gt;A simple title&lt;/title&gt;
                        &lt;section type="sub"&gt;
                        &lt;title&gt;A section title&lt;/title&gt;
                        &lt;para id="p1"&gt;Introductory para&lt;/para&gt;
                        &lt;section type="sub"&gt;
                        &lt;title&gt;A subsection title&lt;/title&gt;
                        &lt;para&gt;Some text with a reference: &lt;xref href="p1"/&gt;.&lt;/para&gt;
                        &lt;/section&gt;
                        &lt;/section&gt;
                        &lt;/text&gt;
                     </div>
                  </div>
                  <div class="para e503">Other well deployed RELAX NG examples of attribute based co-occurrence constraints
                     can be found in 
                     <div class="xref e504" linkend="vanderVlist2003"></div>, Chapter 7, in 
                     <div class="xref e505" linkend="Clark2003"></div>, Section 15, or in the RELAX NG schema for the JLTF (Japanese
                     Layout Taskforce) aligned document shown in 
                     <div class="xref e506" linkend="Sasaki2010"></div>.
                  </div>
                  <div class="para e507">Importantly, co-occurrence constraints do not add anything to the formal generative
                     capacity of the grammar. This is because attributes (or their values, respectively)
                     add
                     an additional specification to the 
                     <div class="emphasis e508" role="ital">terminals</div>. Thereby
                     we can convert competing terminals (or, equivalently, rules) into non-competing ones,
                     but not vice versa. Any co-occurrence constraint thus gives us the possibility to
                     distinguish maybe otherwise indistinguishable non-terminals, thereby at most keeping
                     the
                     complexity of the grammar constant, or even reducing it. Furthermore, as co-occurrence
                     constraints do only affect immediate subtrees (i.e., content models), their expressivity
                     is entirely contained within the expressive capacities of standard regular tree
                     rewriting rules; the only thing we might need to add to our formal grammar model is
                     some
                     additional specification on the terminals.
                  </div>
                  <div class="para e509">Neither DTD
                     <div class="popupBox e510">
                        <div class="popupLabel" onmouseover="$('#d1e1156').show('1000');" onmouseout="$('#d1e1156').hide('1000');">[ footnote ]</div>
                        <div id="d1e1156" style="display: none;">
                           <div class="footnote">
                              <div class="para e511">
                                 <div class="xref e512" linkend="Fiorello2004"></div> discuss DTD++ 2.0 which supports a large number
                                 of co-constraints using a syntax closely resembling DTD.
                              </div>
                           </div>
                        </div>
                     </div> nor XSD 1.0 support such attribute-element constraint, although there are
                     some workarounds or hacks that can be used in XML schema to mimic co-occurrence
                     constraints: either the use of the 
                     <div class="code e513">xsi:type</div> attribute or
                     
                     <div class="code e514">xs:key</div>
                     <div class="popupBox e515">
                        <div class="popupLabel" onmouseover="$('#d1e1166').show('1000');" onmouseout="$('#d1e1166').hide('1000');">[ footnote ]</div>
                        <div id="d1e1166" style="display: none;">
                           <div class="footnote">
                              <div class="para e516">See 
                                 <div class="xref e517" linkend="vanderVlist2003"></div>, p. 65 and 
                                 <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e518" xlink:actuate="onRequest" xlink:href="http://ajwelch.blogspot.com/2008/06/xml-schema-co-occurrence-constraint.html" xlink:show="new" xlink:type="simple">http://ajwelch.blogspot.com/2008/06/xml-schema-co-occurrence-constraint.html</div>
                                 for further information.
                              </div>
                           </div>
                        </div>
                     </div>. Another option to realize this particular constraint is the use of embedded
                     
                     <div class="xref e519" linkend="Schematron"></div> business rules or conditional type assignment using type
                     alternatives or assertions that are introduced in 
                     <div class="xref e520" linkend="XMLSchema2009"></div> (for
                     complex Types) and 
                     <div class="xref e521" linkend="XMLSchema2009-2"></div> (for simple Types). 
                     <div class="xref e522" linkend="lst.grammar.xsd11"></div> shows a possible XSD 1.1 realization.
                  </div>
                  <div class="figure e523" xml:id="lst.grammar.xsd11">
                     <div class="title e524">XSD grammar with XSD 1.1 
                        <div class="code e525">assert</div> element
                     </div>
                     <div class="programlisting e526" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                        &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
                        &lt;xs:element name="text"&gt;
                        &lt;xs:complexType&gt;
                        &lt;xs:complexContent&gt;
                        &lt;xs:extension base="textType"&gt;
                        &lt;xs:attribute name="author" type="xs:string" use="optional"/&gt;
                        &lt;/xs:extension&gt;
                        &lt;/xs:complexContent&gt;
                        &lt;/xs:complexType&gt;
                        &lt;/xs:element&gt;
                        &lt;xs:element name="title" type="xs:string"/&gt;
                        &lt;xs:element name="section"&gt;
                        &lt;xs:complexType&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element ref="title" minOccurs="0"/&gt;
                        &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
                        &lt;/xs:sequence&gt;
                        &lt;xs:attribute name="type" use="optional"&gt;
                        &lt;xs:simpleType&gt;
                        &lt;xs:restriction base="xs:string"&gt;
                        &lt;xs:enumeration value="global"/&gt;
                        &lt;xs:enumeration value="sub"/&gt;
                        &lt;/xs:restriction&gt;
                        &lt;/xs:simpleType&gt;
                        &lt;/xs:attribute&gt;
                        &lt;xs:assert test="@type!='sub' and (child::para | child::section) or 
                        @type='sub' and not(child::section)" /&gt;
                        &lt;/xs:complexType&gt;
                        &lt;/xs:element&gt;
                        &lt;xs:element name="para"&gt;
                        &lt;xs:complexType mixed="true"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element name="xref" minOccurs="0"&gt;
                        &lt;xs:complexType&gt;
                        &lt;xs:attribute name="href" type="xs:IDREF" use="required"/&gt;
                        &lt;/xs:complexType&gt;
                        &lt;/xs:element&gt;
                        &lt;/xs:sequence&gt;
                        &lt;xs:attribute ref="id" use="optional"/&gt;
                        &lt;/xs:complexType&gt;
                        &lt;/xs:element&gt;
                        &lt;xs:complexType name="textType"&gt;
                        &lt;xs:sequence&gt;
                        &lt;xs:element ref="title" minOccurs="0"/&gt;
                        &lt;xs:group ref="sectOrPara" maxOccurs="unbounded"/&gt;
                        &lt;/xs:sequence&gt;
                        &lt;/xs:complexType&gt;
                        &lt;xs:group name="sectOrPara"&gt;
                        &lt;xs:choice&gt;
                        &lt;xs:element ref="section"/&gt;
                        &lt;xs:element ref="para"/&gt;
                        &lt;/xs:choice&gt;
                        &lt;/xs:group&gt;
                        &lt;xs:attribute name="id" type="xs:ID"/&gt;
                        &lt;/xs:schema&gt;
                     </div>
                  </div>
                  <div class="para e527">The 
                     <div class="code e528">section</div> element contains an XSD 1.1 
                     <div class="code e529">assert</div> element
                     that uses an XPath expression in its 
                     <div class="code e530">type</div> attribute to restrain the
                     possible child elements according to the 
                     <div class="code e531">type</div> attribute's value of the
                     
                     <div class="code e532">section</div> element.
                  </div>
                  <div class="para e533">Note that when using XSD 1.1 assertions for expressing co-occurrence constraints we
                     are not limited to immediate subtrees: although the evaluation of the XPath expression
                     is done in the context of the parent element (i.e., XSD 1.1's 
                     <div class="code e534">xs:assert</div>
                     element uses a tree fragment rooted at the element whose type it is tested against)
                     one
                     could put the assertion at the level of the common ancestor, that is, the element
                     that
                     contains all the data needed to compute the assertion. The support for full XPath
                     (i.e.,
                     axes such as ancestor, parent or preceding and preceding-sibling and following and
                     following-sibling, respectively) may be implementation-dependent. XSD 1.1 type alternatives
                     are restricted to tests against constants or attributes on the element itself but
                     not to
                     ancestors, descendants, siblings or children or their attributes while Schematron
                     business rules are not restricted to an XPath subset.
                  </div>
               </div>
               <div class="listitem e535">
                  <div class="para e536">There is one type we should add, which cannot be assigned a place on the hierarchy
                     from STGs to RTGs, which is, however, weakly and strongly between LTGs and RTGs.
                     Grammars of this type satisfy the following conditions: we want to be able to assign
                     a
                     unique interpretation to any node 
                     <div class="emphasis e537" role="ital">a</div>, provided we know
                     the complete subtree it governs. This kind of grammar would facilitate deterministic
                     parsing for bottom-up algorithms. In terms of grammar, this imposes the following
                     restrictions on the formalism:
                  </div>
                  <div class="orderedlist e538" numeration="loweralpha">
                     <div class="listitem e539">
                        <div class="para e540">Every leaf-terminal is introduced by a single nonterminal,</div>
                     </div>
                     <div class="listitem e541">
                        <div class="para e542">for every nonterminal 
                           <div class="emphasis e543" role="ital">N</div> in a given grammar,
                           there is at most one rule which has a given terminal 
                           <div class="emphasis e544" role="ital">a</div>, and 
                           <div class="emphasis e545" role="ital">N</div> appears in its content
                           model. 
                        </div>
                     </div>
                  </div>
                  <div class="para e546">We call this grammar type 
                     <div class="emphasis e547" role="bold">unique subtree grammar</div>
                     (USG). Note that this grammar type does not include STGs and URCGs, nor is it included
                     by them. The restrictions do not restrain the occurrence of competing nonterminals
                     in
                     content models, but rather the labels which belong to nonterminals in the content
                     model.
                     More precisely, whereas the former types restrain the occurrence of competing
                     nonterminals within content models, USGs restrain the content models of competing
                     rules
                     itself. 
                  </div>
                  <div class="para e548">However, as all other types, they properly include the class of LTGs, as every LTG
                     is a USG, but not vice versa, and it easy to find a language which is generated by
                     a
                     USG, but not by LTG. Furthermore, they are properly included in the class of RTGs,
                     in
                     the strong and the weak sense (and weakly within the class of GRCGs, as we will see).
                     
                  </div>
                  <div class="para e549">As is also easy to see, the distinctive USG property provides deterministic bottom
                     up parsing. In order to get the interpretation of a given node, it is therefore
                     sufficient to find a path from the leaves, which is a linear search problem.
                  </div>
               </div>
            </div>
         </div>
      </div><a name="StructureandGlobalAmbiguityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e550">
         <div class="title e551">Structure and Global Ambiguity</div>
         <div class="para e552">First, we will present some well-known results, which are important for our further
            discussion.
         </div>
         <div class="para e553">
            
            <div class="emphasis e554" role="bold">Theorem 1 </div>
            <div class="emphasis e555" role="ital">RTGs are weakly equivalent to
               CFGs (that is, the set of strings of leaves generated by CFGs is equivalent to the
               set of
               strings of leaves generated by RTGs).
            </div>
            
         </div>
         <div class="para e556">
            <div class="emphasis e557" role="bold">Theorem 2 </div>
            
            <div class="emphasis e558" role="ital">RTGs are strongly equivalent
               to graphs generated by a CFGs, modulo a homomorphism of node labels (i.e., a homomorphism
               which maps various node labels in a given tree onto a single one), provided the RTG
               has
               finitary branching.
            </div>
            
         </div>
         <div class="para e559">
            <div class="emphasis e560" role="bold">Theorem 3 </div>
            
            <div class="emphasis e561" role="ital">LTGs are strongly equivalent
               to graphs generated by CFGs, provided finitary branching.
            </div>
            
         </div>
         <div class="para e562">Proof is trivial: as in LTGs every node label is generated by exactly one nonterminal;
            and
            in CFGs, nodes which are not leaves are labeled by nonterminals, there is a one-to-one
            correspondence. This has some importance for the relation of LTGs and RTGs. It follows,
            that
            LTGs and RTGs are equivalent up to homomorphism, as well as all grammar types in between.
            Every discussion we have about generative capacity concerns only non-equivalence in
            isomorphism. Since also the strings of leaves for all grammar types are identical,
            we can only
            be interested in the sets of trees. In the sequel, if we speak of the weak generative
            capacity
            of a tree grammar, we refer to the sets of trees it generates, not the strings of
            leaves.
         </div>
         <div class="para e563">Since to our knowledge, only the strong generative capacity of the grammar types of
            
            <div class="xref e564" linkend="Murata2005"></div> has been in the focus of research, we will now scrutinize their weak
            generative capacity.
         </div>
         <div class="para e565">
            <div class="emphasis e566" role="bold">Theorem 4 </div>
            <div class="emphasis e567" role="ital">The
               sets of trees generated by STGs form a proper subset of the sets of trees generated
               by
               RCGs.
            </div>
         </div>
         <div class="para e568">For proof, consider the trees generated by the following grammar: 
            <div class="programlisting e569" xml:space="preserve">S → a(AB)
               A → b(C)
               B → b(D)
               C → c(D)
               D → c(ε)
            </div>
         </div>
         <div class="para e570">This is an RCG, since A and B do not occur in similar contexts. In order to see that
            there
            is no way to generate this tree with an STG, consider the following fact: 
            <div class="emphasis e571" role="ital">a</div> governs two identical labels, which however govern different
            subtrees. It is therefore impossible to introduce them with identical rules, and (by
            definition of STGs) forbidden to have two competing rules in the content model of
            the first
            rule. This is sufficient for the proof of weak inclusion, since all STG rules are
            also RCG
            rules, and therefore the languages generated form a proper subset.
         </div>
         <div class="para e572">
            <div class="emphasis e573" role="bold">Theorem 5 </div>
            <div class="emphasis e574" role="ital">The
               sets of trees generated by LTGs form a proper subset of the sets of trees generated
               by
               STGs.
            </div>
         </div>
         <div class="para e575">Consider the trees generated by the following grammar: 
            <div class="programlisting e576" xml:space="preserve">
               <div class="emphasis e577" role="ital">A → a(B)
                  B → b(C)
                  C → a(D)
                  D → c(ε)
               </div>
            </div>
         </div>
         <div class="para e578">This is a single type tree grammar, and no LTG is able to generate such a tree (remember
            that LTGs are strongly equivalent to graphs generated by CFG, provided finitary
            branching).
         </div><a name="RestrainedCompetitionGrammarsandVariantsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e579">
            <div class="title e580">Restrained Competition Grammars and Variants</div>
            <div class="para e581">In this section we will scrutinize formal properties of the different types of
               restrained competition grammars. We will show which kind of languages cannot be generated
               by
               RCGs; we will prove that there are GRCGs which are ambiguous, and that for every language
               which can be generated by an RTG, there is a GRCG which generates the same language.
               Finally, we will show that URCGs do not have these properties, are properly included
               within
               GRCGs and properly include RCGs. 
            </div>
            <div class="para e582">The type of languages we cannot generate with RCGs is quickly described as follows:
               all
               grammars, where a single content model contains competing nonterminals, which can
               be
               uniquely distinguished only from their left (right, respectively) context, are not
               RCGs.
               Consequently, we cannot generate sets of trees, where a certain node has different
               subtrees
               depending on its right siblings. If we want to get rid if this asymmetry, and allow
               for
               GRCGs, where competing nonterminals in a single content model are uniquely determined
               by
               their left or right context, we run into problems: 
            </div>
            <div class="para e583">
               <div class="emphasis e584" role="bold">Theorem 6 </div>
               <div class="emphasis e585" role="ital">There
                  are GRCGs which are ambiguous.
               </div>
            </div>
            <div class="para e586"> For proof, consider the following rule: 
               <div class="emphasis e587" role="ital">S →
                  a(AB|BA)
               </div>. Suppose, 
               <div class="emphasis e588" role="ital">A</div> and 
               <div class="emphasis e589" role="ital">B</div> are competing nonterminals; suppose furthermore, that there is some
               overlapping between 
               <div class="emphasis e590" role="ital">A</div> and 
               <div class="emphasis e591" role="ital">B</div>; i.e., the nonterminals generate overlapping sets of trees. In particular,
               we may assume that the trees generated by 
               <div class="emphasis e592" role="ital">A</div> form a subset
               of the trees generated by 
               <div class="emphasis e593" role="ital">B</div>. For example, 
               <div class="emphasis e594" role="ital">A</div> and 
               <div class="emphasis e595" role="ital">B</div> generate identical trees
               up to depth 
               <div class="emphasis e596" role="ital">n</div>; 
               <div class="emphasis e597" role="ital">B</div> in
               addition generates a tree of depth 
               <div class="emphasis e598" role="ital">n+1</div>. In this case, the
               trees of the language have the root 
               <div class="emphasis e599" role="ital">a</div>, with two symmetrical
               sets of subtrees up to depth 
               <div class="emphasis e600" role="ital">n</div>, and possibly one subtree
               with depth 
               <div class="emphasis e601" role="ital">n+1</div>. It is easily seen that now it is impossible
               to merge 
               <div class="emphasis e602" role="ital">A</div> and 
               <div class="emphasis e603" role="ital">B</div>, for then
               we would be incapable of expressing the condition that at most one subtree has depth
               
               <div class="emphasis e604" role="ital">n+1</div>. However, for the trees, where the subtrees
               introduced by 
               <div class="emphasis e605" role="ital">A</div> and 
               <div class="emphasis e606" role="ital">B</div> have
               depth at most 
               <div class="emphasis e607" role="ital">n</div>, there is necessarily more than one
               analysis. The grammar we have described so far is, however, a GRCG, because neither
               
               <div class="emphasis e608" role="ital">A</div> nor 
               <div class="emphasis e609" role="ital">B</div> occur in
               identical contexts (though in similar contexts, remember the preceding section).
            </div>
            <div class="para e610">
               <div class="emphasis e611" role="bold">Theorem 7 </div>
               <div class="emphasis e612" role="ital">For
                  every language which can be generated by an RTG, there is a GRCG which generates the
                  same
                  language.
               </div>
            </div>
            <div class="para e613"> To proof this theorem, we describe a simple procedure to convert any RTG into a GRCG,
               which generates the same language. We define competing sequences of length 
               <div class="emphasis e614" role="ital">n</div> of nonterminals as follows: two sequences of nonterminals
               compete, if for all 
               <div class="emphasis e615" role="ital">n</div>, the 
               <div class="emphasis e616" role="ital">n</div>th nonterminal of one sequence competes with the 
               <div class="emphasis e617" role="ital">n</div>th nonterminal of the other sequence. We have to assume a content model
               
               <div class="emphasis e618" role="ital">r</div> which is not GRCG conform. Therefore, there have to be
               two competing nonterminals or competing sequences of nonterminals 
               <div class="emphasis e619" role="ital">A</div> and 
               <div class="emphasis e620" role="ital">B</div> in 
               <div class="emphasis e621" role="ital">r</div>, such that for possibly empty sequences of nonterminals 
               <div class="emphasis e622" role="ital">Γ</div> and 
               <div class="emphasis e623" role="ital">Δ</div>, (
               <div class="emphasis e624" role="ital">Γ A Δ</div>) and (
               <div class="emphasis e625" role="ital">Γ B Δ</div>) match
               with 
               <div class="emphasis e626" role="ital">r</div>.
            </div>
            <div class="para e627"> Given this, we can be sure, that in the instantiations of 
               <div class="emphasis e628" role="ital">r</div>, which violate the GRCG condition, 
               <div class="emphasis e629" role="ital">A</div> and
               
               <div class="emphasis e630" role="ital">B</div> occur in exactly the same global tree contexts. By
               global tree context we here mean that a tree with a governing the subtrees generated
               by
               
               <div class="emphasis e631" role="ital">A</div> is part of the language iff a also governs the set of
               subtrees generated by 
               <div class="emphasis e632" role="ital">B</div>. Since this is the case, we can
               simply merge the two nonterminals to a new one, 
               <div class="emphasis e633" role="ital">C</div>, which is
               the union of the former two. This new nonterminal substitutes all instantiations of
               
               <div class="emphasis e634" role="ital">A</div> and 
               <div class="emphasis e635" role="ital">B</div>, which occur in
               the same global tree context. This, by definition, are the instantiations which violate
               the
               GRCG condition. This we can apply to all nonterminals which violate the GRCG condition.
               The
               only thing we have to take care of is that we apply this only to those instantiations
               of the
               content models where two competing nonterminals match equally (this might force us
               to change
               some regular expressions). We do not show an exact algorithm at this point, since
               it is
               clear that an equivalent GRCG exist, and the details of the construction are of no
               practical
               interest at this point. 
            </div>
            <div class="para e636">We now show that there is a hierarchy of proper inclusion RCG ⊂ URCG ⊂ GRCG.
               To show that RCG ⊂ URCG, consider the following: every rule which is admitted by an
               RCG is also admitted by a URCG, because if competing nonterminals in the same content
               model
               have a unique prefix, a fortiori they also have a unique context (we have already
               shown that
               a unique prefix of nonterminals is paramount to a unique prefix of labels/siblings,
               by
               induction). Above, we have already shown that for an RCG it is impossible to generate
               languages as the following, which is a URCG. 
               <div class="programlisting e637" xml:space="preserve">
                  <div class="emphasis e638" role="ital">S → a(AC|BD)
                     A → b(C)
                     B → b(D)
                     C → c(ε)
                     D → d(ε)
                  </div>
               </div>
               
               <div class="emphasis e639" role="ital">A</div> and 
               <div class="emphasis e640" role="ital">B</div> compete, but are
               determined uniquely by their context.
            </div>
            <div class="para e641">This concludes the first part; the second part will be a corollary of the next section:
               We will show that some languages are inherently ambiguous, that is, there is no unambiguous
               grammar for them. By Theorem 7 we know that we can generate these languages with GRCGs,
               but
               URCGs cannot:
            </div>
            <div class="para e642">
               <div class="emphasis e643" role="bold">Proposition 1 </div>
               <div class="emphasis e644" role="ital">A URCG cannot be ambiguous.</div>
            </div>
            <div class="para e645">This is easy to see: an ambiguous grammar assigns two different sequences of
               nonterminals to the daughters of one node (since root nodes are unambiguous): Then
               however,
               there must be at least two competing nonterminals which occur in the same content
               model in
               similar contexts, which, by definition, is impossible.
            </div>
         </div><a name="InherentlyAmbiguousLanguagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e646">
            <div class="title e647">Inherently Ambiguous Languages</div>
            <div class="para e648">As a corollary, we can show that there are regular tree languages, for which there
               is no
               unambiguous grammar. There are sets of trees, which are generated by an ambiguous
               GRCG, but
               by no URCG. We will call these languages 
               <div class="emphasis e649" role="ital">inherently
                  ambiguous
               </div>. 
            </div>
            <div class="para e650">
               <div class="emphasis e651" role="bold">Theorem 8 </div>
               <div class="emphasis e652" role="ital">Some
                  regular tree languages are inherently ambiguous.
               </div>
            </div>
            <div class="para e653">This can be seen easily, if we spell out a grammar which we described in the above
               subsection. We will then show that there is now way to write an unambiguous grammar
               which
               generates the same language.
               <div class="programlisting e654" xml:space="preserve">
                  <div class="emphasis e655" role="ital">S → r(AB|BA)
                     A → a(C)
                     B → a(D)
                     C → b(ε)
                     D → b(ε|E)
                     E → c(ε)
                  </div>
               </div>
            </div>
            <div class="para e656">There is no way to merge 
               <div class="emphasis e657" role="ital">A</div> and 
               <div class="emphasis e658" role="ital">B</div>, since they generate different sets of subtrees (we can write 
               <div class="emphasis e659" role="ital">L(A)≠L(B)</div>); but since they overlap (
               <div class="emphasis e660" role="ital">L(A)∩ L(B)≠ ∅</div>), there is no way to have a unique
               interpretation in the cases where the subtrees generated by the nonterminals are identical.
               There will always be two ways to generate trees in this case.
            </div>
            <div class="para e661">We can, furthermore, precisely state the conditions, under which a regular tree language
               is ambiguous. To this end, however, we need to introduce some notation. We now for
               simplicity write trees as terms: a tree with root 
               <div class="emphasis e662" role="ital">a</div> and
               daughters 
               <div class="emphasis e663" role="ital">b</div> and 
               <div class="emphasis e664" role="ital">c</div> is
               denoted as 
               <div class="emphasis e665" role="ital">a(b,c)</div>, etc. As a next step, we define a context
               as the position, where certain subtrees occur within trees of a language. 
            </div>
            <div class="para e666">
               
               <div class="emphasis e667" role="bold">Definition 9</div>
               
               <div class="emphasis e668" role="ital">A context C is a tree-term with exactly one variable. We say that a
                  set of subtrees α occurs in a context C in a language L, if the following holds: We
                  can instantiate the variable of C with any tree from α, and the resulting tree is
                  in
                  L
               </div>.
            </div>
            <div class="para e669">Note that sets of subtrees correspond to nonterminals, when we speak of languages
               rather
               than grammars. In the sequel, for simplicity we will use lower case Greek variables
               equally
               for sets of subtrees as for ordered sequences of sets of subtrees. The definition
               of a
               context is easily accommodated to sequences. A set of sequences of trees of length
               
               <div class="emphasis e670" role="ital">n</div> consists of ordered tuples of trees of length 
               <div class="emphasis e671" role="ital">n</div>, of the form (
               <div class="emphasis e672" role="ital">t
                  <div class="subscript e673">0</div>,...,t
                  <div class="subscript e674">n-1</div>
               </div>). Sets of subtrees
               are then simply sets of one-tuples. Importantly, we will not provide a proof for the
               following proposition, and leave it open as a conjecture. However, we will sketch
               the
               argument. We now make the following conjecture: 
            </div>
            <div class="para e675">
               <div class="emphasis e676" role="bold">Conjecture 1</div>
               
               <div class="emphasis e677" role="ital">A tree-language is inherently ambiguous iff at least one node fulfills
                  all of the following conditions: 
               </div>
            </div>
            <div class="para e678">
               <div class="emphasis e679" role="ital">We need to have one node with an arbitrary label a, with at least
                  two (sequences of) sets of subtrees α and β, such that 
               </div>
            </div>
            <div class="orderedlist e680" numeration="arabic">
               <div class="listitem e681">
                  <div class="para e682">
                     <div class="emphasis e683" role="ital">α ∩ β ≠ ∅</div>;
                  </div>
               </div>
               <div class="listitem e684">
                  <div class="para e685">
                     <div class="emphasis e686" role="ital">α ≠ β</div>;
                  </div>
               </div>
               <div class="listitem e687">
                  <div class="para e688">There is at least one context 
                     <div class="emphasis e689" role="ital">C</div> in 
                     <div class="emphasis e690" role="ital">L</div>, such that both 
                     <div class="emphasis e691" role="ital">a(Γ,
                        (t
                        <div class="subscript e692">1</div>,...,t
                        <div class="subscript e693">n</div>), Δ,
                        (u
                        <div class="subscript e694">1</div>,...,u
                        <div class="subscript e695">n</div>), Θ)
                     </div> and
                     
                     <div class="emphasis e696" role="ital">a(Γ,
                        (u
                        <div class="subscript e697">1</div>,...,u
                        <div class="subscript e698">n</div>), Δ,
                        (t
                        <div class="subscript e699">1</div>,...,t
                        <div class="subscript e700">n</div>), Θ)
                     </div> occur
                     in 
                     <div class="emphasis e701" role="ital">C</div>, for all 
                     <div class="emphasis e702" role="ital">(t
                        <div class="subscript e703">1</div>,...,t
                        <div class="subscript e704">n</div>) ∈ α
                     </div>
                     and all 
                     <div class="emphasis e705" role="ital">(u
                        <div class="subscript e706">1</div>,...,u
                        <div class="subscript e707">n</div>)
                        ∈ β
                     </div>, where uppercase Greek letters designate possibly empty
                     sequences of daughter sub-trees; note that the sequences need to have equal length
                     in
                     order to meet condition 1.
                  </div>
               </div>
            </div>
            <div class="para e708">Due to space restrictions, we leave the prove for this conjecture open here; this
               reminds however of a theorem in 
               <div class="xref e709" linkend="Odgen1968"></div> for string languages. But we
               will give some rather informal discussion of the points in the next section. It is
               not hard
               to see that this is merely a generalization of the cases we have been described above.
               As we
               will see, we can derive some useful facts from these properties of ambiguous languages,
               even
               without a general proof: we can show that we can construe grammars for languages which
               do
               not fulfill one of the conditions, and, moreover, which type of grammars we can
               construe.
            </div>
         </div><a name="UnambiguousLanguagesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e710">
            <div class="title e711">Unambiguous Languages</div>
            <div class="para e712">
               <div class="emphasis e713" role="bold">Theorem 9</div>
               
               <div class="emphasis e714" role="ital">From the grammar types sketched so far, there is no type which
                  generates all and only the RTLs that are not inherently ambiguous.
               </div>
            </div>
            <div class="para e715">We will demonstrate this going through the three conditions mentioned in the preceding
               section, and look which unambiguous grammar we can construe if one condition is not
               met.
               This is to be read as follows: if one condition is not met, then it means, that from
               all
               nodes of the tree language, there might be any one which meets the ones not in question,
               but
               none which meets the one currently under consideration.
            </div>
            <div class="orderedlist e716">
               <div class="listitem e717">
                  <div class="para e718">If there is no intersection between the subtrees of a given node, the grammar is of
                     course not ambiguous. We can, however not necessarily construe a URCG for this grammar,
                     since in the content model of the mother node there are competing nonterminals in
                     similar contexts (recall the example given above).
                  </div>
                  <div class="para e719">We can, however, construe a USG for such a language, since subtrees are uniquely
                     identifiable.
                  </div>
               </div>
               <div class="listitem e720">
                  <div class="para e721">This means that there are no two sets of subtrees governed by the same node which
                     are not identical. We can thus introduce them by the same nonterminals, and have a
                     local
                     tree grammar (having no different sets of subtrees governed by the same node amounts
                     to
                     say we need no competing rules in the grammar, as nonterminals correspond to sets
                     of
                     subtrees).
                  </div>
               </div>
               <div class="listitem e722">
                  <div class="para e723">If the third condition is not met, then we can construe nonterminals (corresponding
                     to the sets of subtrees) such that for all of them the following holds: assuming they
                     compete (introduce identical labels), they either occur in different contexts, in
                     which
                     case they are distinguishable thereby and no ambiguity arises; or they occur in
                     identical contexts, in which case we can use a unique nonterminal which is the merge
                     of
                     both (this also holds for root nodes). The critical case, where the content of one
                     (sequence of) set(s) of subtrees depends on the other one, which makes them occur
                     in
                     similar contexts, while making it impossible to merge them, however, we have excluded
                     by
                     assumption.
                  </div>
                  <div class="para e724">Since this argument holds inductively from the root to all subtrees, we can construe
                     a URCG for the language were condition 3 is not met, but we cannot use any strictly
                     weaker type. The only thing we have provided is that if two sets of subtrees occur
                     in
                     similar contexts (for the grammar we construe), then they actually occur in identical
                     contexts. It follows that we do not need competing nonterminals in similar
                     contexts.
                  </div>
               </div>
            </div>
            <div class="para e725">This shows that we still have not solved the problem to define a canonical grammar
               type
               which generates all and only the unambiguous languages, since there are languages
               which are
               generated by USGs, but no other canonical class which does not allow any ambiguity
               type, and
               languages which are generated by URCGs and no other such type. So far, we are still
               lacking
               a characterization of the unambiguous languages in terms of grammar rules. 
            </div>
         </div>
      </div><a name="ApplicationandFutureResearchANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e726">
         <div class="title e727">Application and Future Research</div>
         <div class="para e728">When we speak of XML schema languages and applications, the first thing that comes
            into
            mind is parsing an instance and validate it according to a respective schema. 
            <div class="xref e729" linkend="Murata2005"></div> have shown algorithms for parsing the three types of tree grammars we
            discussed already. However, a task which is still open is to provide algorithms for
            the new
            grammars types we have defined.
         </div>
         <div class="para e730">
            <div class="xref e731" linkend="Mani2002"></div> demonstrated the use of the theory of regular tree grammars for
            the XML to relational conversion as an additional application of formal language in
            the XML
            context. Again, this work could be extended using the newly established grammar types.
         </div>
         <div class="para e732">Regarding future research this paper may serve as just a foundation in the fields
            of XML
            applications and formal languages. New features that are introduced in XSD 1.1 such
            as
            conditional type assignment, assertions and the 
            <div class="code e733">openContent</div> element as well as
            the relaxed 
            <div class="emphasis e734" role="ital">Unique Particle Attribution</div> rule (UPA, aka the
            determinism rule, see 
            <div class="xref e735" linkend="XMLSchema2009"></div>, Section 3.8.6.4), or changed behavior
            regarding wildcards have effects on the expressiveness. Apart from these natural enhancements,
            another focus may lie in examining the relationships between XPath and XQuery and
            formal
            languages on the basis of the work undertaken in this paper; we expect to shed some
            light on
            this topic during future research. In addition, a more formal approach in the analysis
            of
            overlapping markup structures such as GODDAGs (
            <div class="xref e736" linkend="Sperberg-McQueen2004"></div>) could
            be an interesting field for future work.
         </div>
         <div class="para e737">Seen from a practical perspective and under consideration of the findings in 
            <div class="xref e738" linkend="Martens2006"></div>, a large portion of the XML document grammars that can be found in
            the wild are structurally equivalent to DTDs or 
            <div class="emphasis e739" role="ital">specialized
               DTDs
            </div> (that is, adding a mechanism to decouple element names from their types to
            regular DTDs, see 
            <div class="xref e740" linkend="Papakonstantinou2000"></div> and 
            <div class="xref e741" linkend="Balmin2004"></div>
            – also called EDTDs by 
            <div class="xref e742" linkend="Martens2006"></div>), hence use roughly the
            expressiveness of local tree grammars. This is often due to nontransparent restrictions
            in the
            XML Schema spec such as the already discussed 
            <div class="emphasis e743" role="ital">Element Declarations
               Consistent
            </div> (EDC) constraint. 
            <div class="xref e744" linkend="Bex2009"></div> and 
            <div class="xref e745" linkend="Martens2007"></div> provide simplifications for XSDs and XSD authoring tools that should
            relive authors from the burden of these constraints by 
            <div class="quote e746">automatically transforming
               nondeterministic expressions into concise deterministic ones
            </div>. Regarding RELAX NG
            document grammars we think that restraining its expressive power to the class of URCGs
            would
            provide a feasible compromise. Up to this point we hope that this more fine-grained
            hierarchy
            may serve others as guide for choosing a specific XML schema language depending on
            the
            expressivity of the markup language that has to be developed.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e747">
         <div class="title e748">Bibliography</div>
         <div class="bibliomixed e749" xml:id="Abiteboul2000" xreflabel="Abiteboul et al., 2000">Abiteboul, S., P.
            Buneman, and D. Suciu (2000). Data on the Web: From Relations to Semistructured Data
            and XML.
            Morgan Kaufmann Publishers, San Francisco, California.
         </div>
         <div class="bibliomixed e750" xml:id="Ansari2009" xreflabel="Ansari et al., 2009">Ansari, M. S., Zahid, N., and
            K.-G. Doh. A Comparative Analysis of XML Schema Languages. In Slezak, D., Kim, T.,
            Zhang, Y.,
            Ma, J., and K. Chung, eds., Database Theory and Application. International Conference,
            DTA
            2009, Held as Part of the Future Generation Information Technology Conference, FGIT
            2009, Jeju
            Island, Korea, December 10-12, 2009. Proceedings, volume 64, pages 41– 48. Springer,
            Berlin,
            Heidelberg, 2009. doi: 
            <div class="biblioid doi e751">10.1007/978-3-642-10583-8_6</div>.
         </div>
         <div class="bibliomixed e752" xml:id="Balmin2004" xreflabel="Balmin et al., 2004">Balmin, A., Papakonstantinou,
            Y., and V. Vianu (2004). Incremental validation of XML documents. ACM Transactions
            on Database
            Systems (TODS), 29(4):710–751. doi: 
            <div class="biblioid doi e753">10.1145/1042046.1042050</div>.
         </div>
         <div class="bibliomixed e754" xml:id="Bauman2008" xreflabel="Bauman, 2008">Bauman, S., (2008). Freedom to
            Constrain: where does attribute constraint come from, mommy? In Proceedings of Balisage:
            The
            Markup Conference 2008. Balisage Series on Markup Technologies, vol. 1 (2008). doi:
            
            <div class="biblioid doi e755">10.4242/BalisageVol1.Bauman01</div>.
         </div>
         <div class="bibliomixed e756" xml:id="Bex2009" xreflabel="Bex et al., 2009">Bex, G. J., Gelade, W., Martens, W.
            and F. Neven (2009). Simplifying XML Schema: Effortless Handling of Nondeterministic
            Regular
            Expressions. In SIGMOD ’09: Proceedings of the 35th SIGMOD international conference
            on
            Management of data, pages 731–744, New York, NY, USA, ACM. doi: 
            <div class="biblioid doi e757">10.1145/1559845.1559922</div>.
         </div>
         <div class="bibliomixed e758" xml:id="Brueggemann-Klein1992" xreflabel="Brüggemann-Klein and Wood, 1992">Brüggemann-Klein, A., and D. Wood (1992). Deterministic Regular Languages. In Finkel,
            A. and
            M. Jantzen, eds., STACS 92. 9th Annual Symposium on Theoretical Aspects of Computer
            Science
            Cachan, France, February 13–15, 1992 Proceedings, volume 577 of Lecture Notes in Computer
            Science, pages 173–184. Springer, Berlin, Heidelberg. doi: 
            <div class="biblioid doi e759">10.1007/3-540-55210-3_182</div>.
         </div>
         <div class="bibliomixed e760" xml:id="Brueggemann-Klein1993" xreflabel="Brüggemann-Klein, 1993">Brüggemann-Klein,
            A. (1993). Formal Models in Document Processing. Habilitation, Albert-Ludwig-Universität
            zu
            Freiburg i. Br.
         </div>
         <div class="bibliomixed e761" xml:id="Brueggemann-Klein1997" xreflabel="Brüggemann-Klein and Wood, 1997">Brüggemann-Klein, A., and D. Wood (1997). One-unambiguous regular languages. Information
            and
            computation, 142:182–206. doi: 
            <div class="biblioid doi e762">10.1006/inco.1997.2695</div>.
         </div>
         <div class="bibliomixed e763" xml:id="Brueggemann-Klein2002" xreflabel="Brüggemann-Klein and Wood, 2002">Brüggemann-Klein, A., and D. Wood (2002). The parsing of extended context-free grammars.
            HKUST Theoretical Computer Science Center Research Report HKUST-TCSC-2002-08, The
            Hong Kong
            University of Science and Technology Library.
         </div>
         <div class="bibliomixed e764" xml:id="Brueggemann-Klein2004" xreflabel="Brüggemann-Klein and Wood, 2004">Brüggemann-Klein, A., and D. Wood (2004). Balanced context-free grammars, hedge grammars
            and
            pushdown caterpillar automata. In Proceedings of Extreme Markup Languages, Montréal,
            Québec.
         </div>
         <div class="bibliomixed e765" xml:id="Buck2000" xreflabel="Buck et al., 2000">Buck, L., Goldfarb, C. F., and P.
            Prescod (2000). Datatypes for DTDs (DT4DTD) 1.0. W3C Note 13 January 2000, World Wide
            Web
            Consortium.
         </div>
         <div class="bibliomixed e766" xml:id="Carey2009" xreflabel="Carey, 2009">Carey, B. M. (2009). Meet CAM: A new XML
            validation technology. Take semantic and structural validation to the next level.
            IBM
            developerworks, IBM Corporation. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e767" xlink:actuate="onRequest" xlink:href="http://www.ibm.com/developerworks/xml/library/x-cam/?S_TACT=105AGX54&amp;S_CMP=C0924&amp;ca=dnw-1036&amp;ca=dth-x&amp;open&amp;cm_mmc=6015-_-n-_-vrm_newsletter-_-10731_131528&amp;cmibm_em=dm:0:13962324" xlink:show="new" xlink:type="simple">http://www.ibm.com/developerworks/xml/library/x-cam/?S_TACT=105AGX54&amp;S_CMP=C0924&amp;ca=dnw-1036&amp;ca=dth-x&amp;open&amp;cm_mmc=6015-_-n-_-vrm_newsletter-_-10731_131528&amp;cmibm_em=dm:0:13962324</div>.
         </div>
         <div class="bibliomixed e768" xml:id="Chomsky1955" xreflabel="Chomsky, 1955">Chomsky, N. (1955). Logical Syntax
            and Semantics: Their Linguistic Relevance. Language, 31(1):36–45, 1955. doi: 
            <div class="biblioid doi e769">10.2307/410891</div>.
         </div>
         <div class="bibliomixed e770" xml:id="Chomsky1956" xreflabel="Chomsky, 1956">Chomsky, N. (1956). Three Models for
            the Description of Language. IRE Transactions on Information Theory, 2:113–124,
            1956. doi: 
            <div class="biblioid doi e771">10.1109/TIT.1956.1056813</div>.
         </div>
         <div class="bibliomixed e772" xml:id="Clark2001" xreflabel="Clark, 2001">Clark, J. (2001). TREX – Tree Regular
            Expressions for XML Language Specification. Technical report, Thai Open Source Software
            Center
            Ltd.
         </div>
         <div class="bibliomixed e773" xml:id="Clark2003" xreflabel="Clark et al., 2003">Clark, J., J. Cowan, and M.
            Murata, (2003). Relax NG Compact Syntax Tutorial. Working Draft 26 March 2003, OASIS
            –-
            Organization for the Advancement of Structured Information Standards. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e774" xlink:actuate="onRequest" xlink:href="http://relaxng.org/compact-tutorial-20030326.html" xlink:show="new" xlink:type="simple">http://relaxng.org/compact-tutorial-20030326.html</div>.
         </div>
         <div class="bibliomixed e775" xml:id="Comon2008" xreflabel="Comon et al., 2008">Comon, H., M. Dauchet, R.
            Gilleron, C. Löding, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi (2007). Tree
            Automata
            Techniques and Applications. Release November, 18th 2008. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e776" xlink:actuate="onRequest" xlink:href="http://www.grappa.univ-lille3.fr/tata" xlink:show="new" xlink:type="simple">http://www.grappa.univ-lille3.fr/tata</div>.
         </div>
         <div class="bibliomixed e777" xml:id="Costello2008" xreflabel="Costello and Simmons, 2008"> Costello, R. L., and
            R. A. Simmons (2008). Tutorials on Schematron: Two Types of XML Schema Language. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e778" xlink:actuate="onRequest" xlink:href="http://www.xfront.com/schematron/Two-types-of-XML-Schema-Language.html" xlink:show="new" xlink:type="simple">http://www.xfront.com/schematron/Two-types-of-XML-Schema-Language.html</div>.
         </div>
         <div class="bibliomixed e779" xml:id="Moeller2005" xreflabel="DSD2">Møller, A. (2005). Document Structure
            Description 2.0. Technical report, BRICS (Basic Research in Computer Science, Aarhus
            University), 2005. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e780" xlink:actuate="onRequest" xlink:href="http://www.brics.dk/DSD/dsd2.html" xlink:show="new" xlink:type="simple">http://www.brics.dk/DSD/dsd2.html</div>.
         </div>
         <div class="bibliomixed e781" xml:id="Fiorello2004" xreflabel="Fiorello et al., 2004">Fiorello, D., Gessa, N.,
            Marinelli, P., and F. Vitali. DTD++ 2.0: Adding support for co-constraints. In Proceedings
            of
            Extreme Markup Languages, Montréal, Québec.
         </div>
         <div class="bibliomixed e782" xml:id="Gelade2009" xreflabel="Gelade et al., 2009">Gelade, W, Martens, W., and F.
            Neven (2009). Optimizing Schema Languages for XML: Numerical Constraints and Interleaving.
            SIAM Journal on Computing, 38(5):2021–2043. doi: 
            <div class="biblioid doi e783">10.1137/070697367</div>.
         </div>
         <div class="bibliomixed e784" xml:id="Goldfarb1978" xreflabel="Goldfarb, 1978">Goldfarb, C. F. (1978). DCF GML
            User’s Guide (IBM SH20-9160). IBM, 1978.
         </div>
         <div class="bibliomixed e785" xml:id="Goldfarb1991" xreflabel="Goldfarb, 1991">Goldfarb, C. F. (1991). The SGML
            Handbook. Oxford University Press, Oxford.
         </div>
         <div class="bibliomixed e786" xml:id="Gecseg1997" xreflabel="Gécseg and Steinby, 1997">Gécseg, F., and M. Steinby
            (1997). Tree languages. In Handbook of Formal Languages, volume 3, pages 1-68. Springer,
            New
            York.
         </div>
         <div class="bibliomixed e787" xml:id="Hopcroft2000" xreflabel="Hopcroft et al., 2000">Hopcroft, J., R. Motwani,
            and J. Ullman (2000). Introduction to Automata Theory, Languages, and Computation.
            2nd
            edition. Addison Wesley Longman, Amsterdam.
         </div>
         <div class="bibliomixed e788" xml:id="Jeliffe2009" xreflabel="Jeliffe, 2009">Jeliffe, R. (2009). Is Schematron a
            rules language? Online: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e789" xlink:actuate="onRequest" xlink:href="http://broadcast.oreilly.com/2009/01/is-schematron-a-rules-language.html" xlink:show="new" xlink:type="simple">http://broadcast.oreilly.com/2009/01/is-schematron-a-rules-language.html</div>.
         </div>
         <div class="bibliomixed e790" xml:id="Kilpeläinen2007" xreflabel="Kilpeläinen and Tuhkanen, 2007">Kilpeläinen,
            P., and R. Tuhkanen (2007). One-unambiguity of regular expressions with numeric occurrence
            indicators. Information and Computation, 205(6):890–916. doi: 
            <div class="biblioid doi e791">10.1016/j.ic.2006.12.003</div>.
         </div>
         <div class="bibliomixed e792" xml:id="Klarlund2003" xreflabel="Klarlund et al., 2003">Klarlund, N., T.
            Schwentick, and D. Suciu (2003). XML: Model, Schemas, Types, Logics and Queries. In
            Chomicki,
            J., R. van der Meyden, and G. Saake, eds., Logics for Emerging Applications of Databases,
            pages 1-41. Springer, Berlin, Heidelberg.
         </div>
         <div class="bibliomixed e793" xml:id="Kracht2010" xreflabel="Kracht, 2010">Kracht, M. (to appear). Modal Logic
            Foundations of Markup Structures in Annotation Systems. In Mehler, A., Kühnberger,
            K.-U.,
            Lobin, H., Lüngen, H., Storrer, A., and A. Witt, eds., Modeling, Learning and Processing
            of
            Text Technological Data Structures, Studies in Computational Intelligence. Springer,
            Dordrecht.
         </div>
         <div class="bibliomixed e794" xml:id="Lee2000" xreflabel="Lee and Chu, 2000">Lee, D. and W. Chu. Comparative
            Analysis of Six XML Schema Languages. ACM SIGMOD Record, 29(3):76–87, September
            2000. doi: 
            <div class="biblioid doi e795">10.1145/362084.362140</div>.
         </div>
         <div class="bibliomixed e796" xml:id="Maler1995" xreflabel="Maler and Andaloussi, 1995">Maler, E., and J. E.
            Andaloussi (1995). Developing SGML DTDs: From Text to Model to Markup. Prentice Hall,
            Upper
            Saddle River, New Jersey
         </div>
         <div class="bibliomixed e797" xml:id="Mani2001" xreflabel="Mani, 2001">M. Mani (2001). Keeping chess alive: Do we
            need 1-unambiguous content models? In Proceedings of Extreme Markup Languages, Montréal,
            Québec.
         </div>
         <div class="bibliomixed e798" xml:id="Mani2002" xreflabel="Mani and Lee, 2002">Mani, M., and D. Lee (2002). XML
            to Relational Conversion using Theory of Regular Tree Grammars. In Proceedings of
            the 28th
            VLDB Conference, Hong Kong, China.
         </div>
         <div class="bibliomixed e799" xml:id="Marcoux2008" xreflabel="Marcoux, 2008">Marcoux, Y. (2008). Graph
            characterization of overlap-only TexMECS and other overlapping markup formalisms.
            In
            Proceedings of Balisage: The Markup Conference 2008. Balisage Series on Markup Technologies,
            vol. 1. Montréal, Québec. doi: 
            <div class="biblioid doi e800">10.4242/BalisageVol1.Marcoux01</div>.
         </div>
         <div class="bibliomixed e801" xml:id="Martens2005" xreflabel="Martens et al., 2005">Martens, W., Neven, F., and
            T. Schwentick (2005). Which XML Schemas Admit 1-Pass Preorder Typing? In Eiter, T.,
            and L.
            Libkin, eds., Database Theory – ICDT 2005, volume 3363 of Lecture Notes in Computer
            Science,
            pages 68–82. Springer, Berlin, Heidelberg, 2005. doi: 
            <div class="biblioid doi e802">10.1007/978-3-540-30570-5_5</div>.
         </div>
         <div class="bibliomixed e803" xml:id="Martens2006" xreflabel="Martens et al., 2006">Martens, W., Neven, F.,
            Schwentick, T., and G. Bex (2006). Expressiveness and Complexity of XML Schema. ACM
            Transactions on Database Systems (TODS), 31(3):770–813. doi: 
            <div class="biblioid doi e804">10.1145/1166074.1166076</div>.
         </div>
         <div class="bibliomixed e805" xml:id="Martens2007" xreflabel="Martens et al., 2007">Martens, W., Neven, F. and T.
            Schwentick (2007). Simple off the shelf abstractions for XML schema. SIGMOD Rec.,
            36(3):15–22. doi: 
            <div class="biblioid doi e806">10.1145/1324185.1324188</div>.
         </div>
         <div class="bibliomixed e807" xml:id="Martens2009" xreflabel="Martens et al., 2009">Martens, W., Neven, F. and T.
            Schwentick (2009). Complexity of Decision Problems for XML Schemas and Chain Regular
            Expressions. SIAM Journal on Computing, 39(4):1486–1530. doi: 
            <div class="biblioid doi e808">10.1137/080743457</div>.
         </div>
         <div class="bibliomixed e809" xml:id="Moeller2006" xreflabel="Møller and Schwartzbach, 2006">Møller, A., and M.
            Schwartzbach (2006). An Introduction to XML and Web Technologies, chapter Schema Languages,
            pages 92–187. Addison-Wesley, Harlow, England.
         </div>
         <div class="bibliomixed e810" xml:id="Murata2001" xreflabel="Murata et al., 2001">﻿Murata, M., D. Lee, and M.
            Mani (2001). Taxonomy of XML Schema Languages using Formal Language Theory. In Proceedings
            of
            Extreme Markup Languages, Montréal, Québec.
         </div>
         <div class="bibliomixed e811" xml:id="Murata2005" xreflabel="Murata et al., 2005">﻿Murata, M., D. Lee, M. Mani,
            and K. Kawaguchi (2005). Taxonomy of XML Schema Languages Using Formal Language Theory.
            ACM
            Transactions on Internet Technology, 5(4):660–704. doi: 
            <div class="biblioid doi e812">10.1145/1111627.1111631</div>.
         </div>
         <div class="bibliomixed e813" xml:id="CLiX" xreflabel="Nentwich, 2005">Nentwich, C. (2005). CLiX – A
            Validation Rule Language for XML. Presented by Anthony Finkelstein at W3C Workshop
            on Rule
            Languages for Interoperability, 27-28 April 2005, Washington D.C. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e814" xlink:actuate="onRequest" xlink:href="http://www.w3.org/2004/12/rules-ws/paper/24/" xlink:show="new" xlink:type="simple">http://www.w3.org/2004/12/rules-ws/paper/24/</div>.
         </div>
         <div class="bibliomixed e815" xml:id="NVDL" xreflabel="NVDL">ISO/IEC 19757-4:2006. Information technology —
            Document Schema Definition Languages (DSDL) — Part 4: Namespace-based Validation Dispatching
            Language (NVDL), International Standard, International Organization for Standardization,
            Geneva.
         </div>
         <div class="bibliomixed e816" xml:id="Odgen1968" xreflabel="Odgen, 1968">Odgen, W. (1968). A Helpful Result for
            Proving Inherent Ambiguity. In Mathematical Systems Theory, 2(3):191–194. doi: 
            <div class="biblioid doi e817">10.1007/BF01694004</div>.
         </div>
         <div class="bibliomixed e818" xml:id="Pawson2007" xreflabel="Pawson, 2007">Pawson, D. (2007). ISO Schematron
            tutorial. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e819" xlink:actuate="onRequest" xlink:href="http://www.dpawson.co.uk/schematron/" xlink:show="new" xlink:type="simple">http://www.dpawson.co.uk/schematron/</div>.
         </div>
         <div class="bibliomixed e820" xml:id="Papakonstantinou2000" xreflabel="Papakonstantinou and Vianu, 2000">Papakonstantinou, Y., and V. Vianu (2000). DTD inference for views of XML data. In
            PODS ’00:
            Proceedings of the nineteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of
            database
            systems, pages 35–46, New York, NY, USA, ACM. doi: 
            <div class="biblioid doi e821">10.1145/335168.335173</div>.
         </div>
         <div class="bibliomixed e822" xml:id="Piez2001" xreflabel="Piez, 2001">Piez, W. (2001). Beyond the “descriptive
            vs. procedural” distinction. In Markup Languages – Theory &amp; Practice,
            3(2):141–172. doi: 
            <div class="biblioid doi e823">10.1162/109966201317356380</div>.
         </div>
         <div class="bibliomixed e824" xml:id="RELAXCore" xreflabel="RELAX Core">ISO/IEC TR 22250-1:2002. Information
            technology – Document description and processing languages – Regular Language Description
            for
            XML – part 1: RELAX Core. International Standard, International Organization for
            Standardization, Geneva.
         </div>
         <div class="bibliomixed e825" xml:id="RELAX" xreflabel="RELAX NG">ISO/IEC 19757-2:2008. Information technology –
            Document Schema Definition Language (DSDL) – Part 2: Regular-grammar-based validation
            – RELAX
            NG (ISO/IEC 19757-2). International Standard, International Organization for Standardization,
            Geneva.
         </div>
         <div class="bibliomixed e826" xml:id="RELAX2nd" xreflabel="RELAX NG (2nd Ed.)">ISO/IEC 19757-2:2008. Information
            technology – Document Schema Definition Language (DSDL) – Part 2: Regular-grammar-based
            validation – RELAX NG (ISO/IEC 19757-2). Second Edition. International Standard, International
            Organization for Standardization, Geneva.
         </div>
         <div class="bibliomixed e827" xml:id="Rizzi2001" xreflabel="Rizzi, 2001">Rizzi, R. (2001). Complexity of
            context-free grammars with exceptions and the inadequacy of grammars as models for
            XML and
            SGML. Markup Languages – Theory &amp; Practice, 3(1):107–116. doi: 
            <div class="biblioid doi e828">10.1162/109966201753537222</div>.
         </div>
         <div class="bibliomixed e829" xml:id="Rogers2003" xreflabel="Rogers, 2003">Rogers, J. (2003). Syntactic
            Structures as Multi-dimensional Trees. In Research on Language and Computation,
            1(3-4):265–305. doi: 
            <div class="biblioid doi e830">10.1023/A:1024695608419</div>.
         </div>
         <div class="bibliomixed e831" xml:id="Sasaki2010" xreflabel="Sasaki, 2010">Sasaki, F. (2010). How to avoid
            suffering from markup: A project report about the virtue of hiding xml. In XML Prague
            2010
            Conference Proceedings, pages 105–123, Prague, Czech Republic, March 13–14 2010. Institute
            for
            Theoretical Computer Science.
         </div>
         <div class="bibliomixed e832" xml:id="Schematron" xreflabel="Schematron">ISO/IEC 19757-3:2006 Information
            technology — Document Schema Definition Languages (DSDL) — Part 3: Rule-based validation
            —
            Schematron. International Standard, International Organization for Standardization,
            Geneva.
         </div>
         <div class="bibliomixed e833" xml:id="SGML" xreflabel="SGML">ISO 8879:1986. Information Processing — Text and
            Office Information Systems — Standard Generalized Markup Language. International Standard,
            International Organization for Standardization, Geneva.
         </div>
         <div class="bibliomixed e834" xml:id="Sperberg-McQueen2003" xreflabel="Sperberg-McQueen, 2003">Sperberg-McQueen,
            C. M. (2003). Logic grammars and XML Schema. In Proceedings of Extreme Markup Languages,
            Montréal, Québec.
         </div>
         <div class="bibliomixed e835" xml:id="Sperberg-McQueen2004" xreflabel="Sperberg-McQueen and        Huitfeldt, 2004">Sperberg-McQueen, C.&nbsp;M. and C.
            Huitfeldt (2004). GODDAG: A Data Structure for Overlapping Hierarchies. In King, P.
            and E. V.
            Munson, eds. Proceedings of the 5th International Workshop on the Principles of Digital
            Document Processing (PODDP 2000), volume 2023 of Lecture Notes in Computer Science,
            pages
            139–160. Springer, 2004
         </div>
         <div class="bibliomixed e836" xml:id="Stuehrenberg2009" xreflabel="Stührenberg and Jettka, 2009">Stührenberg, M.
            and D. Jettka (2009). A toolkit for multi-dimensional markup: The development of SGF
            to
            XStandoff. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series
            on Markup
            Technologies, vol. 3 (2009). Montréal, Québec. doi: 
            <div class="biblioid doi e837">10.4242/BalisageVol3.Stuhrenberg01</div>.
         </div>
         <div class="bibliomixed e838" xml:id="Vitali2003" xreflabel="Vitali et al., 2003">Vitali, F., Amorosi, N., and N.
            Gessa. Datatype- and namespace-aware DTDs: A minimal extension. In Proceedings of
            Extreme
            Markup Languages, Montré́al, Québec.
         </div>
         <div class="bibliomixed e839" xml:id="vanderVlist2001" xreflabel="van der Vlist, 2001">van der Vlist, E. (2001).
            Comparing XML Schema Languages, 12 December 2001. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e840" xlink:actuate="onRequest" xlink:href="http://www.xml.com/pub/a/2001/12/12/schemacompare.html" xlink:show="new" xlink:type="simple">http://www.xml.com/pub/a/2001/12/12/schemacompare.html</div>.
         </div>
         <div class="bibliomixed e841" xml:id="vanderVlist2003" xreflabel="van der Vlist, 2003">van der Vlist, E. (2003).
            RELAX NG. O’Reilly, Sebastopol.
         </div>
         <div class="bibliomixed e842" xml:id="XML10" xreflabel="XML 1.0">Extensible Markup Language (XML) 1.0. W3C
            Recommendation, World Wide Web Consortium, 10 February 1998. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e843" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/1998/REC-xml-19980210" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/1998/REC-xml-19980210</div>.
         </div>
         <div class="bibliomixed e844" xml:id="XML" xreflabel="XML 1.0 (Fifth Edition)">Extensible Markup Language (XML)
            1.0 (Fifth Edition). W3C Recommendation, World Wide Web Consortium, 26 November 2008.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e845" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/REC-xml-20081126/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2008/REC-xml-20081126/</div>.
         </div>
         <div class="bibliomixed e846" xml:id="XMLNS" xreflabel="XML Namespaces (Third Edition)">Namespaces in XML 1.0
            (Third Edition). W3C Recommendation, World Wide Web Consortium, 8 December 2009. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e847" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2009/REC-xml-names-20091208/</div>.
         </div>
         <div class="bibliomixed e848" xml:id="XMLSchema2004" xreflabel="XML Schema 1.0 Part 0">XML Schema Part 0: Primer
            Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October 2004. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e849" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/</div>.
         </div>
         <div class="bibliomixed e850" xml:id="XMLSchema2004a" xreflabel="XML Schema 1.0 Part 1">XML Schema Part 1:
            Structures Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October
            2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e851" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</div>.
         </div>
         <div class="bibliomixed e852" xml:id="XMLSchema2004b" xreflabel="XML Schema 1.0 Part 2">XML Schema Part 2:
            Datatypes Second Edition. W3C Recommendation, World Wide Web Consortium, 28 October
            2004.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e853" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</div>.
         </div>
         <div class="bibliomixed e854" xml:id="XMLSchema2009" xreflabel="XML Schema 1.1 Part 1">W3C XML Schema Definition
            Language (XSD) 1.1 Part 1: Structures. W3C Working Draft, World Wide Web Consortium,
            3
            December 2009. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e855" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2009/WD-xmlschema11-1-20091203/</div>.
         </div>
         <div class="bibliomixed e856" xml:id="XMLSchema2009-2" xreflabel="XML Schema 1.1 Part 2">W3C XML Schema
            Definition Language (XSD) 1.1 Part 2: Datatypes. W3C Working Draft, World Wide Web
            Consortium,
            3 December 2009. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e857" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2009/WD-xmlschema11-2-20091203/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2009/WD-xmlschema11-2-20091203/</div>.
         </div>
         <div class="bibliomixed e858" xml:id="XSLT2" xreflabel="XSLT 2.0">XSL Transformations (XSLT) Version 2.0. W3C
            Recommendation, World Wide Web Consortium, 23 January 2007. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e859" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2007/REC-xslt20-20070123/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2007/REC-xslt20-20070123/</div>.
         </div>
         <div class="bibliomixed e860" xml:id="XQuery" xreflabel="XQuery 1.0">XQuery 1.0: An XML Query Language. W3C
            Recommendation, World Wide Web Consortium, 23 January 2007. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e861" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2007/REC-xquery-20070123/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/2007/REC-xquery-20070123/</div>.
         </div>
      </div>
   </div>
</div>