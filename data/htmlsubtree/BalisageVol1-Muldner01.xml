<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#SecurePublishingusingSchemalevelRolebasedAccessControlPoliciesforFragmentsofXMLDocumentsANCHOR" name="SecurePublishingusingSchemalevelRolebasedAccessControlPoliciesforFragmentsofXMLDocumentsTOC">Secure Publishing using Schema-level Role-based Access Control Policies for Fragments
               of XML Documents</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#RelatedWorkANCHOR" name="RelatedWorkTOC">Related Work </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AccessControlPoliciesANCHOR" name="AccessControlPoliciesTOC">Access Control Policies</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DocumentsandDocumentPathsANCHOR" name="DocumentsandDocumentPathsTOC">Documents and Document Paths</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#DocumentlevelAccessControlPoliciesDRBACANCHOR" name="DocumentlevelAccessControlPoliciesDRBACTOC">Document-level Access Control Policies, DRBAC</a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemasandGrammarPathsANCHOR" name="SchemasandGrammarPathsTOC"> Schemas and Grammar Paths</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#SchemalevelAccessControlPoliciesSRBAC%0AANCHOR" name="SchemalevelAccessControlPoliciesSRBAC%0ATOC"> Schema-level Access Control Policies, SRBAC
                        </a></div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#KeyGenerationandDocumentEncryption%0AANCHOR" name="KeyGenerationandDocumentEncryption%0ATOC">Key Generation and Document Encryption
                  </a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#EncryptionandKeyringsANCHOR" name="EncryptionandKeyringsTOC"> Encryption and Keyrings </a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#BasicNotationsANCHOR" name="BasicNotationsTOC"> Basic Notations </a></div>
               </div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#KeyGenerationANCHOR" name="KeyGenerationTOC">Key Generation </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ConfigurationsANCHOR" name="ConfigurationsTOC">Configurations</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FindingabstractvaluesANCHOR" name="FindingabstractvaluesTOC"> Finding abstract values</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemabasedKeyringsandRoleaccessibleKeyringsANCHOR" name="SchemabasedKeyringsandRoleaccessibleKeyringsTOC"> Schema-based Keyrings and Role-accessible Keyrings </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SchemaGraphAnnotationsANCHOR" name="SchemaGraphAnnotationsTOC"> Schema Graph Annotations </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#MultiencryptionofDocumentsANCHOR" name="MultiencryptionofDocumentsTOC"> Multi-encryption of Documents </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DecryptionofMultiEncryptedDocumentsANCHOR" name="DecryptionofMultiEncryptedDocumentsTOC"> Decryption of Multi-Encrypted Documents </a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC"> Implementation </a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ResultsofTestingANCHOR" name="ResultsofTestingTOC"> Results of Testing </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsandFutureWorkANCHOR" name="ConclusionsandFutureWorkTOC"> Conclusions and Future Work </a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#AcknowledgementsANCHOR" name="AcknowledgementsTOC">Acknowledgements</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">access control policy (ACP)</div>
         <div class="singletermTERMS">any</div>
         <div class="singletermTERMS">atomic grammar path</div>
         <div class="singletermTERMS">abstract value</div>
         <div class="singletermTERMS">Algorithm 4.1</div>
         <div class="singletermTERMS">Algorithm 4.2.</div>
         <div class="singletermTERMS">Algorithm 4.3.</div>
         <div class="singletermTERMS">all</div>
         <div class="singletermTERMS">August 12 - 15, 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2008</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">Contributions:</div>
         <div class="singletermTERMS">configuration</div>
         <div class="singletermTERMS">configuration index value</div>
         <div class="singletermTERMS">condition</div>
         <div class="singletermTERMS">Conclusions.</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">D,R</div>
         <div class="singletermTERMS">D2</div>
         <div class="singletermTERMS">Definition 3.1.</div>
         <div class="singletermTERMS">Definition 3.2.</div>
         <div class="singletermTERMS">Definition 3.3.</div>
         <div class="singletermTERMS">Definition 3.4.</div>
         <div class="singletermTERMS">Definition 3.5.</div>
         <div class="singletermTERMS">decrypting key</div>
         <div class="singletermTERMS">Definition 4.1.</div>
         <div class="singletermTERMS">disjoint partition</div>
         <div class="singletermTERMS">Definition 4.2.</div>
         <div class="singletermTERMS">Definition 4.3.</div>
         <div class="singletermTERMS">do not know values of conditions</div>
         <div class="singletermTERMS">Director</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">eXtensible Markup Language (XML)</div>
         <div class="singletermTERMS">efficient multi-encryption</div>
         <div class="singletermTERMS">Example 3.1.</div>
         <div class="singletermTERMS">Example 3.2.</div>
         <div class="singletermTERMS">Example 3.3.</div>
         <div class="singletermTERMS">element names</div>
         <div class="singletermTERMS">Example 3.4.</div>
         <div class="singletermTERMS">Example 3.5.</div>
         <div class="singletermTERMS">Example 3.6.</div>
         <div class="singletermTERMS">Example 3.7.</div>
         <div class="singletermTERMS">Example 3.8.</div>
         <div class="singletermTERMS">Example 3.9.</div>
         <div class="singletermTERMS">encrypting key</div>
         <div class="singletermTERMS">Example 4.1.</div>
         <div class="singletermTERMS">empty document paths</div>
         <div class="singletermTERMS">excluded</div>
         <div class="singletermTERMS">Example 4.2.</div>
         <div class="singletermTERMS">Example 4.3.</div>
         <div class="singletermTERMS">Example 4.4.</div>
         <div class="singletermTERMS">encrypted_data</div>
         <div class="singletermTERMS">Example 4.5.</div>
         <div class="singletermTERMS">Example 4.6.</div>
         <div class="singletermTERMS">encryption queue</div>
         <div class="singletermTERMS">Encryption</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">falsehood</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">grammar paths</div>
         <div class="singletermTERMS">grammar path</div>
         <div class="singletermTERMS">global value table</div>
         <div class="singletermTERMS">Graduate Student</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
         <div class="singletermTERMS">jkm@ibi.uw.edu.pl</div>
         <div class="singletermTERMS">Jan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Krzysztof</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">lazy key generation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">multi-encryption</div>
         <div class="singletermTERMS">materialized</div>
         <div class="singletermTERMS">mixed</div>
         <div class="singletermTERMS">materialized grammar paths</div>
         <div class="singletermTERMS">Müldner</div>
         <div class="singletermTERMS">McNeill</div>
         <div class="singletermTERMS">Miziołek</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">optionally</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">predicate</div>
         <div class="singletermTERMS">partition</div>
         <div class="singletermTERMS">Professor</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">role-available keyring</div>
         <div class="singletermTERMS">Results.</div>
         <div class="singletermTERMS">Robin</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">S,D</div>
         <div class="singletermTERMS">secure publishing</div>
         <div class="singletermTERMS">super-encryption</div>
         <div class="singletermTERMS">single</div>
         <div class="singletermTERMS">schema level</div>
         <div class="singletermTERMS">single pass</div>
         <div class="singletermTERMS">sanitized</div>
         <div class="singletermTERMS">schema-level protection requirement</div>
         <div class="singletermTERMS">symbolic grammar path expression</div>
         <div class="singletermTERMS">Secure access</div>
         <div class="singletermTERMS">Social networks</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">types</div>
         <div class="singletermTERMS">target</div>
         <div class="singletermTERMS">tests</div>
         <div class="singletermTERMS">tomasz.muldner@acadiau.ca</div>
         <div class="singletermTERMS">Tomasz</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">views</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XML Schema</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="SecurePublishingusingSchemalevelRolebasedAccessControlPoliciesforFragmentsofXMLDocumentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973">
      <div class="title e1">Secure Publishing using Schema-level Role-based Access Control Policies for Fragments
         of XML Documents
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2008</div>
            <div class="confdates e5">August 12 - 15, 2008</div>
         </div>
         <div class="abstract e6">
            <div class="para e7"> Popularity of social networks is growing rapidly and secure publishing is an important
               implementation tool for these networks. At the same time, recent implementations of
               access control policies (ACPs) for sharing fragments of XML documents have moved from
               distributing to users numerous sanitized sub-documents to disseminating a single document
               multi-encrypted with multiple cryptographic keys, in such a way that the stated ACPs
               are enforced. Any application that uses this implementation of ACPs will incur a high
               cost of generating keys separately for each document. However, most such applications,
               such as secure publishing, use similar documents, i.e. documents based on a selected
               schema. This paper describes RBAC defined at the schema level, (SRBAC), and generation
               of the minimum number of keys at the schema level. The main advantage of our approach
               is that for any application that uses a fixed number of schemas, keys can be generated
               (or even pre-generated) only once, and then reused in all documents valid for the
               given schema. While in general, key generation at the schema level has to be pessimistic,
               our approach tries to minimize the number of generated keys. Incoming XML documents
               are efficiently encrypted using single-pass SAX parsing in such a way that the original
               structure of these documents is completely hidden. We also describe distributing to
               each user only keys needed for decrypting accessible nodes, and for applying the minimal
               number of encryption operations to an XML document required to satisfy the protection
               requirements of the policy.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Tomasz</div>
               <div class="surname e11">Müldner</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Tomasz Müldner is a professor of computer science at Acadia University in Nova Scotia,
                  one of Canada's top undergraduate universities. He has received numerous teaching
                  awards, including the prestigious Acadia University Alumni Excellence in Teaching
                  Award in 1996. He is the author of several books and numerous research papers. Dr.
                  Müldner received his Ph.D. in mathematics from the Polish Academy of Science in Warsaw,
                  Poland in 1975.  His current research includes XML compression and encryption, and
                  website internationalization.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Professor</div>
               <div class="orgname e16">Jodrey School of Computer Science, Acadia University</div>
            </div>
            <div class="email e17">tomasz.muldner@acadiau.ca</div>
         </div>
         <div class="author e18">
            <div class="personname e19">
               <div class="firstname e20">Robin</div>
               <div class="surname e21">McNeill</div>
            </div>
            <div class="personblurb e22">
               <div class="para e23">Robin McNeill graduated in May of 2008 with a Bachelor of Computer Science degree
                  at Acadia University. He will be returning to Acadia University for the following
                  academic year as a graduate student pursuing his masters degree in computer science.
               </div>
            </div>
            <div class="affiliation e24">
               <div class="jobtitle e25">Graduate Student</div>
               <div class="orgname e26">Jodrey School of Computer Science, Acadia University</div>
            </div>
            <div class="email e27">063637m@acadiau.ca</div>
         </div>
         <div class="author e28">
            <div class="personname e29">
               <div class="firstname e30">Jan</div>
               <div class="othername e31">Krzysztof</div>
               <div class="surname e32">Miziołek</div>
            </div>
            <div class="personblurb e33">
               <div class="para e34">Jan Krzysztof Miziołek works for the University of Warsaw, Poland. Dr. Miziołek received
                  his Ph.D. in mathematics from Technical University of Lodz, Poland in 1981. He worked
                  on design and implementation of a high-level programming language, LOGLAN-82. His
                  current research includes XML compression and encryption.
               </div>
            </div>
            <div class="affiliation e35">
               <div class="jobtitle e36">Director</div>
               <div class="orgname e37"> Computing Services Centre for Studies on the Classical Tradition in Poland and East-Central
                  Europe, University of Warsaw, Warsaw, Poland
               </div>
            </div>
            <div class="email e38">jkm@ibi.uw.edu.pl</div>
         </div>
         <div class="legalnotice e39">
            <div class="para e40">Copyright © 2008 Tomasz Müldner, Robin McNeill, and Jan Krzysztof Miziołek</div>
         </div>
         <div class="keywordset e41" role="author">
            <div class="keyword e42">Secure access</div>
            <div class="keyword e43">Social networks</div>
            <div class="keyword e44">Encryption</div>
            <div class="keyword e45">XML Schema</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e46">
         <div class="title e47">Introduction</div>
         <div class="para e48">Recent years have seen the 
            <div class="emphasis e49" role="ital">eXtensible Markup Language (XML)</div> expand beyond its origins as a standard for web document authoring to become widely
            embraced as a data encoding format.  For example, the most recent releases of commercial
            database systems include utilities for exporting relational data sets into XML format
            to facilitate data exchange.  This trend has naturally motivated researchers to investigate
            fine-grained (i.e., element-level) access control models for XML data sets.  While
            early approaches employed server-side techniques such as materialized security views
            and query re-writing, there has been some concern as to whether such approaches can
            scale up to handle applications involving thousands of users and/or complex access
            control policies.  More recently, attention has been focused on 
            <div class="emphasis e50" role="ital">secure publishing </div>solutions, in which an XML document is made accessible to all users (e.g., by hosting
            it on an HTTP server) through possibly insecure channels. The desired 
            <div class="emphasis e51" role="ital">access control policy (ACP)</div> is enforced by encrypting regions of the document using cryptographic keys. Each
            user is assigned, through a secure channel, a set of keys (a keyring) corresponding
            to the permissions they have been granted under the access control policy, which allows
            them to decrypt exactly a document fragment consisting of element nodes they have
            been granted access to.  There are two crucial issues to note under this scenario:
            (1) the access control policy is only capable of enforcing read operations, as there
            is nothing preventing an authorized user from altering a data field once they have
            decrypted it and republishing a new version, and (2) the document owner (author) relinquishes
            control over the document once it has been published: consequently, any changes to
            the access control policy, or to the contents of the document can only be imposed
            by publishing a new version of the document.
         </div>
         <div class="para e52">
            While secure publishing approaches can overcome many of the performance limitations
            of earlier approaches, some care has to be taken in their implementation to ensure
            scalability.  A naive attempt to enforce an ACP may use 
            <div class="emphasis e53" role="ital">super-encryption</div>, where elements residing in the intersection of two or more document paths in an
            ACP are encrypted with multiple keys, which greatly increases the number of expensive
            encryption and decryption operations. We use a more efficient 
            <div class="emphasis e54" role="ital">multi-encryption </div>strategy, in which every node is encrypted with a 
            <div class="emphasis e55" role="ital">single</div> key.  Additionally, a naive implementation may end up assigning many keys, effectively
            trading the problem of view explosion for key proliferation. Key generation is expensive,
            and requiring each user to handle multiple keys complicates key management.  Hence,
            one seeks to minimize the number of keys required to enforce a particular access control
            policy. Since nowadays many documents conform to one or more schemas, it would be
            more efficient to generate keys once, at the schema level, and then re-use them for
            multi-encrypting documents valid in those schemas.
         </div>
         <div class="para e56">
            
            <div class="emphasis e57" role="bold">Contributions: </div>In this paper, we address the performance issues alluded to earlier.  Our main contribution
            is a generalization of key generation to the 
            <div class="emphasis e58" role="ital">schema level</div>, allowing an access control policy to be defined over an entire class of XML documents
            specified by an XML Schema definition. Specifically, we define SRBAC, Schema-based
            ACP, based on our specification of grammar paths. This is a departure from previous
            research on grammar-level ACPs, which have mainly focused on DTDs and require separate
            key generation for each document valid for the grammar. Our second contribution is
            a specification of processing the schema S, which generates the keyring K
            <div class="subscript e59">S</div>, consisting of the minimum number of keys needed. In general, key generation at the
            schema level has to be pessimistic because it must generate enough keys to correctly
            encrypt all possible documents valid in the schema. However, because these keys are
            generated only once, before any document is to be encrypted, the algorithms to determine
            the minimum number of keys necessary may afford less efficient processing. (This phase
            roughly resembles program optimization performed by the compiler before the program
            is executed). Our third contribution is a specification of a 
            <div class="emphasis e60" role="ital">role-available keyring </div> K
            <div class="subscript e61">S</div>(R) which, for a given role R in the SRBAC policy, consists of keys that will be made
            available to the user in role R so that this user can access precisely the fragment
            of any document D, valid in S, allowed by this policy. Our fourth contribution is
            an 
            <div class="emphasis e62" role="ital">efficient multi-encryption </div> of XML documents in a 
            <div class="emphasis e63" role="ital">single pass </div> (using a SAX parser) in such a way that the decryption of multi-encrypted documents
            results in a well-formed XML document. The encrypted document hides all of the structure
            of the original document. While the decrypted documents are no longer valid in the
            original schema, one may create 
            <div class="emphasis e64" role="ital">sanitized</div> schema (for which such document will be valid), and use them to efficiently apply
            XML tools, such as XQuery for XML databases. Our current research concentrates on
            static documents, but using SAX parsing may allow considering streamed XML documents
            (which will be a focus of future research). Our fifth contribution is a comparison
            of the efficiency of our approach and super-encryption. Our last contribution is that
            our key generation technique applies to 
            <div class="emphasis e65" role="ital">any</div> access control model, not only to the role-based model considered in this paper.
            Note that while encryption is expensive, comparatively speaking, validation is not
            that expensive and we can't know if a document is valid until it has been completely
            traversed, so we may perform several costly and wasteful encryptions before discovering
            that the document is invalid.  In such a case, combining validation and encryption
            only serves to slow down the validation, while performing two separate passes likely
            wouldn't take much longer and would avoid wasted encryptions. Therefore, we first
            validate the document and then encrypt it.
            
         </div>
         <div class="para e66">
            There are various areas where the technique described in this paper can be applied.
            Besides secure publishing mentioned earlier, it can also be used for areas such as
            providing secure data to medical organizations or social networks.
            
         </div>
         <div class="para e67">
            This paper is organized as follows. In Section 2, we describe related work. Section
            3 describes RBAC at the document level, (DRBAC), and RBAC at the schema level, (SRBAC).
            In Section 4, we present our main results concerning SRBAC and key generation at the
            schema level, and briefly describe the implementation. Finally, in Section 5, we provide
            results of testing, and in Section 6 we describe conclusions and our future work.
            
         </div>
      </div><a name="RelatedWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e68">
         <div class="title e69">Related Work </div>
         <div class="para e70">
            The increasing popularity of XML as a data encoding format has forced attention on
            the problem of controlling access to
            XML documents [
            <div class="xref e71" linkend="mul100"></div>]. The majority of approaches to date (e.g. [
            <div class="xref e72" linkend="mul94"></div>],
            [
            <div class="xref e73" linkend="mul108"></div>], [
            <div class="xref e74" linkend="mul107"></div>] and [
            <div class="xref e75" linkend="mul105"></div>]) have focused on specification of access control policies at the document level,
            while a smaller number of proposals have additionally considered expression of policies
            over an entire class of documents at the schema level. [
            <div class="xref e76" linkend="mul96"></div>] and [
            <div class="xref e77" linkend="mul98"></div>] , [
            <div class="xref e78" linkend="mul99"></div>] specify  systems in which discretionary access control policies can be expressed
            over an individual XML document, or over a document type definition (DTD) defining
            a class of XML documents. [
            <div class="xref e79" linkend="mul106"></div>] defines a secure querying method for annotating a DTD with security policies, from
            which a security view is generated.  This view consists of a sanitized DTD Dv, which
            contains only the accessible portions of the original DTD D, and a function f, which
            specifies how to extract accessible data from instance XML documents conforming to
            D, in such a way that each query result generates a document conforming to Dv.  By
            hiding f from clients, the schema and data in the original document remain hidden,
            while clients are able to issue queries on accessible regions using Dv. 
         </div>
         <div class="para e80">More recent work focuses on the use of XML Schema as the schema specification language,
            in place of DTDs.
            [
            <div class="xref e81" linkend="mul103"></div>] describes a system which allows role-based access control policies to be defined
            at either the
            schema or document level.  At the schema level, access permissions are defined on
            schema objects (definitions of elements). [
            <div class="xref e82" linkend="mul110"></div>] describes RBAC-based policy specifications at the schema level, augmented with policy
            constraints using Schematron. Note that in all of these works, access control is enforced
            entirely by a server component, with a customized view of a document, consisting of
            only the accessible portions of the requested document, being returned to each client
            in accordance with their access permissions on the original document.  As a customized
            view must be generated in response to each client access request, in scenarios with
            complex documents and/or several users, view explosion becomes a problem. 
         </div>
         <div class="para e83">In contrast, our strategy forgoes reliance on a centralized access control and instead
            publishes a single (partially-) encrypted copy of each XML document, and relies on
            public-key cryptography to enforce the desired access control permission.  In this
            sense, it resembles the work of [
            <div class="xref e84" linkend="mul107"></div>] and [
            <div class="xref e85" linkend="mul108"></div>]. In addition to avoiding the view explosion problem (alluded to earlier) by publishing
            a single copy of each document, this type of approach is also more suited to deployment
            within decentralized architectures such as peer-to-peer, as it (1) facilitates the
            distribution of authentication and access control responsibilities between participating
            systems, rather than forcing reliance on a centralized component to enforce access
            control, and (2) is receptive to a variety of document distribution strategies, including
            broadcast, rather than being restricted to the client pull model. [
            <div class="xref e86" linkend="mul95"></div>]  and [
            <div class="xref e87" linkend="mul93"></div>] describe how to generate keys for documents and for DTDs/Schema; however, since
            at the schema level some conditions cannot be evaluated, keys must be generated at
            both the schema and document levels. 
         </div>
         <div class="para e88">
            In this paper, we present key generation at the schema level based on the concept
            of symbolic grammar paths. In [
            <div class="xref e89" linkend="mul109"></div>], we describe the design of parameterized role access control policies, which has
            recently been implemented. 
         </div>
      </div><a name="AccessControlPoliciesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e90">
         <div class="title e91">Access Control Policies</div>
         <div class="para e92">
            This section starts with a definition of ACPs at the document level, and then introduces
            ACP at the schema level. It also gives several examples that will be used throughout
            the paper. 
         </div><a name="DocumentsandDocumentPathsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e93">
            <div class="title e94">Documents and Document Paths</div>
            <div class="para e95">
               In our approach, document fragments, or views, are described using document paths
               based on XPath [
               <div class="xref e96" linkend="mul112"></div>]. For a document D, by P
               <div class="subscript e97">D</div> we denote the set of paths in D. We allow disjunctions of document paths, using the
               | operator. To simplify the process of defining grammar path, we borrow the following
               two Unix/C conventions: 
            </div>
            <div class="para e98">
               
               
               <div class="itemizedlist e99">
                  <div class="listitem e100">
                     <div class="para e101"> parameterless macros may be declared using the #define command, and then called using
                        $macro-name 
                     </div>
                  </div>
                  <div class="listitem e102">
                     <div class="para e103"> substitutions of the form
                        string
                        <div class="subscript e104">0</div>{string
                        <div class="subscript e105">1</div>, string
                        <div class="subscript e106">2</div>,..., string
                        <div class="subscript e107">n</div>}string
                     </div>
                     <div class="para e108">denote</div>
                     <div class="para e109">
                        string
                        <div class="subscript e110">0</div>string
                        <div class="subscript e111">1</div>string | string
                        <div class="subscript e112">0</div>string
                        <div class="subscript e113">2</div>string |...| string
                        <div class="subscript e114">0</div>string
                        <div class="subscript e115">n</div>string
                        
                     </div>
                     <div class="para e116">
                        where | denotes the alternative. Nested {} are also supported.
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="para e117">
               For example
            </div>
            <div class="programlisting e118" xml:space="preserve">
               	#define HP	/H/P
               	$HP/{a, b, c/{d,e}}
               
            </div>
            <div class="para e119"> stands for </div>
            <div class="programlisting e120" xml:space="preserve">
               /H/P/a | /H/P/b | /H/P/c/d | /H/P/c/e
               
            </div>
            <div class="para e121" xml:id="Ex3.1" xreflabel="Example 3.1">
               
               <div class="emphasis e122" role="bold">Example 3.1. </div>
            </div>
            <div class="para e123">
               Consider a hospital, where there are three types of tests: basic, confidential and
               very confidential; and each patient has three attributes: name, Id, and perm (the
               last attribute determines whether or not patients with negative Ids will have access
               to very confidential tests). The path P: 
            </div>
            <div class="programlisting e124" xml:space="preserve">
               	#define hp	/hospital/patient
               	P: $hp{/@Id, /basic/text(), /basic, [@Id&lt;"0" AND @perm="true"]/veryConfidential/text()}
               
            </div>
            <div class="para e125">is a document path for the following document D: </div>
            <div class="programlisting e126" xml:space="preserve">
               &lt;?xml version="1.0" encoding="UTF-4"?&gt;
               &lt;hospital&gt;
               	&lt;patient  name="Kay" Id="-1" perm="true" &gt;
               		&lt;basic&gt;B1&lt;/basic&gt;
               		&lt;confidential&gt;C1&lt;/confidential&gt;
               		&lt;veryConfidential&gt;V1&lt;/veryConfidential&gt;
               	&lt;/patient&gt;
               	&lt;patient  name="Smith" Id="-2" perm="false" &gt;
               		&lt;basic&gt;B2&lt;/basic&gt;
               		&lt;confidential&gt;C2&lt;/confidential&gt;
               		&lt;veryConfidential&gt;V2&lt;/veryConfidential&gt;
               	&lt;/patient&gt;
               	&lt;patient  name="Zen" Id="200" perm="true" &gt;
               		&lt;basic&gt;B3&lt;/basic&gt;
               		&lt;confidential&gt;C3&lt;/confidential&gt;
               		&lt;veryConfidential&gt;V3&lt;/veryConfidential&gt;
               	&lt;/patient&gt;
               &lt;/hospital&gt;
               
            </div>
            <div class="para e127">
               The above path P defines a view of D consisting of values of Id for all patients (both
               attribute and its value), the tagname &lt;basic&gt; and its text values, B1, B2 and B3;
               and the value of V1.  □ 
            </div><a name="DocumentlevelAccessControlPoliciesDRBACANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e128">
               <div class="title e129">Document-level Access Control Policies, DRBAC</div>
               <div class="para e130">
                  In this section we define document-level RBAC, DRBAC and the related protection requirement.
                  Here, we use a subset of XPath; a path expression p consists of one or more location
                  steps; each location step operates on the child axis.  A path is then of the form
                  p | not p | p1 intersect p2 | p1 union p2 , and its evaluation produces an ordered
                  sequence of nodes. A valid path is any path which does not evaluate to an empty sequence.
                  
               </div>
               <div class="para e131">
                  
                  <div class="emphasis e132" role="bold">Definition 3.1. </div>
               </div>
               <div class="para e133">
                  For an XML document D and a finite set Ψ of roles, the document-level RBAC (DRBAC)
                  is a mapping π
                  <div class="subscript e134">D</div>:Ψ→P
                  <div class="subscript e135">D</div> such that π
                  <div class="subscript e136">D</div>(Ψ) covers the set D; i.e., each element of D belongs to at least one document path
                  that occurs in the policy. Often, the mapping π
                  <div class="subscript e137">D</div> is tabulated and shown as a tuple [(R
                  <div class="subscript e138">1</div>, P
                  <div class="subscript e139">1</div>),(R
                  <div class="subscript e140">2</div>, P
                  <div class="subscript e141">2</div>),...,(R
                  <div class="subscript e142">n</div>, P
                  <div class="subscript e143">n</div>)] □ 
               </div>
               <div class="para e144">
                  There are various 
                  <div class="emphasis e145" role="ital">views </div> of the document D, and each view is defined by π
                  <div class="subscript e146">D</div>(R). The designer of the policy for an XML document D may decide to leave some parts
                  of D unencrypted (accessible to all users) or to make them inaccessible to all users
                  (i.e., to encrypt them, but not to provide the key used for encryption of these nodes
                  to any user). For the former case, the symbol ♥ is used, while for the latter case
                  we use the symbol •. Therefore, the actual definition of the document-level RBAC is
                  that it is pair (π
                  <div class="subscript e147">D</div>, ♦), where ♦ is either ♥ or •.
                  For simplicity (unless specified otherwise), in the sequel, we omit the second element
                  of this pair, and assume that by default it is always • (i.e. by default, elements
                  of D not covered by D are inaccessible to all users). 
               </div>
               <div class="para e148">
                  
                  <div class="emphasis e149" role="bold">Definition 3.2. </div> 
               </div>
               <div class="para e150">
                  The document-level protection requirement is said to be satisfied under the following
                  conditions. For an XML document D, a finite set of roles Ψ, and the document-level
                  RBAC π
                  <div class="subscript e151">D</div>:Ψ→P
                  <div class="subscript e152">D</div> a user in role R can access precisely the set π
                  <div class="subscript e153">D</div>(R), and if the policy uses ♥ also those nodes in D which are not covered by any path.
                  □ 
               </div>
               <div class="para e154">
                  
                  <div class="emphasis e155" role="bold">Example 3.2. </div> 
               </div>
               <div class="para e156" xml:id="Ex3.2" xreflabel="Example 3.2">
                  Consider the document D from [
                  <div class="xref e157" linkend="Ex3.1"></div>], and a set of roles Ψ = {Nurse, Physician, Resident, Smith}. We define four document
                  paths: 
               </div>
               <div class="programlisting e158" xml:space="preserve">
                  	#define hp	/hospital/patient
                  	#define Sname  	$hp[@name="Smith"]
                  	ND: $hp{/@Id, [@Id&lt;0]/basic/text()}
                  	PD: $hp/{@Id, @name, basic/text(), confidential/text(), veryConfidential/text()}
                  	RD: $hp{/@Id, [@Id&gt;"100" AND @perm= "true"]/veryConfidential/text()}
                  	SD: $Sname/{@perm, basic/text(), confidential/text(), veryConfidential/text() }
                  
               </div>
               <div class="para e159">
                  We now define π
                  <div class="subscript e160">D</div> as: [(Nurse, ND), (Physician, PD), (Resident, RD), (Smith, SD)], which gives: 
               </div>
               <div class="itemizedlist e161">
                  <div class="listitem e162">
                     <div class="para e163">the user in role Nurse access to Ids of all patients, and to the textual content of
                        the basic test for patients whose Id is negative; 
                     </div>
                  </div>
                  <div class="listitem e164">
                     <div class="para e165"> the user in role Physician access to Ids and names of all patients, and to the textual
                        content of the basic, confidential and very confidential tests; 
                     </div>
                  </div>
                  <div class="listitem e166">
                     <div class="para e167"> the user in role Resident access to Ids of all patients, and to the textual content
                        of the very confidential test for patients whose Id is greater than 100 and perm is
                        set to true;
                        
                     </div>
                  </div>
                  <div class="listitem e168">
                     <div class="para e169"> the user in role Smith access to permissions, and the textual content of the basic,
                        confidential and very confidential test for these patients whose name is Smith 
                     </div>
                  </div>
               </div>
               <div class="para e170">
                  Since by default we use the role •, other elements of D are available to nobody. In
                  
                  <div class="xref e171" linkend="fig1"></div>, B1, C1, etc. stand for the text contents of the basic tag, confidential tag, etc.;
                  elements accessible to the user in various roles are labeled with dotted boxes containing
                  first letters of the names of these roles; nodes which are not available to any user
                  are not labeled. 
               </div>
               <div class="figure e172" floatstyle="1" xml:id="fig1" xreflabel="Figure 1">
                  <div class="mediaobject e173">
                     <div class="imageobject e174">
                        <div class="metaBox e175"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e369').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e369" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e175'
                                 </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-001.png'
                                 </span><span class="metaAttribute">format='png'
                                 </span><span class="metaAttribute">width='100%'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                     <div class="caption e176">
                        <div class="para e177"> Labeled document tree for the hospital</div>
                     </div>
                  </div>
               </div>
               <div class="para e178">
                  Let us now use [
                  <div class="xref e179" linkend="Ex3.2"></div>] to compare super-encryption and multi-encryption. In the former case, nodes which
                  are on the intersection of document paths would have to be encrypted and then decrypted
                  with several keys. In the latter case, each node will be encrypted and decrypted with
                  a single key. (In Section 6, we provide results of experiments comparing these two
                  techniques.) 
               </div>
            </div>
         </div><a name="SchemasandGrammarPathsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e180">
            <div class="title e181"> Schemas and Grammar Paths</div>
            <div class="para e182">
               In this paper, we consider schema-oriented XML documents which have to follow the
               grammar rules specified by an associated schema, rather than schema-less documents
               which merely have to be well-formed according to the XML language specification [
               <div class="xref e183" linkend="mul111"></div>]. A commonly used grammar description is XML Schema [
               <div class="xref e184" linkend="mul113"></div>], which we also use in this paper. Throughout this paper, by L
               <div class="subscript e185">Σ</div> we denote the language generated by the schema Σ. Specifically, if Σ is the schema
               of schemas, i.e. the grammar defining schemas, then L
               <div class="subscript e186">Σ</div> is the language of all schemas, and for S∈L
               <div class="subscript e187">Σ</div>, a document D is valid for S iff  D∈L
               <div class="subscript e188">S</div>. We consider only schemas for which there are no anonymous types (we can do it without
               a loss of generality because a schema with anonymous types can always have these types
               replaced by named types.) In the current implementation, we consider only schema with
               no cycles. By the top-level typename of the schema S, we mean the typename of the
               root element of any document valid in S. With each schema, we will associate a schema
               graph. The following examples show two schema and the corresponding graphs. 
            </div>
            <div class="para e189" xml:id="Ex3.3" xreflabel="Example 3.3">
               
               <div class="emphasis e190" role="bold">Example 3.3. </div>
            </div>
            <div class="para e191">
               Consider a reference letter, which provides a specification as to whether or not the
               letter is confidential, names of a referee and an applicant, and zero, one or more
               reviews, where each review provides the name of a supervisor, a numeric score, and
               a comment. The schema T for such a reference letter is given below.
               
            </div>
            <div class="programlisting e192" xml:space="preserve">
               &lt;?xml version="1.0" encoding="UTF-8"?&gt;
               &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               	&lt;xs:element name="letter" type="LetterType"/&gt;
               	&lt;xs:complexType name="LetterType"&gt;
               		&lt;xs:sequence&gt;
               			&lt;xs:element name="referee" type="NameType"/&gt;
               			&lt;xs:element name="applicant" type="NameType"/&gt;
               			&lt;xs:element name="review" type="ReviewType"/&gt;
               		&lt;/xs:sequence&gt;
               		&lt;xs:attribute name="confidential" type="xs:boolean"/&gt;
               	&lt;/xs:complexType&gt;
               	&lt;xs:complexType name="ReviewType" maxOccurs="unbounded"&gt;
               		&lt;xs:sequence&gt;
               			&lt;xs:element name="supervisorName" type="NameType"/&gt;
               		&lt;/xs:sequence&gt;
               		&lt;xs:attribute name="score" type="xs:integer"/&gt;
               		&lt;xs:attribute name="comments" type="xs:string"/&gt;
               	&lt;/xs:complexType&gt;
               	&lt;xs:complexType name="NameType"&gt;
               		&lt;xs:sequence&gt;
               			&lt;xs:element name="first" type="xs:string"/&gt;
               			&lt;xs:element name="last" type="xs:string"/&gt;
               		&lt;/xs:sequence&gt;
               	&lt;/xs:complexType&gt;
               &lt;/xs:schema&gt;
               
            </div>
            <div class="para e193">
               Schema graph for the Schema T (see 
               <div class="xref e194" linkend="fig2"></div>) replicates nodes that represent elements of the same type. This graph shows 
               <div class="emphasis e195" role="ital">types</div> used in the schema. The alternative representation, used by this paper, (see 
               <div class="xref e196" linkend="fig3"></div>) will focus on 
               <div class="emphasis e197" role="ital">element names</div> from the schema, and will 
               <div class="emphasis e198" role="ital">optionally</div> show types of these elements (shown in dotted boxes with gray background). 
            </div>
            <div class="figure e199" floatstyle="1" xml:id="fig2" xreflabel="Figure 2">
               <div class="mediaobject e200">
                  <div class="imageobject e201">
                     <div class="metaBox e202"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e425').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e425" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e202'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-002.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='100%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e203">
                     <div class="para e204"> Schema graph for schema T (based on types) </div>
                  </div>
               </div>
            </div>
            <div class="figure e205" floatstyle="1" xml:id="fig3" xreflabel="Figure 3">
               <div class="mediaobject e206">
                  <div class="imageobject e207">
                     <div class="metaBox e208"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e432').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e432" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e208'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-003.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='100%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e209">
                     <div class="para e210"> Schema graph for schema T (based on element names)</div>
                  </div>
               </div>
            </div>
            <div class="para e211" xml:id="Ex3.4" xreflabel="Example 3.4">
               
               <div class="emphasis e212" role="bold">Example 3.4. </div>
            </div>
            <div class="para e213">
               The schema S (see the schema graph in 
               <div class="xref e214" linkend="fig4"></div>) is a schema for which the document D from [
               <div class="xref e215" linkend="Ex3.1"></div>] valid. 
            </div>
            <div class="programlisting e216" xml:space="preserve">
               &lt;?xml version="1.0" encoding="UTF-8"?&gt;
               &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
               	&lt;xs:element name="hospital" type="HospitalType"/&gt;
               	&lt;xs:complexType name="HospitalType"&gt;
               		&lt;xs:sequence&gt;
               			&lt;xs:element name="patient" type="PatientType" maxOccurs="unbounded"/&gt;
               		&lt;/xs:sequence&gt;
               	&lt;/xs:complexType&gt;
               	&lt;xs:complexType name="PatientType"&gt;
               		&lt;xs:sequence&gt;
               			&lt;xs:element name="basic" type="xs:string"/&gt;
               			&lt;xs:element name="confidential" type="xs:string"/&gt;
               			&lt;xs:element name="veryConfidential" type="xs:string"/&gt;
               		&lt;/xs:sequence&gt;
               		&lt;xs:attribute name="name" type="xs:string"/&gt;
               		&lt;xs:attribute name="Id" type="xs:int"/&gt;
               		&lt;xs:attribute name="perm" type="xs:boolean"/&gt;
               	&lt;/xs:complexType&gt;
               &lt;/xs:schema&gt;
               
            </div>
            <div class="figure e217" floatstyle="1" xml:id="fig4" xreflabel="Figure 4">
               <div class="mediaobject e218">
                  <div class="imageobject e219">
                     <div class="metaBox e220"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e452').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e452" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e220'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-004.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='100%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e221">
                     <div class="para e222"> Schema graph for schema S</div>
                  </div>
               </div>
            </div>
            <div class="para e223">
               In Section 3.1, we defined views of XML documents using document paths. To define
               views of a schema S, we introduce 
               <div class="emphasis e224" role="ital">grammar paths</div>. For a document D valid in S, a grammar path may be 
               <div class="emphasis e225" role="ital">materialized</div> to produce the document path for D. This way, views of a schema determine views of
               documents valid in the schema. Here, we consider only absolute paths, but relative
               paths can be defined in the same way. We denote by Π
               <div class="subscript e226">S</div> the set of all grammar paths for the schema S.  A triple (schema S, grammar path
               G, document D valid in S) defines a document path denoted by Π
               <div class="subscript e227">S,D</div>(G); we refer to this process as a grammar path materialization. 
            </div>
            <div class="para e228">We start by defining an 
               <div class="emphasis e229" role="ital">atomic grammar path</div>, which is of the form /c
               <div class="subscript e230">1</div>/c
               <div class="subscript e231">2</div>/.../c
               <div class="subscript e232">n</div>. Each c
               <div class="subscript e233">i</div> is a tag name optionally followed by a predicate in square brackets. (If the predicate
               is present, then c
               <div class="subscript e234">i</div> is called the current context node.)  A 
               <div class="emphasis e235" role="ital">predicate</div> is formed using standard Boolean operators: &amp;&amp;, ||, and ! (using standard associativity
               and precedence rules) and atomic predicates. There are three kinds of atomic predicates:
               
            </div>
            <div class="itemizedlist e236">
               <div class="listitem e237">
                  <div class="para e238">equality and inequality comparisons for values of attributes of type string or Boolean
                     
                  </div>
               </div>
               <div class="listitem e239">
                  <div class="para e240">equality and inequality comparisons for the textual content of the current context
                     node, specified using text()
                     
                  </div>
               </div>
               <div class="listitem e241">
                  <div class="para e242">arbitrary comparisons for values of numerical attributes
                     
                  </div>
               </div>
            </div>
            <div class="para e243">Note that if content of the element is 
               <div class="emphasis e244" role="ital">mixed</div>, i.e. contains both textual content and sub-elements then text() denotes the concatenation
               of all textual contents of this element. 
            </div>
            <div class="para e245">
               In order to support nested conditions, atomic predicates may also be preceded by one
               of the following unconditional paths, where the i-th component b
               <div class="subscript e246">i</div> is a tag name: 
            </div>
            <div class="itemizedlist e247">
               <div class="listitem e248">
                  <div class="para e249"> /b
                     <div class="subscript e250">1</div>/b
                     <div class="subscript e251">2</div>/.../b
                     <div class="subscript e252">n</div>/; i.e. the absolute path 
                  </div>
               </div>
               <div class="listitem e253">
                  <div class="para e254"> b
                     <div class="subscript e255">1</div>/b
                     <div class="subscript e256">2</div>/.../b
                     <div class="subscript e257">n</div>/; i.e. the relative path that starts from the current context node
                     
                  </div>
               </div>
               <div class="listitem e258">
                  <div class="para e259"> ../b
                     <div class="subscript e260">1</div>/b
                     <div class="subscript e261">2</div>/.../b
                     <div class="subscript e262">n</div>/; i.e. the relative path that starts from the parent of the current context node
                     
                  </div>
               </div>
            </div>
            <div class="para e263">
               Two examples of atomic grammar paths are:
               
               <div class="programlisting e264" xml:space="preserve">
                  	/H[@x &gt; "1" || @x &lt; "0" &amp;&amp;  @y = "0"]/P[text() = "John"]
                  	/H/B[../C/@z &gt; "2" || /H/D/text() = "Mary"]/E
                  
               </div>
               
            </div>
            <div class="para e265">
               Atomic paths may have conditions involving nested paths, but they specify only a single
               node. Often it is convenient to specify subtrees, or parts thereof. Therefore, we
               define a simple grammar path, which is an atomic grammar path followed by a subtree
               operator of the form: 
            </div>
            <div class="para e266">
               
               <div class="programlisting e267" xml:space="preserve">
                  &lt;text = O3; att = O3; tag = O3&gt;
                  
               </div>
               
            </div>
            <div class="para e268">
               where
            </div>
            <div class="para e269">
               
               <div class="itemizedlist e270">
                  <div class="listitem e271">
                     <div class="para e272">all fields (text, att, and tag) may appear in any order (and are separated by ";")
                        
                     </div>
                  </div>
                  <div class="listitem e273">
                     <div class="para e274">fields are optional, but at least one must be present </div>
                  </div>
                  <div class="listitem e275">
                     <div class="para e276">O3 is described below by the following regular expression  </div>
                     <div class="para e277">O1=["*" "+"]; i.e. a character class consisting of * and +</div>
                     <div class="para e278">O2 = (O1 | ".") | ("text" (O1?)); i.e. O1 or "." or "text" optionally followed by
                        O1
                     </div>
                     <div class="para e279">O3 = O2 (","O2)*; ie. one or more O2, separated by";"</div>
                  </div>
               </div>
               
            </div>
            <div class="para e280">The meaning of subtree operators is explained in [
               <div class="xref e281" linkend="Ex3.5"></div>]. Finally, a 
               <div class="emphasis e282" role="ital">grammar path</div> is an atomic grammar path, or a simple grammar path, or one or more alternatives
               of such paths. 
            </div>
            <div class="para e283">For a given schema, a grammar path is valid if it satisfies constraints imposed by
               the Schema, for example that an element name exists (in the given context), or the
               attribute value is a correct data type. 
            </div>
            <div class="para e284" xml:id="Ex3.5" xreflabel="Example 3.5">
               
               <div class="emphasis e285" role="bold">Example 3.5. </div>
            </div>
            <div class="para e286"> Below, we use the following terminology: </div>
            <div class="itemizedlist e287">
               <div class="listitem e288">
                  <div class="para e289"> all descendants of c, meaning all descendants of c, including c; </div>
               </div>
               <div class="listitem e290">
                  <div class="para e291"> all proper descendants of c, meaning all descendants of c, excluding c; </div>
               </div>
               <div class="listitem e292">
                  <div class="para e293"> children of c, meaning only children of c and not grand-children, etc.
                     
                  </div>
               </div>
            </div>
            <div class="para e294">In all examples given below c is the last component of a simple grammar path: </div>
            <div class="programlisting e295" xml:space="preserve">
               All text descendants of c:					c&lt;text=*&gt;
               All proper text descendants of c:				c&lt;text=+&gt;
               Text child of c (concatenated for mixed content):		c&lt;text=.&gt;
               All text descendants of c that are equal to "the":		c&lt;text="the"*&gt;
               All proper text descendants of c that are equal to "the":	c&lt;text="the"+&gt;
               Concatenated text children of c that is equal to "the":	c&lt;text="the"&gt;
               All attribute descendants of c:				c&lt;att=*&gt;
               All proper attribute descendants of c:			c&lt;att=+&gt;
               All attribute children (attributes) of c:			c&lt;at =.&gt;
               A specific attribute foo of c:				c&lt;att="foo"&gt;
               All "foo" attribute descendants of c:				c&lt;att="foo"*&gt;
               All proper "foo" attribute descendants of c:			c&lt;att="foo"+&gt;
               The tag of c:							c&lt;tag="."&gt; or c
               All element descendants of c:					c&lt;tag=*&gt;
               All proper element descendants of c:				c&lt;tag=+&gt;
               All element children (sub-elements) of c:			c&lt;tag=.&gt;
               A specific tag foo of c:					c&lt;tag = "foo"&gt;
               All element descendants called "foo" of c:			c&lt;tag="foo"*&gt;
               All proper element descendants called "foo" of c:		c&lt;tag="foo"+&gt;
               All descendants of c:						c&lt;*&gt;
               All proper descendants f c					c&lt;+&gt;
               All children of c						c&lt;.&gt;
               Finally, some examples of combined fields:
               All proper text descendants of c and all attributes of c:	c&lt;text=*; att =*&gt;
               Attributes foo and goo of c and the tag of c:			c&lt;att = "foo", "goo"; tag =.&gt;
               All element descendants "foo" and "goo" of c, all "hoo" attribute decendants, and
               the text of c:
               c&lt;tag="foo"*, "goo"*; att="hoo"*; text=.&gt; □
               
            </div>
            <div class="para e296" xml:id="Ex3.6" xreflabel="Example 3.6">
               
               <div class="emphasis e297" role="bold">Example 3.6. </div>
            </div>
            <div class="para e298">
               Below, we provide three grammar paths R, C, and N for the schema T from [
               <div class="xref e299" linkend="Ex3.3"></div>]: 
            </div>
            <div class="para e300">
               
               <div class="programlisting e301" xml:space="preserve">
                  	R: /letter[review/score/text() &gt; "7"]/referee/last&lt;text=.&gt;
                  	C: /letter[!(/referee/last/text() = "Smith" ||
                  /referee/last/text() = "Kerry")]&lt;att="comments", "score"&gt;
                  	N: /letter[@confidential = "false"]/{referee, applicant, review/supervisor}&lt;text=+&gt;
                  |
                  /letter[@confidential = "true" &amp;&amp; review/score/text() &gt; "5"
                  || applicant/last/text() = "Brown"]/review/supervisor&lt;text=+&gt;
                  
               </div>
               □
               
            </div><a name="SchemalevelAccessControlPoliciesSRBAC%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e302">
               <div class="title e303"> Schema-level Access Control Policies, SRBAC
                  
               </div>
               <div class="para e304">
                  In this section we define schema-level RBAC, SRBAC and the related protection requirement.
                  
               </div>
               <div class="para e305">
                  
                  <div class="emphasis e306" role="bold">Definition 3.3. </div> 
               </div>
               <div class="para e307">
                  For a schema S, and a set Ψ of roles, an SRBAC policy is a mapping π
                  <div class="subscript e308">S</div>:Ψ→Π
                  <div class="subscript e309">S</div>.□
                  
               </div>
               <div class="para e310" xml:id="Ex3.7" xreflabel="Example 3.7">
                  
                  <div class="emphasis e311" role="bold">Example 3.7. </div>
               </div>
               <div class="para e312">
                  For the schema T from [
                  <div class="xref e313" linkend="Ex3.3"></div>] we define the SRBAC policy π
                  <div class="subscript e314">T</div>: [(REFEREE, R), (COMMENT, C), (NAME, N)], where R, C and N are grammar paths from
                  [
                  <div class="xref e315" linkend="Ex3.6"></div>]. Here: 
               </div>
               <div class="itemizedlist e316">
                  <div class="listitem e317">
                     <div class="para e318"> role REFEREE gives access to last names of referees for reviews with the score greater
                        than 7
                     </div>
                  </div>
                  <div class="listitem e319">
                     <div class="para e320"> role COMMENT gives access to all comments and scores, provided that the referee last
                        name is neither Smith nor Kerry 
                     </div>
                  </div>
                  <div class="listitem e321">
                     <div class="para e322"> role NAME gives access to all names for non-confidential letters and for supervisor
                        names provided that the letter is confidential and the score is greater than 5, or
                        last name of the applicant is Brown
                     </div>
                  </div>
               </div>
               <div class="para e323" xml:id="Ex3.8" xreflabel="Example 3.8">
                  
                  <div class="emphasis e324" role="bold">Example 3.8.  </div>
               </div>
               <div class="para e325">
                  For the schema S from [
                  <div class="xref e326" linkend="Ex3.4"></div>], we define the SRBAC policy π
                  <div class="subscript e327">S</div>: [(Nurse, N), (Physician, P), (Resident, R), (Smith, S)], where roles N, P, R, and
                  S are defined as follows: 
               </div>
               <div class="programlisting e328" xml:space="preserve">
                  	#define HP	/hospital/patient
                  	#define HPN	$HP&lt;att="Id"&gt;
                  	#define SS  	$HP[@name="Smith"]
                  	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
                  	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
                  	R: $HPN | $HP{/confidential&lt;text=.&gt;, [@Id&gt;"100" &amp;&amp;
                  		@perm="true"]/veryConfidential&lt;text=.&gt; }
                  	S: $SS/{@perm, basic&lt;text=.&gt;, confidential&lt;text=.&gt;, veryConfidential&lt;text=.&gt;}
                  
               </div>
               <div class="para e329">
                  The above SRBAC policy gives the patient Smith access to her data. Existence of multiple
                  patients who should have this kind of access will result in role proliferation. A
                  solution to this problem is to use parameterized roles, and this is the subject of
                  our current research, see [
                  <div class="xref e330" linkend="mul109"></div>]. 
               </div>
               <div class="para e331">
                  For every document valid in the schema S, a schema-based ACP defines document-based
                  ACP for this document
               </div>
               <div class="para e332">
                  
                  <div class="emphasis e333" role="bold">Definition 3.4. </div>
               </div>
               <div class="para e334">
                  For an XML Schema S, instance document D∈L
                  <div class="subscript e335">S</div>, and the schema-based policy π
                  <div class="subscript e336">S</div>:Ψ→Π
                  <div class="subscript e337">S</div>, we define the schema-induced document policy π
                  <div class="subscript e338">S,D</div>:Ψ→P
                  <div class="subscript e339">D</div>,  by materializing grammar paths; i.e. π
                  <div class="subscript e340">S,D</div>(R)= Π
                  <div class="subscript e341">S,D</div>(π
                  <div class="subscript e342">S</div>(R)), for R∈Ψ.□
               </div>
               <div class="para e343">
                  Now, we formulate the schema-level protection requirement in a manner similar to that
                  from Def. 3.2: 
               </div>
               <div class="para e344">
                  
                  <div class="emphasis e345" role="bold">Definition 3.5. </div> 
               </div>
               <div class="para e346">
                  The 
                  <div class="emphasis e347" role="ital">schema-level protection requirement</div> is said to be satisfied under the following conditions. For the schema S, the schema-based
                  ACP π
                  <div class="subscript e348">S</div>:Ψ→Π
                  <div class="subscript e349">S</div> and role R∈Ψ, the user in a role R accessing a document D∈L
                  <div class="subscript e350">S</div>, can read precisely the view π
                  <div class="subscript e351">S,D</div>(R).   □
                  
               </div>
               <div class="para e352">
                  
                  <div class="emphasis e353" role="bold">Example 3.9. </div>
               </div>
               <div class="para e354">
                  For any document D valid in the schema S from [
                  <div class="xref e355" linkend="Ex3.4"></div>], grammar paths from [
                  <div class="xref e356" linkend="Ex3.8"></div>] will be materialized as follows: 
               </div>
               <div class="para e357">
                  
                  <div class="itemizedlist e358">
                     <div class="listitem e359">
                        <div class="para e360">Π
                           <div class="subscript e361">S,D</div>(N) consists of Ids of all patients, and the textual content of the basic test for
                           patients whose Id is negative 
                        </div>
                     </div>
                     <div class="listitem e362">
                        <div class="para e363"> Π
                           <div class="subscript e364">S,D</div>(P)consists of Ids and names of all patients, and the textual content of the basic,
                           confidential and very confidential tests 
                        </div>
                     </div>
                     <div class="listitem e365">
                        <div class="para e366">Π
                           <div class="subscript e367">S,D</div>(R) consists of Ids of all patients, and the textual content of the very confidential
                           test for patients whose Id is greater than 100 and perm is set to true
                           
                        </div>
                     </div>
                     <div class="listitem e368">
                        <div class="para e369"> Π
                           <div class="subscript e370">S,D</div>(S) gives access to permissions, and the textual content of the basic, confidential
                           and very confidential test for these patients whose name is Smith.
                           
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e371">
                  For the specific document D from [
                  <div class="xref e372" linkend="Ex3.1"></div>], these materializations will produce respectively paths ND, PD, RD and SD from [
                  <div class="xref e373" linkend="Ex3.2"></div>], and so for the policy π
                  <div class="subscript e374">S</div> from [
                  <div class="xref e375" linkend="Ex3.4"></div>], the induced policy π
                  <div class="subscript e376">S,D</div> is the policy π
                  <div class="subscript e377">D</div> from [
                  <div class="xref e378" linkend="Ex3.2"></div>]. □
                  
               </div>
            </div>
         </div>
      </div><a name="KeyGenerationandDocumentEncryption%0AANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e379">
         <div class="title e380">Key Generation and Document Encryption
            
         </div>
         <div class="para e381">
            In this section, we describe key generation at the schema level, and also explain
            how these keys are used to encrypt documents valid in this schema. As we indicated
            in the introduction, actions that result in key generation at the schema level may
            afford less efficient processing because they are performed only once, before any
            document is to be encrypted. In addition, a typical schema definition (and therefore,
            its schema graph) is quite small; hence, we assume that that the schema graph is stored
            as a DOM tree in main memory. However, for multi-encrypting documents (which may be
            very large), we will only consider single pass, SAX-based parsing. In our approach,
            we generate keys at the schema level. However, one can also use a 
            <div class="emphasis e382" role="ital">lazy key generation</div>: instead of pre-generating keys at the schema level, key generation will be triggered
            by the first document to be multi-encrypted. This would generate only the schema-based
            keys required for multi-encrypting this specific document (and they will be properly
            recorded). When the subsequent document is to be multi-encrypted, first we would determine
            if all necessary keys (at the schema level) have already been generated, and only
            generate any missing keys (at again recorded). 
         </div>
         <div class="para e383">
            We start this section with basic definitions.
            Then, we provide our most important result, which is a schema-based key generation
            algorithm,
            and we define schema-based role-accessible keyrings.
            Next, we describe an annotated schema and proceed to the second most important algorithm
            which uses an annotated schema to efficiently multi-encrypt a document valid in this
            schema.
            Our description will frequently refer to the schema S from [
            <div class="xref e384" linkend="Ex3.4"></div>]
            (which we will call a "running example"), its graph (see 
            <div class="xref e385" linkend="fig4"></div>), and grammar paths from [
            <div class="xref e386" linkend="Ex3.8"></div>].
         </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e387">
            <div class="title e388">Introduction</div><a name="EncryptionandKeyringsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e389">
               <div class="title e390"> Encryption and Keyrings </div>
               <div class="para e391">
                  There are two kinds of encryption: symmetric encryption, which uses a shared secret
                  key, and asymmetric encryption, which uses a public-private key pair. For asymmetric
                  encryption, we will call the public key part a 
                  <div class="emphasis e392" role="ital">decrypting key</div>, and the private key part an 
                  <div class="emphasis e393" role="ital">encrypting key</div>. If it does not lead to confusion, then by a key we mean a decrypting key in an asymmetric
                  encryption and a key in a symmetric encryption. In our approach, we allow either kind
                  of encryption. When asymmetric encryption is used, the user in role R can only decrypt
                  the document fragment. But, with symmetric encryption, they can also encrypt the decrypted
                  m-document. To avoid this problem, the digital signature of the m-document would have
                  to be made available.
                  
               </div>
               <div class="para e394"> 
                  <div class="emphasis e395" role="bold">Definition 4.1. </div>
                  
               </div>
               <div class="para e396">
                  A keyring K is a finite set of keys. For an asymmetric encryption, each key is a triple
                  (key name, encrypting key, decrypting key), and for a symmetric encryption it is a
                  pair (key name, key). By K
                  <div class="subscript e397">S</div> we denote a schema-level keyring for the schema S and its policy π
                  <div class="subscript e398">S</div>. □
               </div>
            </div><a name="BasicNotationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e399">
               <div class="title e400"> Basic Notations </div>
               <div class="para e401">
                  Let us first consider various ways keys may be assigned to documents.
                  Since views may be overlapping, we can not assign keys per view.
                  Indeed, if we did so, then for two overlapping views V
                  <div class="subscript e402">1</div> and V
                  <div class="subscript e403">2</div> we would have two corresponding keys k
                  <div class="subscript e404">1</div> and k
                  <div class="subscript e405">2</div>, and the intersection of the two views would have to be super-encrypted (assigning
                  keys per view would mean that for i=1,2, the user who has access to the view V
                  <div class="subscript e406">i</div> would be given a key k
                  <div class="subscript e407">i</div> and so other options such as encrypting V
                  <div class="subscript e408">1</div> with one key and V
                  <div class="subscript e409">2</div>-V
                  <div class="subscript e410">1</div> with the other key would provide access to the part that is not allowed). What we
                  need to do is to partition the set D (and at the same time each view) into disjoint
                  sets, and then assign one key for each set in this partition. Therefore, for an arbitrary
                  partition {P
                  <div class="subscript e411">1</div>, P
                  <div class="subscript e412">2</div>,...,P
                  <div class="subscript e413">n</div>} of a set D, we need to find a 
                  <div class="emphasis e414" role="ital">disjoint partition</div>. One way to achieve this goal is to create all possible differences of intersections
                  of sets in the partition and remaining unions. Note that in our paper by a 
                  <div class="emphasis e415" role="ital">partition</div> we mean a family of subsets of a set D that does not necessarily cover D. 
               </div>
               <div class="para e416">
                  Here, we work at the schema level, rather than at the document level, but we need
                  to generate keys in such a way that 
                  <div class="emphasis e417" role="ital">materialized grammar paths</div> are disjoint. Since set operations for grammar paths (such as a union) are not defined,
                  we now introduce symbolic grammar paths that allow such operations: 
               </div>
               <div class="para e418">
                  <div class="emphasis e419" role="bold">Definition 4.2. </div> 
               </div>
               <div class="para e420">
                  Consider a set {P
                  <div class="subscript e421">i</div>: i=1,2,...,k} of grammar paths. By a 
                  <div class="emphasis e422" role="ital">symbolic grammar path expression</div> we denote a finite set of string of the form:
                  
                  <div class="figure e423" floatstyle="1" xml:id="eq42" xreflabel="eq42">
                     <div class="mediaobject e424">
                        <div class="imageobject e425">
                           <div class="metaBox e426"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e914').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e914" class="metaSource" style="display:none;">                
                                 &lt;imagedata<span class="metaAttribute">class='e426'
                                    </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-005.png'
                                    </span><span class="metaAttribute">format='png'
                                    </span><span class="metaAttribute">width='100%'
                                    </span>
                                 &gt;
                                 
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
                  
                  
               </div>
               <div class="para e427">
                  Since document paths support the above mentioned set operations, symbolic grammar
                  paths can be materialized. 
               </div>
               <div class="para e428">
                  
                  <div class="emphasis e429" role="bold">Definition 4.3. </div>
               </div>
               <div class="para e430">
                  
                  <div class="figure e431" floatstyle="1" xml:id="eq43" xreflabel="eq43">
                     <div class="mediaobject e432">
                        <div class="imageobject e433">
                           <div class="metaBox e434"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e927').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e927" class="metaSource" style="display:none;">                
                                 &lt;imagedata<span class="metaAttribute">class='e434'
                                    </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-006.png'
                                    </span><span class="metaAttribute">format='png'
                                    </span><span class="metaAttribute">width='100%'
                                    </span>
                                 &gt;
                                 
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>□
                  
               </div>
               <div class="para e435" xml:id="Ex4.1" xreflabel="Example 4.1">
                  
                  <div class="emphasis e436" role="bold">Example 4.1. </div> 
               </div>
               <div class="para e437">
                  Consider first two grammar paths from [
                  <div class="xref e438" linkend="Ex3.8"></div>], and recalled below: 
               </div>
               <div class="programlisting e439" xml:space="preserve">
                  	#define HP	/hospital/patient
                  	#define HPN	$HP&lt;att="Id"&gt;
                  	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
                  	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
                  
               </div>
               <div class="para e440">
                  Here, we have three symbolic grammar paths: N-P, P-N and N*P. To show materializations
                  of the paths, consider the document D valid in S (see 
                  <div class="xref e441" linkend="fig1"></div>. For this document, we have: 
               </div>
               <div class="figure e442" floatstyle="1" xml:id="eq44" xreflabel="eq44">
                  <div class="mediaobject e443">
                     <div class="imageobject e444">
                        <div class="metaBox e445"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e948').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e948" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e445'
                                 </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-007.png'
                                 </span><span class="metaAttribute">format='png'
                                 </span><span class="metaAttribute">width='100%'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e446">Note that the above materializations cover the same subset of D as materializations
                  of original grammar paths, but unlike the original grammar paths, they are disjoint.
                  □
               </div>
            </div>
         </div><a name="KeyGenerationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e447">
            <div class="title e448">Key Generation </div>
            <div class="para e449">
               To generate keys for the schema S one can use the following technique. For every symbolic
               grammar path, generate a key for that path, and then use these keys to multi-encrypt
               materializations of document valid in S. However, by following this approach, we would
               not avoid generating keys for symbolic grammar paths that will always be materialized
               to 
               <div class="emphasis e450" role="ital">empty document paths</div>. Therefore, we use a different approach, described below. 
            </div>
            <div class="para e451">
               A 
               <div class="emphasis e452" role="ital">target</div> of a grammar path G is a single node in SG, or a node and a subgraph rooted at the
               node. An 
               <div class="emphasis e453" role="ital">abstract value</div> of G is a list of targets with the associated information about values of conditions
               that appear in G. Our algorithm finds abstract values of symbolic grammar paths corresponding
               to grammar paths in the SRBAC policy. We then use these values to avoid generating
               keys for these symbolic grammar paths whose abstract values are empty. Note that our
               algorithm additionally avoids creating redundant keys for two or more grammar paths
               whose abstract values are subsets; for example if the abstract value of G
               <div class="subscript e454">1</div> is a subset of the abstract value of G
               <div class="subscript e455">2</div> then the symbolic grammar path G
               <div class="subscript e456">1</div> - G
               <div class="subscript e457">2</div> evaluates to empty. Since at the schema level we 
               <div class="emphasis e458" role="ital">do not know values of conditions</div> that appear in grammar paths, we proceed as follows. By a 
               <div class="emphasis e459" role="ital">configuration</div> we refer to a bit-vector that represents true/false values of all conditions that
               appear in symbolic grammar paths (i.e., if the i-th condition evaluates to true, the
               i-th bit is set to 1, and 0 otherwise). We annotate every node of the schema graph
               with the list of pairs of the form (configurations, key).
               
            </div>
         </div><a name="ConfigurationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e460">
            <div class="title e461">Configurations</div>
            <div class="para e462">
               A 
               <div class="emphasis e463" role="ital">configuration</div> is a binary value of size k that represents true/false values of conditions. For
               a given grammar path X and a configuration C, values of all conditions in X are known,
               and therefore we can find an abstract value of X, which consists of one or more targets
               for the configuration C. A 
               <div class="emphasis e464" role="ital">configuration index value</div> is the integer decimal value corresponding to the binary value of this configuration.
               When it does not lead to confusion, we identify a configuration and its index value.
               Some configurations should be 
               <div class="emphasis e465" role="ital">excluded</div> e.g. if they specify true values for two conditions (involving the same attribute)
               that cannot be true at the same time (and arbitrary values for other conditions).
               
            </div>
            <div class="para e466">
               
               <div class="emphasis e467" role="bold">Algorithm 4.1</div>
            </div>
            <div class="para e468">
               A 
               <div class="emphasis e469" role="ital">condition</div> (with k variables) is a Boolean Expression B(x
               <div class="subscript e470">1</div>,x
               <div class="subscript e471">2</div>,...,x
               <div class="subscript e472">k</div>) built from comparisons of the form: 
            </div>
            <div class="para e473">
               x
               <div class="subscript e474">i</div> RelationalOperator c; where x
               <div class="subscript e475">i</div> and a constant c are of the same data type that supports
               linear order (such as real or integer) and three standard Boolean operators: and,
               or and not,
               with the standard associativity and precedence rules, and brackets, and a RelationalOperator
               is one of: &gt;, &lt;, &lt;=, &gt;=, =, !=.
               For example, the expression B(x,y): x&gt;"0" &amp;&amp; y&gt;"100" || x&gt;="4" &amp;&amp; !(x="99") is a condition.
               
            </div>
            <div class="para e476">
               For given conditions B
               <div class="subscript e477">1</div>,...,B
               <div class="subscript e478">k</div> with k variables x
               <div class="subscript e479">1</div>,x
               <div class="subscript e480">2</div>,...,x
               <div class="subscript e481">k</div>, Algorithm 4.1 
               <div class="emphasis e482" role="ital">tests</div> if for any subset
               (i
               <div class="subscript e483">1</div>,...,i
               <div class="subscript e484">m</div>) with 0&lt;=m&lt;=k of the set (1,...,n)
               the expression of the form D(x
               <div class="subscript e485">1</div>,x
               <div class="subscript e486">2</div>,...,x
               <div class="subscript e487">k</div>) =
               B
               <div class="subscript e488">i
                  <div class="subscript e489">1</div>
               </div>&amp;&amp;B
               <div class="subscript e490">i
                  <div class="subscript e491">2</div>
               </div>&amp;&amp;...&amp;&amp;B
               <div class="subscript e492">i
                  <div class="subscript e493">m</div>
               </div>&amp;&amp;!B
               <div class="subscript e494">j
                  <div class="subscript e495">1</div>
               </div>&amp;&amp;!B
               <div class="subscript e496">j
                  <div class="subscript e497">2</div>
               </div>&amp;&amp;...&amp;&amp;!B
               <div class="subscript e498">j
                  <div class="subscript e499">r</div>
               </div> where {j
               <div class="subscript e500">1</div>,j
               <div class="subscript e501">2</div>,...,j
               <div class="subscript e502">r</div>} = {1,2,...,k} - {i
               <div class="subscript e503">1</div>,i
               <div class="subscript e504">2</div>,...,i
               <div class="subscript e505">m</div>}, is a 
               <div class="emphasis e506" role="ital">falsehood</div>; i.e. is false for all variables x
               <div class="subscript e507">1</div>,x
               <div class="subscript e508">2</div>,...,x
               <div class="subscript e509">k</div>.
               
            </div>
         </div><a name="FindingabstractvaluesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e510">
            <div class="title e511"> Finding abstract values</div>
            <div class="para e512">
               An 
               <div class="emphasis e513" role="ital">abstract value</div> of a grammar path G is defined to be a list consisting of the pairs (target, list
               of configuration ids). If this list contains all non-excluded configurations, then
               it is omitted. 
            </div>
            <div class="para e514">
               
               <div class="emphasis e515" role="bold">Algorithm 4.2. </div>
            </div>
            <div class="para e516">
               Input: A schema S, and an SRBAC policy π
               <div class="subscript e517">S</div>:Ψ→Π
               <div class="subscript e518">S</div>, where Π
               <div class="subscript e519">S</div> ={G 
               <div class="subscript e520">i</div>: i=1,2,...,n} is a set of grammar paths, and role R
               <div class="subscript e521">i</div> is associated with the path G
               <div class="subscript e522">i</div>. 
            </div>
            <div class="para e523">
               Output: A table called Results storing abstract values of symbolic grammar paths.
               
            </div>
            <div class="para e524">
               Outline of the algorithm. While here we say a "table", the actual implementation may
               use a different, more efficient data structure. However, in our explanation of the
               algorithm, we will assume that the table is used.
               There are two steps of the algorithm: 
            </div>
            <div class="itemizedlist e525">
               <div class="listitem e526">
                  <div class="para e527">Create a list E of all non-excluded conditions C that appear in grammar paths in the
                     policy, using Algorithm 4.1 
                  </div>
               </div>
               <div class="listitem e528">
                  <div class="para e529"> Compute abstract values of all grammar paths in the SRBAC. (In the description of
                     an abstract value, we skip the list of configuration ids if this list contains every
                     possible configuration.) Here, we compute symbolic products of pairs G
                     <div class="subscript e530">i</div>*G 
                     <div class="subscript e531">j</div> and sums G
                     <div class="subscript e532">i</div>+G 
                     <div class="subscript e533">j</div>, products and sums of triples, and so on; finally values of symbolic grammar paths.
                     In this process, maintain three tables storing respectively products, sums and resulting
                     grammar paths.
                     
                  </div>
               </div>
            </div>
            <div class="para e534">
               In more details, the table Products[i] stores an abstract value of products G
               <div class="subscript e535">i
                  <div class="subscript e536">1</div>
               </div>*...*G
               <div class="subscript e537">i
                  <div class="subscript e538">j</div>
               </div> where 1&lt;=i
               <div class="subscript e539">1</div>&lt;=...&lt;=i
               <div class="subscript e540">j</div>&lt;=n and 1&lt;=j&lt;=k.
               Here, the index i is a decimal value of the binary word of size k in which bits at
               positions i
               <div class="subscript e541">m</div> are set to 1 and remaining bits are set to 0. For example, for k=4, Products[5] stores
               an abstract value represented by 0101, i.e. of the product G
               <div class="subscript e542">2</div>*G
               <div class="subscript e543">4</div> and Result[5] will store the value of G
               <div class="subscript e544">2</div>*G
               <div class="subscript e545">4</div> − (G
               <div class="subscript e546">1</div>+G
               <div class="subscript e547">3</div>). 
            </div>
            <div class="para e548">
               Execution of step 2 involves: 
            </div>
            <div class="itemizedlist e549">
               <div class="listitem e550">
                  <div class="para e551">compute (and store in arrays Products and Sums) abstract values of all G
                     <div class="subscript e552">i</div>, then products (and sums) of two G
                     <div class="subscript e553">i</div>. If any product is empty then store in Products the value 0 (Empty) for any i-tuple
                     that uses this product. Also, store in Results 0 for symbolic grammar paths that use
                     such products. For example, if G
                     <div class="subscript e554">2</div>*G
                     <div class="subscript e555">4</div> is empty, store 0 in Products at positions 5, and 7 and in Results at the same positions.
                     Note that before any products are computed, we check if the value 0 has already been
                     stored for this product
                  </div>
               </div>
               <div class="listitem e556">
                  <div class="para e557"> repeat the above step for triples, etc. In computing unions, use previously computed
                     values; for example to compute G
                     <div class="subscript e558">1</div>+G
                     <div class="subscript e559">2</div>+G
                     <div class="subscript e560">4</div>, we use the value of G
                     <div class="subscript e561">1</div>+G
                     <div class="subscript e562">2</div> which has already been computed.
                     
                  </div>
               </div>
            </div>
            <div class="para e563" xml:id="Ex4.2" xreflabel="Example 4.2">
               
               <div class="emphasis e564" role="bold">Example 4.2. </div> 
            </div>
            <div class="para e565">
               In our running example, we have four conditions: 
            </div>
            <div class="para e566">
               C1: (@Id&lt;"0"), C2: (@Id&gt;"100"), C3: (@perm="true") and C4: (@name="Smith") 
            </div>
            <div class="para e567">
               and there are 16 configurations; starting with configuration 0, for which all conditions
               are false, and ending with configuration 15, for which all conditions are true. Now,
               consider configuration (1100) with the index value equal to 12. However, C1 and C2
               cannot be true at the same time, and so any configuration of the form 11xx is excluded.
               Therefore, the list of non-excluded configurations consists of integers from 0 to
               11, and an abstract value of the grammar path N is (Id, basic/text(), (9,10,11)).
               
            </div>
            <div class="para e568">
               Abstract values of all symbolic grammar paths are shown below (starting with abstract
               values of four paths), using the following abbreviations: 
            </div>
            <div class="itemizedlist e569">
               <div class="listitem e570">
                  <div class="para e571"> I : {1,3,5,9,11}</div>
               </div>
               <div class="listitem e572">
                  <div class="para e573"> B : basic/text()</div>
               </div>
               <div class="listitem e574">
                  <div class="para e575"> C : confidential/text()</div>
               </div>
               <div class="listitem e576">
                  <div class="para e577"> V : veryConfidential/text()</div>
               </div>
            </div>
            <div class="programlisting e578" xml:space="preserve">
               	{N} = &lt;Id, (B,8,9,10,11)&gt;
               	{P} = &lt;name,Id,B,C,V&gt;
               	{R} = &lt;Id, C, (V,6,7)&gt;
               	{S} = &lt;(B,I), (V,I), (C,I), (Perm,I)&gt;
               
               	Results[1] = S-(P+R+N) = (perm,I)
               	Results[2] = R-(N+P+S) = 0
               	Results[3] = R*S-(P+N) = 0
               	Results[4] = P-(N+R+S) = &lt;name,(B,0,2,4,6),(V,0,2,4,8,10)&gt;
               	Results[5] = P*S-(N+R) = &lt;(B,1,3,5,7),(V,I)&gt;
               	Results[6] = P*R-(N+S) = &lt;(C,0,2,4,6,8,10),(V,6)&gt;
               	Results[7] = P*R*S-N = &lt;(C,I), (V,7)&gt;
               	Results[8] = N-(P+R+S) = 0
               	Results[9] = N*S-(P+R) = 0
               	Results[10] = N*R-(P+S) = 0
               	Results[11] = N*P*R-S = 0
               	Results[12] = N*P-(R+S) = &lt;B,8,10&gt;
               	Results[13] = N*P*S-R = &lt;B,9,11&gt;
               	Results[14] = N*P*R-S= &lt;Id&gt;
               	Results[15] = N*P*R*S = 0
               
            </div>
         </div><a name="SchemabasedKeyringsandRoleaccessibleKeyringsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e579">
            <div class="title e580"> Schema-based Keyrings and Role-accessible Keyrings </div>
            <div class="para e581">
               For a schema S and a schema-level access control policy π
               <div class="subscript e582">S</div>:Ψ→Π
               <div class="subscript e583">S</div>, we use Algorithm 4.1, and for each non-empty value from the table Results, we generate
               one key. The keyring K
               <div class="subscript e584">S</div> consists of all keys generated this way. Note that in our running example, out of
               16 symbolic grammar paths, only 8 are non-empty. Therefore, where a brute-force approach
               would generate 16 keys for four roles for our running example, our optimized algorithm
               will instead generate only 8 keys. Now, we show how for each role R∈Ψ the keyring
               K
               <div class="subscript e585">S</div> defines the set K
               <div class="subscript e586">S</div>(R) of R-accessible keys. A user in role R will be provided with the R-accessible
               keys so that for any document D valid for S, she can decrypt the view π
               <div class="subscript e587">S,D</div>(R), where π
               <div class="subscript e588">S,D</div> is the schema-induced document policy. 
            </div>
            <div class="para e589">
               
               <div class="emphasis e590" role="bold">Algorithm 4.3. </div> 
            </div>
            <div class="para e591">
               Input: A schema S, a schema-level access control policy π
               <div class="subscript e592">S</div>:Ψ→Π
               <div class="subscript e593">S</div> and a role R∈Ψ.
               
            </div>
            <div class="para e594">
               Output: Role R-accessible keyring K
               <div class="subscript e595">S</div>(R). 
            </div>
            <div class="para e596">
               Method: K
               <div class="subscript e597">S</div>(R) = {k∈K
               <div class="subscript e598">S</div> for some symbolic grammar path G, the abstract value of {G} is a subset of the abstract
               value of the grammar path π
               <div class="subscript e599">S</div>(R)} □ 
            </div>
            <div class="para e600" xml:id="Ex4.3" xreflabel="Example 4.3">
               
               <div class="emphasis e601" role="bold">Example 4.3. </div>
            </div>
            <div class="para e602">
               For our running example, let us denote by ri a key corresponding to the value of Results[i]
               which is not empty. Therefore, K
               <div class="subscript e603">S</div>= {r1, r4, r5, r6, r7, r12, r13, r14}. Two examples of role-accessible keyrings are
               K
               <div class="subscript e604">S</div>(Nurse) ={r12, r13, r14}, and K
               <div class="subscript e605">S</div>(Physician) ={r4, r5, r6, r7, r12, r13, r14}.□ 
            </div>
            <div class="para e606">
               One can show that given a schema-level access control policy π
               <div class="subscript e607">S</div>:Ψ→Π
               <div class="subscript e608">S</div> and XML document D valid in S, if the user U in role R is provided only with R-accessible
               keys created by Algorithm 4.3 then the protection requirement is satisfied; in particular
               U can access precisely the view V = π
               <div class="subscript e609">S,D</div>(R). □
               
            </div>
         </div><a name="SchemaGraphAnnotationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e610">
            <div class="title e611"> Schema Graph Annotations </div>
            <div class="para e612">
               Based on the information stored in the table Results, we now annotate the syntax graph
               with a list of pairs
               (key, list of integers representing configuration index values).
               We use ♦ to denote a key for the default role; one of • or ♥.
               If the list consists of 
               <div class="emphasis e613" role="ital">all</div> permissible index values, then it is omitted.
               The annotated schema graph will be used to guide the process of multi-encrypting an
               XML document D during its
               SAX-based parsing. To annotate the schema graph, we traverse the table Results, and
               collect information about
               all keys. Next, we traverse the schema graph again, and if the annotation is missing
               at any node we add the
               annotation of the form (♦). For nodes that have already been annotated, we check if
               these annotations
               contain all permissible index values, if any such values are missing they are added
               with the default key ♦.
               
            </div>
            <div class="para e614" xml:id="Ex4.4" xreflabel="Example 4.4">
               
               <div class="emphasis e615" role="bold">Example 4.4. </div>
            </div>
            <div class="para e616">
               Consider our running example. To annotate the node "veryConfidential" in the schema
               graph, we look in Results[] for the value V, and so its annotation is &lt;(r4,0,2,4,8,10),
               (r5,I), (r6,6), (r7,7)&gt;.  For the complete annotated schema graph see 
               <div class="xref e617" linkend="fig5"></div>.
            </div>
            <div class="figure e618" floatstyle="1" xml:id="fig5" xreflabel="Figure 8">
               <div class="mediaobject e619">
                  <div class="imageobject e620">
                     <div class="metaBox e621"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1387').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1387" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e621'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-008.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='100%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e622">
                     <div class="para e623"> Annotated syntax graph for schema S </div>
                  </div>
               </div>
            </div>
         </div><a name="MultiencryptionofDocumentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e624">
            <div class="title e625"> Multi-encryption of Documents </div>
            <div class="para e626">
               The encryption of the document D valid in the Schema S results in single well-defined
               XML m-document MD, which always has a root element &lt;encrypteddocument&gt;. Each part
               of the document D that is encrypted with a key "k" will be represented as a child
               of the &lt;encrypteddocument&gt; node using this format: &lt;edata key = "k"&gt; 
               <div class="emphasis e627" role="ital">encrypted_data</div> &lt;/edata&gt;. Note that the structure of the document D is hidden inside of the 
               <div class="emphasis e628" role="ital">encrypted_data</div> part and is therefore not visible to users who are not authorized to decrypt the
               document (the &lt;edata&gt; tags are not nested inside of other &lt;edata&gt; tags). The encryption
               is performed by efficient, single-pass SAX parsing of D (performed in parallel with
               the traversal of the previously annotated schema graph GS). For each node d of D,
               the corresponding node s in GS is located, and its annotation is examined to determine
               which key should be used to encrypt this node (note that at that time we can determine
               values of all conditions and so we know which configuration should be used; unless
               nested conditions are used, which require additional treatment). Recall that the same
               key always encrypts the attribute and its value. 
            </div>
            <div class="para e629" xml:id="Ex4.5" xreflabel="Example 4.5">
               
               <div class="emphasis e630" role="bold">Example 4.5. </div>
            </div>
            <div class="para e631">
               Consider the document D from [
               <div class="xref e632" linkend="Ex3.1"></div>], (see 
               <div class="xref e633" linkend="fig6"></div>), in which dotted boxes attached to elements and attributes show the key that is
               used to encrypt this element. To explain the choice of keys, note that there are three
               patients; when the attributes of the first patient are processed, we know that that
               the name is not "Smith", Id is negative, and perm is true, and so the configuration
               10 is used. Similarly, configuration 9 is used for the second patient, and configuration
               6 for the third one. This information is used to retrieve the key to be used for encryption
               from the annotated schema graph. 
            </div>
            <div class="figure e634" floatstyle="1" xml:id="fig6" xreflabel="Figure 9">
               <div class="mediaobject e635">
                  <div class="imageobject e636">
                     <div class="metaBox e637"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e1415').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e1415" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e637'
                              </span><span class="metaAttribute">fileref='../../../vol1/graphics/Muldner01/Muldner01-009.png'
                              </span><span class="metaAttribute">format='png'
                              </span><span class="metaAttribute">width='100%'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
                  <div class="caption e638">
                     <div class="para e639"> Document D and keys used to encrypt this document.</div>
                  </div>
               </div>
            </div>
            <div class="para e640">
               The m-document M
               <div class="subscript e641">D</div> looks like this (assuming that by default ♦ indicates that the node is not available
               to any user, so the corresponding &lt;edata&gt; nodes are omitted; below, we show details
               of the leftmost "patient" subtree and leave out other subtrees; encrypted data are
               also omitted): 
            </div>
            <div class="programlisting e642" xml:space="preserve">
               &lt;encrypteddocument&gt;
               	&lt;edata key="r4"&gt;...&lt;/edata&gt;
               	&lt;edata key="r14"&gt;...&lt;/edata&gt;
               	&lt;edata key="r6"&gt;...&lt;/edata&gt;
               	&lt;edata key="r2"&gt;...&lt;/edata&gt;
               	&lt;edata key="r4"&gt;...&lt;/edata&gt;
               &lt;/encrypteddocument&gt;
               
            </div>
         </div><a name="DecryptionofMultiEncryptedDocumentsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e643">
            <div class="title e644"> Decryption of Multi-Encrypted Documents </div>
            <div class="para e645">
               When the user U can prove that is entitled to play role R, she will first obtain the
               R-accessible keyring K
               <div class="subscript e646">S</div>(R) via a secure channel, and then proceed to decrypt an m-document M
               <div class="subscript e647">D</div>, to produce a document M
               <div class="subscript e648">D,R</div>. The software system available for U will first identify a sub-keyring K1 of K
               <div class="subscript e649">S</div>(R) consisting of keys needed to decrypt M, and then apply keys available in K1 to
               perform decryption. The output from the decryption is a single XML document. Given
               this document, U may use the system to create a sanitized schema (showing only accessible
               parts of schemas), which would allow them to efficiently apply XML tools, such as
               XQuery for XML databases. One can show that given a schema-level access control policy
               and XML document D valid in S, if the user U in role R is provided only with R-accessible
               keys K
               <div class="subscript e650">S</div>(R), then the protection requirement is satisfied. □
               
            </div>
            <div class="para e651" xml:id="Ex4.6" xreflabel="Example 4.6">
               
               <div class="emphasis e652" role="bold">Example 4.6. </div>
            </div>
            <div class="para e653">
               Consider the m-document from [
               <div class="xref e654" linkend="Ex4.5"></div>], using the schema-based ACP policy from [
               <div class="xref e655" linkend="Ex3.8"></div>].
               Recall from [
               <div class="xref e656" linkend="Ex4.3"></div>] that K
               <div class="subscript e657">S</div>(Physician) ={r4, r5, r6, r7, r12, r13, r14}.
               Assuming that the user plays the role Physician, the decrypted file will look as follows
               (note that in this example, tags are encrypted and so their respective values have
               been concatenated): 
            </div>
            <div class="programlisting e658" xml:space="preserve">
               	&lt;encryptedtag name="Kay" Id="-1"&gt;B1C1V1&lt;/encryptedtag&gt;
               
            </div>
            <div class="para e659">□</div>
         </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e660">
            <div class="title e661"> Implementation </div>
            <div class="para e662">
               Our implementation uses the C++ language, with external libraries to support XML usage
               and cryptographic functions; specifically the Xerces-C++ XML toolkit from Apache [
               <div class="xref e663" linkend="mul115"></div>], and Crypto++ [
               <div class="xref e664" linkend="mul116"></div>]. First, the schema file is parsed and loaded into memory represented as a tree like
               structure (a schema graph). Once the tree is constructed, the access control policy
               file will be parsed and can be validated for semantic correctness against the schema
               in memory (although this is not currently completed). Lastly, all of the information
               that the encryption process requires will be saved into a file that can be loaded
               at a later point in time. Currently, this file is a simple xml file that contains
               the generated keys, schema graph and annotations, as well as the set of conditions
               specific in the access control policy. 
            </div>
            <div class="para e665">
               The encryption process works by firstly re-loading (if necessary) the data saved to
               the xml file back into memory, and next the document to be encrypted is parsed with
               a SAX parser. Each node in the document will be encrypted in the order they appear
               in the document, with nodes being queued if there is not enough information available
               to encrypt them at the time they are first encountered (this can happen when the access
               control policy specified a condition for this node which cannot be calculated until
               a node later in the document is parsed). The encryption process is implemented in
               such a way that the algorithm used to perform the encryption can be changed very easily,
               so either a symmetric or asymmetric algorithm can be used based on user preference.
               It is also possible to extend the implementation to provide a run time facility for
               selecting an encryption algorithm.
               
            </div>
            <div class="para e666">
               Nested paths to arbitrary nodes in conditions are supported through a combination
               of data caching and a queue. During encryption, each node to be encrypted is added
               to the end of the 
               <div class="emphasis e667" role="ital">encryption queue</div>. Additionally, if the node is an attribute or text node that is referenced by conditions,
               the value of this node is cached in the 
               <div class="emphasis e668" role="ital">global value table</div>. The encryption queue is then flushed, by trying to encrypt as many nodes from the
               front of the queue as possible. A node can only be encrypted and removed from the
               queue if all of its dependencies are met. A node with no condition has no dependencies,
               and can be always encrypted. A node with a condition has dependencies, and the global
               value table is searched to ensure that all dependent attribute and text nodes have
               values within this table. If any dependent node is missing a value, this node cannot
               be encrypted, and no further nodes flushed from the queue. Otherwise, the condition
               can be evaluated (determining the key to use for encryption) and then the node is
               encrypted.
               
            </div>
         </div>
      </div><a name="ResultsofTestingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e669">
         <div class="title e670"> Results of Testing </div>
         <div class="para e671">
            We performed testing of our implementation, comparing the time required to multi-encrypt
            (and decrypt) against the time spent when super-encryption was used. The detailed
            description of steps performed in testing is provided below: 
         </div>
         <div class="itemizedlist e672">
            <div class="listitem e673">
               <div class="para e674"> For the schema S from [
                  <div class="xref e675" linkend="Ex3.4"></div>], we considered the SRBAC policy S from [
                  <div class="xref e676" linkend="Ex3.8"></div>]
                  , and determined the number of keys generated by our implementation.
               </div>
            </div>
            <div class="listitem e677">
               <div class="para e678"> For the same schema S, we considered two documents valid in this schema; document
                  D from [
                  <div class="xref e679" linkend="Ex3.1"></div>] and document D2, which is similar to D (except it had much longer text values and
                  different values of attributes). For both of these document, we also considred the
                  induced DRBAC policies for these documents.
                  .
               </div>
            </div>
            <div class="listitem e680">
               <div class="para e681"> For each of the two documents D and D2, we multi-encrypted them four times using
                  our approach, measured the time needed to encrypt, and recorded the average multi-encryption
                  time
               </div>
            </div>
            <div class="listitem e682">
               <div class="para e683"> For each of the two multi-encrypted documents M
                  <div class="subscript e684">D</div> and M
                  <div class="subscript e685">D2</div>, we decrypted themfour times for all four roles, measured the time needed to decrypt,
                  and recorded the average decryption time
               </div>
            </div>
            <div class="listitem e686">
               <div class="para e687"> For each of the two documents, we generated keys and super-encrypted these documents
                  by performing the SAX traversal of the document, using the following approach: 
               </div>
               <div class="para e688">
                  a) for every node x in the intersection of document paths there is a keyring consisting
                  of m keys (one for each path); and the node x is super-encrypted with all these keys.
                  The user in any role R associated with the path P from the intersection will receive
                  the entire keyring. 
               </div>
               <div class="para e689">
                  b) to satisfy the protection requirement, keys are reused based on the following principle.
                  Suppose that in performing the SAX traversal of a document, we have encountered the
                  node x as described above (and generated multiple keys), and then we have encountered
                  the node y in the intersection of the same document paths. Then, the same keyring
                  is used (i.e. no new keys are generated), and the node y is super-encrypted with keys
                  from this keyring. 
               </div>
            </div>
            <div class="listitem e690">
               <div class="para e691"> For each of the two documents D1 and D2, we super-encrypted them using the approach
                  described above, and measured the time needed to encrypt 
               </div>
            </div>
            <div class="listitem e692">
               <div class="para e693"> For each of the two super-encrypted documents M
                  <div class="subscript e694">D</div> and M
                  <div class="subscript e695">D2</div>, we decrypted them four times for all four roles, measured the time needed to decrypt,
                  and recorded the average decryption time 
               </div>
            </div>
         </div>
         <div class="para e696">
            
            <div class="emphasis e697" role="bold">Results. </div>
         </div>
         <div class="para e698">
            The total number of keys generated at the schema level was 8, while the number of
            keys generated at the document level (for super-encryption) was 17 for both documents.
            The time needed to generate keys at the schema level was 0.0279024. The average time
            needed respectively for multi-encryption and super-encryption of the document D was
            0.0007776830 and 0.0019404000. For the document D2, the average time was 0.0022022350
            and 0.0042952375.  The average time needed respectively for decryption for the role
            Physician for the multi-encrypted and super-encrypted document M
            <div class="subscript e699">D</div> was 0.00125512 and 0.00368630. For the document M
            <div class="subscript e700">D2</div>, the average time was respectively 0.00633886 and 0.00972875.
         </div>
         <div class="para e701">
            
            <div class="emphasis e702" role="bold">Conclusions. </div> Our testing proved the expected superiority of multi-encryption over super-encryption.
            Approximately half the keys were generated (although at the schema levels we generate
            keys for all valid documents). While multi-encryption incurs the initial cost of time
            spending on key generation, our tests show that on average for multi-encryption, the
            encryption time and the decryption times were between 30 and 50 percent shorter.
            
         </div>
      </div><a name="ConclusionsandFutureWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e703">
         <div class="title e704"> Conclusions and Future Work </div>
         <div class="para e705">
            In this paper, we provided a description of role-based ACPs for defining permissions
            for fragments of XML documents, both at the document and the schema level. Using our
            approach, keys can be generated at the schema level and then only required keys may
            be assigned to specific documents valid for the schema. A complete system was designed
            and implemented. 
         </div>
         <div class="para e706">
            Our future work includes full optimization of the algorithm which generates keys at
            the schema level, removing some restrictions on XML documents, such as IDREF attributes,
            and designing and implementing re-usability of keyrings when a document or ACP is
            modified. Also, we will start using our approach to develop secure publishing solutions
            in areas such as social networks. 
         </div>
      </div><a name="AcknowledgementsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e707">
         <div class="title e708">Acknowledgements</div>
         <div class="para e709"> The algorithm to find excluded configurations was suggested by Raimond Seidel,
            Saarbruecken University. Greg Leighton, a PhD student from the University of Alberta
            provided many useful comments. Finally, the first author would like to acknowledge
            help of Tommie Usdin in resolving various issues when converting the document in thw
            Word format to XML.
            
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e710">
         <div class="title e711">Bibliography</div>
         <div class="bibliomixed e712" xml:id="mul93" xreflabel="Baldano2002">Baldonado, M., Bertino, E. and Ferrari, E. Secure and Selective Dissemination of XML
            Documents. ACM Transactions on Information and System Security (TISSEC), 5(3):290–331,
            (2002). doi:
            <div class="biblioid doi e713">10.1145/545186.545190</div>.
         </div>
         <div class="bibliomixed e714" xml:id="mul94" xreflabel="Bertino2004">Bertino, E., Carminati, B., Ferrari, E., Thuraisingham B. and A. Gupta. Selective
            and Authentic Third-Party Distribution of XML Documents. IEEE Transactions on Knowledge
            and Data Engineering (TKDE), 16(10), 2004, pp. 1263–1278. doi:
            <div class="biblioid doi e715">10.1109/TKDE.2004.63</div>.
         </div>
         <div class="bibliomixed e716" xml:id="mul95" xreflabel="Bertino2001">Bertino, E., Carminati, B. and Ferrari, E. A temporal key management scheme for secure
            broadcasting of XML documents. Conference on Computer and Comm. Security. Proc. of
            the 9th ACM conference on Computer and communications security (2002): 31–40. doi:
            <div class="biblioid doi e717">10.1145/586110.586116</div>.
         </div>
         <div class="bibliomixed e718" xml:id="mul96" xreflabel="Bertino2002">Bertino, E., Carminati, B. and Ferrari, E. Securing XML Documents with Author-X. IEEE
            Internet Computing Volume 5, Issue 3 (2001): 21 – 31. doi:
            <div class="biblioid doi e719">10.1109/4236.935172</div>.
         </div>
         <div class="bibliomixed e720" xml:id="mul97" xreflabel="Cramption2004">Crampton, J. Applying hierarchical and role-based access control to XML documents.
            Proc. of the 2004 workshop on Secure web service (2004): 37 – 46. doi:
            <div class="biblioid doi e721">10.1145/1111348.1111353</div>.
         </div>
         <div class="bibliomixed e722" xml:id="mul98" xreflabel="Damiani2005">Damiani, E. De Capitani di Vimercati, S.D.C. and Samarati, P. New paradigms for access
            control in open environments. Signal Processing and Information Technology, Proc.
            of the Fifth IEEE International Symposium (2005): 540–545. doi:
            <div class="biblioid doi e723">10.1109/ISSPIT.2005.1577155</div>.
         </div>
         <div class="bibliomixed e724" xml:id="mul99" xreflabel="Damiani2002">Damiani, E., De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  A Fine-grained
            Access Control System for XML Documents.  ACM Transactions on Information and System
            Security,5(2): 169–202,(2002). doi:
            <div class="biblioid doi e725">10.1145/505586.505590</div>.
         </div>
         <div class="bibliomixed e726" xml:id="mul100" xreflabel="De Capitani2003">De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  Access control: principles
            and solutions. Software Practice and Experience, Vol, 33, Issue 5 (April 2003): 397–421.
            John Wiley and Sons, Inc. doi:
            <div class="biblioid doi e727">10.1002/spe.513</div>.
         </div>
         <div class="bibliomixed e728" xml:id="mul101" xreflabel="Devanbu2001">Devanbu, P., Gertz, M., Kwong, A., Martel, C., Nuckolls, G. and S.G. Stubblebine.
            Flexible Authentication of XML documents. In Proc. of the 8th ACM Conference on Computer
            and Communications Security, ACM Press, (2001). doi:
            <div class="biblioid doi e729">10.1145/501983.502003</div>.
         </div>
         <div class="bibliomixed e730" xml:id="mul102" xreflabel="Ferraiolo2001">Ferraiolo, D.F., Sandhu, R., Gavrila, S., Kuhn, D.S. and Chandramouli, R. Proposed
            NIST Standard for Role-Based Access Control. ACM Trans. on Information and System
            Security, 4 (3), (2001), 224–274. doi:
            <div class="biblioid doi e731">10.1145/501978.501980</div>.
         </div>
         <div class="bibliomixed e732" xml:id="mul103" xreflabel="Fundulaki2004">Fundulaki, I. and Marx, M. Specifying access control policies for XML documents. Proceedings
            of the ninth ACM symposium on Access control models and technologies (2004) 61 – 69.
            doi:
            <div class="biblioid doi e733">10.1145/990036.990046</div>.
         </div>
         <div class="bibliomixed e734" xml:id="mul104" xreflabel="Goel2003">Goel, S K., Clinton, C. and Rosenthal, A. Derived access control specification for
            XML. Proc. of the 2003 ACM workshop on XML security (2003): 1 – 14. doi:
            <div class="biblioid doi e735">10.1145/968559.968561</div>.
         </div>
         <div class="bibliomixed e736" xml:id="mul105" xreflabel="Kudo2000">Kudo, M. and Hada S. XML document security based on provisional authorization. Proc.
            of the 7th ACM conference on Computer and communications security (2000): 87 –96.
            doi:
            <div class="biblioid doi e737">10.1145/352600.352613</div>.
         </div>
         <div class="bibliomixed e738" xml:id="mul106" xreflabel="Kuper2005">Kuper, G., Massaci, F. and Rassadko, N. Generalized XML security views. Proc. of the
            tenth ACM symposium on Access control models and technologies. (2005):77–84. doi:
            <div class="biblioid doi e739">10.1145/1063979.1063994</div>.
         </div>
         <div class="bibliomixed e740" xml:id="mul107" xreflabel="Miklau2003">Miklau, G. and Suciu, D. Controlling Access to Published Data Using Cryptography,
            In Proc. of the 29th VLDB Conference, Berlin, Germany, (2003).
         </div>
         <div class="bibliomixed e741" xml:id="mul108" xreflabel="Müldner2006"> Müldner, T., Leighton, G. and Miziolek, J.K. Using Multi-Encryption to Provide Secure
            and Controlled Access to XML Documents. Extreme Markup Languages 2006, (2006), Montreal,
            Canada.
         </div>
         <div class="bibliomixed e742" xml:id="mul109" xreflabel="Müldner2008"> Müldner, T., Leighton, G. and Miziolek, J.K. Succinct Access Control Policies for
            Published XML Datasets. 10th International Conference on Enterprise Information Systems.
            12 –16, June 2008, Barcelona, Spain.
         </div>
         <div class="bibliomixed e743" xml:id="mul110" xreflabel="Ramaswamy2003">Ramaswamy C. A Policy Validation Framework for Enterprise Authorization Specification.
            19th Annual Computer Security Applications Conference ACSAC, (2003): 319–329. doi:
            <div class="biblioid doi e744">10.1109/CSAC.2003.1254336</div>.
         </div>
         <div class="bibliomixed e745" xml:id="mul111" xreflabel="XML2008">Extensible Markup Language (XML) 1.0 (Fourth Edition) 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e746" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/REC-xml/</div>.
         </div>
         <div class="bibliomixed e747" xml:id="mul112" xreflabel="XPath2008">XML Path Language. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e748" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xpath</div>.
         </div>
         <div class="bibliomixed e749" xml:id="mul113" xreflabel="XML-Schema2008">XML Schema 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e750" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xmlschema-0/</div>.
         </div>
         <div class="bibliomixed e751" xml:id="mul114" xreflabel="Zhang2003">Zhang, X., Park, J. and Sandhu, R. Schema based XML Security: RBAC Approach, 17th
            IFIP 11.3. Working Conference on Data and Application Security, 2003. doi:
            <div class="biblioid doi e752">10.1007/1-4020-8070-0_24</div>.
         </div>
         <div class="bibliomixed e753" xml:id="mul115" xreflabel="Xerces2008">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e754" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://xerces.apache.org/xerces-c/</div>.
         </div>
         <div class="bibliomixed e755" xml:id="mul116" xreflabel="Crypto++2008">
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e756" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.cryptopp.com/</div>.
         </div>
      </div>
   </div>
</div>