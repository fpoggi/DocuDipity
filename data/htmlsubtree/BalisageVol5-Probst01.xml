<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#ProcessingArbitrarilyLargeXMLusingaPersistentDOMANCHOR" name="ProcessingArbitrarilyLargeXMLusingaPersistentDOMTOC">Processing Arbitrarily Large XML using a Persistent DOM</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RelatedWorkANCHOR" name="RelatedWorkTOC">Related Work</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ContributionsANCHOR" name="ContributionsTOC">Contributions</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DocumentModelStorageStructureANCHOR" name="DocumentModelStorageStructureTOC">Document Model Storage Structure</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TraditionalDocumentModelImplementationANCHOR" name="TraditionalDocumentModelImplementationTOC">Traditional Document Model Implementation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DiskbasedDOMarchitectureANCHOR" name="DiskbasedDOMarchitectureTOC">Disk based DOM architecture</a></div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#StorageLayoutANCHOR" name="StorageLayoutTOC">Storage Layout</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NodeStructureANCHOR" name="NodeStructureTOC">Node Structure</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#EncodingofPrimitivesANCHOR" name="EncodingofPrimitivesTOC">Encoding of Primitives</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#NamebaseCodesANCHOR" name="NamebaseCodesTOC">Namebase Codes</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ModificationsANCHOR" name="ModificationsTOC">Modifications</a></div>
               </div>
               <div class="headedContainerTOC">
                  <div class="headedContainerTitleTOC"><a href="#ImplementationANCHOR" name="ImplementationTOC">Implementation</a></div>
                  <div class="headedContainerTOC">
                     <div class="headedContainerTitleTOC"><a href="#OnDiskLayoutExampleANCHOR" name="OnDiskLayoutExampleTOC">On Disk Layout Example</a></div>
                  </div>
               </div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#MemoryConsumptionANCHOR" name="MemoryConsumptionTOC">Memory Consumption</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ProgrammingModelANCHOR" name="ProgrammingModelTOC">Programming Model</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#PerformanceComparisonsANCHOR" name="PerformanceComparisonsTOC">Performance Comparisons</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ParsingANCHOR" name="ParsingTOC">Parsing</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DOMnavigationANCHOR" name="DOMnavigationTOC">DOM navigation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#XSLtransformationANCHOR" name="XSLtransformationTOC">XSL transformation</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DiscussionANCHOR" name="DiscussionTOC">Discussion</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionANCHOR" name="ConclusionTOC">Conclusion</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">a[start]</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">below</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">DomElementStore</div>
         <div class="singletermTERMS">DomElement</div>
         <div class="singletermTERMS">diff</div>
         <div class="singletermTERMS">DomNode.newDomNode()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">element-content-whitespace</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">First Child next?</div>
         <div class="singletermTERMS">fs</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getLocalName()</div>
         <div class="singletermTERMS">getPageAndSlot()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">if</div>
         <div class="singletermTERMS">isSameNode()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">Martin</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">null</div>
         <div class="singletermTERMS">node1 == node2</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
         <div class="singletermTERMS">org.w3c.dom</div>
         <div class="singletermTERMS">org.w3.dom.Element</div>
         <div class="singletermTERMS">org.w3c.dom.Document</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">prefix:*</div>
         <div class="singletermTERMS">packedLongLen()</div>
         <div class="singletermTERMS">processing</div>
         <div class="singletermTERMS">Probst</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">replaceNode</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">session.commit()</div>
         <div class="singletermTERMS">session.rollback()</div>
         <div class="singletermTERMS">Searching</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XhiveDriverIf</div>
         <div class="singletermTERMS">XhiveSessionIf</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="ProcessingArbitrarilyLargeXMLusingaPersistentDOMANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">Processing Arbitrarily Large XML using a Persistent DOM</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2010</div>
            <div class="confdates e5">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">As the adoption of XML reaches more and more application domains, data sizes increase,
               and efficient XML handling gets more and more important. Many applications face scalability
               problems due to the overhead of XML parsing, the difficulty of effectively finding
               particular XML nodes, or the sheer size of XML documents, which nowadays can easily
               exceed
               gigabytes of data. 
            </div>
            <div class="para e8">In particular the latter issue can make certain tasks seemingly impossible to handle,
               as
               many applications depend on parsing XML documents completely into a Document Object
               Model
               (DOM) memory structure. Parsing XML into a DOM typically requires close to or even
               more
               memory as the serialized XML would consume, thus making it prohibitively expensive
               to handle
               XML documents in the gigabyte range. Recent research and development suggests that
               it is
               possible to modify these applications to run a wide range of tasks in a streaming
               fashion,
               thus limiting the memory consumption of individual applications. However this requires
               not
               only changes in the underlying tools, but often also in user code, such as XSLT style
               sheets. These required changes can often be unintuitive and complicate user code.
               
            </div>
            <div class="para e9">A different approach is to run applications against an efficient, persistent, hard-disk
               backed DOM implementation that does not require entire documents to be in memory at
               a time.
               This talk will discuss such a DOM implementation, EMC's xDB, showing how to use binary
               XML
               and efficient backend structures to provide a standards compliant, non-memory-backed,
               transactional DOM implementation, with little overhead compared to regular memory-based
               DOMs. It will also give performance comparisons and show how to run existing applications
               transparently against xDB's DOM implementation, using XSLT stylesheets as an example.
               
            </div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Martin</div>
               <div class="surname e13">Probst</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">Martin Probst is a senior software engineer at EMC, working on EMC Documentum xDB.
                  He
                  has been working on XML databases and XQuery in particular since 2004. Martin holds
                  a MSc.
                  in Software Engineering from Hasso Plattner Institute in Potsdam, Germany.
               </div>
            </div>
         </div>
         <div class="legalnotice e16">
            <div class="para e17">Copyright © 2010 by EMC Corporation.  All rights reserved.</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e18">
         <div class="title e19">Introduction</div>
         <div class="para e20">As the adoption of XML reaches more and more application domains, data sizes increase,
            and
            efficient XML handling gets more and more important. Many applications face scalability
            problems due to the overhead of XML parsing, the difficulty of effectively finding
            particular
            XML nodes, or the sheer size of XML documents, which nowadays can exceed gigabytes
            of
            data.
         </div>
         <div class="para e21">Parsing a sample 20 MB XML document
            <div class="popupBox e22">
               <div class="popupLabel" onmouseover="$('#d1e36').show('1000');" onmouseout="$('#d1e36').hide('1000');">[ footnote ]</div>
               <div id="d1e36" style="display: none;">
                  <div class="footnote">
                     <div class="para e23">Encoded as UTF-8 text. In UTF-16, the same document (as expected) takes about 40
                        MB.
                     </div>
                  </div>
               </div>
            </div> containing Wikipedia document abstracts into a DOM tree using the Xerces library
            roughly consumes about 100 MB of RAM. Other document model implementations
            <div class="popupBox e24">
               <div class="popupLabel" onmouseover="$('#d1e40').show('1000');" onmouseout="$('#d1e40').hide('1000');">[ footnote ]</div>
               <div id="d1e40" style="display: none;">
                  <div class="footnote">
                     <div class="para e25">While technically, DOM is the name of a particular standardized XML document model
                        programming interface, for the sake of this paper, any document model implementation
                        is
                        equivalent. We are concerned with how to store XML documents as navigable structures,
                        not
                        any particular programming interface against them. As the DOM is the most prevalent
                        document model interface, we use the term interchangeably.
                     </div>
                  </div>
               </div>
            </div> such as Saxon's TinyTree are more memory efficient; parsing the same document in
            Saxon consumes about 50 MB of memory. These numbers will vary with document contents,
            but
            generally the required memory scales linearly with document size, and is typically
            a
            single-digit multiple of the file size on disk. Extrapolating from these (unscientific)
            numbers, we can easily see that handling documents that range in the hundreds of megabytes
            will easily outgrow available memory on today's workstations, that typically have
            several
            gigabytes of memory available. Even when documents do not outgrow available memory,
            memory use
            is a concern in many applications, particularly in servers processing multiple requests
            in
            parallel.
         </div>
         <div class="para e26">Parsing the 20 MB XML file into xDB requires 16 MB of disk space. The amount of memory
            required is not related to document size and can be very small (in the kilobyte range).
         </div><a name="RelatedWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e27">
            <div class="title e28">Related Work</div>
            <div class="para e29">One approach to overcome memory issues is to perform streaming operations in very
               specific situations. Peng and Chawathe (
               <div class="xref e30" linkend="bib.pengchwathe"></div>) present a
               streaming implementation for a limited subset of XPath operations, Florescu, Hillery
               et al.
               (
               <div class="xref e31" linkend="bib.florescuhillery"></div>) achieve the same for XQuery; the Streaming
               Transformations for XML (STX) language defines a language similar to XSLT geared at
               streamed
               execution (
               <div class="xref e32" linkend="bib.stx"></div>); and the unreleased XSLT 2.1 specification will
               contain special syntax to allow a limited streaming execution mode (
               <div class="xref e33" linkend="bib.xslt21"></div>).
            </div>
            <div class="para e34">However, streaming is a very limiting programming model. Many real world XML
               applications require access to preceding or following nodes, like the title of the
               section a
               node is contained in. To achieve streaming execution, the above approaches have to
               exclude
               or severly limit commonly used operations like backwards navigating axes.
            </div>
            <div class="para e35">Another approach is to use databases to store XML documents, moving them out of memory
               to secondary storage. There is a wide range of literature on the topic, with early
               efforts
               focusing on shredding XML documents to store them in relational databases, either
               in tables
               tailored to a specific XML schemata, or in a generic structure (
               <div class="xref e36" linkend="bib.xmlshred"></div>). As requiring schemata upfront contradicted user expectations and a generic database
               layout results in too many join operations for common hierarchy navigation, later
               approaches
               propose a variety of numbering schemes to encode the document structure (
               <div class="xref e37" linkend="bib.exist"></div>). While different solutions with different features exist, these
               numbering schemes generally support resolving at least some structural queries based
               on the
               numbering. Early schemes required re-numbering on document modifications, later ones
               overcome this limitation (
               <div class="xref e38" linkend="bib.ordpath"></div>).
            </div>
            <div class="para e39">Using databases with numbering schemes, we can overcome main memory limitations for
               storage and search. However the question of how to efficiently process potentially
               large XML
               documents in application code remains.
            </div>
         </div><a name="ContributionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e40">
            <div class="title e41">Contributions</div>
            <div class="para e42">This paper presents a different approach: a persistent, hard-disk based DOM that can
               store arbitrarily large XML documents and provides read/write access to them through
               the
               regular Java DOM API without using a node numbering scheme. Regular XML applications
               can use
               the familiar DOM programming model and the wealth of available XML tools relying on
               the DOM
               interface. This paper is based on EMC Documentum xDB's implementation of the presented
               concepts.
            </div>
            <div class="para e43">xDB differs from other persistent XML stores and other persistent DOM implementations
               in
               that it is optimized for direct DOM access. Navigation operations corresponding to
               the
               common DOM operations are executed in constant time comparable to main-memory based
               DOM
               implementations. xDB, unlike other XML databases, does not use a node numbering scheme
               but
               relies on indexes for fast value lookups.
            </div>
            <div class="para e44">We extensively describe xDB's data organization and storage layout, with a particular
               focus on efficient encoding of node data. We provide performance comparisons with
               two
               different main memory DOM implementations.
            </div>
         </div>
      </div><a name="DocumentModelStorageStructureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e45">
         <div class="title e46">Document Model Storage Structure</div><a name="TraditionalDocumentModelImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e47">
            <div class="title e48">Traditional Document Model Implementation</div>
            <div class="para e49">DOM implementations (or any document model) usually create classes for the various
               XML
               node types, and have fields to store the node's properties, like the node name, the
               list of
               children, the parent node, and so on.
            </div>
            <div class="para e50">
               <div class="xref e51" linkend="fig.elementImpl"></div> shows a typical DOM element implementation, ignoring
               any inheritance chain and inlining all fields for the sake of simplicity. We can see
               that
               the Element node keeps references to other nodes in the tree, some basic references
               like the
               first child and the next sibling to implicitly form the tree itself, and some to enhance
               navigation speed, like the parent reference or the previous sibling reference, that
               could be
               emulated using the basic references.
            </div>
            <div class="figure e52" xml:id="fig.elementImpl">
               <div class="title e53">A typical DOM Element Implementation (simplified)</div>
               <div class="mediaobject e54">
                  <div class="imageobject e55">
                     <div class="metaBox e56"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e96').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e96" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e56'
                              </span><span class="metaAttribute">fileref='../../../vol5/graphics/Probst01/Probst01-001.png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e57">There are many different ways of representing an XML document, differing in memory
               consumption, navigation speed for particular axes, whether the document can be modified
               after parsing, and so on. Some implementations avoid storing immediate object references
               to
               limit the number of objects held in memory, but still store the complete document
               in memory.
               However they all rely on the assumption that the complete document is parsed at once,
               and
               kept in memory while operating on it.
            </div>
            <div class="para e58">This leads to the observed limitations in supported document size caused by memory
               exhaustion.
            </div>
         </div><a name="DiskbasedDOMarchitectureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e59">
            <div class="title e60">Disk based DOM architecture</div>
            <div class="para e61">Our DOM implementation avoids this limitation by storing a binary representation of
               an
               XML document on the hard disk. While this representation avoids keeping the whole
               document
               in memory at all times, it is still directly navigable from the programming interface,
               without requiring re-parsing or buffering parts of the document during program execution.
               Documents are also mutable — nodes can modified after initial parsing, again without
               requiring the whole document to be in memory.
            </div>
            <div class="para e62">Nodes are identified using a 64 bit number and stored in data pages that allocate
               individual nodes in slots. The first 54 bit of a node identifier point to the page,
               the
               latter 10 bits identify a slot within a particular page. As the pages are stored in
               files in
               the file system, within the first 54 bits, 20 bits are used to identify a particular
               file
               used for storage. Node identifiers directly point to the physical location of a node;
               there
               is no indirection between node identifiers and physical node location (see 
               <div class="xref e63" linkend="sect.dom-modifications"></div> for a detailed discussion of the impact on updates).
               xDB node identifiers can be considered "physical identifiers".
            </div>
            <div class="para e64">This approach is quite different from other XML databases, that typically use a node
               numbering scheme to identify nodes, separating the logical node identifier from its
               physical
               identifier/location. A node numbering scheme can be helpful to answer unbounded structural
               queries, such as the XPath 
               <div class="code e65">/bib//book//author</div>. On the other hand, such
               numbering schemes only help evaluating queries over a large node set; navigating within
               individual nodes in a DOM-like fashion will probably be slower due to the additional
               indirection required (i.e., typically an index lookup by node ID). We assert that
               unbounded
               structural queries are rare in actual applications. Applications typically either
               search for
               specific pieces of information, or process a complete document or document fragment.
               
               <div class="emphasis e66">Searching</div> within XML can be mapped to value based indexes, while
               
               <div class="emphasis e67">processing</div> XML commonly means visiting more or less every node of the
               document, thus requiring efficient navigation. xDB provides configurable index structures
               that can answer combined structure and value queries (e.g. 
               <div class="code e68">/bib//book[author/lastname
                  = 'Doe']
               </div>) to support efficient searching for nodes. To process nodes once they have
               been found, xDB resorts to efficient navigation using physical node identifiers.
            </div>
            <div class="para e69">Pages are of configurable size but should be identical in size to the underlying file
               system's page size, for reasons of data consistency in write operations
               <div class="popupBox e70">
                  <div class="popupLabel" onmouseover="$('#d1e126').show('1000');" onmouseout="$('#d1e126').hide('1000');">[ footnote ]</div>
                  <div id="d1e126" style="display: none;">
                     <div class="footnote">
                        <div class="para e71">When flushing data to disk, it is only guaranteed that an individual page is written
                           atomically. Thus, if your data pages are larger than the file system data page, you
                           might risk partially-written pages in the case of system failures.
                        </div>
                     </div>
                  </div>
               </div>. This means pages are usually 4 kilobytes (Windows, Linux, Mac OS X) or 8
               kilobytes (certain UNIXes).
            </div>
            <div class="para e72">Individual XML documents can spread across any number of physical files, pages, and
               slots, but always use at least one complete page; pages are not shared between multiple
               documents. The minimum storage size consumed by a document is thus one page (typically
               4
               kilobytes). The theoretical maximum size for an individual document is the number
               of
               possible files times the number of pages in a file, times the individual page size.
               A
               database configured with just a single file can thus (assuming 4096 bytes page size,
               using
               non-SI prefixes) hold documents up to 2
               <div class="superscript e73">34</div> *
               2
               <div class="superscript e74">12</div> bytes = 2
               <div class="superscript e75">46</div> ≈ 64
               terabytes in size; an ideally configured database with 2
               <div class="superscript e76">20</div> files
               could theoretically hold 2
               <div class="superscript e77">66</div> bytes ≈ 64 exabytes. The
               attentive reader will have precluded that we have not been able to test the implementation
               with exabytes of storage. This is left as an exercise to the first customer reaching
               that
               database size. Databases with dozens of terabytes of data are common in customer
               deployments.
            </div>
            <div class="para e78">These theoretical storage limits refer to the size of documents in xDB's internal,
               proprietary binary XML format. We will show that this does not necessarily correspond
               to
               regular serialized XML size, but is typically comparable or slightly less.
            </div><a name="StorageLayoutANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e79">
               <div class="title e80">Storage Layout</div>
               <div class="para e81">xDB's storage layout is depicted in 
                  <div class="xref e82" linkend="fig.storageLayout"></div>. Pages are
                  stored in one of potentially many data files grouped together in segments. Data files
                  are
                  cached in main memory within a data structure called page cache. Each page contains
                  multiple slots, which in turn store individual nodes. Slot size is not fixed - different
                  nodes, even of the same type, can have different lengths. Slot allocation information
                  is
                  stored in an administrative section within the data page, giving start and end locations
                  for each slot.
               </div>
               <div class="figure e83" xml:id="fig.storageLayout">
                  <div class="title e84">Storage Layout in xDB</div>
                  <div class="mediaobject e85">
                     <div class="imageobject e86">
                        <div class="metaBox e87"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e161').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e161" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e87'
                                 </span><span class="metaAttribute">fileref='../../../vol5/graphics/Probst01/Probst01-002.png'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e88">The layout of an individual slot depends on the node's type. Storage layout is defined
                  through an XML dialect, which is then used to generate Java source code through an
                  XSL
                  transformation as part of the build process.
               </div>
            </div><a name="NodeStructureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e89">
               <div class="title e90">Node Structure</div>
               <div class="para e91">xDB stores node trees much like other DOM implementations, spanning a tree through
                  first-child and next-sibling pointers. The major difference is that xDB takes great
                  care
                  to reduce the size of objects, and that xDB directly operates on byte arrays to store
                  nodes.
               </div>
               <div class="para e92">
                  
                  <div class="xref e93" linkend="fig.elementHeader"></div> shows the bit layout of the two bytes comprising an
                  XML Element header. All nodes start with a sequence of bits determining the node type.
                  The
                  most common nodes (elements and text nodes) only need two bits of storage for the
                  type, as
                  their type codes are 
                  <div class="code e94">01</div> and 
                  <div class="code e95">00</div>. Other node types are stored
                  using longer bit sequences starting with a bit 
                  <div class="code e96">1</div>. The following bits all
                  represent booleans, indicating the presence or absence of fields in the elements storage
                  and other properties of the node and its storage layout. This reduces on-disk storage
                  consumption for elements that do not have children or siblings and documents that
                  do not
                  use various features like namespaces, post schema validation infoset (PSVI) information,
                  and so on. The bit fields read only and namespace node handle two special cases. Inlined
                  entity reference nodes are marked as read only to protect against incorrect modifications,
                  thus the bit field. Additionally, xDB supports DOM Level 1 documents that do not have
                  namespace support. For those documents, compliant DOM implementations must return
                  
                  <div class="code e97">null</div> for calls to the namespace-aware methods like
                  
                  <div class="code e98">getLocalName()</div>. If the bit is set to 
                  <div class="code e99">0</div>, xDB will return
                  
                  <div class="code e100">null</div> on those calls. 
               </div>
               <div class="figure e101" xml:id="fig.elementHeader">
                  <div class="title e102">DOM Element Header</div>
                  <div class="mediaobject e103">
                     <div class="imageobject e104">
                        <div class="metaBox e105"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e200').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e200" class="metaSource" style="display:none;">                
                              &lt;imagedata<span class="metaAttribute">class='e105'
                                 </span><span class="metaAttribute">fileref='../../../vol5/graphics/Probst01/Probst01-003.png'
                                 </span>
                              &gt;
                              
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="para e106">For an element, this header is followed by the following, partially optional fields:
                  
                  <div class="itemizedlist e107">
                     <div class="listitem e108">
                        <div class="para e109">Parent reference</div>
                     </div>
                     <div class="listitem e110">
                        <div class="para e111">Next sibling reference (optional)</div>
                     </div>
                     <div class="listitem e112">
                        <div class="para e113">Previous sibling reference (optional)</div>
                     </div>
                     <div class="listitem e114">
                        <div class="para e115">First child reference (optional)</div>
                     </div>
                     <div class="listitem e116">
                        <div class="para e117">Last child reference (optional)</div>
                     </div>
                     <div class="listitem e118">
                        <div class="para e119">Local name code (integer)</div>
                     </div>
                     <div class="listitem e120">
                        <div class="para e121">Namespace URI code (integer, optional)</div>
                     </div>
                     <div class="listitem e122">
                        <div class="para e123">Prefix name code (integer, optional)</div>
                     </div>
                     <div class="listitem e124">
                        <div class="para e125">First attribute reference (optional)</div>
                     </div>
                     <div class="listitem e126">
                        <div class="para e127">Primitive type name code (integer, optional)</div>
                     </div>
                     <div class="listitem e128">
                        <div class="para e129">Complete type name code (integer, optional)</div>
                     </div>
                     <div class="listitem e130">
                        <div class="para e131">PSVI properties (integer, optional)</div>
                     </div>
                  </div>
                  
               </div>
               <div class="para e132">These fields following this header can have different types: 32 bit numbers, 64 bit
                  numbers, node references as relative 64 bit node IDs, strings, and string lists. The
                  presence of optional fields if governed by their respective bit field in the element
                  header. If a field is absent, it takes no storage space at all and retrieving it will
                  return a specified default value, for example 
                  <div class="code e133">null</div> for node references or
                  
                  <div class="code e134">-1</div> for undefined namebase codes.
               </div>
               <div class="para e135">Another storage size optimization is the 
                  <div class="code e136">First Child next?</div> bit field. If
                  true, the following node on the data page is the first child of this node, allowing
                  us not
                  to store the node ID. This reflects the observation that most XML documents are parsed
                  once and rarely modified. In that case, the parsing process will cause an element's
                  children to be stored directly following the element within the data page.
               </div>
               <div class="para e137">xDB stores all different DOM node types using this scheme, exploiting the various
                  optimizations possible for different node types - for example, attribute nodes do
                  not need
                  a type field as their type is implicitly known at the place where they are
                  referenced.
               </div>
            </div><a name="EncodingofPrimitivesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e138">
               <div class="title e139">Encoding of Primitives</div>
               <div class="para e140">All numeric fields, i.e. integers, longs, and node references, are stored using
                  run-length encoded numbers. This means that, for example, a 64 bit number that would
                  normally consume 8 bytes of storage space will be compressed depending on its actual
                  magnitude. Values below 
                  <div class="code e141">0x80</div> (128 decimal) take only one byte of storage
                  space, values below 
                  <div class="code e142">0x4000</div> (16384 decimal) take only two bytes, and so on.
                  This significantly reduces storage size as node references are not stored as the complete
                  node ID, but as the relative offset to the current node ID, giving small numbers even
                  in
                  large databases. Node references are additionally left shifted and then complemented
                  if
                  negative so that small negative offsets are stored as small positive numbers, giving
                  a
                  more compressed number. Because nodes are typically added in batch (either during
                  parsing,
                  or during larger modifications), nodes usually reference other nodes that are very
                  close
                  to them on the data pages. This means we can typically store node references in a
                  byte or
                  two. The same applies to the 32 bit numbers used for namebase codes (see 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e143" linkend="sect.namebase-codes" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">below</div>).
               </div>
               <div class="para e144">Text data from XML text nodes, CDATA sections, and attribute values is stored using
                  an
                  encoding scheme similar to UTF-8. In UTF-8 encoded text, it is always possible to
                  identify
                  whether a byte is starting a new Unicode codepoint, or if it is part of a multi-byte
                  encoded codepoint that started earlier. To support this, UTF-8 'wastes' some bits
                  that
                  could otherwise be used to encode the codepoints themselves more compact. xDB does
                  not
                  need this functionality as our storage layout explicitly marks start and end of strings,
                  allowing us to encode text data a bit compacter. Text data longer than a single database
                  page is stored using special text-only database pages to avoid the overhead of page
                  administration.
               </div>
               <div class="para e145">String lists, such as the value of attributes of type NMTOKENS, are stored as a list
                  of zero-byte separated strings.
               </div>
            </div><a name="NamebaseCodesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e146" xml:id="sect.namebase-codes">
               <div class="title e147">Namebase Codes</div>
               <div class="para e148">xDB stores node names using a so-called namebase, a table mapping integer codes to
                  individual NCNames. This both reduces storage size and replaces string comparisons
                  with
                  simple integer comparisons for name comparisons. URI, prefix, and local name are stored
                  separately to speed up queries using wildcard XPath name tests like 
                  <div class="code e149">prefix:*</div>.
                  While namespace prefixes are not significant according to the XML infoset standard
                  and
                  standards like XPath, they are significant in other standards, like the DOM. Because
                  of
                  this, and because of the user expectation to have complete document fidelity, we store
                  the
                  namespace prefix.
               </div>
            </div><a name="ModificationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e150" xml:id="sect.dom-modifications">
               <div class="title e151">Modifications</div>
               <div class="para e152">Modifying a node simply means modifying the underlying data page, to reflect the
                  changes that are made to the node. All DOM operations, such as 
                  <div class="code e153">replaceNode</div>,
                  are directly reflected in the underlying byte arrays.
               </div>
               <div class="para e154">A problem with the very condensed layout of nodes is that a node might require more
                  storage space than available in its slot after an update. For example, if we add a
                  child
                  element to an XML element node that was previously empty, the element will need more
                  storage space. In the simple case, the space in the data page that is immediately
                  following the element is unused, and we can simply grow the element.
               </div>
               <div class="para e155">In the complex case however, the space following the element node is already used
                  by
                  another node, and we cannot grow the node. At the same time, we cannot simply store
                  the
                  element at a different place and free the originally used storage space, as other
                  nodes
                  will be directly pointing to the current location of the node. If we were to move
                  a node,
                  we would have to update all existing pointers to this node, which is a potentially
                  very
                  expensive operation, requiring the complete database to be scanned.
               </div>
               <div class="para e156">To avoid this, xDB replaces the current node store with a forwarding pointer that
                  will
                  always be small enough to fit in the available space. The pointer references the actual
                  location of the node in the database, and all operations on nodes are safeguarded
                  by a
                  check for a forwarding reference.
               </div>
               <div class="para e157">This scheme has the drawback that documents receiving many update operations can
                  fragment over time. It is possible to create degenerate cases where many nodes will
                  be
                  replaced by forwarding pointers. Again, the observation is that most XML documents
                  are
                  parsed exactly once and hardly ever modified.
               </div>
            </div><a name="ImplementationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e158" xml:id="sect.implementation">
               <div class="title e159">Implementation</div>
               <div class="para e160">Nodes are represented at runtime by regular Java objects. The node storage layout
                  is
                  defined by an XML file that also specifies class name, super class, and the class
                  this
                  node is owned by (e.g. document for most DOM nodes). In the build process, an XSLT
                  stylesheet transforms these XML definitions into a Java source file, by convention
                  ending
                  in 'Store' (e.g. 
                  <div class="code e161">DomElementStore</div>). The Java file defines an abstract class
                  that provides getters and setters for the node's fields operating directly on the
                  page
                  byte array. This is then extended by a concrete class that provides the public API
                  for a
                  given DOM node, e.g. 
                  <div class="code e162">DomElement</div>. This class then implements the respective
                  
                  <div class="code e163">org.w3c.dom</div> interface, typically along several other xDB specific ones.
                  That allows us to keep generated and handwritten code separate.
               </div>
               <div class="para e164">From a Java perspective, every DOM node object instance references only the page (as
                  a
                  Java object) and the slot (as an int), thus instantiated DOM node objects consume,
                  depending on JVM implementation and CPU architecture, between 16 and 32 bytes of main
                  memory. The page object references the byte array storing page data only through a
                  level
                  of indirection, so even if a DOM node is instantiated in a Java program, the underlying
                  data page can be swapped out by the cache manager.
               </div>
               <div class="para e165">Method calls on a DOM interface cause the data page to be obtained (and loaded into
                  memory, if necessary), after which we decode the requested information through a sequence
                  of bit operations. The traditional "fields" of an XML element like children, node
                  name,
                  etc. are never cached. This allows us to keep the memory footprint of a Java application
                  minimal - only DOM nodes directly referenced by a user program are actually kept in
                  memory.
               </div>
               <div class="para e166">
                  <div class="xref e167" linkend="code.get-first-child"></div> shows the Java code retrieving the first child
                  of a DOM element node, pretty printed and simplified from the original, generated
                  version.
                  The actual code is guarded by a method that checks permissions and whether the current
                  transaction is open or interrupted.
               </div>
               <div class="para e168">The code then retrieves the byte array holding the data of the page where the node
                  is
                  stored. This might trigger the page to be swapped in if needed. The code then determines
                  the start and end offsets of this node within the data page. If the node is marked
                  as a
                  forwarding object, the code will retrieve the actual data page and update start and
                  end
                  offsets (not shown).
               </div>
               <div class="para e169">In the series of 
                  <div class="code e170">if</div> statements afterwards, we check the bit fields in the
                  first byte of the element header, referenced by 
                  <div class="code e171">a[start]</div>. The first
                  comparison checks the third bit ("First Child null?") and returns null if true, the
                  second
                  comparison checks if "First Child Next?". In that case, the 
                  <div class="code e172">diff</div> (offset of
                  the first child node relative to this node) is one — it is the next node on this
                  page. Otherwise, we have to actually read the node reference, by first finding it
                  in the
                  storage and putting the position in the variable 
                  <div class="code e173">fs</div>. First we add two to skip
                  the element header (two bytes). Because we don't know the length of the first reference
                  (the parent), we then read the long, and skip as many bytes as it consumes in storage
                  (
                  <div class="code e174">packedLongLen()</div>). The next two references are optional, so we check
                  whether they are present using bit comparisons again, and skip ahead if they are present.
                  Afterwards we read the actual difference, convert the transformed relative difference
                  back, and add it to our current node identifier (
                  <div class="code e175">getPageAndSlot()</div> in the
                  code), retrieve a page object and compute the slot from the number. The call to
                  
                  <div class="code e176">DomNode.newDomNode()</div> will inspect the type field of the referenced object
                  and return a new instance of the appropriate subclass, pointing to the new node ID.
               </div>
               <div class="figure e177" xml:id="code.get-first-child" xreflabel="">
                  <div class="title e178">Retrieving the first child of an element (Java)</div>
                  <div class="programlisting e179" xml:space="preserve">DomNode getFirstChildRef() {
                     Page slotpage = getPage();
                     byte[] a = slotpage.getDataReadOnly();
                     int slot = getSlot();
                     int offset = getOffset(a, slot);
                     int start = Page.unpack2(a, offset);
                     int end = Page.unpack2(a, offset - 2);
                     if (a[start] &lt;= FORWARD_OBJECT) {
                     // handle forwarded objects by updating a, start, and end
                     }
                     
                     long diff;
                     if ((a[start] &amp; 1 &lt;&lt; 3) != 0) {
                     return null;
                     } else if ((a[start] &amp; 1 &lt;&lt; 2) != 0) {
                     diff = 1L;
                     } else {
                     int fs = start;
                     fs += 2;
                     fs += packedLongLen(a, fs);
                     if ((a[start + 1] &amp; 1 &lt;&lt; 7) == 0)
                     fs += packedLongLen(a, fs);
                     if ((a[start + 1] &amp; 1 &lt;&lt; 6) == 0)
                     fs += packedLongLen(a, fs);
                     
                     assert fs &lt; end;
                     diff = getRelDiff(unpackLong(a, fs));
                     }
                     long id = getPageAndSlot() + diff;
                     Page idpage = getPageFromPS(id);
                     int idslot = getSlotFromPS(id);
                     
                     return DomNode.newDomNode(idpage, idslot);
                     }
                  </div>
               </div>
               <div class="para e180">Because we don't reference or cache constructed child objects, in xDB's DOM
                  implementation one logical node might be represented by many different Java object
                  instances. This is in line with the W3C DOM specification that requires users to compare
                  nodes for identity using the function 
                  <div class="code e181">isSameNode()</div>, but sometimes surprising
                  to programmers that expect a simple equality comparison (
                  <div class="code e182">node1 == node2</div>) to
                  be sufficient. Modifications to logical nodes are immediately reflected by all Java
                  DOM
                  node instances, because they are reflected in the underlying byte arrays.
               </div>
               <div class="para e183">The amount of work needed for something as simple as retrieving the first child of
                  an
                  element might seem staggering, but the time these bit shift operations take is quite
                  small
                  in practice, as we will show in 
                  <div class="xref e184" linkend="sect.performance"></div>.
               </div><a name="OnDiskLayoutExampleANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e185">
                  <div class="title e186">On Disk Layout Example</div>
                  <div class="para e187">
                     <div class="xref e188" linkend="code.on-disk-layout"></div> shows a simple example document, and the
                     binary representation of the first two elements on disk in the canonical hex formatting.
                     The bytes surrounding the two elements are blanked out as they are of no
                     interest.
                  </div>
                  <div class="para e189">The document root element, 
                     <div class="code e190">&lt;address_list/&gt;</div>, is stored in the five
                     bytes on the first line. The first two bytes, representing the element header, indicate
                     that this is a regular element node with no sibling or attributes, but a first and
                     a
                     last child, the first child being the immediately following node on the page. These
                     bytes are then followed by the parent offset (encoded as 
                     <div class="code e191">01</div>, meaning an
                     offset of -1, i.e. the previous node), the offset of the last child (
                     <div class="code e192">70</div>),
                     and the namebase code of the local name (
                     <div class="code e193">00</div>).
                  </div>
                  <div class="para e194">The document was parsed with the 
                     <div class="code e195">element-content-whitespace</div> option
                     disabled, so the white space characters preceding the first 
                     <div class="code e196">&lt;address/&gt;</div>
                     element were stripped and did not result in a DOM text node.
                  </div>
                  <div class="para e197">The first 
                     <div class="code e198">&lt;address/&gt;</div> element is stored in 8 bytes. The header
                     indicates that all node reference fields are present, except for the previous sibling.
                     This is then followed by the encoded offset of the parent (again, -1), the next sibling
                     (
                     <div class="code e199">1a</div>), the offsets of first and last child (
                     <div class="code e200">04</div> and
                     
                     <div class="code e201">16</div>), the namespace code (
                     <div class="code e202">01</div>), and the offset of the first
                     attribute (
                     <div class="code e203">02</div>, meaning +1).
                  </div>
                  <div class="figure e204" xml:id="code.on-disk-layout">
                     <div class="title e205">On disk layout of a sample document</div>
                     <div class="programlisting e206" xml:space="preserve">&lt;address_list&gt;
                        &lt;address id='1'&gt;
                        &lt;firstname&gt;...&lt;/firstname&gt;
                        ...
                        &lt;/address&gt;
                        ...
                        &lt;/addresslist&gt;
                        
                        0001e0d0  __ __ __ __ __ __ __ __  __ __ __ 
                        <div class="emphasis e207">15 ff 01 70 00</div>  |ttmjtu2/ynm...p.|
                        0001e0e0  
                        <div class="emphasis e208">10 7f 01 1a 04 16 01 02</div>  __ __ __ __ __ __ __ __  |........?...B...|
                     </div>
                  </div>
                  <div class="para e209">The root element 
                     <div class="code e210">&lt;address_list/&gt;</div> consumes 29 bytes of disk storage
                     when stored as regular XML on disk in UTF-8 (opening and closing tag). In xDB's binary
                     format, it shrinks to 5 bytes, plus 4 bytes for the slot information (not shown above),
                     plus a certain amount of storage for the namebase entry which is shared among all
                     elements with the same name. The more complex 
                     <div class="code e211">&lt;address/&gt;</div> element
                     consumes 19 vs 8 bytes. This reduction in size depends on the document and the use
                     of
                     XML features, such as validation and namespaces. However we can see that in particular
                     elements containing predominantly elements will shrink in size.
                  </div>
                  <div class="para e212">The original addresslist XML document consumed 1138 bytes of disk space, 975 bytes
                     with ignorable whitespace removed. The binary document representation consumes 768
                     bytes
                     (within a 4kb page), giving a bloat factor of ~0.78. These numbers can greatly vary
                     from
                     document to document, depending on factors such as namespace use, number of nodes,
                     and
                     so on. The general experience with XML documents is that the bloat factor will typically
                     be around 0.9, giving a 10% compression.
                  </div>
               </div>
            </div>
         </div>
      </div><a name="MemoryConsumptionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e213">
         <div class="title e214">Memory Consumption</div>
         <div class="para e215">As mentioned above, in xDB DOM nodes are only shallow pointers into the data storage.
            The
            data itself is stored in files, and partially paged into memory in a page cache. These
            pages
            are kept in Java byte arrays at runtime and DOM operations directly operate on the
            byte
            arrays. As DOM nodes only indirectly reference these byte arrays, the database engine
            is free
            to evict data pages from the cache and/or load other cache pages in.
         </div>
         <div class="para e216">A JVM running an xDB database server will allocate a fixed amount of memory to the
            xDB
            page cache, similar to other databases. The amount of memory taken is configurable,
            and the
            database can run correctly with only one data page of cache memory. However, again
            like other
            databases, less cache memory means more page faults, which in turn means slower operation.
            The
            ideal amount of memory to allocate for cache pages is difficult to determine, as more
            cache
            memory will mean that less memory is available to the regular Java application code.
            A very
            large cache will thus cause more garbage collection runs, which will again slow down
            the
            application. Depending on the application, the available Java heaps space might even
            get
            exhausted if it is mostly consumed by xDB cache pages. As a rule of thumb, users are
            advised
            to allocate half of the Java heap to the database cache, which works well in most
            cases.
         </div>
         <div class="para e217">xDB's page cache uses a combination of Least Recently Used (LRU) and an aging cache
            scheme. This means that if the cache has to evict a page, it will attempt to first
            evict pages
            that have not been used for a long time, but prefer evicting pages that have been
            used few
            times over pages that have been used frequently. If a user program uses a piece of
            data
            frequently and also scans a large set of data, only referencing every page once, this
            means
            that the cache will not be completely overwritten by the large scan.
         </div>
         <div class="para e218">Beyond the amount of memory allocated for the page cache, xDB itself uses some memory
            for
            internal data structures like the cache itself, administrative data for background
            threads,
            and so on. The amount of memory used for these data structures is however fixed, and
            not
            proportional to the size of documents or other structures contained in the library.
            A full xDB
            database server can run in a JVM with 16 megabytes of RAM allocated to it.
         </div>
         <div class="para e219">Because xDB does not force DOM structures to stay in memory, applications can perform
            DOM
            operations on documents of effectively arbitrary size. However it is still possible
            to write
            the user application in a way that causes memory exhaustion. For example, a program
            traversing
            a large document and adding all DOM nodes it encounters to a data structure will exhaust
            memory, because it keeps the individual DOM node objects from being garbage collected.
            Our
            experience however shows that such programs are a not common.
         </div>
      </div><a name="ProgrammingModelANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e220">
         <div class="title e221">Programming Model</div>
         <div class="para e222">xDB is a compliant implementation of the W3C DOM level 3 standard. xDB's DOM nodes
            implement the relevant Java interfaces of the 
            <div class="code e223">org.w3c.dom</div> package, including the
            extensions for loading and saving documents (DOM LS).
         </div>
         <div class="para e224">This means that program code written against the familiar classes, such as e.g.
            
            <div class="code e225">org.w3.dom.Element</div>, will work without modification when using xDB. The only
            differences in program code will be in the way the initial Document instance is
            obtained.
         </div>
         <div class="para e226">
            <div class="xref e227" linkend="code.document-reference"></div> shows a sample code snippet operating on an
            xDB-backed DOM. The code first obtains an 
            <div class="code e228">XhiveDriverIf</div>, which is the main Java
            entry point to all xDB operations. After initializing the driver, which will start
            background
            threads and allocate the page cache, the code creates a new 
            <div class="code e229">XhiveSessionIf</div>, which
            represents the context of transactional operations. The code then begins a new transaction,
            retrieves a document that is stored in the database's root library
            <div class="popupBox e230">
               <div class="popupLabel" onmouseover="$('#d1e469').show('1000');" onmouseout="$('#d1e469').hide('1000');">[ footnote ]</div>
               <div id="d1e469" style="display: none;">
                  <div class="footnote">
                     <div class="para e231">xDB databases are structured like UNIX file systems; all documents are contained in
                        libraries, which in turn belong to other libraries, and the complete database is
                        descendant of a root library.
                     </div>
                  </div>
               </div>
            </div>. The object representing the document implements the
            
            <div class="code e232">org.w3c.dom.Document</div> interface. Any program code written for any Java DOM
            implementation can now operate on the document. In particular, XSLT engines that support
            DOM
            documents (i.e. all Java XSLT engines) can transparently perform transformations on
            these
            documents. All changes to the document will be persisted in the 
            <div class="code e233">session.commit()</div>
            call, or rolled back on 
            <div class="code e234">session.rollback()</div>, if the user code throws an unexpected
            exception. Multiple transactions can operate on database and library contents concurrently
            in
            complete isolation. xDB transactions are of serializable isolation level and conform
            to the
            ACID properties.
         </div>
         <div class="figure e235" xml:id="code.document-reference">
            <div class="title e236">Obtaining a Document reference from xDB</div>
            <div class="programlisting e237" xml:space="preserve">XhiveDriverIf driver = XhiveDriverFactory.getDriver("xhive://localhost:1235");
               driver.init();
               XhiveSessionIf session = driver.createSession();
               session.connect("username", "password", "Database");
               session.begin();
               try {
               XhiveLibraryIf rootLibrary = session.getDatabase().getRoot();
               org.w3c.dom.Document document = rootLibrary.get("somedocument.xml");
               // operate on document
               session.commit();
               } finally {
               if (session.isOpen()) session.rollback();
               session.terminate();
               driver.close();  
               }
            </div>
         </div>
         <div class="para e238">xDB locks database contents to avoid concurrent modifications. Locking happens on
            a
            per-document basis; parallel transactions can modify separate documents concurrently,
            but if a
            document is already locked by another transaction, the transaction will block. Deadlocks
            are
            resolved by selecting a victim, whose transaction will be cancelled and rolled back.
         </div>
      </div><a name="PerformanceComparisonsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e239" xml:id="sect.performance">
         <div class="title e240">Performance Comparisons</div>
         <div class="para e241">While the indirection of storage and the bit operations cause a certain overhead,
            performance is comparable to other DOM implementations. Some synthetic benchmarks
            <div class="popupBox e242">
               <div class="popupLabel" onmouseover="$('#d1e495').show('1000');" onmouseout="$('#d1e495').hide('1000');">[ footnote ]</div>
               <div id="d1e495" style="display: none;">
                  <div class="footnote">
                     <div class="para e243">These benchmarks, as all benchmarks, should be taken with a grain of salt. We do not
                        claim that these benchmarks hold much scientific significance or represent performance
                        in
                        your particular XML application. Readers should also be aware that there is always
                        bias if
                        an implementer tests his own implementation. However the results should give a rough
                        impression of the overhead associated with this DOM implementation model.
                     </div>
                  </div>
               </div>
            </div> show that common XML operations take on the order of twice as long in execution as
            in other implementations, while requiring significantly less memory. XSL transformations
            on
            gigabyte-sized XML documents are possible and run in reasonable time.
         </div>
         <div class="para e244">All the following benchmarks have been run on a MacBook Pro 2.8 GHz Core 2 Duo machine
            with 4 GB of DDR3 RAM and a solid state disk drive. The Java implementation was Apple's
            modified distribution of the Sun HotSpot JVM in server mode (
            <div class="code e245">-server</div>), giving 512
            MB of RAM if not otherwise indicated (
            <div class="code e246">-Xmx512M</div>). All times were measured after
            running the benchmark code several times in a warmup phase to account for Just-In-Time
            compilation (JIT). All implementation tests were run in a clean JVM to avoid skewing
            results
            through the effects of class loading and the different compilation results it can
            produce.
            After warmup, individual benchmarks were run 100 times (except for the long running
            large XSLT
            transformation tests, which were run 10 times each); results are given as the average
            runtime
            with standard deviation.
         </div>
         <div class="para e247">The three implementations used were Saxon 9.2.0.6 Home Edition, xDB 10.0.0, Xerces
            2.10.0,
            and Xalan 2.7.1.
         </div><a name="ParsingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e248">
            <div class="title e249">Parsing</div>
            <div class="para e250">An important performance benchmark in XML processing is parsing XML documents. In
               this
               benchmark, we parsed a 20 MB XML document of Wikipedia article titles, URLs, abstracts,
               and
               links. The document has a relatively simple, flat structure, with an element for every
               document that has several children for the document's details.
            </div>
            <div class="table e251">
               <div class="caption e252">
                  <div class="para e253">Parsing a 20 MB XML document</div>
               </div>
               <div class="thead e254">
                  <div class="tr e255">
                     <div class="th e256">Implementation</div>
                     <div class="th e257">Average Runtime (ms)</div>
                     <div class="th e258">Standard Deviation (ms)</div>
                  </div>
               </div>
               <div class="tbody e259">
                  <div class="tr e260">
                     <div class="td e261">Saxon</div>
                     <div class="td e262">696</div>
                     <div class="td e263">45</div>
                  </div>
                  <div class="tr e264">
                     <div class="td e265">xDB</div>
                     <div class="td e266">1388</div>
                     <div class="td e267">8</div>
                  </div>
                  <div class="tr e268">
                     <div class="td e269">xDB (-Xmx64M)</div>
                     <div class="td e270">1565</div>
                     <div class="td e271">7</div>
                  </div>
                  <div class="tr e272">
                     <div class="td e273">Xerces</div>
                     <div class="td e274">624</div>
                     <div class="td e275">98</div>
                  </div>
               </div>
            </div>
            <div class="para e276">xDB's parser and DOM implementation take about twice as long to parse a document,
               probably due to the conversions necessary for xDB's internal storage. The lower standard
               deviation compared to the other two implementations is most likely because xDB creates
               less
               objects in memory, and thus is affected less by Java garbage collection.
            </div>
            <div class="para e277">Reducing the available memory to 64 megabytes, the other two implementations failed
               parsing the document due to memory exhaustion. xDB's parsing time increases, as the
               parsed
               document will no longer easily fit the available cache memory and parts have to be
               paged
               out. If we increase document size further or decrease available memory more, the parsing
               process will be effectively limited by the throughput of the hard disk.
            </div>
            <div class="para e278">More thorough scalability tests of xDB XML parsing can be found in a whitepaper by
               Jeroen van Rotterdam (
               <div class="xref e279" linkend="bib.xdbperformance"></div>)
            </div>
         </div><a name="DOMnavigationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e280">
            <div class="title e281">DOM navigation</div>
            <div class="para e282"> In this test, we walk the document from the parsing test using DOM navigation, or
               in
               the case of Saxon using it's XDM data model. The tests performs an in-order visit
               of all
               nodes in the document, retrieving text values for attributes and text nodes, and node
               names
               for nodes that have a name (elements, attributes, processing instructions). The numbers
               for
               Saxon are not entirely comparable, as the code uses a different document object model
               to
               achieve the same task. Document parsing time is not included in the numbers.
            </div>
            <div class="table e283">
               <div class="caption e284">
                  <div class="para e285">Walking a 20 MB XML DOM</div>
               </div>
               <div class="thead e286">
                  <div class="tr e287">
                     <div class="th e288">Implementation</div>
                     <div class="th e289">Average Runtime (ms)</div>
                     <div class="th e290">Standard Deviation (ms)</div>
                  </div>
               </div>
               <div class="tbody e291">
                  <div class="tr e292">
                     <div class="td e293">Saxon</div>
                     <div class="td e294">78.6</div>
                     <div class="td e295">1.1</div>
                  </div>
                  <div class="tr e296">
                     <div class="td e297">xDB</div>
                     <div class="td e298">204.2</div>
                     <div class="td e299">0.8</div>
                  </div>
                  <div class="tr e300">
                     <div class="td e301">xDB (-Xmx64M)</div>
                     <div class="td e302">348.9</div>
                     <div class="td e303">0.8</div>
                  </div>
                  <div class="tr e304">
                     <div class="td e305">Xerces</div>
                     <div class="td e306">95.8</div>
                     <div class="td e307">0.4</div>
                  </div>
               </div>
            </div>
            <div class="para e308">Again, processing takes about twice as long on xDB's DOM implementation. Runtime
               increases slightly with constrained memory.
            </div>
         </div><a name="XSLtransformationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e309">
            <div class="title e310">XSL transformation</div>
            <div class="para e311">In this test, we transform the aforementioned document using a simple XSLT 1.0
               stylesheet. We use the Saxon and Xalan XSLT implementations, both on their native
               DOM
               implementations (Xerces for Xalan), and both on xDB's DOM implementation.
            </div>
            <div class="para e312">We can again see that xDB's DOM is slower than the XSLT processor's native
               implementations, but again the overhead is tolerable. Saxon performs slightly worse
               than
               Xalan on xDB's DOM; initial investigation suggest this might be due to Saxon's DOM
               driver
               that operates on DOM node lists, which are computationally expensive as they have
               to be live
               lists, directly reflecting any changes in the parent node. This is problematic in
               an
               implementation such as xDB, where single logical DOM nodes can be represented by many
               different objects. In addition, xDB does not maintain a list with all children of
               a node, so
               that indexed access to a child within a DOM list is not O(1) in all cases.
            </div>
            <div class="table e313">
               <div class="caption e314">
                  <div class="para e315">XSLT transformation of a 20 MB XML document</div>
               </div>
               <div class="thead e316">
                  <div class="tr e317">
                     <div class="th e318">Implementation</div>
                     <div class="th e319">Average Runtime (ms)</div>
                     <div class="th e320">Standard Deviation (ms)</div>
                  </div>
               </div>
               <div class="tbody e321">
                  <div class="tr e322">
                     <div class="td e323">Saxon</div>
                     <div class="td e324">90</div>
                     <div class="td e325">6</div>
                  </div>
                  <div class="tr e326">
                     <div class="td e327">xDB (Xalan)</div>
                     <div class="td e328">160</div>
                     <div class="td e329">4</div>
                  </div>
                  <div class="tr e330">
                     <div class="td e331">xDB (Saxon)</div>
                     <div class="td e332">251</div>
                     <div class="td e333">10</div>
                  </div>
                  <div class="tr e334">
                     <div class="td e335">Xalan (Xerces)</div>
                     <div class="td e336">155</div>
                     <div class="td e337">17</div>
                  </div>
               </div>
            </div>
            <div class="para e338">We performed the same test on an identically structured document of 900 MB. Neither
               Saxon nor Xalan were able to parse the document, even with 3.5 GB of memory available.
               Running Xalan on xDB exhausted memory as well, as the implementation appears to copy
               some of
               the DOM structure into it's own data structures, exhausting memory in the process.
            </div>
            <div class="para e339">Running Saxon on top of xDB's DOM implementation managed to transform the document
               in
               reasonable time. Both with a large (512 MB) and a small heap (64 MB), the document
               was
               transformed in less than a minute. Available memory has no noticeable impact on performance;
               runtime is effectively limited by IO throughput as xDB loads cache pages from the
               disk. This
               also explains the supra-linear runtime growth from 250 ms for a 20 MB document to
               45 seconds
               for a 900 MB document; the first test exclusively uses heap memory, while the second
               test is
               limited at least in part by disk performance.
            </div>
            <div class="table e340">
               <div class="caption e341">
                  <div class="para e342">XSLT transformation of a 900 MB document using Saxon on an xDB DOM with different
                     Java heap sizes
                  </div>
               </div>
               <div class="thead e343">
                  <div class="tr e344">
                     <div class="th e345">Available JVM Heap Memory</div>
                     <div class="th e346">Average Runtime (seconds)</div>
                     <div class="th e347">Standard Deviation (seconds)</div>
                  </div>
               </div>
               <div class="tbody e348">
                  <div class="tr e349">
                     <div class="td e350">64 MB</div>
                     <div class="td e351">47</div>
                     <div class="td e352">1</div>
                  </div>
                  <div class="tr e353">
                     <div class="td e354">512 MB</div>
                     <div class="td e355">45</div>
                     <div class="td e356">2</div>
                  </div>
               </div>
            </div>
            <div class="para e357">Interestingly, runtime profiling of these simple XSLT transformations shows that
               significant time (15-20%) is spent looking up element names by their namebase code.
               This
               could be entirely avoided if the DOM API provided an interface to create an implementation
               specific node name matcher. That would not only allow us to avoid the namebase lookup
               but
               also reduce relatively expensive string comparisons on node names to integer comparisons
               on
               namebase codes in xDB's case.
            </div>
         </div><a name="DiscussionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e358">
            <div class="title e359">Discussion</div>
            <div class="para e360">The benchmark results show that xDB's hard-disk backed DOM implementation is slower
               than
               alternative main memory based implementations for small document sizes. On the other
               hand,
               our scheme makes it possible to handle documents of sizes that simply cannot be processed
               using main memory implementations. Beyond that, xDB ofcourse offers many other database
               features that might be useful to users.
            </div>
            <div class="para e361">The fact that xDB performs well compared to a DOM implementation such as Xerces might
               be
               surprising, given that, when navigating to the first child of an element, a Xerces
               DOM node
               can simply return the value of a field (or the first value of an array) where xDB
               has to
               perform a whole series of bit manipulations. We believe that this is an effect of
               a modern
               processor's memory hierarchy. As CPU internal caches and clock rates are significantly
               faster than main memory access, modern CPUs spend most of their clock cycles waiting
               for
               memory to be loaded into the CPU's cache (
               <div class="xref e362" linkend="bib.manegoldmemory"></div>, 
               <div class="xref e363" linkend="bib.cacheconcious"></div>). xDB's compact storage layout sacrifices several CPU
               operations for reduced memory use, but those CPU operations can execute in the time
               a CPU
               would normally spend waiting for memory to be loaded. Because related nodes are allocated
               in
               contiguous byte arrays, it is also more likely that the CPU already holds the memory
               location for the next node in a cache line.
            </div>
            <div class="para e364">Note that these benchmarks assume a document that is parsed once to be processed,
               and
               then discarded. In real world applications, documents will often be processed many
               times.
               Because of its persistent storage, xDB can avoid re-parsing documents over and over
               again,
               giving substantial benefits for such applications.
            </div>
         </div>
      </div><a name="ConclusionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e365">
         <div class="title e366">Conclusion</div>
         <div class="para e367"></div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e368">
         <div class="title e369">Bibliography</div>
         <div class="bibliomixed e370" xml:id="bib.pengchwathe" xreflabel="Peng05">F Peng, S S Chawathe: XSQ: A Streaming
            XPath Engine. ACM Trans. Database Syst (2005). doi: 
            <div class="biblioid doi e371">10.1145/1071610.1071617</div>
         </div>
         <div class="bibliomixed e372" xml:id="bib.florescuhillery" xreflabel="Florescu03">Daniela Florescu, Chris
            Hillery, Donald Kossmann, Paul Lucas, Fabio Riccardi, Till Westmann, Michael J. Carey,
            Arvind
            Sundararajan, Geetika Agrawal: The BEA Streaming XQuery Processor. The VLDB Journal
            (2003)
         </div>
         <div class="bibliomixed e373" xml:id="bib.stx" xreflabel="STX">Streaming Transformations for XML. Homepage, on
            the web at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e374" xlink:actuate="onRequest" xlink:href="http://stx.sourceforge.net/" xlink:show="new" xlink:type="simple">http://stx.sourceforge.net/</div>
         </div>
         <div class="bibliomixed e375" xml:id="bib.xslt21" xreflabel="Kay10">Michael Kay: XSL Transformations (XSLT) 2.1.
            World Wide Web Consortium Working Draft (2010), on the web at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e376" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt-21/" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-21/</div>
         </div>
         <div class="bibliomixed e377" xml:id="bib.ordpath" xreflabel="ONeil04">P. O’Neil, E. O’Neil, S. Pal, I. Cseri, G.
            Schaller, and N. Westbury. ORDPATH: Insert-Friendly XML Node Labels. SIGMOD,
            2004. doi: 
            <div class="biblioid doi e378">10.1145/1007568.1007686</div>
         </div>
         <div class="bibliomixed e379" xml:id="bib.exist" xreflabel="Meier02">Wolfgang Meier: eXist: An Open Source Native
            XML Database. NODe Workshop (2002) 
         </div>
         <div class="bibliomixed e380" xml:id="bib.manegoldmemory" xreflabel="Manegold00">Manegold, S., Boncz, P.A., and
            Kersten, M.L: Optimizing database architecture for the new bottleneck: memory access.
            VLDB
            Journal (2000)
         </div>
         <div class="bibliomixed e381" xml:id="bib.cacheconcious" xreflabel="Chilimbi99">T. M. Chilimbi, B. Davidson J. R.
            Larus: Cache-conscious structure layout. ACM Sigplan Notices (1999). doi: 
            <div class="biblioid doi e382">10.1145/301631.301633</div>
         </div>
         <div class="bibliomixed e383" xml:id="bib.xmlshred" xreflabel="Tatarinov02">I. Tatarinov, S. D. Viglas, K. Beyer,
            J. Shanmugasundaram, E. Shekita, C. Zhang: Storing and Querying Ordered XML Using
            a Relational
            Database System. SIGMOD (2002). doi: 
            <div class="biblioid doi e384">10.1145/564691.564715</div>
         </div>
         <div class="bibliomixed e385" xml:id="bib.xdbperformance" xreflabel="vanRotterdam09">J. van Rotterdam: EMC
            Documentum xDB 9.0 Scalability Tests. Whitepaper, on the web at 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e386" xlink:actuate="onRequest" xlink:href="http://www.emc.com/collateral/software/white-papers/h4662-xdb-performance-wp.pdf" xlink:show="new" xlink:type="simple">http://www.emc.com/collateral/software/white-papers/h4662-xdb-performance-wp.pdf</div>
         </div>
      </div>
   </div>
</div>