<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#DITADocumentTypes:EnablingBlindInterchangeThroughModularVocabulariesandControlledExtensionANCHOR" name="DITADocumentTypes:EnablingBlindInterchangeThroughModularVocabulariesandControlledExtensionTOC">DITA Document Types: Enabling Blind Interchange Through Modular Vocabularies and Controlled
               Extension</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#WhyTraditionalApproachestoInterchangeDoNotWorkANCHOR" name="WhyTraditionalApproachestoInterchangeDoNotWorkTOC">Why Traditional Approaches to Interchange Do Not Work</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DITA'sApproach:ModularVocabularyCompositionandControlledExtensionANCHOR" name="DITA'sApproach:ModularVocabularyCompositionandControlledExtensionTOC">DITA's Approach: Modular Vocabulary Composition and Controlled Extension</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#DocumentTypesareUniqueSetsofModulesANCHOR" name="DocumentTypesareUniqueSetsofModulesTOC">Document Types are Unique Sets of Modules</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#VocabularyExtensionthroughSpecializationANCHOR" name="VocabularyExtensionthroughSpecializationTOC">Vocabulary Extension through Specialization</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ReuseandDocumentTypeCompatibilityANCHOR" name="ReuseandDocumentTypeCompatibilityTOC">Reuse and Document Type Compatibility</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#DITASelfDescriptionandProcessingANCHOR" name="DITASelfDescriptionandProcessingTOC">DITA Self Description and Processing</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ApplyingtheDITAApproachMoreWidelyANCHOR" name="ApplyingtheDITAApproachMoreWidelyTOC">Applying the DITA Approach More Widely</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">almost</div>
         <div class="singletermTERMS">and clearly report</div>
         <div class="singletermTERMS">and</div>
         <div class="singletermTERMS">August 2 - 5, 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">because it was in XML</div>
         <div class="singletermTERMS">blind</div>
         <div class="singletermTERMS">blindly</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">documentation</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">Eliot</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">ideas</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Kimber</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">less</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">required</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">something</div>
         <div class="singletermTERMS">Senior Solutions Architect</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">topic</div>
         <div class="singletermTERMS">topic/p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="DITADocumentTypes:EnablingBlindInterchangeThroughModularVocabulariesandControlledExtensionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3" xml:id="Bal2011kimb0304">
      <div class="title e1">DITA Document Types: Enabling Blind Interchange Through Modular Vocabularies and Controlled
         Extension
      </div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2011</div>
            <div class="confdates e5">August 2 - 5, 2011</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Interchange of XML documents depends in large part on the use of "compatible" vocabularies
               of element types and attributes, where "compatible" means "understandable and processable
               by all parties involved in the interchange". The traditional SGML and XML approach
               to interchange used "interchange" document types that defined a fixed set of element
               types and attributes to which all interchange parties agreed. History has demonstrated
               conclusively that this approach does not work. The DITA standard, which is expressly
               designed to enable blind interchange of DITA documents over the wisest possible scope,
               avoids this failure by turning the problem around. Rather than making the unit of
               vocabulary definition the document type and then allow unconstrained extension to
               it, it makes the units of vocabulary definition invariant modules which are combined
               by documents to form complete document types. Extension is allowed through two controlled
               facilities: constraint modules and specialization. The constraint and specialization
               facilities serve to ensure two preconditions for blind interchange: (1) All DITA documents
               are inherently and reliably processable to some degree by all general-purpose DITA
               processors irrespective of the markup details and (2) non-general-purpose DITA processors
               can quickly determine, from document instances alone, whether or not a given document
               may contain elements and attributes it does not know how to process. It is this aspect
               of DITA that distinguishes it from all other XML applications and in particular from
               traditional "interchange" document types based on monolithic DTDs that allow unconstrained
               (and unconstrainable) extension and customization. This paper presents the details
               of the DITA vocabulary and constraint module system and how that mechanism serves
               to ensure smooth and reliable blind interchange of documents. It makes the argument
               that the DITA vocabulary module and constraint approach, if not the DITA-specific
               implementation details, could be applied to any markup application domain and thus
               to any tag set.
            </div>
         </div>
         <div class="author e8">
            <div class="personname e9">
               <div class="firstname e10">Eliot</div>
               <div class="surname e11">Kimber</div>
            </div>
            <div class="personblurb e12">
               <div class="para e13">Eliot Kimber has been working with generalized markup for more than 25 years. He was
                  a founding member of the XML Working Group, an editor of the HyTime standard (ISO/IEC
                  10744:1992), and a founding and continuing voting member of the OASIS DITA Technical
                  Committee. For the last few years Eliot's focus has been on applying DITA to the information
                  representation and management challenges of professional publishers. Eliot writes
                  and speaks regularly on XML and related topics.
               </div>
            </div>
            <div class="affiliation e14">
               <div class="jobtitle e15">Senior Solutions Architect</div>
               <div class="orgname e16">Really Strategies, Inc.</div>
            </div>
         </div>
         <div class="legalnotice e17">
            <div class="para e18">Copyright © 2011 W. Eliot Kimber</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e19">
         <div class="title e20">Introduction</div>
         <div class="para e21">SGML and XML have always been about interchange, starting with the business problem
            of interchanging typesetting data sets between publishers and printers and evolving
            into the promise that document data could be interchanged widely among different users
            of the data 
            <div class="emphasis e22" role="ital">because it was in XML</div>. 
         </div>
         <div class="para e23">The implicit, and sometimes explicit, promise, or at least vision, of SGML and, later,
            XML, was 
            <div class="emphasis e24">blind</div> interchange: the ability for one party of an interchange to use data provided by
            the other party using only the information in the document itself along with shared
            common knowledge, such as understanding of the standards to which the data conforms,
            without the need for any additional knowledge to be directly communicated from the
            sending party to the receiving party. In other words, the sending party can, for example,
            make data available for licensing to anyone who wants to license it and licensees
            can get the data knowing that they will be able to use it immediately, without the
            need to adapt either the data or their processing infrastructure to accommodate the
            data received.
         </div>
         <div class="para e25">This vision has gone largely unrealized because the SGML and XML community had not
            devised a way to allow local definition of specific vocabulary while ensuring both
            understandability and processability of data. You could either have precise markup
            optimized for local requirements or you could have general-purpose markup that could
            be processed by many potential consumers, but you couldn't have both. This was, and
            continues to be, a problem that limits the value of XML because it adds significant
            cost to the use of XML where interchange is a requirement (and interchange is always
            a requirement, even if that interchange is with only with your future self). An obvious
            example of this cost is the complex system of validation and data normalization transforms
            created and maintained by PubMed Central in order to manage the publishing of journal
            articles from many publishers into the PubMed repository. This cost is entirely avoidable.
         </div>
         <div class="para e26">The DITA architecture provides a general way of thinking about and using modular vocabulary
            that enables interchange at the lowest cost (and lowers the cost of new vocabulary
            development and support of that vocabulary) in a way that no other standard for XML
            documentation does. 
         </div>
         <div class="para e27">DITA's general approach could be adapted to other XML vocabulary domains and thus
            give them the same advantages. As discussed in the last section of this paper, while
            it is technically possible to apply DITA-based markup to essentially any set of documentation
            structuring requirements, there are many reasons why that is not going to be a viable
            solution for many communities. But DITA's architectural 
            <div class="emphasis e28">ideas</div> can, and I assert should, be applied to non-DITA-based XML vocabularies in order
            to realize the same value that DITA provides in terms of reducing the cost of interchange
            and generally minimizing the cost of using XML. That is, I am not suggesting that
            DITA is the solution for everyone, I am only suggesting that DITA's way of thinking
            about document types and vocabularies is powerful and interesting and useful. I am
            asserting that DITA's approach to enabling interchange works where no other approach
            does. 
         </div>
         <div class="para e29">In this paper, the term "community of interchange" means the expected set of partners
            involved in the interchange of a specific set of documents or document types. Different
            communities have different scopes, from small communities limited to a few authors
            or products within a small software company all the way to essentially unbounded scopes,
            such as all potential users of journal articles. 
         </div>
         <div class="para e30">From a business standpoint, my day-to-day concern is with the business challenge of
            very wide scope interchange as done or desired by Publishers, where the value of a
            given unit of content is determined largely by the number of different consumers who
            are willing to buy it or the number of different channels through which it can be
            published. From this standpoint, the cost of interchange is an important determiner
            of overall value of Publisher's primary business output, information. The less it
            costs others to acquire and use the content, the greater the value of that content
            and the larger the potential market for it.
         </div>
         <div class="para e31">This paper focuses in particular on "blind" interchange. By blind interchange I mean
            interchange that requires the least amount of pre-interchange negotiation and knowledge
            exchange between interchange partners. In the ideal scenario, Parter A is able to
            say to Partner B "here is data in format X, a format we both know and understand"
            and Partner B is able to reliably and productively use the data from Parter A in non-trivial
            ways without the need for any more communication with Parter A.
         </div>
      </div><a name="WhyTraditionalApproachestoInterchangeDoNotWorkANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e32">
         <div class="title e33">Why Traditional Approaches to Interchange Do Not Work</div>
         <div class="para e34">SGML introduced the formal "document type definition" (DTD), which allowed communities
            of interchange to define sets of elements that would be allowed in the documents used
            by that community. Because DTDs are formal, machine-processable definitions, documents
            could be validated against a document type to determine conformance to the rules of
            the document type. The general assumption or hope or implication was that documents
            that conformed to a given DTD would then be reliably interchangeable within the community.
         </div>
         <div class="note e35">
            <div class="para e36">In this document I use the term "DTD" as shorthand for "any declarative document constraint
               language or grammar", including DTDs, XSDs, and RelaxNG, unless otherwise specified.
            </div>
         </div>
         <div class="para e37">This approach to interchange does not work and cannot work because it is too simplistic.
            It ignores a number of factors that serve to impede interchange over any non-trivial
            scope, including:
            <div class="itemizedlist e38">
               <div class="listitem e39">
                  <div class="para e40">No fixed set of element types can ever satisfy all the requirements of all participants,
                     for at least two reasons:
                     <div class="orderedlist e41">
                        <div class="listitem e42">
                           <div class="para e43">The set of requirements across all participants is always greater than the time available
                              for analysis and implementation. That is, at some point you have to draw a line and
                              say "good enough" and get something working.
                           </div>
                        </div>
                        <div class="listitem e44">
                           <div class="para e45">New requirements always appear, meaning that even if (1) was not true, there would
                              always be times when new requirements had yet to be analyzed and implemented.
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="listitem e46">
                  <div class="para e47">DTD validation is not sufficient to enforce all important rules to which documents
                     must conform. Thus there will always be processing or business processes that depend
                     on data rules that cannot be enforced by DTDs. This applies to any non-procedural
                     document constraint mechanism, including XSDs, RelaxNG schemas, and so on.
                     <div class="popupBox e48">
                        <div class="popupLabel" onmouseover="$('#d1e82').show('1000');" onmouseout="$('#d1e82').hide('1000');">[ footnote ]</div>
                        <div id="d1e82" style="display: none;">
                           <div class="footnote">
                              <div class="para e49">Procedural constraints (that is, validation applications) can of course check arbitrary
                                 rules given implementation time, but, as processors, validation applications suffer
                                 the same problem as any other processing component in an XML processing system: they
                                 are sensitive to the markup details and therefore cannot reliably work for unknown
                                 document types in the absence of something like DITA's specialization facility. 
                              </div>
                           </div>
                        </div>
                     </div> 
                  </div>
               </div>
               <div class="listitem e50">
                  <div class="para e51">Parties to interchange seldom, if ever, author their content in exactly the form in
                     which it will be interchanged. Most enterprises have some need for internal-use-only
                     markup of some sort, such as for proprietary information that isn't shared or markup
                     that is specific to internal business processes or information systems. This means
                     that there will almost always be a difference between document types as used within
                     the private scope of an interchange partner and document types as used for exchange.
                     This implies the need for a way to express and maintain the relationship between the
                     internal-use markup rules and the interchange markup rules, ideally in a machine-readable
                     and processable form.
                  </div>
               </div>
               <div class="listitem e52">
                  <div class="para e53">There is a tension between simplicity of markup design and precision of semantic identification.
                     XML's value derives at least in part from its ability to bind semantic labels to information
                     as precisely as required. However, the more element types you have (increased semantic
                     precision), the more complicated the document type becomes, increasing the cost of
                     learning, using, supporting, and maintaining it. In addition, more element types increases
                     the opportunity to do the same thing in different ways. Likewise, trying to maintain
                     simplicity by keeping element types generic can make it harder to know how to mark
                     up specific kinds of information, leading to inconsistent practice for the same type
                     of information. In the context of interchange, where an interchange DTD must be the
                     union of the requirements of the interchange partners, the sheer size of the resulting
                     document type tends to weigh heavily in favor of generality in order to avoid the
                     complexity cost of having a huge number of more-precise element types or the analysis
                     cost of determining a set of more-precise element types that reasonably satisfy the
                     requirements of all interchange partners.
                  </div>
               </div>
               <div class="listitem e54">
                  <div class="para e55">Because DOCTYPE declarations are properties of documents, there is no way to guarantee
                     that a document that points to a particular external declaration set by use of a particular
                     public identifier or URN or absolute URL does not either add new element types and
                     attribute unilaterally or otherwise reconfigure the base declarations through local
                     parameter entities. Using a particular public or system ID for the external declaration
                     set does not guarantee that the actual declarations used match any other copy of the
                     declaration set. This means that DOCTYPE declarations, in particular, cannot be relied
                     upon to indicate what may or may not be encountered in a given document. XSD schemas
                     and other constraint mechanisms that are not part of the document itself are a bit
                     better, in that a document cannot unilaterally modify an XSD or RelaxNG schema used
                     by reference.
                  </div>
               </div>
               <div class="listitem e56">
                  <div class="para e57">XML, unlike SGML, does not require the use of DOCTYPE declarations or any other document
                     grammar definition or constraint definition (XSD schema, RelaxNG schema, etc.). Thus,
                     systems should be architected so as to accommodate documents that do not themselves
                     explicitly contain or point to some sort of schema. In SGML that was at least the
                     requirement that a document declare some sort of document type, even if it was actually
                     meaningless and unreliable to do so. XML correctly abandoned that notion. But it means
                     that it must be possible for a document to carry all of the information needed for
                     a processor to associate the appropriate typing and constraint checking to the document.
                     Namespaces can partly serve this but are not sufficient because a namespace declaration
                     tells you nothing about the vocabulary to which that namespace might be bound (and
                     namespaces were never intended to do so). Namespaces simply serve to make names globally
                     unique and, as a side effect, provide the opportunity of associating schemas with
                     elements by locally associating schemas with namespaces. But that namespace-to-schema
                     association is entirely a property of the local processing environment—it is not a
                     property of the document itself.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e58">In short, the idea that you could define single DTDs for non-trivial documents that
            would then enable blind interchange was naive at best and disingenuous at worst. The
            SGML and XML community has proven through painful experience that monolithic "interchange"
            DTDs simply do not work to enable smooth, blind interchange. Interchange can be done
            but at significant cost and impedance. With transforms and documentation and countless
            person hours spent in analysis and DTD design, people have been able to get documents
            interchanged but not in a way that could be in any way characterized as "blind". In
            general where interchange has been made to work, it has involved some combination
            of:
            <div class="itemizedlist e59">
               <div class="listitem e60">
                  <div class="para e61">Limiting the specificity of markup such that the DTD can be reasonably documented
                     and implemented but the markup lacks the precision needed for many requirements, including
                     both important semantic distinctions as well as DTD-level enforcement of rules.
                  </div>
               </div>
               <div class="listitem e62">
                  <div class="para e63">Limiting the scope of the markup to limit the size and complexity of the document
                     type, necessarily creating gaps between requirements of individual interchange partners
                     and the interchange DTD.
                  </div>
               </div>
               <div class="listitem e64">
                  <div class="para e65">Building complex and expensive-to-maintain validation applications that attempt to
                     check rules that cannot be enforced by the DTD (because of the generality constraint).
                  </div>
               </div>
               <div class="listitem e66">
                  <div class="para e67">Building complex and expensive-to-maintain data cleanup or data transformation systems
                     that attempt to normalize data from different sources into a single consistent form.
                  </div>
               </div>
               <div class="listitem e68">
                  <div class="para e69">Either disallowing all extension to ensure 100% consistency of markup across documents
                     (S1000D) or allow unconstrained extension (DocBook, NLM, etc.). In the first case
                     either the DTD must grow to be a true union of all known requirements or some participants
                     will necessarily not have important requirements met, usually forcing these partners
                     to use a custom DTD internally in order to meet local requirements. In the second
                     case, the use of extended DTDs is essentially the same as the use of arbitrary custom
                     DTDs as there is no way to know how any two extensions relate either to each other
                     or to the base DTD simply by inspection of either the DTD declarations or document
                     instances. 
                  </div>
               </div>
            </div>
         </div>
         <div class="para e70">All of these reactions tend to limit the utility of interchange DTDs relative to the
            cost of simply mapping to and from the individual document types of the various interchange
            partners. Where interchange has been made to work at all it is usually because one
            of the trading partners has a significantly more powerful role relative to the other
            partners, for example Boeing or Airbus relative to their suppliers or PubMed Central
            relative to individual publishers. These large players can both impose constraints
            and business rules and also fund and maintain the tooling needed to enable interchange.
         </div>
         <div class="para e71">But where the interchange community does not have such a major player, then the value
            of the interchange DTD is much lower. The example here would be DocBook, where you
            have many relatively small users using DocBook with no single large player imposing
            some particular consistency of use across the many users of DocBook. Because DocBook
            both reflects a wide range of requirements and a general approach of generality over
            specificity, the range of application of DocBook to the same information challenge
            is quite wide. In addition, DocBook allows unilateral and unconstrained extension
            from the base DocBook DTD. This means that there is no formal or automatic way to
            know how any two DocBook-based documents relate to each other. (To be fair, blind
            interchange was never an explicit or primary requirement of DocBook as a standard.)
         </div>
         <div class="para e72">While an invariant monolithic DTD that satisfies all requirements of all interchange
            partners would enable this form of blind interchange, it is obvious that such a DTD
            is impossible in practice. Likewise, unconstrained extension as provided by DTDs like
            DocBook and NLM don't enable blind interchange because at a minimum Partner A has
            to transmit knowledge to Partner B about how Partner A's DTD differs from the base
            standard and, quite likely, provide processing components for processing that content.
            At that point, there is no useful difference between using the standard for interchange
            and using arbitrary DTDs, as the difference is only one of degree, not kind (do I
            have to transmit a lot of knowledge or a little knowledge?): in both cases you have
            to describe the markup details and, usually, provide supporting code or, lacking code,
            impose on Partner B the cost of implementing support for the new or different markup.
            Likewise, there is no guarantee that the data from Partner A will be composable with
            the data from Partner B such that B could re-use data elements from A directly in
            their existing documents, either by copy or by reference. 
         </div>
      </div><a name="DITA'sApproach:ModularVocabularyCompositionandControlledExtensionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e73">
         <div class="title e74">DITA's Approach: Modular Vocabulary Composition and Controlled Extension</div>
         <div class="para e75">The DITA approach flips the solution around. Rather than attempting to enable interchange
            by imposing constraints top-down through a monolithic document type that attempts
            to reflect the union of known requirements that can be met within the scope available,
            it imposes constraints bottom up in a way that enables local extension and configuration
            while ensuring that all conforming DITA documents can be usefully and reliably processed
            by all conforming general-purpose DITA processors. In the best case, interchange among
            partners requires nothing beyond the agreement to use conforming DITA documents. In
            the usual case, partners only need to interchange knowledge of locally-defined markup
            where that markup is of interest to the receiving partner and only need to interchange
            supporting processing where the locally-defined markup requires unique processing
            (that is, its semantic distinction also implies or requires a processing distinction
            of some sort).
         </div>
         <div class="para e76">DITA does this by moving the focus from document types to vocabulary "modules" assembled
            or composed into distinct document types, coupled with two controlled extension mechanisms:
            constraints and specialization. 
         </div>
         <div class="para e77">DITA defines a general architecture to which all DITA documents must conform and from
            which all DITA vocabulary must be derived. However, DITA does not limit the ability
            to define new vocabulary or combine existing vocabulary modules together in new ways,
            as long as the new vocabulary or module combination conforms to a few constraints.
         </div>
         <div class="para e78">A document is a conforming DITA document if the vocabulary it uses conforms to the
            DITA architecture, irrespective of the specific element types used in the document.
            There is no sense in which DITA defines "a" document type. Rather, it enables an infinite
            set of interoperable document types based on a base architectural model. It also enables
            automatic comparison of document types to determine "compatibility" and therefore
            the degree to which content from one DITA document may be directly used by reference
            from another DITA document.
         </div>
         <div class="para e79">All DITA vocabulary is based on a small set of base types that define the basic structural
            and semantic rules for DITA documents. The base types are sufficiently general to
            allow 
            <div class="emphasis e80">almost</div> unconstrained variation in how they are adapted to specific markup requirements so
            that there will always be a way to meet any reasonable markup requirement. In order
            to make the mechanism work the DITA architecture must impose a few arbitrary rules
            but those rules are not particularly limiting.
         </div>
         <div class="para e81">While the DITA standard defines a number of vocabulary modules in addition to the
            base DITA types, these modules are not mandatory (no conforming DITA document is required
            to use or reflect any of these modules). Likewise, the various document type definitions
            defined by the DITA standard or provided by the DITA Technical Committee are not mandatory
            and simply serve as examples or convenience for DITA users. So while the DITA standard
            may appear at first glance like just another monolithic DTD standard, it is absolutely
            not one.
         </div><a name="DocumentTypesareUniqueSetsofModulesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e82">
            <div class="title e83">Document Types are Unique Sets of Modules</div>
            <div class="para e84">In DITA a "document type" is nothing more or less than a unique set of vocabulary
               and constraint modules. Each DITA document declares, through an attribute on the document
               element (
               <div class="code e85">@domains</div>), what set of modules it uses. Two documents that declare the use of the same set
               of modules have the same document type. DITA does not require the use of any particular
               schema technology nor does it require the use of any particular document constraint
               specification or grammar. That is, DITA does not require the use of DOCTYPE declarations
               or XSD schemas or any other form of formal constraint specification.
            </div>
            <div class="para e86">DITA document types are composed of two types of module: vocabulary modules and constraint
               modules. Both types of module have globally unique names (or at least unique within
               the expected scope of interchange) and are invariant. 
            </div>
            <div class="para e87">Modules are invariant in that modules may not be modified directly, meaning that all
               copies of a given module should define exactly the same set of element types or constraints.
               There is no sense in which a given module may be directly extended in the way that
               say the DocBook or NLM DTDs can be extended. It means that you don't need the actual
               declarations of the module, in whatever schema language they might exist in, you only
               need the 
               <div class="emphasis e88">documentation</div> for the module to know what rules the use of the module implies. Compare this with
               DocBook, where knowing that two documents are "DocBook" documents tells you nothing
               reliable about what rules those two documents reflect, because there is no way to
               know, without inspecting the actual declaration sets used by the two documents, what
               markup rules are actually defined.
            </div>
            <div class="para e89">Vocabulary modules define element types and attributes. Constraint modules define
               modifications to content models and attribute lists in vocabulary modules in order
               to make those content models more constrained than the base. There is no mechanism
               in DITA by which content models can be made 
               <div class="emphasis e90">less</div> constrained than the base model (that is, you cannot unilaterally add new element
               types in places where the type—or its base type—is not already allowed). 
            </div>
            <div class="para e91">This restriction ensures two things:
               <div class="orderedlist e92">
                  <div class="listitem e93">
                     <div class="para e94">All general DITA processors are assured they will never encounter element types they
                        do not understand nor will they encounter combinations of elements that are completely
                        unexpected.
                     </div>
                  </div>
                  <div class="listitem e95">
                     <div class="para e96">For any two documents of the same base type, the elements in the more-constrained
                        document will always be compatible with the elements in the less-constrained document.
                        In the case where both documents have "compatible" document types, the contents of
                        both documents are always compatible with each other.
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e97">Because there can be no surprises about the structures that might be encountered in
               a given DITA document and because vocabulary and constraint modules are invariant
               it is therefore sufficient for documents to simply declare the names of the modules
               they use. There is no direct value in having literal declarations for those modules
               in order to enable processing, only to enable syntactic validation and authoring convenience.
               At least in theory, a DITA processor could have built-in knowledge of all markup details
               for a given set of modules and thus do validation without reference to specific DTD
               or XSD declarations. Of course in practice it's easier to just implement the schema
               using normal XML tools. But it is not 
               <div class="emphasis e98">required</div>.
            </div>
            <div class="para e99">Because of the 
               <div class="code e100">@domains</div> attribute, along with several DITA-defined declaration attributes (
               <div class="code e101">@class</div> chief among them), all conforming DITA documents are completely self-describing with
               regard to the information needed to understand and process those documents in terms
               of their DITA nature and the base semantics defined in the DITA standard. Thus, DITA
               documents do not need any form of document type declaration other than the 
               <div class="code e102">@domains</div> attribute on the root element and 
               <div class="code e103">@class</div> attributes on each element.
            </div>
         </div><a name="VocabularyExtensionthroughSpecializationANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e104">
            <div class="title e105">Vocabulary Extension through Specialization</div>
            <div class="para e106">The modular vocabulary mechanism addresses one part of the interchange problem: How
               to know if you can process or reuse a given document?
            </div>
            <div class="para e107">However, is does not by itself address the problem of how to add new vocabulary in
               a way that does not break existing processing or require communication of new knowledge.
            </div>
            <div class="para e108">DITA addresses this second problem through the specialization facility.</div>
            <div class="para e109">The DITA specialization facility allows new element types and attributes to be formally
               derived from base types, where all new elements must be ultimately specialized from
               one of the fundamental base types defined by the DITA standard. Thus all DITA vocabulary
               represents a type hierarchy with a common ancestry. This is roughly analogous to a
               language like Java where all object classes ultimately subclass one of the fundamental
               classes defined by the Java language.
            </div>
            <div class="para e110">The main constraint imposed by specialization is that specialized element types and
               attributes must be at least as constrained as their direct ancestor type. For example,
               given the base type 
               <div class="code e111">&lt;foo&gt;</div> with a content model of 
               <div class="code e112">(a | b | c)*</div>, the element type 
               <div class="code e113">&lt;bar&gt;</div> that is a direct specialization of 
               <div class="code e114">&lt;foo&gt;</div> may have as its content any content model from "EMPTY" (as all of the items are optional),
               to any one of the items 
               <div class="code e115">&lt;a&gt;</div>, 
               <div class="code e116">&lt;b&gt;</div>, or 
               <div class="code e117">&lt;c&gt;</div>, to the content model 
               <div class="code e118">(a, b, c)</div>, and of course the same content model as the base: 
               <div class="code e119">(a | b | c)*</div>. It cannot, however, have a content model of 
               <div class="code e120">(a | b | c | d)</div>, because that would be less constrained, unless the element type 
               <div class="code e121">&lt;d&gt;</div> is itself a specialization of one of 
               <div class="code e122">&lt;a&gt;</div>, 
               <div class="code e123">&lt;b&gt;</div>, or 
               <div class="code e124">&lt;c&gt;</div>. Likewise, if the content model of 
               <div class="code e125">&lt;foo&gt;</div> required an element, 
               <div class="code e126">&lt;bar&gt;</div> would not be able to make that element optional. Finally, the content model of 
               <div class="code e127">&lt;bar&gt;</div> could consist entirely of elements that are specializations of any of 
               <div class="code e128">&lt;a&gt;</div>, 
               <div class="code e129">&lt;b&gt;</div>, or 
               <div class="code e130">&lt;c&gt;</div>.
            </div>
            <div class="para e131">The fact that one element is a specialization of another is defined through the common
               
               <div class="code e132">@class</div> attribute, which lists the entire specialization hierarchy of the element. For example,
               if the element type 
               <div class="code e133">&lt;foo&gt;</div> is a specialization of 
               <div class="code e134">&lt;p&gt;</div> from the 
               <div class="code e135">topic</div> vocabulary module, then the 
               <div class="code e136">@class</div> value of the 
               <div class="code e137">&lt;bar&gt;</div> element would be: 
               <div class="code e138">"- topic/p module-1/foo module-2/bar "</div>, specified on each 
               <div class="code e139">&lt;bar&gt;</div> instance like so:
               <div class="programlisting e140" xml:space="preserve">&lt;bar class="- topic/p module-1/foo module-2/bar "&gt;
                  &lt;a&gt;A bar&lt;/a&gt;
                  &lt;/bar&gt;
               </div>
            </div>
            <div class="para e141">The value of the 
               <div class="code e142">@class</div> attribute is a sequence of module-name/element-name pairs, where the module names
               correspond to the names of modules as declared in the root element's 
               <div class="code e143">@domains</div> attribute.
            </div>
            <div class="para e144">The 
               <div class="code e145">@class</div> attribute thus ensures that any DITA-aware processor will be able to understand any
               element at least in terms of its base type (
               <div class="code e146">topic/p</div> in this case), if not in terms of its more specialized types. That means that all
               DITA documents can be usefully, if not always optimally, processed by any general-purpose,
               specialization-aware DITA processor.
            </div>
            <div class="para e147">Because general-purpose DITA processors can usefully process any DITA document, regardless
               of how specialized or constrained it is, it means that DITA documents can be 
               <div class="emphasis e148">blindly</div> interchanged among interchange partners who have such processors with full assurance
               that they'll always be able to do 
               <div class="emphasis e149">something</div> with those documents, even if their processors don't understand specific specializations
               in the content.
            </div>
         </div>
      </div><a name="ReuseandDocumentTypeCompatibilityANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e150">
         <div class="title e151">Reuse and Document Type Compatibility</div>
         <div class="para e152">The point of interchanging DITA content is not just to be able to process it but to
            do something new and interesting with the content interchanged. That is, we can presume
            that you have acquired the DITA content so that you can then do something more with
            it than simply generate various outputs, since you could have simply requested the
            outputs themselves and saved the expense of generating them.
         </div>
         <div class="para e153">DITA provides two mechanisms for combining content into new publication structures:
            maps and content references.
         </div>
         <div class="para e154">DITA's map mechanism uses documents consisting of only hyperlinks (DITA maps) to organize
            maps and content objects ("topics") into arbitrary hierarchies. The only requirement
            for the use of a given topic by a given map is that the topic be a valid DITA topic
            document. The vocabulary and constraint details of the topics used by the map are
            not relevant. (Maps can also use non-DITA resources, whether XML-based or non-XML
            but of course DITA can only guarantee interoperability of DITA documents.)
         </div>
         <div class="para e155">DITA's content reference mechanism ("conref") uses direct element-to-element links
            within topics (or maps) to establish use-by-reference relationships such that the
            referenced element becomes the effective value of the referencing element. It is similar
            to, but more sophisticated than, XInclude and similar link-based use by reference
            mechanisms.
         </div>
         <div class="para e156">Because conref results in new effective documents (either virtual or literal depending
            on how the processing is implemented), DITA imposes constraints on what may reuse
            what in order to ensure, as much as possible, that the effective result is valid in
            terms of the constraints governing the referencing context. In particular, a document
            can only use content that is at least as constrained and at least as specialized as
            itself (meaning that a more-constrained document cannot use content from a less-constrained
            or less-specialized document). This rule is defined in terms of the vocabulary modules
            used by both documents, not in terms of the individual content models or instance
            data involved.
         </div>
         <div class="para e157">Thus, while there may be cases where less-constrained data would in fact be valid
            in a particular use instance, DITA does not attempt to determine compatibility on
            a per-use-instance basis. Not only would that require access to formal definitions
            of all the content models involved, it would require complex and expensive processing
            for only marginal gains in practice.
         </div>
         <div class="para e158">Rather DITA uses the module use declarations in the 
            <div class="code e159">@domains</div> attribute to compare the modules used in two documents to determine if they are compatible
            for the purposes of content reference.
         </div>
      </div><a name="DITASelfDescriptionandProcessingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e160">
         <div class="title e161">DITA Self Description and Processing</div>
         <div class="para e162">In the most extreme case of blind interchange a system is presented with a document,
            with no advanced preparation or configuration for the document's specific document
            type, with the expectation that the system can first determine what type of document
            the document is and second apply appropriate processing or determine 
            <div class="emphasis e163">and clearly report</div> that it is either not able to determine the document type  or recognizes the document
            type but determines that the document uses facilities or has content that it does
            not know how to process. 
         </div>
         <div class="para e164">For example, XML content management systems should be capable of attempting ingestion
            of any XML document of any sort and, when the document is recognized as being of a
            known type, automatically do whatever is necessary to ingest and manage that document.
         </div>
         <div class="para e165">For this level of automation to be possible, documents and their components must be
            sufficiently self descriptive so as to allow a system to determine the document's
            type and, where appropriate, understand how to handle individual elements and attributes
            within the document. XML documents are inherently self-describing as XML as long as
            they have an XML declaration but beyond that more is required. If we accept that requiring
            the use of a DOCTYPE declaration or XSD schema reference or any other form of reference
            to an external schema is neither acceptable nor possible to enforce in the general
            case, then it follows that any self-description mechanism must use normal document
            markup.
         </div>
         <div class="para e166">All DITA documents are self describing in several important ways, none of which depend
            on the use of any form of document schema or grammar declaration. The self-description
            features are:
            <div class="orderedlist e167">
               <div class="listitem e168">
                  <div class="para e169">The 
                     <div class="code e170">@dita:DITAArchVersion</div> attribute, which is required on the root element of all DITA documents. This attribute
                     nominally specifies the DITA version the document conforms to (1.0, 1.1, 1.2, etc.)
                     but really serves as an excuse to declare the DITA namespace on the root element.
                     This serves to unambiguously signal that this document is a DITA document.
                  </div>
               </div>
               <div class="listitem e171">
                  <div class="para e172">The 
                     <div class="code e173">@domains</div> attribute specifies the set of vocabulary and constraint modules used by the document
                     and how they relate to each other. This attribute serves to define the document type
                     of the document (that is, a unique set of modules) and enables comparison of document
                     types for compatibility in order to enforce content reference rules or to determine
                     whether or not a given processor understands all the vocabulary modules used in the
                     document (and therefore provide clear reasons for not being able to process a given
                     document when it does not understand all the modules).
                  </div>
               </div>
               <div class="listitem e174">
                  <div class="para e175">The 
                     <div class="code e176">@class</div> attribute specifies, for each element instance or specialized attribute, it's place
                     within the DITA type hierarchy. This allows processors that understand at least all
                     the base DITA types to process all DITA elements, no matter how specialized, in terms
                     of the base DITA types.
                  </div>
               </div>
               <div class="listitem e177">
                  <div class="para e178">All DITA documents must have as their root element one of the element types 
                     <div class="code e179">&lt;dita&gt;</div>, 
                     <div class="code e180">&lt;map&gt;</div>, 
                     <div class="code e181">&lt;topic&gt;</div> or a specialization of 
                     <div class="code e182">&lt;map&gt;</div> or 
                     <div class="code e183">&lt;topic&gt;</div> (the 
                     <div class="code e184">&lt;dita&gt;</div> element is the one DITA element type that cannot be specialized).
                  </div>
               </div>
            </div>
         </div>
         <div class="para e185">Taken together, these three self-description mechanisms mean that general-purpose
            processors can be constructed without too much effort that can do the following when
            presented with any conforming DITA document with all attributes explicit (or defaulted
            via a DTD or XSD), no matter how specialized or what set of modules it uses:
            <div class="orderedlist e186">
               <div class="listitem e187">
                  <div class="para e188">Determine that the document is a DITA document, by looking for the 
                     <div class="code e189">@dita:DITAArchVersion</div> attribute. If this attribute is found, the document must be a DITA document.
                  </div>
               </div>
               <div class="listitem e190">
                  <div class="para e191">If there is no 
                     <div class="code e192">@dita:DITAArchVersion</div> attribute on the root element but there is a 
                     <div class="code e193">@class</div> attribute whose value matches the pattern for DITA 
                     <div class="code e194">@class</div> values and the root element is 
                     <div class="code e195">&lt;dita&gt;</div>, 
                     <div class="code e196">&lt;map&gt;</div>, 
                     <div class="code e197">&lt;topic&gt;</div> or a specialization of 
                     <div class="code e198">&lt;map&gt;</div> or 
                     <div class="code e199">&lt;topic&gt;</div>, the document is almost certainly a DITA document.
                  </div>
               </div>
               <div class="listitem e200">
                  <div class="para e201">If the document is a DITA document, apply general DITA processing to the document,
                     whatever that processing might be, 
                     <div class="emphasis e202">with no additional configuration</div>, with the assurance that, if the document is a valid DITA document, that the processing
                     will succeed.
                  </div>
                  <div class="para e203">Note that "valid" in this case doesn't mean "schema valid" it means "conforms to the
                     requirements of the DITA standard", not all of which can be enforced by a schema even
                     when one is used.
                  </div>
               </div>
            </div>
         </div>
         <div class="para e204">With the possible exception of HTML, there is no other XML application for documentation
            that allows both action (3) 
            <div class="emphasis e205">and</div> allows definition of arbitrary new vocabulary.
         </div>
      </div><a name="ApplyingtheDITAApproachMoreWidelyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e206">
         <div class="title e207">Applying the DITA Approach More Widely</div>
         <div class="para e208">The DITA modular vocabulary and specialization facilities could be applied to any
            XML application regardless of domain of application. While the particular implementation
            details used in DITA 1.x of 
            <div class="code e209">@domains</div> and 
            <div class="code e210">@class</div> may not be appropriate for other XML applications, the concept of modular vocabularies
            and controlled extension could be applied. In particular, the DITA 1.x 
            <div class="code e211">@class</div> attribute syntax does not accommodate namespaces in any satisfying way (other than
            requiring the use of specific prefixes). Any more general class-like mechanism would
            need to use a syntactic approach that fully supports namespaces. Designing such a
            mechanism will be a major focus of the DITA 2.0 activity (unless the DITA Technical
            Committee arrives at a solution that is backward compatible with the current 1.x syntax
            as part of the DITA 1.3 development activity under way now).
         </div>
         <div class="para e212">The main practical challenge is applying the necessary constraints to existing markup
            design where the markup was likely not originally designed either as a hierarchy of
            strictly-related types or to enable specialization by avoiding unnecessary constraints
            in base types. Because DITA must impose some constraints on content model design,
            it is usually not possible to take non-trivial document types and simply add 
            <div class="code e213">@class</div> attributes to the existing element types and make them conforming DITA documents—there
            will almost always be some amount of adjustment to structural models required. Even
            in the case where the requirement is not to conform to existing DITA structural models
            but simply to enable specialization from some set of base models reflecting the design
            of the existing document type, it will likely be the case that element types that
            are conceptually specializations of a newly-defined based type will not be structurally
            compatible with the base types, requiring adjustment or normalization of content models.
            This means that applying DITA directly or a DITA-type architecture will usually require
            creating a new non-backward compatible version of the existing document type. As in
            any such endeavor, the cost must be balanced against the benefit, but I assert that
            the potential benefit is quite large.
         </div>
         <div class="para e214">DITA's out-of-the-box vocabulary, while well adapted to the specific requirements
            for which DITA was originally designed (authoring and production of modular technical
            documentation optimized for online and dynamic delivery), is certainly not limited
            to that particular use and can be usefully applied to essentially any type of document
            or documentation. Therefore, new XML standards could be DITA-based without limiting
            their ability to define appropriate vocabulary. That is, one can assert that there
            is no reason not to make all new documentation-related XML document types DITA-based.
         </div>
         <div class="para e215">However, there are well-established applications in specific subject or application
            domains, such as NLM, that reflect person-decades of markup design and that are well
            established within their communities of use. It would be counter-productive to suggest
            or require that those communities replace their existing document types and infrastructure
            with a new DITA-based application just to get the interchangeability of DITA. It makes
            more sense to adapt the DITA concepts of modular vocabulary and specialization to
            those existing applications, preserving the existing investment in knowledge and infrastructure
            while lowering the cost of implementation and interchange, raising the value of the
            content that uses those vocabularies.
         </div>
      </div>
   </div>
</div>