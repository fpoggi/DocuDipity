<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#CarrotANCHOR" name="CarrotTOC">Carrot</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionANCHOR" name="IntroductionTOC">Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Backgroundand%0AinfluencesANCHOR" name="Backgroundand%0AinfluencesTOC">Background and
                  influences</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#IntroductionbyexampleANCHOR" name="IntroductionbyexampleTOC">Introduction by example</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CarrotdefinitionsANCHOR" name="CarrotdefinitionsTOC">Carrot definitions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#GlobalvariablesANCHOR" name="GlobalvariablesTOC">Global variables</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#FunctionsANCHOR" name="FunctionsTOC">Functions</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RulesANCHOR" name="RulesTOC">Rules</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#CarrotexpressionsANCHOR" name="CarrotexpressionsTOC">Carrot expressions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RulesetinvocationsANCHOR" name="RulesetinvocationsTOC">Ruleset invocations</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Shallowcopy%0AconstructorsANCHOR" name="Shallowcopy%0AconstructorsTOC">Shallow copy
                     constructors</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#TextnodeliteralsANCHOR" name="TextnodeliteralsTOC">Text node literals</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ExpressionsemanticsANCHOR" name="ExpressionsemanticsTOC">Expression semantics</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Whataboutxsl:foreach%0Axsl:foreachgroupetc?ANCHOR" name="Whataboutxsl:foreach%0Axsl:foreachgroupetc?TOC">What about xsl:for-each,
                     xsl:for-each-group, etc.?</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ImplementationstrategyANCHOR" name="ImplementationstrategyTOC">Implementation strategy</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#FuturedirectionsANCHOR" name="FuturedirectionsTOC">Future directions</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#SimplemappingoperatorANCHOR" name="SimplemappingoperatorTOC">Simple mapping operator</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#ModemergingANCHOR" name="ModemergingTOC">Mode merging</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#Underlyinglanguage%0AdevelopmentANCHOR" name="Underlyinglanguage%0AdevelopmentTOC">Underlying language
                     development</a></div>
            </div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">August 2 - 5, 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2011</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">copy{…}</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">definitions</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">evan.lenz@marklogic.com</div>
         <div class="singletermTERMS">Evan</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">foo/copy{…}</div>
         <div class="singletermTERMS">foo/&lt;bar/&gt;</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
         <div class="singletermTERMS">is</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">Lenz</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">mode="#default new-mode"</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">not</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
         <div class="singletermTERMS">RXSLT</div>
         <div class="singletermTERMS">ruleset</div>
         <div class="singletermTERMS">raison d'etre</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">Saxon-CE</div>
         <div class="singletermTERMS">simple mapping operator</div>
         <div class="singletermTERMS">Software Developer, Community</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">text{…}</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
         <div class="singletermTERMS">Unifying XSLT and XQuery element construction</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">XSLScript</div>
         <div class="singletermTERMS">XSLTXT</div>
         <div class="singletermTERMS">XQIB</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
         <div class="singletermTERMS">yapp-xslt</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="CarrotANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.3">
      <div class="title e1">Carrot</div>
      <div class="subtitle e2">An appetizing hybrid of XQuery and XSLT</div>
      <div class="info e3">
         <div class="confgroup e4">
            <div class="conftitle e5">Balisage: The Markup Conference 2011</div>
            <div class="confdates e6">August 2 - 5, 2011</div>
         </div>
         <div class="abstract e7">
            <div class="para e8">On the surface, XQuery and XSLT are very different languages. Users tend to prefer
               one language or the other. XSLT users are loath to give up the power of template rules;
               on the other hand, users of XQuery prefer its concise, composable syntax and perhaps
               wouldn't dare writing code in XML. There are good historical reasons why they are
               not the same language. For one thing, XSLT came first, and XQuery was designed more
               with SQL users in mind. However, the two languages share the same data model and a
               large syntactic subset (XPath 2.0), which raises the question: Is there a way to yield
               the unique benefits of both languages without having to continually decide between
               the two? The answer is yes. Carrot, an appetizing hybrid of XQuery and XSLT, lets
               you have your cake and eat it too.
            </div>
            <div class="para e9"></div>
         </div>
         <div class="author e10">
            <div class="personname e11">
               <div class="firstname e12">Evan</div>
               <div class="surname e13">Lenz</div>
            </div>
            <div class="personblurb e14">
               <div class="para e15">Evan Lenz has been a specialist in XML technologies since 1999, having served on the
                  W3C XSL Working Group, written XML-related books and articles, and spoken at numerous
                  conferences. He is currently working for MarkLogic Corporation.
               </div>
            </div>
            <div class="affiliation e16">
               <div class="jobtitle e17">Software Developer, Community</div>
               <div class="orgname e18">MarkLogic Corporation</div>
            </div>
            <div class="email e19">evan.lenz@marklogic.com</div>
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e20" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://developer.marklogic.com/blog</div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright © 2011 MarkLogic Corporation</div>
         </div>
      </div><a name="IntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e23">
         <div class="title e24">Introduction</div>
         <div class="para e25">Carrot combines the best that XQuery and XSLT have to offer:</div>
         <div class="itemizedlist e26">
            <div class="listitem e27">
               <div class="para e28">
                  the friendly
                  syntax and composability of XQuery expressions, plus
               </div>
            </div>
            <div class="listitem e29">
               <div class="para e30">
                  the power and
                  flexibility of template rules in XSLT.
               </div>
            </div>
         </div>
         <div class="para e31">
            Carrot can also be (loosely) thought of as an alternative, more
            composable syntax for XSLT.
         </div>
      </div><a name="Backgroundand%0AinfluencesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e32">
         <div class="title e33">Background and
            influences
         </div>
         <div class="para e34">
            Carrot is not the first XSLT-inspired project to provide a shorter
            syntax than XSLT itself. Syntax shorthands have included Paul
            Tchistopolskii's 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e35" xlink:actuate="onRequest" xlink:href="http://markmail.org/message/niumiluelzho6bmt" xlink:show="new" xlink:type="simple">XSLScript</div>, Sam
            Wilmott's 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e36" xlink:actuate="onRequest" xlink:href="http://www.wilmott.ca/rxslt/rxslt.html" xlink:show="new" xlink:type="simple">RXSLT</div>, and another
            project called 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e37" xlink:actuate="onRequest" xlink:href="http://savannah.nongnu.org/projects/xsltxt" xlink:show="new" xlink:type="simple">XSLTXT</div>. Although
            none of these projects provided direct inspiration for Carrot, they
            all address one of the same desires that Carrot addresses: being
            able to program in XSLT more concisely. However, unlike these
            projects, Carrot addresses more than XSLT's verbosity. It also
            addresses XSLT's limited composability. For example, in XSLT you
            can't include an element constructor in a path expression (like you
            can in XQuery and Carrot) or apply templates inside a path
            expression (which you can uniquely do in Carrot).
         </div>
         <div class="para e38">A
            more direct inspiration was James Clark's proposal for 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e39" xlink:actuate="onRequest" xlink:href="http://www.jclark.com/xml/construct.html" xlink:show="new" xlink:type="simple">Unifying XSLT and XQuery
               element construction
            </div>. Written during the early days of
            the W3C activity on XQuery, that proposal suggested that XQuery and
            XSLT language constructs could be used interchangeably if XQuery
            used an XML-based syntax (via a simple document element wrapper).
            As we now know, things didn't turn out that way. Carrot takes
            essentially the opposite approach. Rather than make XQuery use an
            XML-based syntax like XSLT's, make XSLT (Carrot, actually) use a
            non-XML-based syntax like XQuery's.
         </div>
         <div class="para e40">
            Carrot is also inspired by Haskell's syntax, which defines
            functions using pattern-matching and an equation-like syntax.
         </div>
      </div><a name="IntroductionbyexampleANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e41">
         <div class="title e42">Introduction by example</div>
         <div class="para e43">
            Carrot is best understood by example. Here's an example of XSLT's
            syntax for a template rule (henceforth "rule"):
         </div>
         <div class="programlisting e44" xml:space="preserve">&lt;xsl:template match="para"&gt;
            &lt;p&gt;
            &lt;xsl:apply-templates/&gt;
            &lt;p&gt;
            &lt;/xsl:template&gt;
         </div>
         <div class="para e45">
            In Carrot, you'd write the above rule like this:
         </div>
         <div class="programlisting e46" xml:space="preserve">^(para) := &lt;p&gt;{^()}&lt;/p&gt;;</div>
         <div class="para e47">There are a few things to note
            about the above. To define a rule in Carrot, you use the same
            operator that XQuery uses for binding variables
            (:=).
            Everything on the right-hand side up to the semi-colon is an
            expression in Carrot. An expression in Carrot is simply an XQuery
            expression, plus some extensions. In this case, the expression is
            using the extended syntax for invoking rules:
         </div>
         <div class="programlisting e48" xml:space="preserve">^()</div>
         <div class="para e49">
            which is short for:
         </div>
         <div class="programlisting e50" xml:space="preserve">^(node())</div>
         <div class="para e51">
            just as:
         </div>
         <div class="programlisting e52" xml:space="preserve">&lt;xsl:apply-templates/&gt;</div>
         <div class="para e53">
            is short for:
         </div>
         <div class="programlisting e54" xml:space="preserve">&lt;xsl:apply-templates select="node()"/&gt;</div>
         <div class="para e55">
            All rules belong to a&nbsp;
            <div class="emphasis e56" role="ital">ruleset</div>&nbsp;(equivalent to a "mode" in
            XSLT). The above examples use the unnamed ruleset (there's just one
            of these). Here's an example that belongs to a ruleset named
            "toc":
         </div>
         <div class="programlisting e57" xml:space="preserve">^toc(section) := &lt;li&gt;{ ^toc() }&lt;/li&gt;;</div>
         <div class="para e58">
            The above is short for:
         </div>
         <div class="programlisting e59" xml:space="preserve">&lt;xsl:template match="section" mode="toc"&gt;
            &lt;li&gt;
            &lt;xsl:apply-templates mode="toc"/&gt;
            &lt;/li&gt;
            &lt;/xsl:template&gt;
         </div>
         <div class="para e60">
            Here's the identity transform in Carrot:
         </div>
         <div class="programlisting e61" xml:space="preserve">^(@*|node()) := copy{ ^(@*|node()) };</div>
         <div class="para e62">
            This recursively copies the input to the output, one node at a
            time.
         </div>
         <div class="para e63">Here's a Carrot script that
            creates an HTML document with dynamic content for its title and
            body, converting&nbsp;&lt;para&gt;&nbsp;elements
            in the input to&nbsp;&lt;p&gt; elements
            in the output:
         </div>
         <div class="programlisting e64" xml:space="preserve">^(/) :=
            &lt;html&gt;
            &lt;head&gt;
            { /doc/title }
            &lt;/head&gt;
            &lt;body&gt;
            { ^(/doc/para) }
            &lt;/body&gt;
            &lt;/html&gt;;
            
            ^(para) := &lt;p&gt;{ ^() }&lt;/p&gt;;
         </div>
         <div class="para e65">
            As a comparison, here's what you'd have to write if you were using
            regular XSLT:
         </div>
         <div class="programlisting e66" xml:space="preserve">&lt;xsl:transform version="2.0"
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
            
            &lt;xsl:template match="/"&gt;
            &lt;html&gt;
            &lt;head&gt;
            &lt;xsl:copy-of select="/doc/title"/&gt;
            &lt;/head&gt;
            &lt;body&gt;
            &lt;xsl:apply-templates select="/doc/para"/&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            &lt;/xsl:template&gt;
            
            &lt;xsl:template match="para"&gt;
            &lt;p&gt;
            &lt;xsl:apply-templates/&gt;
            &lt;/p&gt;
            &lt;/xsl:template&gt;
            
            &lt;/xsl:stylesheet&gt;
         </div>
         <div class="para e67">Just
            as in XSLT, rules in Carrot can be associated with more than one
            mode. In XSLT, this template rule belongs to two modes:
         </div>
         <div class="programlisting e68" xml:space="preserve">&lt;xsl:template mode="foo bar" match="bang"/&gt;</div>
         <div class="para e69">Here's the equivalent rule in
            Carrot, belonging to two rulesets:
         </div>
         <div class="programlisting e70" xml:space="preserve">^foo|bar(bang) := ();</div>
      </div><a name="CarrotdefinitionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e71">
         <div class="title e72">Carrot definitions</div>
         <div class="para e73">A
            Carrot module consists of a set of unordered 
            <div class="emphasis e74" role="ital">definitions</div>. Unlike XQuery, there is
            no distinction between main modules and library modules. Likewise, a Carrot module
            has no "body." Instead, there are only definitions.
            Carrot is more like XSLT in this regard. Also unlike XQuery, Carrot modules need not
            be associated with a namespace.
         </div>
         <div class="para e75">There are three kinds of
            definitions in Carrot:
         </div>
         <div class="itemizedlist e76">
            <div class="listitem e77">
               <div class="para e78">global variables,</div>
            </div>
            <div class="listitem e79">
               <div class="para e80">functions, and</div>
            </div>
            <div class="listitem e81">
               <div class="para e82">rules.</div>
            </div>
         </div><a name="GlobalvariablesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e83">
            <div class="title e84">Global variables</div>
            <div class="para e85">A global
               variable definition is very similar to a variable declaration in
               XQuery, except that you don't need the "declare variable" verbiage.
               Whereas in XQuery you would write:
            </div>
            <div class="programlisting e86" xml:space="preserve">declare variable $foo := "a string value";</div>
            <div class="para e87">In
               Carrot you would instead write:
            </div>
            <div class="programlisting e88" xml:space="preserve">$foo := "a string value";</div>
         </div><a name="FunctionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e89">
            <div class="title e90">Functions</div>
            <div class="para e91">A
               function definition is just like a function declaration in XQuery
               except that you don't need the "declare function" verbiage and,
               instead of curly braces, you use the same binding operator (:=) as
               a variable definition. For example, whereas in XQuery, you would
               declare functions like this:
            </div>
            <div class="programlisting e92" xml:space="preserve">declare function my:foo() { "return value" };
               declare function my:bar($str as xs:string) as xs:string { upper-case($str) };
            </div>
            <div class="para e93">In
               Carrot, you would instead write:
            </div>
            <div class="programlisting e94" xml:space="preserve">my:foo() := "return value";
               my:bar($str as xs:string) as xs:string := upper-case($str);
            </div>
            <div class="para e95">Why
               not just use the regular XQuery syntax? Two reasons: conciseness
               (lower signal-to-noise ratio) and consistency (with the other two
               types of definitions).
            </div>
         </div><a name="RulesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e96">
            <div class="title e97">Rules</div>
            <div class="para e98">The third type of definition is a rule. This
               corresponds to a template rule in XSLT. For example, this rule
               matches any element node (*):
            </div>
            <div class="programlisting e99" xml:space="preserve">^foo(*) := "return value";</div>
            <div class="para e100">
               Unlike a function definition, the "argument"  of a rule definition ("*" in the above
               case)
               is 
               <div class="emphasis e101" role="ital">not</div> an (optional) formal
               parameter list; instead it is a required pattern (as XSLT defines a
               pattern). Thus, it's illegal to have an empty set of parentheses in
               a rule definition:
            </div>
            <div class="programlisting e102" xml:space="preserve">^foo() := "return value"; (: NOT LEGAL :)</div>
            <div class="para e103">Note
               the asymmetry with ruleset invocations, where it 
               <div class="emphasis e104" role="ital">is</div> legal to call 
               <div class="code e105">^foo()</div>, which is short
               for 
               <div class="code e106">^foo(node())</div>.
            </div>
            <div class="para e107">Of
               course, rules can also have parameters (just as template rules can
               have parameters in XSLT). The syntax for declaring these is very similar to an XQuery
               function parameter list, except that it comes after the pattern and is
               separated from the pattern by a semicolon:
            </div>
            <div class="programlisting e108" xml:space="preserve">^foo(* ; $str as xs:string) := concat($str, .);</div>
            <div class="para e109">Carrot also supports tunnel parameters, as in XSLT. To indicate a tunnel parameter,
               you add the keyword "tunnel" before the parameter:
            </div>
            <div class="programlisting e110" xml:space="preserve">^foo(* ; tunnel $str as xs:string) := concat($str, .);</div>
            <div class="para e111">Unlike XQuery functions, parameters in a rule are identified by name, not position.
               Thus the syntax for passing them looks very similar to how they are declared, and
               the order of parameters is insignificant. The following expression applies the "foo"
               ruleset to the context node, passing the tunnel parameter $str with the value "Hello":
            </div>
            <div class="programlisting e112" xml:space="preserve">^foo(. ; tunnel $str := "Hello")</div>
            <div class="para e113">What about conflict resolution among multiple matching rules? Carrot behaves the same
               as XSLT: rules with higher import precedence win, followed by rules with higher priority.
               Default priority is based on the syntax of the pattern, just as in XSLT. You can also
               specify the priority explicitly (right before the binding operator :=), as in the
               first rule of this example, which explicitly sets the priority to 1:
            </div>
            <div class="programlisting e114" xml:space="preserve">^author-listing( author[1]      ) 1 :=           ^();
               ^author-listing( author         )   := ", "    , ^();
               ^author-listing( author[last()] )   := " and " , ^();
            </div>
         </div>
      </div><a name="CarrotexpressionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e115">
         <div class="title e116">Carrot expressions</div>
         <div class="para e117">The
            right-hand side of a Carrot definition, whether it be a variable,
            function, or rule, is a Carrot expression. The context for the
            expression evaluation is the same as it is for sequence
            constructors within a template rule in XSLT. For example, the
            context node is the node matched by the rule's pattern.
         </div>
         <div class="para e118">A
            Carrot expression is an XQuery expression with some extensions:
         </div>
         <div class="itemizedlist e119">
            <div class="listitem e120">
               <div class="para e121">
                  ruleset
                  invocations — 
                  <div class="code e122">^mode(nodes)</div>
               </div>
            </div>
            <div class="listitem e123">
               <div class="para e124">
                  shallow 
                  <div class="code e125">copy{…}</div>
                  constructors
               </div>
            </div>
            <div class="listitem e126">
               <div class="para e127">
                  text node
                  literals — 
                  <div class="code e128">`my text node`</div>
               </div>
            </div>
         </div>
         <div class="para e129">Let's
            look at each of these extensions in turn and the rationale behind
            each one.
         </div><a name="RulesetinvocationsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e130">
            <div class="title e131">Ruleset invocations</div>
            <div class="para e132">
               Ruleset invocations (i.e., "apply-templates" in XSLT) are largely
               Carrot's 
               <div class="emphasis e133">raison d'etre</div>. They are not possible in XQuery; thus, the
               extension is required. Not only that, but XSLT can't invoke rules
               (apply templates) in an expression either. In Carrot, all
               definitions are bound to an expression, so the only way to "do"
               anything is to write an expression. (Unlike XSLT, Carrot does not
               make a distinction between "instructions" and "expressions";
               everything is an expression.)
            </div>
         </div><a name="Shallowcopy%0AconstructorsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e134">
            <div class="title e135">Shallow copy
               constructors
            </div>
            <div class="para e136">
               Shallow copy constructors are possible in XSLT but not XQuery. The
               difference between a copy constructor and using an XQuery element
               constructor is that, in the latter case, the namespace context
               comes from the query rather than the source document. XQuery allows
               you to perform deep element copies from the source document, but
               not shallow copies. Without this ability, modified identity
               transforms are impractical in XQuery. The semantics of Carrot's
               copy constructor are essentially the same as XSLT's
               &lt;xsl:copy&gt; instruction. For example, when the context node is
               not an element node, it behaves the same as if a deep copy were
               being performed.
            </div>
            <div class="note e137">
               <div class="para e138">XSLT 2.1/3.0 promises to add a "select" attribute to &lt;xsl:copy&gt; to make it convenient
                  to perform a shallow copy of a node other than the context node. This is largely unnecessary
                  in Carrot, since copy constructors can be easily composed within an expression, making
                  it convenient to write, for example, 
                  <div class="code e139">foo/copy{…}</div>.
               </div>
            </div>
         </div><a name="TextnodeliteralsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e140">
            <div class="title e141">Text node literals</div>
            <div class="para e142">
               Carrot also adds text node literals, using the back-tick (`) for
               the delimiter. This extension may at first seem to be of minimal
               value, since XQuery already allows you to construct text nodes
               using 
               <div class="code e143">text{…}</div>, and strings using quotes (or apostrophes).
               However, in practice, text node literals will often be the
               preferred syntax, as the following examples should make clear.
               Consider the following template rules in XSLT:
            </div>
            <div class="programlisting e144" xml:space="preserve">&lt;xsl:template mode="file-name" match="doc"&gt;doc&lt;/xsl:template&gt;
               &lt;xsl:template mode="file-ext" match="doc"&gt;.xml&lt;/xsl:template&gt;
               
               &lt;xsl:template match="/doc"&gt;
               &lt;result&gt;
               &lt;xsl:apply-templates mode="file-name" select="."/&gt;
               &lt;xsl:apply-templates mode="file-ext" select="."/&gt;
               &lt;/result&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e145">In
               Carrot, you might naturally rewrite the above as follows:
            </div>
            <div class="programlisting e146" xml:space="preserve">^file-name(doc) := "doc";
               ^file-ext (doc) := ".xml";
               ^(/doc)         := &lt;result&gt;{ ^file-name(.), ^file-ext(.) }&lt;/result&gt;
            </div>
            <div class="para e147">The
               problem is that this will produce an undesired result:
            </div>
            <div class="programlisting e148" xml:space="preserve">&lt;result&gt;doc .xml&lt;/result&gt;</div>
            <div class="para e149">The
               extra space results because of the way in which sequences of atomic
               values are combined to make a text node in XQuery. Contiguous sequences of text nodes,
               on
               the other hand, are merged together without any intervening spaces,
               so you could fix things by using explicit text node
               constructors:
            </div>
            <div class="programlisting e150" xml:space="preserve">^file-name(doc) := text{"doc"};
               ^file-ext (doc) := text{".xml"};
            </div>
            <div class="para e151">The
               problem here is that it may be an edge case with a large syntactic
               cost if you want to cover your bases (six extra characters for
               every text node). If in 90% of cases, using a string will result in
               the exact same behavior as if you had used a text node, you will be
               strongly tempted as a user to use quotes instead of 
               <div class="code e152">text{…}</div>
               everywhere. However, you will get bugs in the remaining 10% of your
               code because of the way sequences of strings are concatenated to
               make a text node in XQuery.
            </div>
            <div class="para e153">
               Whereas it's more verbose in XQuery to construct a text node (using
               
               <div class="code e154">text{…}</div>) than it is to return a string (using quotes), it's more verbose in
               XSLT to return a string (using &lt;xsl:sequence&gt;) than it is to
               return a text node (using a literal text node in the stylesheet). Text node literals
               in Carrot address this imbalance by
               making it equally convenient to create text nodes and strings.
               Thus, we naturally rewrite our Carrot definitions to get the
               desired result, without having to think about whether this is an
               edge case or not:
            </div>
            <div class="programlisting e155" xml:space="preserve">^file-name(doc) := `doc`;
               ^file-ext (doc) := `.xml`;
            </div>
            <div class="para e156">The existence of text
               node literals makes it easy to follow a simple rule: use text node
               literals when you are constructing part of a result document; use
               string literals when you know you want to return a string.
            </div>
         </div><a name="ExpressionsemanticsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e157">
            <div class="title e158">Expression semantics</div>
            <div class="para e159">
               Expressions in Carrot, unless otherwise noted here, are assumed to
               have the same semantics as in XQuery. Carrot operates on exactly
               the same data model as XQuery 1.0 and XPath 2.0.
            </div>
            <div class="para e160">One
               exception is that namespace attribute declarations on element
               constructors in Carrot do not affect the default element namespace
               for XPath expressions. Carrot is more like XSLT in this regard, in
               that it makes a distinction between the default namespace for input
               documents and the default namespace for output documents
               ("xpath-default-namespace" in XSLT), thereby correcting what is
               arguably a design bug in XQuery.
            </div>
         </div><a name="Whataboutxsl:foreach%0Axsl:foreachgroupetc?ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e161">
            <div class="title e162">What about xsl:for-each,
               xsl:for-each-group, etc.?
            </div>
            <div class="para e163">Given
               that XQuery expressions do not include everything that it's
               possible to do in an XSLT template rule, that begs the question:
               What do all the XSLT instructions get mapped to in Carrot? In many
               cases, Carrot simply does not have an analogue. In some cases,
               that's because XQuery already provides a different way to achieve
               the same use case. For example, &lt;xsl:for-each&gt; does not have
               a direct analogue in Carrot. For iteration over a sequence, you can
               use "for" expressions, or even just "/" when applicable. The
               following Carrot (and XQuery) expression constructs a new
               &lt;bar&gt; element for each &lt;foo&gt; element, rendering
               &lt;xsl:for-each&gt; unnecessary for this case: 
               <div class="code e164">foo/&lt;bar/&gt;</div>. Similarly,
               Carrot does not support &lt;xsl:sort&gt;. For sorting sequences in
               Carrot, you would instead use "order by", as in XQuery. Local
               variables are defined using "let" expressions. Etc.
            </div>
            <div class="para e165">The
               biggest area not currently addressed by Carrot—and which remains
               an open question—is how to perform grouping. There are a few
               answers to this question, not all mutually exclusive:
            </div>
            <div class="orderedlist e166">
               <div class="listitem e167">
                  <div class="para e168">
                     Extend Carrot to support grouping.
                  </div>
               </div>
               <div class="listitem e169">
                  <div class="para e170">
                     Import an XSLT
                     2.0 stylesheet when you need grouping.
                  </div>
               </div>
               <div class="listitem e171">
                  <div class="para e172">
                     Wait for
                     grouping to be added to XQuery 3.0 expressions and use
                     those.
                  </div>
               </div>
            </div>
            <div class="para e173">At
               this stage, the operative answers to this question are #2 and
               #3.
            </div>
            <div class="para e174">
               Designing support for multiple output documents (corresponding to
               &lt;xsl:result-document&gt; in XSLT) and how it interacts with
               document{} node constructors is on my TODO list. (If you have ideas, I'd be happy
               to hear them.)
            </div>
         </div>
      </div><a name="ImplementationstrategyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e175">
         <div class="title e176">Implementation strategy</div>
         <div class="para e177">
            Carrot is being implemented by compilation to XSLT 2.0. Several
            things are worth noting about this:
         </div>
         <div class="itemizedlist e178">
            <div class="listitem e179">
               <div class="para e180">
                  Each Carrot
                  module compiles to an XSLT 2.0 module.
               </div>
            </div>
            <div class="listitem e181">
               <div class="para e182">
                  Carrot can
                  include and import other Carrot modules or XSLT
                  modules.
               </div>
            </div>
            <div class="listitem e183">
               <div class="para e184">
                  Carrot can also
                  import XQuery modules, but since this is not supported directly in
                  XSLT 2.0, the semantics depend on your target XSLT processor (e.g.,
                  &lt;saxon:import-query&gt; in Saxon and &lt;xdmp:import-module&gt;
                  in MarkLogic Server)
               </div>
            </div>
         </div>
         <div class="para e185">
            Carrot is still in the process of being defined more formally. The
            current strategy for defining and implementing Carrot is as
            follows:
         </div>
         <div class="orderedlist e186">
            <div class="listitem e187">
               <div class="para e188">
                  Create a BNF grammar for Carrot
               </div>
               <div class="orderedlist e189" numeration="loweralpha">
                  <div class="listitem e190">
                     <div class="para e191">
                        Hand-convert the EBNF grammar for XQuery expressions to
                        BNF
                     </div>
                  </div>
                  <div class="listitem e192">
                     <div class="para e193">
                        Extend the
                        resulting BNF to support Carrot definitions and
                        expressions
                     </div>
                  </div>
               </div>
            </div>
            <div class="listitem e194">
               <div class="para e195">
                  Use 
                  <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e196" xlink:actuate="onRequest" xlink:href="http://www.o-xml.org/yapp/" xlink:show="new" xlink:type="simple">yapp-xslt</div>
                  
                  to generate the Carrot parser from the Carrot BNF
               </div>
            </div>
            <div class="listitem e197">
               <div class="para e198">
                  Write a
                  compiler in XSLT 2.0 to convert parsed Carrot modules to XSLT 2.0
                  modules
               </div>
            </div>
         </div>
         <div class="para e199">The
            syntax for other top-level constructs, such as namespace
            declarations, serialization options, and parameter definitions are
            still being worked out. Some mock-up examples can be found at the
            project's home page: 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e200" xlink:actuate="onRequest" xlink:href="http://github.com/evanlenz/carrot" xlink:show="new" xlink:type="simple">http://github.com/evanlenz/carrot</div>
         </div>
      </div><a name="FuturedirectionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e201">
         <div class="title e202">Future directions</div>
         <div class="para e203">
            Carrot is both a practical tool and a research project. I'm trying
            to find the right balance between innovation and sticking to the
            syntax and/or semantics of XPath, XSLT, and XQuery. I'm excited by
            the future possibility of using XML-oriented scripting languages in
            the browser, as made possible by projects like 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e204" xlink:actuate="onRequest" xlink:href="http://saxonica.com/ce/doc/contents.html" xlink:show="new" xlink:type="simple">Saxon-CE</div>
            and 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e205" xlink:actuate="onRequest" xlink:href="http://www.xqib.org/" xlink:show="new" xlink:type="simple">XQIB</div>. I'm convinced that
            XSLT's syntax is an obstacle to mainstream adoption as a browser
            scripting language. Carrot, or something like it, could help
            overcome such obstacles.
         </div>
         <div class="para e206">As a
            research project, the ideas at the heart of Carrot may possibly
            influence the longer-term W3C work, as XQuery and XSLT continue to
            move closer to each other. I'm already quite satisfied by the
            composability that Carrot provides in contrast to XSLT. That said,
            I'm always itching for more features in the XPath/XQuery/XSLT
            triumvirate. As a sample, here are two.
         </div><a name="SimplemappingoperatorANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e207">
            <div class="title e208">Simple mapping operator</div>
            <div class="para e209">I
               think XPath needs a "
               <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e210" xlink:actuate="onRequest" xlink:href="http://lists.w3.org/Archives/Public/public-qt-comments/2003Dec/0061.html" xlink:show="new" xlink:type="simple">simple
                  mapping operator
               </div>" that behaves similarly to "/" except without
               its restrictions and special behavior with regard to node
               sequences. This is one possible extension that could be added to
               Carrot, without having to wait for XSLT/XQuery 3.0 (if it's
               even being considered for inclusion).
            </div>
         </div><a name="ModemergingANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e211">
            <div class="title e212">Mode merging</div>
            <div class="para e213">
               Another more recent idea (which would be straightforward to
               implement in Carrot) would be "mode merging."
            </div>
            <div class="para e214">In XSLT, a single template rule can declare
               itself to be a part of more than one mode. However, a single call
               to apply-templates cannot invoke rules in more than one mode. The
               ability to merge modes would provide a static mode extension
               mechanism, the chief benefit of course being that you wouldn't have
               to go add a new mode to each template rule's list of modes (and in
               the case when it's in the default mode, go add 
               <div class="code e215">mode="#default new-mode"</div> to each
               rule).
            </div>
            <div class="para e216">In
               XSLT:
            </div>
            <div class="programlisting e217" xml:space="preserve">&lt;xsl:apply-templates mode="foo bar"/&gt;</div>
            <div class="para e218">
               In Carrot:
            </div>
            <div class="programlisting e219" xml:space="preserve">^foo|bar()</div>
            <div class="para e220">This
               would be especially handy in multi-stage transformations where each
               stage of processing makes an incremental change to its input, but
               some stages need to handle things slightly differently, for
               example, to avoid transforming an already-converted element more
               than once. Mode merging would allow you to invoke statically
               determined subsets and supersets of rules.
            </div>
         </div><a name="Underlyinglanguage%0AdevelopmentANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e221">
            <div class="title e222">Underlying language
               development
            </div>
            <div class="para e223">
               Finally, Carrot is a project that can grow with the languages it is
               based on. As various features are added in XSLT/XQuery 3.0, such as
               JSON support or the ability to apply templates to sequences of
               atomic values, Carrot will (happily) be updated accordingly.
            </div>
         </div>
      </div>
   </div>
</div>