<div id="mainContainerTOC">
   <div id="mainContainerTitleTOC" onclick="$('#mainContainerEntriesTOC').toggle('1000');">Table of Content</div>
   <div id="mainContainerEntriesTOC" style="display:none;">
      <div class="headedContainerTOC">
         <div class="headedContainerTitleTOC"><a href="#AStreamingXSLTProcessorANCHOR" name="AStreamingXSLTProcessorTOC">A Streaming XSLT Processor</a></div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#Streaming:anIntroductionANCHOR" name="Streaming:anIntroductionTOC">Streaming: an Introduction</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreamedXPathintheSchemaValidatorANCHOR" name="StreamedXPathintheSchemaValidatorTOC">Streamed XPath in the Schema Validator</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreamingCopyANCHOR" name="StreamingCopyTOC">Streaming Copy</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#InitialimplementationofStreamingCopyANCHOR" name="InitialimplementationofStreamingCopyTOC">Initial implementation of Streaming Copy</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#RefinementsoftheStreamingCopyfeatureANCHOR" name="RefinementsoftheStreamingCopyfeatureTOC">Refinements of the Streaming Copy feature</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StreamingwithRetainedStateANCHOR" name="StreamingwithRetainedStateTOC">Streaming with Retained State</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#LimitationsofStreamingCopyANCHOR" name="LimitationsofStreamingCopyTOC">Limitations of Streaming Copy</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#StreamingTemplatesANCHOR" name="StreamingTemplatesTOC">Streaming Templates</a></div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StreamingTemplatesinSaxon92ANCHOR" name="StreamingTemplatesinSaxon92TOC">Streaming Templates in Saxon 9.2</a></div>
            </div>
            <div class="headedContainerTOC">
               <div class="headedContainerTitleTOC"><a href="#StreamableTemplatesinSaxon93ANCHOR" name="StreamableTemplatesinSaxon93TOC">Streamable Templates in Saxon 9.3</a></div>
            </div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#ConclusionsANCHOR" name="ConclusionsTOC">Conclusions</a></div>
         </div>
         <div class="headedContainerTOC">
            <div class="headedContainerTitleTOC"><a href="#BibliographyANCHOR" name="BibliographyTOC">Bibliography</a></div>
         </div>
      </div>
   </div>
</div>
<div id="mainContainerTERMS">
   <div id="mainContainerTitleTERMS" onclick="$('#mainContainerEntriesTERMS').toggle('1000')">Index of Terms</div>
   <div id="mainContainerEntriesTERMS" style="display:none;">
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">a</div>
         <div class="singletermTERMS">apply</div>
         <div class="singletermTERMS">ApplyTemplatesWatch</div>
         <div class="singletermTERMS">August 3 - 6, 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">b</div>
         <div class="singletermTERMS">burst-mode streaming</div>
         <div class="singletermTERMS">Balisage: The Markup Conference 2010</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">c</div>
         <div class="singletermTERMS">call-template</div>
         <div class="singletermTERMS">customers.xml</div>
         <div class="singletermTERMS">customer</div>
         <div class="singletermTERMS">CopyWatch</div>
         <div class="singletermTERMS">copy-of</div>
         <div class="singletermTERMS">count()</div>
         <div class="singletermTERMS">count(.//employee)</div>
         <div class="singletermTERMS">CountWatch</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">d</div>
         <div class="singletermTERMS">doc()</div>
         <div class="singletermTERMS">data()</div>
         <div class="singletermTERMS">data(.)</div>
         <div class="singletermTERMS">distinct-values()</div>
         <div class="singletermTERMS">drill-down construct</div>
         <div class="singletermTERMS">divisible</div>
         <div class="singletermTERMS">Director</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">e</div>
         <div class="singletermTERMS">endElement</div>
         <div class="singletermTERMS">exists()</div>
         <div class="singletermTERMS">employee</div>
         <div class="singletermTERMS">empty()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">f</div>
         <div class="singletermTERMS">FieldWatch</div>
         <div class="singletermTERMS">following-sibling</div>
         <div class="singletermTERMS">foldl</div>
         <div class="singletermTERMS">ForEachWatch</div>
         <div class="singletermTERMS">feed</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">g</div>
         <div class="singletermTERMS">getNextInput()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">h</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">i</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">j</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">k</div>
         <div class="singletermTERMS">Kay</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">l</div>
         <div class="singletermTERMS">last()</div>
         <div class="singletermTERMS">local-name()</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">m</div>
         <div class="singletermTERMS">mode</div>
         <div class="singletermTERMS">mike@saxonica.com</div>
         <div class="singletermTERMS">Michael</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">n</div>
         <div class="singletermTERMS">name</div>
         <div class="singletermTERMS">note</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">o</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">p</div>
         <div class="singletermTERMS">processLeft()</div>
         <div class="singletermTERMS">processRight()</div>
         <div class="singletermTERMS">Pattern</div>
         <div class="singletermTERMS">position()</div>
         <div class="singletermTERMS">Push</div>
         <div class="singletermTERMS">Program Inversion</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">q</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">r</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">s</div>
         <div class="singletermTERMS">SelectorWatch</div>
         <div class="singletermTERMS">startElement</div>
         <div class="singletermTERMS">saxon:read-once</div>
         <div class="singletermTERMS">select</div>
         <div class="singletermTERMS">section</div>
         <div class="singletermTERMS">saxon:read-once="yes"</div>
         <div class="singletermTERMS">saxon:stream()</div>
         <div class="singletermTERMS">saxon:stream(doc('customers.xml')/*/customer)</div>
         <div class="singletermTERMS">saxon:stream(doc('customers.xml')/*/@version)</div>
         <div class="singletermTERMS">saxon:assign</div>
         <div class="singletermTERMS">saxon:iterate</div>
         <div class="singletermTERMS">string()</div>
         <div class="singletermTERMS">saxon:mode</div>
         <div class="singletermTERMS">skip</div>
         <div class="singletermTERMS">StreamingDespatcher</div>
         <div class="singletermTERMS">sum()</div>
         <div class="singletermTERMS">sum(.//value)</div>
         <div class="singletermTERMS">skills/skill</div>
         <div class="singletermTERMS">string-join()</div>
         <div class="singletermTERMS">skill</div>
         <div class="singletermTERMS">StringValueWatch</div>
         <div class="singletermTERMS">SimpleContentWatch</div>
         <div class="singletermTERMS">streaming route</div>
         <div class="singletermTERMS">Streaming</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">t</div>
         <div class="singletermTERMS">transaction</div>
         <div class="singletermTERMS">TypedValueWatch</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">u</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">v</div>
         <div class="singletermTERMS">version</div>
         <div class="singletermTERMS">value-of</div>
         <div class="singletermTERMS">value</div>
         <div class="singletermTERMS">VoidWatch</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">x</div>
         <div class="singletermTERMS">xsl:apply-templates</div>
         <div class="singletermTERMS">xsl:call-template</div>
         <div class="singletermTERMS">xs:selector</div>
         <div class="singletermTERMS">xsl:with-param</div>
         <div class="singletermTERMS">xs:field</div>
         <div class="singletermTERMS">xsl:copy-of</div>
         <div class="singletermTERMS">xsl:iterate</div>
         <div class="singletermTERMS">xsl:for-each</div>
         <div class="singletermTERMS">xsl:value-of</div>
         <div class="singletermTERMS">xsl:element</div>
         <div class="singletermTERMS">xsl:attribute</div>
         <div class="singletermTERMS">xsl:comment</div>
         <div class="singletermTERMS">xsl:processing-instruction</div>
         <div class="singletermTERMS">xsl:result-document</div>
         <div class="singletermTERMS">xsl:variable</div>
         <div class="singletermTERMS">xsl:sequence</div>
         <div class="singletermTERMS">xsl:choose</div>
         <div class="singletermTERMS">xsl:apply-imports</div>
         <div class="singletermTERMS">xsl:next-match</div>
         <div class="singletermTERMS">xsl:for-each-group</div>
         <div class="singletermTERMS">XSLT Programmer's Reference</div>
         <div class="singletermTERMS">XML</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">y</div>
      </div>
      <div class="letterContainerTERMS">
         <div class="letterlableTERMS">z</div>
      </div>
   </div>
</div>
<div id="mainContainerIML"><a name="AStreamingXSLTProcessorANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="article e0" version="5.0-subset Balisage-1.2">
      <div class="title e1">A Streaming XSLT Processor</div>
      <div class="info e2">
         <div class="confgroup e3">
            <div class="conftitle e4">Balisage: The Markup Conference 2010</div>
            <div class="confdates e5">August 3 - 6, 2010</div>
         </div>
         <div class="abstract e6">
            <div class="para e7">Existing XSLT implementations build a tree representation of the source document in
               memory, and
               are therefore limited to processing of documents that fit in memory. With many transformations,
               however,
               there is a direct correspondence between the order of information in the output, and
               the order of the
               corresponding information in the input. In such cases it ought to be possible to perform
               the transformation
               without allocating memory to the entire source tree.
            </div>
            <div class="para e8">The XSL Working Group within W3C has been working on a new version of the language
               designed
               to make streamed implementations feasible, and the author, who is editor of that specification,
               has
               at the same time been working on the implementation of streaming in the Saxon XSLT
               processor. This paper
               describes how far this work has progressed, and the way in which the implementation
               is structured.
               It adopts a chronological approach to the exposition, explaining how the streaming
               features have gradually
               developed from small beginnings.
            </div>
         </div>
         <div class="author e9">
            <div class="personname e10">
               <div class="firstname e11">Michael</div>
               <div class="surname e12">Kay</div>
            </div>
            <div class="personblurb e13">
               <div class="para e14">Michael Kay is the editor of the W3C XSLT specification, and is a member of the XQuery
                  and XML Schema Working Groups. He is the developer of the Saxon XSLT, XQuery, and
                  XML Schema processor.
                  He is the author of 
                  <div class="quote e15">XSLT Programmer's Reference</div> (now in its fourth edition) and a contributor
                  to many other books.
               </div>
               <div class="para e16">He is a member of the Advisory Board for Balisage 2010.  In 2009, he chaired the associated
                  Symposium
                  on Processing XML Efficiently.
               </div>
            </div>
            <div class="affiliation e17">
               <div class="jobtitle e18">Director</div>
               <div class="orgname e19">Saxonica Limited</div>
            </div>
            <div class="email e20">mike@saxonica.com</div>
         </div>
         <div class="legalnotice e21">
            <div class="para e22">Copyright Â© Michael Kay 2010</div>
         </div>
         <div class="keywordset e23" role="author">
            <div class="keyword e24">XML</div>
            <div class="keyword e25">Streaming</div>
            <div class="keyword e26">Push</div>
            <div class="keyword e27">Program Inversion</div>
         </div>
      </div><a name="Streaming:anIntroductionANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e28">
         <div class="title e29">Streaming: an Introduction</div>
         <div class="para e30">The architecture of most XSLT processors is as shown in Figure 1. The XML parser is
            used
            to build a tree representation of the source document in memory. XSLT instructions
            are then
            executed, which cause the evaluation of XPath expressions, which select nodes from
            the source
            tree by navigating around this tree. Because the XPath axes (child, descendant, parent,
            ancestor, preceding-sibling, and so on) allow navigation around this tree in arbitrary
            directions, it is necessary for the entire tree to be held in memory for the duration
            of the
            transformation. For some XML documents, this is simply not feasible: even sample datasets
            representing virtual 3D city models run to 44Gbytes in size (
            <div class="xref e31" linkend="CityGML"></div>).
         </div>
         <div class="figure e32" xml:id="fig1">
            <div class="title e33">Fig 1: Architecture of an XSLT Processor</div>
            <div class="mediaobject e34">
               <div class="imageobject e35">
                  <div class="metaBox e36"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e60').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e60" class="metaSource" style="display:none;">                
                        &lt;imagedata<span class="metaAttribute">class='e36'
                           </span><span class="metaAttribute">fileref='../../../vol5/graphics/Kay01/Kay01-001.png'
                           </span>
                        &gt;
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="caption e37">
               <div class="para e38">In this schematic, arrows represent flow of control (not data flow). Thus the two
                  controlling components (outlined bold) are the Parser and the XSLT engine; the parser
                  writes the source tree and the XSLT engine reads it (via the XPath engine). The serializer
                  is invoked by the XSLT engine to process one result tree event at a time, which means
                  that
                  the result tree does not actually need to be materialized in memory.
               </div>
            </div>
         </div>
         <div class="para e39">By contrast, there is no need to hold the result tree in memory. Although the semantics
            of
            the language speak of a result tree, a naive execution of XSLT instructions causes
            nodes to be
            written to the result tree in document order, which means that data can be serialized
            (to
            lexical XML or HTML) as soon as it is generated. So the result tree is a fiction of
            the
            specification, and does not occupy real memory in a typical implementation.
         </div>
         <div class="para e40">It has long been recognized that the need to hold the source tree in memory is a serious
            restriction for many applications. Researchers have made a number of attempts to tackle
            the problem:
         </div>
         <div class="orderedlist e41">
            <div class="listitem e42">
               <div class="para e43">Some have concentrated on streaming XPath processors (
                  <div class="xref e44" linkend="Barton2003"></div>,
                  
                  <div class="xref e45" linkend="BarYossef2004"></div>, 
                  <div class="xref e46" linkend="Joshi"></div>). The focus here is on
                  rewriting the reverse axes (such as preceding-sibling) in terms of forwards axes.
                  There
                  has been significant progress demonstrated in these projects, though they all leave
                  out
                  some of the most awkward features of the language, such as the 
                  <div class="code e47">last()</div>
                  function. However, streamed evaluation of a single XPath expression during a single
                  pass
                  of a source document does not help much with streamed evaluation of XSLT, since a
                  stylesheet contains many XPath expressions, and the starting point for one is typically
                  dependent on the nodes found by another.
               </div>
            </div>
            <div class="listitem e48">
               <div class="para e49">Other projects have concentrated on streamed evaluation of XQuery (
                  <div class="xref e50" linkend="Florescu2003"></div>, 
                  <div class="xref e51" linkend="Li2005"></div>). Again these projects rely heavily
                  on rewriting the execution plan. These results are difficult to translate to XSLT,
                  because
                  XQuery has the luxury of a flow-of-control that is fully statically analyzable (there
                  is
                  no polymorphism or dynamic despatch). In XQuery, the compiler can look at a function
                  call
                  and know which function it is calling; it can therefore determine what navigation
                  is
                  performed by the called function. Template rules in XSLT, by contrast, are fired
                  dynamically based on input data.
               </div>
            </div>
            <div class="listitem e52">
               <div class="para e53">Guo et al (
                  <div class="xref e54" linkend="Guo2004"></div>) describe an approach to streamed XSLT processing that restricts the supported
                  XSLT constructs to a small core. This core language is DTD-aware, and restricts match
                  patterns to those
                  that can be uniquely ascribed to an element declaration in the DTD grammar. XPath
                  expressions appear only
                  in the 
                  <div class="code e55">xsl:apply-templates</div> instruction, and always select downwards by element name. As a result,
                  the call hierarchy becomes statically tractable, as in the XQuery case.
               </div>
            </div>
            <div class="listitem e56">
               <div class="para e57">Zergaoui (
                  <div class="xref e58" linkend="Zergaoui2009"></div>) observes that many transformations
                  are intrinsically non-streamable, because the events representing the result tree
                  appear in a different
                  order from the events from the source tree on which they depend. He therefore suggests
                  that pure
                  (zero-memory) streaming is an impractical goal, and that practical engineering solutions
                  should
                  strive rather to minimize the amount of buffering needed, without restricting the
                  expressive
                  capabilities of the transformation language.
                  
               </div>
            </div>
            <div class="listitem e59">
               <div class="para e60">Echoing this, Dvorakova (
                  <div class="xref e61" linkend="Dvorakova2008"></div>, 
                  <div class="xref e62" linkend="Dvorakova2009a"></div>,
                  
                  <div class="xref e63" linkend="Dvorakova2009b"></div>) and her colleagues describe an approach that supports
                  a rather larger subset of the XSLT language, though it still contains some serious
                  limitations:
                  match patterns in template rules are simple element names, path expressions can select
                  downwards only, recursive structures in the schema are not allowed. Their approach,
                  implemented in the Xord framework, is based on static analysis of the XSLT code in
                  the
                  context of a schema to determine the extent to which streaming can be employed, and
                  the
                  scope of input buffering needed to handle constructs (for example, non-order-preserving
                  constructs) where pure streaming is not possible. (An implicit assumption of their
                  approach, which sadly is not true in real life, is that an element name appearing
                  in the
                  match pattern of a template rule can be used to identify unambiguously a schema definition
                  of the structure of the elements that match this rule.)
               </div>
            </div>
            <div class="listitem e64">
               <div class="para e65">Others have adopted the approach that if XSLT cannot be streamed, then a different
                  language
                  is needed. STX 
                  <div class="xref e66" linkend="STX"></div> is one example of an alternative transformation language, designed explicitly for
                  streaming.
                  Another is the INRIA XStream project (
                  <div class="xref e67" linkend="Frisch2007"></div>) (not to be confused with other projects of the same name).
                  STX abandons the attempt to be purely declarative, instead giving the programmer access
                  to mutable
                  variables which can be used to remember data from the input document that might be
                  needed later in the transformation;
                  this means that the responsibility for controlling memory usage rests entirely on
                  the programmer.
                  XStream, by contrast, is a purely functional language that relies heavily on partial
                  evaluation of functions
                  as soon as relevant inputs are available; the buffering of input is thus represented
                  by the pool of partially-evaluated
                  function calls, and the efficiency of the process depends strongly on the programmer
                  having a good
                  understanding of this execution model.
                  
               </div>
            </div>
         </div>
         <div class="para e68">What all this activity makes clear is that streaming of the XSLT language as currently
            defined is seriously
            difficult; it is unreasonable to treat streaming as a mere optimization that implementors
            can provide if they
            choose to apply themselves to the task.
         </div>
         <div class="para e69">Since 2007 the W3C XSL Working Group has been working on enhancements to the XSLT
            language designed
            to make streaming a feasible proposition. A first working draft of XSLT 2.1 has been
            published (
            <div class="xref e70" linkend="Kay2010b"></div>), 
            and an overview
            of the design approach is available in 
            <div class="xref e71" linkend="Kay2010a"></div>.
         </div>
         <div class="para e72">This paper describes how streaming is implemented in the Saxon XSLT processor (
            <div class="xref e73" linkend="Saxonica"></div>). This is influenced
            by the work of the W3C specification, but it is by no means an exact match to the
            specification in its current form:
            many features that should be streamable according to the specification are not yet
            streamable in Saxon, while Saxon
            succeeds in streaming some constructs that are non-streamable according to XSLT 2.1.
         </div>
         <div class="para e74">Streaming facilities in Saxon have been developed over a number of years, and have
            become
            gradually more sophisticated in successive releases. In order to aid understanding,
            the
            facilities are therefore presented as a narrative, describing enhancements as they
            were
            introduced in successive releases. This includes features that have been implemented
            but not
            yet released at the time of writing, in what is destined to be Saxon 9.3.
         </div>
      </div><a name="StreamedXPathintheSchemaValidatorANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e75">
         <div class="title e76">Streamed XPath in the Schema Validator</div>
         <div class="para e77">Since version 8.0, released in June 2004, Saxon has incorporated an XML Schema 1.0
            processor. This was introduced to underpin the schema-aware capabilities of the (then
            draft)
            XSLT 2.0 and XQuery 1.0 specifications, but can also be used as a freestanding validator
            in
            its own right.
         </div>
         <div class="para e78">XML Schema 1.0 (XSD 1.0) allows uniqueness and referential constraints to be expressed
            by
            means of XPath expressions. For example, in a schema describing XSLT stylesheet documents,
            the
            constraint that every 
            <div class="code e79">with-param</div> element within an 
            <div class="code e80">call-template</div>
            element must have a distinct value for its 
            <div class="code e81">name</div> attribute might be expressed as
            follows:
         </div>
         <div class="programlisting e82" xml:space="preserve">
            &lt;xs:element name="call-template" type="call-template-type"&gt;
            &lt;xs:unique&gt;
            &lt;xs:selector xpath="xsl:with-param"/&gt;
            &lt;xs:field xpath="@name"/&gt;
            &lt;/xs:unique&gt;
            &lt;/xs:element&gt;
            
         </div>
         <div class="para e83">In this example the two XPath expressions are very simple. XSD 1.0 allows them to
            be rather
            more complicated than these examples, but they are still restricted to a very small
            subset of
            XPath: downward selection only; no predicates; union operator allowed at the top level
            only.
            The specification explicitly states the reason why the subset is so small:
         </div>
         <div class="popupBox e84">
            <div class="popupLabel" onmouseover="$('#d1e151').show('1000');" onmouseout="$('#d1e151').hide('1000');">[ blockquote ]</div>
            <div id="d1e151" style="display: none;">
               <div class="blockquote">
                  <div class="para e85">In order to reduce the burden on implementers, in particular implementers of streaming
                     processors, 
                     only restricted subsets of XPath expressions are allowed in {selector} and {fields}.
                     
                  </div>
               </div>
            </div>
         </div>
         <div class="para e86">It was important to the designers of XML Schema 1.0 that a validator should be able
            to process its input document
            in a pure streaming manner with no buffering, and a subset of XPath was chosen to
            make this viable.
         </div>
         <div class="para e87">Accordingly, Saxon 8.0 included in its schema processor a streamed implementation
            of this XPath subset.
         </div>
         <div class="para e88">For various reasons, the schema validator in Saxon was implemented as a push pipeline
            (
            <div class="xref e89" linkend="Kay2009"></div>); the component for evaluating uniqueness and referential constraints
            forms one of the steps in this pipeline. A SAX XML parser generates a sequence of
            parsing
            events (startElement, endElement, etc) which are piped into the validator, which in
            turn
            passes them on to the next stage in the process, whatever that might be. Streamed
            XPath
            evaluation therefore operates in push mode, and this design choice continues to affect
            the way
            the design evolves today. One of the great advantages of a push pipeline is that it
            is easy to
            direct parsing events to many different consumers: this is particularly useful with
            uniqueness
            constraints because many such constraints can be under evaluation at any one time,
            scoped to
            the same or different parent elements.
         </div>
         <div class="para e90">The despatching of events to the listeners involved in evaluating a uniqueness constraint
            is handled by a component
            called the 
            <div class="code e91">WatchManager</div>; each of the listening components is called a 
            <div class="code e92">Watch</div>. For the example
            constraint given, the process is as follows:
         </div>
         <div class="orderedlist e93">
            <div class="listitem e94">
               <div class="para e95">When the startElement event for the 
                  <div class="code e96">xsl:call-template</div> element is notified by the
                  parser, the validator for the 
                  <div class="code e97">xsl:call-template</div> element is fired up. This
                  creates a 
                  <div class="code e98">SelectorWatch</div> for the uniqueness constraint. The
                  
                  <div class="code e99">SelectorWatch</div> maintains a table of key values that have been encountered
                  (initially empty) so that it can check these for uniqueness.
               </div>
            </div>
            <div class="listitem e100">
               <div class="para e101">All parsing events are now notified to this 
                  <div class="code e102">SelectorWatch</div>. For each event, it
                  checks whether the ancestor path in the document matches the path given in the
                  
                  <div class="code e103">xs:selector</div> element. In this case this is simply a test whether the event
                  is a startElement event for an 
                  <div class="code e104">xsl:with-param</div> element. More generally, it is
                  essentially a match of one list of element names against another list of element names,
                  taking account of the fact that the 
                  <div class="code e105">//</div> operator can appear at the start of
                  the path to indicate that it is not anchored to the root 
                  <div class="code e106">xsl:call-template</div>
                  element. When the matching startElement event is encountered, the
                  
                  <div class="code e107">SelectorWatch</div> instantiates a 
                  <div class="code e108">FieldWatch</div> to process any nodes
                  that match the expression in the 
                  <div class="code e109">xs:field</div> element.
               </div>
            </div>
            <div class="listitem e110">
               <div class="para e111">The 
                  <div class="code e112">FieldWatch</div> is now notified of all parsing events, and when the
                  
                  <div class="code e113">@name</div> attribute is encountered, it informs the owning
                  
                  <div class="code e114">SelectorWatch</div>, which checks that its value does not conflict with any value
                  previously notified. This process is more complex than might appear, because there
                  can be
                  multiple 
                  <div class="code e115">xs:field</div> elements to define a composite key, and furthermore, the
                  field value can be an element rather than an attribute, in which case it may be necessary
                  to assemble the value from multiple text nodes separated by comments or processing
                  instructions. It is also necessary to check that the 
                  <div class="code e116">FieldWatch</div> fires exactly
                  once. (A simplifying factor, however, is that XSD requires the element to have simple
                  content.) 
               </div>
            </div>
            <div class="listitem e117">
               <div class="para e118">After detecting a 
                  <div class="code e119">startElement</div> event that matches its path expression, the
                  
                  <div class="code e120">SelectorWatch</div> must remain alert for further matching events. Before the
                  corresponding 
                  <div class="code e121">endElement</div> event is encountered, another matching
                  
                  <div class="code e122">startElement</div> might be notified. This cannot happen in the above example.
                  But consider the constraint that within each section of a chapter, the figure numbers
                  must
                  be unique: 
               </div>
               <div class="programlisting e123" xml:space="preserve">
                  &lt;xs:element name="chapter" type="call-template-type"&gt;
                  &lt;xs:unique&gt;
                  &lt;xs:selector xpath=".//section"/&gt;
                  &lt;xs:field xpath=".//figure"/&gt;
                  &lt;/xs:unique&gt;
                  &lt;/xs:element&gt;
                  
               </div>
               <div class="para e124">It is entirely possible here for chapters to be nested within chapters, and for
                  sections to be nested within sections. (It is not possible for figures to be nested
                  within
                  figures, however: the node selected by the 
                  <div class="code e125">xs:field</div> element must have simple
                  content.) The 
                  <div class="code e126">WatchManager</div> may therefore be distributing events
                  simultaneously to a large number of 
                  <div class="code e127">Watch</div> instances, even for a single
                  uniqueness constraint; at the same time, of course, other uniqueness constraints may
                  be
                  active on the same elements or on different elements at a different level of the source
                  tree.
               </div>
            </div>
         </div>
      </div><a name="StreamingCopyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e128">
         <div class="title e129">Streaming Copy</div>
         <div class="para e130">The next step in Saxon's journey towards becoming a streaming XSLT processor was to
            exploit the mechanisms described in the previous section in contexts other than schema
            validation. This was introduced in Saxon 8.5, released in August 2005, and subsequently
            extended. The facility used standard XSLT 2.0 syntax, but required the user to write
            code in a
            highly stereotyped way for streaming to be possible.
         </div><a name="InitialimplementationofStreamingCopyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e131">
            <div class="title e132">Initial implementation of Streaming Copy</div>
            <div class="para e133">Typically, the user would write code like this:</div>
            <div class="programlisting e134" xml:space="preserve">
               
               &lt;xsl:function name="f:customers"&gt;
               &lt;xsl:copy-of select="doc('customers.xml')/*/customer"
               saxon:read-once="yes" xmlns:saxon="http://saxon.sf.net/"/&gt;
               &lt;/xsl:function&gt;
               
               &lt;xsl:template name="main"&gt;
               &lt;xsl:apply-templates select="f:customers()"/&gt;
               &lt;/xsl:template&gt;
               
               
            </div>
            <div class="para e135">Without the processing hint expressed by the 
               <div class="code e136">saxon:read-once</div> attribute, this
               code would parse the source document 
               <div class="code e137">customers.xml</div> and build a tree
               representation of the document in memory. It would then search the tree for the elements
               matching the path 
               <div class="code e138">/*/customer</div>, and for each of these in turn it would create a
               copy of the subtree rooted at this element, returning it from the function and then
               applying
               templates to it.
            </div>
            <div class="para e139">It is easy to see that in this operation, building the tree representation of the
               large
               
               <div class="code e140">customers.xml</div> document is unnecessary; it can be bypassed if the elements
               matching 
               <div class="code e141">/*/customer</div> can be recognized in the event stream issuing from the XML
               parser. Instead of one large tree, the processor can build a series of smaller trees,
               each
               representing a single customer record. So long as the size of the customer record
               is kept
               within bounds, there is then no limit on the number of customer records present in
               the input
               document. This is sometimes referred to as 
               <div class="emphasis e142">windowing</div> or
               
               <div class="emphasis e143">burst-mode streaming</div>: the source document is processed as a sequence
               of small trees, rather than as one large tree.
            </div>
            <div class="para e144">The use of the 
               <div class="code e145">xsl:copy-of</div> instruction here is significant. In the implementation, there is no physical
               copying taking place, because the original whole-document tree is never built. But
               the result is equivalent to the result
               of building the whole-document tree and then copying the sequence of subtrees. In
               particular, the nodes in one subtree
               are not linked in any way to the nodes in other subtrees; there is no way the application
               can navigate outside the boundaries
               of a subtree. Attempting to retrieve the ancestors or siblings of the 
               <div class="code e146">customer</div> element returns nothing,
               just as it would with a true subtree copy.
            </div>
            <div class="para e147">Saxon implements this construct by reusing the 
               <div class="code e148">WatchManager</div> machinery
               described in the previous section. Having analyzed the 
               <div class="code e149">select</div> attribute of the
               
               <div class="code e150">xsl:copy-of</div> instruction to confirm that it satisfies the constraints on
               streamable XPath expressions, the document 
               <div class="code e151">customers.xml</div> is then processed
               using a SAX parser which sends parsing events to a 
               <div class="code e152">WatchManager</div> which in this
               case notifies a new kind of 
               <div class="code e153">Watch</div>, a 
               <div class="code e154">CopyWatch</div>, of the start and
               end of elements matching the path expression; between these start and end events,
               the
               
               <div class="code e155">CopyWatch</div> is notified of all intermediate events and uses these to build a
               tree representing the 
               <div class="code e156">customer</div> element.
            </div>
            <div class="para e157">Note again that two elements matching the path can be active at the same time. This
               cannot happen with the example above, because
               the path 
               <div class="code e158">/*/customer</div> has a fixed depth. But change the example to 
               <div class="code e159">//section</div>, and it is clear that
               the set of 
               <div class="code e160">section</div> elements selected by the path can include one section that is a subtree of another.
               This situation
               requires some internal buffering: the language semantics require that the sections
               are delivered in document order, which means that
               the outermost section must be delivered before its nested sections. The trees representing
               the nested sections must therefore
               be held in memory, to be released for processing only when the 
               <div class="code e161">endElement</div> event for the outermost section is
               notified. The code is written so that it is always prepared to do this buffering;
               in practice, it is very rarely needed, and
               no extra costs are incurred in the case where it is not needed. In some cases it would
               be possible to determine statically
               that no buffering will be needed, but this knowledge confers little benefit.
            </div>
            <div class="para e162">The reader may be puzzled by the choice of name for the attribute
               
               <div class="code e163">saxon:read-once="yes"</div>. Although the implementation of the
               
               <div class="code e164">xsl:copy-of</div> instruction in streaming mode is very different from the
               conventional execution plan, the functional behaviour is identical except in one minor
               detail: there is no longer a guarantee that if the 
               <div class="code e165">customers.xml</div> file is read
               more than once within the same transformation, its contents will be the same each
               time. At
               the time this feature was first implemented, the XSLT 2.0 conformance rules required
               implementations to deliver stable results in this situation. The streaming implementation
               necessarily departed from this rule (the only practical way to enforce the rule is
               to make
               an in-memory copy of the tree), so the 
               <div class="code e166">saxon:read-once</div> attribute was provided
               as a way for the user to assert that the file would not be read more than once, thus
               licensing the non-conformance in the case where the assertion was not honoured. In
               the final
               version of the XSLT 2.0 specification, there was explicit provision that implementations
               were allowed to provide a user option to waive the stability requirement for the
               
               <div class="code e167">doc()</div> function, thus making this extension conformant.
            </div>
            <div class="para e168">A further complication in the implementation is caused by the fact that the
               
               <div class="code e169">CopyWatch</div> component delivers its results (the sequence of small
               
               <div class="code e170">customer</div> trees) using a push interface (it calls the next component in the
               pipeline to deliver each one in turn), whereas the 
               <div class="code e171">xsl:apply-templates</div>
               instruction that calls the user-defined function expects to use a pull interface (it
               calls
               the XPath engine to deliver each one in turn). There is thus a push-pull conflict,
               which is
               resolved using the design described in 
               <div class="xref e172" linkend="Kay2009"></div> and shown in Figure 2. The push
               code operates in one thread, writing the sequence of 
               <div class="code e173">customer</div> trees to a cyclic
               buffer, which is then read by a parallel thread delivering the trees in response to
               requests
               from the 
               <div class="code e174">xsl:apply-templates</div> instruction.
            </div>
            <div class="figure e175">
               <div class="title e176">Figure 2: Two-thread processing model</div>
               <div class="mediaobject e177">
                  <div class="imageobject e178">
                     <div class="metaBox e179"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e391').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e391" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e179'
                              </span><span class="metaAttribute">fileref='../../../vol5/graphics/Kay01/Kay01-002.png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e180">
                  <div class="para e181">Thread One contains the parser and the push-mode evaluation of the streaming path
                     expression (the WatchManager and CopyWatch). This emits a sequence of small trees
                     (each
                     representing one customer record) to the cyclic butter, from where they are read by
                     the
                     pull-mode XPath engine running in Thread Two. Arrow represent flow of control.
                  </div>
               </div>
            </div>
         </div><a name="RefinementsoftheStreamingCopyfeatureANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e182">
            <div class="title e183">Refinements of the Streaming Copy feature</div>
            <div class="para e184">In releases subsequent to Saxon 8.5, the streaming copy mechanism described in the
               previous section was enhanced in a number of ways,
               without changing its fundamentals.
            </div>
            <div class="para e185">In Saxon 8.8 (September 2006) two changes were made. Firstly, the set of XPath expressions
               that could be handled in streaming mode was extended, to include union expressions
               and
               simple predicates. Secondly, the need for the two-thread model was eliminated in cases
               where
               no further processing of the copied subtrees was required: for example, in a transformation
               whose output contained these subtrees without modification.
            </div>
            <div class="para e186">In Saxon 9.1 (July 2008) the mechanism was extended to XQuery, via a new extension
               function 
               <div class="code e187">saxon:stream()</div>, which was also made available in XSLT. This might be
               regarded as a pseudo-function: the call
               
               <div class="code e188">saxon:stream(doc('customers.xml')/*/customer)</div> delivers a copy of the value of
               its argument (that is, a sequence of 
               <div class="code e189">customer</div> subtrees), but it requires its
               argument to conform to the syntax of streamable path expressions. 
               <div class="popupBox e190">
                  <div class="popupLabel" onmouseover="$('#d1e413').show('1000');" onmouseout="$('#d1e413').hide('1000');">[ footnote ]</div>
                  <div id="d1e413" style="display: none;">
                     <div class="footnote">
                        <div class="para e191">Looking at this syntax, one might reasonably ask whether a pull pipeline would not
                           deliver the result with less complexity. For this example, it probably would. The
                           push
                           code was used primarily because it already existed and could be reused. But I think
                           this
                           is no accident: I tend to the view that components implemented with a push model are
                           likely to be reusable in a wider variety of configurations. For more details on push
                           versus pull pipelines, see 
                           <div class="xref e192" linkend="Kay2009"></div>.
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="para e193">In Saxon 9.2 (August 2009) a further refinement was introduced to allow the processing
               of
               the input stream to terminate prematurely. For example, the query
               
               <div class="code e194">saxon:stream(doc('customers.xml')/*/@version)</div> will return the value of the
               
               <div class="code e195">version</div> attribute from the outermost element of the document, and will read
               no further once this has been seen. This makes it possible to obtain information from
               near
               the start of an XML document in constant time, regardless of the document size, which
               is
               especially useful in a pipeline when making decisions on how to route a document for
               processing based on information in its header. (It's a moot point whether this is
               consistent
               with the requirement in the XML 1.0 specification that all well-formedness errors
               in a
               document must be reported to the application. But the facility is so useful that we
               can
               ignore the standards-lawyers on this one.)
            </div>
         </div><a name="StreamingwithRetainedStateANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e196">
            <div class="title e197">Streaming with Retained State</div>
            <div class="para e198">A limitation of the streaming copy approach as outlined above is that there is no
               way of
               using the information in a subtree once the processing of that subtree has finished;
               so
               there is no way that the processing of one subtree can influence the processing of
               subsequent subtrees. (Saxon always had a workaround to this problem, the deprecated
               
               <div class="code e199">saxon:assign</div> instruction which introduces mutable variables to the language;
               but this plays havoc with optimisation).
            </div>
            <div class="para e200">An answer to this problem was found in the form of the 
               <div class="code e201">xsl:iterate</div>
               instruction defined in the XSLT 2.1 working draft. This was implemented in Saxon 9.2
               in the
               Saxon namespace (as 
               <div class="code e202">saxon:iterate</div>), but I will present it using the W3C syntax,
               which becomes available in Saxon 9.3.
            </div>
            <div class="para e203">Consider the problem of processing a sequence of 
               <div class="code e204">transaction</div> elements, and outputting the
               same sequence of elements but with an additional attribute holding the running balance
               on the account, obtained
               by accumulating the values of all the preceding transactions.
            </div>
            <div class="para e205">The classic solution to this would use sibling recursion:</div>
            <div class="programlisting e206" xml:space="preserve">
               &lt;xsl:template match="transaction"&gt;
               &lt;xsl:param name="balance" as="xs:decimal"/&gt;
               &lt;transaction value="{@value}" balance="{$balance + @value}"/&gt;
               &lt;xsl:apply-templates select="following-sibling::transaction[1]"&gt;
               &lt;xsl:with-param name="balance" select="$balance + @value"/&gt;
               &lt;/xsl:apply-templates&gt;
               &lt;/xsl:template&gt;
            </div>
            <div class="para e207">There are a number of difficulties with this approach. Firstly, everyone who has taught
               XSLT appears to agree that students have considerable difficulty producing the code
               above as
               the solution to this exercise, despite its brevity and apparent simplicity. Secondly,
               it
               relies rather heavily on the XSLT processor implementing tail call optimization; if
               you run
               this on a variety of popular XSLT processors, many of them will run out of stack space
               after
               processing 500 or so transactions, showing that they do not implement this optimization.
               Finally, the analysis needed to demonstrate that a streaming implementation of this
               code is
               feasible is far from easy, and one suspects that minor departures from this particular
               way
               of writing the code will invalidate any such analysis.
            </div>
            <div class="para e208">For all these reasons, XSLT 2.1 introduces a new instruction 
               <div class="code e209">xsl:iterate</div>, which allows the solution to
               be expressed as follows:
            </div>
            <div class="programlisting e210" xml:space="preserve">
               &lt;xsl:iterate select="transaction"&gt;
               &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;
               &lt;transaction value="{@value}" balance="{$balance + @value}"/&gt;
               &lt;xsl:next-iteration&gt;
               &lt;xsl:with-param name="balance" select="$balance + @value"/&gt;
               &lt;/xsl:next-iteration&gt;
               &lt;/xsl:iteration&gt;
            </div>
            <div class="para e211">This has the appearance of a simple loop rather than functional recursion; it behaves
               like
               the familiar 
               <div class="code e212">xsl:for-each</div> instruction with the added ability to set a parameter
               after the processing of one value which is then available for use when processing
               the next.
               A key difference compared with the recursive solution is that the set of transactions
               to be
               processed is identified in one place, the 
               <div class="code e213">select</div> attribute of the
               
               <div class="code e214">xsl:iterate</div> instruction, rather than being the product of a sequence of
               independent calls on 
               <div class="code e215">following-sibling</div>. A useful consequence of this difference
               is that termination is guaranteed.
            </div>
            <div class="para e216">Another way of looking at 
               <div class="code e217">xsl:iterate</div> is as syntactic sugar for the
               
               <div class="code e218">foldl</div> higher-order function found in many functional programming languages:
               this applies a user-supplied function (the body of 
               <div class="code e219">xsl:iterate</div>) to each item of
               an input sequence (the value of the 
               <div class="code e220">select</div> expression), with each iteration
               delivering an accumulated value of some kind, which is made available as a parameter
               to the
               user-supplied function when called to process the next item.
            </div>
            <div class="para e221">Saxon 9.2 implements this new instruction (albeit in its own namespace) and allows
               the
               
               <div class="code e222">select</div> expression to select the stream of subtrees arising from a streaming
               copy operation: for example 
               <div class="code e223">&lt;xsl:iterate
                  select="saxon:stream(doc('transactions'xml')/*/transaction"&gt;
               </div>. By this means,
               information computed while processing one input transaction can be made available
               while
               processing the next. The implementation of 
               <div class="code e224">xsl:iterate</div> in fact knows nothing
               about streaming; it is processing the sequence of subtrees just as it would process
               any
               other sequence of items.
            </div>
         </div><a name="LimitationsofStreamingCopyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e225">
            <div class="title e226">Limitations of Streaming Copy</div>
            <div class="para e227">The streaming copy feature has enabled many applications to be written using Saxon
               that
               would otherwise have been impossible because of the size of the input document. Many
               of the
               streaming use cases published by the W3C Working Group (
               <div class="xref e228" linkend="Cimprich2010"></div>) can be implemented using
               this feature. But despite the various refinements that have been described, there
               are some
               serious limitations:
            </div>
            <div class="itemizedlist e229">
               <div class="listitem e230">
                  <div class="para e231">There is no way of getting access to part of the streamed source document other than
                     what is contained in the copied subtrees. This problem can be mitigated by using a
                     union expression to select
                     all the data that is needed. However, the programming then becomes rather complex.
                  </div>
               </div>
               <div class="listitem e232">
                  <div class="para e233">The design pattern works well with "hedge-like" source documents: those where the
                     hierarchy
                     fans out quickly to a large number of small subtrees. But there are many large source
                     documents that do not fit into this pattern - this arises particularly with
                     "document-oriented" XML, but also for example with GML (Geography Markup Language)
                     [gml]
                     where individual geographical features represented in the data stream can each be
                     of
                     considerable size.
                  </div>
               </div>
            </div>
            <div class="para e234">These limitations arise because streaming copy treats the input document as a flat
               sequence of elements, not really as a hierarchy. To address these limitations, it
               is
               necessary to restore the ability to process the input tree using recursive descent
               using
               template rules. The way in which template rules can be made to work in a streaming
               manner is
               the subject of the next section.
            </div>
         </div>
      </div><a name="StreamingTemplatesANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e235">
         <div class="title e236">Streaming Templates</div>
         <div class="para e237">Consider a stylesheet containing the following two rules:</div>
         <div class="programlisting e238" xml:space="preserve">
            &lt;xsl:template match="*"&gt;
            &lt;xsl:copy&gt;
            &lt;xsl:apply-templates/&gt;
            &lt;/xsl:copy&gt;
            &lt;/xsl:template&gt;
            
            &lt;xsl:template match="note"/&gt;
            
         </div>
         <div class="para e239">This follows a familiar coding pattern: first a generic template which acts as the
            default processing for all
            elements in the source document (this example copies the element to the output, sans
            attributes, and uses the
            
            <div class="code e240">xsl:apply-templates</div> instruction to invoke recursive processing of its children); then one or more templates
            for specific named elements to process them in a way that differs from the general
            rule. The effect of this stylesheet
            is to copy the source document to the result document unchanged except for the loss
            of all attributes, and of elements
            named 
            <div class="code e241">note</div> together with their descendants.
         </div>
         <div class="para e242">It is easy to see how this stylesheet could be implemented in a single pass over the
            source document, without building an in-memory tree. A simple filter can be applied
            to events
            emanating from the parser before passing them on to the serializer: all events are
            passed on
            unchanged, except for (a) events representing attribute nodes and (b) events that
            occur
            between the 
            <div class="code e243">startElement</div> event and corresponding 
            <div class="code e244">endElement</div> event
            for a 
            <div class="code e245">note</div> element.
         </div>
         <div class="para e246">In XSLT 2.1 streamability is a property of a 
            <div class="emphasis e247" role="ital">mode</div> (
            <div class="xref e248" linkend="Kay2010a"></div>). 
            If a mode is declared to be streamable, then all the template rules in that mode must
            obey the restrictions placed on streamable templates. The analysis defined in the
            XSLT 2.1
            specification to determine streamability is rather complex; the rules currently implemented
            in
            Saxon are much simpler (and in most cases, more restrictive), while still allowing
            a wide
            class of transformations to be expressed. I will present first the Saxon 9.2 implementation,
            which is relatively easy to understand, and then the Saxon 9.3 extensions, which add
            considerable complexity and power.
         </div><a name="StreamingTemplatesinSaxon92ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e249">
            <div class="title e250">Streaming Templates in Saxon 9.2</div>
            <div class="para e251">Saxon 9.2 follows the principle that streamability is a property of a mode, though
               its
               restrictions on streamable templates are far more severe than those in the XSLT 2.1
               draft.
               The rules for streamable templates can be summarised (in simplified form) as follows:
            </div>
            <div class="itemizedlist e252">
               <div class="listitem e253">
                  <div class="para e254">The match pattern must contain no predicates.</div>
               </div>
               <div class="listitem e255">
                  <div class="para e256">The template body may contain at most one 
                     <div class="emphasis e257">drill-down construct</div>. This may
                     be an 
                     <div class="code e258">xsl:apply-templates</div> instruction with defaulted 
                     <div class="code e259">select</div>
                     expression, or one of the following expressions or instructions applied to the context
                     node: 
                     <div class="code e260">xsl:copy-of</div>, 
                     <div class="code e261">xsl:value-of</div>, 
                     <div class="code e262">string()</div>,
                     
                     <div class="code e263">data()</div> (or implicit atomization), or one of a small number of other
                     constructs.
                  </div>
               </div>
               <div class="listitem e264">
                  <div class="para e265">The drill-down construct may have only the following as its containing (ancestor)
                     instructions: 
                     <div class="code e266">xsl:element</div>, literal result elements,
                     
                     <div class="code e267">xsl:value-of</div>, 
                     <div class="code e268">xsl:attribute</div>, 
                     <div class="code e269">xsl:comment</div>,
                     
                     <div class="code e270">xsl:processing-instruction</div>, 
                     <div class="code e271">xsl:result-document</div>,
                     
                     <div class="code e272">xsl:variable</div>, 
                     <div class="code e273">xsl:sequence</div>.
                  </div>
               </div>
               <div class="listitem e274">
                  <div class="para e275">Apart from the drill-down construct and its ancestors, any expression within the template
                     that
                     has a dependency on the context item must fall into one of the following categories:
                     (a)
                     a function (for example, 
                     <div class="code e276">local-name()</div> or 
                     <div class="code e277">exists()</div>) that
                     returns a local property of the node, or of one of its attributes or ancestors, or
                     of an
                     attribute of an ancestor; (b) an expression that returns the string value or typed
                     value
                     of an attribute of the node or an attribute of one of its ancestors.
                  </div>
               </div>
            </div>
            <div class="para e278">The effect of these rules is that the stylesheet given above, with the addition of
               the declaration 
               
               <div class="code e279">&lt;xsl:mode streamable="yes"/&gt;</div>
               <div class="popupBox e280">
                  <div class="popupLabel" onmouseover="$('#d1e624').show('1000');" onmouseout="$('#d1e624').hide('1000');">[ footnote ]</div>
                  <div id="d1e624" style="display: none;">
                     <div class="footnote">
                        <div class="para e281">In Saxon 9.2, the element is in the Saxon namespace as 
                           <div class="code e282">saxon:mode</div>
                        </div>
                     </div>
                  </div>
               </div>,
               is fully streamable.
            </div>
            <div class="para e283">These rules allow a wide variety of transformations to be expressed. However, they
               impose
               many arbitrary restrictions. For example, a template cannot contain the instruction
               
               <div class="code e284">&lt;xsl:value-of select=". + 3"/&gt;</div>, because an addition expression
               (
               <div class="code e285">+</div>) is not an acceptable ancestor of the implicit drill-down construct
               
               <div class="code e286">data(.)</div>. To get around this restriction, it is possible to bind a variable to
               the value of 
               <div class="code e287">data(.)</div> and then perform the addition using the value of the
               variable.
            </div>
            <div class="para e288">To understand the reason for such arbitrary restrictions, it is necessary to understand
               something of the architecture of the implementation: whose explanation, indeed, is
               the main
               purpose of this paper.
            </div>
            <div class="para e289">Traditionally, Saxon constructed the source tree using a push pipeline. XSLT instructions
               were then interpreted, and by-and-large, they evaluated their XPath subexpressions
               using a
               pull pipeline of iterator objects navigating the source tree, and generated output
               (including temporary trees) by pushing SAX-like events to a serializer or tree builder
               pipeline. To implement streaming templates, this model has been turned upside-down,
               almost
               literally. During streamed evaluation, everything operates in push mode, driven by
               events
               coming from the XML parser. In effect, the code implementing a template rule operating
               in
               push mode is a Jackson inversion (
               <div class="xref e290" linkend="Kay2009"></div>) of the code used to implement
               the same template rule in the traditional architecture. This inversion is analogous
               to
               rewriting a top-down parser as a bottom-up parser: instead of the application being
               in
               control and making 
               <div class="code e291">getNextInput()</div> calls to the parser, the application becomes
               event-driven and is called when new input is available. In consequence, the application
               has
               to maintain its own stack to represent the current state; it can no longer rely on
               the call
               stack maintained by the compiler of the implementation language.
            </div>
            <div class="para e292">The inverted code for a template is generated by the XSLT compiler, and consists (in
               Saxon
               9.2) of a sequence of pre-descent actions, a drill-down action, and a sequence of
               post-descent actions. The pre-descent actions generally involve writing
               
               <div class="code e293">startElement</div> events or evaluating complete instructions; the post-descent
               actions similarly involve either complete instructions or 
               <div class="code e294">endElement</div> actions.
               These correspond to the instructions that are permitted as ancestors of the drill-drown
               construct: mainly instructions such as 
               <div class="code e295">xsl:element</div>, which are classified as
               
               <div class="emphasis e296" role="ital">divisible</div> instructions representing the fact that their
               push-mode execution can be split into two halves, realised by the entry points
               
               <div class="code e297">processLeft()</div> and 
               <div class="code e298">processRight()</div>. The drill-down action is one
               of 
               <div class="code e299">apply</div>, 
               <div class="code e300">copy-of</div>, 
               <div class="code e301">value-of</div>, or 
               <div class="code e302">skip</div>,
               and indicates what is to be done with the content of the matched element (the events
               that
               occur after the 
               <div class="code e303">startElement</div> that activates the template rule and before the
               corresponding 
               <div class="code e304">endElement</div>). The value 
               <div class="code e305">skip</div> causes these events to
               be skipped, and arises when the template rule contains no drill-down construct. The
               value
               
               <div class="code e306">copy-of</div> indicates that a subtree is to be built from these events;
               
               <div class="code e307">value-of</div> indicates that a string is to be constructed by concatenating the
               text nodes and ignoring everything else. Finally, the value 
               <div class="code e308">apply</div> indicates
               that the events should be matched against template rules for the relevant mode; when
               a match
               occurs, the selected template rule will then receive the events until the matching
               
               <div class="code e309">endElement</div> event occurs.
            </div>
            <div class="para e310">This is all implemented using the a 
               <div class="code e311">StreamingDespatcher</div> that despatches events
               to the relevant template rules. This functions in a very similar way to the
               
               <div class="code e312">WatchManager</div> described earlier, and in the current Saxon 9.3 code base the
               two despatching classes have been combined into one.
            </div>
         </div><a name="StreamableTemplatesinSaxon93ANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e313">
            <div class="title e314">Streamable Templates in Saxon 9.3</div>
            <div class="para e315">Saxon 9.3 (not yet released at the time of submitting this paper) extends streamable
               templates to handle a much
               larger subset of the XSLT language, while still falling a little short of the capabilities
               defined in the XSLT 2.1 draft.
            </div>
            <div class="para e316">The first extension is in the area of match patterns for templates. Saxon 9.3 integrates
               the two concepts of a match pattern
               and a streamable XPath expression. This makes sense because both are implemented by
               testing to see whether a given
               node matches the pattern; the only difference is that with an XSLT match pattern in
               non-streaming mode, the predicates can
               contain XPath expressions that perform arbitrary tree navigation. For XSD selector
               and field expressions, the parsing still
               artificially restricts the path expression to conform to the XSD-defined XPath subset,
               but the object that results from the parsing,
               and that is used at run-time, is a 
               <div class="code e317">Pattern</div> object equivalent that used when starting from an XSLT match pattern.
               The pattern used in a streamable template rule can be any XSLT pattern provided it
               does not contain a predicate that is
               positional (for example, is numeric or calls 
               <div class="code e318">position()</div> or 
               <div class="code e319">last()</div>) or that uses
               the child, descendant, descendant-or-self, following, following-sibling, preceding,
               or preceding-sibling axes.
            </div>
            <div class="para e320">The body of the template rule is inverted in the same way as with Saxon 9.2, but the
               rules for what it may contain are less restrictive. There is still a rule that only
               one
               downward selection is allowed: more specifically, in the expression tree (abstract
               syntax
               tree) representing the body of the template rule, there must be only one leaf node
               whose
               path to the root of the expression tree contains a downwards selection. This path
               through
               the expression tree is referred to as the 
               <div class="emphasis e321" role="ital">streaming route</div>.
               This rule is relaxed in the case where the template contains a conditional instruction
               such
               as 
               <div class="code e322">xsl:choose</div>; in this case each branch of the conditional may make downwards
               selections. Unlike the XSLT 2.1 draft, Saxon does not currently allow a node in the
               streamed
               input document to be bound to a variable, or passed as a parameter to another template
               or
               function. A further rule is that the template must not return a node in the streamed
               document (for example, 
               <div class="code e323">&lt;xsl:sequence select="."/&gt;</div>) - this is because there
               is no way of analyzing what the caller attempts to do with such a node.
            </div>
            <div class="para e324">It is also possible, of course, for the template rule to make no downward selection
               at all: this results in the subtree
               below the matched node being skipped.
            </div>
            <div class="para e325">All the expressions that appear on the streaming route must be capable of push
               evaluation, that is, they must have an implementation that is event-driven. Saxon
               supports
               push evaluation at two different levels of granularity (
               <div class="xref e326" linkend="Kay2009"></div>),
               parse-event granularity and item granularity; the corresponding event streams are
               referred
               to respectively as decomposed or composed streams. In the first case the expression
               evaluator is notified every time a parse event occurs (for example, startElement and
               endElement). In the second case, it is notified only for complete XDM items (nodes
               or atomic
               values). The 
               <div class="code e327">sum()</div> function supports push evaluation at the item level, which
               means that given the expression 
               <div class="code e328">sum(.//value)</div>, each descendant
               
               <div class="code e329">value</div> element is assembled as a complete node, which is then atomized, and
               the resulting atomic values are notified one by one to the sum implementation, which
               adds
               each one in turn to the running total. By constrast, the functions 
               <div class="code e330">count()</div> and
               
               <div class="code e331">exists()</div> have implementations that work at the parse-event level, which means
               that there is no need to build the nodes being counted as trees in memory: thus
               
               <div class="code e332">count(.//employee)</div> merely tallies the startElement events that match its
               argument expression 
               <div class="code e333">.//employee</div> without ever building a tree representation of
               an 
               <div class="code e334">employee</div> element.
            </div>
            <div class="para e335">A push component that takes a composed stream (XDM items) as input is referred to
               as a 
               <div class="emphasis e336" role="ital">feed</div>; an evaluator 
               that works on a decomposed stream (parse events) is referred to as a 
               <div class="emphasis e337" role="ital">watch</div>. This classification
               is based on the nature of the input stream. Orthogonally, the component may deliver
               its result as either a composed or
               decomposed stream: so there are four categories overall: a composing and decomposing
               Watch, and a composing and decomposing Feed.
               Examples of the four categories are shown in the table below:
               
            </div>
            <div class="table e338">
               <div class="thead e339">
                  <div class="tr e340">
                     <div class="th e341">Input/Output</div>
                     <div class="th e342">Composed</div>
                     <div class="th e343">Decomposed</div>
                  </div>
               </div>
               <div class="tbody e344">
                  <div class="tr e345">
                     <div class="td e346">Composed</div>
                     <div class="td e347">remove($in, 3)</div>
                     <div class="td e348">&lt;e&gt;{$in}&lt;/e&gt;</div>
                  </div>
                  <div class="tr e349">
                     <div class="td e350">Decomposed</div>
                     <div class="td e351">data($in)</div>
                     <div class="td e352">&lt;xsl:for-each select="$in"/&gt;</div>
                  </div>
               </div>
            </div>
            <div class="para e353">In general, the flow is that decomposed events arrive from the source XML parser.
               After
               some processing they are turned into composed items; these are then further processed,
               and
               eventually decomposed into events to be sent to the serializer. To make this more
               concrete
               consider the streaming template:
            </div>
            <div class="programlisting e354" xml:space="preserve">
               &lt;xsl:template match="emp"&gt;
               &lt;employee name="{@name}" nr="{@empNr}"&gt;
               &lt;xsl:value-of select="distinct-values(skills/skill)"/&gt;
               &lt;/employee&gt;
               &lt;/xsl:template&gt;
               
            </div>
            <div class="para e355">The streaming route here contains a literal result element (
               <div class="code e356">employee</div>), the
               
               <div class="code e357">xsl:value-of</div> instruction, the 
               <div class="code e358">distinct-values()</div> function call,
               and the path expression 
               <div class="code e359">skills/skill</div>. It also contains expressions added by the
               compiler, reflecting the implicit atomization and type checking performed by the
               
               <div class="code e360">distinct-values()</div> function, and the implicit call on
               
               <div class="code e361">string-join()</div> that is performed to insert separator spaces on behalf of the
               
               <div class="code e362">xsl:value-of</div> instruction. The full expression tree is shown in Figure 3, with
               the streaming route highlighted.
            </div>
            <div class="figure e363" xml:id="fig03">
               <div class="title e364">Figure 3: The expression tree of a template, showing the streaming route</div>
               <div class="mediaobject e365">
                  <div class="imageobject e366">
                     <div class="metaBox e367"><img src="resources/manbluflag.jpg" class="metaImage" onclick="$('#d1e840').toggle('1000');" alt="Marker: click here for details..." title="Marker: click here for details..."><div id="d1e840" class="metaSource" style="display:none;">                
                           &lt;imagedata<span class="metaAttribute">class='e367'
                              </span><span class="metaAttribute">fileref='../../../vol5/graphics/Kay01/Kay01-003.png'
                              </span>
                           &gt;
                           
                        </div>
                     </div>
                  </div>
               </div>
               <div class="caption e368">
                  <div class="para e369">The expression tree omits some nodes, for example type-checking operators, for clarity.
                     The
                     highlighted "path" node acts as the Watch, looking for events coming from the parser
                     that match the
                     pattern 
                     <div class="code e370">skills/skill</div>. The 
                     <div class="code e371">data()</div> node composes these events into strings
                     representing the typed value of the 
                     <div class="code e372">skill</div> elements; these are fed through the operators
                     found on the streaming route until they reach the 
                     <div class="code e373">&lt;employee&gt;</div> element
                     constructor, which delivers a stream of events representing the newly constructed
                     element. Typically
                     these events go straight to the serializer. The parts of the expression tree that
                     are not on the streaming
                     route (the two attribute constructors) are evaluated in pull-mode as normal.
                  </div>
               </div>
            </div>
            <div class="para e374">The 
               <div class="code e375">distinct-values()</div> function implicitly atomizes its input. So the first
               thing that happens to the incoming data is that it is sent to a TypedValueWatch: this
               takes
               in a decomposed sequence of events and outputs a composed sequence of atomic values
               representing the typed values of the 
               <div class="code e376">skill</div> elements. This is piped into a type
               checker that checks that the values in this sequence are all strings. The type-checked
               csequence is then piped into the component that evaluates the 
               <div class="code e377">distinct-values()</div>
               function, which again outputs a composed stream (this being identical to its input
               stream
               except that values are removed from the stream if they have been encountered before).
               The
               
               <div class="code e378">xsl:value-of</div> instruction is initially compiled into a pipeline of primitive
               instructions that first joins adjacent text nodes, then atomizes, then inserts separators
               between adjacent strings, then converts the resulting string to a text node; in this
               case
               the optimizer knows from type analysis that the first two steps are superfluous, so
               we are
               left with a pipeline that takes a composed sequence of strings as its input, and produces
               a
               composed sequence comprising a single text node as its output. Finally, the component
               representing the literal result element 
               <div class="code e379">employee</div> takes this composed input, and
               produces decomposed output consisting of a startElement event, two attribute events,
               a text
               node event, and an endElement event. Typically these events will be sent directly
               to the
               serializer.
            </div>
            <div class="para e380">An expression, of course, may have more than one sub-expression, and it may be capable
               of push evaluation in respect of some of those sub-expressions but not others. All
               expressions support push evaluation in respect of sub-expressions that are singletons
               (cardinality zero-or-one). Thus, for example, the expression 
               <div class="code e381">(sum(.//value) +
                  1)
               </div> is streamable, because although there is no specific support for evaluating the
               addition in push mode, the system is capable of constructing the two singleton arguments
               and
               using the conventional pull-mode addition. Many expressions also benefit from a generic
               implementation in cases where an argument is a non-singleton sequence. This generic
               implementation buffers the argument sequence in memory and then uses the pull-mode
               implementation once the sequence is complete. This of course is not pure streaming,
               but it
               provides useful scaffolding to enable less commonly used expressions to appear in
               a
               streaming template while awaiting a pure streaming implementation. Currently this
               mechanism
               is used for comparison expressions such as 
               <div class="code e382">.//value = 17</div> (recall that in XPath,
               this returns true if at least one of the 
               <div class="code e383">value</div> elements is equal to 17); there
               is no technical reason that prevents the creation of a pure push-mode implementation
               of a
               general comparison expression with respect to either argument, but it has not yet
               been
               implemented, and it is not a top priority because in the vast majority of cases the
               arguments actually turn out to be singletons.
            </div>
            <div class="para e384">The compile-time template inversion process operates by means of a recursive walk
               of the
               expression tree. At every level there must be at most one branch that performs downward
               selection; this branch is taken, and by this means the streaming route is identified.
               The
               process then attempts to identify the longest suffix of the streaming route that constitutes
               a streamable pattern. For example, if the body of the template is 
               <div class="code e385">&lt;xsl:value-of
                  select="sum(.//value) + 1"/&gt;
               </div>, the streamable pattern is 
               <div class="code e386">.//value</div>. The
               immediate parent of this pattern on the streaming route must always be an expression
               that
               can be evaluated as a Watch. The number of expressions implemented as a Watch is suprisingly
               small:
            </div>
            <div class="itemizedlist e387">
               <div class="listitem e388">
                  <div class="para e389">
                     <div class="code e390">TypedValueWatch</div> handles all expressions that use the atomized value of the
                     selected nodes.
                  </div>
               </div>
               <div class="listitem e391">
                  <div class="para e392">
                     <div class="code e393">StringValueWatch</div> handles all expressions that use the string value of the
                     selected nodes.
                  </div>
               </div>
               <div class="listitem e394">
                  <div class="para e395">
                     <div class="code e396">CountWatch</div> handles the 
                     <div class="code e397">count()</div>, 
                     <div class="code e398">exists()</div>, and
                     
                     <div class="code e399">empty()</div> functions.
                  </div>
               </div>
               <div class="listitem e400">
                  <div class="para e401">
                     <div class="code e402">CopyWatch</div> (the one we met earlier) handles 
                     <div class="code e403">xsl:copy-of</div>.
                  </div>
               </div>
               <div class="listitem e404">
                  <div class="para e405">
                     <div class="code e406">VoidWatch</div> is used for templates or branches of a conditional that make no
                     downwards selection.
                  </div>
               </div>
               <div class="listitem e407">
                  <div class="para e408">
                     <div class="code e409">SimpleContentWatch</div> implements the rules for instructions such as
                     
                     <div class="code e410">xsl:value-of</div> and 
                     <div class="code e411">xsl:attribute</div>; specifically, it
                     concatenates adjacent text nodes, removes empty text nodes, and reduces all other
                     nodes
                     to string values.
                  </div>
               </div>
               <div class="listitem e412">
                  <div class="para e413">
                     <div class="code e414">ApplyTemplatesWatch</div> is used where the downwards selection appears in the select
                     expression of an 
                     <div class="code e415">xsl:apply-templates</div> instruction, and also supports
                     
                     <div class="code e416">xsl:apply-imports</div> and 
                     <div class="code e417">xsl:next-match</div>.
                  </div>
               </div>
               <div class="listitem e418">
                  <div class="para e419">
                     <div class="code e420">ForEachWatch</div> is used where the downwards selection appears in the select
                     expression of an 
                     <div class="code e421">xsl:for-each</div> instruction.
                  </div>
               </div>
            </div>
            <div class="para e422">Most of these Watch implementations are composing: they emit a sequence of XDM items.
               
               The two exceptions are the 
               <div class="code e423">ForEachWatch</div> and the 
               <div class="code e424">ApplyTemplatesWatch</div>, which
               emit a sequence of parse events.
            </div>
            <div class="para e425">We have already seen the 
               <div class="code e426">CopyWatch</div> earlier in the paper: it is used for a
               simple streaming copy, as well as for 
               <div class="code e427">xsl:copy-of</div> instructions appearing within
               a streaming template. When it receives a startElement event representing an element
               selected
               by its controlling pattern (we'll assume to keep things simple that it is watching
               for
               elements), it starts building a tree. All subsequent parse events until the matching
               endElement are directed to this tree builder. When the tree is complete, the node
               at the
               root of the tree is emitted to the Feed that implements the parent of the
               
               <div class="code e428">xsl:copy-of</div> instruction, that is, the parent expression in the streaming
               route through the expression tree. 
            </div>
            <div class="para e429">The 
               <div class="code e430">StringValueWatch</div> and 
               <div class="code e431">TypedValueWatch</div> work in a very
               similar way, except that instead of building a tree from the incoming events, they
               construct
               the string value or typed value of the node by concatenating the values of those events
               that
               represent text nodes.
            </div>
            <div class="para e432">All these Watch implementations have a complication that has already been mentioned
               for Streaming Copy: a startElement
               event for a matching element might be notified while an existing matching element
               is already being processed; that is, the
               pattern that the Watch matches may select a node that is a descendant of another matched
               node. For this reason, the Watch
               does not actually construct the tree (or string value or typed value) directly; instead
               it creates an event receiver
               dedicated to this task, which it passes back to the WatchManager; the WatchManager
               then notifies all events to all active
               event receivers to do the necessary work, taking care of deactivating them when needed.
               When the endElement event occurs,
               the Watch passes the constructed tree to the next Feed in the streaming route only
               if the matched element has no matching
               ancestors; for an inner matched node, the tree is held in a queue until the outer
               tree is complete, since the outer tree
               comes first in document order and must therefore be notified to the waiting Feed before
               the inner trees. This queue
               again represents a departure from pure streaming; the XSLT 2.1 draft has an open issue
               on this question.
            </div>
            <div class="para e433">The 
               <div class="code e434">ApplyTemplatesWatch</div> is similarly notified of the startElement event for
               a node that matches the select expression of the 
               <div class="code e435">xsl:apply-templates</div>
               instruction. It responds to this by searching for a matching template rule â this
               is
               possible because the constraints on match patterns in a streamable template ensure
               that the
               pattern can be evaluated when positioned at the startElement event (the object representing
               the event, it should be mentioned, provides methods to get local properties of the
               node such
               as the name and type annotation, and also to navigate to the node's ancestors and
               their
               attributes). Having identified the template to be applied, which because it is in
               a
               streaming mode will always have been compiled with template inversion, it then gets
               the
               Watch expression identified during the analysis of the called template, and nominates
               this
               Watch expression to the WatchManager. All events up to the corresponding endElement
               will
               therefore be sent by the WatchManager to the called template, where the same process
               continues recursively. At the same time, the same events are being sent to the calling
               
               <div class="code e436">ApplyTemplatesWatch</div>, because as with 
               <div class="code e437">xsl:copy-of</div>, it is entirely
               possible for the 
               <div class="code e438">select</div> expression of 
               <div class="code e439">xsl:apply-templates</div> to
               select an element that is a descendant of another element already being processed;
               the
               results of the processing of such nested elements will again be buffered.
            </div>
            <div class="para e440">The 
               <div class="code e441">ForEachWatch</div> operates in a very similar way to the
               
               <div class="code e442">ApplyTemplatesWatch</div>, except that there is no need to search for a matching
               template. Rather, the body of the 
               <div class="code e443">xsl:for-each</div> instruction is compiled directly
               as an inverted template and is invoked unconditionally for each startElement event
               matching
               a selected node.
            </div>
            <div class="para e444">A similar streaming implementation has been written for 
               <div class="code e445">xsl:iterate</div>; none
               is yet available for 
               <div class="code e446">xsl:for-each-group</div>, but it is expected that it will follow
               the same principles.
            </div>
         </div>
      </div><a name="ConclusionsANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="section e447">
         <div class="title e448">Conclusions</div>
         <div class="para e449">Streaming of XSLT transformations has long been an aspiration, and many partial solutions
            have
            been developed over the years. It has proved difficult or impossible to create streaming
            implementations
            of the full XSLT language as defined by W3C.
         </div>
         <div class="para e450">The draft XSLT 2.1 specification has been developed as a solution to this problem.
            It
            defines a subset of the full XSLT language that is intended to be streamable without
            requiring
            unknown magic on the part of the implementation, and at the same time it provides
            extensions
            to the language (such as 
            <div class="code e451">xsl:iterate</div>) that make it possible to write powerful
            transformations without straying from the streamable subset. The design of the language
            is
            informed by experience with both XSLT 2.0 and STX, and by a large collection of use
            cases
            describing problems that benefit from a streamed implementation.
         </div>
         <div class="para e452">Successive releases of Saxon, some predating this work and some influenced by it,
            have provided partial
            solutions to the streaming challenge with increasing levels of sophistication. At
            the time of writing, there are
            many ideas in the specification that are not yet implemented in Saxon, and there are
            some features in the Saxon
            implementation that are not yet reflected in the specification. Nevertheless, development
            of the language
            standard and of an industrial implementation are proceeding in parallel, which is
            always a promising indicator
            that standards when they arrive will be timely and viable. Both the language and the
            implementation, however,
            still need a lot more work.
         </div>
         <div class="para e453">Saxon's approach to the problem is based on using a push architecture end-to-end,
            to eliminate the
            source tree as an intermediary between push-based XML parsing/validation and pull-based
            XPath processing.
            Implementing the entire repertoire of XPath expressions and XSLT instructions in an
            event-based pipeline
            is challenging, to say the least. However, enough has been completed to show that
            the undertaking is viable,
            and a large enough subset is already available to users to enable some serious large-scale
            transformation
            tasks to be performed.
         </div>
      </div><a name="BibliographyANCHOR" href="#mainContainerTitleTOC" class="anchor">toc</a><div class="bibliography e454">
         <div class="title e455">Bibliography</div>
         <div class="bibliomixed e456" xml:id="Barton2003" xreflabel="Barton2003">Charles Barton et al.
            An Algorithm for Streaming XPath Processing with Forward and Backward Axes.
            In Proc. 19 Int Conf Data Eng, Banagalore, India, 5-8 March 2003. ISBN: 0-7803-7665-X
            
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e457" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.research.ibm.com/xj/pubs/icde.pdf</div>
         </div>
         <div class="bibliomixed e458" xml:id="BarYossef2004" xreflabel="BarYossef2004">Ziv Bar-Yossef, Marcus Fontoura, and Vanja Josifovski.
            On the Memory Requirements of XPath Evaluation over XML Streams.
            J Comp Sys Sci Vol 73 Iss 3 pp 391-441, May 2007, ISSN 0022-0000 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e459" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.almaden.ibm.com/cs/people/fontoura/papers/pods2004.pdf</div>.
            doi: 
            <div class="biblioid doi e460">10.1016/j.jcss.2006.10.002</div>.  
            
         </div>
         <div class="bibliomixed e461" xml:id="Cimprich2010" xreflabel="Cimprich2010">Petr Cimprich (ed). 
            Requirements and Use Cases for XSLT 2.1. W3C Working Draft 10 June 2010. 
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e462" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-21-requirements/</div>
         </div>
         <div class="bibliomixed e463" xml:id="CityGML" xreflabel="CityGML">Exchange and Storage of Virtual 3D City Models.
            Thomas H Kolbe (ed). 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e464" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.citygml.org/</div>. Retrieved 2010-07-10.
         </div>
         <div class="bibliomixed e465" xml:id="Dvorakova2008" xreflabel="Dvirakova2008">Jana DvoÅÃ¡kovÃ¡.
            A Formal Framework for Streaming XML Transformations.
            PhD Thesis, Comenius University, Bratislava, Slovenia, 2008.
            
         </div>
         <div class="bibliomixed e466" xml:id="Dvorakova2009a" xreflabel="Dvorakova2009a">Jana DvoÅÃ¡kovÃ¡.
            Automatic Streaming Processing of XSLT Transformations Based on Tree Transducers.
            Informatica: An International Journal of Computing and Informatics, 
            Special Issue - Intelligent and Distributed Computing, Slovene Society Informatika,
            2009   
            
         </div>
         <div class="bibliomixed e467" xml:id="Dvorakova2009b" xreflabel="Dvorakova2009b">Jana DvoÅÃ¡kovÃ¡ and F Zavoral.
            Using Input Buffers for Streaming XSLT Processing, 
            Proceedings of the International Conference on Advances in Databases - GlobeNet/DB
            2009, 
            Gosier, IEEE Computer Society Press, 2009.
            doi: 
            <div class="biblioid doi e468">10.1109/DBKDA.2009.25</div>.  
            
         </div>
         <div class="bibliomixed e469" xml:id="Florescu2003" xreflabel="Florescu2003">Daniela Florescu et al.
            The BEA/XQRL Streaming XQuery Processor. In Proc. 29 VLDB, 2003, Berlin, Germany,
            pp 997-1008. ISBN:0-12-722442-4
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e470" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.vldb.org/conf/2003/papers/S30P01.pdf</div>
         </div>
         <div class="bibliomixed e471" xml:id="Frisch2007" xreflabel="Frisch2007">Alain Frisch and Keisuke Nakano. Streaming
            XML transformations using term rewriting. PLAN-X 2007 Nice, France, 20 Jan 2007 pp
            2-13.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e472" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://yquem.inria.fr/~frisch/xstream/long.pdf</div>
            
         </div>
         <div class="bibliomixed e473" xml:id="GML">OpenGIS Geography Markup Language (GML) Encoding Standard.
            OGC (Open Geospatial Consortium). 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e474" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.opengeospatial.org/standards/gml</div>. Retrieved 2010-07-10.
         </div>
         <div class="bibliomixed e475" xml:id="Guo2004" xreflabel="Guo2004">Zhimao Guo, Min Li, Xiaoling Wang, and Aoying Zhou.
            Scalable XSLT Evaluation. In Proc 6 Asia-Pacific Web Conf, Hangzhou, China, 14-17
            April 2004. ISBN 3-540-21371-6
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e476" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://arxiv.org/pdf/cs.DB/0408051</div>
         </div>
         <div class="bibliomixed e477" xml:id="Kay2009" xreflabel="Kay2009">Michael Kay.
            You Pull, Iâll Push: on the Polarity of Pipelines.
            Presented at Balisage: The Markup Conference 2009, MontrÃ©al, Canada, August 11 - 14,
            2009.
            In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup
            Technologies, vol. 3 (2009).
            doi: 
            <div class="biblioid doi e478">10.4242/BalisageVol3.Kay01</div>.
            
         </div>
         <div class="bibliomixed e479" xml:id="Kay2010a" xreflabel="Kay2010a">Michael Kay.
            Streaming in XSLT 2.1. 
            Proc XML Prague 2010. 13-14 March 2010, Prague, Czech Rep.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e480" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.xmlprague.cz/2010/files/XMLPrague_2010_Proceedings.pdf</div>
         </div>
         <div class="bibliomixed e481" xml:id="Kay2010b" xreflabel="Kay2010b">Michael Kay (ed). XSL Transformations (XSLT) Version 2.1.
            W3C Working Draft 11 May 2010. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e482" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.w3.org/TR/xslt-21/</div>. 
         </div>
         <div class="bibliomixed e483" xml:id="Li2005" xreflabel="Li2005">Xiaogang Li and Gagan Agrawal.
            Efficient evaluation of XQuery over streaming data. 
            In Proc. 31 VLDB, 2005, Trondheim, Norway, pp 265-276. ISBN 1-59593-154-6
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e484" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.vldb2005.org/program/paper/wed/p265-li.pdf</div>
         </div>
         <div class="bibliomixed e485" xml:id="Joshi" xreflabel="Joshi">Amruta Joshi and Oleg Slezburg.
            CS276B Project Report: Streaming XPath Engine. Undated. 
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e486" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www-cs-students.stanford.edu/~amrutaj/work/papers/xpath.pdf</div>
            Retrieved 2010-04-12
         </div>
         <div class="bibliomixed e487" xml:id="Saxonica" xreflabel="Saxonica">The Saxon XSLT and XQuery Processor.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e488" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.saxonica.com/</div> Retrieved 2010-07-10.
         </div>
         <div class="bibliomixed e489" xml:id="STX" xreflabel="STX">Streaming Transformations for XML (STX).
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e490" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://stx.sourceforge.net/</div> Retrieved 2010-07-10. Contains links to articles and presentations by Tobias Trapp,
            Oliver Becker, and Petr Cimprich.
         </div>
         <div class="bibliomixed e491" xml:id="Zergaoui2009" xreflabel="Zergaoui2009">Mohamed Zergaoui. Memory management in
            streaming: Buffering, lookahead, or none. Which to choose? Int Symp on Processing
            XML
            Efficiently. 10 Aug 2009, Montreal, Canada. Balisage Series on Markup Technologies,
            vol. 4
            (2009). doi: 
            <div class="biblioid doi e492">10.4242/BalisageVol4.Zergaoui02</div>.
            
            <div xmlns:xlink="http://www.w3.org/1999/xlink" class="link e493" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple">http://www.balisage.net/Proceedings/vol4/html/Zergaoui02/BalisageVol4-Zergaoui02.html</div>
            
         </div>
      </div>
   </div>
</div>