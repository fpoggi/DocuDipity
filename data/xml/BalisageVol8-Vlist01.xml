<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>Fleshing the XDM chimera</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>The XQuery and XPath Data Model 3.0 (XDM) is the kernel of the XML ecosystem. XDM had been extended with foreign item types to embrace new data sources such as JSON, taking the risk
                to become a chimera. This talk explores some ways to move this fundamental piece of the XML stack forward.</para></abstract><author><personname><firstname>Eric</firstname><surname>van der Vlist</surname></personname><personblurb><para>Eric is an independent consultant and trainer. His domain of expertise include Web development and XML technologies.</para><para>He is the creator and main editor of <link xlink:href="http://xmlfr.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XMLfr.org</link>, the main site dedicated to XML technologies in French, the author of the O'Reilly
                    animal books XML Schema and RELAX NG and a member or the ISO DSDL (<link xlink:href="http://dsdl.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://dsdl.org</link>) working group focused on XML schema languages.</para><para>He is based in Paris and you can reach him by mail (<link xlink:href="mailto:vdv@dyomedea.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">vdv@dyomedea.com</link>) or meet him in one of the many conferences where he
                    presents his projects.</para></personblurb><affiliation><orgname>Dyomedea</orgname></affiliation></author><legalnotice><para>Published under the Creative Commons "cc by" license</para></legalnotice></info><section><title>Motivation</title><blockquote><para><link xlink:href="http://en.wikipedia.org/wiki/Chimera_%28mythology%29" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Chimera (mythology)</link>: The Chimera (also Chimaera or Chimæra) (Greek: Χίμαιρα, Khimaira, from χίμαρος,
                khimaros, "she-goat") was, according to Greek mythology, a monstrous fire-breathing female creature of Lycia in Asia Minor, composed of the parts of multiple animals: upon the body of
                a lioness with a tail that ended in a snake's head, the head of a goat arose on her back at the center of her spine. The Chimera was one of the offspring of Typhon and Echidna and a
                sibling of such monsters as Cerberus and the Lernaean Hydra. The term chimera has also come to describe any mythical animal with parts taken from various animals and, more generally,
                an impossible or foolish fantasy.</para><attribution><link xlink:href="http://en.wikipedia.org/wiki/Chimera_%28mythology%29" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Wikipedia</link></attribution></blockquote><blockquote><para><link xlink:href="http://en.wikipedia.org/wiki/Chimera_%28genetics%29" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Chimera (genetics)</link>: A chimera or chimaera is a single organism (usually an animal) that is composed of
                two or more different populations of genetically distinct cells that originated from different zygotes involved in sexual reproduction. If the different cells have emerged from the
                same zygote, the organism is called a mosaic. Chimeras are formed from at least four parent cells (two fertilized eggs or early embryos fused together). Each population of cells keeps
                its own character and the resulting organism is a mixture of tissues. </para><attribution><link xlink:href="http://en.wikipedia.org/wiki/Chimera_%28genetics%29" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Wikipedia</link></attribution></blockquote><para>During her opening keynote at XML Prague 2012, speaking about the relation between XML, HTML, JSON and RDF, Jeni Tennison warned us against the temptation to create chimeras:
                <citation>chimera are usually ugly, foolish or impossible fantasies</citation>.</para><para>The next morning, Michael Kay and Jonathan Robie came to present new features in XPath/XQuery/XSLT 3.0. A lot of these features are directly based on the XQuery and XPath Data Model 3.0
            (aka <link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#other-items" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XDM</link>):<blockquote><para>The XPath Data Model is the abstraction over which XPath expressions are evaluated. Historically, all of the items in the data model could be derived directly (nodes) or
                    indirectly (typed values, sequences) from an XML document. However, as the XPath expression language has matured, new features have been added which require additional types of
                    items to appear in the data model. These items have no direct XML serialization, but they are never the less part of the data model. </para></blockquote></para><para>XDM 3.0 is composed of items from a number of different technologies:<itemizedlist><listitem><para>Items from the XML Infoset (nodes, attributes, ...)</para></listitem><listitem><para>Datatype information borrowed from the Post Schema Validation Infoset</para></listitem><listitem><para>Sequences</para></listitem><listitem><para>Atomic values</para></listitem><listitem><para>Functions that can also be used to model JSON arrays</para></listitem></itemizedlist></para><note><para>The feature that will be introduced to model JSON arrays is called "maps" and it will be specified as a XSLT feature in the XSLT 3.0 recommendation (not published yet). The XSLT 3.0
                editor, Michael Kay has published an <link xlink:href="http://dev.saxonica.com/blog/mike/2012/01/#000188" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">early version</link> of this feature in his blog. In this paper, XDM 3.0 will
                refer to the XSLT 3.0 data model (the XPath 3.0 data model augmented with maps).</para></note><para>XDM 3.0 being a single data model composed of items from different data models, it is fair to say that it is a chimera!</para><para>Following Jeni Tennison on stage, I have tried to <link xlink:href="http://www.xmlprague.cz/2012/sessions.html#The-eX-Markup-Language" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">show</link> that in a world where HTML 5 on one
            hand and JSON on the other hand are gaining traction, XML has become an ecosystem in a competitive environment and that it's data model is a major competitive advantage.</para><para>Among other factors, the continued success of XML will thus come from its ability to seamlessly integrate other data models such as JSON.</para><para>If we follow this conclusion, we must admit that this chimera is essential to the future of XML and do our best to make it elegant and smart.</para></section><section><title>XML Data Models</title><para>Whether it's a bug or a feature could be debated endlessly, but a remarkable feature of the XML recommendation it's all about syntax and parsing rule and does not really define a data
            model. The big advantage is that everyone can find pretty much what he wants in XML documents but for the sake of this paper we need to choose a well known -and well defined- data model to
            work on. </para><para>The most common XML data model is probably the data model defined by the trio XPath/XSLT/XQuery known as "XDM" since XPath version 2.0 and that's the one we will choose.</para><para>XDM version 3.0, still work in progress, will be the third version of this data model. It's important to understand its design and evolution to use its most advanced features and we'll
            start our prospective by a short history of its versions.</para><section><title>XPath/XSLT 1.0</title><para>The <link xlink:href="http://www.w3.org/TR/xpath/#data-model" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XPath 1.0 data model</link> is described as being composed of seven types of nodes (root, elements, text, attributes,
                namespaces, processing instructions and comments).</para><para>The <link xlink:href="http://www.w3.org/TR/xslt/#data-model" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XSLT 1.0 data model</link> is defined as being the XPath 1.0 data model with:</para><itemizedlist><listitem><para>Relaxed constraints on root node children to support well-formed external general parsed entities that are not well formed XML documents</para></listitem><listitem><para>An additional "base URI" property on every node.</para></listitem><listitem><para>An additional "unparsed entities" property on the root node. </para></listitem></itemizedlist><para>It's fair to say that these two -very close- data models are completely focused on XML, but is that all?</para><para>Not entirely and these two specifications introduce other notions that should be considered as related to the data model even if they are not described in their sections called "Data
                Model"...</para><para>XSLT 1.0 inadvertently mentions <quote>the four basic XPath data-types (string, number, boolean, node-set)</quote> to explicitly add a fifth one: <quote>result tree
                fragments</quote>.</para><para>These four basic data-types are implicitly defined in XPath 1.0 in its section about its function library but no formal description of these types is given.</para></section><section><title>XDML 2.0: XPath 2.0/XSLT 2.0/XQuery 1.0</title><para>In version 2.0, the XDM is promoted to get its <link xlink:href="http://www.w3.org/TR/xpath-datamodel/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">own specification</link>.</para><para>XDM 2.0 keeps the same seven types of nodes as XPath 1.0 and integrates the additions from the XSLT 1.0 data model. A number of properties are added to these nodes to capture
                information that had been left outside the data model by the previous version and also to support the data-type system from the PSVI (Post Schema Validation Infoset).</para><para>The term "data-type" or simply "type" being now used to refer to XML Schema data-types, a new terminology is introduced where the data model is composed of "information items" (or
                items) being either XML nodes or "atomic values".</para><para>The concept of "sequences" is also introduced. Sequences are not strictly considered as items but play a very important role in XDM. They are defined as <quote>an ordered collection
                    of zero or more <link xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-item" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">items</link></quote>.</para><para>The data model is thus now composed of three different concepts:<itemizedlist><listitem><para>nodes</para></listitem><listitem><para>atomic values</para></listitem><listitem><para>sequences</para></listitem></itemizedlist></para><para>XDM 2.0 notes that an important difference between nodes and atomic values is that only nodes have <link xlink:href="http://www.w3.org/TR/xpath-datamodel/#node-identity" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">identities</link>:<blockquote><para>Each node has a unique identity. Every <link xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-node" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">node</link> in an instance of the data model is unique: identical to
                        itself, and not identical to any other node. (<link xlink:href="http://www.w3.org/TR/xpath-datamodel/#dt-atomic-value" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Atomic values</link> do not have identity; every instance
                        of the value “5” as an integer is identical to every other instance of the value “5” as an integer.)</para><attribution><link xlink:href="http://www.w3.org/TR/xpath-datamodel/#node-identity" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)</link></attribution></blockquote></para><para>This is a crucial distinction that divides the data model into two different kind of items (those which have an identity and those which haven't one). Let's take an example: </para><programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;bar foo="5"&gt;
        &lt;foo&gt;5&lt;/foo&gt;
    &lt;/bar&gt;
&lt;/root&gt;</programlisting><para>The three <code>&lt;foo&gt;5&lt;/foo&gt;</code> look similar and can be considered "<link xlink:href="http://www.w3.org/TR/xpath-functions/#func-deep-equal" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">deeply equal</link>" but they
                are three different elements with three different identities. This is needed because some of their properties are different: the parent of the first two is <code>&lt;root/&gt;</code>
                while the parent of the third one is <code>&lt;bar/&gt;</code>, the preceding sibling of the second one is the first one while the first one has no preceeding sibling, ...</para><para>The three "5" text nodes are similar but they still are different text nodes with different identities and this is necessary because they don't have the same parent elements.</para><para>By contrast, the atomic values of the three <code>&lt;foo/&gt;</code> element (and the atomic value of the <code>@foo</code> attribute) are the same atomic value, the "5" (assuming they
                have all been declared with the same datatype). Among many other things, this means that when you manipulate their values, you can't access back to the node that is holding the
                value).</para></section><section><title>XDM 3.0: XPath 3.0/XSLT 3.0/XQuery 3.0</title><para><note><para>These specifications are still work on progress, currently divided between <link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery and XPath Data
                            Model 3.0</link> and data model extensions described in XSL Transformations (XSLT) Version 3.0.</para></note></para><para>XDM 3.0 adds functions as a third kind of items, transforming XQuery and XSLT into functional languages.</para><para>Like atomic values, functions have no identity:<blockquote><para>Functions have no identity, cannot be compared, and have no serialization.</para><attribution><link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#function-items" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery and XPath Data Model 3.0 - W3C Working Draft 13 December
                        2011</link></attribution></blockquote></para><para>XSLT 3.0 adds to XDM 3.0 a fourth king of items: maps, derived from functions which, among many other use cases, can be used to model JSON objects:</para><para>Like atomic values and functions (from which they are derived), maps have no identity:<blockquote><para>Like sequences, maps have no identity. It is meaningful to compare the contents of two maps, but there is no way of asking whether they are "the same map": two maps with the
                        same content are indistinguishable.</para><attribution><link xlink:href="http://www.w3.org/TR/xslt-30/#map" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XSL Transformations (XSLT) Version 3.0 - W3C Working Draft 10 July 2012</link></attribution></blockquote><note><para>In this statement, the specification does acknowledge that sequences have no identity either. This is understandable but didn't seem to be clearly specified elsewhere.</para></note></para><para>Of course, XSLT 3.0 is also adding functions to create, manipulate maps and serialize/deserialize them as JSON and a syntax to define map literals. It does not any new pattern to
                select of match maps or map entries, though.</para></section></section><section><title>Identity Crisis</title><blockquote><para>Appolonius' ship is a beautiful ship. Over the years it has been repaired so many times that there is not a single piece of the original materials remaining. The question is,
                therefore, is it really still Appolonius' ship? </para><attribution><link xlink:href="http://c2.com/cgi/wiki?ObjectIdentity" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">ObjectIdentity on c2.com</link></attribution></blockquote><para>Object identity is often confused with mutability. The need for objects to have identities is more obvious when they are mutable, their identities being then used to track them despite
            their changes like Appolonius' ship. However, XDM 3.0 gives us a good opportunity to explore the meaning and consequences of having (or not having) an identity for immutable object
            structures.</para><para>The definition of node identity in XDM 3.0 is directly copied from XDM 2.0:<blockquote><para>Each node has a unique identity. Every <link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#dt-node" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">node</link> in an instance of the data model is
                    unique: identical to itself, and not identical to any other node. (<link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#dt-atomic-value" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Atomic values</link>
                    do not have identity; every instance of the value “5” as an integer is identical to every other instance of the value “5” as an integer.)</para><attribution><link xlink:href="http://www.w3.org/TR/2011/WD-xpath-datamodel-30-20111213/#node-identity" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery and XPath Data Model 3.0 - W3C Working Draft 13 December
                    2011</link></attribution></blockquote></para><para>I find this definition confusing:<itemizedlist><listitem><para>Why should the value “5” as an integer be instantiated and why should we care? The value “5” as an integer is... the value “5” as an integer! It's unique and being unique,
                        doesn't it have an identity?</para></listitem><listitem><para>A node, with all the properties defined in XDM (including its document-uri and parent accessors) would be unique if it had "previous-sibling" or "document-order" accessors.
                    </para></listitem></itemizedlist><note><para>To find the previous siblings of a node relying only on the accessors defined in XDM (2.0 or 3.0), you'd have to access to the node's parent and loop over it's children until you
                    find the current node that you would identify as such by checking its identity.</para></note></para><para>Rather than focussing on uniqueness, which for immutable information items does not really matter, a better differentiation could be between information items which have enough context
            information to "know where they belong" in the data model and those which don't. </para><para>This differentiation has the benefit of highlighting the consequences of having or not having an identity: to be able to navigate between an information item and its ancestors or sibling
            this item must know where it belongs. When that's not the case, it is still be possible to navigate between the item and its descendants but axis such as <code>ancestor::</code> or
                <code>sibling::</code> are not available. </para><note><para>Identity can be seen as the price to pay for the <code>ancestor::</code> and <code>sibling::</code> axis. </para></note><para>Let's take back a simple example:</para><para>
            <programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;foo&gt;5&lt;/foo&gt;
    &lt;bar&gt; 
        &lt;foo&gt;5&lt;/foo&gt;
    &lt;/bar&gt;
&lt;/root&gt;</programlisting>
        </para><para>In an hypothetical data model where nodes have no identity, there would be only 3 elements:<itemizedlist><listitem><para>The root element</para></listitem><listitem><para>The bar element</para></listitem><listitem><para>The foo element (referred twice has children of root end once as child of bar)</para></listitem></itemizedlist></para><para>If we add identity (or context information) properties, the foo elements become three information different items since they defer by these properties.</para><para>The process of adding these properties to an information item looks familiar. Depending on your background, you can compare it to:<itemizedlist><listitem><para>class/object instantiation in class based Object Oriented Programming</para></listitem><listitem><para>clones in prototype based Object Oriented Programming</para></listitem><listitem><para>RDF reification.</para></listitem></itemizedlist></para><para>We've seen that XDM 3.0 acknowledges this difference between information items which have context information and those which don't have. I don't want to deny that both types of data
            models have their use cases: there are obviously many use cases where context information is needed and use cases where lightweight structures are a better fit.</para><para>That being said, if we are serious about the support of JSON in XDM, we should offer the same features to access data whether this data is stored in maps or in XML nodes. </para><para>Let's consider this JSON object borrowed from the XSLT 3.0 Working
            Draft:<programlisting xml:space="preserve">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </programlisting></para><para>This object could be represented in XML by the following
            document:<programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;company&gt;
    &lt;department name="sales"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
    &lt;department name="accounting"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
&lt;/company&gt;</programlisting></para><para>The features introduced in the latest XSLT 3.0 Working Draft do allow to transform rather easily from one model to the other, but these two models do not have, bar far, the same
            features.</para><para>In the XML flavor, when the context item is the employee "John Doe", you can easily find out what his department is because this is an element and element do carry context information.
            In the map flavor by contrast when the context item is an employee map, this object has no context information and you can't tell which is his department without looping within the
            containing map.  </para><para>This important restriction is at a purely data model level. It is aggravated by the XPath syntax has not been extended to generalize axis so that they can work with maps. If I work with
            the XML version of this structure, it's obvious to evaluate things such as the number of employees, the average age of employees, the number of departments, the number of employees by
            department, the average age by department, obvious to find out if there is an employee called "Mary Smith" in one of the departments, the employees who are more than 40, to get a list of
            employees from all the department sorted by age, ... In the map flavor by contrast, I don't have any XPath axis available and must do all these operations using a limited number of map
            functions (map:keys(), map:contains(), map:get()). In other words, while I can use XPath expressions with the XML version, I must use DOM like operations to access the map version!</para><para>To summarize, yes XDM 3.0 does support JSON but to do pretty much anything interesting with JSON objects, you'd better transform them into XML nodes first! XSLT 3.0 does give you the
            tools to do this transformation quite easily but the message to JSON users is that we don't treat their data model as a first class citizen.</para><para>To make it worse, XPath is used by many other specifications, within and outside the W3C and the level of support for JSON provided by XDM and XPath will determine how these
            specifications will be able to support for JSON. Specifications that are impacted by this issue include XForms, XProc and Schematron. Supporting JSON would be really useful for these three
            specifications if and only if map items could have the same features than nodes.</para><para>Furthermore, the same asymmetry exists when you went to create these two structures from other sources: to create the XML structure you can use sequence constructors but to create the
            map structure, you have to use the <code>map:new()</code> and <code>map:item()</code> functions.</para><para>My proposal to solve this issue is:<itemizedlist><listitem><para>To acknowledge the fact that any type of information item can be either "context independent" or include context information and explore the consequences of this
                        statement.</para></listitem><listitem><para>To generalize XPath axis so that they can be used with map items. </para></listitem><listitem><para>To create sequence constructors for maps and map entries.</para></listitem></itemizedlist></para><para>You are welcome to discuss this further:<itemizedlist><listitem><para> W3C XSLT 3.0 <link xlink:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16118" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Bug 16118</link>, "Maps should be first class citizens"</para></listitem><listitem><para>Blog entry: <link xlink:href="http://eric.van-der-vlist.com/blog/2012/02/25/xdm-maps-should-be-first-class-citizens/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XDM Maps should be first class citizens</link>.</para></listitem><listitem><para>Blog entry: <link xlink:href="http://eric.van-der-vlist.com/blog/2012/02/28/more-musings-on-xdm-3-0/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">More musings on XDM 3.0</link></para></listitem></itemizedlist></para></section><section><title>Introducing χίμαιραλ (chimeral), the Chimera Language</title><para>When I started to work on <link xlink:href="http://χίμαιραλ.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">χίμαιραλ</link> a few months ago, my first motivation was to propose an XDM serialization for maps which would turn the
            rather abstract prose from the specification into concrete angle brackets that you could see and read.</para><para>The exercise has been very instructive and helped me a lot to understand the spec, however a more ambitious use pattern has emerged while I was making progress. The XSLT 3.0 Working
            Draft is part of a batch of Working Drafts which are far more advanced. My proposals to solve the "map identity crisis" are probably too intrusive and too late to be taken into account and
            the batch of specifications will most probably carry on with the current proposal.</para><para>If that's the case, we've seen that it makes a lot of sense to convert maps into nodes to enable to use XPath axis and χίμαιραλ provides a generic target format for these
            conversions.</para><section><title>Example</title><para>Let's take again the JSON object borrowed from the XSLT 3.0 Working
                Draft:<programlisting xml:space="preserve">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </programlisting></para><para>Its χίμαιραλ representation
                is:<programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
    &lt;χ:map&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
    &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Granted, it's much more verbose than the JSON version, but it's the exact translation of the XDM corresponding to the JSON object in XML. </para></section><section><title>χίμαιραλ In a Nutshell</title><para>The design goals are:<itemizedlist><listitem><para>Be as close as possible to the XDM and its terminology</para></listitem><listitem><para>Represent XML nodes as... XML nodes</para></listitem><listitem><para>Allow round-trips (an XDM model serialized as χίμαιραλ should give a XDM model identical to the original one when de-serialized)</para></listitem><listitem><para>Be easy to process using XPath/XQuery/XSLT</para></listitem><listitem><para>Support of the PSVI is not a goal</para></listitem></itemizedlist></para><para>χίμαιραλ is not the only proposal to serialize XDM as XML. Two other notable ones are:<itemizedlist><listitem><para>Zorba's <link xlink:href="http://bazaar.launchpad.net/~zorba-coders/zorba/pul-and-xdm-schemas/view/head:/schemas/xdm.xsd" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XDM serialization</link> is a straight and
                            accurate XDM serialization which does support PSVI annotations. As a consequence, nodes are serialized as <code>xdm:*</code> elements (an element is an
                                <code>xdm:element</code>, an attribute an <code>xdm:attribute</code> element, ...). This does'n meet  by second requirement to represent nodes as themselves.</para></listitem><listitem><para><link xlink:href="http://balisage.net/Proceedings/vol7/html/Rennau01/BalisageVol7-Rennau01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XDML</link>, presented by Rennau, Hans-Jürgen, and David A. Lee at
                            Balisage 2011 is more than just an XDM serialization and also includes manipulation and processing definitions. It introduces its own terminology and concepts and is too
                            far away from XDM for my design goals.</para></listitem></itemizedlist></para><para>A lot of attention has been given to the first design goal: the structure of a χίμαιραλ model and the name of its elements and attributes are directly derived from the
                specifications.</para><para>In XDM, map entries' values can be arrays (an array beeing nothing else than a map with integer keys) but also sequences (which is not possible in JSON). χίμαιραλ respects the fact
                that in XDM there is no difference between a sequence composed of a single element and represents sequences by a repetition of values.</para><para>The map <code>map{1:= 'foo'}</code> is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="1" keyType="number"&gt;
         &lt;χ:atomic-value type="string"&gt;foo&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>And the map <code>map{1:= ('foo', 'bar')}</code> is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="1" keyType="number"&gt;
         &lt;χ:atomic-value type="string"&gt;foo&lt;/χ:atomic-value&gt;
         &lt;χ:atomic-value type="string"&gt;bar&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>We've seen that XDM makes a clear distinction between nodes which have identities and other item types (atomic values, functions and maps) which haven't. XDM allows to use nodes as
                map entry values. χίμαιραλ allows this feature too, but copying the nodes would create new nodes with different identities.</para><para>To avoid that, documents to which these nodes belong are copied into χ:instance elements and references between map entries values and instances are made using XPath expressions. </para><para>The following <code>$map</code>
                variable:<programlisting xml:space="preserve">&lt;xsl:variable name="a-node"&gt;
    &lt;foo/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</programlisting></para><para>Is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4" kind="document"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="document" instance="d4" path="/"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Like XSLT variable, instances do not always contain document nodes and the following <code>$map</code>
                variable:<programlisting xml:space="preserve">&lt;xsl:variable name="a-node" as="node()"&gt;
    &lt;foo/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</programlisting></para><para>Is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4e0" kind="fragment"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="element" instance="d4e0" path="root()" name="foo"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Nodes can belong to more than one instances, and this $map
                variable:<programlisting xml:space="preserve">&lt;xsl:variable name="a-node" as="node()*"&gt;
    &lt;foo/&gt;
    &lt;bar/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map" select="map{'a-node':= $a-node}"/&gt;</programlisting></para><para>Is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4e0" kind="fragment"&gt;
      &lt;foo/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:instance id="d4e3" kind="fragment"&gt;
      &lt;bar/&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="a-node" keyType="string"&gt;
         &lt;χ:node kind="element" instance="d4e0" path="root()" name="foo"/&gt;
         &lt;χ:node kind="element" instance="d4e3" path="root()" name="bar"/&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Nodes can be "deep linked", a same node can be linked several times and nodes can be mixed with atomic values at wish. The following $map
                variable:<programlisting xml:space="preserve">&lt;xsl:variable name="doc"&gt;
    &lt;department name="sales"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
    &lt;department name="accounting"&gt;
        &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
        &lt;/employee&gt;
        &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
        &lt;/employee&gt;
    &lt;/department&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map"
    select="map{
            'sales' := $doc/department[@name='sales'],
            'Sally' := $doc//employee[firstName = 'Sally'],
            'kids'  := $doc//employee[age &amp;lt; 30],
            'dep-names-attributes' := $doc/department/@name,
            'dep-names' := for $name in $doc/department/@name return string($name)
            }"/&gt;</programlisting></para><para>Is serialized
                as:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
   &lt;χ:instance id="d4" kind="document"&gt;
      &lt;department name="sales"&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Sally&lt;/firstName&gt;
            &lt;lastName&gt;Green&lt;/lastName&gt;
            &lt;age&gt;27&lt;/age&gt;
         &lt;/employee&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Jim&lt;/firstName&gt;
            &lt;lastName&gt;Galley&lt;/lastName&gt;
            &lt;age&gt;41&lt;/age&gt;
         &lt;/employee&gt;
      &lt;/department&gt;
      &lt;department name="accounting"&gt;
         &lt;employee&gt;
            &lt;firstName&gt;John&lt;/firstName&gt;
            &lt;lastName&gt;Doe&lt;/lastName&gt;
            &lt;age&gt;23&lt;/age&gt;
         &lt;/employee&gt;
         &lt;employee&gt;
            &lt;firstName&gt;Mary&lt;/firstName&gt;
            &lt;lastName&gt;Smith&lt;/lastName&gt;
            &lt;age&gt;32&lt;/age&gt;
         &lt;/employee&gt;
      &lt;/department&gt;
   &lt;/χ:instance&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="sales" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]"
                 name="department"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="Sally" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="kids" keyType="string"&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
         &lt;χ:node kind="element"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[2]/&amp;#34;&amp;#34;:employee[1]"
                 name="employee"/&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="dep-names-attributes" keyType="string"&gt;
         &lt;χ:node kind="attribute"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[1]/@name"
                 name="name"&gt;sales&lt;/χ:node&gt;
         &lt;χ:node kind="attribute"
                 instance="d4"
                 path="/&amp;#34;&amp;#34;:department[2]/@name"
                 name="name"&gt;accounting&lt;/χ:node&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="dep-names" keyType="string"&gt;
         &lt;χ:atomic-value type="string"&gt;sales&lt;/χ:atomic-value&gt;
         &lt;χ:atomic-value type="string"&gt;accounting&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para></section><section><title>Remaining Issues</title><para>A collation property should be added to <code>&lt;χ:map/&gt;</code>, probably as an attribute, the transformation to serialize to χίμαιραλ should be cleaned up and the reverse
                transformation should be implemented.</para><para>These are pretty trivial issues and the biggest one is probably to find a way to cleanly serialize references to nodes that are not contained within an element, such as the following
                $map
                variable:<programlisting xml:space="preserve">&lt;xsl:variable name="attribute" as="node()"&gt;
    &lt;xsl:attribute name="foo"&gt;bar&lt;/xsl:attribute&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="map"
    select="map{
            'attribute' := $attribute
            }"/&gt;</programlisting></para><para>Support of functions should also be considered.</para></section><section><title>χίμαιραλ and the identity crisis</title><para>To some extend, χίμαιραλ can be considered as a solution to the XDM identity crisis: <itemizedlist><listitem><para>Serializing an XDM model as χίμαιραλ creates elements for maps, map entries and atomic values and these elements, being nodes, have identities. The serialization is
                            therefore also an instantiation of XDM information items as defined above.</para></listitem><listitem><para>De-serializing a χίμαιραλ to create an XDM data model is also a de-instantiation-- except of course that the identity of XML nodes is not "removed". </para></listitem></itemizedlist></para><para>However, χίμαιραλ does keep a strong difference between nodes which are kept in <code>&lt;χ:instance&gt;</code> elements and maps and atomic values.</para></section></section><section><title>Moving the chimera forward</title><para>χίμαιραλ is a good playground to explore the new possibilities offered by XDM 3.0. Here is a (non exhaustive) list of a few directions that seem interesting... </para><note><para>Don't expect to find fully baked proposals in this section which contains, on the contrary very early drafts of  ideas to follow to support XDM maps as "first class citizens"!</para></note><section><title>Embracing RDF</title><para>If you had the opportunity to enjoy the sunny weather of Orlando in December 2001, you may remember "<link xlink:href="http://web.archive.org/web/20020115041927/http://www.idealliance.org/papers/xml2001/papers/html/03-01-04.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The Syntactic Web</link>" a provocative talk where
                Jonathan Robie has shown how XQuery 1.0 could be used to query normalized XML/RDF documents.</para><para>The gap between RDF triples and the versatility of its XML representation was a big issue, but the new features brought by this new version of the XPath/XQuery/XSLT package should
                help us.</para><para>The basic data model of RDF is based on triples, a triple being a composed of a subject, a predicate and an object. In XDM, a triple can now be represented by either a sequence, an
                array or a map of three items.</para><para>XDM sequences have the property that they cannot include other sequences and representing triples as sequences would mean that you couldn't define sequences of triples. For that
                reason it is probably better to define triples as maps or arrays. An array being a map indexed by integers, that doesn't make a huge difference at a conceptual level, but I find it
                cleaner to access to the subject of a triple using a QName (such as rdf:subject) rather than an index. Following this principle, we could define a triple
                as:<programlisting xml:space="preserve">map {
    xs:QName('rdf:subject')   := xs:anyURI('http://www.example.org/index.html'),
    xs:QName('rdf:predicate') := xs:anyURI('http://purl.org/dc/elements/1.1/creator'),
    xs:QName('rdf:object')    := xs:anyURI('http://www.example.org/staffid/85740')
}</programlisting></para><para>The χίμαιραλ serialization of this map
                is:<programlisting xml:space="preserve">&lt;χ:data-model xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:χ="http://χίμαιραλ.com#"
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
   &lt;χ:map&gt;
      &lt;χ:entry key="rdf:object"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://www.example.org/staffid/85740&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="rdf:predicate"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://purl.org/dc/elements/1.1/creator&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
      &lt;χ:entry key="rdf:subject"
               keyType="xs:QName"&gt;
         &lt;χ:atomic-value type="xs:anyURI"&gt;http://www.example.org/index.html&lt;/χ:atomic-value&gt;
      &lt;/χ:entry&gt;
   &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>What can we do with such triples? Using higher order functions, it should not be too difficult to define triple stores with basic query features!</para><para>Is this lightweight enough? Or does RDF support deserve new information item types to be supported by XDM?</para></section><section><title>Syntactical sugar</title><para>We've seen that this JSON
                object<programlisting xml:space="preserve">{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  </programlisting></para><para>Is serialized in χίμαιραλ
                as:<programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;χ:data-model xmlns:χ="http://χίμαιραλ.com#"&gt;
    &lt;χ:map&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;χ:map&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;χ:map&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/χ:map&gt;
                &lt;/χ:entry&gt;
            &lt;/χ:map&gt;
        &lt;/χ:entry&gt;
    &lt;/χ:map&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>We can work with that, but wouldn't it be nice if we had a native syntax that does not use XML elements and attributes to represent maps?</para><para>Depending on the requirements, many approaches are possible. </para><para>A first option would be to define pluggable notation parsers within XML and
                write:<programlisting xml:space="preserve">&lt;χ:notation mediatype="application/json"&gt;&lt;![CDATA[
{ "accounting" : [ 
      { "firstName" : "John", 
        "lastName"  : "Doe",
        "age"       : 23 },
      
      { "firstName" : "Mary", 
        "lastName"  : "Smith",
        "age"       : 32 }
                 ],                                 
  "sales"     : [ 
      { "firstName" : "Sally", 
        "lastName"  : "Green",
        "age"       : 27 },
      
      { "firstName" : "Jim",  
        "lastName"  : "Galley",
        "age"       : 41 }
                  ]
}                  
]]&gt;&lt;/χ:notation&gt;</programlisting>The
                meaning of the <code>&lt;χ:notation/&gt;</code> element would be to trigger a parser supporting the application/json datatype. This is less verbose, more natural to JSON users, but
                doesn't allow to add XML nodes in maps or sequences.</para><para>Another direction would be to extend the syntax of XML itself. To do so, again, there are many possibilities. The markup in XML is based on angle brackets and the distinction between
                the different XML productions is usually done through the character following the bracket in the opening tags.</para><para>This principle leaves a lot of possibilities. For instance, maps could be identified by the tags <code>&lt;{&gt;</code> and <code>&lt;/}&gt;</code> to follow the characters used by XDM map
                literals and JSON objects
                :<programlisting xml:space="preserve">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;χ:entry key="sales" keyType="string"&gt;
            &lt;{&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
            &lt;/}&gt;
        &lt;/χ:entry&gt;
        &lt;χ:entry key="accounting" keyType="string"&gt;
            &lt;{&gt;
                &lt;χ:entry key="1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
                &lt;χ:entry key="2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;χ:entry key="lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                        &lt;χ:entry key="firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/χ:entry&gt;
                    &lt;/}&gt;
                &lt;/χ:entry&gt;
            &lt;/}&gt;
        &lt;/χ:entry&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Map entries are not ordered and in that respect they are similar to XML attributes. We could use this similarity and use the character <code>@</code> to identify map
                entries:<programlisting xml:space="preserve">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@"sales" keyType="string"&gt;
            &lt;{&gt;
                &lt;@"1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"1"&gt;
                &lt;@"2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"2"&gt;
            &lt;/}&gt;
        &lt;/@"sales"&gt;
        &lt;@"accounting" keyType="string"&gt;
            &lt;{&gt;
                &lt;@"1" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"1"&gt;
                &lt;@"2" keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@"lastName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/@"lastName"&gt;
                        &lt;@"age" keyType="string"&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/@"age"&gt;
                        &lt;@"firstName" keyType="string"&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/@"firstName"&gt;
                    &lt;/}&gt;
                &lt;/@"2"&gt;
            &lt;/}&gt;
        &lt;/@"accounting"&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>The key names have been enclosed between quotes because map keys can include any character including whitespaces, but they can be made optional when they are not needed. We could
                also give to the keyType a default value of
                "string":<programlisting xml:space="preserve">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Green&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;27&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Sally&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@1
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Galley&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;41&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Jim&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@2
            &lt;/}&gt;
        &lt;/@sales
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Doe&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;23&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;John&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@1
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;χ:atomic-value type="string"&gt;Smith&lt;/χ:atomic-value&gt;
                        &lt;/@lastName
                        &lt;@age&gt;
                            &lt;χ:atomic-value type="number"&gt;32&lt;/χ:atomic-value&gt;
                        &lt;/@age
                        &lt;@firstName&gt;
                            &lt;χ:atomic-value type="string"&gt;Mary&lt;/χ:atomic-value&gt;
                        &lt;/@firstName
                    &lt;/}&gt;
                &lt;/@2
            &lt;/}&gt;
        &lt;/@accounting
    &lt;/}&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>Atomic values could be identified by <code>&lt;=&gt;</code> and <code>&lt;/=&gt;</code> and the same default value applied to its type
                attribute:<programlisting xml:space="preserve">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Green&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;27&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Sally&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Galley&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;41&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Jim&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@sales&gt;
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Doe&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;23&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;John&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;
                            &lt;=&gt;Smith&lt;/=&gt;
                        &lt;/@lastName&gt;
                        &lt;@age&gt;
                            &lt;= type="number"&gt;32&lt;/=&gt;
                        &lt;/@age&gt;
                        &lt;@firstName&gt;
                            &lt;=&gt;Mary&lt;/=&gt;
                        &lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@accounting&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;</programlisting></para><para>The tags that surround atomic values are useful when these values are within a sequence but look superfluous when the item has a single value. The next step could be to define that
                in that case as a shortcut the value and its type attribute could be directly included in the
                item:<programlisting xml:space="preserve">&lt;χ:data-model&gt;
    &lt;{&gt;
        &lt;@sales&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Green&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;27&lt;/@age&gt;
                        &lt;@firstName&gt;Sally&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Galley&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;41&lt;/@age&gt;
                        &lt;@firstName&gt;Jim&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@sales&gt;
        &lt;@accounting&gt;
            &lt;{&gt;
                &lt;@1 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Doe&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;23&lt;/@age&gt;
                        &lt;@firstName&gt;John&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@1&gt;
                &lt;@2 keyType="number"&gt;
                    &lt;{&gt;
                        &lt;@lastName&gt;Smith&lt;/@lastName&gt;
                        &lt;@age type="number"&gt;32&lt;/@age&gt;
                        &lt;@firstName&gt;Mary&lt;/@firstName&gt;
                    &lt;/}&gt;
                &lt;/@2&gt;
            &lt;/}&gt;
        &lt;/@accounting&gt;
    &lt;/}&gt;
&lt;/χ:data-model&gt;
</programlisting></para></section><section><title>XPath</title><para>The χίμαιραλ serialization being XML, it is possible to use XPath path expressions to query its structure. For instance, to get a list of employees which are less than 30, we can
                write:<programlisting xml:space="preserve">χ:map/χ:entry/χ:map/χ:entry/χ:map[χ:entry[@key='age'][χ:atomic-value &lt; 30]]</programlisting></para><para>Or, if we're feeling lucky:<programlisting xml:space="preserve">//χ:map[χ:entry[@key='age'][χ:atomic-value &lt; 30]]</programlisting></para><para>Again, that's good as long we work on a χίμαιραλ serialization but it would be good to be able to use <link xlink:href="http://www.w3.org/TR/2011/WD-xpath-30-20111213/#id-path-expressions" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">path expressions</link>  directly on map data structures. To do so we would need at minima to
                define steps to match maps and entries.</para><para>XSLT 3.0 introduces a new <link xlink:href="http://www.w3.org/TR/xslt-30/#map-type" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"><code>map()</code> item type</link> which could be used as a <link xlink:href="http://www.w3.org/TR/2011/WD-xpath-30-20111213/#doc-xpath30-KindTest" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">kind test</link> to identify maps.</para><para>If we follow the idea that map entries are similar to XML attributes, we could use the <code>@</code> notation to identify them. The XPath expression would then
                become:<programlisting xml:space="preserve">map()/@*/map()/@*/map()[@age &lt; 30]]</programlisting></para><para>Or, if we're feeling lucky:<programlisting xml:space="preserve">//map()[@age &lt; 30]]</programlisting></para></section><section><title>Validation</title><para>These data models can be complex. Wouldn't it be useful to be able to validate them with schema languages? This would give us a way to validate JSON maps!</para><para>Of course we can already serialize them in χίμαιραλ and validate the serialization using any schema language, but again it would be good to be able to validate these structures
                directly.</para><para>A RELAX NG schema to validate the χίμαιραλ serialization of our example would
                be:<programlisting xml:space="preserve">namespace χ = "http://χίμαιραλ.com#"

start = element χ:data-model { top-level-map }

# Top level map: departments
top-level-map =
    element χ:map {
        element χ:entry {
            attribute key { xsd:NMTOKEN },
            attribute keyType { "string" },
            emp-array
        }*
    }

# List of employees
emp-array =
    element χ:map {
        element χ:entry {
            attribute key { xsd:positiveInteger },
            attribute keyType { "number" },
            emp-map
        }*
    }

# Description of an employee
emp-map = element χ:map { (age | firstName | lastName) + }

age =
    element χ:entry {
        attribute key { "age" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "number" },
            xsd:positiveInteger
        }
    }

firstName =
    element χ:entry {
        attribute key { "firstName" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "string" },
            xsd:token
        }
    }

lastName =
    element χ:entry {
        attribute key { "lastName" },
        attribute keyType { "string" },
        element χ:atomic-value {
            attribute type { "string" },
            xsd:token
        }
    }
</programlisting></para><note><para>In the description of the maps used to describe employees, we cannot use <code>interleave</code> patterns because of the <link xlink:href="http://relaxng.org/spec-20011203.html#interleave-restrictions" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">restriction on interleave</link> and the schema is approximate. In this specific case, we could
                    enumerate the six possible combinations but the exercise would quickly become verbose if the number of items
                    grew:<programlisting xml:space="preserve">emp-map = element χ:map { 
      (age, firstName, lastName)  
    | (age, lastName, firstName) 
    | (firstName, age, lastName)  
    | (firstName, lastName, age) 
    | (lastName, age, firstName)  
    | (lastName, firstName, age) 
}</programlisting></para></note><para>A Schematron schema for the χίμαιραλ serialization could be developed based on XPath expressions similar to those that have been shown in the previous section.</para><para>Again, it would be interesting to support maps directly as first class citizens in XML schema languages.</para><para>The ability to use Schematron on XDM maps depends directly on the ability to browse maps using patterns and path expressions in XPath and XSLT (see above)...</para><para>The main impact on RELAX NG would be to add <code>map</code> and <code>item</code> patterns and the schema could look
                like:<programlisting xml:space="preserve">namespace χ = "http://χίμαιραλ.com#"

start = element χ:data-model { top-level-map }

# Top level map: departments
top-level-map =
    map  {
        entry xsd:NMTOKEN {
            emp-array
        }*
    }

# List of employees
emp-array =
    map {
        entry xsd:positiveInteger {
            emp-map
        }*
    }

# Description of an employee
emp-map = map { age, firstName, lastName  }

age =
    entry age {
            xsd:positiveInteger
        }
    }

firstName =
    entry firstName {
             xsd:token
        }
    }

lastName =
    entry lastName {
            xsd:token
        }
    }
</programlisting></para><para>Sequences could probably be supported without adding a new pattern but would require to relax some restrictions to allow the description of sequences mixing atomic values, maps and
                nodes (in Relax NG, sequences of atomic values are already possible in list datatypes, sequences of nodes are of course available to describe node contents but these two type of
                sequences cannot be mixed).</para></section></section><section><title>Conclusion</title><para>According to the definition of chimeras in genetics from Wikipedia quoted in the introduction, <citation>chimeras are formed from at least four parent cells (two fertilized eggs or early
                embryos fused together). Each population of cells keeps its own character and the resulting organism is a mixture of tissues</citation>.</para><para>The current XDM proposals have added to the XML data model a foreign model to represent maps. This new model is a superset of the JSON data model. The two data models keep their own
            character and the resulting model is a mixture of information items.</para><para>It's far to say that the current XDM proposal is a chimera, something described as <citation>usually ugly, foolish or impossible fantasies</citation> by Jeni Tennison.</para><para>I hope that the proposals sketched in this paper will help to address this situation and fully integrate these new information items in the XML echosystem.</para></section></article>