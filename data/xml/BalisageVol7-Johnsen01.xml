<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title>TagAl</title><subtitle>A tag algebra for document markup</subtitle><info><confgroup><conftitle>Balisage: The Markup Conference 2011</conftitle><confdates>August 2 - 5, 2011</confdates></confgroup><abstract><para> This paper takes its point of departure in an overview of the overlap problem, and of
        proposed solutions to that problem. We then look at some analogies between bracketed markup
        notations and rules for well-formedness and structuring of simple parenthetical expressions.
        We propose a method for building lattices from marked up documents with and without overlap,
        and for generating, from these lattices, document models in the form of trees for XML
        documents, and in the form of GODDAGs for documents with overlap. It turns out that one and
        the same method can be used for generating both kinds of models, and we argue that lattices
        can also be used to implement well-formedness constraints for both kinds of documents.
        Finally, we discuss and compare some of the algebraic features of the document models, and
        the relations between them. </para></abstract><author><personname><firstname>Lars</firstname><othername>G</othername><surname>Johnsen</surname></personname><personblurb><para>Lars G. Johnsen is Associate Professor of linguistics at the University of Bergen,
          Norway.</para></personblurb><email>hfolg@uib.no</email><affiliation><jobtitle>Associate Professor</jobtitle><orgname>University of Bergen, Norway</orgname></affiliation></author><author><personname><firstname>Claus</firstname><surname>Huitfeldt</surname></personname><personblurb><para>Claus Huitfeldt is Associate Professor at the Department of Philosophy of the
          University of Bergen, Norway.</para></personblurb><affiliation><jobtitle>Associate Professor </jobtitle><orgname>University of Bergen</orgname></affiliation><email>claus.huitfeldt@uib.no</email></author><legalnotice><para>Copyright © 2011 by the authors.  Used with permission.</para></legalnotice></info><section><title>Digital documents: Representational forms and operations</title><para>When computers were first used for purposes of text processing, documents were typically
      represented as linear sequences of characters. This format lends reasonable support to basic
      operations on documents, such as visual presentation, editing, retrieval, content extraction,
      linguistic and quantitative analysis, and various forms of transformation. </para><para>However, the objects of such operations are not always most naturally thought of, or not
      easily identified, in terms of character sequences. Some operations are performed on
      structural partitions of documents such as sections, paragraphs, or sentences. Objects defined
      in terms of their thematic, linguistic, rhetorical or other properties, such as names, foreign
      words, high-lighted phrases etc. may also be the target of operations to be performed.
      Sometimes such objects can be identified at least indirectly in terms of properties of
      character sequences, but seldom reliably, <footnote><para>Simple examples in point are sentences, quotations, and proper names</para></footnote> and often not at all. </para><para>Document markup can be seen as a response to these problems: when candidate objects of
      operations are explicitly marked, text processing applications are relieved of the burden of
      identifying them, and developers of such applications may concentrate on the operations to be
      performed rather than on the identification of the objects to be processed. Thus, marked up
      documents provide improved support for text processing, compared to documents without markup. </para><para> Therefore, it is perhaps only natural that with the introduction of document markup, the
      number and kinds of document objects that became subject of interest for processing increased.
      Markup languages and tools were developed not only for general purpose document publication
      and analysis, but also for more specialized purposes and document types. </para><para>For a number of reasons, the markup languages which became most widely used, and the
      grammars which ultimately acquired the status of international standards for those languages,
      such as SGML and XML, <footnote><para>For convenience, we will allow ourselves to use the term "XML" in the rest of this
          paper, also when for historical or other reasons the correct reference would be either to
          XML, or to SGML, or to both.</para></footnote> were based on context-free grammars. One obvious reason was that representations
      based on context-free grammars were processable according to well known and computationally
      efficient algorithms. Over the years a plethora of general as well as special-purpose software
      for XML document processing has become available. </para><para> Such markup languages invite an abstract view of document structure and content, in which
      the "artifacts" of markup in the document in its serial form are represented in a more
      conspicuous way. Many or most XML processors do not actually perform operations on the
      document in its serialized form, but only (or largely) on a model of the document, usually in
      the form of a labeled directed acyclic graph. The graph is constructed from the serialized
      form of the document, and reserialized only for purposes of storage and exchange. Since one
      and the same graph may be represented in the form of more than one serialization, focus tends
      to be transferred on the graph (or, in XML terms, the document object model), rather than the
      serial form of the document. </para></section><section><title>The Overlap Problem</title><para> The coincidence of the two factors mentioned above (i.e. the increasing interest in
      marking up more and more aspects of documents, and the fact that available systems were based
      on context-free grammars) lead to a number of closely related problems which are now commonly
      referred to as "the overlap problem". <footnote><para>The one problem which has received most attention in the literature is the difficulty
          or inconvenience of representing overlapping elements in XML. There are related problems
          pertaining to the representation of discontinuous elements and alternate ordering of
          elements, which we do not address in this paper. We do believe, however, that the general
          strategy outlined here could also be adopted in order to get a better grip on these
          problems.</para></footnote> On the one hand, the obvious advantages of markup lead to interest in marking up a
      wide variety of aspects of document structure, often necessitating different segmentations of
      one and the same document. On the other hand, standard markup systems did not provide a
      straight-forward and natural way of representing such competing or conflicting segmentations. <footnote><para> An important exception on this point is the SGML CONCUR feature, which did provide a
          mechanism for the encoding of concurrent hierarchies. Unfortunately, CONCUR was never
          widely supported by SGML implementations, and was not carried over to XML. However see
            [<xref linkend="Schonefeld2007"/>]. </para></footnote> So although marked up documents provide better support for a broad range of
      processing purposes than documents without markup, the introduction of markup also lead to a
      number of problems one did not have much means or motivation to identify or formulate before
      the introduction of markup. </para><para>The so-called overlap problem was identified fairly early, and the literature of proposed
      solutions goes more than 30 years back in time. <footnote><para>See e.g. [<xref linkend="Barnardetal.1988"/>], [<xref linkend="Barnardetal.1995"/>], [<xref linkend="DeRose2004"/>], and [<xref linkend="Witt2005"/>].
          We cannot and do not attempt a full overview of the literature in this paper, but only to
          point to some of the main courses among various approaches to the problem. </para></footnote> The responses to the problem may be said to fall largely in four groups: 1)
      Alternate linear forms, 2) Alternate document models, 3) Stand-off markup, and 4)
      Transformation algorithms. </para><section><title>Alternate linear forms</title><para> Since the syntax of XML enforces a strict hierarchical nesting of XML elements, it
        seems like a tempting solution simply to lift or soften this restriction. A large number of
        such proposals have been made. </para><para>Some notable examples are SGML CONCUR [<xref linkend="Goldfarb1990"/>], XCONCUR
          [<xref linkend="Schonefeld2007"/>], MECS [<xref linkend="Huitfeldt1998"/>],
        TexMecs [<xref linkend="HuitfeldtandSperberg-McQueen2003"/>], and LMNL [<xref linkend="TennisonandPiez2002"/>]. </para><para>The advantages of most of these proposals is that they provide what for human readers
        seems like a more natural and easily readable linear representation of overlapping elements
        than is provided by alternative proposals adhering to XML syntax. They may also provide
        better support for certain operations on overlapping elements. However, for the most part it
        is unclear how to perform anything like a full range of standard operations on their markup
        constructs, and there are unresolved issues of processability, expressive power etc. </para></section><section><title>Alternate document models</title><para> Some proposals provide alternatives to what is commonly perceived as the XML document
        model, i.e. tree-shaped graphs like XDM or XML DOM, either in combination with or
        independently of proposals for alternative linear forms. </para><para>Some notable examples are LMNL [<xref linkend="TennisonandPiez2002"/>], Goddag
          [<xref linkend="Sperberg-McQueenandHuitfeldt2000"/>], multi-colored trees [<xref linkend="Jagadishetal.2004"/>], and Multi-Document Graphs [<xref linkend="SchmidtandColomb2009"/>]. </para><para>Although these solutions in general provide better support for at least certain
        operations on overlapping elements, the question of how to perform other standard operations
        is mostly unclear or not systematically addressed. For some of the proposals it is also
        unclear whether, or to what extent, it is possible to support roundtripping between the
        proposed document model and its form, or even what such roundtripping would amount to. (This
        is the case, for example, concerning the relation between Goddag and TexMecs.) Again, there
        are in general unresolved issues of processability, expressive power etc. </para></section><section><title>Stand-off markup</title><para>Quite early on, it was suggested that many or most of the problems related to overlap
        can be seen as a result of the general limitations of embedded markup. [<xref linkend="Raymondetal1992"/>, <xref linkend="Raymondetal1995"/>] Thus, the idea
        of separating the markup from the document to be marked up, in the form of so-called
        "stand-off" markup has received considerable attention and adoption. </para><para>Some notable examples are xStandoff [<xref linkend="StührenbergandJettka2009"/>],
        Nite [<xref linkend="Carlettaetal.2005"/>], Earmark [<xref linkend="DiIorioetal.2009"/>], and (as an interesting limiting case) Multix [<xref linkend="Chattietal.2007"/>]. TEI [<xref linkend="TEIP5"/>] also contains recommendation for stand-off
        markup. </para><para>Stand-off markup does indeed provide potentially very strong expressive power and might
        seem to be the one sweeping solution to all problems related to overlap. And perhaps it is. <footnote><para>In addition, stand-off markup may provide solutions to problems related to the
            representation of document change histories, of multi-versioned documents, and to
            dynamic document editing. These problems often coincide with, but are in our view
            distinct from, the overlap problem. Common objections to stand-off markup concern data
            integrity under document editing. This is indeed a serious concern, but one which lies
            outside the scope of this paper.</para></footnote> We note, however, that standoff markup either has been used, or could be used,
        in combination with any or all of the linear formats and document models referred to above.
        Thus, all the unclarities that pertain to those, and to the relationships between them,
        pertain also to stand-off markup. </para></section><section><title>Transformation algorithms</title><para>Since there is such a multitude of proposals for alternate linear forms and document
        models, since they all have their pros and cons, and since no universal agreement on a
        unified solution seems to be forthcoming, it has been proposed that one should instead try
        to provide a common framework of algorithms for transformation between different linear
        forms and/or document models. <footnote><para>Requests and proposals for transformation tools are abundant in the literature, but
            we know of only one proposal which recommends the establishment of a common framework of
            transformation algorithms as a general solution: [<xref linkend="Marinellietal.2008"/>].</para></footnote>
      </para><para>The advantages of this approach may be as obvious as its disadvantages: A major
        advantage is that, to the extent that transformations may be performed without loss of
        information, it makes all the strengths of all of the solutions above available to the
        users. Major disadvantages are: First, for every alternate serial form and/or document model
        introduced, the number of required transformation algorithms increases exponentially. Second
        (and perhaps most importantly), there seems to be no established and agreed-upon way of
        deciding whether or not any given transformation algorithm introduces information
      loss.</para></section></section><section><title>The idea of a tag algebra</title><para> There seems to be no consensus neither on whether the basic elements of marked up
      documents are most suitably regarded as partitions of a character stream (tags, elements etc.)
      or nodes of a graph of some kind, nor on what the basic operations on these elements are and
      how they are to be defined. As long as these issues are not clear, it is hard to compare and
      evaluate the various approaches to the overlap problem. </para><para>Elementary algebra assumes that numbers are the same whether written in Arabic or Roman
      notation, or, for that matter, whether we use a decimal, a digital or a hexadecimal numeral
      system, and that the sum of two numbers is the same irrespective of which algorithm we employ
      to calculate it. Certainly, some notations may seem less intuitive than others, and some
      notations require the use of more complex algorithms than others in order to perform certain
      operations. However, while important enough, such issues have no bearing on the question of
      what the correct result of an operation is. There is one and only one answer to the question
      of what the sum of two numbers are, irrespective of which notation and algorithm one might
      choose to use in computing that sum.</para><para>Similarly, a tag algebra should be able to tell us whether two representations of a
      document marked up using different notations are representations of the same document or not,
      and what the result of adding or subtracting a specific element to or from that document
      should be. In what follows, we hope to establish at common basis for the solution of at least
      the first of these problems. We believe this basis will also be useful for defining operations
      on marked up documents, although we do not get that far in this paper. </para></section><section><title>Bracketed notations and matching</title><para> In the rest of this paper, we will explore the relationship between markup without
      overlap and markup with overlap by way of comparing XML to another, imaginary markup language.
      This other markup language, which we may call O-XML, is exactly like XML, except that in O-XML
      overlap is allowed. <footnote><para>For all relevant purposes, therefore, O-XML is equivalent to what Yves Marcoux termed
          "overlap-only TexMECS" in [<xref linkend="Marcoux2008"/>]. Note that, like
          "overlap-only TexMECS" and some other notations, but unlike yet other notations allowing
          for overlap, O-XML does not allow for self-overlap.</para></footnote> So whereas nesting structures like
      <programlisting xml:space="preserve">&lt;a&gt;...&lt;b&gt;...&lt;/b&gt;...&lt;/a&gt;</programlisting> are well-formed in both
      XML and O-XML, overlapping structures like
      <programlisting xml:space="preserve">&lt;a&gt;...&lt;b&gt;...&lt;/a&gt;...&lt;/b&gt;</programlisting> are ill-formed in XML,
      but well-formed in O-XML. As we are concerned exclusively with element structure, we ignore
      all other features or mechanisms of XML such as attributes, entities, comments, declarations,
      cdata sections, processing instructions, etc. </para><para>We may start with the observation that in XML all elements nest, while in documents with
      overlap not all of them do. <footnote><para>The latter may seem like a tautology, as it merely says that in documents with overlap
          some elements overlap. Note that in the sense we are using the term overlap here, XML
          documents do not have overlap, whereas documents in notations like O-XML, such as MECS,
          TexMecs, LMNL, xConcur etc. may have.</para></footnote> We may also observe that the element structure of XML documents can be deduced
      without looking at the generic identifiers of end tags, <footnote><para>This may be one of the reasons for the complaints about the verbosity of XML as
          compared to e.g. SGML, which allows for the omission of generic identifiers on end
        tags.</para></footnote> whereas in notations allowing overlap this information is essential. We might
      summarize this by saying that in XML the start and end tags of nesting elements always match,
      whereas in other notations they do not always match. </para><para>But there is something puzzling about this way of putting the matter. Exactly what do we
      mean by the terms <quote>nesting</quote>, <quote>element</quote>, and <quote>match</quote>? We
      observe that whereas there is no overlap in
      <programlisting xml:space="preserve">&lt;a&gt;...&lt;b&gt;...&lt;/b&gt;...&lt;/a&gt;</programlisting> and there is overlap in
      <programlisting xml:space="preserve">&lt;a&gt;...&lt;b&gt;...&lt;/a&gt;...&lt;/b&gt;</programlisting> the difference between
      them disappears if we leave out the generic identifiers:
      <programlisting xml:space="preserve">&lt; &gt;...&lt; &gt;...&lt;/ &gt;...&lt;/ &gt;</programlisting> Our guess is that it
      probably seems natural to most readers to assume that the element structure of the last
      example above is identical to the first, rather than the second. But is this necessarily so,
      and if so, why? Let us pursue the similarities between the nesting of start and end tags and
      the nesting of simple parentheses a bit further. </para><para>Consider any string consisting of left (i.e. start, or open) and right (i.e. end, or
      close) parentheses. One common assumption is that there should be a one to one correspondence
      between left and right parentheses, so that they are equal in number. This ensures that the
      string <code>((()))</code> is to be regarded as well-formed, while the string
      <code>((())</code> is not. Another common assumption is that for every left parenthesis there
      is a succeeding right parenthesis. This ensures that the string <code>)()(</code> is not to be
      regarded as well-formed. In the following, we will refer to these two assumptions as "basic".</para><para> The two basic assumptions do not by themselves imply any specific answer to the question
      which of the left parentheses correspond to which of the right parentheses in the well-formed
      cases. The intuitively most plausible (or common) reading of the string <code>(())</code> may
      be in accordance with a "nesting" convention, to the effect that the first left parenthesis
      corresponds to the last right parenthesis. According to this convention, the structure of the
      expression <code>()(())</code> looks like this, where subscripts indicate correspondence: <blockquote><para>
          <code>(<subscript>1</subscript> )<subscript>1</subscript> (<subscript>2</subscript>
              (<subscript>3</subscript> )<subscript>3</subscript> )<subscript>2</subscript></code>
        </para></blockquote> However, nothing in the two basic assumptions as stated stops us from adopting
      other conventions. We might imagine a "mirroring" convention, where the first left parenthesis
      corresponds to the first right, the second left parenthesis to the second right, and so on. A
      "mirroring" convention for the same expression may look like this: <blockquote><para>
          <code>(<subscript>1</subscript> )<subscript>1</subscript> (<subscript>2</subscript>
              (<subscript>3</subscript> )<subscript>2</subscript> )<subscript>3</subscript></code>
        </para></blockquote> (Note the "overlap" between parentheses subscripted <quote>2</quote> and
        <quote>3</quote> here. <footnote><para>Nesting and mirroring agrees on single level coordinate structures, for example
            <code>()()</code>.</para></footnote>)</para><para>Other conventions may be imagined in which some parentheses are selected according to
      specific rules, while the rest follow some general scheme like nesting or mirroring. <footnote><para> Imagine speakers of two dialects Nest and Mirr of the language Parenthesian, a
          language forming subsets of well-formed parentheses. In dialect Nest the semantics follows
          nested brackets, in Mirr matches are a mix of mirrored and nested parenthesis. In both
          dialects the word for walk is <code>"()"</code> and the word for dog is "(())". The rule
          for forming "verb+subject" sentences in dialect Nest is to wrap the verb inside the first
          parenthesis of the noun, so that "dog walks" becomes <code>"(()())"</code>. Using
          subscripted d's to indicate "dog" the structure is:<code>
              (<subscript>d</subscript>()(<subscript>d</subscript>)<subscript>d</subscript>)<subscript>d</subscript>.
          </code> Dialect Mirr has a different rule for forming sentences (verb+subject): wrap the
          last parenthesis of the verb around the first parenthesis of the noun, resulting in the
          configuration <code>"(()())"</code>. Surprisingly, this is exactly the same expression as
          above, although it now has a different structure: <code>
              ((<subscript>d</subscript>)(<subscript>d</subscript>)<subscript>d</subscript>)<subscript>d</subscript>.
          </code></para></footnote>
    </para><para> Thus, the two basic assumptions concerning the well-formedness of parenthetical
      expressions are compatible with alternate ways of assigning structure to those expressions.
      This important fact is easy to overlook, because one common method of testing for
      well-formedness, namely the use of rewrite grammars, also lends itself very easily to the
      assignment of a structure in accordance with the "nesting" convention above. The following
      example will illustrate this. </para><para>A rewrite grammar for generating strings of parentheses which obey the two basic
      assumptions may look like this: <variablelist><varlistentry><term>Base step</term><listitem><para>
              <code>P→()</code>
            </para></listitem></varlistentry><varlistentry><term>Subordination step</term><listitem><para>
              <code>P→(P)</code>
            </para></listitem></varlistentry><varlistentry><term>Coordination step</term><listitem><para>
              <code>P→PP</code>
            </para></listitem></varlistentry></variablelist>A string is well-formed, in accordance with the two basic assumptions, if and
      only if it can be generated by this grammar, which generates strings like <code>()</code>,
        <code>()(()())</code> and <code>((()))</code>
      <footnote><para> If we allow for the use of regular expressions in grammar rules, the base and
          coordination steps can be merged to: <code>P→P*</code>
        </para></footnote>
    </para><para> As mentioned, this grammar may also be used in order to assign a structure to the
      expressions in accordance with the "nesting" convention. This may be done by associating with
      each other the two parentheses that are generated together in each of the subordination or
      base steps. Selecting an index from the sequence number of rule application, the string
        <code>(()())</code> could be derived with indicated associations as follows, where each rule
      selects a <code>P</code> in the string coming from the immediately preceding rule application,
      and substitutes it with the right hand side of the →: <variablelist><varlistentry><term> 0th step, start symbol</term><listitem><para>
              <code>P</code>
            </para></listitem></varlistentry><varlistentry><term>1st step, subordination</term><listitem><para>
              <code>(<subscript>1</subscript> P )<subscript>1</subscript></code>
            </para></listitem></varlistentry><varlistentry><term>2nd step, coordination step</term><listitem><para>
              <code>(<subscript>1</subscript> P P )<subscript>1</subscript></code>
            </para></listitem></varlistentry><varlistentry><term>3rd step, base step </term><listitem><para>
              <code>(<subscript>1</subscript> (<subscript>3</subscript> )<subscript>3</subscript> P )<subscript>1</subscript></code>
            </para></listitem></varlistentry><varlistentry><term>4th step, base step</term><listitem><para>
              <code>(<subscript>1</subscript> (<subscript>3</subscript> )<subscript>3</subscript>(<subscript>4</subscript> )<subscript>4</subscript> )<subscript>1</subscript></code>
            </para></listitem></varlistentry></variablelist> After the fourth step, there are no non-terminals left in the expression, and
      the process halts. As can be seen from the last line, the structure that has been assigned to
      the expression is in exact accordance with the "nesting" convention. </para><para>This confirms that rewrite grammars may be used for assigning structure as well as for
      checking well-formedness. However, one may very well use a rewrite grammar to check for
      well-formedness <emphasis role="ital">without</emphasis> using that same grammar for assigning
      structure. Moreover, there are other ways both of checking well-formedness and of assigning
      structure than using rewrite grammars.</para><para>This should make clear that well-formedness is separate from structure. In the appendix we
      prove that well-formedness is preserved even when inserting randomly any left parenthesis,
      succeeded by another randomly inserted right parenthesis, into a well-formed string. </para><para>We observe that the rule for matching of start and end tags in XML is identical to what we
      called a "nesting" convention for simple parenthetical expressions above. We also observe that
      this seems to be the "default" rule for matching of start and end tags in markup languages
      which allow overlap, such as O-XML. In such languages, however, deviations from the default
      rule are allowed, and they are signaled by the selection of generic identifiers for end tags. </para><para>This explains why, as we noted above, the element structure of XML documents can be
      identified independently of information about the generic identifiers of start and end tags,
      whereas in O-XML this information is essential. In the following sections we will exploit
      these observations in order to look at alternate ways of describing the difference between
      nesting and overlap.</para></section><section><title>Document lattices</title><para>We believe that lattice theory [<xref linkend="Grätzer1971"/>] may usefully be
      applied to the construction of document models from marked-up documents. Lattice theory, like
      graph theory, is a way of reasoning over ordering relations. The theory has two components,
      one is a theory of order, the other of algebraic operations defined in terms of that order. In
      this section we will consider the order aspect, while algebraic operations will be discussed
      in the next section ("Algebraic characterization"). </para><para>A lattice is a partially ordered set of objects, here referred to as nodes, which will
      provide the elements of document models. Not all nodes will find their way into a document
      model, only those that do may also be referred to as elements, in agreement with the use of
      this term in XML and XSLT. A key requirement for an ordered collection of nodes to constitute
      a lattice, is that there should be one unique largest and one unique smallest node in the
      collection. If there is only a largest (or smallest) node, it is what is called a
      semi-lattice. <footnote><para>In the following, this distinction will not always be important, and we may
          occasionally refer to lattices and semi-lattices indiscriminately as "lattices".</para></footnote> Examples of lattices so constructed abound. Any society ordered by social rank (or
      constitutional order) is a semi-lattice, with e.g president or monarch at the top. XML trees
      are semi lattices, with a root node on the top and text nodes at the bottom. </para><para> We analyze the stream of characters making up a document morphologically into a series of
      typed objects consisting of start tags, end tags, and simples.<footnote><para>As noted above, the only difference between XML and O-XML is that O-XML allows
          overlapping elements. Therefore, element structures of some other markup languages, such
          as the suspend and resume tags of TexMecs, are not taken into consideration.</para></footnote> The terms "start tag" and "end tag" should require no further explanation. We will
      used XML notation in specifying them. </para><para>The term "simples" refers to PCDATA. Informally, we might say that a simple is whatever
      occurs between two tags. <footnote><para>Excluding other markup constructs, such as comments, processing instructions or
          declarations, cf. the remark above. It does not matter whether the tags separating two
          simples are start tags, end tags, or a combination of start and end tags.</para></footnote>
    </para><para>Empty elements are treated as a start tag followed by an end tag, without any intervening
      simple. </para><para>We assume a linear order on the morphological constituents. This order is derived directly
      from the serialized form of the document.</para><para>Consider the following XML sample document, D<subscript>1</subscript>:<figure><title>Sample document 1 (D<subscript>1</subscript>)</title><para>
          <code>&lt;a&gt;X&lt;b&gt;Y&lt;/b&gt;&lt;c&gt;Z&lt;/c&gt;&lt;/a&gt;</code>
        </para></figure> According to the definitions just given, this document is a linearly ordered set of
      token objects, consisting of the following morphological constituents with the properties
      indicated in this table, along with position indexes which, for our purpose, serve as token
      indexes for the types: <table border="1" cellpadding="10" cellspacing="0"><tr><td>Constituent</td><td>&lt;a&gt;</td><td>X</td><td>&lt;b&gt;</td><td>Y</td><td>&lt;/b&gt;</td><td>&lt;c&gt;</td><td>Z</td><td>&lt;/c&gt;</td><td>&lt;/a&gt;</td></tr><tr><td>Type</td><td>start</td><td>simple</td><td>start</td><td>simple</td><td>end</td><td>start</td><td>simple</td><td>end</td><td>end</td></tr><tr><td>N</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></table>
    </para><para>For any document D, let S be the set of all start tag tokens and E the set of all end tag
      tokens in the document. Take the Cartesian product (all possible combinations) of S and E, and
      subtract all pairs for which the position of the end tag does not succeed the start tag. This
      object then represents all the possibilities for a start tag to match up with an end tag. Add
      the simples, and name the result L(D). </para><para>L(D<subscript>1</subscript>) now consists of the following nodes: <table border="1" cellpadding="15" cellspacing="0"><tr><td>&lt;a&gt;</td><td>&lt;/b&gt;</td><td>1</td><td>5</td></tr><tr><td>&lt;a&gt;</td><td>&lt;/c&gt;</td><td>1</td><td>8</td></tr><tr><td>&lt;a&gt;</td><td>&lt;/a&gt;</td><td>1</td><td>9</td></tr><tr><td>&lt;b&gt;</td><td>&lt;/b&gt;</td><td>3</td><td>5</td></tr><tr><td>&lt;b&gt;</td><td>&lt;/c&gt;</td><td>3</td><td>8</td></tr><tr><td>&lt;b&gt;</td><td>&lt;/a&gt;</td><td>3</td><td>9</td></tr><tr><td>&lt;c&gt;</td><td>&lt;/c&gt;</td><td>6</td><td>8</td></tr><tr><td>&lt;c&gt;</td><td>&lt;/a&gt;</td><td>6</td><td>9</td></tr><tr><td>X</td><td/><td>2</td><td>2</td></tr><tr><td>Y</td><td/><td>4</td><td>4</td></tr><tr><td>Z</td><td/><td>7</td><td>7</td></tr></table>
    </para><para>The reader may be puzzled by the fact that we include non-matching pairs of tags, i.e.
      nodes with start and end tags with different generic identifiers (GIs), among the nodes of the
      lattice. This is simply because the point of the exercise at this stage is to see how far we
      are able to build document models without taking the generic identifiers of tags into
      consideration.</para><para> We define a hierarchical order relation between nodes in terms of
      <emphasis>containment</emphasis> as follows: A node x is larger than a node y if and only if
      the start position of x is smaller or equal to that of y, and the end position of x is greater
      or equal to that of y (viewed as strings the larger, or higher, node contains the other). <footnote><para>This would mean that nodes contain each other if their start and end positions are
          identical, -- however this situation cannot occur in the current context, since a position
          index functions as token index.</para></footnote> This relation is asymmetric and transitive, so it is a partial order. <footnote><para> We observe that these concepts are parallel to the concepts of sequence and range of
          Core Range Algebra [<xref linkend="Nicol2002a"/>]. There is a connection between the
          approach adopted here, and Core Range Algebra, but we leave a discussion of that
          connection for future work.</para></footnote></para><para>With this order in place, L(D<subscript>1</subscript>) as given in the table above is a semi-lattice. It
      has a top node, namely the pair consisting of the first start tag and last end tag
        <code>&lt;a&gt;₁&lt;/a&gt;₉</code>. It also has a set of minimal nodes, the
      simples. Each pair of tag tokens is a node in the semilattice. Lattice structures are
      displayed using Hasse-diagrams (familiar from tree structures).<orderedlist><listitem><para>Nodes are positioned vertically according to their position in the hierarchy, with
            the more inclusive nodes at the top and the less inclusive further down. </para></listitem><listitem><para>Nodes at the same vertical level are positioned from left to right according to
            their linear order in the document. </para></listitem></orderedlist>
    </para><para>The lattice structure for L(D<subscript>1</subscript>): <figure xml:id="L" xreflabel="Lattice         L(D₁)"><title>Lattice L</title><mediaobject><imageobject><imagedata width="330px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-001.png"/><!--<imagedata width="230px" format="png" fileref="bal2011john111001.png"/>--></imageobject></mediaobject></figure>
    </para><para>As mentioned, the hierarchical order is transitive. According to the conventions of
      diagrams like these, however, lines are drawn only between nodes immediately ordered. </para><para>Before we proceed, we need to define a relation we call <emphasis role="ital">relatives</emphasis>: Two nodes are relatives if they share a token start or end tag. This is
      a reflexive, symmetric and non-transitive relation. </para><para>We also need to define a concept which has already been introduced implicitly, the concept
      of a <emphasis role="ital">minimal node</emphasis>: A node is minimal if it is lowest in the
      hierarchy, i.e. if it contains no other node.</para></section><section><title>Building document models from lattices</title><section><title>Modeling documents without overlap</title><para>In what follows, we will show how what we may call a "standard" document model can be
        built on the basis of the lattice. In building this model, we will rely on distinguishing
        between nodes only in terms of the morphology introduced earlier, i.e. on the basis of which
        start tags, end tags, or simple tokens they contain. In particular, we do <emphasis role="ital">not</emphasis> take the GIs of tags into consideration in the building of this
        model. </para><para>A document model for D<subscript>1</subscript> from the lattice L(D<subscript>1</subscript>) is built through a
        number of steps by selecting subsets from L(D<subscript>1</subscript>). Hence, the model building process
        can be viewed as a filtering process. We start from the bottom of the lattice and identify
        all the lowest-level minimal nodes. We copy these minimal nodes, i.e. the nodes labeled
        X₂, Y₄ and Z₇, from L and transfer them to a subset of L(D<subscript>1</subscript>)
        which we call S<subscript>0</subscript>. <figure xml:id="D0" xreflabel="subset           S₀"><title>Subset S<subscript>0</subscript></title><para>
            <code>X₂ Y₄ Z₇</code>
          </para></figure> We then delete these minimal nodes from L(D<subscript>1</subscript>), <footnote><para>These minimal nodes happen to have no relatives, otherwise we would have had to
            delete those as well. See next step.</para></footnote> and call the result L<subscript>0</subscript>. <figure xml:id="L0" xreflabel="Lattice L0"><title>Subset L<subscript>0</subscript></title><mediaobject><imageobject><imagedata width="330px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-002.png"/><!--<imagedata width="230px" format="png" fileref="bal2011john111002.png"/>--></imageobject></mediaobject></figure>
      </para><para>We repeat the process of selecting minimal nodes, now from L<subscript>0</subscript>,
        and add them to S<subscript>0</subscript>, naming the result S<subscript>1</subscript>. In
        this case the minimal nodes are those labeled &lt;b&gt;₃&lt;/b&gt;₅ and
        &lt;c&gt;₆&lt;/c&gt;₈. S<subscript>1</subscript> inherits the order from L, and looks like
        this: <figure xml:id="S1" xreflabel="Lattice S1"><title>Subset S<subscript>1</subscript></title><mediaobject><imageobject><imagedata width="310px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-003.png"/><!--<imagedata width="210px" format="png" fileref="bal2011john111003.png"/>--></imageobject></mediaobject></figure> Next, we delete these minimal nodes, <emphasis role="ital">as well as all their
          relatives</emphasis>, from L<subscript>0</subscript>, and call the result
        L<subscript>1</subscript>. </para><para>Removal of the relatives assures that a tag can only enter into a relationship once. As
        soon as a node is selected for the model, neither the start nor the end tag of that node can
        enter into another node of the model. The relatives of &lt;b&gt;₃&lt;/b&gt;₅
        in L(D<subscript>1</subscript>) are the following nodes <figure xml:id="rel1" xreflabel="relatives           b/b"><title>Relatives of &lt;b&gt;₃&lt;/b&gt;₅</title><mediaobject><imageobject><imagedata width="250px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-004.png"/><!--<imagedata width="200px" format="png" fileref="bal2011john111004.png"/>--></imageobject></mediaobject></figure>
        <footnote><para>Remember that the relatives of a node are defined as the set of other nodes with the
            same start or end tag <emphasis role="ital">token</emphasis>. If there had been further
            nodes with tokens of the start tag &lt;b&gt; or the end tag &lt;/b&gt; in the lattice,
            they would still not have been relatives of &lt;b&gt;₃&lt;/b&gt;₅. In
            other words, we are still ignoring information derivable from GIs.</para></footnote>
      </para><para>L<subscript>1</subscript> looks like this:<figure xml:id="L1" xreflabel="Lattice L1"><title>Lattice L<subscript>1</subscript></title><para>&lt;a&gt;₁&lt;/a&gt;₉</para></figure>
      </para><para>As L<subscript>1</subscript> only contains the single node
        &lt;a&gt;₁&lt;/a&gt;₉ a repetition of the step above, which copies this
        minimal node to S<subscript>1</subscript> resulting in S<subscript>2</subscript>, will
        terminate the process. <footnote><para>The above process can be defined inductively using the functions
            <emphasis>min</emphasis> that selects the minimal nodes from a lattice, and
              <emphasis>rel</emphasis> which selects the relatives of its argument. Recall that the
            latter relation is reflexive, which means that rel(S) has S as a subset. The induction
            stops when <emphasis>L</emphasis><subscript>i</subscript> is empty. <variablelist><varlistentry><term>Base step for S:</term><listitem><para>S<subscript>0</subscript> =
                  <emphasis>min</emphasis>(<emphasis>L</emphasis>)</para></listitem></varlistentry><varlistentry><term>Base step for L:</term><listitem><para><emphasis> L<subscript>0</subscript></emphasis> = <emphasis>L</emphasis> -
                      rel(S<subscript>0</subscript>)</para></listitem></varlistentry><varlistentry><term>Induction step for S:</term><listitem><para>S<subscript>i+1</subscript> =
                        <emphasis>min</emphasis>(<emphasis>L<subscript>i</subscript></emphasis>)
                    ∪ S<subscript>i</subscript></para></listitem></varlistentry><varlistentry><term>Induction step for L:</term><listitem><para><emphasis>L<subscript>i+1</subscript></emphasis> =
                      <emphasis>L<subscript>i</subscript></emphasis> -
                    rel(D<subscript>i</subscript>) </para></listitem></varlistentry></variablelist>
          </para><para>This method bears a resemblance to cascaded finite state transducers, used in
            natural language processing <xref linkend="abney97"/>. A finite state transducer
            F, may scan a string over the symbols "(" and ")" replacing each occurrence of "()" (i.e
            the innermost, or minimal elements) with the empty string. Then repeat the process on
            the output (the cascading). When nothing is left, the process stops and the parentheses
            that are removed together can be taken to match. Even though the language over
            parentheses itself is context free, a cascaded approach using finite state transducers
            can in principle analyze it.</para></footnote> There are now no more nodes to select, and the process stops with the following
        candidate model M of D<subscript>1</subscript>: <figure xml:id="D2" xreflabel="Lattice D2"><title>subset S<subscript>2</subscript>=M(D<subscript>1</subscript>)</title><mediaobject><imageobject><imagedata width="310px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-005.png"/><!--<imagedata width="210px" format="png" fileref="bal2011john111005.png"/>--></imageobject></mediaobject></figure></para><para>What we find in S<subscript>2</subscript> is, mutatis mutandis, identical to the
        "standard" XML document tree for the document we started with: <figure xml:id="D3" xreflabel="Lattice D3"><title>Standard document model of D<subscript>1</subscript></title><mediaobject><imageobject><imagedata width="160px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-006.png"/><!--<imagedata width="110px" format="png" fileref="bal2011john111006.png"/>--></imageobject></mediaobject></figure>
      </para><para> While GIs have been left out of consideration during the building, the candidate model
        will also be subjected to a well-formedness check: <emphasis>For each node in the model, the
          GI of the start tag must be identical to the GI of the end tag.</emphasis>. For this
        model, this is the case. </para><para>We conclude that with the method described here, lattices can be used to generate
        "standard" models of XML documents in the form of conventional XML document trees. Recall
        that we may also refer to nodes that are members of the model as elements. The claim that these constitue trees will be
        substantiated below, where we will show that the model building procedure indeed
        guarantees production of tree structures only.</para></section><section><title>Modeling documents with overlap</title><para>In this section, we will show that lattices can also be used in order to generate models
        of O-XML documents in the form of GODDAGs [<xref linkend="Sperberg-McQueenandHuitfeldt2000"/>]. Consider the following O-XML sample document, D<subscript>2</subscript>: <figure><title>Sample document 2 (D<subscript>2</subscript>)</title><para>
            <code>&lt;a&gt;&lt;b&gt;X&lt;c&gt;Y&lt;/b&gt;Z&lt;/c&gt;&lt;/a&gt;</code>
          </para></figure>
      </para><para>The lattice L(D<subscript>2</subscript>) for this document is as follows (while we have used capital M
        to designate document models for XML documents, we will use capital O to designate document
        models for O-XML models): <figure xml:id="O" xreflabel="Lattice O"><title>Lattice L(D<subscript>2</subscript>)</title><mediaobject><imageobject><imagedata width="330px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-007.png"/><!--<imagedata width="230px" format="png" fileref="bal2011john111007.png"/>--></imageobject></mediaobject></figure>
      </para><para>An application of the method described in the previous section to this lattice, yields
        the following candidate model: <figure xml:id="P" xreflabel="Lattice P"><title>Candidate model of D<subscript>2</subscript>, M(D<subscript>2</subscript>)</title><mediaobject><imageobject><imagedata width="170px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-008.png"/><!--<imagedata width="120px" format="png" fileref="bal2011john111008.png"/>--></imageobject></mediaobject></figure>
      </para><para>It easy enough to see that something must have gone wrong here, as there is disagreement
        between the GIs of the start and end tags for the nodes &lt;b&gt;₂&lt;/c&gt;₈ and
        &lt;c&gt;₄&lt;/b&gt;₆. Now D<subscript>2</subscript> is not a well-formed XML document, and we have used the
        same procedure for generating M(D<subscript>2</subscript>) from D<subscript>2</subscript> (which is a well-formed O-XML document
        with overlap, but not a well-formed XML document) as we did for building M(D<subscript>1</subscript>) from
        D<subscript>1</subscript> (which is a well-formed XML document). The method will build document models for
        well-formed as well as ill-formed documents. However, the ill-formedness of D<subscript>2</subscript> will be
        captured by the well-formedness condition introduced above.</para><para>In constructing O(D<subscript>2</subscript>), it suffices to introduce one single modification to the
        procedure described in the previous section: Before performing any other operations on
        L(D<subscript>2</subscript>), we remove all nodes that have start and end tags with different GIs. Once
        this rule is introduced, the application of the procedure produces the following candidate
        model: <figure xml:id="Q" xreflabel="Lattice           Q"><title>Subset O(D<subscript>2</subscript>)</title><mediaobject><imageobject><imagedata width="280px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-009.png"/><!--<imagedata width="180px" format="png" fileref="bal2011john111009.png"/>--></imageobject></mediaobject></figure>
      </para><para>What we find here is, mutatis mutandis, identical to the GODDAG document model of the
        document: <figure xml:id="R" xreflabel="Lattice R"><title>GODDAG model of D<subscript>2</subscript></title><mediaobject><imageobject><imagedata width="270px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-010.png"/><!--<imagedata width="170px" format="png" fileref="bal2011john111010.png"/>--></imageobject></mediaobject></figure>
      </para><para>We conclude that with the method described here, lattices can also be used for
        generating document models of O-XML documents with overlap in the form of GODDAGs. Since the
        extra rule that we introduced in this section does not affect the result for XML documents,
        one and the same method can be used for generating XML trees from XML documents and GODDAGs
        from O-XML documents. In other words, if D is a well-formed XML document M(D)=O(D). However,
        O(D) does not have any built-in well-formedness check. </para></section><section><title>Well-formedness</title><para>In the previous section we noticed, in passing, that of the proposed method for building
        models from XML and O-XML documents, only M-models carry a well-formedness constraint. By
        introducing the rule that all nodes with different GIs on start and end tags should be
        deleted from the lattice, we effectively made sure that O(D) fulfills one well-formedness
        constraint on documents. The difference between the M- and O-constructions is subtle: The
        M-construction will always produce trees, while the O-construction will not necessarily
        produce trees. That issue is discussed in a subsequent section. The question to be asked
        here is: Can document lattices be used to capture the full set of well-formedness
        constraints? </para><para>The model building in itself may work even if document D starts with and end tag or ends
        with a start tag. The process will just ignore them. If they are taken into account as e.g.
        simples, the requirement that L(D) is a lattice will rule them out, since they will be
        ordered on the same level as the widest start tag/end tag pair. </para><para>Another source of ill-formedness stems from unbalanced parenthesis. For M(D) this is
        taken care of by requiring that the top node of L(D) is also the top node of M(D). The
        reason for this is that the top node of L(D) will be the widest start/end tag pair. If that
        pair is not a node it will be because all the tags are used up, so to speak, before it is
        reached, as the model building moves inside out. Consider this ill-formed document<blockquote><para>
            <code>&lt;a&gt;₁&lt;b&gt;₂&lt;/b&gt;₃</code>
          </para></blockquote> The top node for L(D) is <code>&lt;a&gt;₁&lt;/b&gt;₃</code>
        but this node will be removed from M(D) as a relative of the minimal
          <code>&lt;b&gt;₂&lt;/b&gt;₃</code>. </para><para>For O(D) this doesn't work since the removal process looks at tag GI, so if the document
        is this <blockquote><para>
            <code>&lt;a&gt;₁&lt;b&gt;₂&lt;/a&gt;₃</code>
          </para></blockquote> it is &lt;b&gt;₂&lt;/a&gt;₃ which is left out. So we cannot
        pin the requirement on the top node. However, we take it that for any document, including O-XML,
        that each tag should find a partner. Clearly &lt;b&gt;₂ in this document does
        not have one. </para><para>We conjecture that, in addition to the already introduced rule of deleting nodes with
        non-matching GIs on start and end tags, the following rule should suffice to capture all
        remaining well-formedness constraints on O-XML: </para><para> For any x.start or x.end in L(D) there must be an element E in M(D) or O(D) such that
        E.start=x.start or E.end=x.end.</para><para>This should make sure that every tag in L(D) finds a match in M(D) or O(D). Moreover, ff
        M(D) is constructed without first removing non macthin GIs, the GI agreement constraint
        mentioned above will rule out any overlap.</para><para>If this conjecture is correct, it means that checking for well-formedness as well as
        asignment of document structure can be accomplished by using document lattices, and without
        the use of rewrite grammars.</para></section><section><title>Concluding remarks</title><para>We believe that the proposed use of document lattices for building document models from
        marked up documents provides a unified account of the assignment of structure to documents
        with and without overlap. If our conjecture about well-formedness is correct, this account
        is also able to capture all well-formedness constraints on both types of markup.</para><para>The proposed method exploits the observations made about possible alternative
        conventions for the assignment of structure to simple parenthetical expressions made
        earlier. In building models for both kinds of documents, XML and O-XML, we rely on the
        "nesting" convention. The difference is that for XML documents, information about the GIs of
        tags may be ignored, whereas for O-XML documents this information is essential. </para><para>In introducing O-XML, we said that the only difference between XML and O-XML is that
        O-XML allows overlapping elements, whereas XML does not. What about so-called self-overlap,
        discontinuous elements and virtual elements, mechanisms which have been proposed in for
        example TexMECS, LMNL and other alternative markup languages? We believe that the handling
        of self-overlap with document lattices is just a question of adjusting the basic morphology.
        Whether, or to what extent, document lattices can also be used for markup languages with
        discontinuous or virtual elements we simply do not know.</para></section></section><section><title>Algebraic characterization</title><section><title>Meet and join</title><para>The meet and join operations are a central part of lattice theory. In our context, they
        may serve to characterize the difference between the models for XML and O-XML, and their
        relationship to the lattice L. </para><para> The meet operation selects the largest node below its operands, while join selects the
        smallest above its operands. A requirement for lattices is that any two nodes have a meet
        and a join. </para><para>Since we are dealing not primarily with lattices in the strict sense, but mostly with
        semi-lattices, we need to lighten this requirement for the meet operation: two nodes are
        allowed not to have any meet if they do not have any common nodes below them at all. </para><para>We indicate the vertical ordering of nodes in a lattice by using the symbols ⊒
        and ⊑, so that the opening is faced towards the larger node. In other words,
        x⊒y means that x is higher in the lattice than y, while x⊑y means that y
        is higher than x.</para><para>We can now define the meet operation, indicated by the operator ⊓, and the
        join operation, indicated by the operator ⊔, as follows: <variablelist><varlistentry><term>meet:</term><listitem><para>x⊓y=z iff, for all u, whenever u⊑x and u⊑y then
                u⊑z. </para></listitem></varlistentry><varlistentry><term>join:</term><listitem><para>x⊔y=z iff, for all u, whenever u⊒x and u⊒y then
                u⊒z. </para></listitem></varlistentry></variablelist>
      </para><para>The meet and join operations can also be characterized in terms of tag configurations.
        Let the start and end tag for a node x be written as x.start and x.end. The meet operation
        can be captured by saying that whenever z=x⊓y then z.start=max(x.start, y.start)
        and z.end=min(x.end,y.end). Similarly, the join operation can be captured by saying that
        whenever z=x⊔y then z.start=min(x.start,y.start) and z.end=max(x.end, y.end). <footnote><para> To see that this is so, consider first the case of ⊓. Any node that is
            below x must have a start tag occurring after or at x.start and an end tag at or before
            x.end, and similarly for any node below y. Thus, any node u, such that u⊑x and
            u⊑y, must satisfy that u.start ≥ x.start and that u.start ≥
            y.start, and both of u.end ≤ x.end and u.end ≤y.end. Consequently, any
            such u will therefore also satisfy u⊑z so z must be equal to x⊓y in
            accordance with the definition for ⊓. A similar argument can be applied to
            ⊔. As simples are minimal, they cannot have a meet, while their join will be
            discussed below.</para></footnote>
      </para></section><section><title>Are M(D) and O(D) lattices?</title><para>The first step of the method we have proposed consists in constructing, on the basis of
        a marked up document D, a lattice L(D). The construction method ensures that L(D) always is
        a lattice, i.e. that it has a unique largest node, that every pair of nodes has a join, and
        that every pair of non-minimal nodes has a meet. The document models, M(D) for XML documents
        and O(D) for O-XML documents, however, are derived from L(D) through a filtering process.
        Therefore, it is appropriate to ask whether M(D) and O(D) are also lattices, or not. </para><para>In this section we will argue that M(D) is not only guaranteed to be a lattice, it is
        also guaranteed to be a tree. O(D), however, is obviously not guaranteed to be a tree, but
        it is also not guaranteed to be a lattice.</para><para> We have earlier observed the similarity between the document model M(D) and XML trees.
        The following argument will show that this is necessarily the case for any model M(D). In
        XML, whenever both x.start&lt;y.start and y.start&lt;x.end is true, it is safe to conclude
        that y.end&lt;x.end (in other words, there is no overlap). This is also true for the
        relationships in M(D). </para><para> To see why, consider x and y, both elements of a model M(D), with the assumption that
        x.start&lt;y.start and y.start&lt;x.end. We want to show that it will always be the case
        that y.end&lt;x.end under these circumstances. So suppose for contradiction that this is not
        so, and that x.end&lt;y.end. Then there exists a node z=(y.start,x.end) in L(D), since
        y.start&lt;x.end (recall that L(D) contains all pairs of start tags followed by end tags).
        It is also clear that z is not a member of M(D). Further, from z's definition, we note that
        z is smaller than both x and y, and also a relative of both. This is enough to contradict
        the selection assumption for M(D): if z is smaller than x, then, since z=(y.start, x.end), z
        cannot have been removed in the model building process as a candidate for x, because any
        node is below all the relatives it removes, and by assumption z&lt;x . So z must then have
        been removed as candidate for M(D) considered as a relative of y. But this contradicts the
        assumption that z&lt;y, since y&lt;z for z to be removed. We can therefore conclude that
        assuming that x.end&lt;y.end is not tenable, and therefore that y.end&lt;x.end. This means
        that if ⊓ is confined to elements of M(D), u⊓v is either one of u or v (if it
        has a value at all); if u strictly comes after v, they would not share any nodes. A
        consequence of this is that any element x must have a unique parent (if it has one at all):
        if both u and v where distinct parents in M(D) (i.e. smallest nodes above x), x⊑u and
        x⊑v, which would mean that x⊑u⊓v=u (or v). We can therefore conclude that
        M(D) is a tree. </para><para> The above argument does not hold for O(D) which models overlap structures. The example
        GODDAG in <xref linkend="R"/> shows that the structure is not a tree, as the simple Y has
        two parents. Also, the join may be undefined when restricted to O(D) (that is, redefined
        within O(D) and not computed within L(D)). In O(D) two elemnts do not necessarily have a
        unique smallest dominating element, even if there are elements above them. For example, two
        elements x and y may be dominated by elementss a and b, and neither of these dominate the
        other if they overlap. In this example it is therefore impossible to select a smallest
        dominating element to serve as the join of x and y. </para></section><section><title>Closure</title><para> In this section and the ones that follow, we will look at the differences between O-
        and M-models in terms of meet and join. This also brings us to regard M(D) and O(D) as
        subsets of L(D), and consider ways of adding nodes to them in order to make them satisfy
        certain requirements. </para><para> When M(D) and O(D) are seen as subsets of L(D), with meet and join computed in L(D),
        there are a number of differences between them that were not captured above, when we limited
        ourselves to look at their structures only. Our first question is whether the meet and join
        operations are closed in M(D) and O(D). (An operation is closed in a subset A if the result
        of the operation stays in A when operating on elements of A.) </para><para>One defining difference between O(D) and M(D) in terms of closure is that while the meet
        operation is closed in M(D), it is not in O(D). As we saw above, given two elements x and y
        in M(D), their meet is either x or y, which is still in M(D). If u and v in O(D) are
        distinct and overlapping, which means that u.start&lt;v.start while u.end&lt;v.end, their
        meet is w=(v.start,u.end), which is not an element of O(D). (It is a node in L(D), but since
        it is a relative of both u and v, it is not a member of O(D)). </para><para>The join operation will not always be closed, neither in M(D) nor in O(D). If x precedes
        y with both tags of x before y.start, their join is (x.start,y.end). This node cannot be any
        element neither of M(D) nor of O(D), since it is a relative of both x and y, but not
        identical to any of them. </para><para>An observation concerning M(D) is that there are nested documents that are closed under
        both join and meet. Documents where no node precedes another are of that type, like for
        example <code>&lt;r&gt;&lt;a&gt;X&lt;/a&gt;&lt;r&gt;</code>. In a document like this, where ⊑ is a
        total order, it is the case that if x⊔y=x then x⊓y=y and vice versa. A
        document with overlap will in general leak into L(D) for both meet and join.</para><para>Consider D<subscript>2</subscript> from the previous section. The lattice L(D<subscript>2</subscript>) may be used to
        represent M(D<subscript>2</subscript>) as well as O(D<subscript>2</subscript>). D<subscript>2</subscript> is an O-XML document with overlap, so
        M(D<subscript>2</subscript>) will be ill-formed, but that is not of relevance at this point; M(D<subscript>2</subscript>) will
        simply exhibit the nested view of the document. In the figure below, showing the lattice
        L(<subscript>2</subscript>), the elements of M(D<subscript>2</subscript>) are indicated with a ✓, while the elements of
        O(D<subscript>2</subscript>) are indicated with a ✗; the simples are members of both models. <figure xml:id="OMD2" xreflabel="Lattice OMD2"><title>L(D<subscript>2</subscript>) with subsets ✓M(D<subscript>2</subscript>) and ✗O(D<subscript>2</subscript>)</title><mediaobject><imageobject><imagedata width="330px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-011.png"/><!--<imagedata width="230px" format="png" fileref="bal2011john111011.png"/>--></imageobject></mediaobject></figure>
      </para><para>We write M(D)* for the closure of M(D). It is obtained by collecting all nodes
        x⊓y and x⊔y in L(D) where x, y are elements of M(D), with recombinations.
        Similarly, we write O(D)* for the closure of O(D). The new nodes that are added in this way
        are called semi-elements, distinct from the elements of M(D) or O(D).</para><para>Here is what the O-XML document D<subscript>2</subscript> with overlap looks like with semi-elements
        added. The semi-elements are indicated with a check mark, ✓. Note that the
        semi-elements are precisely the candidate elements for M(D<subscript>2</subscript>), an observation we return
        to below.<figure xml:id="oOMD2" xreflabel="Lattice oOMD2"><title>O(D<subscript>2</subscript>)* with semi-elements check marked.</title><mediaobject><imageobject><imagedata width="277px" format="png" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-012.png"/><!--<imagedata width="177px" format="png" fileref="bal2011john111012.png"/>--></imageobject></mediaobject></figure>
      </para><para> The semi-elements are considered nameless, they may be annotated with an algebraic
        formula having that node as value. <figure xml:id="oOMD2s" xreflabel="Lattice oOMD2s"><title>O(D<subscript>2</subscript>)* </title><mediaobject><imageobject><imagedata width="222px" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-013.png"/><!--<imagedata width="172px" fileref="bal2011john111013.png"/>--></imageobject></mediaobject></figure>
      </para><para> The reader may check that the above diagram represents the closure of O(D<subscript>2</subscript>). Here
        are all possible combinations alongside their value, not including combinations involving
        elements x and y such that x≤y. <table><caption><para>All possible meet and join combinations for O(D<subscript>2</subscript>)</para></caption><col align="left" span="1"/><tr><td>X₃⊔Y₅ = b = &lt;b&gt;₂&lt;/b&gt;₆</td></tr><tr><td>X₃⊔Z₇ = b⊔c = &lt;b&gt;₂&lt;/c&gt;₈</td></tr><tr><td>Z₇⊔Y₅ = c = &lt;c&gt;₄&lt;/c&gt;₈</td></tr><tr><td>b⊓c = &lt;c&gt;₄&lt;/b&gt;₆</td></tr></table>
      </para><para> It was noted above that M(D<subscript>2</subscript>) was a subset of O(D<subscript>2</subscript>)*. We want to demonstrate
        that it holds for any document D that M(D) is a subset of O(D)*, even though M(D) and O(D)
        need only have the top element in common. The converse does not hold. A consequence of this
        is that O-XML documents with overlap cannot be reached from algebraic manipulations on M(D),
        but that the corresponding XML document without overlap can be reached from O(D)*.</para><para> For this to make sense, D must be a well-formed overlapping O-XML document. If D has no
        overlap, it will also be a well-formed XML document for which we have already established
        that O(D)=M(D). Hence, in that case M(D) will automatically be a subset of O(D)* (=M(D)*).
        Further, we take it without argument that if O(D) contains an element x that does not
        overlap with any other element y in O(D), x will also be a member of M(D). It doesn't matter
        if x contains, or is contained, in an overlap configuration as long x does not itself
        overlap with another element. To illustrate, the a and b elements of the following document
        D<subscript>4</subscript> will be elements of both M(D<subscript>4</subscript>) and O(D<subscript>4</subscript>), even though c and d overlaps.
        The latter two will obviously not be members of M(D<subscript>4</subscript>):
        <programlisting xml:space="preserve">&lt;a&gt;&lt;d&gt;X&lt;c&gt;&lt;b&gt;Y&lt;/b&gt;&lt;/d&gt;Z&lt;/c&gt;&lt;/a&gt;</programlisting> In
        addition to the simples, the elements of M(D<subscript>4</subscript>) will be these (token indexes are skipped
        since the GIs serve to uniquely identify token tags), where the linear order of the elements
        also reflects the hierarchical order:
        <programlisting xml:space="preserve">(&lt;a&gt;,&lt;/a&gt;) (&lt;d&gt;,&lt;/c&gt;) (&lt;c&gt;,&lt;/d&gt;) (&lt;b&gt;,&lt;/b&gt;)</programlisting>
        So the odd elements here, which are not elements of O(D<subscript>4</subscript>), are these two
        <programlisting xml:space="preserve">(&lt;d&gt;,&lt;/c&gt;) (&lt;c&gt;,&lt;/d&gt;)</programlisting> It can be seen that these
        two nodes are semi-elements of O(D<subscript>4</subscript>)* given the equations <programlisting xml:space="preserve">(&lt;d&gt;,&lt;/c&gt;)=(&lt;d&gt;,&lt;/d&gt;)⊔(&lt;c&gt;,&lt;/c&gt;)</programlisting>
        <programlisting xml:space="preserve">(&lt;c&gt;,&lt;/d&gt;)=(&lt;d&gt;,&lt;/d&gt;)⊓(&lt;c&gt;,&lt;/c&gt;)</programlisting>
      </para><para>The above equations hold also in the general case. Consider an O-XML document D, and an
        element m in M(D), so m may possibly not have matching tags. Then it will be the case that either m
        is in O(D), or else there will be elements in O(D) so that m is their join, their meet or a
        combination of join and meet. To see this, note that m will either be well-formed according
        to XML (checked through the GI-identity constraint) or it will not, but still well-formed
        according to O-XML. So it is like either <code>(&lt;a&gt;,&lt;/a&gt;)</code> or
          <code>(&lt;d&gt;,&lt;/c&gt;)</code> of M(D<subscript>4</subscript>). If m is a member of O(D), it will also be in
        O(D)*. So consider the case where m is not an element in O(D). Then there must be distinct
        elements a and b in O(D) so that a.start=m.start and b.end=m.end, this because of the
        constraint which says all tag tokens must be part of an element. Now there are three cases
        to consider: <orderedlist><listitem><para>a.start&lt;b.start and a.end&lt;b.end (this subsumes overlap and
              sequencing)</para></listitem><listitem><para>b.start&lt;a.start and b.end&lt;a.end (overlap only)</para></listitem><listitem><para>a.start&lt;b.start and b.end&lt;a.end (nesting)</para></listitem></orderedlist>
      </para><para> In the first case m=a⊔b, while in the second, m=a⊓b, parallel to the case
        for D<subscript>4</subscript>.The third case, the nesting case is a bit trickier. The tag configuration for a and
        b is now <programlisting xml:space="preserve">...&lt;a&gt;...&lt;b&gt;....&lt;/b&gt;...</programlisting> where
          m=<code>(&lt;a&gt;,&lt;/b&gt;</code>), another way of stating that m=(a.start, b.end). Recall
        that the M-models are constructed without looking at GIs, so for m to be an element of M(D),
        all the tags between a.start(=m.start) and b.end(=m.end) must match up. In particular there
        must be an equal number of start tags and end tags between a.start and b.end. Since we
        already have b.start in there, we know there must be at least one extra end tag between
        a.start and b.end. That end tag must be matched in O(D) by a start tag outside of the
        (a.start, b.end) configuration. Which means that there must be an element c of O(D) such
        that c.end is between a.start and b.end and such that c.start is outside of the pair, that
        is c.start&lt;a.start. Now m can be written on the form m=a⊓c⊔b, and so is a
        semi-element of O(D)*. <footnote><para>Note in passing that there must be an end tag positioned between b.start and b.end.
            This is so because m as a member of M(D) do not allow overlap, and with b.start between
            its start and end tags, b.start must match up with a tag in M(D) that comes before b.end
            itself. If c does not serve this purpose, there will be additional tags between a.start
            and b.end</para></footnote> </para><para>This result, that M(D) is a subset of O(D)*, but not vice versa, pinpoints an asymmetry
        between overlapping and nesting documents. Nested documents can be recovered, so to speak,
        from overlapping documents, but there are overlapping documents that cannot be described
        algebraicly in terms of nested documents. </para></section><section><title>Spurious overlap</title><para>Closure models may be help in representing certain cases so-called spurious overlap as discussed in [<xref linkend="HuitfeldtandSperberg-McQueen2003"/>]. Roughly, spurious overlap occurs
        whenever two elements a and b overlap, and there is no PCDATA either between the two start
        tags, or between the two end tags, or between the start tag of a and the end tag of b. The
        following O-XML document D<subscript>3</subscript> may illustrate. <blockquote><para>
            <code>&lt;a&gt;&lt;b&gt;X&lt;c&gt;&lt;/b&gt;Y&lt;/c&gt;&lt;a&gt;</code>
          </para></blockquote> Its document model is this <figure xml:id="MD3" xreflabel="Spurious           model"><title>O(D<subscript>3</subscript>)</title><mediaobject><imageobject><imagedata width="200px" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-014.png"/><!--<imagedata width="150px" fileref="bal2011john111014.png"/>--></imageobject></mediaobject></figure>
      </para><para> Except for token indexes, it is identical to the document model for the following
        XML document: <blockquote><para>
            <code>&lt;a&gt;&lt;b&gt;X&lt;/b&gt;&lt;c&gt;Y&lt;/c&gt;&lt;a&gt;</code>
          </para></blockquote> The closures of the two document models are slightly different, though. The
        document with spurious overlap has this closure: <figure xml:id="SCD3" xreflabel="Spurious           closure"><title>O(D<subscript>3</subscript>)*</title><mediaobject><imageobject><imagedata width="200px" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-015.png"/><!--<imagedata width="150px" fileref="bal2011john111015.png"/>--></imageobject></mediaobject></figure> while the document without overlap has this closure:<figure xml:id="CD3" xreflabel="Nested             closure"><title>M(D<subscript>3</subscript>a)*</title><mediaobject><imageobject><imagedata width="200px" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-016.png"/><!--<imagedata width="150px" fileref="bal2011john111016.png"/>--></imageobject></mediaobject></figure>
      </para><para> This may serve to illustrate the close relationship between the lattice model and the
        serial form of the marked up document. By the use of closure models with semi-elements,
        documents with spurious overlap can be distinguished from other documents which share the
        same document model.</para></section></section><section><title>Conclusion</title><para> We have described a method for building lattices from marked up documents with and
      without overlap, and for generating, from these lattices, document models in the form of trees
      for XML documents, and in the form of GODDAGs for documents with overlap. We have shown that
      one and the same method can be used for generating both kinds of models, and we have given
      reasons to believe that lattices can also be used to implement well-formedness constraints for
      both kinds of documents. In this sense, this is also a step away from relying on context free
      grammars and the like in analyzing documents. As presented here, model building is kept
      separate from grammar, but we leave open the question of how this bears on document
      validation. </para><para>We have discussed and compared some of the algebraic features of the document models and
      the relations between them, and pointed out some interesting results. For example, that the
      algebraic operations provide a link between nested documents and overlapping documents. The
      former can be computed by algebraic means from the latter, but not the other way around. We
      have also disussed how the algebraically closed models can be used to distinguish models of
      spurious overlap from nested models, via the introduction of semi-elements.</para><para> Therefore, although many of the details in the work presented here probably are in need
      of correction and revision, we believe that the application of lattices to marked up documents
      may provide a unified account of markup languages with and without overlap.</para></section><section><title>Appendix</title><para>In the section called "Bracketed notations and matching" we defined the grammar P. We will
      formally prove that any two parentheses (a left then a right) can be added to a well-formed
      parenthetical expression according to this grammar, while preserving well-formedness. We start
      with the following lemma </para><para>
      <emphasis role="bold">Lemma on string splitting</emphasis>
    </para><para>Let the string <code>S</code> over left and right parentheses be derived according to P,
      and decomposed into <code>S=XYZ</code>. Then <code>X</code>, <code>Y</code> and <code>Z</code>
      can be reduced, by removing non-terminal Ps
      from each of them into <code>X'</code>, <code>Y'</code>, and <code>Z'</code>, such that 
      <code>X'=(<superscript>n</superscript></code> and
          <code>Y'=)<superscript>m</superscript>(<superscript>p</superscript></code> and
          <code>Z'=)<superscript>q</superscript></code>, so that <code>S'</code> is well-formed. </para><para>Proof: Since <code>X</code> is the leftmost string of <code>S</code>, any right
      parenthesis, <code>)</code>, in <code>X</code> must occur in the pattern <code>(p)</code>, and
      such a pattern can safely be removed without destroying the well-formedness of the expression.
      Thus, <code>X</code> will in the end be reduced to <code>X'</code> as a consecutive string of
      left parentheses. A parallel argument goes for <code>Z</code> and its reduction to
      <code>Z'</code> as a string of right parentheses. For <code>Y</code> the story is a bit
      different, since a left or right parenthesis may be generated with a corresponding parenthesis
      in <code>X</code> or <code>Z</code>. However, we can safely conclude that if all
      <code>P</code>s are removed from Y, then there can be no string of the form <code>(W)</code>
      in <code>Y</code>, since either <code>)</code> is derived with a corresponding <code>(</code>
      in <code>W</code>, or <code>(</code> is derived with a corresponding <code>)</code> in
      <code>W</code>. Thus, Y' must be a string of <code>)</code>'s followed by <code>(</code>'s.
      Since removing a <code>P</code> from a well-formed string won't affect its well-formedness,
      the string <code>S'=X'Y'Z'</code> is well-formed.</para><para> This lemma will be used to show that any pair of left and right parentheses can be
      inserted into a well-formed string without affecting its well-formedness. </para><para>
      <emphasis role="bold">Well-formedness of additional parentheses</emphasis>
    </para><para>Let the string S be a well-formed parenthetical expression according to P. Inserting a
      left parenthesis anywhere in <code>S</code> followed by a right parenthesis anywhere after the
      left, will result in a well-formed string according to <code>P</code>.</para><para>Proof: Split the string <code>S</code> into three substrings <code>XYZ</code> at the
      positions where ( and ) are to be inserted, so that The new string is </para><blockquote><para>
        <code>S<subscript>1</subscript>=X(Y)Z.</code>
      </para></blockquote><para> Now according to lemma, X Y and Z can be reduced and re-concatenated into the well-formed
      expression</para><blockquote><para>
        <code>
            (<superscript>n</superscript>)<superscript>m</superscript>(<superscript>p</superscript>)<superscript>q</superscript>
        </code>
      </para></blockquote><para> Inserting the new left-( and right-) into their respective positions, results in <blockquote><para>
          <code>
              (<superscript>n</superscript>()<superscript>m</superscript>(<superscript>p</superscript>))<superscript>q</superscript>
          </code>
        </para></blockquote> Now, all that is left to do is just to shift the superscripts to the right and
      left; this expression can be written as <blockquote><para>
          <code>
              ((<superscript>n</superscript>)<superscript>m</superscript>(<superscript>p</superscript>)<superscript>q</superscript>)
          </code>
        </para></blockquote>
    </para><para> But this is just the expression <code>(X'Y'Z')</code>, and since the <code>X'Y'Z'</code>,
      can be reduced to a sequence of <code>Ps</code>, <!-- a sequence of peas? --> the resulting
      expression is also well-formed, being then on the form <code>(P*)</code>. </para><para> This proposition guarantees that the intended matching of the parentheses is of no
      concern to the well-formedness of the expression. </para></section><bibliography><title>References</title><bibliomixed xml:id="abney97" xreflabel="Abney 1997">Abney, Steven, <quote>Partial Parsing via
        Finite-State Cascades</quote>. <emphasis role="ital">Journal of Natural Language Engineering
        2:337-344.</emphasis></bibliomixed><bibliomixed xml:id="Barnardetal.1988" xreflabel="Barnard et al. 1988">Barnard, David, Ron
      Hayter, Maria Karababa, George Logan, and John McFadden, <quote>SGML-based markup for literary
        texts: Two problems and some solutions</quote>, <emphasis role="ital">Computers and the
        Humanities</emphasis>, 22: 265-276. <link xlink:href="http://www.springerlink.com/content/r1p6t63627663436/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.springerlink.com/content/r1p6t63627663436/</link></bibliomixed><bibliomixed xml:id="Barnardetal.1995" xreflabel="Barnard et al. 1995">Barnard, David; Burnard,
      Lou; Gaspart, Jean-Pierre; Price, Lynne A.; Sperberg-McQueen, C. M.; Varile, Giovanni
      Battista, <quote>Hierarchical Encoding of Text: Technical Problems and SGML Solutions</quote>,
        <emphasis role="ital">Computers and the Humanities</emphasis>, The Text Encoding Initiative:
      Background and Contents, Guest Editors Nancy Ide and Jean Vèronis, 29/3, 211-231. <link xlink:href="http://www.springerlink.com/content/p7775247276v88h3/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.springerlink.com/content/p7775247276v88h3/</link></bibliomixed><bibliomixed xml:id="Bauman2005" xreflabel="Bauman 2005">Bauman, Syd, <quote>TEI HORSEing
        around</quote>, <emphasis role="ital">Proceedings of Extreme Markup Languages®</emphasis>.
        <link xlink:href="http://conferences.idealliance.org/extreme/html/2005/Bauman01/EML2005Bauman01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2005/Bauman01/EML2005Bauman01.html</link></bibliomixed><bibliomixed xml:id="Carlettaetal.2005" xreflabel="Carletta et al. 2005">Carletta, J.; S. Evert;
      U. Heid; and J. Kilgour, <quote>The NITE XML Toolkit: data model and query</quote>, <emphasis role="ital">Language Resources and Evaluation</emphasis>, 39.4: 313-334. <link xlink:href="http://www.springerlink.com/content/j37h2p15u682075g/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.springerlink.com/content/j37h2p15u682075g/</link></bibliomixed><bibliomixed xml:id="Chattietal.2007" xreflabel="Chatti et al. 2007">Chatti, Noureddine; Suha
      Kaouk; Sylvie Calabretto; and Jean Marie Pinon, <quote>MultiX: an XML-based formalism to
        encode multi-structured documents</quote>, <emphasis role="ital">Proceedings of Extreme
        Markup Languages</emphasis>. <link xlink:href="http://conferences.idealliance.org/extreme/html/2007/Chatti01/EML2007Chatti01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2007/Chatti01/EML2007Chatti01.html</link></bibliomixed><bibliomixed xml:id="DeRose2004" xreflabel="DeRose 2004">DeRose, Steven J., <quote>Markup
        overlap: A review and a horse</quote>, <emphasis role="ital">Proceedings of Extreme Markup
        Languages®</emphasis>. <link xlink:href="http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html</link></bibliomixed><bibliomixed xml:id="DiIorioetal.2009" xreflabel="Di Iorio et al. 2009">Di Iorio, Angelo; Silvio
      Peroni; and Fabio Vitali, <quote>Towards markup support for full GODDAGs and beyond: the
        EARMARK approach</quote>, <emphasis role="ital">Balisage Series on Markup
        Technologies</emphasis>, vol. 3. <link xlink:href="http://www.balisage.net/Proceedings/vol3/html/Peroni01/BalisageVol3-Peroni01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol3/html/Peroni01/BalisageVol3-Peroni01.html</link></bibliomixed><bibliomixed xml:id="Goldfarb1990" xreflabel="Goldfarb 1990">Charles F. Goldfarb, <emphasis role="ital">The SGML Handbook</emphasis>, Clandon Press, Oxford. </bibliomixed><bibliomixed xml:id="Grätzer1971" xreflabel="Grätser 1971">Gråtser, George, <emphasis role="ital">Lattice Theory, first concepts and distributive lattices</emphasis> San
      Fransisco, Calif., 1971. xv+212 pp. Softcover edition, Dover Publications, 2009. <link xlink:href="http://server.maths.umanitoba.ca/homepages/gratzer.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://server.maths.umanitoba.ca/homepages/gratzer.html</link>
    </bibliomixed><bibliomixed xml:id="Hilbertetal.2005" xreflabel="Hilbert et al. 2005">Hilbert, Mirco; Oliver
      Schonefeld; and Andreas Witt, <quote>Making CONCUR work</quote>, <emphasis role="ital">Proceedings of Extreme Markup Languages®</emphasis>. <link xlink:href="http://conferences.idealliance.org/extreme/html/2005/Witt01/EML2005Witt01.xml" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2005/Witt01/EML2005Witt01.xml</link></bibliomixed><bibliomixed xml:id="Huitfeldt1998" xreflabel="Huitfeldt 1998">Huitfeldt C, <quote>MECS - A
        Multi-Element Code System</quote>, <emphasis role="ital">Working Papers from the
        Wittgenstein Archives at the University of Bergen</emphasis>, No 3, Version October 1998.
        <link xlink:href="http://helmer.aksis.uib.no/claus/mecs/mecs.htm" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://helmer.aksis.uib.no/claus/mecs/mecs.htm</link></bibliomixed><bibliomixed xml:id="HuitfeldtandSperberg-McQueen2003" xreflabel="Huitfeldt and Sperberg-McQueen       2003">Huitfeldt, Claus; and C. M.
      Sperberg-McQueen, <quote>TexMECS: An experimental markup meta-language for complex
        documents</quote>, <emphasis role="ital">Working paper of the project Markup Languages for
        Complex Documents (MLCD)</emphasis>, University of Bergen. <link xlink:href="http://decentius.aksis.uib.no/mlcd/2003/Papers/texmecs.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://decentius.aksis.uib.no/mlcd/2003/Papers/texmecs.html</link></bibliomixed><bibliomixed xml:id="Jagadishetal.2004" xreflabel="Jagadish et al. 2004">Jagadish, H.V.; Laks V.
      S. Lakshmanan; Monica Scannapieco; Divesh Srivastava; and Nuwee Wiwatwattana, <quote>Colorful
        XML: one hierarchy isn't enough</quote>, <emphasis role="ital">Proceedings of the 2004 ACM
        SIGMOD international conference on Management of data</emphasis>, Paris, France: 251-262.
        <link xlink:href="http://doi.acm.org/10.1145/1007568.1007598" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://doi.acm.org/10.1145/1007568.1007598</link></bibliomixed><bibliomixed xml:id="Marcoux2008">Marcoux, Yves. <quote>Graph characterization of overlap-only
        TexMECS and other overlapping markup formalisms.</quote> Presented at Balisage: The Markup
      Conference 2008, Montréal, Canada, August 12 - 15, 2008. In <emphasis role="ital">Proceedings
        of Balisage: The Markup Conference 2008. Balisage Series on Markup Technologies</emphasis>,
      vol. 1 (2008). doi:10.4242/BalisageVol1.Marcoux01. <link xlink:href="http://balisage.net/Proceedings/vol1/html/Marcoux01/BalisageVol1-Marcoux01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://balisage.net/Proceedings/vol1/html/Marcoux01/BalisageVol1-Marcoux01.html</link>
    </bibliomixed><bibliomixed xml:id="Marinellietal.2008" xreflabel="Marinelli et al. 2008">Marinelli, P.,
      Vitali, F., Zacchiroli, S., <quote>Towards the unification of formats for overlapping
        markup</quote>, <emphasis role="ital">The New Review of Hypermedia and
      Multimedia</emphasis>. <link xlink:href="http://www.informaworld.com/smpp/ftinterface~content=a903040611~fulltext=713240930" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.informaworld.com/smpp/ftinterface~content=a903040611~fulltext=713240930</link></bibliomixed><bibliomixed xml:id="Nicol2002a" xreflabel="Nicol 2002a">Nicol, Gavin, <quote>Core range
        algebra: Toward a formal theory of markup</quote>, <emphasis role="ital">Extreme Markup
        Languages</emphasis>. <link xlink:href="http://www.mind-to-mind.com/library/papers/ara/core-range-algebra-03-2002.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.mind-to-mind.com/library/papers/ara/core-range-algebra-03-2002.html</link></bibliomixed><bibliomixed xml:id="Nicol2002b" xreflabel="Nicol 2002b">Gavin Nicol, <quote>Attributed range
        algebra: Extending core range algebra to arbitrary structures</quote>, <emphasis role="ital"/>. <link xlink:href="http://www.mind-to-mind.com/library/papers/ara/attributed-range-algebra-07-2002.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.mind-to-mind.com/library/papers/ara/attributed-range-algebra-07-2002.pdf</link></bibliomixed><bibliomixed xml:id="Raymondetal1992" xreflabel="Raymond et al. 1992"> Raymond, Darrell R;
      Tompa, Frank William, and Wood, Derick: <quote>Markup Reconsidered</quote>. University of
      Western Ontario. <link xlink:href="www.cs.uwaterloo.ca/~fwtompa/.papers/markup.ps" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">www.cs.uwaterloo.ca/~fwtompa/.papers/markup.ps</link></bibliomixed><bibliomixed xml:id="Raymondetal1995" xreflabel="Raymond et al. 1995"> Raymond, Darrell R;
      Tompa, Frank William, and Wood, Derick: <quote>From Data Representation to Data Model:
        Meta-Semantic Issues in the Evlution of SGML.</quote>
      <link xlink:href="http://reference.kfupm.edu.sa/content/f/r/from_data_representation_to_data_model___1594703.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://reference.kfupm.edu.sa/content/f/r/from_data_representation_to_data_model___1594703.pdf</link>
    </bibliomixed><bibliomixed xml:id="SchonefeldandWitt2006" xreflabel="Schonefeld and Witt 2006">Schonefeld,
      Oliver, and Andreas Witt, <quote>Towards validation of concurrent markup</quote>, <emphasis role="ital">Proceedings of Extreme Markup Languages®</emphasis>, . <link xlink:href="http://conferences.idealliance.org/extreme/html/2006/Schonefeld01/EML2006Schonefeld01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2006/Schonefeld01/EML2006Schonefeld01.html</link></bibliomixed><bibliomixed xml:id="Schonefeld2007" xreflabel="Schonefeld 2007">Schonefeld, Oliver Georg Rehm,
      Andreas Witt, Lothar Lemnitzer (eds.), <quote>XCONCUR and XCONCUR-CL: A constraint-based
        approach for the validation of concurrent markup</quote>, <emphasis role="ital">Datenstrukturen für linguistische Ressourcen und ihre Anwendungen / Data structures for
        linguistic resources and applications: Proceedings of the Biennial GLDV Conference
        2007</emphasis>, Tübingen: Gunter Narr Verlag. Pp. 347-356. <link xlink:href="" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"/></bibliomixed><bibliomixed xml:id="SchmidtandColomb2009" xreflabel="Schmidt and Colomb 2009">Schmidt, D.,
      Colomb, R., <quote>A data structure for representing multi-version texts online</quote>,
        <emphasis role="ital">International Journal of Human-Computer Studies</emphasis>, . <link xlink:href="http://portal.acm.org/citation.cfm?id=1523966" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://portal.acm.org/citation.cfm?id=1523966</link></bibliomixed><bibliomixed xml:id="Sperberg-McQueenandHuitfeldt2000" xreflabel="Sperberg-McQueen and Huitfeldt       2000">Sperberg-McQueen, C. M., and Claus
      Huitfeldt Peter R. King and Ethan V. Munson (eds.), <quote>GODDAG: A Data Structure for
        Overlapping Hierarchies</quote>, <emphasis role="ital">Digital documents: systems and
        principles. Lecture Notes in Computer Science 2023</emphasis>, Berlin: Springer, 2004, pp.
      139-160. Paper given at Digital Documents: Systems and Principles. 8th International
      Conference on Digital Documents and Electronic Publishing, DDEP 2000, 5th International
      Workshop on the Principles of Digital Document Processing, PODDP 2000, Munich, Germany,
      September 13-15, 2000.. <link xlink:href="http://www.w3.org/People/cmsmcq/2000/poddp2000.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/People/cmsmcq/2000/poddp2000.html</link></bibliomixed><bibliomixed xml:id="StührenbergandJettka2009" xreflabel="Stührenberg and Jettka 2009">Stührenberg, Maik; and Daniel Jettka, <quote>A toolkit for multi-dimensional markup: The
        development of SGF to XStandoff</quote>, <emphasis role="ital">Proceedings of Balisage: The
        Markup Conference 2009. Balisage Series on Markup Technologies</emphasis>, Vol. 3. <link xlink:href="http://www.balisage.net/Proceedings/vol3/html/Stuhrenberg01/BalisageVol3-Stuhrenberg01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol3/html/Stuhrenberg01/BalisageVol3-Stuhrenberg01.html</link></bibliomixed><bibliomixed xml:id="TEIP5" xreflabel="TEI P5">Lou Burnard and Syd Bauman (eds.),
        <quote>Non-hierarchical Structures</quote>, <emphasis role="ital">Guidelines for the
        Encoding and Interchange of Machine-Readable Texts (TEI P5)</emphasis>, The TEI Consortium.
        <link xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/NH.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/NH.html</link></bibliomixed><bibliomixed xml:id="TennisonandPiez2002" xreflabel="Tennison and Piez 2002">Tennison, J. and W.
      Piez, <quote>The Layered Markup and Annotation Language (LMNL)</quote>, <emphasis role="ital">Proceedings of Extreme Markup Languages®</emphasis>. <link xlink:href="http://www.idealliance.org/papers/extreme/proceedings/author-pkg/2002/Tennison02/EML2002Tennison02.zip" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.idealliance.org/papers/extreme/proceedings/author-pkg/2002/Tennison02/EML2002Tennison02.zip</link></bibliomixed><bibliomixed xml:id="Witt2005" xreflabel="Witt 2005">Andreas Witt Stefanie Dipper, Michael
      Götze, and Manfred Stede (eds.), <quote>Multiple Hierarchies: New Aspects of an Old
        Solution</quote>, <emphasis role="ital">Heterogeneity in Focus: Creating and and Using
        Linguistic Databases</emphasis>, volume 2 of Interdisciplinary Studies on Information
      Structure (ISIS), Working Papers of the SFB 632. University of Potsdam, Germany. (Corrected
      reprint of an Extreme Markup 2004 paper). <link xlink:href="http://en.scientificcommons.org/42597903" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://en.scientificcommons.org/42597903</link></bibliomixed></bibliography></article>