<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>Document lattices:</title><subtitle>Equivalence, compatibility, and contradiction in document markup</subtitle><info><confgroup><conftitle>Balisage: The Markup Conference 2014</conftitle><confdates>August 5 - 8, 2014</confdates></confgroup><abstract><para>If the information conveyed by the markup in a document
      can be identified with the set of inferences we can draw from
      that markup, as has been proposed in earlier work, then the sets
      of inferences licensed by documents form an infinitely large
      lattice, by means of which the relative information content of
      any two documents (equivalence, subsumption, contradiction,
      consistency) can be displayed visually.  The sets of inferences
      licensed by markup can be used to test translations from one
      markup language to another for equivalence or information loss;
      a simple example using XHTML and CALS table markup illustrates
      the process.
    </para></abstract><author><personname><firstname>C. M.</firstname><surname>Sperberg-McQueen</surname></personname><personblurb><para>C. M. Sperberg-McQueen is the founder and 
	principal of Black Mesa Technologies, a consultancy
	specializing in helping memory institutions improve
	the long term preservation of and access to the
	information for which they are responsible.</para><para>He served as editor in chief of the TEI
	Guidelines from 1988 to 2000, and has also served
	as co-editor of the World Wide Web Consortium's 
	XML 1.0 and XML Schema 1.1
	specifications.
	</para></personblurb><affiliation><jobtitle>Founder and principal</jobtitle><orgname>Black Mesa Technologies LLC</orgname></affiliation></author><author><personname><firstname>Yves Marcoux</firstname><surname>Yves Marcoux</surname></personname><personblurb><para>Yves Marcoux has been a faculty member at EBSI, 
	University of Montréal, since 1991. 
	He is mainly involved in teaching, research, standardization, 
	and international cooperation activities 
	in the field of document informatics. 
	Prior to his appointment at EBSI, 
	Dr. Marcoux worked for 10 years
	in systems maintenance and development, 
	in Canada, the U.S., and Europe. 
	He obtained his Ph.D. in theoretical computer science 
	from Université de Montréal in 1991. 
	His main research interests are intertextual semantics, 
	the design of communication, markup languages 
	and digital humanities.</para></personblurb><affiliation><jobtitle>Associate Professor (Professeur agrégé)</jobtitle><orgname>École de bibliothéconomie et des
	sciences de l'information, Université de Montréal</orgname></affiliation></author><author><personname><firstname>Claus</firstname><surname>Huitfeldt</surname></personname><personblurb><para>Claus Huitfeldt is Associate Professor at the Department
	of Philosophy of the University of Bergen, Norway. He was
	founding Director (1990-2000) of the Wittgenstein Archives at
	the University of Bergen, for which he developed the text
	encoding system MECS as well as the editorial methods for the
	publication of Wittgenstein's Nachlass - The Bergen Electronic
	Edition (Oxford University Press, 2000).</para><!--*
	<para>
	  Mag.art. Claus Huitfeldt (born 1957) is Associate Professor
	  (f&#xf8;rsteamanuensis) at the Department of Philosophy of
	  the University of Bergen since 1994.
	</para>
	<para>
	  He was founding Director (1990-2000) of the Wittgenstein
	  Archives at the University of Bergen, for which he developed
	  the text encoding system MECS as well as the editorial
	  methods for the publication of <emphasis>Wittgenstein's
	  Nachlass &#x2014; The Bergen Electronic Edition</emphasis>
	  (Oxford University Press, 2000).</para>
	<para>
	  He was Research Director (2000-2002) of Aksis (Section for
	  Culture, Language and Information Technology at the Bergen
	  University Research Foundation). In 2003 he returned to his
	  position at the Department of Philosophy, where he teaches
	  modern philosophy and philosophy of language, and also gives
	  frequent courses in text technology at the The Department of
	  Humanistic Informatics.
	</para>
	<para>
	  He was active in the Text Encoding Initiative (TEI) since
	  1991, and was centrally involved in the foundation of the TEI
	  Consortium in 2001. The consortium now counts more than 90
	  member institutions.
	</para>
	<para>
	  Huitfeldt's research interests are within philosophy of
	  language, philosophy of technology, text theory, editorial
	  philology and markup theory. He is currently leader of the
	project Markup Languages for Complex Documents (MLCD).</para>
	*--></personblurb><affiliation><jobtitle>Associate Professor (førsteamanuensis)</jobtitle><orgname>Department of Philosophy, University of Bergen</orgname></affiliation></author><legalnotice><para>Copyright © 2014 by the authors.  Used with permission.</para></legalnotice></info><section xml:id="intro"><title>Introduction</title><para>
      Practitioners of descriptive markup rely on the ability of
      markup in a document to convey information; earlier work
      has attempted to characterize the nature of that
      information and describe ways to make it manifest in ways
      beyond what is done by conventional processing of SGML, XML,
      and similar systems.<footnote><para>See discussion of related work, below.</para></footnote>
      Among the methods so far suggested is to capture the
      information carried by the markup of the document in symbolic
      logic.  It is possible in principle to enumerate the crucial
      inferences licensed by the markup in a document; these
      sentences, together with all the other sentences that can be
      inferred from them, are held to constitute the set of
      inferences licensed by the markup (which in turn is held by
      some to constitute the meaning of the markup).
    </para><para>We offer here an application of that idea to the problem of
    document comparison.  Given the sets of inferences licensed by the
    markup in two documents, we suggest a method for determining
    whether the markup in the two documents is semantically
    equivalent, semantically compatible (but richer in one than the
    other), or contradictory.
    </para><para>One consequence of this is that the information in documents
    can usefully be taken to form a lattice, which can in turn be used
    to illustrate the relation among documents.</para></section><section xml:id="related"><title>Related work</title><para>
      It should be noted at the outset that the kind of document
      comparison we describe here has nothing to do with the problem
      of XML file comparison or <quote>diff</quote> tools.
    </para><para>
      The crucial basis for the current work is provided by a long
      series of papers on markup semantics by various authors
      (including at times the authors of this document, in various
      combinations and with various others).  A number of proposals
      for identifying the meaning of markup amount to proposals to
      make that meaning visible and processable by extracting it and
      translating it into some other form.  Some proposals are
      agnostic on the target format (e.g. [<xref linkend="hrsm"/>]):
      others target English prose ([<xref linkend="Marcoux2009"/>] and
      [<xref linkend="MR2009"/>]), first-order predicate calculus
      ([<xref linkend="pemm"/>], [<xref linkend="allc-skeletons"/>],
      [<xref linkend="extreme2003"/>]), Prolog, the logic of situation
      semantics ([<xref linkend="Wrightson2005"/>], [<xref linkend="Wrightson2007"/>], and [<xref linkend="Wickett2010"/>]), <quote>relational systems</quote> for
      knowledge management ([<xref linkend="WeltyIde99"/>]), RDF, and
      perhaps others.
    </para><para>
      One way in which one might motivate the choice of one of these
      target syntaxes over the others would be to show that it makes
      it easier to perform useful tasks with the information carried
      by the markup in the documents.  The proposal made here exploits
      the fact that inference is well understood for first-order
      predicate calculus in many different variants, and uses (a very
      simple form) of mechanical theorem proving to perform
      interesting work.
    </para><para>
      In 2011, Sperberg-McQueen proposed to use the sets of inferences
      licensed by markup in the field of digital preservation, as a
      way to test the information equivalence of documents before and
      after conversion [<xref linkend="msm2011"/>].  We provide a
      concrete illustration of the technique described there,
      generalize the test from equivalence to subsumption,
      compatibilty, and contradiction, and discuss some implications
      of the technique.
    </para></section><section xml:id="cf"><title>Document comparison</title><section xml:id="docrels"><title>Relations among documents</title><para>We claim that with respect to the information carried by
      the markup in any two documents
      <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript>, exactly one of the
      following states of affairs will apply:
      <itemizedlist><listitem><para>
	    <emphasis>D</emphasis><subscript>1</subscript> and
	    <emphasis>D</emphasis><subscript>2</subscript> are
	    equivalent: all of the information in
	    <emphasis>D</emphasis><subscript>1</subscript> is present in
	    <emphasis>D</emphasis><subscript>2</subscript> and vice
	  versa.</para></listitem><listitem><para>
	    <emphasis>D</emphasis><subscript>1</subscript>
	    <emphasis>subsumes</emphasis> or <emphasis>is an
	    abstraction of</emphasis>
	    <emphasis>D</emphasis><subscript>2</subscript>: all of the
	    information in
	    <emphasis>D</emphasis><subscript>1</subscript> is present in
	    <emphasis>D</emphasis><subscript>2</subscript>, but the
	    reverse is not true.  Equivalently, we say that
	    <emphasis>D</emphasis><subscript>2</subscript> <emphasis>is
	    a refinement</emphasis> of
	    <emphasis>D</emphasis><subscript>1</subscript>.
	    </para></listitem><listitem><para><emphasis>D</emphasis><subscript>2</subscript> subsumes
	  <emphasis>D</emphasis><subscript>1</subscript>.</para></listitem><listitem><para>Neither <emphasis>D</emphasis><subscript>1</subscript>
	  nor <emphasis>D</emphasis><subscript>2</subscript> subsumes
	  the other, but they are logically consistent with each
	  other.
	  </para></listitem><listitem><para>
	    <emphasis>D</emphasis><subscript>1</subscript> and
	    <emphasis>D</emphasis><subscript>2</subscript> contradict each
	    other.
	  </para></listitem></itemizedlist>
      </para></section><section xml:id="opdef"><title>An algorithm for document comparisons</title><para>To compare two documents
      <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript>, we first enumerate
      a set of key inferences from the markup for each document.  Let
      us call these two sets
      <emphasis>S</emphasis><subscript>1</subscript> and
      <emphasis>S</emphasis><subscript>2</subscript>.  These take the
      form of sentences in some suitable form of symbolic logic.  (In
      the example below, we use a more or less standard first-order
      predicate calculus; in demonstrating that the comparisons can be
      implemented in software, we also use the syntaxes of Prolog and
      Alloy.)</para><para>Note that we do not ask for an enumeration of all the
      inferences licensed by the markup in either document; that set
      is by definition closed under inference, and by all conventional
      accounts will be infinite. By an <quote>enumeration of key
      inferences</quote> we mean some finite set of sentences inferred
      from the document, which suffice to allow the inference of all
      the others (sometimes called a <emphasis>basis</emphasis> for
      the infinite set of inferences).  We will refer to the closure
      of <emphasis>S</emphasis><subscript>1</subscript> under logical
      inference as *<emphasis>S</emphasis><subscript>1</subscript>, and
      the closure of <emphasis>S</emphasis><subscript>2</subscript>
      under inference will be
      *<emphasis>S</emphasis><subscript>2</subscript>.
      </para><para>In the simple case,
      <emphasis>S</emphasis><subscript>1</subscript> and
      <emphasis>S</emphasis><subscript>2</subscript> will use the same
      predicates, assume the existence of the same individuals, and
      use the same names for the individuals in the universe of
      discourse.  Then establishing the informational equivalence of
      the two documents is simply a case of checking that every
      sentence in <emphasis>S</emphasis><subscript>1</subscript> is
      present in <emphasis>S</emphasis><subscript>2</subscript>, and
      vice versa.  The subsumption relation can similarly be
      established by checking for a subset relation between
      <emphasis>S</emphasis><subscript>1</subscript> and
      <emphasis>S</emphasis><subscript>2</subscript>.
      </para><para>
	In the general case, however, none of these will be true:
	<emphasis>S</emphasis><subscript>1</subscript> and
	<emphasis>S</emphasis><subscript>2</subscript> may use different
	predicates; they may assume the existence of different
	individuals in the universe of discourse; even when they
	assume the <quote>same</quote> predicates or individuals, they
	may use different names for them.  A prerequisite for
	comparing the sets
	<emphasis>S</emphasis><subscript>1</subscript> and
	<emphasis>S</emphasis><subscript>2</subscript> in practice is
	thus the preparation of rules of inference that allow
	statements in the vocabulary of
	<emphasis>S</emphasis><subscript>1</subscript> to be inferred
	from statements in the vocabulary of
	<emphasis>S</emphasis><subscript>2</subscript>, and vice-versa.
	We will call these the <emphasis>translation inference
	rules</emphasis>, since their goal is to translate information
	from one vocabulary to another.  Some translation inference
	rules map from <emphasis>S</emphasis><subscript>1</subscript> to
	<emphasis>S</emphasis><subscript>2</subscript>: they allow us to
	infer statements in the vocabulary of
	<emphasis>S</emphasis><subscript>2</subscript>, given other
	statements in the vocabulary of
	<emphasis>S</emphasis><subscript>1</subscript>.  We refer to
	these as <emphasis>S</emphasis><subscript>1</subscript> →
	<emphasis>S</emphasis><subscript>2</subscript>; we refer to the
	translation inference rules mapping in the other direction as
	<emphasis>S</emphasis><subscript>2</subscript> →
	<emphasis>S</emphasis><subscript>1</subscript>.
      </para><para>Note that in what follows we silently assume that the
      translation inference rules
      <emphasis>S</emphasis><subscript>1</subscript> →
      <emphasis>S</emphasis><subscript>2</subscript> and
      <emphasis>S</emphasis><subscript>2</subscript> →
      <emphasis>S</emphasis><subscript>1</subscript> are given, and are
      included in the closures
      *<emphasis>S</emphasis><subscript>1</subscript> and
      *<emphasis>S</emphasis><subscript>2</subscript>, along with other
      general world knowledge.</para><para>In this more general situation, we can establish the
      equivalence of <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript> by checking that
      every sentence in <emphasis>S</emphasis><subscript>1</subscript>
      is present in, <emphasis>or follows from</emphasis>,
      <emphasis>S</emphasis><subscript>2</subscript>, and vice versa.
      Subsumption, consistency, and inconsistency relations can
      similarly be established on the basis of logical
      implication.</para><para>We provide an algorithm for determining which state of
      affairs applies between documents
      <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript>:
      <itemizedlist><listitem><para>From the set
      <emphasis>S</emphasis><subscript>1</subscript> and the translation
      rules <emphasis>S</emphasis><subscript>1</subscript> →
      <emphasis>S</emphasis><subscript>2</subscript>, we attempt to
      infer each sentence in
      <emphasis>S</emphasis><subscript>2</subscript>.  </para><para>If
      we succeed for all sentences in
      <emphasis>S</emphasis><subscript>2</subscript>, then
      <emphasis>S</emphasis><subscript>2</subscript> is contained within
      the logical closure of
      <emphasis>S</emphasis><subscript>1</subscript>
      (i.e. <emphasis>S</emphasis><subscript>2</subscript> ⊆
      *<emphasis>S</emphasis><subscript>1</subscript>, and by definition
      also *<emphasis>S</emphasis><subscript>2</subscript> ⊆
      *<emphasis>S</emphasis><subscript>1</subscript>).  Less formally:
      all of the information in
      <emphasis>S</emphasis><subscript>2</subscript> is present in
      <emphasis>S</emphasis><subscript>1</subscript> (and similarly for
      <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript>).  </para><para>If
      we succeed for some but not all sentences in
      <emphasis>S</emphasis><subscript>2</subscript>, then some but not
      all of the information in
      <emphasis>S</emphasis><subscript>2</subscript> (and
      <emphasis>D</emphasis><subscript>2</subscript>) is present in
      <emphasis>S</emphasis><subscript>1</subscript>
      (<emphasis>D</emphasis><subscript>1</subscript>).
      </para></listitem><listitem><para>Conversely, from the set
      <emphasis>S</emphasis><subscript>2</subscript> and the translation
      rules <emphasis>S</emphasis><subscript>2</subscript> →
      <emphasis>S</emphasis><subscript>1</subscript>, we attempt to
      infer each sentence in
      <emphasis>S</emphasis><subscript>1</subscript>.  (Or, more
      formally, we test whether
      *<emphasis>S</emphasis><subscript>1</subscript> ⊆
      *<emphasis>S</emphasis><subscript>2</subscript>.)</para></listitem><listitem><para>From
      the set <emphasis>S</emphasis><subscript>1</subscript> and the
      translation rules <emphasis>S</emphasis><subscript>1</subscript>
      → <emphasis>S</emphasis><subscript>2</subscript>, we
      attempt to infer the negation of each sentence in
      <emphasis>S</emphasis><subscript>2</subscript>.  </para><para>If
      we succeed for any sentence in
      <emphasis>S</emphasis><subscript>2</subscript>, then
      <emphasis>S</emphasis><subscript>1</subscript> and
      <emphasis>S</emphasis><subscript>2</subscript> contradict each
      other (as do <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript>).  </para><para>If
      we fail for all sentences in
      <emphasis>S</emphasis><subscript>2</subscript>, then
      <emphasis>S</emphasis><subscript>1</subscript> (and
      <emphasis>D</emphasis><subscript>1</subscript>) are compatible
      (logically consistent) with
      <emphasis>S</emphasis><subscript>2</subscript>
      (<emphasis>D</emphasis><subscript>2</subscript>).
      </para></listitem><listitem><para>Again, we perform the same
      task in the other direction, seeking to infer negations of
      sentences in <emphasis>S</emphasis><subscript>2</subscript> from
      the set <emphasis>S</emphasis><subscript>1</subscript> and the
      translation rules <emphasis>S</emphasis><subscript>1</subscript>
      →
      <emphasis>S</emphasis><subscript>2</subscript>.</para></listitem></itemizedlist>
      </para><para>The relation of the documents' information content (as
      given by the markup) is determined by the results of this
      exercise.
      <itemizedlist><listitem><para><emphasis>D</emphasis><subscript>1</subscript>
	subsumes <emphasis>D</emphasis><subscript>2</subscript> if and
	only if each sentence in
	<emphasis>S</emphasis><subscript>1</subscript> can be inferred
	from <emphasis>S</emphasis><subscript>2</subscript> and
	<emphasis>S</emphasis><subscript>2</subscript> →
	<emphasis>S</emphasis><subscript>1</subscript>.</para></listitem><listitem><para><emphasis>D</emphasis><subscript>2</subscript>
	subsumes <emphasis>D</emphasis><subscript>1</subscript> if and
	only if each sentence in
	<emphasis>S</emphasis><subscript>2</subscript> can be inferred
	from <emphasis>S</emphasis><subscript>1</subscript> and
	<emphasis>S</emphasis><subscript>1</subscript> →
	<emphasis>S</emphasis><subscript>2</subscript>.</para></listitem><listitem><para><emphasis>D</emphasis><subscript>1</subscript>
	and <emphasis>D</emphasis><subscript>2</subscript> are equivalent
	if and only if <emphasis>D</emphasis><subscript>1</subscript>
	subsumes <emphasis>D</emphasis><subscript>2</subscript> and
	<emphasis>D</emphasis><subscript>2</subscript> subsumes
	<emphasis>D</emphasis><subscript>1</subscript>.</para></listitem><listitem><para><emphasis>D</emphasis><subscript>1</subscript>
	and <emphasis>D</emphasis><subscript>2</subscript> contradict each
	other if and only if
	¬<emphasis>s</emphasis><subscript>1</subscript> follows, for
	some sentence <emphasis>s</emphasis><subscript>1</subscript> in
	<emphasis>S</emphasis><subscript>1</subscript>, from
	<emphasis>S</emphasis><subscript>2</subscript> and
	<emphasis>S</emphasis><subscript>2</subscript> →
	<emphasis>S</emphasis><subscript>1</subscript>, or
	¬<emphasis>s</emphasis><subscript>2</subscript> follows, for
	some sentence <emphasis>s</emphasis><subscript>2</subscript> in
	<emphasis>S</emphasis><subscript>2</subscript>, from
	<emphasis>S</emphasis><subscript>1</subscript> and
	<emphasis>S</emphasis><subscript>1</subscript> →
	<emphasis>S</emphasis><subscript>2</subscript>.</para></listitem><listitem><para><emphasis>D</emphasis><subscript>1</subscript>
	and <emphasis>D</emphasis><subscript>2</subscript> are compatible
	(logically consistent) with each other if and only if neither
	contradicts the other.</para></listitem></itemizedlist>
      </para><para>That is, the relation between documents
      <emphasis>D</emphasis><subscript>1</subscript> and
      <emphasis>D</emphasis><subscript>2</subscript> is determined by
      the subset/superset relations between
      *<emphasis>S</emphasis><subscript>1</subscript> and
      *<emphasis>S</emphasis><subscript>2</subscript>.
      </para></section><section xml:id="doclattices"><title>The document lattice</title><para>The subset/superset relations among sets of inferences
      licenced by documents constitute a partial order over all
      documents.  It is a consequence of this fact that the universe
      of documents forms a lattice, in the mathematical sense of the
      term.</para><para>A simple lattice formed by the subset relation over
      the subsets of the {a, b, c} is:
      <figure><mediaobject><imageobject><imagedata format="png" width="30%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-001.png"/></imageobject></mediaobject></figure>
      A similar lattice formed by the subset relation over
      the subsets of the {a, b, c, d, e} is:
      <figure><mediaobject><imageobject><imagedata format="png" width="80%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-002.png"/></imageobject></mediaobject></figure>
      </para><para>Any two points <emphasis>a</emphasis> and <emphasis>b</emphasis> in a lattice (and thus any two
      documents in a lattice of documents) have both a greatest
      lower bound (a point <emphasis>c</emphasis> in the lattice such that <emphasis>c</emphasis> ≤
      <emphasis>a</emphasis> and <emphasis>c</emphasis> ≤ <emphasis>b</emphasis>, and <emphasis>x</emphasis> ≤ <emphasis>c</emphasis> for all <emphasis>x</emphasis> such that
      <emphasis>x</emphasis> ≤ <emphasis>c</emphasis> and <emphasis>x</emphasis> ≤ <emphasis>b</emphasis>) and a greatest lower bound,
      known in lattice contexts respectively as the
      <emphasis>meet</emphasis> and the <emphasis>join</emphasis> of <emphasis>a</emphasis> and <emphasis>b</emphasis>.
      <figure><mediaobject><imageobject><imagedata format="png" width="80%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-003.png"/></imageobject></mediaobject></figure>
      Informally, the meet is the highest point where downward
      paths from <emphasis>a</emphasis> and <emphasis>b</emphasis> meet, the join is the lowest point
      where climbing paths meet.</para><para>Since the set of documents is infinite, so is the universal
          document lattice (as we will call the lattice formed
          from the sets of sentences entailed by documents); we will not
          attempt to provide an image of this infinite lattice.
          Instead, we will illustrate document lattices by 
          considering the lattice formed by the sets *<emphasis>S</emphasis><subscript>1</subscript>, *<emphasis>S</emphasis><subscript>2</subscript>,
          *(<emphasis>S</emphasis><subscript>1</subscript> ∪ <emphasis>S</emphasis><subscript>2</subscript>), *(<emphasis>S</emphasis><subscript>1</subscript> ∩ <emphasis>S</emphasis><subscript>2</subscript>), *(<emphasis>S</emphasis><subscript>1</subscript> \ <emphasis>S</emphasis><subscript>2</subscript>),
          *(<emphasis>S</emphasis><subscript>2</subscript> \ <emphasis>S</emphasis><subscript>1</subscript>), and the top and bottom nodes (⊤ and
          ⊥) of the universal document lattice.<footnote><para>In these expressions, * indicates closure
          under logical inference, given some universal set of
          assumptions independent of the documents under consideration
          — what we elsewhere describe as <quote>world
          knowledge</quote>.  The node ⊤ is
          the universal set of all sentences; note that ⊤ is
          self-contradictory:  for every
          sentence <emphasis>s</emphasis> included in ⊤, the negation of <emphasis>s</emphasis> is also
          included.
          The node
          ⊥ is not the empty set, as might be expected,
          but the set of sentences which can be inferred
          without reference to any information in any document:
          that is, the set of tautologies, the set of sentences
          representing world knowledge, and the set of sentences
          inferrable from the tautologies together with world
          knowledge.
          And finally \ is the set difference operator:  
          (<emphasis>S</emphasis><subscript>1</subscript> \ <emphasis>S</emphasis><subscript>2</subscript>) contains those sentences of <emphasis>S</emphasis><subscript>1</subscript> which 
          are not in <emphasis>S</emphasis><subscript>2</subscript>.</para><para>There is a certain notational tension in the fact
	  that lattices based on the subset/superset relation
	  are typically drawn with the ⊤ as the universal set
	  and ⊥ as the empty set (or, as in our case, a
	  set minimal in some way), while discussions of logic
	  sometimes use the symbol ⊤ to denote truth
	  and the symbol ⊥ to denote falsehood, or
	  contradiction.  Perhaps we should draw our lattice
	  in the other direction, with subsets above not below
	  their supersets.</para></footnote>
          Note that all illustrations assume that neither 
          <emphasis>D</emphasis><subscript>1</subscript> nor <emphasis>D</emphasis><subscript>2</subscript> is self-contradictory (so neither
          *<emphasis>S</emphasis><subscript>1</subscript> nor *<emphasis>S</emphasis><subscript>2</subscript> is equal to ⊤)
          and that neither is vacuous (so neither
          *<emphasis>S</emphasis><subscript>1</subscript> nor *<emphasis>S</emphasis><subscript>2</subscript> is equal to ⊥).
          </para><para>Every document is represented by a point in the lattice.  
          If and only if two documents <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> are equivalent, 
          then <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> map to the same point in the lattice.  
          If <emphasis>D</emphasis><subscript>1</subscript> subsumes <emphasis>D</emphasis><subscript>2</subscript> but the two documents are not equivalent, 
          then <emphasis>D</emphasis><subscript>1</subscript> is below <emphasis>D</emphasis><subscript>2</subscript> in the lattice.  
          Informally:  we can reach <emphasis>D</emphasis><subscript>1</subscript> from <emphasis>D</emphasis><subscript>2</subscript> by going
          down in the graph (or <emphasis>D</emphasis><subscript>2</subscript> from <emphasis>D</emphasis><subscript>1</subscript> by climbing).
          If neither <emphasis>D</emphasis><subscript>1</subscript> nor <emphasis>D</emphasis><subscript>2</subscript>
          subsumes the other, then neither is above or below the other
          in the lattice.</para><para>
          For the document lattice (based as it is upon the subset
          relation), the meet of two documents <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> is
          represented by the set *<emphasis>S</emphasis><subscript>1</subscript> ∩ *<emphasis>S</emphasis><subscript>2</subscript>, their join by *<emphasis>S</emphasis><subscript>1</subscript>
          ∪ *<emphasis>S</emphasis><subscript>2</subscript>.  (In the figure, the nodes <emphasis>a</emphasis> and <emphasis>b</emphasis> are 
          colored yellow and blue; their meet is colored gray,
          their joint is colored green.  As the bold arrows show,
          there may be more than one path connecting a node to its
          meet or its join with another node, but the meet and join
          are nevertheless each guaranteed unique.)
          </para><para>We have the following relations in the lattice for the
          various possible relations of <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript>, which we 
          illustrate on the finite lattice described earlier:
          <itemizedlist><listitem><para>If <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> are equivalent, then they map
	  to the same point in the lattice (as do their union and
	  intersection).
	  <figure><mediaobject><imageobject><imagedata format="png" width="20%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-004.png"/></imageobject></mediaobject></figure>
	</para></listitem><listitem><para>If <emphasis>D</emphasis><subscript>1</subscript> subsumes <emphasis>D</emphasis><subscript>2</subscript> but they are not
	equivalent, then <emphasis>D</emphasis><subscript>1</subscript> is below <emphasis>D</emphasis><subscript>2</subscript> in the lattice and can
	be reached by a sequence of downward arcs.
	<figure><mediaobject><imageobject><imagedata format="png" width="30%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-005.png"/></imageobject></mediaobject></figure>
	</para></listitem><listitem><para>If <emphasis>D</emphasis><subscript>2</subscript> subsumes <emphasis>D</emphasis><subscript>1</subscript> but they are not
	equivalent, then the reverse is true.</para></listitem><listitem><para>If <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> contradict each other, then
	their join is the topmost point in the lattice (the
	set of all possible sentences).<footnote><para>
	The topmost point in any lattice of sets is taken 
	by the universal set; the bottom point in such a lattice
	is taken by the empty set.  The sets we are concerned
	with are all closed under logical inference, and
	the most striking characteristic of a logical 
	contradiction is that it allows absolutely any
	sentence to be inferred.  So any set that contains
	a contradiction automatically also contains all possible
	sentences.</para></footnote>
	<figure><mediaobject><imageobject><imagedata format="png" width="50%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-006.png"/></imageobject></mediaobject></figure>
      </para></listitem><listitem><para>If neither <emphasis>D</emphasis><subscript>1</subscript> nor <emphasis>D</emphasis><subscript>2</subscript> subsumes the other, but
      they are logically consistent with each other, then
      they have a join somewhere other than the 
      top of the lattice.
      <figure><mediaobject><imageobject><imagedata format="png" width="60%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-007.png"/></imageobject></mediaobject></figure>
      </para></listitem></itemizedlist>
          </para><para>Most of what has been said so far is a straightforward
          account of the relation of arbitrary sets of sentences in a
          logical notation, when the sets are closed under logical
          inference.  It is not uniquely true of sets of sentences
          derived from the markup in documents.  Readers thus may well
          be asking themselves where some application to document
          processing comes in.</para><para>The document lattice we have described makes explicit
          some facts about information in documents that is obvious to
          markup practitioners (but often disappointingly non-obvious
          to clients and novices).  The kinds of translation processes
          referred to as up-translations and down-translations 
          correspond directly to relations in the lattice:  an
          up-translation involves mapping from some document
          <emphasis>D</emphasis><subscript>1</subscript> to another document <emphasis>D</emphasis><subscript>2</subscript> above <emphasis>D</emphasis><subscript>2</subscript> on the lattice,
          a down translation similarly involves moving downwards
          in the lattice.</para><para>If our task is to translate from
          document <emphasis>D</emphasis><subscript>1</subscript> in one markup vocabulary (say, Docbook) into
          some document <emphasis>D</emphasis><subscript>2</subscript> in another vocabulary (say, XHTML) by
          fully automatic means (e.g. an XSLT stylesheet), then either
          <emphasis>D</emphasis><subscript>2</subscript> must subsume <emphasis>D</emphasis><subscript>1</subscript>, or our task is impossible: fully
          automatic transforms can in principle map only from one
          document into another document reachable by zero or more
          downward steps.  (<emphasis>D</emphasis><subscript>2</subscript> is reachable in zero downward steps
          if it is logically equivalent to <emphasis>D</emphasis><subscript>1</subscript>; this is possible in
          principle but often quite difficult in practice.)
          </para><para>If a conversion from one vocabulary to another is
          intended to have no information loss, then the requiremet
          is that for any <emphasis>D</emphasis><subscript>1</subscript> in the source vocabulary, the
          conversion produce a <emphasis>D</emphasis><subscript>2</subscript> which occupies the same point
          in the lattice.</para></section></section><section xml:id="eg"><title>Example</title><para>A simple example may help to illustrate the operation
	    of the algorithm we have given above.</para><section xml:id="egdesc"><title>High-level description</title><para>Consider the following simple table:
	  
	  <figure><mediaobject><imageobject><imagedata format="png" width="80%" fileref="../../../vol13/graphics/Sperberg-McQueen01/Sperberg-McQueen01-008.png"/></imageobject></mediaobject></figure>
        </para><para>Let us imagine that we have two versions of this table,
        each in a different markup language with a possibly different
        table model, and we wish to know whether the table
        markup in the two documents is equivalent, or at least
        logically consistent.</para><para>One table, let us suppose, is tagged in XHTML:
        <programlisting xml:space="preserve">    &lt;table border="1"&gt;
      &lt;tr&gt;
        &lt;th&gt;Année&lt;/th&gt;
        &lt;th&gt;Événement&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;1969&lt;/td&gt;
        &lt;td&gt;Création d'ARPANET, le premier réseau 
        national américain d'ordinateurs, par le 
        &lt;em&gt;Defense Department's Advanced
        Research Projects Agency&lt;/em&gt; (DARPA)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;1992&lt;/td&gt;
        &lt;td&gt;Mise en service du &lt;em&gt;World Wide Web&lt;/em&gt; 
        par le CERN (Centre européen de recherche 
        nucléaire), en Suisse&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;</programlisting>
        </para><para>The other table, intended to be equivalent, is tagged
        using the SGML Open exchange subset of the CALS table model 
        [<xref linkend="Oasis"/>],
        [<xref linkend="CALS"/>].
        <programlisting xml:space="preserve">&lt;table colsep="1" rowsep="1"&gt;
  &lt;tgroup cols="2"&gt;
    &lt;colspec colnum="1" colname="annee" colwidth="1*"/&gt;
    &lt;colspec colnum="2" colname="evenement" colwidth="4*"/&gt;
   &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;Année&lt;/entry&gt;
        &lt;entry&gt;Événement&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry colname="evenement"&gt;Création d'ARPANET, 
        le prémier réseau américain
        d'ordinateurs, par le Defense Department's 
        Advanced Research
        Projects Agency (DARPA)&lt;/entry&gt;
        &lt;entry colname="annee"&gt;1969&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry colname="annee"&gt;1992&lt;/entry&gt;
        &lt;entry&gt;Mise en service du World Wide Web 
          par le CERN
          (Centre européen de recherche nucléaire), 
          en Suisse&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;</programlisting>
        </para></section><section xml:id="fopc"><title>In first-order predicate calculus</title><para>From each marked up table we derive a set of 
          sentences.<footnote><para>The processes by which
          these inferences may be enumerated has been described
          elsewhere; we won't expound it again here.</para></footnote> 
          </para><section xml:id="S1-2x3"><title>Set <emphasis>S</emphasis><subscript>1</subscript></title><para>In more or less conventional first-order predicate calculus 
	    notation,<footnote><para>
	      Since notations for symbolic logic vary widely, it may 
	      be helpful to summarize here the essentials of our
	      notation.
	      <itemizedlist><listitem><para>The symbols used for variables and predicate names 
		follow, more or less, the rules for non-colonized names
		in XML.</para></listitem><listitem><para>Atomic facts are written in the form 
		<quote>p(<emphasis>a</emphasis><subscript>1</subscript>,
		<emphasis>a</emphasis><subscript>2</subscript>, ...,
		<emphasis>a</emphasis><emphasis><subscript>n</subscript></emphasis>)</quote>; here <quote>p</quote> is the
		predicate symbol and
		<emphasis>a</emphasis><subscript>1</subscript> through
		<emphasis>a</emphasis><emphasis><subscript>n</subscript></emphasis> are its 
		arguments.</para></listitem><listitem><para>Sentences can be combined with the connectors
		∧ (and), ∨ (or), ⇒ (implies, if-then),
		and ⇔ (if and only if).</para></listitem><listitem><para>Sentences of the form (∀ <emphasis>x</emphasis>)[P(<emphasis>x</emphasis>)]
		may be read <quote>For all <emphasis>x</emphasis>, P(<emphasis>x</emphasis>)</quote>,
		i.e. for everything that exists, the predicate P
	    holds.</para></listitem><listitem><para>Sentences of the form (∃ <emphasis>x</emphasis>)[P(<emphasis>x</emphasis>)]
		may be read <quote>There exists some <emphasis>x</emphasis> such that P(<emphasis>x</emphasis>)</quote>,
		i.e. some thing exists (here identified with the variable
		<emphasis>x</emphasis>) of which the predicate P
	    holds.</para></listitem><listitem><para>Sentences of the form (∃<subscript>1</subscript> <emphasis>x</emphasis>)[P(<emphasis>x</emphasis>)]
		may be read <quote>There exists exactly one <emphasis>x</emphasis> such that P(<emphasis>x</emphasis>)</quote>.
		This is conventionally (following Russell) taken as 
		meaning (∃ <emphasis>x</emphasis>)[P(<emphasis>x</emphasis>) ∧ (∀ <emphasis>y</emphasis>)[P(<emphasis>y</emphasis>) ⇒
		<emphasis>y</emphasis> =
		<emphasis>x</emphasis>]].</para></listitem><listitem><para>For brevity, sentences of the form 
		(∃ <emphasis>x</emphasis>)[<emphasis>x</emphasis> ∈ ℕ ∧ P(<emphasis>x</emphasis>)]
		may be abbreviated
		(∃ <emphasis>x</emphasis> ∈ ℕ)[P(<emphasis>x</emphasis>)].
		And similarly for other quantifiers (∀, ∃<subscript>1</subscript>).
		ℕ here means <quote>the natural numbers</quote>, i.e.
		the non-negative integers.
		</para></listitem><listitem><para>For brevity, multiple quantifiers may be written together:
		(∃ <emphasis>x</emphasis>)(∃ <emphasis>y</emphasis>)[P(<emphasis>x</emphasis>, <emphasis>y</emphasis>)]
		may be abbreviated
		(∃ <emphasis>x</emphasis>, <emphasis>y</emphasis>)[P(<emphasis>x</emphasis>, <emphasis>y</emphasis>)].
		And similarly for other quantifiers (∀, ∃<subscript>1</subscript>).
		</para></listitem></itemizedlist>
	    </para></footnote>
	    the first set of inferences is as follows.<footnote><para>
            It is impossible to contemplate this list without
            thinking about those who have argued in the past
            that documents would be much easier to process if 
            instead of XML people would use some more <quote>semantic</quote>
            notation, like symbolic logic or RDF or some knowledge-representation
            scheme, to represent them.  The only way we can imagine to 
            produce an actual printed table from these logical 
            sentences is to try to translate them back into
            markup, and then use conventional XML processing
            to display the table.</para></footnote></para><para>Table <emphasis>T</emphasis> is 3 by 2.  In consequence, cell (3, 2) exists in table <emphasis>T</emphasis>,
            but cells (4, 1) and (1, 3) do not.)
            <itemizedlist><listitem><para>table_dimensions(<emphasis>T</emphasis>, 3, 2)</para></listitem><listitem><para>cell(<emphasis>T</emphasis>, 3, 2) ∧ ¬cell(<emphasis>T</emphasis>, 4, 1) and ¬cell(<emphasis>T</emphasis>, 1, 3)</para></listitem></itemizedlist>
            </para><para>The two heading cells in row 1, columns 1 and 2, 
            are identified as headings.
            <itemizedlist><listitem><para>isTableHeader(<emphasis>T</emphasis>, 1, 1)</para></listitem><listitem><para>isTableHeader(<emphasis>T</emphasis>, 1, 2)</para></listitem></itemizedlist>
            </para><para>Next, the contents of the various cells are given.
            <itemizedlist><listitem><para>tableCellContent(<emphasis>T</emphasis>, 1, 1, "Année")</para></listitem><listitem><para>tableCellContent(<emphasis>T</emphasis>, 1, 2, "Événement")</para></listitem><listitem><para>tableCellContent(<emphasis>T</emphasis>, 2, 1, "1969")</para></listitem><listitem><para>tableCellContent(<emphasis>T</emphasis>, 2, 2, "Création d'ARPANET...")</para></listitem><listitem><para>tableCellContent(<emphasis>T</emphasis>, 3, 1, "1992")</para></listitem><listitem><para>tableCellContent(<emphasis>T</emphasis>, 3, 2, "Mise en service du...")</para></listitem></itemizedlist>
            </para><para>The table has some styling information, given in CSS and not
	    shown above:  the table
            width is 80% of its parent element's width, and it has a 10% left margin.
            <itemizedlist><listitem><para>tableWidth(<emphasis>T</emphasis>, "80%")</para></listitem><listitem><para>tableMarginLeft(<emphasis>T</emphasis>, "10%")</para></listitem></itemizedlist>
            The background color of the heading cells is <code>#CCCCCC</code>, and all cells
            are vertically aligned to the top of the cell.
            <itemizedlist><listitem><para>(∀ <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[isTableHeader(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇒ tableCellBackgroundColor(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, "#CCCCCC")]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[cell(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇒ tableCellVerticalAlign(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, "top")]</para></listitem></itemizedlist>
            Table borders are thin, solid lines.
            <itemizedlist><listitem><para>(∀ <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[cell(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇒ tableCellBorderWidth(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, "thin")]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[cell(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇒ tableCellBorderStyle(<emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, "solid")]</para></listitem></itemizedlist>
            </para><para>Finally, we give some rules which apply to all tables and not just to this one.
            These can be used for sanity checking of sets of sentences, to ensure that we have specified
            content for all the cells that need to be described, and so on.</para><para>
            In any table, only those cells <quote>exist</quote> which have content.
            <itemizedlist><listitem><para>(∀ <emphasis>t</emphasis>, <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[cell(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇔ (∃ <emphasis>c</emphasis>)[tableCellContent(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)]]</para></listitem></itemizedlist>
            </para><para>All tables are finite and have no holes.  (Literally:  for all tables,
            there are maximum dimensions <emphasis>x</emphasis> and <emphasis>y</emphasis> such that all cells have row and
            column coordinates less than or equal to <emphasis>x</emphasis> and <emphasis>y</emphasis>, respectively.)
              <itemizedlist><listitem><para>(∀ <emphasis>t</emphasis>)(∃ <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)(∀ <emphasis>x</emphasis>′ ∈ ℕ, <emphasis>y</emphasis>′ ∈ ℕ)[
                cell(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ⇔ ((<emphasis>x</emphasis>′ ≤ <emphasis>x</emphasis>) ∧ (<emphasis>y</emphasis>′ ≤ <emphasis>y</emphasis>))
                ]</para></listitem></itemizedlist>
            </para><para>No table is empty. (So all tables have at least one row and one column and thus a cell in position (1, 1).)
              <itemizedlist><listitem><para>(∀ <emphasis>t</emphasis>)[cell(<emphasis>t</emphasis>, 1, 1)]</para></listitem></itemizedlist>
            </para><para>In a table, only existing cells can have <quote>interesting</quote> properties.
            (Literally, we postulate <emphasis>isTableHeader</emphasis>, or a background color, or
            vertical alignment, or border width and style, of some triple <emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis> only if
            there is a cell <emphasis>T</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>.)
              <itemizedlist><listitem><para>(∀ <emphasis>t</emphasis>, <emphasis>x</emphasis> ∈ ℕ, <emphasis>y</emphasis> ∈ ℕ)[
<?fmt linebreak?>
                (
<?fmt linebreak?>
                isTableHeader(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>) ∨
<?fmt linebreak?>
                (∃ <emphasis>c</emphasis>)[tableCellBackgroundColor(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>) ∨
<?fmt linebreak?>
                tableCellVerticalAlign(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>) ∨
<?fmt linebreak?>
                tableCellBorderWidth(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>) ∨
<?fmt linebreak?>
                tableCellBorderStyle(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)]
<?fmt linebreak?>
                ) ⇒ cell(<emphasis>t</emphasis>, <emphasis>x</emphasis>, <emphasis>y</emphasis>)
<?fmt linebreak?>
                ]
                </para></listitem></itemizedlist>
            </para></section><section xml:id="S2-2x3"><title>Set <emphasis>S</emphasis><subscript>2</subscript></title><para>The description of the other table is this; notice both that
            it takes a rather different view of which <emphasis>individuals</emphasis> need to exist to
            enable the description of the table, and that the markup from
            which it started said nothing about vertical alignment or
            table borders. 
            </para><para>This set of sentences begins by identifying the individuals 
            in the universe of discourse and saying what kinds of things they are:
            <emphasis>c11</emphasis> and <emphasis>c12</emphasis> are heading cells, various other individuals are
            data cells, rows, columns, or tables.
            <itemizedlist><listitem><para>headingcell(<emphasis>c11</emphasis>)</para></listitem><listitem><para>headingcell(<emphasis>c21</emphasis>)</para></listitem><listitem><para>datacell(<emphasis>c12</emphasis>)</para></listitem><listitem><para>datacell(<emphasis>c22</emphasis>)</para></listitem><listitem><para>datacell(<emphasis>c13</emphasis>)</para></listitem><listitem><para>datacell(<emphasis>c23</emphasis>)</para></listitem><listitem><para>row(<emphasis>r1</emphasis>)</para></listitem><listitem><para>row(<emphasis>r2</emphasis>)</para></listitem><listitem><para>row(<emphasis>r3</emphasis>)</para></listitem><listitem><para>column(<emphasis>c1</emphasis>)</para></listitem><listitem><para>column(<emphasis>c2</emphasis>)</para></listitem><listitem><para>table(<emphasis>t1</emphasis>)</para></listitem></itemizedlist>
            </para><para>The table <emphasis>t1</emphasis> contains a particular set of rows in a particular
            order, and a particular set of columns in a particular order.
            (We write sequences as comma-separated lists in angle brackets, 
            as is common in some fields.)
            <itemizedlist><listitem><para>table_rowsequence(<emphasis>t1</emphasis>, 〈 <emphasis>r1</emphasis>, <emphasis>r2</emphasis>, <emphasis>r3</emphasis> 〉)</para></listitem><listitem><para>table_colsequence(<emphasis>t1</emphasis>, 〈 <emphasis>c1</emphasis>, <emphasis>c2</emphasis> 〉)</para></listitem><listitem><para>row_cellsequence(<emphasis>r1</emphasis>, 〈 <emphasis>c11</emphasis>, <emphasis>c21</emphasis> 〉)</para></listitem><listitem><para>row_cellsequence(<emphasis>r2</emphasis>, 〈 <emphasis>c12</emphasis>, <emphasis>c22</emphasis> 〉)</para></listitem><listitem><para>row_cellsequence(<emphasis>r3</emphasis>, 〈 <emphasis>c13</emphasis>, <emphasis>c23</emphasis> 〉)</para></listitem><listitem><para>col_cellsequence(<emphasis>c1</emphasis>, 〈 <emphasis>c11</emphasis>, <emphasis>c12</emphasis>, <emphasis>c13</emphasis> 〉)</para></listitem><listitem><para>col_cellsequence(<emphasis>c2</emphasis>, 〈 <emphasis>c21</emphasis>, <emphasis>c22</emphasis>, <emphasis>c23</emphasis> 〉)</para></listitem></itemizedlist>
            </para><para>The individual cells each contain text, represented
            here as a simple string of characters.<footnote><para>That is, 
            for simplicity we here ignore the possibility of embedded markup
            inside the table cells.  Since table cells can typically include 
	    more or less arbitrary paragraph- or phrase-level markup from
	    the host markup language, addressing the equivalence of cell
	    contents in the general case would involve a full account of
	    the host markup language(s), and would rather spoil the simplicity
	    of the example.
	  </para></footnote>
            <itemizedlist><listitem><para>cell_text(<emphasis>c11</emphasis>, "Année")</para></listitem><listitem><para>cell_text(<emphasis>c21</emphasis>,"Evénement")</para></listitem><listitem><para>cell_text(<emphasis>c12</emphasis>,"1969")</para></listitem><listitem><para>cell_text(<emphasis>c22</emphasis>,"Création d'ARPANET, le prémier réseau national américain d'ordinateurs ...")</para></listitem><listitem><para>cell_text(<emphasis>c13</emphasis>,"1992")</para></listitem><listitem><para>cell_text(<emphasis>c23</emphasis>,"Mise en service du World Wide Web pare le CERN ...")</para></listitem></itemizedlist>
            </para></section><section xml:id="constraint-2x3"><title>Ensuring the identity of individuals (digression)</title><para>The next step is to formulate translation inference rules
	    for mapping from the vocabulary of <emphasis>S</emphasis><subscript>1</subscript> to that of <emphasis>S</emphasis><subscript>2</subscript> and
	    vice versa.</para><para>There is a complication here, however, which requires a brief
            digression.  The issue has no particular interest from the
            markup point of view but is crucial to make the inference
            process work smoothly.  It is perhaps best illustrated if
            we imagine a two-player game similar to Twenty Questions.
            Player One is equipped with sentences <emphasis>S</emphasis><subscript>1</subscript>, which Player
            Two cannot see, while Player Two has set <emphasis>S</emphasis><subscript>2</subscript>, which is
            invisible to Player One; both have access to the
            translation inference rules.  The players take turns
            challenging each other to say whether a given sentence is
            or is not present in (or inferrable from) the challenger's
            set of sentences.</para><para>In our example Player One might ask whether
            <emphasis>table_dimensions(t, 2, 3)</emphasis> is in set <emphasis>S</emphasis><subscript>1</subscript>.  Player
            Two knows that the table has three rows and two columns,
            so the correct form of such a sentence should be
            <emphasis>table_dimensions(t, 3, 2)</emphasis>, so Player Two
            correctly answers no.</para><para>The complication arises when Player 1 asks whether the
            sentence <emphasis>table_dimensions(t, 3, 2)</emphasis> is in <emphasis>S</emphasis><subscript>1</subscript>.
            It could be; the order of arguments is correct.  But does
            <emphasis>S</emphasis><subscript>1</subscript> refer to the table in question as <emphasis>t</emphasis>?  Or as <emphasis>t1</emphasis>?
            Or by some other name?  There is no way for Player Two to
            find out: in symbolic logic, the identifiers used to denote individuals are
            arbitrary and do not in themselves carry information.</para><para>If Player Two is required to <emphasis>guess</emphasis> how
            <emphasis>S</emphasis><subscript>1</subscript> spells the identifier, then the game quickly becomes
            uninteresting.  We need some way to make such guessing
            unnecessary.  Perhaps the players could agree in advance
            on the names of all the individuals to be postulated in
            the universe of discourse.  That would simplify life a
            great deal, but it is not always possible: <emphasis>S</emphasis><subscript>1</subscript> and <emphasis>S</emphasis><subscript>2</subscript>
            do not necessarily agree on the number or nature of the
            individuals to be postulated in the universe of
            discourse.</para><para>We therefore impose a rule that the arbitrary
            identifier used for each individual must be discoverable
            from the essential properties of that individual.  <emphasis>For
            each individual with an arbitrary identifier, the set of
            sentences referring to that individual must include some
            predicate which is true of that individual and of no other
            individual in the universe of discourse.</emphasis><footnote><para>The rule does not apply for individuals
            with well-known names, such that the identifier used for
            the individual is not arbitrarily chosen by the creator of
            the set <emphasis>S</emphasis>.  The natural numbers (for example) and the
            set of strings of Unicode characters do not need such
            uniquely identifying predicates.</para></footnote></para><para>Set <emphasis>S</emphasis><subscript>1</subscript>, for example, assigns the arbitrary identifier
            <emphasis>T</emphasis> to the table being described.  Since for purposes of
            the example there is never more than one table in the
            universe of discourse, a predicate like
            <emphasis>this_table(T)</emphasis> can be used to identify the
	    table uniquely, make the identifier <emphasis>T</emphasis> discoverable, 
	    and satisfy the rule.  We therefore add that predicate
	    to our sketch of <emphasis>S</emphasis><subscript>1</subscript>:
	    <itemizedlist><listitem><para>this_table(T)</para></listitem></itemizedlist>
	    The natural numbers 1, 2, and 3, and various
            strings of Unicode characters are referred to using
            standard well known notations and not using arbitrary
            identifiers, so we do not need such uniquely identifying
            predicates for them.<footnote><para>Before the
            character set enthusiasts among our readership ask, we
            assume that all strings have been normalized using some
            appropriate form of Unicode normalization, so that
            <quote>Année</quote> and <quote>Événement</quote> are always spelled the
            same way.  The more or less analogous issues of whitespace
            normalization, by contrast, we simply ignore; they would
            take us too far afield.</para></footnote></para><para>Set <emphasis>S</emphasis><subscript>2</subscript> identifies a larger set of individuals, but we
            can easily use the positions of rows, columns, and cells
            within a table to uniquely identify them.  The individuals
            postulated in the universe of discourse by <emphasis>S</emphasis><subscript>2</subscript> can all be
            identified with the following set of uniquely identifying
            predicates:
            <itemizedlist><listitem><para>table_row(r1, t1, 1)</para></listitem><listitem><para>table_row(r2, t1, 2)</para></listitem><listitem><para>table_row(r3, t1, 3)</para></listitem><listitem><para>table_column(c1, t1, 1)</para></listitem><listitem><para>table_column(c2, t1, 2)</para></listitem><listitem><para>table_cell(c11, t1, 1, 1)</para></listitem><listitem><para>table_cell(c21, t1, 1, 2)</para></listitem><listitem><para>table_cell(c12, t1, 2, 1)</para></listitem><listitem><para>table_cell(c22, t1, 2, 2)</para></listitem><listitem><para>table_cell(c13, t1, 3, 1)</para></listitem><listitem><para>table_cell(c23, t1, 3, 2)</para></listitem></itemizedlist>
            When such uniquely identifying predicates are available, 
            we no longer have to wonder if a cell whose existence
            is predicated by set <emphasis>S</emphasis><subscript>1</subscript> and the <emphasis>S</emphasis><subscript>1</subscript> → <emphasis>S</emphasis><subscript>2</subscript> rules is
            supposed to represent cell <emphasis>c11</emphasis> or cell <emphasis>c21</emphasis> or one of the
            others.</para><para>The rules of the game can now be refined: players are
            forbidden to ask about sentences involving arbitrary
            identifiers.  So Player One cannot pose the sentence
            <emphasis>table_dimensions(t, 3, 2)</emphasis> as a challenge.
            Instead, all sentences must use bound variables; the
            uniquely identifying predicates make it possible to bind
            variables reliably to any chosen individual.  So Player
            One can usefully ask:
            <itemizedlist><listitem><para>(∃ <emphasis>x</emphasis>)[this_table(<emphasis>x</emphasis>) ∧ table_dimensions(<emphasis>x</emphasis>, 3, 2)]</para></listitem></itemizedlist>
            The form of the query is superficially more complicated, but the
            outer structure and first part of the sentence (namely 
            <emphasis>(∃ <emphasis>x</emphasis>)[this_table(<emphasis>x</emphasis>) ∧ ...]</emphasis>)
            serve merely to set up the real question, namely
            <emphasis>table_dimensions(<emphasis>x</emphasis>, 3, 2)</emphasis>.<footnote><para>
            The notation becomes lighterweight when we allow functions
            in our logical system and require not a uniquely identifying
            predicate for each individual but a function call which 
            returns it.  Then the challenge can be expressed
            <emphasis>table_dimensions( this_table(), 3, 2)</emphasis>.
            This shorter form is often helpful in practice, but imposes
            a heavier burden on the prose exposition, so we omit further
            mention of it here.</para></footnote>
            </para></section><section xml:id="s1s2-2x3"><title>The <emphasis>S</emphasis><subscript>1</subscript> → <emphasis>S</emphasis><subscript>2</subscript> translation inference rules</title><para>We can translate from the vocabulary of <emphasis>S</emphasis><subscript>1</subscript> into that 
            of <emphasis>S</emphasis><subscript>2</subscript> by these rules:</para><para>We begin with existential claims for the individuals in <emphasis>S</emphasis><subscript>2</subscript>, 
	    beginning with the table and continuing with the rows, columns,
	    and cells.
	    <itemizedlist><listitem><para>(∃ <emphasis>x</emphasis>)[this_table(<emphasis>x</emphasis>)]
		
<?fmt linebreak?>
		⇒
		(∃ <emphasis>y</emphasis>)[table(<emphasis>y</emphasis>)]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ 1 ≤ <emphasis>i</emphasis> 
	      ∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      (∃<subscript>1</subscript> <emphasis>r</emphasis>)[table_row(<emphasis>r</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)]]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ 1 ≤ <emphasis>i</emphasis> 
	      ∧ <emphasis>i</emphasis> ≤ <emphasis>m</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      (∃<subscript>1</subscript> <emphasis>c</emphasis>)[table_column(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)]]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ 1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis>
	      ∧ 1 ≤ <emphasis>j</emphasis> ∧ <emphasis>j</emphasis> ≤ <emphasis>m</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      (∃<subscript>1</subscript> <emphasis>c</emphasis>)[table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>)]]</para></listitem></itemizedlist>
	    </para><para>Next, we specify that the rows are rows, the columns are columns,
	    etc.<itemizedlist><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>r</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ (1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis>)
	      ∧ table_row(<emphasis>r</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      row(<emphasis>r</emphasis>)]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ (1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>m</emphasis>)
	      ∧ table_column(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      column(<emphasis>c</emphasis>)]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ isTableHeader(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      headingcell(<emphasis>c</emphasis>)]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ ¬ isTableHeader(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      datacell(<emphasis>c</emphasis>)]</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ)
	      
<?fmt linebreak?>
	      [(this_table(<emphasis>x</emphasis>) 
	      ∧ table(<emphasis>y</emphasis>)
	      ∧ cell(<emphasis>c</emphasis> <emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
	      
<?fmt linebreak?>
	      ⇒
	      cell(<emphasis>c</emphasis>)]</para></listitem></itemizedlist></para><para>The table_rowsequence, table_colsequence,
	    row_cellsequence, and column_cellsequence predicates
	    are a little more complicated, as they require
	    the construction of a sequence of objects.
	    </para><para>
	    While sequences are familiar enough to anyone involved
	    with XML or with contemporary programming languages, there
	    are a variety of ways they can be specified in logical
	    terms.  One common approach<footnote><para>One
	    example of this common approach is the account of
	    sequences on pages 128ff of [<xref linkend="Wetzel2009"/>], which in general we follow (except that
	    we number members of a sequence from one, not zero, to
	    minimize confusion for XPath users).</para></footnote> which
	    suffices for our present purposes is to say that a
	    sequence <emphasis>s</emphasis> of length <emphasis>n</emphasis> is a mapping from an initial
	    segment of the counting numbers (1, 2, ... <emphasis>n</emphasis>) to a
	    set.  
	    To indicate that a variable <emphasis>s</emphasis> in a logical expression
	    denotes a sequence, we declare it as (<emphasis>s</emphasis> ∈ Seq).
	    A sequence can be written out as a whole
	    by listing its members, in order, between angle
	    brackets (as was done above in the discussion of set
	    <emphasis>S</emphasis><subscript>2</subscript>); an individual member of the sequence can 
	    be identified by writing the number for its position
	    and the element in that position, joined by
	    the symbol ↦, e.g. 1 ↦ A, 2 ↦ B, 
	    ...  For clarity, such mappings may be parenthesized:
	    (1 ↦ A), (2 ↦ B), ...
	    We say that sequence <emphasis>s</emphasis> has element <emphasis>x</emphasis> at position
	    <emphasis>n</emphasis> by writing (<emphasis>n</emphasis> ↦ <emphasis>x</emphasis>) ∈ <emphasis>s</emphasis>.
	    </para><para>Armed with this account of sequences, we can now
	    describe the sequences of rows and columns in the table
	    and the sequences of cells in columns and rows.
	    <itemizedlist><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>r</emphasis>)
		(∀ <emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ, <emphasis>s</emphasis> ∈ Seq)
		
<?fmt linebreak?>
		[(this_table(<emphasis>x</emphasis>)
		∧ table(<emphasis>y</emphasis>)
		∧ row(<emphasis>r</emphasis>)
		∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
		
<?fmt linebreak?>
		∧ ((<emphasis>i</emphasis> ↦ <emphasis>r</emphasis>) ∈ <emphasis>s</emphasis> ⇔ (1 ≤ <emphasis>i</emphasis> 
		∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis> ∧ table_row(<emphasis>r</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)))
		
<?fmt linebreak?>
		∧ (<emphasis>i</emphasis> ≤ 0 ∨ <emphasis>n</emphasis> &lt; <emphasis>i</emphasis>)
		⇒
		¬(∃ <emphasis>z</emphasis>)[(<emphasis>i</emphasis> ↦ <emphasis>z</emphasis>) ∈ <emphasis>s</emphasis>])
		
<?fmt linebreak?>
		⇒
		table_rowsequence(<emphasis>x</emphasis>, <emphasis>s</emphasis>)]
		</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>)
		(<emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ, <emphasis>s</emphasis> ∈ Seq)
		
<?fmt linebreak?>
		[(this_table(<emphasis>x</emphasis>)
		∧ table(<emphasis>y</emphasis>)
		∧ column(<emphasis>c</emphasis>)
		∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
		
<?fmt linebreak?>
		∧ 
		((<emphasis>i</emphasis> ↦ <emphasis>c</emphasis>) ∈ <emphasis>s</emphasis> 
		⇔ (1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>m</emphasis> ∧ table_column(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>)))
		
<?fmt linebreak?>
		∧ (<emphasis>i</emphasis> ≤ 0 ∨ <emphasis>m</emphasis> &lt; <emphasis>i</emphasis>)
		⇒
		¬(∃ <emphasis>z</emphasis>)[(<emphasis>i</emphasis> ↦ <emphasis>z</emphasis>) ∈ <emphasis>s</emphasis>])
		
<?fmt linebreak?>
		⇒
		table_colsequence(<emphasis>x</emphasis>, <emphasis>s</emphasis>)]
		</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>r</emphasis>, <emphasis>c</emphasis>) 
		(<emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ, <emphasis>s</emphasis> ∈ Seq)
		
<?fmt linebreak?>
		[(this_table(<emphasis>x</emphasis>)
		∧ table(<emphasis>y</emphasis>)
		∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
		
<?fmt linebreak?>
		∧ row(<emphasis>r</emphasis>)
		∧ 1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis>
		∧ table_row(<emphasis>r</emphasis>, <emphasis>t</emphasis>, <emphasis>i</emphasis>)
		
<?fmt linebreak?>
		∧ ((<emphasis>j</emphasis> ↦ <emphasis>c</emphasis>) ∈ <emphasis>s</emphasis> 
		⇔ 1 ≤ <emphasis>j</emphasis> ∧ <emphasis>j</emphasis> ≤ <emphasis>m</emphasis> ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>))
		∧ (<emphasis>j</emphasis> ≤ 0 ∨ <emphasis>m</emphasis> &lt; <emphasis>j</emphasis>)
		⇒
		¬(∃ <emphasis>z</emphasis>)[(<emphasis>j</emphasis> ↦ <emphasis>z</emphasis>) ∈ <emphasis>s</emphasis>])
		
<?fmt linebreak?>
		⇒
		row_cellsequence(<emphasis>r</emphasis>, <emphasis>s</emphasis>)]
		</para></listitem><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>col</emphasis>, <emphasis>c</emphasis>) 
		(<emphasis>n</emphasis> ∈ ℕ, <emphasis>m</emphasis> ∈ ℕ, <emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ, <emphasis>s</emphasis> ∈ Seq)
		
<?fmt linebreak?>
		[(this_table(<emphasis>x</emphasis>)
		∧ table(<emphasis>y</emphasis>)
		∧ table_dimensions(<emphasis>x</emphasis>, <emphasis>n</emphasis>, <emphasis>m</emphasis>)
		
<?fmt linebreak?>
		∧ column(<emphasis>col</emphasis>)
		∧ 1 ≤ <emphasis>j</emphasis> ∧ <emphasis>j</emphasis> ≤ <emphasis>m</emphasis>
		∧ table_column(<emphasis>col</emphasis>, <emphasis>t</emphasis>, <emphasis>j</emphasis>)
		
<?fmt linebreak?>
		∧ ((<emphasis>i</emphasis> ↦ <emphasis>c</emphasis>) ∈ <emphasis>s</emphasis> 
		⇔ 1 ≤ <emphasis>i</emphasis> ∧ <emphasis>i</emphasis> ≤ <emphasis>n</emphasis> ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>))
		∧ (<emphasis>i</emphasis> ≤ 0 ∨ <emphasis>n</emphasis> &lt; <emphasis>i</emphasis>)
		⇒
		¬(∃ <emphasis>z</emphasis>)[(<emphasis>i</emphasis> ↦ <emphasis>z</emphasis>) ∈ <emphasis>s</emphasis>])
		
<?fmt linebreak?>
		⇒
		col_cellsequence(<emphasis>col</emphasis>, <emphasis>s</emphasis>)]
		</para></listitem></itemizedlist>
	    </para><para>Finally, we specify rules for the cell_text predicate.
	    <itemizedlist><listitem><para>(∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>, <emphasis>s</emphasis>)
		(<emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ)
		
<?fmt linebreak?>
		[(this_table(<emphasis>x</emphasis>) ∧ table(<emphasis>y</emphasis>) ∧ table_cell(<emphasis>c</emphasis>, <emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>)
		and tableCellContent(<emphasis>x</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>, <emphasis>s</emphasis>))
		
<?fmt linebreak?>
		⇒
		cell_text(<emphasis>c</emphasis>, <emphasis>s</emphasis>)]
		</para></listitem></itemizedlist>
	    </para></section><section xml:id="s2s1-2x3"><title>The <emphasis>S</emphasis><subscript>2</subscript> → <emphasis>S</emphasis><subscript>1</subscript> translation inference rules</title><para>And conversely, we can translate from the vocabulary of <emphasis>S</emphasis><subscript>2</subscript> into that 
            of <emphasis>S</emphasis><subscript>1</subscript> by these rules:
            <itemizedlist><listitem><para>
		  (∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>)
		  
<?fmt linebreak?>
		  [table(<emphasis>x</emphasis>) ⇒ this_table(<emphasis>y</emphasis>)]
		</para></listitem><listitem><para>
		  (∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>, <emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ)
		  
<?fmt linebreak?>
		  [(table(<emphasis>x</emphasis>) ∧ this_table(<emphasis>y</emphasis>)
		  ∧ headingcell(<emphasis>c</emphasis>)
		  ∧ table_cell(<emphasis>c</emphasis>, <emphasis>x</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>))
		  
<?fmt linebreak?>
		  ⇒
		  isTableHeader(<emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>)]
		</para></listitem><listitem><para>
		  (∀ <emphasis>x</emphasis>, <emphasis>y</emphasis>, <emphasis>c</emphasis>, <emphasis>s</emphasis>, <emphasis>i</emphasis> ∈ ℕ, <emphasis>j</emphasis> ∈ ℕ)
		  
<?fmt linebreak?>
		  [(table(<emphasis>x</emphasis>) ∧ this_table(<emphasis>y</emphasis>)
		  ∧ cell(<emphasis>c</emphasis>)
		  ∧ table_cell(<emphasis>c</emphasis>, <emphasis>x</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>))
		  ∧ cell_text(<emphasis>c</emphasis>, <emphasis>s</emphasis>))
		  
<?fmt linebreak?>
		  ⇒
		  tableCellContent(<emphasis>y</emphasis>, <emphasis>i</emphasis>, <emphasis>j</emphasis>, <emphasis>s</emphasis>)]		  
		</para></listitem></itemizedlist>
            </para><para>Note that no translation rules are listed which 
	    allow us to infer any instances of the <emphasis>S</emphasis><subscript>1</subscript> predicates
	    tableWidth, tableMarginLeft, tableCellBackgroundColor,
	    tableCellVerticalAlign, tableCellBorderWidth, or
	    tableCellBorderStyles.  This reflects the fact that
	    the set of enumerations <emphasis>S</emphasis><subscript>1</subscript> includes an analysis of
	    the CSS styling for the XHTML table, while
	    the Oasis Exchange Model (CALS) encoding of the table
	    lacks such style information.
	    As a consequence, here <emphasis>D</emphasis><subscript>1</subscript> and <emphasis>D</emphasis><subscript>2</subscript> are not equivalent;
	    instead, <emphasis>D</emphasis><subscript>2</subscript> subsumes <emphasis>D</emphasis><subscript>1</subscript>.
	    </para></section></section><section xml:id="prolog"><title>In Prolog</title><para>The logic outlined above has been translated into Prolog
          to demonstrate that the inferences required are automatically
          derivable.<footnote><para>It must be admitted that the
	  sentences enumerated in the Prolog are not quite identical
	  to those given in the predicate-calculus versions given
	  above, owing to changes during the preparation of the paper
	  in our understanding of the best way to formulate the
	  logical descriptions of tables.  Of course, some changes
	  of detail are required by the nature of Prolog.
	</para></footnote>
	  The following files are available in the appendices to this paper:<footnote><para>In addition to the versions given in the appendices, these
	  files are available on the Web at the project's web site:
	  <link xlink:href="http://mlcd.blackmesatech.com/mlcd/2014/W/document-equivalence/samples/toy1-new-cut-with-predic-prefixes/y.pl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Set <emphasis>S</emphasis><subscript>1</subscript></link>,
	  <link xlink:href="http://mlcd.blackmesatech.com/mlcd/2014/W/document-equivalence/samples/toy1-new-cut-with-predic-prefixes/m.pl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Set <emphasis>S</emphasis><subscript>2</subscript></link>, 
	  <link xlink:href="http://mlcd.blackmesatech.com/mlcd/2014/W/document-equivalence/samples/toy1-new-cut-with-predic-prefixes/y_to_m.pl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The <emphasis>S</emphasis><subscript>1</subscript> → <emphasis>S</emphasis><subscript>2</subscript> translation inference rules</link>,
	  <link xlink:href="http://mlcd.blackmesatech.com/mlcd/2014/W/document-equivalence/samples/toy1-new-cut-with-predic-prefixes/m_to_y.pl" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">The <emphasis>S</emphasis><subscript>2</subscript> → <emphasis>S</emphasis><subscript>1</subscript> translation inference rules</link>.	  
	  </para></footnote>
          <itemizedlist><listitem><para><!--* <link xlink:href="samples/toy1-new-cut-with-predic-prefixes/y.pl">Set <emphasis>S</emphasis><subscript>1</subscript></link> *-->
	  <!--* <link xlink:href="Bal2014Sper051809.pl">Set <emphasis>S</emphasis><subscript>1</subscript></link> *-->
	  Set <emphasis>S</emphasis><subscript>1</subscript> is in <xref linkend="s1.prolog"/>.
	  </para></listitem><listitem><para><!--* <link xlink:href="samples/toy1-new-cut-with-predic-prefixes/m.pl">Set <emphasis>S</emphasis><subscript>2</subscript></link> *-->
	  <!--* <link xlink:href="Bal2014Sper051810.pl">Set <emphasis>S</emphasis><subscript>2</subscript></link> *-->
	      Set <emphasis>S</emphasis><subscript>2</subscript> is in
	  <xref linkend="s2.prolog"/>.
	  </para></listitem><listitem><para><!--* <link xlink:href="samples/toy1-new-cut-with-predic-prefixes/y_to_m.pl">The <emphasis>S</emphasis><subscript>1</subscript> &#x2192; <emphasis>S</emphasis><subscript>2</subscript> translation inference rules</link> *-->
	  <!--* <link xlink:href="Bal2014Sper051811.pl">The
	  <emphasis>S</emphasis><subscript>1</subscript> &#x2192;
	  <emphasis>S</emphasis><subscript>2</subscript> translation
	  inference rules</link> *-->
	      The <emphasis>S</emphasis><subscript>1</subscript>
	      → <emphasis>S</emphasis><subscript>2</subscript> 
	      translation inference rules are in 
	      <xref linkend="s1-s2.prolog"/>.
	    </para></listitem><listitem><para><!--* <link xlink:href="samples/toy1-new-cut-with-predic-prefixes/m_to_y.pl">The <emphasis>S</emphasis><subscript>2</subscript> &#x2192; <emphasis>S</emphasis><subscript>1</subscript> translation inference rules</link> *-->
	  <!--* <link xlink:href="Bal2014Sper051812.pl">The
	  <emphasis>S</emphasis><subscript>2</subscript> &#x2192;
	  <emphasis>S</emphasis><subscript>1</subscript> translation
	  inference rules</link> *-->
	    The <emphasis>S</emphasis><subscript>2</subscript>
	      → <emphasis>S</emphasis><subscript>1</subscript> 
	      translation inference rules are in <xref linkend="s2-s1.prolog"/>.</para></listitem></itemizedlist>
          The two sets of translation inference rules adopt the convention
          of defining two predicates with standard names:
          <itemizedlist><listitem><para><code>individuals</code> asserts the existence of
            all the individuals mentioned in the target set of 
            sentences, using a Skolem function (<code>gensym</code>)
            to create a name for the individual, and asserting the
            uniquely identifying predicate for that individual.</para></listitem><listitem><para><code>obligations</code> consists of a conjunction
            of all the ground facts of the target set of sentences,
            using appropriately bound variables in place of the 
            identifiers actually used in the target set.</para></listitem></itemizedlist>
          </para></section></section><section xml:id="winita"><title>Further work</title><para>Several questions arise from the operational
	    definitions offered here of document equivalence,
	    subsumption, compatibility, and contradiction.</para><para><emphasis>Can the constraints given above on the form
	taken by the enumerations for a given document be
	relaxed?</emphasis>
        </para><para><emphasis>Given two compatible documents in a given vocabulary <emphasis>V</emphasis>,
        is it always, sometimes, or never possible to generate 
        documents in <emphasis>V</emphasis> representing the meet and the join of the
        two initial documents?</emphasis>
        We conjecture that it is sometimes possible, depending on
        properties of the vocabulary <emphasis>V</emphasis> and the specific information
        in the two documents.  This conjecture leads to another question:
        </para><para><emphasis>Is it possible to design a vocabulary <emphasis>V</emphasis> so as
        to ensure that the meet and the join of arbitrary sets of
        documents is always representable?</emphasis>
        If it is not possible to guarantee that the meet and join
        are always representable, can we increase the likelihood
        that it's representable for interesting cases?
        </para><para><emphasis>Can the technique described here scale up to
        full colloquial XML vocabularies like JATS, DocBook,
        TEI, and HTML?  Or even to full table markup in the
        CALS and XHTML table models?</emphasis>  We believe so, but
        cannot exhibit a full formal description of any
	colloquial XML vocabulary.
        </para><para><emphasis>For two given vocabularies <emphasis>V</emphasis><subscript>1</subscript> and <emphasis>V</emphasis><subscript>2</subscript>, is it
        possible to generalize about the relative position in the
        lattice of documents in <emphasis>V</emphasis><subscript>1</subscript> and <emphasis>V</emphasis><subscript>2</subscript>?</emphasis>  Is it
        possible (and if so, how can it be done?) to define <emphasis>V</emphasis><subscript>1</subscript> and <emphasis>V</emphasis><subscript>2</subscript> 
        such that
        <itemizedlist><listitem><para>No document <emphasis>D</emphasis><subscript>1</subscript> in vocabulary <emphasis>V</emphasis><subscript>1</subscript> is equivalent
          to any document <emphasis>D</emphasis><subscript>2</subscript> in <emphasis>V</emphasis><subscript>2</subscript>.</para></listitem><listitem><para>Every document <emphasis>D</emphasis><subscript>1</subscript> in vocabulary <emphasis>V</emphasis><subscript>1</subscript> has at least
          one equivalent document <emphasis>D</emphasis><subscript>2</subscript> in <emphasis>V</emphasis><subscript>2</subscript>.</para></listitem><listitem><para>Every document
	    <emphasis>D</emphasis><subscript>1</subscript> in vocabulary
	    <emphasis>V</emphasis><subscript>1</subscript> can be
	    reached by a down-translation from some document
	    <emphasis>D</emphasis><subscript>2</subscript> in
	    <emphasis>V</emphasis><subscript>2</subscript> (i.e. for
	    every <emphasis>D</emphasis><subscript>1</subscript>, there
	    exists some <emphasis>D</emphasis><subscript>2</subscript>
	    such that the join of
	    <emphasis>D</emphasis><subscript>1</subscript> and
	    <emphasis>D</emphasis><subscript>2</subscript> is
	    <emphasis>D</emphasis><subscript>2</subscript>).</para></listitem></itemizedlist>
        </para><!--*
	<note><para>Note to reviewers:</para><para>Before the conference, the authors expect to produce
          a few more examples in the same vein, perhaps exercising
          more of the semantic challenges of CALS table markup
	  and coming closer to a full treatment of the two table
	  models.
          We also expect to translate the examples into Alloy
          (the modeling tool produced at MIT by Daniel Jackson and
          his collaborators), to underscore the point that the 
          purpose of the paper is to describe an effective procedure
          for comparison of the information content of documents,
          and not to describe a particular programming-language-specific
          technique.</para></note>
          *--></section><appendix xml:id="s1.prolog"><title>Sentence set
    <emphasis>S</emphasis><subscript>1</subscript></title><programlisting xml:space="preserve">% Prolog equivalent of S1 sentences
%
% Revisions
%
% 2014-04-18 : YM : added y/m prefix to each (exported) predicate
% 2014-04-15 : YMA :	reintroduced the module definition (no change)
% 2014-04-12 : YMA :	various major revisions
% 2014-04-08 : CMSMcQ : supply uniquely identifying predicate for T
%                       extend with style rules
%                       remove general rules to y_general.pl
% 2014-04-03 : CMSMcQ : initial translation from table_trial_YM.txt

:- module(y, [y_this_table/1,
	      y_table_dimensions/3,
	      y_cell/3,
	      y_table_consistent/1,
	      y_tableWidth/2,
	      y_tableMarginLeft/2,
          y_isTableHeader/3,
          y_tableCellContent/4,
	      y_tableCellBackgroundColor/4,
	      y_tableCellVerticalAlign/4,
	      y_tableCellBorderWidth/4,
	      y_tableCellBorderStyle/4
	     ]).

% Individuals: for each individual that needs one, we have a uniquely
% identifying predicate. (Here, we have only one individual needing
% such a predicate:  the table.)
% t is a table; it is the only individual we identify
% apart from the natural numbers and the strings

y_this_table(t).

y_tableWidth(t,"80%").
y_tableMarginLeft(t,"10%").

y_isTableHeader(t, 1, 1).
y_isTableHeader(t, 1, 2).

y_tableCellContent(t, 1, 1, "Année").
y_tableCellContent(t, 1, 2, "Événement").

y_tableCellContent(t, 2, 1, "1969").
y_tableCellContent(t, 3, 1, "1992").

y_tableCellContent(t, 2, 2, "Création d'ARPANET, le premier réseau national américain d'ordinateurs, par le Defense Department's Advanced Research Projects Agency (DARPA)").
y_tableCellContent(t, 3, 2, "Mise en service du World Wide Web par le CERN (Centre européen de recherche nucléaire), en Suisse").

% Uncomment to test for incorrectness
% y_tableCellContent(t, 4, 4, "Extraneous").

% The style is consistent across cells in the table, so we can
% have some general rules.

y_cell(T,R,C) :- y_tableCellContent(T, R, C, _).

y_tableCellBackgroundColor(t,R,C,"#CCCCCC") :- y_isTableHeader(t,R,C).
y_tableCellVerticalAlign(t,R,C,"top") :- y_cell(t,R,C).
y_tableCellBorderWidth(t,R,C,"thin") :- y_cell(t,R,C).
y_tableCellBorderStyle(t,R,C,"solid") :- y_cell(t,R,C).

% General rules about tables. We formulate some of these as tests of
% consistent description for a table.

table_nonempty_finite_rectangular_and_dense(T) :-
	y_cell(T, R, C),
	\+ (
		y_cell(T, Row, Col),
		(Row &gt; R;
		Col &gt; C)
	   ;
		between(1, R, Row),
		between(1, C, Col),
		(\+ y_cell(T, Row, Col))
	   ).

table_properties_ok(T) :-
	\+ (has_properties(T,Row,Col),
	      \+ cell(T,Row,Col)).

has_properties(T, R, C) :-
	y_isTableHeader(T,R,C);
	y_tableCellBackgroundColor(T,R,C,_);
	y_tableCellVerticalAlign(T,R,C,_);
	y_tableCellBorderWidth(T,R,C,_);
	y_tableCellBorderStyle(T,R,C,_).

y_table_consistent(T) :-
	table_nonempty_finite_rectangular_and_dense(T),
	table_properties_ok(T).

y_table_dimensions(T,Row,Col) :-
% This is not a validity check, but rather a simple way
% to compute a table's dimensions.
% Note: Reliable only if table_nonempty_finite_rectangular_and_dense(T)
	y_cell(T,Row,Col),
	R is Row + 1,
	C is Col + 1,
	\+ y_cell(T, R, 1),
	\+ y_cell(T, 1, C).
</programlisting></appendix><appendix xml:id="s2.prolog"><title>Sentence set
    <emphasis>S</emphasis><subscript>2</subscript></title><programlisting xml:space="preserve">% S2 Inferences from the XHTML table

% 2014-04-18 : YM : added y/m prefix to each (exported) predicate
% 2014-04-17 : YM :  Corrected definitions of row(R) and col(C)
                     (R and C were at a wrong place in the predicate
                     on the right)
% 2014-04-08 : MSM : add uniquely identifying predicates for all
%                    individuals.
% 2014-03-21 : MSM : transcribed ---28.

:- module(m, [m_headingcell/1,
	      m_datacell/1,
	      m_cell/1,
	      m_row/1,
	      m_column/1,
	      m_this_table/1,
	      m_table_row/3,
	      m_table_column/3,
	      m_table_cell/4,
	      m_table_rowsequence/2,
	      m_table_colsequence/2,
	      m_row_cellsequence/2,
	      m_col_cellsequence/2,
	      m_cell_text/2,
	      m_table_row/2,
	      m_table_col/2,
	      m_table_cell/2,
	      m_row_cell/2,
	      m_col_cell/2]).

% Individuals
m_this_table(t1).
m_table_row(r1, t1, 1).
m_table_row(r2, t1, 2).
m_table_row(r3, t1, 3).
m_table_column(c1, t1, 1).
m_table_column(c2, t1, 2).

% convention:  cell X, Y is cXY
m_table_cell(c11,t1,1,1).
m_table_cell(c21,t1,1,2).
m_table_cell(c12,t1,2,1).
m_table_cell(c22,t1,2,2).
m_table_cell(c13,t1,3,1).
m_table_cell(c23,t1,3,2).

% basic classes
m_row(R) :- m_table_row(R,_T,_N).
m_column(C) :- m_table_column(C,_T,_N).
m_headingcell(c11).
m_headingcell(c21).
m_datacell(c12).
m_datacell(c22).
m_datacell(c13).
m_datacell(c23).

% Relations
%

m_table_rowsequence(t1, [r1, r2, r3]).
m_table_colsequence(t1, [c1, c2]).

m_row_cellsequence(r1, [c11, c21]).
m_row_cellsequence(r2, [c12, c22]).
m_row_cellsequence(r3, [c13, c23]).

m_col_cellsequence(c1, [c11, c12, c13]).
m_col_cellsequence(c2, [c21, c22, c23]).

m_cell_text(c11, "Année").
m_cell_text(c21, "Événement").
m_cell_text(c12, "1969").
m_cell_text(c22, "Création d'ARPANET, le premier réseau national américain d'ordinateurs, par le Defense Department's Advanced Research Projects Agency (DARPA)").
m_cell_text(c13, "1992").
m_cell_text(c23, "Mise en service du World Wide Web par le CERN (Centre européen de recherche nucléaire), en Suisse").


% Synonyms / analytic sentences
% These are not essential, but may be convenient to have.

m_cell(X) :- m_headingcell(X).
m_cell(X) :- m_datacell(X).

m_table_row(T,R) :- m_this_table(T), m_row(R), m_table_rowsequence(T,Rs), member(R,Rs).
m_table_col(T,C) :- m_this_table(T), m_column(C), m_table_colsequence(T,Cs), member(C,Cs).
m_row_cell(R,C) :- m_row(R), m_cell(C), m_row_cellsequence(R,Cs), member(C,Cs).
m_col_cell(Col,Cell) :- m_column(Col),
	m_cell(Cell),
	m_col_cellsequence(Col, Cells),
	member(Cell,Cells).

m_table_cell(T,C) :- 
	m_this_table(T),
	m_cell(C),
	m_row(R),
	m_table_row(T,R),
	m_row_cell(R,C).

m_table_cell(T,C) :-
	m_this_table(T),
	m_cell(C),
	m_column(C2),
	m_table_col(T,C2),
	m_col_cell(C2,C).
</programlisting></appendix><appendix xml:id="s1-s2.prolog"><title>The <emphasis>S</emphasis><subscript>1</subscript>
	      → <emphasis>S</emphasis><subscript>2</subscript> 
	      translation inference rules</title><programlisting xml:space="preserve">% S1 to S2: translation rules from Y sentences to M sentences.
%
% 2014-04-18 : YM : added y/m prefix to each (exported) predicate
% 2014-04-17 : YMA :	added M goals at the end
% 2014-04-08 : CMSMcQ : revise for new y.pl and new m.pl
% 2014-04-03 : CMSMcQ : first version
%
% Our job is to define the predicates exported from m.pl
% in terms of the vocabulary in y.pl.  Or at least the
% predicates used for ground facts.
%
% So:  to define are first the uniquely identifying predicates:
%
% m_this_table/1,
% m_table_row/3,
% m_table_column/3,
% m_table_cell/4
%
% And then the other predicates:
%
% m_headingcell/1,
% m_datacell/1,
% m_cell/1,
% m_row/1,
% m_column/1,
% m_table_rowsequence/2,
% m_table_colsequence/2,
% m_row_cellsequence/2,
% m_col_cellsequence/2,
% m_cell_text/2,
% m_table_row/2,
% m_table_col/2,
% m_table_cell/2,
% m_row_cell/2,
% m_col_cell/2.

% And we are given:
% y_this_table/1, y_cell/3, y_table_dimensions/3, y_table_consistent/1,
% y_tableWidth/2, y_tableMarginLeft/2, y_isTableHeader/3, y_tableCellContent/4,
% y_tableCellBackgroundColor/4, y_tableCellVerticalAlign/4,
% y_tableCellBorderWidth/4, y_tableCellBorderStyle/4

% First, assert the existence of appropriate individuals.

individuals :-
	abolish(m_this_table/1),
	known_table,
	abolish(m_table_row/3),
	known_rows,
	abolish(m_table_column/3),
	known_columns,
	abolish(m_table_cell/4),
	known_cells.

known_table :- 
	gensym('m', T),
	assertz(m_this_table(T)).
known_rows :- y_this_table(T0), m_this_table(T),
	y_table_dimensions(T0, RowCount, _ColCount),
	(   between(1,RowCount,RowNum),
	    gensym('m',R),
	    assertz(m_table_row(R, T, RowNum)),
	    fail
	)
	;
	true.
known_columns :- y_this_table(T0), m_this_table(T),
	y_table_dimensions(T0, _RowCount, ColCount),
	(   between(1,ColCount,ColNum),
	    gensym('m',C),
	    assertz(m_table_column(C, T, ColNum)),
	    fail
	)
	;
	true.
known_cells :- y_this_table(T0), m_this_table(T),
	y_table_dimensions(T0, RowCount, ColCount),
	(   between(1, RowCount, RowNum),
	    between(1, ColCount, ColNum),
	    gensym('m',Cell),
	    assertz(m_table_cell(Cell, T, RowNum, ColNum)),
	    fail
	)
	;
	true.

% m_headingcell/1

m_headingcell(H) :- y_this_table(T0),
	y_isTableHeader(T0,Row,Col),
	m_this_table(T1),
	m_table_cell(H,T1,Row,Col).

% m_datacell/1,

m_datacell(D) :- y_this_table(T0),
	y_cell(T0,Row,Col),
	\+ (y_isTableHeader(T0,Row,Col)),
	m_this_table(T1),
	m_table_cell(D, T1, Row, Col).

% m_cell/1,

m_cell(Cell) :- y_this_table(T0),
	y_cell(T0, Row, Col),
	m_this_table(T1),
	m_table_cell(Cell, T1, Row, Col).

% m_row/1,
m_row(R) :- y_this_table(T0),
	y_table_dimensions(T0, RowCount, _ColCount),
	between(1, RowCount, RowNum),
	m_this_table(T1),
	m_table_row(R, T1, RowNum).

% m_column/1,
m_column(R) :- y_this_table(T0),
	y_table_dimensions(T0, _RowCount, ColCount),
	between(1, ColCount, ColNum),
	m_this_table(T1),
	m_table_column(R, T1, ColNum).

% m_this_table/1,
% taken care of by the 'individuals' predicate.

% the following are all derivative.  If we can prove the
% ground facts, they all follow.
% m_table_row/3,
% m_table_column/3,
% m_table_cell/4,

% m_table_rowsequence/2,
m_table_rowsequence(T, Rows) :-
	y_this_table(T0), m_this_table(T),
	y_table_dimensions(T0, RowCount, _ColCount),
	aux_rowseq(T, 1, RowCount, Rows).
aux_rowseq(Table, RowNum, RowCount, [Row|Rows]) :-
	RowNum &lt; RowCount,
	m_table_row(Row, Table, RowNum),
	NextRow is RowNum + 1,
	aux_rowseq(Table, NextRow, RowCount, Rows).
aux_rowseq(Table, N, N, [Row]) :-
	m_table_row(Row, Table, N).



% m_table_colsequence/2,
m_table_colsequence(T, Cols) :-
	y_this_table(T0), m_this_table(T),
	y_table_dimensions(T0, _RowCount, ColCount),
	aux_colseq(T, 1, ColCount, Cols).
aux_colseq(Table, ColNum, ColCount, [Col|Cols]) :-
	ColNum &lt; ColCount,
	m_table_column(Col, Table, ColNum),
	NextCol is ColNum + 1,
	aux_colseq(Table, NextCol, ColCount, Cols).
aux_colseq(Table, N, N, [Col]) :-
	m_table_column(Col, Table, N).


% m_row_cellsequence/2,
m_row_cellsequence(R,Cells) :-
	m_table_row(R, Table, RowNum),
	aux_rowcells(Table, RowNum, Cells).
aux_rowcells(Table, RowNum, Cells) :-
	y_this_table(T0),
	y_table_dimensions(T0, _RowCount, ColCount),
	aux2_rowcells(Table, RowNum, 1, ColCount, Cells).
aux2_rowcells(Table, RowNum, ColNum, ColCount, [Cell|Cells]) :-
	ColNum =&lt; ColCount,
	m_table_cell(Cell, Table, RowNum, ColNum),
	NextCol is ColNum + 1,
	aux2_rowcells(Table, RowNum, NextCol, ColCount, Cells).
aux2_rowcells(_Table, _RowNum, ColNum, ColCount, []) :-
	ColNum &gt; ColCount.


% m_col_cellsequence/2,
m_col_cellsequence(Col,Cells) :-
	m_table_column(Col, Table, ColNum),
	aux_colcells(Table, ColNum, Cells).
aux_colcells(Table, ColNum, Cells) :-
	y_this_table(T0),
	y_table_dimensions(T0, RowCount, _ColCount),
	aux2_colcells(Table, ColNum, 1, RowCount, Cells).
aux2_colcells(Table, ColNum, RowNum, RowCount, [Cell|Cells]) :-
	RowNum =&lt; RowCount,
	m_table_cell(Cell, Table, RowNum, ColNum),
	NextRow is RowNum + 1,
	aux2_colcells(Table, ColNum, NextRow, RowCount, Cells).
aux2_colcells(_Table, _ColNum, RowNum, RowCount, []) :-
	RowNum &gt; RowCount.

% m_cell_text/2,
m_cell_text(C, Chars) :-
	y_this_table(T0), m_this_table(T1),
	m_table_cell(C, T1, Row, Col),
	y_tableCellContent(T0, Row, Col, Chars).


obligations :-
	m_this_table(T),
	m_table_row(R1, T, 1),
	m_table_row(R2, T, 2),
	m_table_row(R3, T, 3),
	m_table_column(C1, T, 1),
	m_table_column(C2, T, 2),
	m_table_cell(C11, T, 1, 1),
	m_table_cell(C21, T, 1, 2),
	m_table_cell(C12, T, 2, 1),
	m_table_cell(C22, T, 2, 2),
	m_table_cell(C13, T, 3, 1),
	m_table_cell(C23, T, 3, 2),
	m_row(R1),
	m_row(R2),
	m_row(R3),
	m_column(C1),
	m_column(C2),
	m_headingcell(C11),
	m_headingcell(C21),
	m_datacell(C12),
	m_datacell(C22),
	m_datacell(C13),
	m_datacell(C23),
	m_table_rowsequence(T, [R1, R2, R3]),
	m_table_colsequence(T, [C1, C2]),
	m_row_cellsequence(R1, [C11, C21]),
	m_row_cellsequence(R2, [C12, C22]),
	m_row_cellsequence(R3, [C13, C23]),
	m_col_cellsequence(C1, [C11, C12, C13]),
	m_col_cellsequence(C2, [C21, C22, C23]),
	m_cell_text(C11, "Année"),
	m_cell_text(C21,"Événement"),
	m_cell_text(C12,"1969"),
	m_cell_text(C22,"Création d'ARPANET, le premier réseau national américain d'ordinateurs, par le Defense Department's Advanced Research Projects Agency (DARPA)"),
	m_cell_text(C13,"1992"),
	m_cell_text(C23,"Mise en service du World Wide Web par le CERN (Centre européen de recherche nucléaire), en Suisse").
</programlisting></appendix><appendix xml:id="s2-s1.prolog"><title>The <emphasis>S</emphasis><subscript>2</subscript> →
    <emphasis>S</emphasis><subscript>1</subscript> translation
    inference rules</title><programlisting xml:space="preserve">% m_to_y.pl:  translate from M sentences to Y sentences.
% Our job here is to define rules for
% all the predicates exported from y.pl, in
% terms of the rules in m.pl.

% 2014-04-18 : YM : added y/m prefix to each (exported) predicate
% 2014-04-17 : YM : added Y goals

% First, assert the existence of appropriate individuals
% (here, only one: the table).

individuals :-
	abolish(y_this_table/1),
    gensym('y',T),
	assertz(y_this_table(T)).

% y_isTableHeader/3
% y_isTableHeader(Table, Rownum, Colnum)
y_isTableHeader(Table0,Row,Col) :-
    m_this_table(Table1), 
	y_this_table(Table0),
	m_headingcell(Cell),
	table_cell_rownum(Table1, Cell, Row),
	table_cell_colnum(Table1, Cell, Col).

% y_tableCellContent/4
% y_tableCellContent(Table, Row, Column, String)
y_tableCellContent(Table0, Row, Col, String) :-
	m_this_table(Table1), 
	y_this_table(Table0),
	m_cell(Cell),
	table_cell_rownum(Table1, Cell, Row),
	table_cell_colnum(Table1, Cell, Col),
	m_cell_text(Cell, String).

table_cell_rownum(Table,Cell,Rownum) :-
	m_this_table(Table),
	m_row(Row),
	m_table_rowsequence(Table,Rows),
	nth1(Rownum,Rows,Row),
	m_cell(Cell),
	m_row_cellsequence(Row,Cs),
	member(Cell,Cs).

table_cell_colnum(Table, Cell, Colnum) :-
	m_this_table(Table),
	m_column(Column),
	m_table_colsequence(Table,Columns),
	nth1(Colnum,Columns,Column),
	m_cell(Cell),
	m_col_cellsequence(Column, Cells),
	member(Cell, Cells).


obligations :-
	y_this_table(Ty),

	y_isTableHeader(Ty, 1, 1),
	y_isTableHeader(Ty, 1, 2),

	y_tableCellContent(Ty, 1, 1, "Année"),
	y_tableCellContent(Ty, 1, 2, "Événement"),

	y_tableCellContent(Ty, 2, 1, "1969"),
	y_tableCellContent(Ty, 3, 1, "1992"),

	y_tableCellContent(Ty, 2, 2, "Création d'ARPANET, le premier réseau national américain d'ordinateurs, par le Defense Department's Advanced Research Projects Agency (DARPA)"),
	y_tableCellContent(Ty, 3, 2, "Mise en service du World Wide Web par le CERN (Centre européen de recherche nucléaire), en Suisse").
</programlisting></appendix><bibliography><title>References</title><bibliomixed xml:id="Oasis" xreflabel="Bingham 1995">
            
            Bingham, Harvey. <quote>Exchange Table Model Document Type 
            Definition</quote>  
            <emphasis>OASIS Technical Resolution</emphasis> TR 9503:1995. 
            <link xlink:href="https://www.oasis-open.org/specs/a503.htm" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">https://www.oasis-open.org/specs/a503.htm</link>
          </bibliomixed><bibliomixed xml:id="Marcoux2009" xreflabel="Marcoux 2009">
            Marcoux, Yves. 
            <quote>Intertextual semantics generation for structured documents: 
            a complete implementation in XSLT.</quote>
            <emphasis>Actes du 12e Colloque international sur 
            le Document Électronique (CiDE.12)</emphasis>, 
            Montréal, octobre 2009, pp. 159-170.
          </bibliomixed><bibliomixed xml:id="MR2009" xreflabel="Marcoux and Rizkallah 2009">
            Marcoux, Yves, and Élias Rizkallah. 
            <quote>Intertextual semantics: 
            A semantics for information design.</quote>
            <emphasis>Journal of the American Society for 
            Information Science &amp; Technology</emphasis>
            60.9 (2009): 1895-1906. 
            doi:<biblioid class="doi">10.1002/asi.21134</biblioid>.
          </bibliomixed><bibliomixed xml:id="CALS" xreflabel="Severson and Bingham 1995">
            
            Severson, Eric, and Harvey Bingham. <emphasis>TABLE INTEROPERABILITY: 
            Issues for the CALS Table Model</emphasis> <emphasis>OASIS Technical 
            Research Paper 9501:1995</emphasis>. 
            <link xlink:href="https://www.oasis-open.org/specs/a501.htm" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">https://www.oasis-open.org/specs/a501.htm</link>
          </bibliomixed><bibliomixed xml:id="msm2011" xreflabel="Sperberg-McQueen 2011">Sperberg-McQueen, C. M. 
	  		<quote>What constitutes successful format conversion? 
	  			Towards a formalization of ‘intellectual content’.</quote>
	  		<emphasis>International Journal of Digital Curation</emphasis>
	  		6.1 (2011): 153-164.
	  	</bibliomixed><bibliomixed xml:id="hrsm" xreflabel="Sperberg-McQueen/Huitfeldt/Renear 2001a">
            Sperberg-McQueen, C. M., Claus Huitfeldt, and Allen Renear.
            <quote>Meaning and interpretation of markup.</quote>
            <emphasis>Markup Languages: Theory &amp; Practice</emphasis>
            2.3 (2001): 215–234.
            <link xlink:href="http://www.w3.org/People/cmsmcq/2000/mim.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/People/cmsmcq/2000/mim.html</link>
          </bibliomixed><bibliomixed xml:id="pemm" xreflabel="Sperberg-McQueen/Huitfeldt/Renear 2001b">
            Sperberg-McQueen, C. M., Claus Huitfeldt, and Allen Renear. <quote>Practical extraction of meaning from markup.</quote> Paper
            given at ACH/ALLC 2001, New York, June 2001. (Slides at
            <link xlink:href="http://www.w3.org/People/cmsmcq/2001/achallc2001/achallc2001.slides.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/People/cmsmcq/2001/achallc2001/achallc2001.slides.html</link>)
          </bibliomixed><bibliomixed xml:id="allc-skeletons" xreflabel="Sperberg-McQueen et al. 2002">
            Sperberg-McQueen, C. M., Renear, A., Huitfeldt, C., and
            Dubin, D. Skeletons in the closet: Saying what markup means. Paper 
          given at ALLC/ACH, Tübingen, Germany, July 2002.</bibliomixed><bibliomixed xml:id="extreme2003" xreflabel="Sperberg-McQueen et al. 2003">
            Sperberg-McQueen, C. M., David
            Dubin, Claus Huitfeldt, and Allen Renear.  
            <quote>Drawing inferences
            on the basis of markup</quote>.  Extreme Markup Languages
            2003. 
            <link xlink:href="http://www.w3.org/People/cmsmcq/2002/EML2002Sper0518.final.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/People/cmsmcq/2002/EML2002Sper0518.final.html</link>
          </bibliomixed><bibliomixed xml:id="HTML4" xreflabel="HTML 4.01">
            
            W3C. <emphasis>Tables</emphasis> <emphasis>HTML 4.01 Specification</emphasis>
            W3C Recommendation 24 December 1999. 
            <link xlink:href="http://www.w3.org/TR/html401/struct/tables.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/html401/struct/tables.html</link>
          </bibliomixed><bibliomixed xml:id="WeltyIde99" xreflabel="Welty and Ide 1999">
            Welty, Christopher, and Nancy Ide. 1999. <quote>Using 
            the Right Tools: Enhancing Retrieval from Marked-up Documents.</quote>
            <emphasis>Computers and the Humanities</emphasis> 1999: 59-84. 
            Originally delivered at TEI 10, Providence(1997). 
          </bibliomixed><bibliomixed xml:id="Wetzel2009" xreflabel="Wetzel 2009">
            Wetzel, Linda. 
            <emphasis>Types &amp; tokens:  On abstrct objects</emphasis>.
	    Cambridge, Mass.; London:  MIT Press, 2009.
          </bibliomixed><bibliomixed xml:id="Wickett2010" xreflabel="Wickett 2010">
            
            Wickett, Karen M. <quote>Discourse situations and markup interoperability: An application of 
            situation semantics to descriptive metadata.</quote> 
            Presented at Balisage: The Markup Conference 2010, Montréal, Canada, August 3 - 6, 2010. 
            <emphasis>Proceedings of Balisage: The Markup Conference 2010. Balisage Series on Markup 
            	Technologies</emphasis>, vol. 5 (2010). doi:<biblioid class="doi">10.4242/BalisageVol5.Wickett01</biblioid>. 
            <link xlink:href="http://balisage.net/Proceedings/vol5/html/Wickett01/BalisageVol5-Wickett01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://balisage.net/Proceedings/vol5/html/Wickett01/BalisageVol5-Wickett01.html</link>
          </bibliomixed><bibliomixed xml:id="Wrightson2005" xreflabel="Wrightson 2005">
            Wrightson, Ann.
            <quote>Semantics of Well Formed XML as a Human and Machine Readable Language:
            Why is some XML so hard to read?</quote>.
            Extreme Markup Languages 2005, Montréal.         
            <link xlink:href="http://conferences.idealliance.org/extreme/html/2005/Wrightson01/EML2005Wrightson01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2005/Wrightson01/EML2005Wrightson01.html</link>
          </bibliomixed><bibliomixed xml:id="Wrightson2007" xreflabel="Wrightson 2007">
            Wrightson, Ann.
            <quote>Is it Possible to be Simple Without being Stupid?: Exploring the Semantics of Model-driven XML</quote>.
            Extreme Markup Languages 2007, Montréal.         
            <link xlink:href="http://conferences.idealliance.org/extreme/html/2007/Wrightson01/EML2007Wrightson01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2007/Wrightson01/EML2007Wrightson01.html</link>
          </bibliomixed></bibliography></article>