<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>Extending XQuery with pattern matching over XML, HTML and JSON, and its usage for data mining </title><!-- <subtitle>The lure of vegetable culture</subtitle>--><info><confgroup><conftitle>Balisage: The Markup Conference 2014</conftitle><confdates>August 5 - 8, 2014</confdates></confgroup><abstract><para> Pattern matching in a broad sense is a common feature of modern functional programming languages, answering the question, if one complex structured object has a form that is the same as another complex structured object, for some definition of “the same”. In XQuery path expressions, switch, and typeswitch statements are often described as performing pattern matching, but these are merely impoverished flavors of matching when compared to the real thing. 
      We describe a syntax for general pattern matching based on regular expressions for XML/HTML/JSONiq trees, how these patterns are matched against input data, and how this pattern matching can be integrated into the syntax and semantics of the XQuery language.<!--
      We describe a structured regular expression
      
       We demonstrate that this pattern matching can be used to match JSONiq as well as XML, 
      This paper presents an XQuery syntax extension for pattern matching on XML or HTML elements and JSONiq types, which can be used as a more intuitive alternative to path expressions. --><!-- can replace path expressions--><!--
      
      
      
      This paper presents an XQuery syntax extension for pattern matching on XML or HTML elements and JSONiq types, which can be used as a more intuitive alternative to path expressions.--> <!-- can replace path expressions--><!-- , implemented in our experimental XQuery engine--> <!--
      
      We describe the syntax of the patterns, how they are matched against input data, and how the patterns can be integrated within an XQuery expression. It ends with our positive and negative experiences when applying these patterns to large scale data mining of library systems.
      -->
      At the end we summarize real-world experience using it for large-scale data mining of library webcatalogs.  </para></abstract><author><personname><firstname>Benito</firstname><!--        <othername>/othername>--><surname>van der Zander</surname></personname><personblurb><para>Benito van der Zander is a graduate student at the University of Lübeck, working on the Ph.D. project "Algorithmics Of Causal Inference" investigating algorithms for Pearl's causality framework. Before his enrollment in that graduate school, he has developed the open-source XQuery engine <link xlink:href="http://xidel.sourceforge.net" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Xidel</link>. He received a computer science B.S. from the University of Düsseldorf, and a M.S. from the RWTH Aachen.  </para></personblurb><affiliation><!-- <jobtitle>Graduate student</jobtitle>--><orgname>Institute for Theoretical Computer Science </orgname></affiliation><affiliation><orgname>Graduate School for Computing in Medicine and Life Sciences, University of Lübeck</orgname></affiliation><email>benito@benibela.de</email><!--      <link xlink:href="http://www.benibela.de" >homepage</link>--></author><legalnotice><para>Copyright © 2014 Benito van der Zander</para></legalnotice><keywordset role="author"><keyword>Pattern matching</keyword><keyword>XQuery syntax extension</keyword><keyword>JSONiq syntax extension</keyword><keyword>Data mining</keyword></keywordset></info><section><title>Introduction</title><para>Modern XQuery is becoming a more and more functional programming language. Nowadays it has, for example,  filter and map operators, inline functions, higher order functions and sequence heads/tails. However, it still does not support any kind of pattern matching, although pattern matching is often considered one of the most remarkable features of functional programming. Some of them, like Haskell, even base their entire syntax on it.  In such languages a pattern matching algorithm takes an input value and one or more patterns, and searches the pattern that has the same internal structure as the input value, possibly extracting some data from the value.  </para><para>The most similar feature in XQuery is the <code>switch</code> expression that can be used for atomic values, which branches to a case clause of equal value. But, since it is limited to atomic values, it cannot be used for the majority of data used in XQuery, the XML infosets. </para><para>XML Schemas <!--are fully integrated in XQuery and -->could be used for matching these XML infosets in path or <code>typeswitch</code>-expressions. However, this matching cannot directly return data from the matched nodes and defining an XML Schema for schema-less input data (like HTML pages) can be cumbersome, since its definition requires an additional file and cannot occur within the XQuery itself. Also the definition of an XML Schema  is not implicit/intuitive like a pattern, but explicit by declaring every element and attribute by a special element, so it cannot really be considered pattern matching. </para><para>Sometimes the standard path expressions are called "pattern matching", but this is not correct either, since a path expression is also a list of explicitly applied filtering expressions, not an implicitly defined pattern. </para><para>In academics there are various different meanings  of the term "pattern matching", often it is used to denote any specific querying on XML trees, like in  [<xref linkend="rel2"/>] or [<xref linkend="rel3"/>]. Or in another direction, [<xref linkend="rel1"/>] considers pattern matching as finding specially ordered subsequences in sequences, similarly to regular expressions on sequences of letters. None of this is pattern matching in our sense. We consider a pattern to be an exemplary part of an XML (HTML, JSON) document that is compared to an input document, detecting if the input document contains the pattern, and which parts of the input document were added. 
     </para><para>
     More specifically, but also figuratively, a pattern can be considered a tree with holes, and during matching we must test if the tree of an input document contains the pattern tree as subtree, and which nodes of the document are matched to/fall into  the "holes".
     
<!--     keeps the tree structure of the original document and can be compared to similar documents, detecting if the document contains the pattern as subtree and finding the parts that are in th.--> <!-- matches 
      has to be compared to the input data, detecting if it matches, and which parts were omitted.--> <!--during the matching needs to be found in the input data and filled with the remaining part. --></para><!--    <para>Pattern matching is often considered one of the most remarkable features of functional programming languages. Some of them, like Haskell, even base their entire syntax on it. </para>
    
    <para>
      With the introduction of inline functions, higher order functions and sequence heads/tails XQuery is becoming a more and more functional language, yet it still has no true pattern matching. This paper describes a possible syntax for pattern matching, how these patterns can return selected data and how these patterns can be used in XQuery in a natural way. We conclude with our experiences of applying these patterns to HTML pages, and possible future work.
    </para>--><para><!--So, for examples of existing approaches<footnote><para>Which we were, for the record, not aware of when developing our original pattern matching.</para></footnote>  for pattern matching on XML we need to look outside of XQuery:-->
     To see examples of such patterns, we need to look outside of XQuery and the common XML research:</para><para>One of the first query languages using true XML pattern matching was XML-QL [<xref linkend="xmlql"/>],   an early attempt to develop an XML query language which combines SQL with XML pattern matching. However it has never evolved beyond drafting state and appears to have been forgotten in favor of XQL the predecessor of XQuery. It is even unclear, if there has ever existed an implementation of XML-QL. Its pattern matching as such is more expressive than ours, but since it cannot use the matched values in a Turing-complete functional language, it is in total less powerful than our system. </para><para>Another example is the language Scala [<xref linkend="scala"/>], which tries to combine functional and object-oriented programming concepts. It can perform true pattern matching on all of its objects, and has XML literals as abbreviations for XML elements, so it can naturally  perform pattern matching on XML elements. However, it cannot do this on elements with attributes and is therefore of limited use. </para><!--     <para>[reg ex ??todo ]</para>--><!--None of these languages are widely used as query languages, probably because they lack the expressiveness and flexibility of XQuery or XSLT.  By combining patterns with a full XQuery implementation our language obtains the advantages of both designs.--><para>This paper brings these concepts to XQuery by describing a possible syntax for XML pattern matching, how these patterns can return selected data and how these patterns can be used in XQuery in a natural way. We conclude with our experiences of applying these patterns to HTML pages, and possible future work. We do not investigate theoretical implications or efficient ways to implement it, instead we want to develop an easy and powerful syntax that can be practically used.
         </para><para>The pattern matching described here<!--in this paper--> is an idealized variant of the actual pattern matching in our implementation<footnote><para>Available as standalone version under the name "<link xlink:href="http://xidel.sourceforge.net" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Xidel</link>" as command line tool and <link xlink:href="http://videlibri.sourceforge.net/cgi-bin/xidelcgi" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">webservice</link>, and under the name "<link xlink:href="https://github.com/benibela/internettools" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Internet Tools</link>" as  GPL library for FreePascal.<!-- and "VideLibri" (the umbrella project the engine and pattern matching was developed for). Although the function <code>pxp:match</code> exists in our implementation it is there not written in XQuery and depends on our own special features.--></para></footnote>. On the one hand, some logical extensions explained here have not  yet been implemented, and on the other hand, our implementation has features we do not mention, because they are deprecated or would cause confusion.	</para><para>We assume the reader is familiar with the XML  [<xref linkend="xml"/>], XQuery  [<xref linkend="xquery"/>] and JSONiq  [<xref linkend="jsoniq"/>] standards, so terms and definitions given there will not be repeated.</para><!-- Our system was designed to extract data from  HTML pages, so there was no point to handle typed data.    --></section><section><title>The pattern syntax<!--\section{syntax}--></title><!--In the ideal case a pattern fulfills the following properties:--><para>Our goal is to develop a pattern syntax that fulfills the following three properties:</para><itemizedlist><listitem><para><emphasis>Intuitive</emphasis>:</para><para> It should be obvious which data a pattern could match, even if you have never seen a pattern before. We realize this, first, by requiring that  a (basic) pattern has to match itself, if the pattern is given as input. Therefore the pattern is an illustrative example for itself. <!--you have an example input data just by looking at a pattern.--> And, second, by basing most of the syntax on regular expressions which should be familiar to any programmer.</para></listitem><listitem><para><emphasis>Validating</emphasis>:</para><para>When matched against not-matching, unexpected input data the pattern should raise an error, instead returning something arbitrary. (unlike a simple path expression that returns an empty sequence on failure.  )</para></listitem><listitem><para><emphasis>Minimal</emphasis>:</para><para> There should be no pointless redundancy or data not relevant to the query within a pattern. This means that all additional data in the input should be ignored during matching, so we can exclude unimportant data from the pattern.</para></listitem></itemizedlist><para>From the first and third property (and later given examples) it follows that it is also easy to create a pattern to match a given input, since the pattern can be created by copying the input data, completely removing all data that should not be queried for, replacing the remaining data with annotations and finally calling it a pattern. We hope that this is even easy for people who only have knowledge of XML/HTML and no real programming language, since they do not have to write anything new,  contrary to a path expression.</para><para>There is, however, a conflict between the second and third property, which cannot be resolved in general. By ignoring additional data a pattern might match a completely different input document successfully, which was not intended to be accepted as a match, but contains matching data somewhere within it. So for any actual pattern, it must be carefully decided what to include and exclude from the pattern. Nevertheless the third property is important, because the (HTML) documents we are processing contain far too much noise to include it all in the pattern. </para><section xml:id="sec_basic"><title>Basic node matching</title><para>Due to the intuitiveness goal the pattern itself has to be a well-formed XML document (resp. fragment). We can therefore define the basic "matching" as recursive relation between a node of the pattern and a node of the input as follows:<!-- recursively as follows:--></para><itemizedlist><listitem><para>
      A <emphasis>text node</emphasis> matches another text node, if they have matching string values.
      </para></listitem><listitem><para>
      An <emphasis>attribute</emphasis> matches another attribute, if they have the same name and matching string values. 
      </para></listitem><listitem><para>
<!--      A XML element <code>&lt;e></code> matches an element <code>&lt;f></code>, if <code>&lt;f></code> has the same name, matching attributes and matching descendants.-->
      An  <emphasis>element</emphasis> <code>E</code> matches another element <code>F</code>, if they have the same name, every attribute of <code>E</code> matches an attribute of <code>F</code> and every child of <code>E</code> matches a descendant of <code>F</code> in order. <!-- there exists a matching attribute (unordered) resp. descendant (ordered) for each of its attributes resp. children. --> <!--, matching attributes and matching descendants.-->
      </para></listitem></itemizedlist><para>An exact definition for "matching string values" is given below. The property "in order" of the last point means: if a child <code>C</code> of <code>E</code> matches a descendant <code>X</code> of <code>F</code> and another child <code>D</code> of <code>E</code> matches a descendant <code>Y</code> of <code>F</code>, <code>C</code> precedes <code>D</code> in the pattern if and only if <code>X</code> precedes <code>Y</code> in the document. </para><para>
      Trivial examples are the pattern <code>&lt;foo/&gt;</code> matching an identical input document <code>&lt;foo/&gt;</code> or a text node pattern <code>foo</code> matching an identical text node <code>foo</code>.
      A more meaningful example is the pattern
      
      <programlisting xml:space="preserve">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</programlisting>
      
      that matches <programlisting xml:space="preserve">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</programlisting> or (ignoring additional data) <programlisting xml:space="preserve">&lt;element foo="bar" att="value"&gt;&lt;p&gt;cat&lt;call&gt;&lt;meow loudness="60 dB"/&gt;&lt;/call&gt;&lt;/p&gt;&lt;/element&gt;</programlisting> but neither (missing attribute) <programlisting xml:space="preserve">&lt;element&gt;cat&lt;meow/&gt;&lt;/element&gt;</programlisting> nor (wrong name) <programlisting xml:space="preserve">&lt;element foo="bar" xmlns="elsewhere"&gt;cat&lt;meow/&gt;&lt;/element&gt;</programlisting> nor (wrong order of descendants) <programlisting xml:space="preserve">&lt;element foo="bar"&gt;&lt;meow/&gt;cat&lt;/element&gt;</programlisting>
<!--

      , so we need to consider two different syntax aspects of the  that .
      
      <programlisting>text</programlisting>

      <programlisting><![CDATA[<element/>]]></programlisting>
      
      <programlisting><![CDATA[<element attribute="value"/>]]></programlisting>-->
      </para><para>
      We have not considered a syntax to match comment or processing-instruction nodes, since such nodes rarely contain data that should be returned by a query and    cannot contain a selector expression (see <link linkend="sec_selection" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">below</link>) as a child to select this data. Also the most natural way to match a comment node would be to include an <code>&lt;!-- .. --&gt;</code> XML comment node in the pattern, which is problematic in our application, because we use standalone patterns outside of XQuery, where  we prefer to use XML comments as actual comments that are ignored by the matching process. There is also no syntax to match document nodes, since it is always possible to match the root node of the document instead. </para><para>That a child in the pattern is allowed to match any descendant in the input, not only another child, follows the principle of ignoring additional data to keep the pattern minimal. </para><para>Requiring that the descendants have to occur in the same order as the children, instead accepting any order, has a few benefits. First, it follows the idea of patterns as XML regular expressions, which also match their letters ordered. Second, XQuery itself is good at selecting unordered elements, but very difficult [<xref linkend="rel1"/>] to use to select ordered elements<footnote><para>Many people do not even understand how to use the <code>following</code> or <code>preceding</code> axes, which becomes evident after watching   XPath questions on stackoverflow for a while.</para></footnote>, so the combination of XPath and patterns provides a simple and powerful solution for both cases. Third, the advanced pattern syntax contains natural, <link linkend="para_unordered" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">unrelated features</link> that can directly be used for unordered matching. It is doubtful that unordered matching could be used for ordered matching in such a way. </para><para>The conditions for text node matching could be relaxed to accept any node that has a matching string value, not just other text nodes. This might be useful, if the input data could sometimes contain markups like <code>&lt;em&gt;</code> within the text and sometimes not. However, we have not seen such a use case, and therefore have implemented the faster way to match text nodes only to text nodes.</para><para>
      <emphasis>String values</emphasis> can be matched using one of six different modes: <code>eq</code>, <code>matches</code>, <code>starts-with</code>, <code>ends-with</code>, <code>contains</code> and <code>list-contains</code>. <code>eq</code> checks for an exact match, like the <code>eq</code> operator. <code>list-contains</code> treats the string value as space separated list (e.g. like the class attribute of HTML elements) and matches, if the value of the pattern occurs in that list. The other modes match, if the call to the corresponding XQuery function, e.g. <code>fn:starts-with($value, $pattern)</code>, returns <code>true</code>.
      
      Additionally the matching can be case-sensitive or case-insensitive, in latter case, the values are first converted to lowercase resp. the <code>i</code> flag is passed to <code>fn:matches</code>.
      </para><para>
      Which  mode is chosen depends on the node whose string value is matched and the local settings. Due to legacy reasons, the default modes of our implementation are <code>starts-with</code> for text nodes, <code>list-contains</code> for <code>class</code>-attributes and <code>eq</code> for all other attributes<footnote><para>However, in a new, not HTML-focused implementation <code>matches</code> as default for everything might be a more reasonable choice.</para></footnote>. These modes can be changed within a pattern, similarly to the options described <link linkend="tmeta" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">below</link>.
      </para><para>There is no difference between matching a pattern to an XML document and matching it against a HTML document, except that node names are compared case sensitive for XML and case insensitive for HTML. </para><!--  of <code>&lt;e></code> matches an attributes and . and whose children match the children of the 
             template element.             
      
      
      
      
      <programlisting><![CDATA[<element>{.}</element>]]></programlisting>
      
      <programlisting><![CDATA[<element attribute="{.}"/>]]></programlisting>
      
      <programlisting>text</programlisting>
      
      
      --></section><section xml:id="sec_selection"><title>Selecting data<!--\subsection{selecting}--></title><para>So far we have only described how a pattern can be used to test if an input document has a certain structure. To become a real replacement for standard XPath selectors, we need a way to select specific data from the matches in the input document. In regular expressions such selecting can be done with capture groups, an idea  we need to transfer to the pattern syntax. <!-- but we find them too restrictive. Instead we allow arbitrary --> <!-- there should be a way to select specific data from the matches in the input document-->
       <!--Because we want to select specific data from that structure or the input document like it is possible to extract partial matches from a regular expression with capture groups, we have added selector expressions to the pattern syntax.
      These selectors can embed arbitrary XQuery expressions in a pattern, so .
        which follow an idea similar to the "capture groups" of regular expressions.  , so we extend the patterns to embed arbitrary XQuery expressions. </para>-->
        </para><para>For this we allow the  embedding of arbitrary XQuery expressions which will be evaluated in the context of partial matches and whose return values become the return values of the pattern matching. So in  case someone needs a query that does not just copy the matched data from the input document, but needs to perform certain calculations with the data, he can do it with all the power of XQuery. </para><!--We now--><!--introduce the syntax that allows--><!--extend the patterns to return the matched data, so the patterns are no longer restricted to only return a boolean value indicating a successful or failed match. To make the patterns as powerful as any possible XQuery expression, we will allow arbitrary XQuery selector expressions to be embedded within a pattern.--><!--by integrating arbitrary XQuery selector expressions within a pattern.  and become as powerful as any XQuery expression could be.--><!--  Patterns that only return a boolean flag if they match a node do not have much practical use, so we introduce a syntax to return .  --><!-- would not be interesting, if they  to check for a positive or negative match.  They can also return the .--><!--      <para>This requires a syntax to include queries within a pattern, an initialization of these queries such that they benefit from the previous matching, and a way to return data from these queries. </para>--><para>We have decided to allow the following ways to embed a query in the pattern:</para><para>
      
      <itemizedlist><listitem><para><code>{expression}</code>: A text node starting with <code>{</code> and ending with <code>}</code> is the shortest syntax to include an expression. The <code>{}</code> parentheses are used, because they correspond to the expression in a standard XQuery element constructor, and, more important, because every string starting with <code>{</code> is an invalid regular expression. So there is never a collision between a regular expression used to match text nodes and a selector expression.  </para></listitem><listitem><para><code>&lt;template:s&gt;expression&lt;/template:s&gt;</code>: A more standard syntax to include queries in an XML document. Although the <code>{...}</code> syntax does not collide with regex text matching, it is sometimes problematic to use. For example, if you want to have a text node for matching and a selector expression in the same parent node. So we have added the <code>&lt;s&gt;</code>-element in the namespace <code>http://www.benibela.de/2011/templateparser</code> (at default bound to the namespace prefixes <code>template</code><footnote><para>We usually refer to the patterns as "templates" in our implementation. However, "pattern" is a more appropriate term. </para></footnote> and <code>t</code>) that can also contain an expression.</para></listitem><listitem><para><code>&lt;t:s&gt;expression&lt;/t:s&gt;</code>:  This is actually identical to  <code>&lt;template:s&gt;expression&lt;/template:s&gt;</code> due to binding the same namespace to prefixes <code>template</code> and <code>t</code>, but faster to write being the shortest name a node  outside the default namespace can have. </para></listitem><listitem><para><code>attribute="{expression}"</code>: The <code>{}</code> syntax can also be used in attributes. In that case the attribute is replaced by a <code>t:condition</code> attribute (see <link linkend="tcondition" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">below</link>) just checking the existence of the old attribute, and a <code>&lt;t:s&gt;@attribute / (expression) &lt;/t:s&gt;</code> child node is inserted instead. E.g. <code>&lt;a href="{.}"/&gt;</code> to query for the url of a link target. </para></listitem></itemizedlist>
            
      </para><para>After the matching process each node of the pattern has been matched to a unique node of the input data. This node is then set as context item <code>.</code> when evaluating the query contained in the children of the pattern node and the result of these queries is returned as result of the pattern. </para><para>With this definition we can for example already write <programlisting xml:space="preserve">&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</programlisting> as a  pattern query for the first  <code>b</code>-element contained in an <code>a</code>-element<footnote><para>The content of the b-element, i.es. a sequence of all its children, might be more natural, but it cannot be assigned to the context item.</para></footnote>, e.g. it returns <code>&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;</code> on input <programlisting xml:space="preserve">&lt;a&gt;&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;&lt;/a&gt;</programlisting>. Using the longer syntax, we get example patterns
      <programlisting xml:space="preserve">&lt;a&gt;&lt;b&gt;&lt;t:s&gt;.&lt;/t:s&gt;&lt;/b&gt;&lt;/a&gt;</programlisting> and <programlisting xml:space="preserve">&lt;a&gt;&lt;b&gt;&lt;template:s&gt;.&lt;/template:s&gt;&lt;/b&gt;&lt;/a&gt;</programlisting> that are matched in exactly the same way as the first example pattern.</para><para>An example for the attribute variant is <programlisting xml:space="preserve">&lt;a href="{.}"/&gt;</programlisting> which returns an attribute node <code>href="http://balisage.net/"</code> when matched against <programlisting xml:space="preserve">&lt;html&gt;Some text&lt;p&gt;&lt;a href="http://balisage.net/"&gt;title&lt;/a&gt;&lt;/p&gt;&lt;/html&gt;</programlisting>.</para><para>A combined example is the pattern <programlisting xml:space="preserve">&lt;a href="{.}"&gt;{concat("=&gt; ", .)}&lt;/a&gt;</programlisting> which would return an attribute node <code>href="http://balisage.net/"</code> as well as a string value <code>"=&gt; title"</code>.</para><para>Someone who is familiar with  XQuery's handling of sequences might now wonder what happens when a pattern has multiple selector expressions that all return a sequence. Does the pattern return multiple sequences? Is that even possible? Does it return a single sequence of all sequences flattened together?</para><para>We prefer former case, because it makes it possible to combine multiple patterns to a single one. However, multiple sequences cannot really be handled with standard XQuery data types, so we have decided to extend the XQuery syntax to create some kind of named return values. </para><para>
      <!--To enable the pattern to return arbitrary data we extend XQuery with-->
       Thus we have added variable assignments <code>$variable := expression</code> which evaluate the expression on the right hand side and assign it to a global variable on the left hand side.  The priority of the <code>:=</code> operator is set to be lower than the priority of every existing operator. More formally, we have introduced these extensions to the XQuery EBNF:
      
      <programlisting xml:space="preserve">ExprSingle         ::= FLWORExpr | QuantifiedExpr | SwitchExpr | TypeswitchExpr | IfExpr | TryCatchExpr | VarAssignmentExpr
VarAssignmentExpr  ::= (VarRef ":=" )* OrExpr
VarRef             ::= "$" VarName   </programlisting>
 
      Now we can return multiple sequences by assigning these sequences to variables, e.g. <code>{$var1 := (1,2,3), $var2 := (4,5,6)}</code>. </para><para>This leaves the question, what happens, when there are multiple assignments to the same variable. We will later see that in <link linkend="tloop" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">loops</link> every selector expression is evaluated multiple times, so the most reasonable way is to return two different variables with the same name. Although in most of the <link linkend="integration" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery syntax extension</link> this is not possible, we prefer to do it, where possible. So e.g. <code>{$x := (1,2), $x := (3,4)}</code> also returns two different sequences. This is easier to understand, when the variable assignments are not considered as creating actual variables, but as creating a name+value pair (like a  map with one element) and adding it to a sequence. Since the pairs are not sequences themselves, they are not flattened. </para><!--      These variables are not intended to be used for imperative programming, instead they should only br used named return values of the pattern. 
      In fact, when multiple assignments to the same variable occur in a pattern, it will return the value of each assignment separately.- -></para>--><para>
      However, always writing <code>{$var := expr}</code> would be  cumbersome, especially after seeing the <code>{.}</code> examples above. So we have added two abbreviations<footnote><para>They also apply to <code>&lt;t:s&gt;</code>-expressions, but in the following we will restrict ourselves to <code>{..}</code> for breverity</para></footnote>:
      
      <itemizedlist><listitem><para><code>{expression}</code> not containing <code>:=</code>: An expression without assignment is replaced by an assignment <code>{$result := expression}</code> to a default variable <code>$result</code>. The name of the default variable is configurable, and later we will even extend it to assignments to the context item <code>.</code> itself. <!--, i.e. an assignment to a default-variable called <code>$result</code> (name is configurable. We can even consider it to be an assignment to the context item <code>.</code> itself).--></para></listitem><listitem><para><code>{$variable}</code>: A selector expression containing exactly one variable is replaced by <code>{$variable := .}</code></para></listitem></itemizedlist>
       
      With this definition, the meaning of <code>{.}</code> is implied and does not need to be defined explicitly, and the above example pattern <code>&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</code> returns the <code>b</code>-element in the default variable (if the matching does not fail). Like the XQuery expression <code>let $result := exactly-one(((//a)[1]//b)[1]) return ...</code> (but we will omit the <code>let $result :=</code> prefix in the remaining of the paper for brevity). 
      </para><para>
      Another example is <programlisting xml:space="preserve">&lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;/root&gt;</programlisting> returning the first <code>a</code>-element in <code>$a</code> and a following <code>b</code>-element in <code>$b</code>. It is equivalent to the XQuery expression
      <programlisting xml:space="preserve">let $a := exactly-one(((//root)[1]//a)[1]),  
    $b := exactly-one(($a/following::b)[1] intersect (//root)[1]//b)
return ...</programlisting>
      This example also shows how awkward it is to simultaneously encode the order requirement (<code>b</code> following <code>a</code>) as well as the descendant requirement (<code>a</code> and <code>b</code> being descendants of <code>root</code>) in standard XQuery<footnote><para><code>following-sibling::</code> cannot be used, since it encodes a sibling not a descendant relationship.</para></footnote>.
      </para><!--
      <programlisting>
      PatternExpr := Literal | VarRef | VarAssignment | ContextItemExpr | PatternConstructor
      VarAssignment := VarRef  ":=" Expr 
      PatternConstructor := Constructor
      </programlisting>
    --><para>So in the end the matching process either raises an matching error or returns a list of variable assignments <programlisting xml:space="preserve">$var1 := value1
$var2 := value2
... </programlisting>. We call this list "assignment stream", since it is similar to a  tuple stream of a flower expression except that it involves different variables.</para></section><section xml:id="sec_advanced"><title>Advanced patterns<!--\subsection{advanced}--></title><para>The previous sections have explained the basic matching of individual elements, in which each node of the pattern is matched to exactly one node in the input data. But in practical applications it is necessary to return data that does not have a 1-1 relationship with the query itself. For this the patterns have various syntaxes which are explained in this section:</para><section><title>Optional elements</title><para>An optional element is optional, i.e. if a match for the element exists in the input, the element is matched as usual, otherwise it is ignored.</para><para>
      There are two ways to mark an element as optional:
      
      <itemizedlist><listitem><para><code>?</code>: The element is followed by a <code>?</code>, e.g.: <code>&lt;element/&gt;?</code></para></listitem><listitem><para><code>t:optional = "true"</code>: It has an <code>optional</code> attribute, e.g.: <code>&lt;element t:optional="true"/&gt;</code> or <code>&lt;element template:optional="true"/&gt;</code></para></listitem></itemizedlist>
      </para><para><code>?</code> as marker does not conflict with text node matching, since regular expressions cannot start with a question mark.</para><para><!--The recursive definition is straightforward: it is matched as usual, but if there does not exist a corresponding match in the input data, it is ignored-->A naive implementation can match optional elements first as non-optional, and if that fails with a matching error, skip the element in the pattern and match it again. 
         <!--   <para>It is important to notice that <code>&lt;element/>?</code> is not always the same as <code>&lt;element/>{0,1}</code>. Both can be matched once or never, however <code>?</code> has a higher priority than <code>{0,1}</code>. This becomes evident, when the patterns <code><![CDATA[<x><y>{.}</y>?</x>]]></code> and <code><![CDATA[<x><y>{.}</y>{0,1}</x>]]></code> are matched against  <code><![CDATA[<root><x></x><x><y>match</y></x></root>]]></code> </para>--></para></section><section xml:id="tloop"><title>Repeated elements</title><para>With the patterns described so far, we can only apply a selector expression to a single element of the input document and therefore only return a single value with a simple selector like <code>{.}</code> or <code>{$var}</code>, although the input usually contains many elements, which all should be examined by a query. In fact returning multiple elements is considered so important that it easier to select all elements than only the first element with standard path expressions. So the patterns need to be extended to be able to match multiple elements.</para><para><!--So the patterns need to be extended to match multiple elements, -->
            For this we introduce a notation similar to regular expressions:
      
      <itemizedlist><listitem><para><code>*</code>: The preceding element can be repeated arbitrary many times.  E.g.  <code>&lt;element/&gt;*</code></para></listitem><listitem><para><code>+</code>: The preceding element can be repeated once or more times. E.g.  <code>&lt;element/&gt;+</code></para></listitem><listitem><para><code>{min, max}</code>: The preceding element is repeated between min and max times. E.g. <code>&lt;element/&gt;{1,3}</code></para></listitem><listitem><para><code>{count}</code>: The preceding element is repeated exactly count times. E.g. <code>&lt;element/&gt;{3}</code> is equivalent to <code>&lt;element/&gt;&lt;element/&gt;&lt;element/&gt;</code></para></listitem><listitem><para><code>&lt;t:loop [min=".."] [max=""]&gt; ... &lt;/t:loop&gt;</code>: The child elements are matched at least <code>@min</code> and at most <code>@max</code> times. A missing <code>min</code> attribute is interpreted as 0, and a missing <code>max</code> attribute as infinite. E.g. <code>&lt;t:loop min="1"&gt;&lt;tr/&gt;&lt;/t:loop&gt; </code> </para></listitem></itemizedlist></para><para>Using these symbols is unproblematic like <code>?</code> for optionality and <code>{}</code> for selector expressions, since no regular expression can start with <code>+</code> or <code>*</code>.  <code>{count}</code> could be confused with a selector expression returning <code>count</code>, however a selector returning a single number is pointless, so we can assume every single number is not meant to be a selector. A single text node can contain a repetition marker and a selector expression. </para><para>The use of a minimal count can be demonstrated with the following example: each of the patterns <code>&lt;x&gt;{.}&lt;/x&gt;*</code> and <code>&lt;x&gt;{.}&lt;/x&gt;+</code> applied to  <code>&lt;root&gt;&lt;x&gt;1&lt;/x&gt;&lt;x&gt;2&lt;/x&gt;&lt;x&gt;3&lt;/x&gt;&lt;/root&gt;</code> returns <code>&lt;x&gt;1&lt;/x&gt;</code>, <code>&lt;x&gt;2&lt;/x&gt;</code> and <code>&lt;x&gt;3&lt;/x&gt;</code>.  However, if applied to <code>&lt;root/&gt;</code>, former succeeds and returns nothing, while latter raises a matching error.</para><para>Unlike the minimal count a maximal count does not raise matching errors, instead all elements after the first max elements are just ignored, following the principle of ignoring additional data. </para><para>Although <code>&lt;x&gt;{.}&lt;/x&gt;*</code> seems to be the same as <code>//x</code>, it is not. This becomes obvious, if we look at the expanded pattern <code>&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;...</code>. All the x-elements in the pattern are siblings and not descendants of each other, so the pattern will only match separated <code>x</code>-elements which do not contain each other. An equivalent XQuery would therefore be <code>let $temp := count(ancestor-or-self::x) return .//x[count(ancestor::x) eq $temp]</code> or shorter <code>.//x except .//x//x </code> <!--.<footnote><para>One might think the shorter path expression  <code>.//x[not(.//x)]</code> was equivalent. However, it is not, since <code>&lt;x/>*</code> matched nodes containing x-elements, just not . </para></footnote>-->.</para><para>Considering a loop to be a sequence of repeated elements also explains, how selectors are handled within the loop: Every selector is evaluated for every matched element and the result is returned as another assignment to the result variable. </para><para>For example <programlisting xml:space="preserve">&lt;a&gt;{$var}&lt;b/&gt;&lt;/a&gt;+</programlisting> applied to <programlisting xml:space="preserve">&lt;root&gt; &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt; &lt;a&gt;2&lt;/a&gt; &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;</programlisting> returns an assigment stream
     <programlisting xml:space="preserve">$var := &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt;
$var := &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;</programlisting>. The second <code>&lt;a/&gt;</code> is skipped, because it does not a <code>&lt;b/&gt;</code> child. </para><para><code>&lt;t:loop&gt;</code> is the most powerful variant of these five syntaxes, not only does it generalize the other notations<footnote><para>In fact, our implementation converts everything to <code>&lt;t:loop&gt;</code> before matching.</para></footnote>, it is the only one that can repeat multiple elements e.g. to separate odd and even rows: <code> &lt;t:loop&gt;&lt;tr&gt;{$odd}&lt;/tr&gt; &lt;tr&gt;{$even}&lt;/tr&gt; &lt;/t:loop&gt; </code></para><para>A possible way to implement repeated elements is to modify the matching process of the parent of the loop node to match all its children and children of <code>t:loop</code>-elements against all possible nodes in the input document. The last match of the non-loop children following the loop children is then a constraint for the maximum number of matching loop children, because only nodes preceding  that last match can be matched by children of the loop. </para></section><section xml:id="tcondition"><title>Conditionals</title><para>In some cases it is necessary to check for arbitrary conditions that cannot be expressed directly by a pattern, e.g. for conditions that are not local like two values depending on each other. For this we use an attribute <code>t:condition</code>, which stores an XQuery expression that an input element has to satisfy in order to be accepted as valid match, similarly to the expression contained in a filter expression. The context item <code>.</code> is set to the node currently checked for a match.  </para><para>
      For example the pattern <code>&lt;e t:condition="exists(@a) and @b eq ."/&gt;</code> matches <code>&lt;e a="" b="1"&gt;1&lt;/e&gt;</code>, but neither <code>&lt;e  b="1"&gt;1&lt;/e&gt;</code> nor <code>&lt;e a="" b="1"&gt;2&lt;/e&gt;</code>.
      </para><!--   todo:   <code>t:ignore-self-test</code> --><para>Another use of conditionals is to skip parts of the pattern. E.g. if you have two data sources which are similar, but not identical, you might want to use the same pattern for both, ignoring the parts of the pattern which only apply to the other data source. 
      This can be accomplished with the <code>&lt;t:if&gt;</code> element, whose children are only matched, if the XQuery expression given in the <code>test</code> attribute of the <code>&lt;t:if&gt;</code> element evaluates to true. The context item <code>.</code> is the previously matched element.</para><para> For example <code>&lt;x&gt;&lt;y&gt;{$y}&lt;/y&gt;&lt;t:if test="$y eq 17"&gt;&lt;z&gt;{$z}&lt;/z&gt;&lt;/t:if&gt;&lt;/x&gt;</code> matched against <code>&lt;x&gt;&lt;y&gt;1&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</code> returns <code>$x := &lt;y&gt;1&lt;/y&gt;</code> and matched against <code>&lt;x&gt;&lt;y&gt;17&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</code>, it returns <code>$x := &lt;y&gt;17&lt;/y&gt;, $y := &lt;z&gt;2&lt;/z&gt;</code>.</para><para>Most languages support an <code>else</code> statement to be used  with their <code>if</code> statement, so we added a similar <code>&lt;t:else/&gt;</code>-element to the pattern syntax. The children of a <code>&lt;t:else/&gt;</code> element are only matched, if the children of the preceding <code>&lt;t:if/&gt;</code> element were ignored. <!--Sometimes we do not want just to ignore an element if the conditions <footnote><para>A <code><![CDATA[<switch/>)]]></code> element could be used, but in that </para></footnote>  <code><![CDATA[<t:else>]]></code>- -> </para>      <para>-->
      For example <code>&lt;root&gt;&lt;t:if test="$check"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;/t:if&gt;&lt;t:else&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:else&gt;&lt;/root&gt;</code> matched against <code>&lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;/root&gt;</code> returns <code>&lt;a&gt;1&lt;/a&gt;</code>, if <code>$check</code> is true, and <code>&lt;b&gt;2&lt;/b&gt;</code> otherwise. </para><para>If the <code>&lt;t:if&gt;</code> element is used to give a condition for a single element, it is quite cumbersome to surround just that element with <code>&lt;t:if&gt;..&lt;/t:if&gt;</code>. Therefore we allow the <code>t:test</code> attribute being used directly on elements, as abbreviation for a surrounding <code>&lt;t:if&gt;</code>. E.g. <code>&lt;a t:test="$check"/&gt;</code> is equivalent to <code>&lt;t:if t:test="$check"&gt;&lt;a/&gt;&lt;/t:if&gt;</code> and  ignored if <code>$check</code> is <code>false</code>. </para><para> <code>t:test</code> might be confused with <code>t:condition</code> by someone just seeing a pattern without having read this paper. but they are very different from each other. <code>t:test</code> is a condition the element in the pattern (given the previous variables) has to satisfy, is checked (at most once, outside t:loop) before a match for this element is searched and only a positive return value can lead to a matching error. <code>t:condition</code> is a condition the element in the input data has to satisfy, might be checked for every element in the input data, and only a negative return value can lead to a matching error. </para></section><section xml:id="para_unordered"><title>Alternative elements</title><para>Sometimes different  elements may occur in the input data and should be accepted as matches, but it is not known a priori which one actually exists.
             It would be possible to handle this with optional elements and conditions, but that would be cumbersome. 
             Instead the patterns  support a <code>&lt;t:switch&gt;</code> element, which contains different alternative patterns, i.e. it matches an element in the input successfully, if any of its children match that element successfully.
       </para><para>For example <code>&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</code> applied to either <code>&lt;a&gt;1&lt;/a&gt;</code> or  <code>&lt;b&gt;1&lt;/b&gt;</code> will return the input node (with value 1). </para><para>There occurs a strange effect, if all the children exist as elements in the input data,  but in a different order, like <code>&lt;root&gt;&lt;x&gt;&lt;b&gt;B&lt;/b&gt;&lt;/x&gt;&lt;a&gt;A&lt;/a&gt;&lt;/root&gt;</code> for the previous example. The <code>&lt;t:switch/&gt;</code> element as described so far would return the b-element, because <code>&lt;t:switch/&gt;</code> is first matched against <code>&lt;root&gt;</code> and <code>&lt;x&gt;</code>, which are not accepted by any of its children, and then against <code>&lt;b&gt;</code>, which is matched by the second child. So   <code>&lt;t:switch&gt;</code> always chooses the first matching element in the input.</para><para>However, it has turned out that we usually want the element matching the earliest child that has a match, when we combine multiple patterns into a single one. So we have added an attribute <code>prioritized</code>, which enables "prioritized" matching, i.e. performing the matching of the children in order and accepting the first match of the earliest child. E.g. <code>&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</code> would return the a-element when matched against the previous  example input document. </para><para>Another interesting use of the <code>&lt;t:switch&gt;</code> element is to perform unordered matching, when combined with a loop. For example <code>&lt;t:loop&gt;&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;&lt;/t:loop&gt;</code> returns all  (not nested) <code>&lt;a/&gt;</code> and <code>&lt;b/&gt;</code> nodes of the input document. So applied to the example input above it returns <code>&lt;b&gt;B&lt;/b&gt;</code> and <code>&lt;a&gt;A&lt;/a&gt;</code>. (without the loop and switch, it would raise a matching error due to the different order). This occurs automatically, without handling this case in an implementation, since the switch-element is matched against every element in the input.  </para><para>A possible abbreviation for a <code>&lt;t:switch&gt;</code> element could be the regex inspired <code>(&lt;a&gt;{.}&lt;/a&gt;|&lt;b&gt;{.}&lt;/b&gt;)</code>. We have, however, not implemented this, because a regex is allowed to start with a <code>|</code> (matching an empty string), so it might not be clear, if a switch abbreviation or a regex for text node matching is meant.</para><!-- todo: value switch --></section><section xml:id="tmeta"><title>Default options</title><para>The way string values are matched can be changed with the <code>&lt;t:meta/&gt;</code>-element, which sets the comparison function and case-sensitiveness for text nodes and attributes:
      <programlisting xml:space="preserve">&lt;t:meta [text-matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [text-case-sensitive="true|false"] 
        [attribute-matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [attribute-case-sensitive="true|false"] /&gt;</programlisting>      
      </para><para>
      For example <code>&lt;t:meta text-case-sensitive="false"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</code> matches <code>&lt;a&gt;foobar&lt;/a&gt;</code> and <code>&lt;a&gt;FOOBAR&lt;/a&gt;</code>, while <code>&lt;t:meta text-case-sensitive="true"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</code> matches only former input.
      </para><para>For individual attributes the string value matching can be controlled with the <code>&lt;t:meta-attribute/&gt;</code>-element:
      <programlisting xml:space="preserve">&lt;t:meta-attribute 
        name="..."
        [matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [case-sensitive="true|false"] /&gt;</programlisting>      
      </para><para>
      For example <code>&lt;t:meta-attribute name="x" case-sensitive="false"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</code> matches <code>&lt;a x="y"/&gt;</code> and <code>&lt;a x="Y"/&gt;</code>, while <code>&lt;t:meta-attribute name="x" case-sensitive="true"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</code> matches only former input.
      </para><para>A meta element changes the options for all its children, and, if it does not have children, for all following elements due to legacy reasons.</para></section></section><section><title>Matching JSONiq<!--\subsection{jsoniq}--></title><para>After having specified a pattern syntax for XML data, it appears reasonable to extend it to other data storage formats, like JSON. Recently a JSON-query language called JSONiq [<xref linkend="jsoniq"/>] was announced as extension to XQuery, which we have implemented and plan to extend with pattern matching. <!-- pattern matching extension for JSONiq would work--></para><para>To perform pattern matching on JSONiq types, we need to define the matching process for all new types added by JSONiq: <code>null</code>, objects and arrays<footnote><para>This section is purely theoretical, we have never used JSONiq matching in any practical application.</para></footnote>. As well as for the standard atomic XQuery types derived from <code>xs:anyAtomicType</code>, because the previous sections only defined the matching for nodes.</para><para>
      A small problem is that none of the JSONiq types support namespaces, so we cannot do advanced matching with a <code>t:</code> prefix, like in the XML case, not even to include selector expressions. However, the important JSONiq types, arrays and objects, can contain XML nodes, so we can wrap the selector expressions in <code>&lt;t:s/&gt;</code>-elements and include them like that in the JSONiq item. 
      </para><itemizedlist><listitem><para>
      Defining a natural matching for <emphasis>atomic types and <code>null</code></emphasis> is easy: These values matches another value, if the <code>eq</code>-operator returns true. Due to the definition of the equality of <code>null</code> in JSONiq, it follows <code>null</code> matches <code>null</code> and nothing else.
      </para></listitem><listitem><para>
      An <emphasis>object</emphasis> pattern matches a value, if that value is an object and the value of every property of the pattern matches the value of the corresponding property of the value. 
      </para></listitem><listitem><para>      
      
      
      For arrays there are three reasonable ways to define array matching: An array pattern <code>$a</code> matches an  value <code>$b</code>, if 
      <itemizedlist><listitem><para> <emphasis>Exact matching</emphasis>: <!--<code>$a</code> and <code>$b</code> have the same number of elements, and--> element <code>$a[$i]</code> matches <code>$b[$i]</code> for all <code>$i in 1 to jn:size($a)</code>, and <code>$a</code> and <code>$b</code> have the same number of elements. </para></listitem><listitem><para><!--<code>$b</code> has at least as many elements as <code>$a</code>, and--><emphasis>Exact prefix matching</emphasis>: element <code>$a[$i]</code> matches <code>$b[$i]</code> for all <code>$i in 1 to jn:size($a)</code>. I.e. after the exactly matched beginning of the array <code>$b</code>  there might follow arbitrary other elements.</para></listitem><listitem><para><emphasis>Existence matching</emphasis>: element <code>$a[$i]</code> matches an <code>$b[$j($i)]</code>, such that $j($i) &lt; $j($i+1),  for all <code>$i in 1 to jn:size($a)</code>. I.e. every element of $a can be matched, but there might be arbitrary many elements between each match.</para></listitem></itemizedlist>
      </para><para>Each way represents a different compromise between the goal 2 (validation) and goal 3 (minimality). We have decided to use the last way, giving priority to minimality<footnote><para>Sequences could be handled similar to arrays, but we will not consider sequences here, since they do not occur as such in input data.</para></footnote>.</para></listitem></itemizedlist><para>An example of a pattern according to above definitions is 
      <programlisting xml:space="preserve">{"a": [1,2,3], "b": null, "c": &lt;t:s&gt;{.}&lt;/t:s&gt;}</programlisting>
      which matches 
      <programlisting xml:space="preserve">{"a": [1,2,3], "b": null, "c": "foobar"}</programlisting>
      returning <code>foobar</code>
      or 
      <programlisting xml:space="preserve">{"a": [1,"u",2,"v",3], "b": null, "c": [7,8,9], "d": 17}</programlisting>
      returning <code>[7,8,9]</code>.
      </para><para>
      But it matches neither 
      <programlisting xml:space="preserve">{"a": [1,2,3], "b": [4,5], "c": "xyz"}</programlisting>
      nor 
      <programlisting xml:space="preserve">{"a": [1,2,3], "c": "foobar"}</programlisting>
       </para><!--<para>Furthermore, we allow the empty array <code>[]</code> to match any value, regardless if the matched value is an array or not. </para>--><!-- <para>We further extend our assignment operator to allow assigments to object properties, e.g. <code>$variable("property") := value</code>, leading to the following modification of the EBNF:
      <programlisting> VarRef             ::= "$" VarName  ( "(" ExprSingle ")" )* </programlisting>
      
      This is useful to <code><![CDATA[<root><list>{$result := {}}<a>{$result("a")}</a><b>{$result("b")}</b></list>*</root>]]></code>. ()
      
      <programlisting>
      ObjectConstructor   ::= '{' PairConstructorList? '}'
      PairConstructorList ::= PairConstructor ( ',' PairConstructor )*
      PairConstructor     ::= ExprSingle ':' ExprSingle
      
      ArrayConstructor    ::= '[' Expr? ']'
      </programlisting>

      </para>--><para>Since writing <code>&lt;t:s/&gt;</code> is extremely cumbersome in a JSONiq pattern, it might be beneficial to allow abbreviations like <code>{"c": .}</code>, <code>{"c": $result}</code> or <code>{"c": $result := .}</code> in an implementation, in which the <code>&lt;t:s&gt;</code> is omitted. This syntax is mostly unambiguous, however it cannot be evaluated and stored as JSONiq type. Therefore, such an implementation must be able to partially evaluate JSONiq types, keeping it in AST form or serializing the XQuery-AST back to a reparsable query wrapped in <code>&lt;t:s&gt;</code>. Another alternative might be to use inline functions instead <code>&lt;t:s&gt;</code>, e.g <code>function(){$result := .}</code> replacing <code>&lt;t:s&gt;$result := . &lt;/t:s&gt;</code>, in which case no serialization of XQuery expressions is needed. But we will not consider such  extensions in the remaining paper. </para></section></section><section xml:id="integration"><title>The integration in XQuery<!--\section{integration}--></title><section><title>As function, without syntax modification</title><para>Since every pattern is a valid XML element (or JSONiq item), it <!--<footnote><para>Except for a possible trailing loop marker like <code>*</code>, but the root element in the input can occur only once, so a pattern with loop marker can always be wrapped in a root node</para></footnote>--> can be represented by valid values in the XQuery type schema, and it is possible to write a matching function that takes a pattern and input data as arguments and performs the matching in standard XQuery (or JSONiq). Such a function is useful to perform pattern matching in existing XQuery implementations without having to write a new implementation.</para><para> To use the full power of selector expressions within a patten, the underlying implementation has to support some kind of <code>eval</code> function to evaluate an XQuery given as string. And of course, only the right-hand-side of <code>:=</code> assignment can be passed to the <code>eval</code>-function and the variable names have to be tracked separately. </para><para>The type declaration of our matching function is:<footnote><para>The prefix <code>pxp</code> can be considered an abbreviation of "Pascal XQuery Project", another name of our XQuery implementation. Although the function <code>pxp:match</code> exists in our implementation it is there not written in XQuery and depends on our own special features. </para></footnote></para><programlisting xml:space="preserve">pxp:match($pattern as item(), data as item()*) as item()*</programlisting><para>The first argument is the pattern that is matched against every item in the <code>$data</code> sequence, thereby creating multiple assignment streams which are concatenated. Since <code>$pattern</code> is an ordinary value, the <code>{...}</code> selector expressions have to be encoded as <code>{{...}}</code>, if the pattern is created within the query by an element constructor.  </para><para>In theory, the function should return the final assignment stream, but an assignment stream is not a valid XDM instance. So we wrap the result in an XQuery map which maps variable names to a sequence of values and which can be read like a function call. For example the map <code>$map := {"foo": "bar", "x": ("y", "z")}</code> contains two keys which can be accessed with <code>$map("foo") = "bar"</code> and <code>$map("x") = ("y", "z")</code>. In modern XQuery such a map can be implemented as an anonymous function that returns a certain value if called with the corresponding key.  A theoretical alternative to a map is to wrap the data in an XML element, however, that would destroy information like the parents of the returned items<footnote><para>For the same reason we are talking about a "map" instead of a JSONiq "object". A standard JSONiq object would contain copies of the XML elements and therefore  lose the parent relationships as well.</para></footnote>.   <!--If the pattern only contains assignments to the default variable, it . --> </para><para>Since sequences cannot nest, assignments of sequences to variables are flattened in the returned sequence. e.g. the assignment stream <code>$a = (1, 2), $a = 3, $a = 4</code> becomes a single sequence in the map <code>{"a": (1,2,3,4)}</code>. If the only assigment is to the default variable, we do not wrap it in a map and return the value directly. </para><para>For example

      <programlisting xml:space="preserve">pxp:match(&lt;root&gt;&lt;foo&gt;{{.}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</programlisting>
      
      has internally the assigment stream
      
      <programlisting xml:space="preserve">. = &lt;foo&gt;1&lt;/foo&gt;
. = &lt;foo&gt;2&lt;/foo&gt;
</programlisting>

      and returns 
      
      <programlisting xml:space="preserve">(&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;)</programlisting></para><para>Another example with variables is <programlisting xml:space="preserve">pxp:match(&lt;root attrib="{{$attrib}}"&gt;&lt;foo&gt;{{$var}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root attrib="ABC"&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</programlisting>
      which has the assigment stream
      <programlisting xml:space="preserve">$attrib = "ABC"
$var = &lt;foo&gt;1&lt;/foo&gt;
$var = &lt;foo&gt;2&lt;/foo&gt;
</programlisting>
      and returns
      <programlisting xml:space="preserve">{"attrib": "ABC", "var": (&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;) }</programlisting></para><!--      <para>This function in our implementation is not actually written in standard XQuery We have not actually written </para>--></section><section><title>Extending Switch-Expressions</title><para>The natural way to extend the <code>switch</code>-expression with pattern matching seems to allow patterns as operands of <code>case</code> clauses, like <code>case &lt;element&gt; ...the pattern... &lt;/element&gt; return ... </code>. However, this is already a valid XQuery syntax, denoting the atomization of the case operand to the string value <code>...the pattern...</code> and comparing that value to the input. So the <code>case</code>-clause cannot be used and we have to add a new keyword <code>match</code> that has a pattern as operand. The formal grammar of this new <code>switch</code>-expression is then: </para><programlisting xml:space="preserve"><!--SwitchExpr 	   ::=    	"switch" "(" Expr ")" SwitchCaseClause+ "default" "return" ExprSingle
-->SwitchCaseClause    ::=  ("case" SwitchCaseOperand | "match" SwitchMatchOperand)+ "return" ExprSingle
SwitchMatchOperand  ::=  PatternExpr</programlisting><para>A pattern given to <code>match</code> will not be evaluated, before the matching.  So writing <code>&lt;x&gt;{$y}&lt;/x&gt;</code> is sufficient for a pattern that assigns  <code>&lt;x/&gt;</code> to <code>$y</code> and it does <emphasis>not</emphasis> have to be encoded as <code>&lt;x&gt;{{$y}}&lt;/x&gt;</code>.  So the variables that could be created by the pattern are statically known, and can be added to the static context of the expression in the corresponding return clause. </para><para>We define <code>PatternExpr</code> to be either an XML pattern with optional loop marker (e.g. <code>+</code>) or a JSONiq constructor: </para><programlisting xml:space="preserve">LoopIndicator   := OccurrenceIndicator | "{" Digits "}" | "{" Digits "," Digits "}" 
PatternExpr     := DirectConstructor LoopIndicator? | ObjectConstructor | ArrayConstructor </programlisting><para>This syntactical definition is broader than the semantically allowed values (e.g. function calls would not be allowed), so some expressions are rejected during evaluation. </para><para>
      The switch expression is then evaluated as follows:</para><para>
      All <code>case</code> and <code>match</code> clauses are processed in order.
      <itemizedlist><listitem><para>If a <code>case</code> clause is meet, it is "matched" like in standard XQuery.</para></listitem><listitem><para>If a <code>match</code> clause is meet, its pattern is matched against the input as described in the previous sections.
          <itemizedlist><listitem><para>If a matching error occurs, this clause is skipped (the error is not propagated upwards). </para></listitem><listitem><para>If the matching succeeds, the value of the switch expression is the value of the current return expression.
          All variables that were created by the pattern are available in the evaluation of the return expression and, if a value was assigned to the default variable, it replaces the context item. </para></listitem></itemizedlist></para></listitem></itemizedlist>
      </para><para>So for example, either
      
      <programlisting xml:space="preserve">switch (&lt;y&gt;123&lt;/y&gt;) 
  match &lt;x&gt;{$data}&lt;/x&gt; return "The x-data is " || $data
  match &lt;y&gt;{$data}&lt;/y&gt; return "The y-data is " || $data
  default return "foo"</programlisting>
      
      or

      <programlisting xml:space="preserve">switch (&lt;y&gt;123&lt;/y&gt;) 
  match &lt;x&gt;{.}&lt;/x&gt; return "The x-data is " || .
  match &lt;y&gt;{.}&lt;/y&gt; return "The y-data is " || .
  default return "foo"</programlisting>      
      
      
      will return <code>The y-data is 123</code>.</para><para> 
      If multiple values have been added to a single variable by the pattern, like in <code>&lt;x&gt;{$var}&lt;/x&gt;+</code> they are all flattened to a variable containing a sequence. However, if the assignment was to the context item, an exception is thrown, since <code>.</code> cannot be a sequence.
      </para><!-- todo: allow quantifiers after patten? better handling of sequencea? --><para>So we could use the following example to count all links on a webpage:
      <programlisting xml:space="preserve">switch ($inputdata) 
  match &lt;a&gt;{$a}&lt;/a&gt;+ return "There are " || count($a) || " links on the webpage"
  match &lt;html/&gt; return "There are no links on the webpage"
  default return "Invalid input"</programlisting>      </para></section><section><title>Extending Flowers</title><para>
        Before we can extend the flower expressions, we need to extend the tuple stream, so it behaves more like an assignment stream.
        In XQuery implementations this stream assigns certain values to certain variables. Since our patterns also allow assignments to a default variable with <code>{.}</code> which is then mapped to the context item <code>.</code>, the tuple stream has to be able to not only store normal variables, but also this default variable. We will write such assignments
        <programlisting xml:space="preserve">(. = 1)
(. = 2)</programlisting>
        in this paper.
        </para><para>
        We then could write <code>for . in $sequence return expression ...</code> meaning the same as <code>$sequence ! expression ...</code> or <code>let . := $value return expression</code> meaning the same as <code>exactly-one($value) ! expression ...</code> in a query<footnote><para>Actually our current parser rejects these expressions, but they would be natural extensions.</para></footnote>. 
        </para><section><title>Extending let</title><para>We extend the <code>let</code>-expression by  allowing patterns to be used as binding variable, i.e. by adding a  <code>MatchLetClause</code> to the <code>InitialClause</code>-EBNF defined as follows:
      <programlisting xml:space="preserve">MatchLetClause         ::=    	"let" PatternLetBinding ("," PatternLetBinding)*      
LetBinding             ::=    	PatternExpr ":=" ExprSingle</programlisting></para><para>During evaluation this pattern is matched against the right-hand-side of <code>:=</code> and the resulting variables are added to the tuple stream, so they can be used just like in the <code>return</code> clause of an extended <code>switch</code>-expression.</para><para>For example
      <programlisting xml:space="preserve">let &lt;a&gt;{.}&lt;/a&gt; := &lt;root&gt;&lt;a&gt;123&lt;/a&gt;&lt;/root&gt; return .</programlisting>
      will create a tuple stream
<programlisting xml:space="preserve">(. = &lt;a&gt;123&lt;/a&gt;)
</programlisting>
 and therefore return <code>&lt;a&gt;123&lt;/a&gt;.</code></para><para>As mentioned when extending the <code>switch</code>-expression, multiple assignments will be flattened to a sequence. E.g. <code>let &lt;a&gt;{$a}&lt;/a&gt;* := &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt;</code> creates the tuple stream <code>($a = (&lt;a&gt;1&lt;/a&gt;, &lt;a&gt;2&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;))</code>.</para><para>The practical usage of such an expression is to validate that (schema-less) data has a certain structure, without creating a new XML schema or using a lot of if-expressions. E.g. <code>let &lt;xml&gt;&lt;a&gt;{$a}/&lt;a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;c&gt;{$c}&lt;/c&gt;&lt;/xml&gt; := &lt;xml&gt;&lt;a&gt;{123}/&lt;a&gt;&lt;b&gt;{456}&lt;/b&gt;&lt;c&gt;{789}&lt;/c&gt;&lt;/xml&gt; return ($a, $b, $c)</code> queries the three elements and throws an exception, if they do not occur or have a different order. </para></section><section><title>Extending for</title><para>Similar to the let-expression we extend the for-expression by allowing a pattern as binding variable. Hence we add a new initial clause <code>MatchForClause</code>:
      <programlisting xml:space="preserve">MatchForClause         ::=    	"for" PatternForBinding ("," PatternForBinding)*
PatternForBinding      ::=    	PatternExpr "in" ExprSingle</programlisting></para><para>During evaluation, this pattern is matched against the right-hand-side of <code>in</code> similar to the evaluation of the extended <code>let</code>. However, this  time the resulting variables are not directly added to the tuple stream. Instead each assignment within the pattern creates a new row in the stream, in which only the currently assigned variable has a value. This also means that a sequence assigned to a variable is not flattened. </para><para>
      For example
      <programlisting xml:space="preserve">for &lt;a&gt;{.}&lt;/a&gt;+ in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt; return .</programlisting>
      will create the tuple stream
      <programlisting xml:space="preserve">(. = &lt;a&gt;1&lt;/a&gt;)
(. = &lt;a&gt;2&lt;/a&gt;)
(. = &lt;a&gt;3&lt;/a&gt;)</programlisting>
      and return every a-element.<!-- <code><![CDATA[<a>1</a>]]></code>, <code><![CDATA[<a>2</a>]]></code>, <code><![CDATA[<a>3</a>]]></code>-->
      </para><para>
      And
      <programlisting xml:space="preserve">for  &lt;html&gt;&lt;h2&gt;Title A&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Title B&lt;/h2&gt;&lt;/html&gt; in $input-data return .</programlisting>
      will return all paragraphs between <code>Title A</code> and <code>Title B</code>, a natural appearing query that would be complicated to express with standard XPath.
      </para><para>When multiple variables are used in the pattern, they all occur in the tuple stream, but only one is non-empty. For example:
      <programlisting xml:space="preserve">for &lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;a&gt;{$a := (., .)}&lt;/a&gt;&lt;/root&gt; in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt; return .</programlisting>
      results in the tuple stream
      <programlisting xml:space="preserve">($a = &lt;a&gt;1&lt;/a&gt;,             $b = ()),
($a = (),                   $b = &lt;b&gt;2&lt;/b&gt;)
($a = (&lt;a&gt;3&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;), $b = ())
</programlisting>
      
       </para><!--      <programlisting>
        	InitialClause 	       ::=    	ForClause | LetClause | WindowClause | MatchLetClause | MatchForClause
        	IntermediateClause     ::=    	InitialClause | WhereClause | GroupByClause | OrderByClause | CountClause
        	MatchForClause 	       ::=    	"for" "match" PatternForBinding ("," PatternForBinding)*
        	PatternForBinding      ::=    	PatternExpr "in" ExprSingle
        	MatchLetClause         ::=    	"match" PatternLetBinding ("," PatternLetBinding)*      
        	LetBinding             ::=    	PatternExpr ":=" ExprSingle
      </programlisting>--><para>Combinations of <code>let</code> and <code>for</code> as well as the intermediate clauses can be used as usually, since they change the tuple stream in a certain way, independent of the source of that tuple stream.</para></section></section></section><section><title>Using pattern matching for data mining</title><para>In this section we summarize our experiences and observed issues when applying the pattern matching to perform data mining from various webpages, which is, in fact, the purpose the patterns were designed for.  </para><para>The webpages in question are the 
    <!--We have applied the described system to perform data mining from the -->  catalogs of over 175 different libraries which were using 14 different library systems with, in total, around 100 individual HTML pages. We have created a pattern for each of these 100 pages, ranging from querying  all the data on the page to querying a single link. With these patterns we mirror the entire functionality of the catalog, like searching for books, getting detailed bibliography data, ordering them for lending, showing the items lend by a patron, renewing loans...  A list of these libraries is available on the <link xlink:href="http://videlibri.sourceforge.net/#libraries" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">German VideLibri webpage</link> and the patterns itself can be found in its <link xlink:href="http://sourceforge.net/p/videlibri/code/ci/trunks/tree/programs/internet/VideLibri/data/libraries/templates/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">source repository</link>.<!-- that we have created patterns for. <!- -61 + 44 -2 - -> We can conclude that task would have been much more difficult and taken much more time without these patterns<footnote><para>Although possibly not as-->
    </para><!--    <section>
	    <title>Advantages</title>--><para>
	    We have observed the following positive aspects when applying the pattern matching:
	    <itemizedlist><listitem><para>The patterns have vastly simplified the task of mining data from a new webpage. As mentioned above a pattern "can be created by copying the input data, completely removing all data that should not be queried for, replacing the remaining data with annotations and finally calling it a pattern", so we can add a new webpage in a few minutes<footnote><para>Outside the scope of this paper, we have simplified this creation process even further by developing a script that can create a pattern for a HTML file, by just selecting the relevant data with the mouse in Firefox.</para></footnote> and an entire new library system in an hour (up to corner cases/bugs that only appear after months of testing).</para></listitem><listitem><para>A more concise point is that the pattern is useful for "grounding" an XQuery expression. If we use path expressions to query data from the same element, we either have to prefix each expression with <code>//all/ancestors/of/that/element/</code> (pointless redundancy) or create a new variable <code>$var := //all/ancestors/of/that/element/</code> and prefix <code>$var</code>  instead (many variables to name and keep track of). With patterns we create just one element <code>&lt;all&gt;&lt;ancestors&gt;&lt;of&gt;&lt;that&gt;&lt;element&gt;{...}&lt;/element&gt;&lt;/that&gt;&lt;/of&gt;&lt;/ancestors&gt;&lt;/all&gt;</code> (or copy it from the webpage) and all expressions inside that element are relative to it. This is especially helpful, if there are additional expressions with  partial identical ancestors like,  <code>//all/ancestors/of/that/element/foo/bar</code> and <code>//all/ancestors/of/x/y/z</code>. The patterns make it obvious how they are related to each other and in which order they occur on the webpage, the path expression not so much. </para></listitem><listitem><para>It is very easy to query for elements surrounded by certain siblings like <code>&lt;root&gt;&lt;pre-sibling/&gt;&lt;elements/&gt;+&lt;post-sibling/&gt;&lt;/root&gt;</code> or more specific <code>&lt;root&gt;&lt;h2&gt;Header 1&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Header 2&lt;/h2&gt;&lt;/root&gt;</code>, which often occurs on webpages and is not easy in pure XPath.</para></listitem><listitem><para>Many people prefer to CSS selectors instead XPath/XQuery expressions, because they are better suited to process HTML, e.g. when querying for classes and ids, although those selectors cannot process the selected data. Our patterns are as easy to use as CSS selectors (especially due to special handling of <code>class</code> attributes) and provide a way to process the data with all the power of XQuery. </para></listitem><listitem><para>As expected the patterns are much shorter than queries in a non pattern based system. We do not know how many lines our implementation would have required without patterns, but we can compare it to another, independently developed, open-source project (using Java and CSS selectors) that attempts to mine data from some of these pages. <!--can query 3 of our 14 systems--> For these pages, our pattern based implementation consists of 1641 lines (mostly copied from the original pages), while the other project had to use 3362 lines (assumed to be written manually).</para></listitem><listitem><para>The patterns are easy to unit test. For this we keep an archive of all ever mined webpages and match the corresponding pattern to each of them, testing if they still return the same assignment stream.  This would be difficult to do for a bunch of path expressions, since these expressions are embedded within a query and do not return an assignment stream, so for every tested pattern there would be several path expressions to test. </para></listitem></itemizedlist>
	    </para><!--<para>We used the following workflow:
	    <itemizedlist>
	    <listitem></listitem>
	    <listitem></listitem>
	    <listitem></listitem>
	    <listitem></listitem>
	    </itemizedlist>
	    </para>--><para><!--We have applied the described system to perform data mining from the webcatalogues of over 175 different libraries which were using 14 different library systems with, in total, around 100 individual HTML pages that we have created patterns for. <!- -61 + 44 -2 --> We can conclude that the mining task would have been much more difficult and taken much more time without our patterns<footnote><para>Although possibly not as much time, as we have spend developing a complete XQuery engine to integrate the patterns.</para></footnote>. </para></section><!--
            vl        webopac
    pica:   476          780
    sisis: 1475          572 the columns are swapped, aren't they?
    adis:  1107          593
    --><section><title><!--Problems\section{Further work}-->Futher work</title><!--We have  is not yet powerful --><para>Nevertheless the practical application has shown that the pattern are still  neither as easy and intuitive to use nor as powerful as we hoped. <!--a few problems of the pattern matching, which we describe in the--> The following list describes a few observed issues together with possible extensions that might solve them:</para><itemizedlist><listitem><para>Within loops the validating-property works against its purpose, such that too strongly validating patterns in loops lead to skipped elements.
                For example, you can use the following pattern to read the 2nd column of all rows of a table that have an image in the first column: <programlisting xml:space="preserve">&lt;tr&gt;&lt;td&gt;&lt;img/&gt;&lt;/td&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+</programlisting> 
                But if (unexpectedly) a row does not contain an image
                <programlisting xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;img unavailable&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</programlisting>
 it is skipped, because the row does not match, which can be surprising to someone expecting either a correct matching of all rows or a matching error. </para><para>In this example the issue is easily solved by marking the image as optional, either with a following <code>?</code> or the <code>t:optional</code> attribute. However, someone creating the pattern has to remember to do that, and needs to know that there might be no image. But when patterns are created based on various samples from a webpage, we often do not know which elements are optional and not.</para><para>We have considered two possible extensions to the pattern syntax, which could solve the issue of skipped rows by requiring that all rows participate in the matching: 
          <itemizedlist><listitem><para>An option that all children of a certain element have to be matched, if one of them has been matched. (a <code>++</code> qualifier might fit well) </para></listitem><listitem><para>An option that disables the recursive matching, when searching the next match for a loop child, and only tests the loop child itself  (and perhaps its n-th  descendants for a fixed n), if it would match an element (as if the loop child had no children itself). If this first test succeeds, the recursive matching is performed to evaluate the contained selector expressions as before, but if that recursive matching fails then, the entire matching is aborted with a matching error. E.g. with this option, a pattern like <code>&lt;tr&gt;...&lt;/tr&gt;+</code> would first ignore the <code>...</code> and just search the next <code>tr</code>-element. Afterward the <code>...</code> would be matched against that element as usual, propagating exceptions. </para></listitem></itemizedlist></para></listitem><listitem><para>There is no syntax to match or loop over table <emphasis>columns</emphasis>, instead rows. Although you can read the i-th column by prepending <code>&lt;td/&gt;{i-1}</code> to skip the previous <code>i-1</code> columns, it is quite difficult to create a pattern that matches the i-th column on one page and the j-th column on another, or that handles different column orders on different pages<footnote><para>Former case can be solved with optional columns, later only with both cases being included in the pattern as switchable subpatterns.</para></footnote>. This issue stems from the hierarchical structure of SGML and is problematic in every query language.</para><para>To solve it, a pattern syntax not based on a tree structure is required. Maybe it is possible to add an option that connects the order of children of different elements in the pattern. Then the first row of the pattern could match the header, unordered, and the following rows were linked to the header row, such that the children are processed in the same order the header elements were assigned to their matches. </para></listitem><!--No handlign of order ??--><listitem><para>Some pages use a table layout with many nested tables. In these cases the table, tr, td-elements of a pattern that are supposed to match a single table might all match <emphasis>different</emphasis> tables. For example <programlisting xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+
&lt;/table&gt;</programlisting> appears to be a good pattern to match all rows below a header row in a certain table. <!--and raise a matching error, if no rows exist.--> However, if table layouts are used like in 
      <programlisting xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;bar&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</programlisting> the table-element matches the outer table (because it still contains a descendant <code>Header</code> text node), and the pattern selects all rows of that table, i.e. the last td-element containing <code>bar</code>. And <emphasis>not</emphasis> the td-element containing <code>foo</code>.
      </para><para>A solution would be to add an option to only match direct children of certain elements, instead all descendants. Perhaps even enable it at default for tables, although this will cause new issues with table rows never being children of the table, but of a tbody-element. </para></listitem><listitem><para>Despite our goal of minimality there is a lot of unnecessary redundancy in the pattern syntax. For example a frequently used pattern to read properties of a book is
      <programlisting xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Author:&lt;/td&gt;   &lt;td&gt;{$book.author}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Title:&lt;/td&gt;    &lt;td&gt;{$book.title}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Publisher:&lt;/td&gt;&lt;td&gt;{$book.publisher}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Year:&lt;/td&gt;     &lt;td&gt;{$book.year}&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</programlisting> which contains many duplicated td and tr-elements. This is not a problem during the creation of the pattern, but if it needs to adapted to changes (e.g. to read divs instead tds or have the value in the third column) each tag has to updated, which is pointless work.</para><para> So perhaps some kind of "meta-pattern" needs be developed that can create a pattern programmatically within the pattern itself, like a macro in C++ or a function with access to the AST.   </para></listitem><listitem><para>The validation property was not as useful as expected to find errors. We assumed that an element throwing a matching error tells us, which element in the pattern was wrong/changed and should be adapted. But although this works in patterns like <code>&lt;a&gt;&lt;b&gt;&lt;c&gt;{.}&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</code>, where we can get a matching error for a, b or c and know which element is missing in the input, in patterns containing multiple alternatives like  <code>&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}/b&gt;</code> we get a matching error for the t:switch expression and cannot distinguish if the input was supposed to match a or b.</para><para>Therefore the error reporting <!--of matching errors -->has to somehow consider all possible pattern branches and report the error for the most likely one.</para></listitem><!--
      <listitem>
      <para>Finally the psychological issue that many end users do not recognize the value of matching exceptions<!- - according to their received feedback.- ->. They would rather have the application showing some (possible invalid) result than aborting the processing altogether.</para>
      <para>A possible, far fetched solution would be better computer science education, possibly starting in elementary school.</para> 
      </listitem>- ->
      
      </itemizedlist>
   <!- - </section>--><!--  </section>--><!--  <section>
    <title>Further work<!- -\section{further work}- -></title>--><!-- We suggest the following points for interesting, further research:
      <itemizedlist>
      <listitem><para>Solving the issues described in the previous section.</para></listitem>--><listitem><para>
      Currently every pattern is represented by a valid XML file, which is useful for automatic parsing/processing and familiarity.
      However, the pattern syntax can be greatly simplified by allowing non-valid XML patterns.
      The first possible extension in this direction is to allow regular expressions as element and attribute names. A simple pattern like
      <programlisting xml:space="preserve">&lt;a|b|c foo|bar="123" x.z="17" /&gt;</programlisting>
      could then replace this more complex, but equivalent pattern:
      <programlisting xml:space="preserve">&lt;t:switch&gt;
&lt;a foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;a bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;b foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;b bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;c foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;c bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;/t:switch&gt;</programlisting>
      </para><para>      
      The second extension is to allow other attribute value separators than the <code>=</code> sign which would specify the matching mode used for the string value. 
      
      E.g. the symbols <code>==</code>, <code>~=</code>, <code>^=</code>, <code>$=</code>, <code>*=</code> or <code>|=</code> could be used to specify the resp. matching mode
      <code>eq</code>, <code>matches</code>, <code>starts-with</code>, <code>ends-with</code>, <code>contains</code> or <code>list-contains</code>.
      
      For example <code>foo ^= "bar"</code> would match a foo attribute starting with "bar".
      
      </para><para>      
      The third is to allow omitted end tags. Currently half of the pattern consists of redunant end tags, which is not very useful. If we allow the old SGML syntax with closing short tags <code>&lt;/&gt;</code> or null end tags <code>&lt;element/ ... /</code> in the pattern, it could be much shorter. Since we already match the patterns  against HTML as well, there is no point in keeping a pure XML syntax.
      </para></listitem><listitem><para>
      The patterns as defined so far only match against the string values of the nodes. It might be useful to combine them with XML schemas to match on typed values, distinguishing e.g. <code>xs:integer(17)</code> and <code>xs:string("17")</code>.
      </para></listitem><listitem><para>
      <!--How the pattern matching can be implemented in the most efficient way. -->Our current implementation performs naive backtracking, following exactly the recursive definition of the matching process, which is well suited for the fast testing of experimental syntaxes. It is, however, not very performant. It is therefore worthwhile to research more efficient ways to implement patterns. One faster way would be to use dynamic programming, using a <code>n*m</code> table tracking which pattern element can be matched to which input element. Another way might be to model the matching as NFA like a regular expression.  A third way would be an automated conversion of a pattern to normal path expressions. Such an approach could benefit from the existing research on query optimization, but might miss specific optimizations applicable only to the patterns. Especially problematic from an optimization POV is that variables created in a selector expression could be later used in a condition affecting the matching. It might be a good idea to implement the special case where such usage does not occur separately. 
      </para></listitem><listitem><para>
      The basic node patterns do not have a syntax for back (like <code>parent::</code>) or forward (like <code>following::</code>) references. Therefore they seem to present a  natural way to write queries with streaming parsers that read one element at the time and do not store preceding or following nodes.   <!--It is therefore probably possible to use them in a streaming XML parser in a very efficient way.-->
      It is worthwhile to investigate how well and efficient they can be combined with such a streaming XML parser. 
      </para></listitem><listitem><para>
      Once further extensions have been researched, it might be a good idea to convince the W3C to add patterns to the next XQuery standard.
      </para></listitem></itemizedlist></section><section><title>Conclusion<!--\section{conclusion}--></title><para>We have presented a true pattern matching on XML and HTML nodes with a syntax based on regular expressions and XQuery, which provides an intuitive way to write  queries for XML and HTML data. It was then successfully extended to matching on arbitrary JSONiq data, albeit with a less intuitive syntax.  </para><para>It was then shown that it can be integrated naturally in XQuery <code>switch</code>, <code>let</code> and <code>for</code> expressions, allowing one to use patterns in XQuery and XQuery expressions in patterns. </para><para>We conclude with the experiences of many years of pattern matching usage that such a matching is very useful to run queries on schema-less data like HTML pages, although there are still open issues and possible further syntax extensions that need to be researched. </para></section><section><title>Acknowledgment</title><para>This paper was supported by the Graduate School for Computing in Medicine and Life Sciences funded by Germany’s Excellence Initiative [DFG GSC 235/1].</para></section><bibliography><title>Bibliography</title><bibliomixed xml:id="xmlql" xreflabel="XMLQL">Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and Dan Suciu. <emphasis role="ital"> XML-QL: A Query Language for XML</emphasis>. 1998. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/1998/NOTE-xml-ql-19980819</link></bibliomixed><bibliomixed xml:id="xml" xreflabel="XML">W3C <emphasis role="ital">Extensible Markup Language (XML) 1.0</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"> http://www.w3.org/TR/xml/</link></bibliomixed><bibliomixed xml:id="xquery" xreflabel="XQuery">W3C <emphasis role="ital">XQuery 3.0: An XML Query Language</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-30/</link></bibliomixed><bibliomixed xml:id="jsoniq" xreflabel="JSONiq">Jonathan Robie, Ghislain Fourny, Matthias Brantner, Daniela Florescu, Till Westmann, and Markos Zaharioudakis. <emphasis role="ital">The JSON Query Language</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.jsoniq.org/docs/JSONiqExtensionToXQuery/html-single/index.html</link></bibliomixed><bibliomixed xml:id="scala" xreflabel="Scala">Odersky, M., Altherr, P., Cremet, V., Emir, B., Maneth, S., Micheloud, S., ... &amp; Zenger, M. <emphasis role="ital">An overview of the Scala programming language</emphasis>. 2004.</bibliomixed><bibliomixed xml:id="rel1" xreflabel="Fischer2010">Peter Fischer,  Aayush Garg and Kyumars Sheykh Esmaili.   <emphasis role="ital">Extending XQuery with a Pattern Matching Facility</emphasis>, in Database and XML Technologies, Lecture Notes in Computer Science. 2003. </bibliomixed><bibliomixed xml:id="rel2" xreflabel="Hosoya2003">Haruo Hosoya, and Benjamin C. Pierce.  <emphasis role="ital">Regular expression pattern matching for XML</emphasis>, in Journal of Functional Programming. 2003. </bibliomixed><bibliomixed xml:id="rel3" xreflabel="Yao2004">J. T. Yao, and Ming Zhang. <emphasis role="ital">A fast tree pattern matching algorithm for XML query</emphasis>, IEEE. 2004. </bibliomixed><!--@incollection{
    year={2010},
    isbn={978-3-642-15683-0},
    booktitle={Database and XML Technologies},
    volume={6309},
    series={, Lecture Notes in Computer Science},
    editor={Lee, MongLi and Yu, JeffreyXu and Bellahsène, Zohra and Unland, Rainer},
    doi={10.1007/978-3-642-15684-7_5},
    title={Extending XQuery with a Pattern Matching Facility},
    url={http://dx.doi.org/10.1007/978-3-642-15684-7_5},
    publisher={Springer Berlin Heidelberg},
    keywords={XQuery; Pattern Matching},
    author={Fischer, PeterM. and Garg, Aayush and Sheykh Esmaili, Kyumars},
    pages={48-57}
    }--></bibliography></article>