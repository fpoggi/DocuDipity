<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title>The Effects of Bytecode Generation in XSLT and XQuery</title><info><confgroup><conftitle>Balisage: The Markup Conference 2011</conftitle><confdates>August 2 - 5, 2011</confdates></confgroup><abstract><para>This paper attempts to analyze the performance benefits that are achievable by
                adding a code generation phase to an XSLT or XQuery engine. This is not done in
                isolation, but in comparison with the benefits delivered by high-level query
                rewriting. The two techniques are complementary and independent, but can compete for
                resources in the development team, so it is useful to understand their relative
                importance. We use the Saxon XSLT/XQuery processor as a case study, where we can now
                translate the logic of queries into Java bytecode. We provide an experimental
                evaluation of the performance of Saxon with the addition of this feature compared to
                the existing Saxon product. Saxon's Enterprise Edition already delivers a
                performance benefit over the open source product using the join optimizer and other
                features. What can we learn from these to achieve further performance gains through
                direct byte code generation?</para></abstract><author><personname><firstname>O'Neil</firstname><othername>Davion</othername><surname>Delpratt</surname></personname><personblurb><para>Dr Delpratt is a software developer at Saxonica. Before joining Saxonica, he
                    completed his post-graduate studies at the University of Leicester. His thesis
                    title was 'In-memory Representations of XML documents', which coincided with a
                    C++ software development of a memory efficient DOM implementation, called
                    Succinct DOM.</para></personblurb><affiliation><orgname>Saxonica</orgname></affiliation><email>oneil@saxonica.com</email></author><author><personname><firstname>Michael</firstname><surname>Kay</surname></personname><personblurb><para>Michael Kay has been developing the Saxon product since 1998, initially as a
                    spare-time activity at ICL and then Software AG, but since 2004 within the
                    Saxonica company which he founded. He holds a Ph.D from the University of
                    Cambridge where he studied under the late Maurice Wilkes, and spent 24 years
                    with ICL, mainly on development of database software. He is the editor of the
                    W3C XSLT specification.</para></personblurb><affiliation><orgname>Saxonica</orgname></affiliation><email>mike@saxonica.com</email></author><legalnotice><para>Copyright Â© 2011 by the authors. Used with permission.</para></legalnotice><keywordset role="author"><keyword>XSLT</keyword><keyword>XQuery</keyword><keyword>java</keyword><keyword>bytecode</keyword></keywordset></info><section xml:id="Introduction"><title>Introduction</title><para>Many modern compilers generate code in an intermediate representation which is then
            interpreted by a virtual machine. One of the best known examples is Java: its
            intermediate code (known simply as bytecode) has proved flexible enough to be used as a
            target by many other high-level languages, allowing these languages to be mixed in the
            same Java Virtual Machine (JVM). XSLT and XQuery are no different from other languages
            in this respect, and a number of processors for these languages have used code
            generation to boost performance. There are few reports, however, that enable the
            effectiveness of this technique to be assessed, largely because of the difficulty in
            attributing performance differences to one particular optimization technique. This paper
            attempts to evaluate the impact of introducing code generation into the Saxon processor,
            enabling such a comparison to be made.</para><para>One well-known XSLT processor that compiles queries to Java bytecode is XSLTC [<xref linkend="XSLTC"/>]. [<xref linkend="XSLTC"/>] at a superficial level works by
            parsing the XSLT into an Abstract Syntax Tree (AST) which then goes through a
            type-checking phase before being compiled into Java bytecode. The output is a so-called
                <emphasis role="ital">translet</emphasis> class which can be used for
            transformations or saved to disk for re-use later. For XSLTC (which is distributed as
            part of the Apache Xalan-J package), the aim is not only to deliver enhanced performance
            in the runtime execution of queries, but also to produce a compact executable (the
            translet) which can be readily shipped around the network and executed anywhere.</para><para>Code generation is also believed to be used in a number of proprietary XSLT
            processors, such as the Datapower processor [<xref linkend="DataPower"/>] and
            Microsoft's .NET processor. However, no technical details of these products have been
            published in the literature.</para><para>Saxon first introduced Java code generation as long ago as version 4.2 [<xref linkend="Kay1999"/>] (some six months before XSLT 1.0 was published in 1999).
            However, this proved to be something of a blind alley, since it became clear that much
            greater performance gains could be realized through other optimization techniques, and
            that the existence of a code generator actually made these techniques more difficult to
            introduce. The architecture of Saxon at this time was to interpret the DOM of the source
            stylesheet directly instead of building an expression tree. This design made it
            impossible to do any extensive optimisation rewrites, as it is done now. One of the
            present authors [<xref linkend="Kay2006a"/>] argued that <quote> high-level
                optimizations are more important, and that compiling expressions to bytecode might
                reduce the scope for high-level optimizations, if only by making them more complex
                to implement and debug.</quote>As a result, the code generation was "shelved" while
            the architecture was changed to introduce tree rewriting. </para><para>Eventually code generation re-emerged in version 8.9 (Feb 2007), supporting XQuery
            only. It still took the form of Java source code generation, rather than bytecode
            generation. But it cannot be counted a great success: we are aware of very little usage.
            This is for several reasons:</para><para>
            <itemizedlist><listitem><para>From a user perspective the generation of java source code is cumbersome,
                        requiring three phases: firstly they must generate the Java source code to a
                        file, then the Java source must be compiled, and finally the query can be
                        executed.</para></listitem><listitem><para>The performance gains are modest (typically 25% improvement).</para></listitem><listitem><para>There are numerous restrictions concerning the subset of the language that
                        is supported in this mode.</para></listitem></itemizedlist>
        </para><para>This paper describes a new approach in which we hope to eliminate these problems. In
            particular, we believe that a 25% speed-up is not enough to encourage users to go to a
            great deal of effort in the way they execute their stylesheets and queries, but it will
            be much appreciated if it comes with no effort. There is a commercial factor which
            motivates this: Saxon is distributed in two versions, a free open-source product and a
            commercial paid-for version. While the commercial Enterprise Edition already has many
            features that users value, including features that can be used to deliver improved
            performance, users are sometimes disappointed to find it does not always run faster "out
            of the box". Code generation is an obvious way to remedy this, and ensure that users who
            pay their dues get some immediate benefit, with no need to change a single line of
            code.</para><para>Our objectives in adding code generation to Saxon are rather different from those for
            XSLTC, and this affects the approach we have adopted. In particular, we are not
            primarily interested in producing an executable that can be saved to disk or sent around
            the network. Rather, we want to integrate code generation and interpretation closely, so
            that we only generate code where there is a performance benefit to be gained, and
            continue to interpret otherwise. This should ensure that there are no language
            restrictions or differences when using code generation; it allows development effort to
            be focused where the potential gains are largest; and it limits the extent to which the
            existence of a code generation phase working off the expression tree limits our freedom
            to evolve the design of the expression tree itself when implementing new rewrite
            optimizations. </para><para>The remainder of this paper is organized as follows. Firstly, we discuss the
            high-level optimization of Saxon. Secondly, we discuss the bytecode generation feature
            of Saxon. Then we give an experimental evalaution of the running time performance of
            bytecode generation compared to Saxon interpreted mode. We base our experiments on the
            XMark benchmark queries, and conclude our findings.</para></section><section><title>High-level Optimization</title><para>The Saxon XSLT/XQuery processor includes a number of internal processes to compile,
            simplify and execute queries or stylesheets efficiently. In our discussion we will only
            make reference to XQuery, however in the Saxon internals very similar processes apply to
            XSLT.</para><para>Queries are parsed by a XSLT/XQuery compiler into a Abstract Syntax Tree (AST), which
            is a in-memory expression tree structure representing the logical structure of the
            query. In the case of XSLT, this tree combines the two sublanguages, XSLT and XPath,
            into a single integrated structure. References to variables and functions are largely
            resolved during parsing, an operation that is only slightly complicated by the fact that
            forwards references are permitted. Saxon then perfoms three optimization steps to
            produce the final AST that is interpreted at runtime. The first step is the
            normalisation of the AST, the second step is the type checking of the sub-expressions,
            and the third is expression rewriting. Detail of these are provided in the literature
                [<xref linkend="Kay2008"/>], [<xref linkend="Kay2006b"/>] and [<xref linkend="Kay2005"/>]. We summarize these steps below. </para><para>The optimizations require several depth-first traversals of the tree. In Saxon a
            visitor object provides a depth-first navigation of the expression tree. This class
            supports the various optimization steps involved in the processing of an expression
            tree, as it requires a recursive walk visiting each node in turn. A stack is also
            maintained as each node is visited, which holds the current ancestor nodes. The
            expression tree consists of many kinds of expression nodes, each of which implement the
            Expression interface. (This is the classic Interpreter design pattern.) The Expression
            class contains three important methods: <emphasis>simplify</emphasis>,
                <emphasis>typeCheck</emphasis> and <emphasis>optimize</emphasis>. <orderedlist><listitem><para><emphasis>Normalisation</emphasis>. As in databases this is an important
                        step, where we minimize redundancies in queries. In Saxon the expression
                        visitor is used to walk the tree. At each expression node the <emphasis role="ital">simplify</emphasis> method is called on its child
                        sub-expressions before normalisation is applied if required. It is possible
                        that at each node the <emphasis>simplify</emphasis> method may be called
                        several times after the re-writing of sub-expressions. For example, the
                        XPath <code>a/b/c</code> is rewritten to <code>docOrder(a!b!c)</code>, where
                        docOrder is an operator that eliminates duplicates and sorts into document
                        order, and <code>!</code> is a simple mapping operator which evaluates
                            <code>c</code> once for each item in <code>b</code>, which in turn is
                        evaluated once for each item in <code>a</code>.</para></listitem><listitem><para><emphasis>Type Check</emphasis>. As we traverse the expression tree each
                        sub-expression node is type checked. Here checks are performed on the
                        operands of the expression, whether the static types of the operands are
                        known to be subtypes of the required type. [<xref linkend="Kay2006b"/>]
                        details several possible outcomes in the process: The static type is a
                        subtype of the required type, then no further check is required, or some
                        instances only are instances of the required type, here a node is inserted
                        in the tree to indicate run-time type check required. The other possiblility
                        is that the static type and the required type are disjoint, therefore Saxon
                        generates a type error at compile time. Saxon also performs atomization
                        conversions, such as casting of untypedAtomic values. It also removes any
                        redundant conversions, such as casts written by the user. </para></listitem><listitem><para><emphasis>Expression Rewriting (Optimization)</emphasis>. The optimizing
                        of XSLT stylesheets, XQuery and XPath expressions is a well studied area,
                        which has provided implementations significant performance gains. In [<xref linkend="Kay2007"/>] and [<xref linkend="Snelson2011"/>] there is a
                        detailed study of the main optimization techniques, some of which are used
                        in Saxon. The rewrite of expressions is achieved in the
                            <emphasis>optimize</emphasis> method, requiring a third pass of the
                        expression tree. Saxon performs join optimization (familar in database
                        languages), by replacing predicate expressions with key indexes. There are
                        other techniques such as function inlining and the optimization of tail
                        recursion, which is familar in functional programming languages. This is
                        another area where Saxon differentiates the commercial product from the free
                        open-source product: many of the more advanced optimizations are available
                        in the Enterprise Edition only.</para></listitem></orderedlist></para><para>Each of these phases adds information to the tree. The most obvious information is the
            inferred static type of each expression, but there are many other properties that play
            an equally important role: for example the dependencies of an expression on variables or
            on the dynamic context, and properties of node-sets such as whether they are known to be
            sorted and whether they can contain duplicates. </para></section><section><title>Bytecode Generation</title><para>We now discuss a new Java bytecode generation feature in Saxon, which we consider as a
            fourth step in the optimization processes discussed in Section 2. It directly replaces
            the java source code generation feature provided in Saxon up to version 9.3. Here we are
            now generating the Java bytecode directly when compiling a query after it has been
            optimized. Our approach is different to that in XSLTC because we are generating bytecode
            selectively for expressions that are considered to have potential performance
            improvements, so that interpreted code and compiled code interact freely. The fact that
            compiled code exists only transiently in memory means that it can refer to data
            structures on the expression tree, rather than regenerating them at initialization time.
            In the longer term, this architecture also leaves the door open to just-in-time
            compilation (or hotspot compilation) based on observed execution patterns at
            run-time.</para><para>There are a number of Java class manipulation tools available (see <xref linkend="Bruneton2002"/>). One of the most widely used of these tools is BCEL [<xref linkend="Dahm1999"/>, <xref linkend="Bruneton2002"/>]. In this tool the class
            modification is achieved in a three part process: The bytecode representing the class is
            deserialized into a constructed class structure in memory, with a object created for
            each node, right down to the bytecode instructions. This structure is then manipulated
            in the second phase. The third phase is to serialize the modified object structure into
            a new byte array. </para><para>We chose instead to use the ASM [<xref linkend="Bruneton2002"/>] framework library
            tool to generate bytecode for queries. ASM [<xref linkend="Bruneton2002"/>] claims to be
            smaller and to give better performance than other tools. Where BCEL builds a DOM-like
            tree representation of the code, ASM works using a series of SAX-like streaming passes
            over it. There are other Java class manipulation tools which we only mention here such
            as SERP, JIOE: these are described in [<xref linkend="Bruneton2002"/>]. We have not done
            any experimental anaylsis of the Java class manipulation tools nor is there scope in
            this paper to provide an anaysis of these tools. Nevertheless, we have chosen the ASM
            library based upon [<xref linkend="Bruneton2002"/>], due to the simplicity of the tool
            and our requirement which only relied upon a small part of the library to dynamically
            generate bytecode in the runtime of queries.</para><para>The bytecode generation process has as input an AST, optimized to a greater or lesser
            extent in earlier phases depending on the Saxon product that is used. The top-level
            expression in each function or XSLT template is compiled into an equivalent Java
            bytecode class. We call this a <emphasis>CompiledExpression</emphasis>: it is
            constructed as we traverse the AST and can be evaluated at runtime. If the expression
            cannot be compiled, perhaps because it uses unusual language constructs, it is simply
            interpreted instead: but its subexpressions can still be compiled. The structure of the
                <emphasis>CompiledExpression</emphasis> is as follows: Firstly we generate static
            variables which have been initialised. As mentioned above, we are generating transient
            bytecode that works interchangably with interpreted code. The static variables in the
            generated code contain references to data on the expression tree: either whole
            expressions, or helper classes such as node tests, comparators, converters, and the
            like. For example, the <emphasis>NodeTest</emphasis> object, which provides XSLT pattern
            matching, acts as a predicate in axis steps, and also acts as an item type for type
            matching, is stored as a static variable available for use in the bytecode generated. </para><para>As discussed in [<xref linkend="Kay2009"/>] and [<xref linkend="Kay2010"/>], Saxon can
            execute internally in both <emphasis>pull</emphasis> and <emphasis>push</emphasis> mode.
            In pull mode, an expression iterates over the data supplied by its child expressions;
            child expressions therefore implement an <emphasis role="ital">iterate()</emphasis>
            method which delivers results incrementally to the caller. In push mode, an expression
            writes SAX-like events to an output destination (a <emphasis role="ital">Receiver</emphasis>). Choosing between pull and push mode can make a substantial
            difference to performance: during development, when we have observed situations where
            compiled code was outperformed by interpreted code, it was generally because the
            interpreter was making better decisions on when to pull and when to push. The compiled
            code therefore needs to work in both modes, so each
                <emphasis>CompiledExpression</emphasis> has two methods: an
                <emphasis>iterate</emphasis> method to deliver results to its caller, and a
                <emphasis>process</emphasis> method to write events to a Receiver. A third method,
                <emphasis role="ital">evaluateItem()</emphasis>, is provided for single-shot
            evaluation of expressions that always return a singleton result. Of course in many cases
            these methods will share common logic.</para><section><title>Architecture of Java bytecode generator</title><para>The <emphasis>ExpressionCompiler</emphasis> is an abstract class which represents
                the compiler (that is, Java bytecode generator) for a particular kind of expression
                on the expression tree. The <emphasis>ExpressionCompiler</emphasis> classes are used
                to build the <emphasis>CompiledExpression</emphasis> class in bytecode, traversing
                the expression tree in depth-first manner: there is a one-to-one correspondence
                between the classes implementing the expression on the expression tree and the
                compiler object used to generate Java code fragments<footnote><para>It would have been possible to use the same class for both purposes: This
                        is a rare example of a distortion to the design caused by Saxon's need to
                        divide open-source from proprietary code.</para></footnote>. The following methods are supplied to compile expressions; exactly one
                of them is called, depending on the context in which the expression appears:
                <programlisting xml:space="preserve">compileToItem    - Generate bytecode to evaluate the expression as an Item
compileToIterator - Generate bytecode to evaluate the expression as an Iterator.
compileToBoolean  - Generate bytecode to evaluate the expression as a boolean.
compileToPush     - Generate bytecode to evaluate the expression in push mode.
compileToLoop     - Generate bytecode to evaluate the expression in such a way that
                the supplied loop body argument is executed once for each Item. 
compileToPrimitive - Generate bytecode to evaluate the expression as a plain Java value 
                     (e.g. int, double, String). This method must only be called if the 
                     target type of the expression is known  statically.</programlisting></para><para>Within each kind of expression one or more of the methods above is implemented.
                For example, the <emphasis role="ital">exists()</emphasis> function delivers a
                boolean value so we implement the <emphasis role="ital">compileToBoolean</emphasis>
                method. To understand why compiled code is sometimes faster than interpreted code,
                it is useful to examine this example in some detail. Essentially, compiled code will
                only be faster than the interpreter if decisions can be made at compile-time than
                would otherwise be made at execution time. There are many cases where this is simply
                not possible: for example, code that is dominated by string-to-number conversion
                will gain no speed-up from compilation, because the actual code executed is
                identical whether it is compiled or interpreted. Making decisions at compile time is
                only possible where the information needed to make those decisions is present in the
                expression tree. For example, for the <emphasis role="ital">exists()</emphasis>
                function we compare its <emphasis role="ital">compileToBoolean</emphasis> method to
                the interpreted code and the Java source generation below. The simple query
                    <code>exists(.)</code> generates the following bytecode in push mode (simplified
                only to remove diagnostic information used by the debugger):</para><programlisting xml:space="preserve">
 public process(Lnet/sf/saxon/expr/XPathContext;)V
   L0
    // Get the Receiver to which output will be sent
    ALOAD 1    // the XPathContext object
    INVOKEINTERFACE net/sf/saxon/expr/XPathContext.getReceiver ()Lnet/sf/saxon/event/SequenceReceiver;
    ASTORE 2   // local variable holding the current Receiver
    ALOAD 2
   L1
   L2
    // Get the context item (evaluate ".")
    ALOAD 1    // the XPathContext object
    INVOKEINTERFACE net/sf/saxon/expr/XPathContext.getContextItem ()Lnet/sf/saxon/om/Item;
    DUP
    // Generate an error if no context item is defined
    IFNONNULL L3
    NEW net/sf/saxon/trans/XPathException
    DUP
    LDC "Context item for '.' is undefined"
    LDC "XPDY0002"
    INVOKESPECIAL net/sf/saxon/trans/XPathException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V
    DUP
    GETSTATIC CE_main_671511612.nContextItemExpression0 : Lnet/sf/saxon/expr/ContextItemExpression;
    INVOKEVIRTUAL javax/xml/transform/TransformerException.setLocator (Ljavax/xml/transform/SourceLocator;)V
    ATHROW
    // Load "true" (1) or "false" (0) depending on whether the value is null
   L3
    IFNULL L4_returnFalse
    ICONST_1    //Load true (1)
    GOTO L5
   L4_returnFalse
    ICONST_0    //Load false (0)
   L5_endExists
    // Convert the result to a Saxon BooleanValue object and send it to the Receiver
    INVOKESTATIC net/sf/saxon/value/BooleanValue.get (Z)Lnet/sf/saxon/value/BooleanValue;
    INVOKEVIRTUAL net/sf/saxon/event/SequenceReceiver.append (Lnet/sf/saxon/om/Item;)V
    RETURN
}</programlisting><para>It is interesting to compare this with the java source code generated for the same
                query <code>exists(.)</code> using Saxon 9.3:
                <programlisting xml:space="preserve">public void process(final XPathContext context) throws XPathException {
    SequenceReceiver out = context.getReceiver();
    if (context.getContextItem() == null) {
        dynamicError("The context item is undefined", "XPDY0002", context);
    }
    final boolean b0 = (context.getContextItem() != null);
    out.append(BooleanValue.get(b0), 0, NodeInfo.ALL_NAMESPACES);
}</programlisting>The
                logic is very similar, and in fact the bytecode generated when this Java source code
                is compiled is very similar too (just fractionally less efficient because of the
                unnecessary boolean variable <emphasis>b0</emphasis>). See the bytecode of the Java
                source code in <xref linkend="appendix1"/>, which can be compared with the generated
                bytcode above. Thus for a typical query, the new bytecode generation feature does
                not provide noticeable performance benefits over the generated java source from
                Saxon 9.3. However from a usability point-of-view, the advantage is that there is no
                need to compile and run the java program source code, which makes all the difference
                for a typical user.</para><para>It's also worth noting that the logic in Saxon to generate the bytecode is not
                significantly more complex than the logic that was used to generate Java bytecode.
                All the complexity is in the ASM library. Debugging the logic when it is incorrect
                can be a little harder however (diagnostics are not ASM's strongest feature). </para><para> </para></section></section><section><title>Experimental Evaluation</title><para>In this section we draw comparisons of the running time performance between
            interpreted code and generated bytecode. An important aim is to compare the impact of
            code generation with the impact of high-level rewrite optimizations: to this end we run
            with four configurations, both features being switched on or off. (In the released
            product, neither feature will be available in the open source Saxon-HE, and by default
            both will be enabled in Saxon-EE).</para><section><title>Setup</title><para>We used Saxon 9.3.0.4 as the baseline. The test machine was a Intel Core i5
                processor 430M laptop with 4GB memory, 2.26Ghz CPU and 3MB L3 cache, running Ubuntu
                10.04LTS Linux. The compiler was Sun/Oracle Java 1.6.0.2. The experiments are based
                on the XMark benchmark [<xref linkend="XMark"/>]. We use the XMark XQuery queries
                numbered q1 to q20, and synthetically generate several XML data files from [<xref linkend="XMark"/>], these being of sizes in the range 1MB to 64MB.</para><section><title>Running Times</title><para>The 20 XMark queries are run repeatedly up to 1000 times or until 30 seconds
                    have elapsed, and we record the average time spent to complete the runs, using
                    the system clock in Java. [<xref linkend="appendix3"/>] shows the complete
                    running times. We show these for Saxon-HE, Saxon-Bytecode, Saxon-EE and
                    Saxon-EE-Bytecode (that is, with weak optimization and no code generation; with
                    weak optimization plus code generation, with strong optimization and no code
                    generation, and with strong optimization followed by code generation). We
                    compare the running times of the Saxon-EE product for the interpreted code and
                    bytecode. We found on average over all files that bytecode generation gave
                    between 14% and 27% improvement.</para><figure xml:id="Figure1"><title>Scalability test. Running time performance for different file sizes on
                        query 10</title><mediaobject><imageobject><imagedata fileref="../../../vol7/graphics/Delpratt01/Delpratt01-001.png"/></imageobject></mediaobject><caption><para>Scalability test: For Saxon-HE, Saxon-EE and Saxon-EE-Bytecode the
                            timing results of running the XMark benchmark query 10 on XMark
                            generated data files of sizes 2MB, 4MB, 8MB, 16MB, 32MB and 64MB. For
                            Saxon-HE the running time for the 64MB data file is omitted as it goes
                            off the graph.</para></caption></figure><para>In <xref linkend="Figure1"/>, we show a graph of the scalability of running
                    the query 10 on the XMark data files of sizes ranging from 2MB to 64MB with
                    Saxon-HE, Saxon-EE and Saxon-EE-Bytecode. In Saxon-EE and Saxon-EE-bytecode the
                    timing results show a linear growth as files become larger in size. For Saxon-HE
                    we observe a quadratic growth: this shows up the absence of join optimization in
                    the Saxon-HE product.</para><para>In <xref linkend="Figure2"/> and in <xref linkend="Table3"/> in <xref linkend="appendix3"/> we observe that for certain queries the performance of
                    bytecode generation is well above average. Queries 8, 10, 11 and 12 gave
                    improvements between 35% and 50%. We compare the Saxon-EE products with the
                    feature of Java code generation (Saxon-EE-JavaGen, featured in Saxon 9.3), the
                    interpreted code and bytecode. Again we see an overall improvement over the
                    intepreted code, but we observe similar results for Java code generation and
                    bytecode generation, the difference being approximately 10% on average over all
                    queries. </para></section><section><title>Effect of Optimization Rewrites</title><para>Comparison of the timings for different data sizes shows that with weak
                    optimization, queries 8, 9, 10, 11 and 12 have performance that is quadratic in
                    the data size; with strong optimization, only query 11 is quadratic. This is
                    because queries 8, 9, 10 and 12 are equijoins, whereas query 11 is a
                    non-equijoin which the Saxon optimizer cannot handle well.</para><para/><para>
                    <figure xml:id="Figure2"><title>XQuery Queries Running Times (10MB data file)</title><mediaobject><imageobject><imagedata fileref="../../../vol7/graphics/Delpratt01/Delpratt01-002.png"/></imageobject></mediaobject><caption><para>For Saxon-EE-JavaGen (Java Generation in Saxon 9.3), Saxon-EE
                                and Saxon-EE-Bytecode the timing results of running XMark benchmark
                                query 7, 8, 9, 10, 11 and 12 on a 10MB XMark generated data
                                file.</para></caption></figure></para></section></section></section><section><title>Using Hand-written Code as a Benchmark</title><para>In the previous sections we've concentrated on comparing the performance of compiled
            queries and stylesheets with the same queries and stylesheets run under the interpreter.
            But there's another technique we have found useful, which is to compare the performance
            of a compiled query with hand-written Java code performing the same task. The
            performance of the hand-written code sets a target to aim for, and provides a measure of
            how much room for improvement is available.</para><para>The results show great variation between different queries, which is useful
            information in itself. Here we'll consider two simple queries.</para><para>The first computes the average income of buyers recorded in the XMark dataset: we're
            running the query
            <programlisting xml:space="preserve">avg(//profile/@income)</programlisting> against the
            10Mb version of the dataset. </para><para>The Saxon interpreter runs this in an average of 792ms. Currently, when compiling to
            bytecode, the improvement is quite modest: average time is 768ms.</para><para>The same query coded in Java looks like this:
            <programlisting xml:space="preserve">NodeInfo root = doc.getUnderlyingNode();
AxisIterator descendants = root.iterateAxis
                      (net.sf.saxon.om.Axis.DESCENDANT, 
                       new NameTest(Type.ELEMENT, profileNC, pool));
NodeInfo profile;
double total = 0;
int count = 0;
while ((profile = descendants.next()) != null) {
    String income = Navigator.getAttributeValue(profile, "", "income");
    if (income != null) {
        total += Double.valueOf(income);
        count++;
    }
}</programlisting></para><para>The execution time for this code is 690ms. So we see that the interpreter is already
            almost as fast as the hand-written Java code. On the assumption that generated bytecode
            will rarely be better than hand-written Java code, there is little headroom available
            for the code generator to make a significant impact. It's easy to see why this should be
            the case: the query is spending nearly all its time (a) searching the descendant axis
            for <emphasis role="ital">&lt;profile&gt;</emphasis> elements, and (b) converting
            attribute values from strings to numbers. These two operations are done by library
            routines that execute exactly the same code whether it is run under the XQuery
            interpreter, the XQuery code generator, or the hand-written Java code. Both routines
            have been carefully tuned over the years and there is little scope for improvement;
            neither is doing any work that doesn't absolutely need to be done.</para><para>Our second query is rather different. This one doesn't in fact process any XML, so one
            could argue that it is atypical; but as a fragment within a larger query it is code that
            one might well encounter:
            <programlisting xml:space="preserve">sum(for $i in 1 to $p return xs:double($i)*xs:double($i))</programlisting>
            Here, with $p set to 100000, the XQuery interpreter executes the query in 29.4ms. The
            equivalent hand-written Java code is
            <programlisting xml:space="preserve">double j = 0;
for (int i=1; i&lt;=100000; i++) {
    j += (double)i * (double)i;
}</programlisting>and
            this executes much faster, in just 1.2ms. So this time there is a lot more headroom, a
            lot more scope for the code generator to make a difference. Our first version of the
            code generator in fact made no difference at all to the execution time of this query (a
            mere 1% improvement, which is within the range of experimental error). It's not
            difficult to see why: the generated code was essentially an inlined version of the same
            instructions that the interpreter was executing, except for a very small amount of
            control logic to walk the expression tree. Comparing this with the hand-written code in
            this case shows us that we can do a lot better. There is no reason in principle why the
            XQuery code should not run just as fast as the Java code. We're not quite there yet, but
            we have improved it to around 12ms. One technique that proved useful in achieving this
            was to write a Java program that executed the same logic as the XQuery-generated
            bytecode, and to measure the effect of making a variety of improvements to it: this
            exercise showed where it would be worthwhile to invest effort. The two areas that
            account for the improvement are: <orderedlist numeration="loweralpha"><listitem><para>Removal of unnecessary boxing and unboxing operations. Saxon generally
                        wraps simple values such as integers, strings, and booleans in a wrapper
                        (IntegerValue, StringValue, and BooleanValue, all subclasses of AtomicValue)
                        so they can all be manipulated using polymorphic methods. This means that
                        multiplying two doubles to produce another double involves not only the
                        multiplication, but two unboxing steps and one boxing step. Eliminating
                        these operations accounted for around half the improvement.</para></listitem><listitem><para>Removal of unnecessary mapping iterators. The way this query is executed
                        in the interpreter is to create an iterator over the integers 1 to 100000;
                        the results of this iterator are piped into a mapping iterator which applies
                        a mapping function to each value, this being the expression <emphasis role="ital">xs:double($i)*xs:double($i);</emphasis> and the resulting
                        doubles are then piped to the sum() function, which reads through the
                        iterator and totals the values. Inverting this structure to a loop where a
                        running total is incremented in the body of the loop, as in the hand-written
                        Java solution, accounts for the other half of the improvement.</para></listitem></orderedlist></para><para>The lessons from this exercise are firstly, that there are some execution paths where
            it is very hard to improve performance because it is already very close to optimal; but
            that there are other operations that still leave much room for improvement, and one good
            way to identify this is to compare the system-generated code with hand-written Java code
            that performs the same task.</para></section><section><title>Conclusion</title><para>The purpose of this paper was to study the performance benefits that can be achieved
            by adding a code-generation phase to an XSLT or XQuery processor. To do so, we examined
            these side-by-side with the benefits achieved by high level optimization rewrites. The
            two techniques are orthogonal to each other, in that one can do either or both, but it
            is interesting to analyze which delivers better improvements in relation to the
            cost.</para><para>In the best case (or the worst case, depending on how you look at it), optimization
            rewrites can turn a query with quadratic performance into one with linear performance.
            This is something code generation can never aspire to. This therefore vindicates the
            approach that has been taken in Saxon of putting aside work on code generation until the
            high-level optimizer had achieved a sufficient level of maturity.</para><para>The conclusion of our study is that compiled code can be expected to run about 25%
            faster than code executed under an optimal interpreter, but the improvements can be
            greater (up to 50% in our case) when the interpreter is less than optimal or when the
            individual expressions on the expression tree are performing tasks such as arithmetic
            operations or numeric comparisons whose execution time is small in comparison to the
            overhead of the control logic for invoking them.</para><para>For Saxon, the extra 25% is well worth achieving, since there are many users with
            demanding workloads, and since the business model for the product relies on the
            development being funded by revenue from the small number of users with the most
            demanding requirements. For other products, the trade-off might be different: in
            particular the message from this study is that code-generation is something you should
            do only when all other opportunities for performance improvement have been
            exhausted.</para></section><appendix xml:id="appendix1"><title>Bytecode of generated Java source code</title><para>Using Saxon 9.3.0.4 generated Java code for the simple query <code>exists(.)</code> we
            show its byte code using the tool <emphasis>javap</emphasis> with option
                <emphasis>-c</emphasis>:
            <programlisting xml:space="preserve"> public void process(net.sf.saxon.expr.XPathContext)   throws net.sf.saxon.trans.XPathException;
  Code:
   0:	aload_1
   1:	invokeinterface	#2,  1; //InterfaceMethod net/sf/saxon/expr/XPathContext.getReceiver:()Lnet/sf/saxon/event/SequenceReceiver;
   6:	astore_2
   7:	aload_1
   8:	invokeinterface	#3,  1; //InterfaceMethod net/sf/saxon/expr/XPathContext.getContextItem:()Lnet/sf/saxon/om/Item;
   13:	ifnonnull	25
   16:	aload_0
   17:	ldc	#4; //String The context item is undefined
   19:	ldc	#5; //String XPDY0002
   21:	aload_1
   22:	invokevirtual	#6; //Method dynamicError:(Ljava/lang/String;Ljava/lang/String;Lnet/sf/saxon/expr/XPathContext;)V
   25:	aload_1
   26:	invokeinterface	#3,  1; //InterfaceMethod net/sf/saxon/expr/XPathContext.getContextItem:()Lnet/sf/saxon/om/Item;
   31:	ifnull	38
   34:	iconst_1
   35:	goto	39
   38:	iconst_0
   39:	istore_3
   40:	aload_2
   41:	iload_3
   42:	invokestatic	#7; //Method net/sf/saxon/value/BooleanValue.get:(Z)Lnet/sf/saxon/value/BooleanValue;
   45:	iconst_0
   46:	iconst_2
   47:	invokevirtual	#8; //Method net/sf/saxon/event/SequenceReceiver.append:(Lnet/sf/saxon/om/Item;II)V
   50:	return</programlisting>
        </para></appendix><appendix xml:id="appendix3"><title>Running times of the 20 XMark XQuery queries</title><para>The following three tables show running times of the 20 XMark XQuery queries. Each
            query is executed 1000 or until 30 seconds have elapsed, whichever comes first. The
            average is time reported in micro-seconds. We show results for Saxon-HE (no
            optimization), Saxon-Bytecode (no optimization, with bytecode generation), Saxon-EE
            (with optimization), Saxon-EE-JavaCode (with optimization and java source code
            generation) and Saxon-EE-Bytecode (with optimization and bytecode generation). We also
            show the Saxon-EE-Bytecode speedup as percentages with respect to Saxon-EE times. The
            fastest Saxon configuration for each result is set in bold font.<table border="1" cellpadding="10" xml:id="Table1"><caption><para>Running Times, with 1MB data file</para></caption><thead><tr valign="top"><th>Query</th><th>Saxon-HE</th><th>Saxon-Bytecode</th><th>Saxon-EE</th><th>Saxon-EE-Bytecode</th><th>Bytecode speedup (%)</th></tr></thead><tbody><tr><td>q1</td><td>0.363</td><td>0.394</td><td>0.095</td><td><emphasis role="bold">0.080</emphasis></td><td>NEG</td></tr><tr><td>q2</td><td>0.456</td><td>0.452</td><td>0.473</td><td><emphasis role="bold">0.432</emphasis></td><td>9%</td></tr><tr><td>q3</td><td>0.547</td><td>0.450</td><td>0.606</td><td><emphasis role="bold">0.416</emphasis></td><td>31%</td></tr><tr><td>q4</td><td>0.308</td><td><emphasis role="bold">0.296</emphasis></td><td>0.443</td><td>0.380</td><td>14%</td></tr><tr><td>q5</td><td>0.183</td><td><emphasis role="bold">0.127</emphasis></td><td>0.176</td><td>0.144</td><td>18%</td></tr><tr><td>q6</td><td>0.181</td><td>0.208</td><td>0.177</td><td><emphasis role="bold">0.166</emphasis></td><td>6%</td></tr><tr><td>q7</td><td>0.773</td><td>0.717</td><td>0.773</td><td><emphasis role="bold">0.626</emphasis></td><td>19%</td></tr><tr><td>q8</td><td>15.468</td><td>12.630</td><td>0.491</td><td><emphasis role="bold">0.458</emphasis></td><td>7%</td></tr><tr><td>q9</td><td>19.401</td><td>15.833</td><td>1.313</td><td><emphasis role="bold">1.058</emphasis></td><td>19%</td></tr><tr><td>q10</td><td>4.639</td><td>4.128</td><td>4.180</td><td><emphasis role="bold">2.329</emphasis></td><td>44%</td></tr><tr><td>q11</td><td>7.688</td><td>5.984</td><td>7.533</td><td><emphasis role="bold">4.957</emphasis></td><td>34%</td></tr><tr><td>q12</td><td>2.926</td><td>2.226</td><td>2.918</td><td><emphasis role="bold">1.812</emphasis></td><td>38%</td></tr><tr><td>q13</td><td>0.138</td><td><emphasis role="bold">0.137</emphasis></td><td>0.146</td><td>0.152</td><td>-4%</td></tr><tr><td>q14</td><td>1.740</td><td>1.710</td><td>1.698</td><td><emphasis role="bold">1.654</emphasis></td><td>3%</td></tr><tr><td>q15</td><td><emphasis role="bold">0.108</emphasis></td><td>0.149</td><td>0.123</td><td>0.170</td><td>-39%</td></tr><tr><td>q16</td><td>0.162</td><td><emphasis role="bold">0.161</emphasis></td><td>0.262</td><td>0.274</td><td>-5%</td></tr><tr><td>q17</td><td>0.175</td><td>0.140</td><td>0.176</td><td><emphasis role="bold">0.160</emphasis></td><td>9%</td></tr><tr><td>q18</td><td>0.343</td><td>0.303</td><td>0.231</td><td><emphasis role="bold">0.219</emphasis></td><td>5%</td></tr><tr><td>q19</td><td>1.774</td><td>1.549</td><td>1.633</td><td><emphasis role="bold">1.483</emphasis></td><td>9%</td></tr><tr><td>q20</td><td><emphasis role="bold">0.371</emphasis></td><td>0.403</td><td>0.454</td><td>0.452</td><td>NEG</td></tr></tbody></table>
            <table border="border" cellpadding="10" xml:id="Table2"><caption><para>Running Times, with 4MB data file</para></caption><thead><tr><th>Query</th><th>Saxon-HE</th><th>Saxon-Bytecode</th><th>Saxon-EE</th><th>Saxon-EE-Bytecode</th><th>Bytecode speedup (%)</th></tr></thead><tbody><tr><td>q1</td><td>0.210</td><td>0.209</td><td><emphasis role="bold">0.011</emphasis></td><td>0.012</td><td>-7%</td></tr><tr><td>q2</td><td>0.408</td><td><emphasis role="bold">0.329</emphasis></td><td>0.416</td><td>0.417</td><td>NEG</td></tr><tr><td>q3</td><td>1.143</td><td><emphasis role="bold">0.845</emphasis></td><td>1.238</td><td>0.962</td><td>22%</td></tr><tr><td>q4</td><td>1.005</td><td>0.926</td><td>1.257</td><td><emphasis role="bold">0.922</emphasis></td><td>27%</td></tr><tr><td>q5</td><td>0.418</td><td><emphasis role="bold">0.268</emphasis></td><td>0.428</td><td>0.305</td><td>29%</td></tr><tr><td>q6</td><td>0.371</td><td>0.362</td><td>0.369</td><td><emphasis role="bold">0.306</emphasis></td><td>17%</td></tr><tr><td>q7</td><td>2.930</td><td>2.908</td><td>2.941</td><td><emphasis role="bold">2.354</emphasis></td><td>20%</td></tr><tr><td>q8</td><td>293.398</td><td>207.416</td><td>1.605</td><td><emphasis role="bold">1.107</emphasis></td><td>31%</td></tr><tr><td>q9</td><td>333.601</td><td>257.565</td><td>2.992</td><td><emphasis role="bold">2.750</emphasis></td><td>8%</td></tr><tr><td>q10</td><td>52.349</td><td>41.815</td><td>19.142</td><td><emphasis role="bold">9.514</emphasis></td><td>50%</td></tr><tr><td>q11</td><td>119.141</td><td>90.013</td><td>118.535</td><td><emphasis role="bold">71.100</emphasis></td><td>39%</td></tr><tr><td>q12</td><td>37.280</td><td>26.328</td><td>37.029</td><td><emphasis role="bold">20.050</emphasis></td><td>46%</td></tr><tr><td>q13</td><td>0.254</td><td><emphasis role="bold">0.216</emphasis></td><td>0.262</td><td>0.261</td><td>NEG</td></tr><tr><td>q14</td><td>6.531</td><td>6.181</td><td>6.489</td><td><emphasis role="bold">6.011</emphasis></td><td>7%</td></tr><tr><td>q15</td><td>0.325</td><td><emphasis role="bold">0.294</emphasis></td><td>0.382</td><td>0.434</td><td>-14%</td></tr><tr><td>q16</td><td>0.536</td><td><emphasis role="bold">0.453</emphasis></td><td>0.597</td><td>0.627</td><td>-5%</td></tr><tr><td>q17</td><td>0.632</td><td><emphasis role="bold">0.501</emphasis></td><td>0.700</td><td>0.537</td><td>23%</td></tr><tr><td>q18</td><td>0.692</td><td>0.601</td><td>0.577</td><td><emphasis role="bold">0.517</emphasis></td><td>10%</td></tr><tr><td>q19</td><td>4.613</td><td>4.164</td><td>4.517</td><td><emphasis role="bold">3.638</emphasis></td><td>19%</td></tr><tr><td>q20</td><td>1.428</td><td><emphasis role="bold">1.397</emphasis></td><td>1.689</td><td>1.449</td><td>14%</td></tr></tbody></table>
            <table border="border" cellpadding="10" xml:id="Table3"><caption><para>Running Times, with 10MB data file</para></caption><thead><tr><th>Query</th><th>Saxon-HE</th><th>Saxon-Bytecode</th><th>Saxon-EE</th><th>Saxon-EE-Bytecode</th><th>Bytecode speedup (%)</th></tr></thead><tbody><tr><td>q1</td><td>0.597</td><td>0.519</td><td><emphasis role="bold">0.010</emphasis></td><td>0.015</td><td>NEG</td></tr><tr><td>q2</td><td>1.067</td><td><emphasis role="bold">0.820</emphasis></td><td>1.130</td><td>0.880</td><td>22%</td></tr><tr><td>q3</td><td>3.415</td><td><emphasis role="bold">2.505</emphasis></td><td>3.63</td><td>2.54</td><td>30%</td></tr><tr><td>q4</td><td>2.8824</td><td>2.5606</td><td>3.66</td><td><emphasis role="bold">2.43</emphasis></td><td>34%</td></tr><tr><td>q5</td><td>1.0686</td><td><emphasis role="bold">0.6742</emphasis></td><td>1.08</td><td>0.76</td><td>30%</td></tr><tr><td>q6</td><td>0.9080</td><td>0.8893</td><td>0.90</td><td><emphasis role="bold">0.76</emphasis></td><td>16%</td></tr><tr><td>q7</td><td>7.487</td><td>7.403</td><td>7.55</td><td><emphasis role="bold">6.03</emphasis></td><td>20%</td></tr><tr><td>q8</td><td>1725.13</td><td>1295.78</td><td>5.00</td><td><emphasis role="bold">3.26</emphasis></td><td>35%</td></tr><tr><td>q9</td><td>2081.03</td><td>1534.66</td><td>10.1</td><td><emphasis role="bold">8.168</emphasis></td><td>19%</td></tr><tr><td>q10</td><td>325.35</td><td>276.57</td><td>49.74</td><td><emphasis role="bold">25.16</emphasis></td><td>49%</td></tr><tr><td>q11</td><td>701.79</td><td>539.59</td><td>708.45</td><td><emphasis role="bold">421.38</emphasis></td><td>41%</td></tr><tr><td>q12</td><td>228.34</td><td>162.37</td><td>228.38</td><td><emphasis role="bold">124.48</emphasis></td><td>45%</td></tr><tr><td>q13</td><td>0.66</td><td><emphasis role="bold">0.58</emphasis></td><td>0.70</td><td>0.59</td><td>16%</td></tr><tr><td>q14</td><td>15.57</td><td>15.23</td><td>16.03</td><td><emphasis role="bold">14.73</emphasis></td><td>8%</td></tr><tr><td>q15</td><td>0.77</td><td><emphasis role="bold">0.72</emphasis></td><td>0.94</td><td>1.05</td><td>-12%</td></tr><tr><td>q16</td><td>1.28</td><td><emphasis role="bold">1.11</emphasis></td><td>1.50</td><td>1.39</td><td>7%</td></tr><tr><td>q17</td><td>1.59</td><td><emphasis role="bold">1.26</emphasis></td><td>1.77</td><td>1.27</td><td>28%</td></tr><tr><td>q18</td><td>1.86</td><td>1.62</td><td>1.57</td><td><emphasis role="bold">1.29</emphasis></td><td>18%</td></tr><tr><td>q19</td><td>12.85</td><td>12.12</td><td>12.64</td><td><emphasis role="bold">10.90</emphasis></td><td>14%</td></tr><tr><td>q20</td><td>5.32</td><td><emphasis role="bold">3.64</emphasis></td><td>5.92</td><td>3.74</td><td>37%</td></tr></tbody></table>
        </para></appendix><bibliography><title>References</title><bibliomixed xml:id="Bruneton2002" xreflabel="Bruneton2002">E. Bruneton et al. ASM: A code
            manipulation tool to implement adaptable systems. In Proceedings <emphasis>Adaptable and
                extensible component systems</emphasis>, November 2002, Grenoble, France. <link xlink:href="http://asm.ow2.org/current/asm-eng.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://asm.ow2.org/current/asm-eng.pdf</link>
        </bibliomixed><bibliomixed xml:id="Dahm1999" xreflabel="Dahm1999">Dahmm, Markus. Byte Code Engineering.
            1999. doi: <biblioid class="doi">10.1.1.103.8299</biblioid>
        </bibliomixed><bibliomixed xml:id="DataPower" xreflabel="DataPower">WebSphere DataPower SOA Appliances.
            <link xlink:href="http://www-01.ibm.com/software/integration/datapower/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www-01.ibm.com/software/integration/datapower/</link>
        </bibliomixed><bibliomixed xml:id="Kay1999" xreflabel="Kay1999">Kay, Michael. SAXON 4.2 - An XSL Compiler.
            23 April 1999. <link xlink:href="http://xml.coverpages.org/saxon42Ann.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://xml.coverpages.org/saxon42Ann.html</link>
        </bibliomixed><bibliomixed xml:id="Kay2005" xreflabel="Kay2005">Kay, Michael. Saxon: Anatomy of an XSLT
            processor. April 2005. <link xlink:href="http://www.ibm.com/developerworks/library/x-xslt2/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.ibm.com/developerworks/library/x-xslt2/</link>
        </bibliomixed><bibliomixed xml:id="Kay2006a" xreflabel="Kay2006a">Kay, Michael. Experiments with
            Compilation, 24 July 2006. <link xlink:href="http://saxonica.blogharbor.com/blog/archives/2006/7/24/2157486.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://saxonica.blogharbor.com/blog/archives/2006/7/24/2157486.html</link>
        </bibliomixed><bibliomixed xml:id="Kay2006b" xreflabel="Kay2006b">Kay, Michael. Optimization in XSLT and
            XQuery. In Proceeding <emphasis>XMLPrague 2006&gt;</emphasis>, June 2006, Prague, Czech
            Republic. <link xlink:href="http://www.xmlprague.cz/2006/images/xmlprague2006.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2006/images/xmlprague2006.pdf</link>
        </bibliomixed><bibliomixed xml:id="Kay2006c" xreflabel="Kay2006c">Kay, Michael. First compiled XMark
            results. 6 November 2006. <link xlink:href="http://saxonica.blogharbor.com/blog/_archives/2006/11/6/2477675.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://saxonica.blogharbor.com/blog/_archives/2006/11/6/2477675.html</link>
        </bibliomixed><bibliomixed xml:id="Kay2007" xreflabel="Kay2007">Kay, Michael. Writing an XSLT Optimizer in
            XSLT. In Proceeding <emphasis>Extreme Markup Languages 2007</emphasis>, 2007, Montreal,
            Canada. <link xlink:href="http://conferences.idealliance.org/extreme/html/2007/Kay01/EML2007Kay01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://conferences.idealliance.org/extreme/html/2007/Kay01/EML2007Kay01.html</link>
        </bibliomixed><bibliomixed xml:id="Kay2008" xreflabel="Kay2008">Kay, Michael. Ten Reasons Why Saxon XQuery
            is Fast. In the <emphasis>IEEE Data Engineering Bulletin</emphasis>, December 2008.
            <link xlink:href="http://sites.computer.org/debull/A08dec/saxonica.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://sites.computer.org/debull/A08dec/saxonica.pdf</link>
        </bibliomixed><bibliomixed xml:id="Kay2009" xreflabel="Kay2009">Kay, Michael. You Pull, Iâll Push: on the
            Polarity of Pipelines <emphasis>Balisage: The Markup Conference 2009</emphasis>, Aug
            11-14, 2009, MontrÃ©al, Canada. doi:<biblioid class="doi">10.4242/BalisageVol3.Kay01</biblioid>. <link xlink:href="http://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html</link>
        </bibliomixed><bibliomixed xml:id="Kay2010" xreflabel="Kay2010">Kay, Michael. A Streaming XSLT Processor.
            In Proceeding Balisage: The Markup Conference 2010, August 3-6, 2010. Montreal, Canada.
            doi: <biblioid class="doi">10.4242/BalisageVol5.Kay01</biblioid>. <link xlink:href="http://www.balisage.net/Proceedings/vol5/html/Kay01/BalisageVol5-Kay01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.balisage.net/Proceedings/vol5/html/Kay01/BalisageVol5-Kay01.html</link>
        </bibliomixed><bibliomixed xml:id="Snelson2011" xreflabel="Snelson2011">Snelson, John. Declarative XQuery
            Rewrites for Profit or Pleasure. An optimization meta language for implementers and
            users alike. In Proceeding <emphasis>XMLPrague 2011</emphasis>, March 2011, Prague,
            Czech Republic. <link xlink:href="http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</link>
        </bibliomixed><bibliomixed xml:id="XMark" xreflabel="XMark">XMark - XML Benchmark Project. <link xlink:href="http://www.xml-benchmark.org/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xml-benchmark.org/</link>
        </bibliomixed><bibliomixed xml:id="XSLTC" xreflabel="XSLTC">XSLTC, a part of Xalan-J. <emphasis>The Apache
            XML Project</emphasis>. <link xlink:href="http://xml.apache.org/xalan-j/xsltc/index.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://xml.apache.org/xalan-j/xsltc/index.html</link>
        </bibliomixed></bibliography></article>