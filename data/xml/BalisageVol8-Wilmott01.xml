<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>Literate Programming: A Case Study and Observations</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>A newly revived interest in literate programming means that we need to look at what's been done in the past.  Literate Programming requires both the integration of computer programming code with its documentation, and the elimination of duplicate information between the code and the documentation.  It's the latter that has been overlooked in the past.  This paper describes a project that integrated programming code with its documentation, using a markup language, and discusses lessons that might be learned from it.  It also illustrates the use of, and discusses the advantages of using compact markup (as exemplified by SGML short references and Wiki markup) especially as it applies to using a markup language for literate programming.</para></abstract><author><personname><firstname>Sam</firstname><surname>Wilmott</surname></personname><personblurb><para>Sam Wilmott started using markup languages in the late '60s. Since then he has led the development of typesetting/text-formatting systems for the Canadian Government Printing Office and for a major real-estate company, implemented one of the first SGML parsers (which was also the first pull-model markup parser), and is the originator of the <xref linkend="omnimark"/> programming language, with its strong support of SGML, XML, and text transformation.</para><para>More recently Sam has been working the XSLT world: he has recently contributed to the implementation of an XSLT compiler and currently works as an XSLT programmer and analyst.  As a side project, he is working on new programming language ideas for markup language processing.</para></personblurb><email>sam@wilmott.ca</email></author><legalnotice><para>Copyright Â© 2012 Sam Wilmott and Stilo International plc.</para></legalnotice><keywordset role="author"><keyword>Literate Programming</keyword><keyword>Markup Language Implementation</keyword><keyword>SGML</keyword><keyword>Short References</keyword><keyword>Wiki Markup</keyword><keyword>XML</keyword></keywordset></info><section><title>Why Literate Programming?</title><para>First of all, I'd like to thank Stilo International<footnote><para>Stilo International <link xlink:href="http://stilo.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://stilo.com</link></para></footnote> for giving me access to some of their internal documents.  This paper wouldn't exist without their contribution.</para><para><xref linkend="lp"/>, the integration of program code with its documentation, has been a feature of both the programming and the documentation fields for over thirty years.  It got off to a good start with <xref linkend="knuth"/> but there hasn't been a lot of new work in the field over most of the intervening decades.  However, now there seems to be a renewed interest in Literate Programming.  Why? you might ask.</para><para>Integrating programming code and its documentation isn't just about having them in the same document, as was done in Knuth's WEB: it's about eliminating duplication of information coded in both programming and documentation forms. In contrast, and most commonly, programmers are continuing with the traditional model of completely separating code and its documentation.  The difficulty with this approach is that it duplicates a lot of information: information coded in a programming language and also written up in its documentation, as text or in tables.  The result is costly in three ways:<itemizedlist><listitem><para>Doing so increases the amount of work required by the programmers and the documenters (who may be the same or different folk) to initially create and to later update the code and the documentation.</para></listitem><listitem><para>Organizing multiple copies of information can itself increase the cost of developing, maintaining and managing programming code: there's more to do that way.</para></listitem><listitem><para>Most importantly, duplication increases the chances of error: rewriting a text description into code can result in an error, as can describing code using text.  Updating one can easily cause it to be out of step with the other, even when they were previously in step.</para></listitem></itemizedlist></para><para>There's been a number of approaches taken to deal with these difficulties:<itemizedlist><listitem><para>All production programming languages support integrating comments with code.  Comments are most commonly used to help the reader understand the details of why coding is done in a particular way.  Comments are also used to document how a program is to be used, but they don't make for good reading for the users, and force the user to read the code.</para></listitem><listitem><para>Many ways have been looked at for adding markup to program languages' comments, both <xref linkend="xml"/> and non-XML (often wiki-like) markup.  This certainly improves things.  It means that the user documentation can be extracted from the programming code and repurposed for the user: a big help.</para><para>Marked-up comments still have a problem, however: a lot of information needs to be duplicated, so that there's a "human" version of the information and a "computer" version of it too.  For example, the information in function/method headers needs to be available to and understood by both the user and the computer.</para></listitem><listitem><para>Taking things one more step further, there have been a few approaches to adding markup to a programming language's code itself, so that it can be used within the documentation without duplication.  This is where the future lies, what I'll be talking about here, and is something still in development.</para></listitem></itemizedlist></para><para>There are a number of good papers at this conference already covering different aspects of this problem:<itemizedlist><listitem><para>"Code Up: Marking up Programming Languages and the winding road to an XML Syntax"<footnote><para>David Lee, MarkLogic, "Code Up: Marking up Programming Languages and the winding road to an XML Syntax", to be presented at Balisage 2012, Wednesday 2:00pm.<!-- #021 --></para></footnote> describes and analyzes various approaches, from simple commenting to a program that's all XML.</para></listitem><listitem><para>"On XML Languages"<footnote><para>Norman Walsh, MarkLogic, "On XML Languages", to be presented at Balisage 2012, Wednesday 2:45pm.<!-- #099 --></para></footnote> describes both XML and "compact" (non-XML) syntaxes for existing W3C scripting languages, discussing the advantages and disadvantages of each approach.</para></listitem><listitem><para>"Encoding Transparency: Literate Programming and Test Generation for Scientific Function Libraries"<footnote><para>Mark Flood, Matthew McCormick and Nathan Palmer, Office of Financial Research, Department of the Treasury, "Encoding Transparency: Literate Programming and Test Generation for Scientific Function Libraries", to be presented at Balisage 2012, Wednesday 4:00pm.<!-- #191 --></para></footnote> describes an XML-based approach to duplicating what was achieved with Donald Knuth's Literate Programming tools (his WEB targeting <xref linkend="tex"/>).</para></listitem></itemizedlist></para><para>This paper adds to the discussion in two ways:<itemizedlist><listitem><para>It presents an existing system, integrating programming code and its documentation in a practical way.</para></listitem><listitem><para>It discusses further issues that have to be dealt with when designing languages and building tools for such a system.</para></listitem></itemizedlist></para></section><section><title>A Blast From The Past: A Case Study</title><para>Back in the days when <xref linkend="sgml"/> was still new (when XML hadn't shown up yet), and when the <xref linkend="c"/> was still a practical language of choice for cross-platform tool development (when C was about the only language that ran uniformly on all major platforms, and when there were a much larger variety of machine architectures than there are in our now Intel-dominated world), I implemented one of the still-existing SGML parsers.  Almost uniquely, I think, the SGML parser is itself an SGML document.  (It helped a lot that it was the second SGML parser developed by the company, so that the first one could be used to initially process the second one.  Once the second SGML parser was well developed, it took over and was used to help processed itself.)</para><para>The following examples are taken from the code of the SGML parser used in Stilo International's <xref linkend="omnimark"/> programming language.  This code has been in use for over twenty years, so it serves as a good example of "real world" markup-based literate programming.  The markup language used to markup the SGML parser's code is quite complex, but you'll get most of it's ideas from the following examples.</para><para>In practice, the following program-oriented markup elements are included in otherwise common paragraph-level markup.</para><para>Here's the header of the module processing SGML declarations (other than ENITY declarations)<footnote xml:id="stilo"><para>Please note that the copyright information isn't just an example.  This code is copyright and extracted from the original code of the product (with some abbreviations to make it easier to present).  Stilo International has kindly allowed me to use snippets of it as examples in a public forum.</para></footnote>:<programlisting xml:space="preserve">
&lt;!-- xkdecl.doc: 

   Copyright (C) Stilo International plc, 1991 - 2011
   All Rights Reserved

   PROPRIETARY AND CONFIDENTIAL

  --&gt;
&lt;chapter&gt;Declarations
&lt;revinfo&gt;$Id: xkdecl.doc,v 1.83 2001/10/19 15:11:08 kernel Exp $
&lt;system&gt;kernel:XK
&lt;module defined&gt;decl &lt;!-- Declarations;--&gt;;
basic; mem; syn; lex; var; ent; mod; con; attr; edec; err; fsm1
&lt;cinclude&gt;xktypes.h
</programlisting></para><para>It contains:<itemizedlist><listitem><para>Importantly, copyright and distribution information.<xref linkend="stilo"/></para></listitem><listitem><para>A chapter heading, both as a lead comment in the code and as a chapter start and title in the user's and programmer's documentation.</para></listitem><listitem><para>Revision information for the revision control system used at the time.  (For a stable piece of software such as this, it doesn't get updated often, as you can see.)</para></listitem><listitem><para>Information about the system name, the used module name, what other modules are used, and what C include files are needed.</para></listitem></itemizedlist></para><para>Data structures are documented rather than coded:<programlisting xml:space="preserve">
&lt;struct external&gt;document type definition
# The data structure which describes a document type definition (a "compiled"
  DTD) and which points to all the data structures for the objects declared
  for the document type definition. #
&lt;comment&gt;
The following fields provide information about specific features of
a document type.
&lt;/comment&gt;
=  document element: 'element definition'*
   # Pointer to the definition for the document element. #
=  default general entity: 'entity definition'*
   # Pointer to the default general entity. #
...
&lt;/struct&gt;
</programlisting></para><para>Documentation of a structure as a whole as well as of each field is required.  The markup used for the fields of a structure is exactly the same as for an ordered list of labeled textual items: no distinction is made between the markup for documentation and for code.</para><para>Structures, functions and other constructs have attributes specified with them that are meaningful either to the target code, the programmer's documentation, the user's documentation or two or more of these things.</para><para>Global names are marked up (surrounded by apostrophes in code and by "at" signs in text), and are chosen to be appropriate for documentation.  The processing software replaces these names with the kinds of names required by the target language, together with appropriate prefixing.  This approach makes the code more portable between systems.</para><para>Functions/methods have their interface information marked up as documentation:<programlisting xml:space="preserve">
&lt;function external&gt;initialize document type: 'boolean'
# Prepare for parsing a document instance. #
&lt;inout setself&gt;parsing_state: 'parsing state'*
&lt;in&gt;base_element: 'element definition'*
&lt;comment&gt;
This procedure prepares ~parsing_state~ to parse a document instance using the
current document type definition in ~parsing_state~.  Three options are
available for selecting what is to be parsed, depending on the value of
~base_element~, as follows:
&lt;ol&gt;
=  If ~base_element~ is the base document element of the document type (i.e.
the one named following the keyword DOCTYPE in the DTD), then the following
input text is parsed with that element as the document element (see
ISO 8879-1986, definition 4.99).
=  If ~base_element~ is any other element in the DTD, then that other element
is treated as if it were the document element for the purposes of parsing the
following input text.  This allows parts of documents to be parsed, such as a
single chapter.
=  If ~base_element~ is "null" (@element definition.null@), then the following
text may consist of any sequence of elements defined in the DTD.
&lt;/ol&gt;
   In the first two cases, @initialize document type@ sets the number of opened
elements to zero (0).
...
&lt;code&gt;
   &lt;return/'initialize parsing state generally'
                (parsing_state,
                 ('document type definition'*) 'document type definition.null',
                 base_element,
                 ('document syntax'*) 'document syntax.null',
                 ('document syntax'*) 'document syntax.null',
                 ('parsing state setup result'*) 0)/
&lt;/function&gt;
</programlisting></para><para>Function arguments are documented both by text and by the markup of the argument.  Code in the body of a function is the one place where program code is used in preference to markup, for a number of reasons:<itemizedlist><listitem><para>Dense code is generally easier to read in a more compact form.</para></listitem><listitem><para>The code is only used in two (potential) targets: the produced C code that was intended to be compiled, and in the annotated code documentation.</para></listitem></itemizedlist></para><para>That said, there are exceptions to using a non-SGML form for code:<itemizedlist><listitem><para>Constructs that impact a function's interface, such as "return" (but not things like "if") are marked up.<footnote><para>I forget exactly why returns were marked up.  Oh well.</para></footnote></para></listitem><listitem><para>The big issue in choosing verbose markup or compact markup is in the trade-off of readability and utility.  This trade-off can be subjective -- different people with come to different conclusions, depending largely on what markup and other notations they are familiar with.</para></listitem><listitem><para>References to names in the software's interface, either of interest to the user or of global interest to the software's developers, are marked up, so that they can be easily found if needed.  One use of marked up marked-up names is an index of all uses of every name can be listed.</para></listitem></itemizedlist></para><para>Using markup also means that things that are better coded as tables than as code, but which need to be run as code, can be included.  This was done in the SGML parser, by coding the syntactic parsing logic as a finite state machine (FSM).  For example, here's the logic for parsing an SGML end tag (in a somewhat abbreviated form):<programlisting xml:space="preserve">
   From Clause 7.5, End-tag:

&lt;fsm&gt;end-tag (TAG):
&amp;more;
=  name {end-tag}: +generic identifier specification
=  tagc {back over lexeme; check end-tag shorttag}: +checked shorttag
=  * {impossible}
#  checked shorttag
   {empty end-tag}: +generic identifier specification
#  generic identifier specification (TAG):
&amp;s;
=  tagc {end of end-tag: other prolog; end of tag}: content
=  stago no rhs, etago no rhs
   {back over lexeme; report missing end tag tagc missing;
    end of end-tag: other prolog; end of tag}: content
=  * {backup needed; 'unrecognized item'}: +unrecognized
#  unrecognized
   {end of end-tag: other prolog; end of tag}: content
&lt;/fsm&gt;
</programlisting></para><para>Each entry has four parts: the thing or things being recognized, the lexical context in effect (i.e. what tokens are recognized, identified by a keyword such as "TAG"), the action to be taken when recognizing that thing (in curly braces), and what state in the state machine to go to next.  In particular:<itemizedlist><listitem><para>"#" introduces a sub-state and "+" prefixes a local reference to the next state.  Next states with no "+" prefix are major states, like "end-tag".</para></listitem><listitem><para>Substates need not recognize anything, but just do something, like "checked shorttag".</para></listitem><listitem><para>Groups of common actions are coded as entity references ("&amp;more;" and "&amp;s;").</para></listitem></itemizedlist></para><para>Note that the above example is very heavily marked up: all of ( ) { } + = # ' and ; are compact markup (a.k.a. SHORTREFs).</para><para>Actions in the FSM are marked up specially:<programlisting xml:space="preserve">
&lt;action value&gt;end tag
# Process an end tag containing an element name and signal the
change of context to the application. #
&lt;comment&gt;
The current lexical item is the name of the element.
@parsing state.selected element@ is to be made the definition of the element.
to the previous state after closing one element, or go to the alternate
state after having reported an error.
&lt;/comment&gt;
&lt;local&gt;element: 'element definition'*
&lt;local&gt;opened_element: 'opened element'*
&lt;code&gt;
   if (parsing_state-&gt;'parsing state.opened element count' &gt; 0)
      opened_element = parsing_state-&gt;'parsing state.opened element stack';
   else
      opened_element = 'opened element.null';
   if (!'look up element' (parsing_state,
                          parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item start',
                          ('integer')
                          (parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item end' -
                           parsing_state-&gt;'parsing state.opened entity stack'-&gt;
                                          'opened entity.item start'),
                          addr(element)))
   {
      parsing_state-&gt;'parsing state.selected element' =
                     'element definition.null';
      'report error' (parsing_state,
                      'exception code.undefined element in end tag');
      &lt;return//
   }
   parsing_state-&gt;'parsing state.selected element' = element;
   'create opened element' (parsing_state);
   'initiate closing current element' (parsing_state, opened_element);
&lt;/action&gt;
</programlisting></para><para>Actions can be compiled as functions, with calls to them included in the FSM code, or they can be marked as a "macro", and included in-line.  The "value" attribute indicates that the action (potentially) returns a value to the invoking application.  This illustrates the use of markup not just for documentation purposes, but to make the coding simpler.</para><para>The FSM markup language made it easy to create program code, and was easy to work with.  It greatly shortened the time of creating a high-performance SGML parser.</para><para>Using SGML to help create an SGML parser had nothing, of course, to do with the fact that it was an SGML parser that was being developed using this technique.  However it did help to speed up development of the product in an otherwise inappropriate programming language: C.  One could also argue that it took someone with expertise in implementing and using SGML to perform both tasks.</para><para>It's unclear whether this use of literate programming was a success or not:<itemizedlist><listitem><para>It's use helped greatly in the project in which it was used.</para></listitem><listitem><para>It wasn't reused in later projects.</para></listitem></itemizedlist></para><para>So an argument could be made both for success and for failure.</para></section><section><title>An Aside On Short References</title><para>The work described in this paper makes extensive use of short references and illustrates how they can be useful.</para><para>Another paper being presented at this conference, <footnote xml:id="shortrefs"><para>Mario Blazevic, Stilo International, "Extending XML with SHORTREFs specified in RELAX NG", to be presented at Balisage 2012, Wednesday 4:45pm.<!-- #027 --></para></footnote> describes a simplified mechanism for introducing the advantages of <xref linkend="wiki"/> and SGML short references into XML.  As that paper correctly points out, it's not easy to get SGML short references right.  The difficulty is not so much compact markup its self -- it's in the mechanism for defining it, in the tool support for such markup, and in the quality of the documentation of such markup.  (If anything, it's in the later that the use of SGML short references failed most notably.)</para><para>XML was designed and made different from SGML on the assumption that markup support tools, such as XML editors and XML exporting support in word processors, had or would develop to the point where users were no longer entering XML markup "by hand", but would use semi-automated tools for doing so.  This is true for a large class of users.  But there is also a large number of users entering XML tags using non-XML-specific editors: one major category of such being in programming language environments, where those languages have syntaxes in addition to that of XML.  To be effective user-helpful tools need to support multiple syntaxes, not just that of the programming language or languages used, or just XML, but all of them.</para><para>One difficulty with using compact markup is that it's best used sparingly.  That is, only a small number of compact markup forms should be used in any particular context.  Successful Wiki Markup languages are a testament to this principle. Too many different compact forms results in confusion.  The classical paper on the subject is Miller's <xref linkend="mn7"/>, which says that the limit on the number of usable forms (per context) is about 7 (plus or minus 2).</para><para>At this stage in the development of markup languages, it doesn't seem to be a particularly controversial statement to say that the best use of fully-tagged and compact markup is in some combination of the two -- with the balance chosen based on the needs of a particular application.  One size does not fit all.  For an example, consider the mixture of fully-tagged XML and compact <xref linkend="xpath"/> that appear in most <xref linkend="xslt"/> programs.</para><para>There are a number of ways in which the advantages of compact markup can be realized in an XML context, including:<itemizedlist><listitem><para>A general facility could be added to XML structure descriptors (DTD, schema, RELAX-NG, etc), maybe some up-dated form of short references as suggested in another paper here<xref linkend="shortrefs"/> for markup language developers to develop their own compact markup.</para></listitem><listitem><para>A similar facility could be created as a separate process, complementary to existing XML structure descriptors, that could be used with any of them, that for example, adds further element structure to a preexisting parsed XML tree based on discovered compact markup.</para></listitem><listitem><para>Some special-purpose compact markup could be supported as a separate process.  This approach would be appropriate if there were a limited number of applications of compact markup -- only for literate programming applications, for example -- and no need for a general approach.</para></listitem></itemizedlist>
</para><para>The Literate Programming work described in this paper wouldn't have really been possible without the use of some form of compact markup to complement the primary markup (SGML or XML).  The level of detail would make full XML markup, for example, difficult to read, especially for programmers, whose primary interest is the programming code.</para></section><section><title>Another Aside, On The Kinds Of Documentation</title><para>The SGML/C project described above supported four kinds of documentation that could be targeted by marked-up code and documentation:<itemizedlist><listitem><para>User documentation: information for the end user of a software system.</para></listitem><listitem><para>Design documentation: information for helping maintain a software system, outlining the structure of the software and how it works</para></listitem><listitem><para>Fully annotated code: for use by those actually working with the code, detailing what, how and why is actually done.</para><para>These three categories of documentation are incremental: generally speaking, design documentation includes everything the user is told, and annotated code includes all the user and design information.</para></listitem><listitem><para>Comments: There is some documentation that falls outside of any of the above categories: comments detailing the how and why of specific code snippets (rather than the more general techniques that apply to whole methods or other segments of code).  These comments are inseparable from the code they annotate, and seem to be best entered as language-specific comments rather than as marked-up documentation.  Unlike the above categories of documentation, these kinds of comments need no special handling.</para></listitem></itemizedlist>and of course, there's the code itself: what the programming language's compiler needs to be given.  In practice there can be more than one kind of code:<itemizedlist><listitem><para>The "production" code, that appears in the final product.  There can be multiple products, or multiple versions of a product, originating in one set of code.</para></listitem><listitem><para>In addition, code can exist as part of the software development process, with lots of extra checks and reports.</para></listitem></itemizedlist>Markup can effectively distinguish between different versions and kinds of code.</para><para>So there's at least four kinds of things created from marked-up code: user, design and annotated code documentation, and the compiler's code.</para></section><section><title>A Literate Programming Markup Language As A New Language</title><para>Adding comments to program code doesn't change the programming language used in any way.  It remains the same programming language plus comments.  But once major programming language constructs, such as data structure declarations and function headings, are replaced by documentation-friendly markup, we find ourselves looking at different programming language.</para><para>At what point changing the syntax of a programming language makes it a different language depends largely on one's point of view.  From the point of view of the programming language designer, syntax is a minor issue: functionality is their focus.  From the point of view of the language user syntax is just about everything: it's important how to code an "if" statement, even though it's semantics is more-or-less the same in every programming language.  As a consequence, any useful definition of what constitutes a programming language, and the extent to which two are the same, has got to take syntax into account.</para><para>A major impediment to acceptance of a literate programming language is the fact that it is a different language.  It's not the programming language that a programmer knows, and switching over is not a small job.  And I'm afraid to say that I've found computer programmers in general very conservative in what languages they are willing to work with: they generally stick with what they know.  A major selling job is needed to convince programmers to switch.</para><para>It being a different language than what programmers were used to seems to be a large part of the reason that the SGML/C-based programming language described in this paper failed.  It may well be for other reasons: lack of promotion of the language, or a well-established base of other software that management and the programmers didn't want to change.  These things have to be taken into consideration when developing a new language, to ensure its better acceptance.</para></section><section><title>Conclusions And Observations</title><para>Literate Programming is something that clearly needs more work:<itemizedlist><listitem><para>More use of Literate Programming needs to be undertaken so that useful ideas can be developed.  If nobody does it, it's not going to happen.</para></listitem><listitem><para>Markup conventions for Literate Programming need to be developed, either with respect to a particular programming language, or which apply to a variety of programming languages.  There is not going to be general acceptance of Literate Programming if every language or, worse yet, every system has its own set of conventions.</para><para>As noted earlier, the trade-offs between full and compact markup are somewhat subjective.  As a consequence, these conventions will need to be arbitrary.  And that has to be accepted.</para></listitem><listitem><para>Literate Programming tools need to be integrated into software development systems.  At present, Literate Programming is usually implemented as a preprocessor.  But this doesn't fit well with most visual software development systems, or with the expectations of most programmers.</para></listitem><listitem><para>The use of compact markup in XML documents needs to be researched further.  Whether XML itself needs to be extended to support compact, whether that can best be done outside of XML, or whether it's unwise to try either needs to be reexamined.</para></listitem></itemizedlist></para><para>Markup-based Literate Programming gives us the opportunity to bring the advantages of markup in general, and XML in particular, to a wider community.  More than any new programming language feature -- which language designers are always on the lookout for -- better and more reliable documentation could make a difference to how computer programmers work.  But it's not a small task: it's as big as developing a whole new programming langauge.</para></section><bibliography><title>References</title><bibliomixed xml:id="c" xreflabel="C programming language">Home page of ISO/IEC JTC1/SC22/WG14 - C <link xlink:href="http://www.open-std.org/jtc1/sc22/wg14" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.open-std.org/jtc1/sc22/wg14</link></bibliomixed><bibliomixed xml:id="knuth" xreflabel="Knuth's WEB System">Donald E. Knuth, Literate Programming <link xlink:href="http://www.literateprogramming.com/knuthweb.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.literateprogramming.com/knuthweb.pdf</link></bibliomixed><bibliomixed xml:id="lp" xreflabel="Literate Programming">Literate Programming Web Site <link xlink:href="http://www.literateprogramming.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.literateprogramming.com</link></bibliomixed><bibliomixed xml:id="mn7" xreflabel="The Magical Number Seven">George A. Miller, Harvard University, "The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information" <link xlink:href="http://www.psych.utoronto.ca/users/peterson/psy430s2001/Miller%20GA%20Magical%20Seven%20Psych%20Review%201955.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.psych.utoronto.ca/users/peterson/psy430s2001/Miller GA Magical Seven Psych Review 1955.pdf</link></bibliomixed><bibliomixed xml:id="omnimark" xreflabel="OmniMark">OmniMark Developer Resources <link xlink:href="http://developers.omnimark.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://developers.omnimark.com</link></bibliomixed><bibliomixed xml:id="sgml" xreflabel="SGML">Standard Generalized Markup Language (SGML) <emphasis role="ital">International Organization for Standardization</emphasis> ISO 8879:1986</bibliomixed><bibliomixed xml:id="tex" xreflabel="TeX">TeX Users Group <link xlink:href="http://www.tug.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.tug.org</link></bibliomixed><bibliomixed xml:id="wiki" xreflabel="Wiki Markup">Wikipedia Wiki Markup Help page <link xlink:href="http://en.wikipedia.org/wiki/Help:Wiki_markup" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://en.wikipedia.org/wiki/Help:Wiki_markup</link></bibliomixed><bibliomixed xml:id="xml" xreflabel="XML">Extensible Markup Language (XML) 1.1 (Second Edition) <link xlink:href="http://www.w3.org/TR/xml11" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xml11</link></bibliomixed><bibliomixed xml:id="xpath" xreflabel="XPath">XML Path Language (XPath) 3.0 <link xlink:href="http://www.w3.org/TR/xpath-30" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-30</link></bibliomixed><bibliomixed xml:id="xslt" xreflabel="XSLT">XSL Transformations (XSLT) <link xlink:href="http://www.w3.org/TR/xslt" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</link></bibliomixed></bibliography></article>