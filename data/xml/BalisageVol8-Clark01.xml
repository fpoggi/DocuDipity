<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3"><title>Meta-stylesheets: Exploring the Provenance of XSL Transformations</title><info><confgroup><conftitle>Balisage: The Markup Conference 2012</conftitle><confdates>August 7 - 10, 2012</confdates></confgroup><abstract><para>When documents are transformed with XSLT, what methods can be used to understand and record those transformations? Though they aren't specifically meant for provenance capture, existing tools and informal practices can be used to manually piece together the provenance of XSLTs. However, a meta-stylesheet approach has the potential to generate provenance information by creating a copy of XSLT stylesheets with provenance-specific instructions. This method is currently being implemented, using the strategies and workflows detailed here. Even with the complications and limitations of the method, XSLT itself enables a surprising amount of provenance capture.</para></abstract><author><personname><firstname>Ashley</firstname><surname>Clark</surname></personname><personblurb><para>Ashley Clark recently received her M.S. from the Graduate School of Library and Information Science at the University of Illinois at Urbana-Champaign, where she specialized in data curation and worked as a research assistant and hourly academic. Her interests include data curation and data provenance in the humanities.</para></personblurb></author><legalnotice><para>Copyright Â© 2012 by the author. Used with permission.</para></legalnotice></info><section><title>Introduction</title><para>Provenance records are records for trust and authenticity, records to prove that the object is what it is claimed to be. Provenance has its roots in the archival world, where the goal is to see objects survive with minimal weathering as they pass from one caretaker to the next (<xref linkend="sweeney08"/>). Similarly, data provenance answers the question "How did this come to be here, in this state?", and it does so by identifying the agents, transformation events, and other artifacts associated with that object.</para><para>Computer usage is so prevalent in humanities and sciences research that it is all but guaranteed that data will be changed in some way during its lifetime. This has the advantage that tools can automatically generate provenance information, recording important details about the transformation process. Later, a provenance record of this sort may be used for error-checking, to independently reproduce a result, or simply for results verification (<xref linkend="kusteretal11"/>). Few e-humanities software tools offer provenance capabilities, likely due to time constraints and a lack of common practice. However, one reason may be in terms of nomenclature. Humanities research often involves documents, and humanists may bristle to think of their documents as the 'data' part of data provenance (<xref linkend="fear11"/>).<footnote><para>See <xref linkend="babeu11"/> for an in-depth look at digital humanists and the challenges of creating "ecosystems" to suit their needs.</para></footnote></para><para>Still, more and more documents are becoming - or are born as - data, thanks to mark-up languages (<xref linkend="bunemankhannatan00"/>). XSLT is one possible step in document transformation, and as such, is subject to the same provenance needs as other processes. XSL transformations can be examined and, with a little effort, used to generate provenance information about the creation of documents. The goal of this project is to examine methods of gathering provenance information about XSL transformations, and to explore the possibilities of automatically generating such records.</para></section><section><title>Provenance terminology</title><para>A handful of provenance ontologies exist, and each identifies three basic classes of provenance: information about processes, or transformation events; about agents, or the people (or software) which catalyze or carry out the event; and artifacts, or 'things' which may be acted on, generated by, or otherwise associated with a transformation event. The below figure gives the terminology of two such ontologies, the Open Provenance Model (<xref linkend="moreau10"/>) and the W3C PROV-O (<xref linkend="belhajjame12"/>). <figure><title>Provenance classes of OPM and W3C PROV-O</title><table><thead><tr><td>Ontology</td><td>'Thing'</td><td>Transformation Event</td><td>Person/Software</td></tr></thead><tbody><tr><td><emphasis>Open Provenance Model (OPM)</emphasis></td><td><emphasis>Artifact</emphasis></td><td><emphasis>Process</emphasis></td><td><emphasis>Agent</emphasis></td></tr><tr><td>W3C PROV</td><td>Entity</td><td>Action</td><td>Agent</td></tr></tbody></table></figure></para><para>My first attempts at provenance documentation were founded on the XML binding of OPM. OPM was designed primarily to capture information about scientific data workflows, and loosely fit the information needed to document XSLT provenance. Current work makes use of the Open Provenance Model Vocabulary, a modified version of OPM which includes a module for XSLT provenance (<xref linkend="zhao10"/>). As such, this paper makes use of OPM and OPMV XSLT module terminology.<footnote><para>Currently a work in progress, the W3C PROV is an attempt at a provenance ontology general enough to be used for many fields, but flexible enough to handle the specific provenance needs of any organization or community. Once completed, it will likely prove more useful than OPM for provenance markup. For example, OPM has no versioning capabilities, while PROV does.</para></footnote></para></section><section><title>What can we glean from an XSL transformation?</title><para>Gathering XSLT provenance information is already possible through a number of methods. The simplest method (though not necessarily the easiest for understanding) is to simply examine the artifacts associated with an XSL transformation - mainly the input, output, and stylesheets involved in the transformation. In particular, comments left on a stylesheet could reveal the author agent's identity, thought process, and understanding of what the XSLT code does or is supposed to do. One might be able to determine the templates' firing order, but the process may just as well be laborious in terms of piecing together provenance.</para><para>A better method is to use a debugger to step through a transformation, which grants an in-depth look at the way an output document is constructed from input and stylesheet. Parameter and variable values may also be shown, which may explain choices made by the XSLT processor. This step-through method is aimed for human understanding, but no record of the steps is available for consultation. Provenance information would be easier to identify with this method as opposed to the first, but it would still have to be documented by hand.</para><para>In contrast, the Saxon processor has a trace function<footnote><para>Append "-T" when transforming via Java platform.</para></footnote> which provides a tree view of the steps within an XSL transformation. It shows what input nodes are matched to templates, and includes the file name and line numbers of each processed node. The trace log cannot reference the specific elements in the output that came into existence due to any one transformation step. Instead, one must infer the structure of the output from the steps taken. Still, when used as a roadmap to examining the input documents and stylesheets, the trace log is explicit and exact in its references - a good representation of the transformation which created the output, so long as one has access to the files referenced.<figure><title>Sample Saxon trace output (with other error output removed)</title><programlisting xml:space="preserve">&lt;trace saxon-version="9.4.0.3" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
 &lt;source node="/" line="0" file="test1.xml"&gt;
  &lt;xsl:template match="/" line="16" module="testRegStylesheet.xsl"&gt;
   &lt;LRE name="html" line="17" module="testRegStylesheet.xsl"&gt;
    &lt;LRE name="head" line="18" module="testRegStylesheet.xsl"&gt;
     &lt;LRE name="title" line="19" module="testRegStylesheet.xsl"&gt;
      &lt;xsl:text line="19" module="testRegStylesheet.xsl"&gt;
      &lt;/xsl:text&gt;
     &lt;/LRE&gt;
    &lt;/LRE&gt;
    &lt;xsl:apply-templates line="21" module="testRegStylesheet.xsl"&gt;
     &lt;source node="/test/compute[1]" line="3" file="test1.xml"&gt;
      &lt;xsl:template match="compute" line="26" module="testRegStylesheet.xsl"&gt;
       &lt;LRE name="body" line="27" module="testRegStylesheet.xsl"&gt;
        &lt;xsl:apply-templates line="28" module="testRegStylesheet.xsl"&gt;
         &lt;source node="/test/compute[1]/message[1]" line="3" file="test1.xml"&gt;
          &lt;xsl:template match="message" line="33" module="testRegStylesheet.xsl"&gt;
           &lt;xsl:call-template line="34" module="testRegStylesheet.xsl"&gt;
            &lt;xsl:value-of line="36" module="testRegStylesheet.xsl"&gt;
            &lt;/xsl:value-of&gt;
            &lt;xsl:template name="summon" line="42" module="testRegStylesheet.xsl"&gt;
             &lt;xsl:param name="sayeth" line="43" module="testRegStylesheet.xsl"&gt;
             &lt;/xsl:param&gt;
             &lt;LRE name="b" line="44" module="testRegStylesheet.xsl"&gt;
              &lt;xsl:text line="45" module="testRegStylesheet.xsl"&gt;
              &lt;/xsl:text&gt;
              &lt;xsl:value-of line="46" module="testRegStylesheet.xsl"&gt;
              &lt;/xsl:value-of&gt;
              &lt;xsl:text line="47" module="testRegStylesheet.xsl"&gt;
              &lt;/xsl:text&gt;
              &lt;xsl:value-of line="48" module="testRegStylesheet.xsl"&gt;
              &lt;/xsl:value-of&gt;
             &lt;/LRE&gt;
            &lt;/xsl:template&gt;
           &lt;/xsl:call-template&gt;
          &lt;/xsl:template&gt;
         &lt;/source&gt;&lt;!-- /test/compute[1]/message[1] --&gt;
        &lt;/xsl:apply-templates&gt;
       &lt;/LRE&gt;
      &lt;/xsl:template&gt;
     &lt;/source&gt;&lt;!-- /test/compute[1] --&gt;
    &lt;/xsl:apply-templates&gt;
   &lt;/LRE&gt;
  &lt;/xsl:template&gt;
 &lt;/source&gt;&lt;!-- / --&gt;
&lt;/trace&gt;</programlisting></figure></para><para>XSLT itself also provides the capability to capture some provenance information, through functions such as <code>system-property()</code> and <code>base-uri()</code>. With these functions, the output of a stylesheet could include information on the XSLT version used; the processor agent which controlled the XSL transformation; and the file names of an input document and the primary stylesheet. However, the use of this method is dependent on those who created or who maintain the stylesheet.<footnote><para>Read: those who likely already know the files and processor being used, and who may not see the use in including such information.</para></footnote></para><para>The oXygen XML Editor has a documentation generation tool for XSLT stylesheets. The tool creates a log giving information about the stylesheet and children of the <code>xsl:stylesheet</code> node (most notably, templates). Interestingly enough, the documentation tool also assumes that if a node has a comment placed immediately before it, then the comment is documentation for the contents of that node. While this assumption could be wrong, it certainly rewards those who provide descriptions of stylesheets and templates through comments. It is worth noting that the documentation tool may not contain any provenance information at all, since it only describes the stylesheet artifact and does not guarantee any references to agents, process instances, or other artifacts. On the other hand, the documentation is an excellent example of the types of information that should be included when a provenance record references a stylesheet or template artifact.</para><para>What kinds of information, then, can we find about an XSL transformation? <itemizedlist><listitem><para>XSLT version</para></listitem><listitem><para>XSLT processor name, version, vendor</para></listitem><listitem><para>input document URI</para></listitem><listitem><para>stylesheet URI</para></listitem><listitem><para>template matches or calls</para></listitem><listitem><para>literal result element (LRE) insertion</para></listitem><listitem><para>input node transformation steps</para></listitem><listitem><para>authorship (dependent on programmer)</para></listitem><listitem><para>copyright information (dependent on programmer)</para></listitem><listitem><para>explanation of coding choices (dependent on programmer)</para></listitem></itemizedlist>Although we have a number of methods for piecing together the provenance of an XSL transformation, there are a number of limitations, the foremost of which is the fact that these methods offer only a portion of the provenance information available for XSLT processes. To gather all of the above information would require using each method and manually piecing together the results to form comprehensive provenance documentation. A general provenance tool for XSLT should include as much of this information as possible, recording it during XSLT processes at a user's behest.</para></section><section><title>The meta-stylesheet method</title><section><title>Assumptions and approach</title><para>When I started looking at XSLT provenance, I hoped to find a method that would be: <orderedlist><listitem><para>comprehensive, combining as many types of the above provenance information as possible; </para></listitem><listitem><para>easy to use - either fitting right into existing workflows, or able to be run and used with minimum fuss; and</para></listitem><listitem><para>in a format built for shareable provenance.</para></listitem></orderedlist>I also hoped for a method that would be reliant on neither a specific type of XSLT processor (as helpful as the Saxon trace has been), nor on a specific program such as oXygen.</para><para>Wendell Piez suggested a possible solution - to build a "meta-stylesheet." The meta-stylesheet will take stylesheet A as input, and output a stylesheet B, which in turn will approximate the XSLT processes of running stylesheet A with the same input document. Instead of the output expected from stylesheet A, the "meta'd" transformation scenario will output an OPMV-based RDF graph, providing provenance information on multiple levels of granularity. Currently, only two levels of provenance are captured: first, the file-level transformation process; second, the firing of templates as they are matched or called.</para></section><section><title>A workflow for provenance reporting</title><para>The steps of the XSLT provenance workflow are currently as follows: <orderedlist><listitem><para>Use the meta-stylesheet to create stylesheet B (for generating provenance) and, optionally, stylesheet C (for assigning <code>rdf:ID</code>s to template code)</para></listitem><listitem><para>Use stylesheet A or C<footnote><para>Since A and C have the same output, I refer to "A" when talking about the characteristics of both, and "C" when specifically talking about stylesheet C.</para></footnote> and input.xml to create output.xml<footnote><para>The input and output can, of course, be in formats other than XML.</para></footnote>.</para></listitem><listitem><para>Use stylesheet B on input.xml to create an OPMV RDF graph representing the provenance of step 2.</para></listitem></orderedlist></para><para><figure><title>An overview of the meta-stylesheet method</title><mediaobject><imageobject><imagedata fileref="../../../vol8/graphics/Clark01/Clark01-001.png"/></imageobject></mediaobject></figure>The workflow is meant to capture the provenance of step 2, on two levels of granularity: file-level and template-level. The file-level XSL transformation process references the input document, as well as the stylesheet(s) used. The process is controlled by the XSLT processor, and generates an output document. As with the Saxon trace, this method can only give the provenance information of the transformation process which created the output.xml.<figure><title>Provenance at the file level</title><mediaobject><imageobject><imagedata fileref="../../../vol8/graphics/Clark01/Clark01-002.png"/></imageobject></mediaobject></figure><figure><title>Sample file-level provenance documentation (provenance.rdf)</title><programlisting xml:space="preserve">&lt;!-- Provenance for the transformation of file:/C:/Users/Ashley/Desktop/global_001/input.xml 
using stylesheetC.xsl: --&gt;
&lt;xslt:Stylesheet rdf:about="stylesheetC.xsl"&gt;
    &lt;xslt:version&gt;1.0&lt;/xslt:version&gt;
&lt;/xslt:Stylesheet&gt;
&lt;xslt:Processor rdf:ID="proc01"&gt;
    &lt;xslt:vendor rdf:resource="http://www.saxonica.com/"/&gt;
    &lt;xslt:productName&gt;SAXON&lt;/xslt:productName&gt;
    &lt;xslt:productVersion&gt;PE 9.3.0.5&lt;/xslt:productVersion&gt;
&lt;/xslt:Processor&gt;
&lt;xslt:Binding rdf:ID="alpha"&gt;
    &lt;xslt:value&gt;Y&lt;/xslt:value&gt;
&lt;/xslt:Binding&gt;
&lt;xslt:Transformation rdf:ID="overall"&gt;
    &lt;xslt:source rdf:resource="file:/C:/Users/Ashley/Desktop/global_001/input.xml"/&gt;
    &lt;xslt:stylesheet rdf:resource="stylesheetC.xsl"/&gt;
    &lt;xslt:processor rdf:resource="#proc01"/&gt;
    &lt;xslt:binding rdf:resource="#alpha"/&gt;
&lt;/xslt:Transformation&gt;</programlisting></figure></para><para>Like the overall transformation process, template-level provenance heavily uses the XSLT module for OPMV. Here, each <code>xslt:Transformation</code> points to an <code>xslt:Template</code> artifact, which could be of either subtype <code>xslt:MatchedTemplate</code> or <code>xslt:NamedTemplate</code>. The edge between the two is <code>xslt:used</code>. If the template firing was triggered by <code>xsl:apply-templates</code>, then it also contains a reference to the source node to which the template was matched. Any template, and thus any transformation, might contain parameters or variables, and thus, bindings. Unlike stylesheet bindings, a template parameter of the same name - but different <code>rdf:ID</code>! - can carry a different value every time the template is run. <figure><title>Provenance at the template level</title><mediaobject><imageobject><imagedata fileref="../../../vol8/graphics/Clark01/Clark01-003.png"/></imageobject></mediaobject></figure><figure><title>Sample template-level provenance documentation (provenance.rdf)</title><programlisting xml:space="preserve">&lt;!-- Template-level provenance: --&gt;
&lt;xslt:Template rdf:about="stylesheetC.xsl#art_t1"&gt;
    &lt;rdfs:label&gt;mode='#default', match='/', name=''&lt;/rdfs:label&gt;
    &lt;rdfs:comment&gt;&amp;lt;xsl:template match='/'&amp;gt;
    &amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
            &amp;lt;meta http-equiv='Content-Type' content='text/html; charset=UTF-8'&amp;gt;&amp;lt;/meta&amp;gt;
            &amp;lt;title&amp;gt;Provenance&amp;lt;/title&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;xsl:apply-templates&amp;gt;&amp;lt;/xsl:apply-templates&amp;gt;
    &amp;lt;/html&amp;gt;
&amp;lt;/xsl:template&amp;gt;&lt;/rdfs:comment&gt;
    &lt;opmv:wasEncodedBy rdf:resource="stylesheetC.xsl"/&gt;
&lt;/xslt:Template&gt;
&lt;xslt:Template rdf:about="stylesheetC.xsl#art_t2"&gt;
    &lt;rdfs:label&gt;mode='#default', match='compute', name=''&lt;/rdfs:label&gt;
    &lt;rdfs:comment&gt;&amp;lt;xsl:template match='compute'&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;xsl:apply-templates&amp;gt;&amp;lt;/xsl:apply-templates&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/xsl:template&amp;gt;&lt;/rdfs:comment&gt;
    &lt;opmv:wasEncodedBy rdf:resource="stylesheetC.xsl"/&gt;
&lt;/xslt:Template&gt;
&lt;xslt:Transformation rdf:ID="pr_d1-1"&gt;
    &lt;rdfs:label&gt;Template art_t1 applied&lt;/rdfs:label&gt;
    &lt;xslt:source rdf:resource="file:/C:/Users/Ashley/Desktop/global_001/input.xml#"/&gt;
    &lt;xslt:used&gt;
        &lt;xslt:MatchedTemplate rdf:about="stylesheetC.xsl#art_t1"/&gt;
    &lt;/xslt:used&gt;
    &lt;xslt:processor rdf:resource="#proc01"/&gt;
    &lt;opmv:wasTriggeredBy rdf:resource="#overall"/&gt;
&lt;/xslt:Transformation&gt;
&lt;xslt:Transformation rdf:ID="pr_d1e3-2"&gt;
    &lt;rdfs:label xmlns=""&gt;Template art_t2 applied&lt;/rdfs:label&gt;
    &lt;xslt:source
        rdf:resource="file:/C:/Users/Ashley/Desktop/global_001/input.xml#/test[1]/compute[1]"/&gt;
    &lt;xslt:used&gt;
        &lt;xslt:MatchedTemplate rdf:about="stylesheetC.xsl#art_t2"/&gt;
    &lt;/xslt:used&gt;
    &lt;xslt:processor rdf:resource="#proc01"/&gt;
    &lt;opmv:wasTriggeredBy rdf:resource="#pr_d1-1"/&gt;
&lt;/xslt:Transformation&gt;</programlisting></figure></para></section><section><title>Layering code for provenance</title><para>The job of stylesheet B is to carry the same structure as stylesheet A, so that for any input document, an XSLT processor will choose the same transformation step for either stylesheet. However, the structure needed to accurately mirror stylesheet A depends on the granularity expectations. If stylesheet B only needs to capture file-level granularity, the XSLT code only requires information about the input document artifact and the processor agent. On the other hand, template-level granularity would require stylesheet B to maintain the same templates with the same attributes and the same template calls or matches. Currently, the stylesheet B keeps only those elements from stylesheet A which are essential to the structure of the stylesheet (such as <code>xsl:template</code>), or which are needed to determine parameter or variable bindings. The more provenance required, the more stylesheet B will come to resemble stylesheet A. However, stylesheet B keeps this structure only to accurately represent the process of obtaining output.xml in step 2.<footnote><para>As provenance becomes increasingly fine-grained, other elements will be left in as well.</para></footnote></para><para>The meta-stylesheet is simply a means to create stylesheet B. The meta-stylesheet passes the OPMV base structures to the meta'd stylesheet. The stylesheet artifact, and template artifacts must be generated at this step. The meta-stylesheet also sets up the XSLT code for the transformation processes and artifacts which must be generated when stylesheet B is used with input, so as to accurately represent the transformation at step 2.</para><para>As an example, the next figure shows a simple comment taken from the beginning of the provenance output. The two figures after that show the XSLT code needed to generate that comment. The meta-stylesheet must layer <code>xsl:comment</code> within an <code>xsl:element</code> so that the comment appears in provenance.rdf and not stylesheet B. The meta-stylesheet also passes the name of stylesheet A to stylesheet B, since stylesheet B otherwise would have no knowledge of the parallel stylesheet. Stylesheet B, however, must find the <code>base-uri()</code> of the input document and generate the comment for provenance.rdf.</para><figure><title>Selection from provenance.rdf</title><programlisting xml:space="preserve">&lt;!-- Provenance for the transformation of file:/C:/Users/Ashley/Desktop/global_001/input.xml 
using stylesheetC.xsl: --&gt;</programlisting></figure><figure><title>Selection from stylesheet B.xsl</title><programlisting xml:space="preserve">&lt;xsl:comment&gt; Provenance for the transformation of &lt;xsl:value-of select="base-uri()"/&gt; 
using stylesheetC.xsl: &lt;/xsl:comment&gt;</programlisting></figure><figure><title>Selection from the meta-stylesheet (metaRDF.xsl)</title><programlisting xml:space="preserve">&lt;xsl:element name="xsl:comment"&gt;
    &lt;xsl:text&gt; Provenance for the transformation of &lt;/xsl:text&gt;
    &lt;xsl:element name="xsl:value-of"&gt;
        &lt;xsl:attribute name="select"&gt;base-uri()&lt;/xsl:attribute&gt;
    &lt;/xsl:element&gt;
    &lt;xsl:text&gt; using &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$regularStylesheet"/&gt;
    &lt;xsl:text&gt;: &lt;/xsl:text&gt;
&lt;/xsl:element&gt;</programlisting></figure><para>Essentially, the meta-stylesheet has knowledge of stylesheet A; the version of XSLT and the files it uses; and the number of and identifying information regarding the templates. The stylesheet B will be able to grab information about the input document, the specifics of an individual transformation, and the XSLT processor. The meta-stylesheet sets up stylesheet B to take that kind of information and funnel it into the provenance output.</para></section><section><title>Requirements for a meta-stylesheet</title><para>Before it does anything else, the meta-stylesheet matches the root of its input and creates an copy of stylesheet A, only with <code>rdf:ID</code>s attached to the templates. "Stylesheet C" is unnecessary for the provenance workflow above, but it may be useful for linking relevant template code to the provenance template artifacts.</para><para>After stylesheet C is taken care of, the meta-stylesheet starts on stylesheet B. However, stylesheet A might fall into one of three categories: <itemizedlist><listitem><para>there is no template matching root (default template rules apply); </para></listitem><listitem><para>there is a template which matches root and only root; </para></listitem><listitem><para>or, there is a template which matches root as well as other nodes.</para></listitem></itemizedlist>Since the meta-stylesheet must keep the structure of stylesheet A as well as preparing for eventual RDF/XML output, the <code>rdf:Graph</code> container element must be carefully placed. In the first case, a root template is created. In the second case, stylesheet A's root template can be reduced to provenance-ready structure, but with the template node's descendants wrapped in the <code>rdf:Graph</code>. The third case is slightly more difficult. The original template must have the root node stripped from <code>@match</code> before it can be copied forward into stylesheet B, and a new template created to match only root, with the same instructions wrapped in the <code>rdf:Graph</code>. It's also worth noting that each template in stylesheet B will be prepared with an <code>rdf:about</code> with a link to a template in stylesheet C. In the third case, both template artifacts derived from the original will point to the same template in stylesheet C. </para><para>Placing the root element is also important because there is no better place to record the file-level provenance. When the processor matches the root node to any template (or built-in rule, as the case may be), the stylesheet and input file artifacts are already known, as are the processor agent and stylesheet-level parameters and variables.<figure><title>Code for the overall transformation process (metaRDF.xsl)</title><programlisting xml:space="preserve">&lt;!-- Set up the xslt:Transformation for $regularStylesheet and its input. --&gt;
&lt;xslt:Transformation rdf:ID="overall"&gt;
    &lt;xslt:source&gt;
        &lt;xsl:element name="xsl:attribute"&gt;
            &lt;xsl:attribute name="name"&gt;rdf:resource&lt;/xsl:attribute&gt;
            &lt;xsl:element name="xsl:value-of"&gt;
                &lt;xsl:attribute name="select"&gt;base-uri()&lt;/xsl:attribute&gt;
            &lt;/xsl:element&gt;
        &lt;/xsl:element&gt;
    &lt;/xslt:source&gt;
    &lt;xslt:stylesheet&gt;
        &lt;xsl:attribute name="rdf:resource"&gt;
            &lt;xsl:value-of select="$regularStylesheet"/&gt;
        &lt;/xsl:attribute&gt;
    &lt;/xslt:stylesheet&gt;
    &lt;xslt:processor&gt;
        &lt;xsl:attribute name="rdf:resource"&gt;
            &lt;xsl:text&gt;#proc01&lt;/xsl:text&gt;
        &lt;/xsl:attribute&gt;
    &lt;/xslt:processor&gt;
    &lt;xsl:for-each select="/(xsl:transform | xsl:stylesheet)/xsl:param"&gt;
        &lt;xslt:binding&gt;
            &lt;xsl:attribute name="rdf:resource"&gt;
                &lt;xsl:text&gt;#&lt;/xsl:text&gt;
                &lt;xsl:value-of select="@name"/&gt;
            &lt;/xsl:attribute&gt;
        &lt;/xslt:binding&gt;
    &lt;/xsl:for-each&gt;
&lt;/xslt:Transformation&gt;</programlisting></figure>The template artifacts can be generated here by using <code>xsl:for-each</code>, so long as one is willing to accept that template artifacts may be listed that are not referenced in any transformation.</para><para>The processes for templates firing should be generated during the transformation of stylesheet B, thus guaranteeing a chain of template-level processes. A template-level process is triggered by another process - either the file-level process, or by an <code>xsl:apply-templates</code> or <code>xsl:call-template</code> during another template's firing. If a template is called or matched, OPMV contains two Template subclasses - <code>xslt:MatchedTemplate</code> and <code>xslt:CalledTemplate</code>. For a process to correctly reference the use of a template artifact, the meta-stylesheet must set up stylesheet B to pass along information about the 'parent' template. I used tunneled parameters to accomplish this - each template in stylesheet B gains two parameters, called 'provTemplate' and 'provTrigger'. 'provTemplate' identifies the XSLT instruction which initiated the current template process, and 'provTrigger' passes along the identifier for the 'parent' template. The meta-stylesheet must assign <code>xsl:with-param</code> instructions to each <code>xsl:apply-templates</code> and <code>xsl:call-template</code>.<figure><title>Code to track template parentage with xsl:call-template (metaRDF.xsl)</title><programlisting xml:space="preserve">&lt;xsl:template match="xsl:call-template"&gt;
    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;xsl:element name="xsl:with-param"&gt;
            &lt;xsl:attribute name="name"&gt;provTemplate&lt;/xsl:attribute&gt;
            &lt;xsl:attribute name="tunnel"&gt;yes&lt;/xsl:attribute&gt;
            &lt;xsl:text&gt;called&lt;/xsl:text&gt;
        &lt;/xsl:element&gt;
        &lt;xsl:element name="xsl:with-param"&gt;
            &lt;xsl:attribute name="name"&gt;provTrigger&lt;/xsl:attribute&gt;
            &lt;xsl:attribute name="tunnel"&gt;yes&lt;/xsl:attribute&gt;
            &lt;xsl:element name="xsl:value-of"&gt;
                &lt;xsl:element name="xsl:text"&gt;#pr_&lt;/xsl:element&gt;
                &lt;xsl:element name="xsl:value-of"&gt;
                    &lt;xsl:attribute name="select"&gt;generate-id()&lt;/xsl:attribute&gt;
                &lt;/xsl:element&gt;
                &lt;xsl:element name="xsl:text"&gt;-&lt;/xsl:element&gt;
                &lt;xsl:number count="xsl:template" level="any"/&gt;
            &lt;/xsl:element&gt;
        &lt;/xsl:element&gt;
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></figure></para></section></section><section><title>Future work</title><para>The meta-stylesheet has been successfully created, and it can provide file- and template-level provenance documentation for XSL transformations, as shown in the examples above. Still, there are a number of questions still left to explore regarding the meta-stylesheet method and XSLT provenance documentation. For example, how much provenance collection is too much? Further work can be done to include finer levels of granularity, but it probably isn't necessary to document every XSLT instruction. What about coarser granularity? If XSLTs are used in a workflow, what kinds of provenance documentation can be generated, and what should it look like?</para><para>Unfortunately, the meta-stylesheet method does not entirely fulfill the assumptions listed previously, especially in ease of use. No matter what version of XSLT is used by stylesheet A, both the meta-stylesheet and stylesheet B currently require the use of an XSLT 2.0 processor. This certainly limits the number of processors able to make use of this method without fuss. Further, the meta-stylesheet has only undergone testing using the Saxon HE and PE processors shipped with oXygen. More testing is needed to ensure that the approach works in broader contexts, with other tools and XSLT 2.0 processors.</para><para>But the biggest problem with this approach is the meta-stylesheet's inability to say anything concrete about the output of stylesheet A. Neither the meta-stylesheet nor stylesheet B has knowledge of the actual contents of output.xml, although a good estimation can probably be made by modifying the structure of stylesheet B. It is unclear whether this is a beneficial side-effect (as in workflows where intermediate outputs may not be available) or something that should be fixed.</para><para>Besides attempting to solve these questions, I continue to test the meta-stylesheet against a greater number of input stylesheets, and to include other types of provenance information, such as the template descriptions given by the oXygen Editor. Even at this date, this project shows that an impressive amount of provenance information can be generated with just XSLT.</para></section><section><title>Acknowledgements</title><para>Many, many thanks to Wendell Piez for coming up with the idea for a meta-stylesheet, as well as providing guidance and technical help along the way. Thanks also to Allen Renear, Megan Senseney, and my colleagues at CIRSS for their advice and unflagging support.</para><para>This project was supported by DCEP-H, an initiative to extend the Data Curation Education Program to the humanities. Funded by IMLS Grant RE-05-08-0062-08, DCEP-H was based at the Center for Informatics Research in Science and Scholarship at the University of Illinois at Urbana-Champaign.</para></section><bibliography><title>Bibliography</title><bibliomixed xreflabel="Babeu, 2011" xml:id="babeu11">Babeu, A. (2011). "Rome wasn't digitized in a day": Building a cyberinfrastructure for digital classics. Washington, D.C.: Council on Library and Information Resources. Accessed at <link xlink:href="http://www.clir.org/pubs/reports/pub150/pub150.pdf" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.clir.org/pubs/reports/pub150/pub150.pdf</link></bibliomixed><bibliomixed xreflabel="Belhajjame et al., 2012" xml:id="belhajjame12">Belhajjame, K., Deus, H., Garijo, D., Klyne, G., Missier, P., Soiland-Reyes, S., Zednik, S. (2012). PROV Model Primer, W3C Working Draft 03 May 2012. Accessed at <link xlink:href="http://www.w3.org/TR/2012/WD-prov-primer-20120503/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/2012/WD-prov-primer-20120503/</link></bibliomixed><bibliomixed xreflabel="Buneman, Khanna, &amp; Tan, 2000" xml:id="bunemankhannatan00">Buneman, P., Khanna, S., &amp; Tan, W. (2000). Data provenance: Some basic issues. In Kapoor, S., &amp; Prasad, S (Eds.), <emphasis role="ital">Lecture Notes in Computer Science : Vol. 1974. FST TCS 2000: Foundations of Software Technology and Theoretical Computer Science</emphasis> (pp. 87-93). Berlin, Germany: Springer. doi:<biblioid class="doi">10.1007/3-540-44450-5_6</biblioid></bibliomixed><bibliomixed xreflabel="Fear, 2011" xml:id="fear11">Fear, K. (2011). "You made it, you take care of it": Data management as personal information management. <emphasis role="ital">The International Journal of Digital Curation,</emphasis> 6(2), 53-77. Accessed at <link xlink:href="http://www.ijdc.net/index.php/ijdc/article/view/183/250" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.ijdc.net/index.php/ijdc/article/view/183/250</link></bibliomixed><bibliomixed xreflabel="KÃ¼ster, Ludwig, Al-Hajj, &amp; Selig, 2011" xml:id="kusteretal11">KÃ¼ster, M., Ludwig, C., Al-Hajj, Y. &amp; Selig, T. (2011). TextGrid provenance tools for digital humanities ecosystems. <emphasis role="ital">Proceedings of the 5th IEEE International Conference on Digital Ecosystems and Technologies 2011</emphasis>. (pp. 317-323). Daejeon, Korea: IEEE. doi:<biblioid class="doi">10.1109/DEST.2011.5936615</biblioid></bibliomixed><bibliomixed xreflabel="Moreau et al., 2010" xml:id="moreau10">Moreau, L., Clifford, B., Freire, J., Futrelle, J., Gil, Y., Groth, P., ..., Van den Bussche, J. (2010). The Open Provenance Model core specification (v1.1). Accessed at <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://eprints.ecs.soton.ac.uk/21449/</link></bibliomixed><bibliomixed xreflabel="Sweeney, 2008" xml:id="sweeney08">Sweeney, S. (2008). The ambiguous origins of the archival principle of "provenance". <emphasis role="ital">Libraries &amp; the Cultural Record</emphasis> 43(2), 193-213. University of Texas Press. doi:<biblioid class="doi">10.1353/lac.0.0017</biblioid></bibliomixed><bibliomixed xreflabel="Zhao, 2010" xml:id="zhao10">Zhao, Jun. (2010). Open Provenance Model Vocabulary specification. Accessed at <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://purl.org/net/opmv/ns-20101006</link>.</bibliomixed></bibliography></article>