<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title>Easy XML Serialization of C# and Java Objects</title><info><confgroup><conftitle>Balisage: The Markup Conference 2011</conftitle><confdates>August 2 - 5, 2011</confdates></confgroup><abstract><para>Object serialization is the process of rendering an object into a state that can be stored persistently. 
        Serializing objects to XML brings many advantages over binary encoding because XML is human and computer readable,
        and it also aims to have better interoperability between different programming languages. This paper presents
        Web Objects in XML (WOX), an efficient and easy to use XML serializer for C# and Java objects. It allows to serialize
        Java objects to XML, de-serialize them to C#, and viceversa. Our serialization approach does not need code annotations 
        or any other type of configuration from the user in order to serialize objects. The XML encoding used in our WOX serializer can 
        represent objects in other object-oriented programming languages. We describe the main features and uses of the WOX serializer,
        its implementation, and the XML representation generated along with some examples.</para></abstract><author><personname><firstname>Carlos</firstname><othername>R.</othername><surname>Jaimez-Gonzalez</surname></personname><personblurb><para>Carlos is currently an Associate Professor at the Information Technology
          Department of the Universidad Autonoma Metropolitana in Mexico City, where he is responsible of the
          Web Technologies and Systems Research Group. He holds a PhD from the School of Computer 
          Science and Electronic Engineering of the University of Essex, UK. His research interests include 
          web services, distributed objects, XML and related technologies, interoperability, systems integration, 
          web application development, and technologies for enhancing education.</para><para>Carlos has also been involved in several software projects for the industry; working as a Software 
          Developer, Team Leader, and Database Officer. He is a Microsoft Certified Systems Engineer (MCSE), 
          Database Administrator (MCDBA), and Solution Developer (MCSD).</para></personblurb><affiliation><jobtitle>Associate Professor</jobtitle><orgname>Departamento de Tecnologias de la Informacion, Universidad Autonoma Metropolitana - Unidad Cuajimalpa, Mexico</orgname></affiliation><email>cjaimez@correo.cua.uam.mx</email></author><author><personname><firstname>Simon</firstname><othername>M.</othername><surname>Lucas</surname></personname><personblurb><para>Simon M. Lucas is a Professor of Computer Science at the University of Essex, UK. His main research interests 
          are in machine learning and games. He has published widely in these fields with over 130 peer-reviewed papers and 
          is the Founding Editor-in-Chief of the IEEE Transactions on Computational Intelligence and AI in Games.</para><para>Professor Lucas was chair of IAPR Technical Committee 5 on Benchmarking and Software (2002–2006) and is the 
         inventor of the scanning n-tuple classifier, a fast and accurate OCR method. He was appointed inaugural chair of 
         the IEEE CIS Games Technical Committee in July 2006, has chaired or co-chaired many international conferences, 
         including the First IEEE Symposium on Computational Intelligence and Games in 2005. He is also an associate editor 
         of the IEEE Transactions on Evolutionary Computation, and the Springer Journal of Memetic Computing. He was an 
         invited keynote speaker or tutorial speaker at IEEE CEC 2007, IEEE WCCI 2008, IEEE CIG 2008, PPSN 2008,IEEE CEC 2009 
         and IEEE CEC 2010. He leads the newly established Game Intelligence Group at the University of Essex.</para></personblurb><affiliation><jobtitle>Professor</jobtitle><orgname>School of Computer Science and Electronic Engineering, University of Essex, UK</orgname></affiliation><email>sml@essex.ac.uk</email></author><author><personname><firstname>Erick</firstname><othername>J.</othername><surname>Lopez-Ornelas</surname></personname><personblurb><para>Erick is currently an Associate Professor at the Information Technology
          Department of the Universidad Autonoma Metropolitana in Mexico City. He holds a PhD from the Universite
          Paul Sabatier (France). He worked as researcher in the high resolution remote perception laboratory
          in Toulouse, France, in the areas of processing of high resolution satelital images, and geographical
          information systems. His research interests include the analysis of high resolution images,
          and the  processing, visualization, and extraction of knowledge from spatial information.</para></personblurb><affiliation><jobtitle>Associate Professor</jobtitle><orgname>Departamento de Tecnologias de la Informacion, Universidad Autonoma Metropolitana - Unidad Cuajimalpa, Mexico</orgname></affiliation><email>elopez@correo.cua.uam.mx</email></author><legalnotice><para>Copyright © 2011 by the authors. Used with permission.</para></legalnotice><keywordset role="author"><keyword>XML serializer</keyword><keyword>Java objects</keyword><keyword>C# objects</keyword><keyword>Interoperability</keyword><keyword>XML representation</keyword></keywordset></info><section><title>Introduction</title><para>Object serialization is the process of rendering an object into a state that can be stored persistently. 
      Serializing objects to XML brings many advantages over binary encoding because XML is human and computer readable,
      and it also aims to have better interoperability between different programming languages. Interoperability is 
      an important issue in distributed object-based systems, because it allows the communication of 
      programs (clients and servers) written in different object-oriented programming languages. There are some fundamental 
      issues that have to be agreed by the different programming languages to be able to reach interoperability. Some of these 
      are related to the data type mapping, object representation, messages, serialization and de-serialization.</para><para><emphasis role="ital">Data type mapping</emphasis>. Data types are one of the main issues when it comes to interoperability between different 
      programming languages. There must be an agreed mapping between the data types in the programming language X and the data 
      types in the programming language Y. One way to solve this problem is a mapping table with the different data types 
      supported by the different programming languages.</para><para><emphasis role="ital">Object representation</emphasis>. There must be a standard way of representing objects, either the object is written in Java, 
      C#, or other object-oriented programming language. A standard format must be established to represent the supported 
      structures in the different programming languages: classes, primitive data types, arrays, and user-defined classes. 
      This must also include a standard way to represent remote object references.</para><para><emphasis role="ital">Messages</emphasis>. They represent the way clients and servers communicate. Messages are used to make requests or receive 
      responses, and they must also be written in a standard way to be understood by clients and servers.</para><para><emphasis role="ital">Serialization and de-serialization</emphasis>. In the context of data storage and transmission, serialization is the process 
      of rendering an object into a state that can be saved persistently into a storage medium, such as a file, database, or 
      a stream to be transmitted through the network. De-serialization is the opposite process, which puts the serialized 
      version of the object into a live object. Serialization and de-serialization are processes heavily used when dealing 
      with distributed object-based systems.</para><para>In this paper we present Web Objects in XML (WOX), an efficient and easy to use XML serializer for interoperability 
      between the C# and Java programming languages. The WOX serializer is a stand-alone library based on XML (woxSerializer.jar 
      for the Java programming language, and woxSerializer.dll for the C# programming language), which is able to serialize
      Java and C# objects to XML and back again. One of its main features is the generation of standard XML, which is language 
      independent. This means that if we serialize a Java object to XML, we could take the generated XML to reconstruct the 
      object back to C#; and viceversa. It is worth noticing that our serialization approach does not need code annotations 
      or any other type of configuration from the user in order to serialize objects. </para><para>We have made our WOX serializer publicly available as an open-source project,
      which can be downloaded from <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://woxserializer.sourceforge.net/</link>. It must be noticed that the
      WOX serializer presented in this paper is an improved and interoperable version of the serializer that is part of
      the WOX framework reported in [Jaimez 2007], which has been used to develop distributed object-based applications.
      Many people have been using our WOX interoperable serializer since we made it available. As a consequence of this work, 
      the MSDN Magazine (a Microsoft Magazine) published an article, in its October 2010 issue [Khan 2010], about interoperability between 
      Java and .NET, where they mention and recommend the use of our work for interoperability between applications. We consider this as a 
      valuable example that demonstrates that our work has had an impact on the MSDN community.</para><para>The rest of the paper is organized as follows. Existing XML serializers are discussed in the next section. 
      A following section describes the main features and uses of the WOX serializer. Then, we dedicate another section to the implementation 
      of the WOX serializer. The XML representation generated by the WOX serializer is presented in a subsequent section along with some examples. 
      Finally, conclusions and further work are discussed in the final section.</para></section><section><title>Existing XML Serializers</title><para>We have not found any out of the box XML serializer to interoperate 
      between different programming languages. In this section we present a series of frameworks and libraries to 
      serialize objects to XML. All of the libraries explored (except one of them) are not able to generate a standard 
      XML object representation to interoperate between different programming languages.</para><para><emphasis role="ital">XStream</emphasis>. This is a Java library [XStream 2010] to serialize objects to XML and back again. XStream is able 
      to serialize most objects without the need for custom mappings. The XML generated is easy to understand. One of 
      its features is the use of aliases, which offer a way to use different tags or attribute names in the XML produced. 
      Class types, package names, and field names can be mapped to XML tags. This library is a good option to have an 
      object serialized to XML, but the main limitation is that it is only implemented in Java.</para><para><emphasis role="ital">Koala</emphasis>. Koala XML serialization [Koala 1998] is a Java application that provides a way to serialize and 
      de-serialize any Java objects in an XML document. The serialization mechanism of Koala relies in the Java 
      Serializable interface. This application is called KOML for Koala Object Markup Language, which is also a 100% 
      pure Java solution. The website of this project has not been updated since 1998.</para><para><emphasis role="ital">XMOP</emphasis>. XML Metadata Object Persistence [XMOP 2000] allows some degree of interoperability between object 
      technologies such as Java, and Microsoft COM. In the case of Java, it provides automatic serialization capabilities 
      only for simple classes. For those classes that contain string and array members, developers have to hand code the 
      serialization methods. In the case of COM, it does not provide automatic serialization for simple nor complex objects. 
      Developers have to code COM serialization/persistence through some interfaces provided. XMOP employs the Simple 
      Object Definition Language (SODL) and its DTD. Using introspection an object is serialized in the XMOP document format, 
      which is a description of the interfaces, properties and methods of an object. Although the XML representation 
      generated by XMOP is interoperable between programming languages, the developer has to do considerable effort to hand 
      code the serialization methods for the objects to be serialized.</para><para><emphasis role="ital">JSX</emphasis>. Java Serialization to XML [JSX 2002] serializes only Java objects to XML. JSX can persist any Java object in 
      a human readable format, where the XML generated is nice and clean. Another of its benefits is that it provides the 
      evolution techniques of the Java Object Serialization. This library used to be free, but it now provides a trial period 
      of 30 days, after which the user must pay to use it.</para><para><emphasis role="ital">Castor</emphasis>. The Castor project [Castor 2010] is an open source data binding framework for Java. It provides Java-to-XML 
      binding and Java-to-SQL persistence. The Java-to-XML framework enables the user to deal with the data defined in an XML 
      document through an object model which represents that data. Castor can marshal almost any Java object to and from XML. 
      One restriction is that the Java classes of the objects to be serialized must follow the Java Bean conventions. Castor 
      uses a set of class descriptors and field descriptors to describe how an object should be serialized and de-serialized 
      from XML. Castor can work in two different modes: the introspection mode does not require any configuration from the 
      user; but in the mapping mode, the user provides a user-defined mapping file that allows the definition of a customized 
      mapping between Java classes and XML.</para><para><emphasis role="ital">JAXB</emphasis>. The Java Architecture for XML Binding [JAXB 2010] is a framework for processing XML documents. Unmarshalling 
      an XML document with JAXB results in a tree of objects, with the nodes in this tree corresponding to XML elements, which 
      contain attributes and the content as instance variables. In order to extract this information and convert it to objects 
      from the XML document it is needed an XML Schema (which defines the structural relationships and data types). The XML 
      Schema is compiled, and a set of Java classes is generated, which define the types required for accessing elements, 
      attributes and other content. In this approach the user is required to know the structure of the XML document, and 
      create an XML Schema in order to map it to Java objects.</para><para>Although there are other existing libraries to serialize objects or messages to XML and viceversa, they are not 
      stand-alone, but they are part of a framework for web services, such as XML-RPC [Winer 1999], or those that implement 
      the SOAP standard [SOAP 2003]. Web service frameworks like those use XML serialization internally, and are out 
      of the scope of this paper.</para><para>The next section presents some of the main features of our WOX serializer, which can be used to generate standard 
      XML representations of objects, and is able to interoperate between C# and Java.</para></section><section><title>WOX Features and Uses</title><para>The main features of the WOX serializer are listed below. 
    <itemizedlist><listitem><para><emphasis role="ital">Stand-alone</emphasis>. It runs as a stand-alone library to serialize and de-serialize Java or C# objects.</para></listitem><listitem><para><emphasis role="ital">Easy to use</emphasis>. There is an Easy class, in both programming languages, that provides serialization and de-serialization methods.</para></listitem><listitem><para><emphasis role="ital">Simple XML</emphasis>. The XML generated by the WOX serializer is simple, easy to understand, and language independent.</para></listitem><listitem><para><emphasis role="ital">Classes require no modifications</emphasis>. The classes of objects to be serialized do not require to be changed with default 
                  constructors, getters, setters, or any other modifications.</para></listitem><listitem><para><emphasis role="ital">Field visibility</emphasis>. Private fields in classes are serialized just as any other field. The WOX serializer serializes 
                  fields regardless their visibility.</para></listitem><listitem><para><emphasis role="ital">Interoperability between Java and C#</emphasis>. WOX can serialize a Java object to XML, and reconstruct the XML back to a C# 
                  object; and viceversa.</para></listitem><listitem><para><emphasis role="ital">Standard XML object representation</emphasis>. This could potentially allow to have WOX serializers in different object-oriented 
                  programming languages. There are two WOX serializers already developed: one for Java, and one for C#.</para></listitem><listitem><para><emphasis role="ital">WOX data types mapping</emphasis>. There is a WOX mapping table that specifies how data types in Java and C# are mapped to WOX data types.</para></listitem><listitem><para><emphasis role="ital">Robust to class changes</emphasis>. If classes change, default values will be used for newly added fields.</para></listitem><listitem><para><emphasis role="ital">Arrays</emphasis>. Uni-dimensional and multi-dimensional arrays of primitive types and objects of any class are handled by the serializer.</para></listitem><listitem><para><emphasis role="ital">Base-64</emphasis>. Byte arrays are base-64 encoded for efficiency.</para></listitem><listitem><para><emphasis role="ital">Collection classes</emphasis>. Lists and Maps are provided as WOX data types. They are mapped to the ArrayList 
                  and HashMap classes in Java; and the ArrayList and Hashtable classes in C#.</para></listitem><listitem><para><emphasis role="ital">Object references</emphasis>. TheWOX serializer is capable to handle duplicate and circular object references with id and idref attributes.</para></listitem><listitem><para><emphasis role="ital">Class and Type</emphasis>. Objects of these classes are saved by their String name.</para></listitem><listitem><para><emphasis role="ital">Small footprint</emphasis>. The woxSerializer.jar file (which contains only .class files) is only 25KB.</para></listitem></itemizedlist>
      </para><para>The WOX serializer can be used by any program that needs to interoperate between C# or Java, or simply to serialize 
      objects to XML from any of those programming languages. Some of the purposes where the WOX serializer can be used are listed below. 
    <itemizedlist><listitem><para><emphasis role="ital">Transport an object</emphasis>. Serializing an object allows you send it through a network. Then it can be reconstructed at the other end.</para></listitem><listitem><para><emphasis role="ital">Store an object</emphasis>. Persisting objects with the WOX serializer is easy. You can use them later by reconstructing them to the 
                  appropriate programming language.</para></listitem><listitem><para><emphasis role="ital">Represent an object in a standard format</emphasis>. The XML generated byWOX aims to be independent of the programming language in which 
                  the object was created.</para></listitem><listitem><para><emphasis role="ital">Work with Java and C# objects</emphasis>. Java and C# objects can be serialized and de-serialized to and from XML.</para></listitem><listitem><para><emphasis role="ital">Testing</emphasis>. An object can be serialized to inspect its current state (fields and nested objects). This can help for debugging purposes.</para></listitem><listitem><para><emphasis role="ital">Duplicate an object</emphasis>. Serialization is an easy way to duplicate objects.</para></listitem></itemizedlist>
      </para></section><section><title>WOX Implementation</title><para>The implementation of the WOX serializer is described in this section through three different flow charts, which 
      illustrate how the WOX serializer writes any object to XML. This section has also been presented in [Jaimez 2011].
      The flow chart in <xref linkend="FigFlowChart01Basic"/> shows 
      the base functionality. There are some notes indicated with numbers inside a dotted square (A1 to A7) which are explained 
      below.</para><figure xml:id="FigFlowChart01Basic"><title>Flow chart A</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-001.jpg"/></imageobject></mediaobject><caption><para>Flow chart A: Base of the WOX serializer.</para></caption></figure><para>A1. We represent a NULL object as an EMPTY object in XML.</para><para>A2. We use a Map to store object references. This avoids the duplication of objects in the XML representation, and 
      the unnecessary serialization processing of objects that were already serialized. This Map is also used to handle adequately 
      recursive object references, because the serializer puts an object in the Map as soon as it goes through it (it is the first 
      step in the serialization process). This means that if this object is nested inside another object, the serializer will not 
      serialize it again, because when it reaches this object, the serializer will find out that its reference is already in the Map, 
      which handles the problem of recursive references.</para><para>A3. If the object is already in the Map, it is not necessary to serialize it again (a reference to the object will be 
      stored instead). The Map is populated as the serializer finds new objects. The <code>idref</code> XML attribute specifies the 
      object <code>id</code> in the Map that corresponds to the object found. It is important to notice that the
      <code>id</code> and <code>idref</code> attributes are not the same as those normally used in the XML sense; but they
      are used to identify uniquely objects that have already been serialized.</para><para>A4. We say that an object is stringable if it is of any of the following classes: <code>Byte</code>, <code>Short</code>, 
      <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>, 
      <code>Class</code>, <code>String</code>.</para><para>A5. Other objects in their stringable versions can be seen below.
<programlisting xml:space="preserve">&lt;object type="boolean" value="true" id="11" /&gt;
&lt;object type="char" value="\u0009" id="15" /&gt;
&lt;object type="int" value"785" id="21" /&gt;</programlisting>
    </para><para>A6. The serializer will process the array. The process to serialize an array is illustrated in the Flow chart B shown in Figure 2.</para><para>A7. At this point the serializer has found another type of object (not a stringable object, not an array). It is a 
      user-defined class or other type of object not covered in the previous cases. The serializer will write this object, 
      and go through each of its fields (attributes) to serialize them. The process to serialize each of the object fields 
      (attributes) is illustrated in Figure 3.</para><para>The flow chart in <xref linkend="FigFlowChart02Arrays"/> shows the functionality of the WOX serializer to deal with 
      arrays. The flow chart has some notes indicated with numbers inside a dotted square (B1 to B3), which are explained below.</para><figure xml:id="FigFlowChart02Arrays"><title>Flow chart B</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-002.jpg"/></imageobject></mediaobject><caption><para>Flow chart B: Arrays.</para></caption></figure><para>B1. The serializer checks the class of the object against an array that holds all the possible primitive uni-dimensional arrays.</para><para>B2. It is not a uni-dimensional array. It could be a n-dimensional array, or an array of objects of user-defined classes.</para><para>B3. The type of the primitive array found is any of the following: <code>int</code>, <code>boolean</code>, <code>short</code>, 
      <code>long</code>, <code>char</code>, <code>float</code> or <code>double</code>. Some examples of primitive arrays serialized to XML 
      by the WOX serializer are shown below.
<programlisting xml:space="preserve">&lt;array type="int" length="6" id="10"&gt;45 67 78 32 34 79&lt;/array&gt;
&lt;array type="char" length="3" id="19"&gt;\u0065 \u0004 \u0067&lt;/array&gt;</programlisting>
    </para><para>The flow chart in <xref linkend="FigFlowChart03Fields"/> shows the functionality of the WOX serializer to deal with fields of an object. The 
      flow chart has some notes indicated with numbers inside a dotted square (C1 to C3), which are explained below.</para><figure xml:id="FigFlowChart03Fields"><title>Flow chart C</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-003.jpg"/></imageobject></mediaobject><caption><para>Flow chart C: Fields of an object.</para></caption></figure><para>C1. The WOX serializer considers the following as primitive data types: <code>byte</code>, <code>short</code>, 
      <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code>.</para><para>C2. In this case stringable objects are treated as fields of a parent object. A stringable object is not labeled 
      as object when it is the field of another object (observe that it also lacks of the id attribute). This aims to have 
      a more compact encoding.</para><para>C3. An example of the XML generated for a field of an object is shown below. The field is an object of type 
      <code>ser.Person</code>, which also has two more fields: <code>name</code> of type <code>string</code>, and 
      <code>age</code> of type <code>int</code>.
<programlisting xml:space="preserve">&lt;field name="fieldName"&gt;
   &lt;object type="ser.Person" id="9"&gt;
      &lt;field name="name" type="string" value="Carlos" /&gt;
      &lt;field name="age" type="int" value="30" /&gt;
   &lt;/object&gt;
&lt;/field&gt;</programlisting>
    </para></section><section><title>WOX XML Representation</title><para>In this section we will introduce the data type mapping 
      table used by WOX, and show the XML representation of different types of WOX objects: simple objects with primitive types, 
      uni-dimensional primitive arrays, multi-dimensional primitive arrays, object arrays, lists, maps, and user-defined 
      objects (which also have fields with different types of objects).</para><section><title>Data Type Mapping Table</title><para>Table 1 shows the data type mapping used in WOX with the Java and C# programming languages. The 
        first column shows the data types used in WOX, and the second and third columns represent the 
        corresponding data types in Java and C#, respectively.</para><table><caption><para>Data type mapping between WOX, Java and C#</para></caption><col align="right" valign="top" span="1"/><col valign="top" span="1"/><col align="center" valign="top" span="1"/><thead><tr valign="top"><th>WOX</th><th>Java</th><th>C#</th></tr></thead><tbody><tr valign="top"><td>byte</td><td>byte/Byte</td><td>sbyte (SByte)</td></tr><tr valign="top"><td>short</td><td>short/Short</td><td>short (Int16)</td></tr><tr valign="top"><td>int</td><td>int/Int</td><td>int (Int32)</td></tr><tr valign="top"><td>long</td><td>long/Long</td><td>long (Int64)</td></tr><tr valign="top"><td>float</td><td>float/Float</td><td>float (Single)</td></tr><tr valign="top"><td>double</td><td>double/Double</td><td>double (Double)</td></tr><tr valign="top"><td>char</td><td>char/Character</td><td>char (Char)</td></tr><tr valign="top"><td>boolean</td><td>boolean/Boolean</td><td>bool (Bool)</td></tr><tr valign="top"><td>string</td><td>String</td><td>string (String)</td></tr><tr valign="top"><td>object</td><td>Object</td><td>object (Object)</td></tr><tr valign="top"><td>array</td><td>Any Array</td><td>Any Array</td></tr><tr valign="top"><td>list</td><td>ArrayList</td><td>ArrayList</td></tr><tr valign="top"><td>map</td><td>HashMap</td><td>Hashtable</td></tr><tr valign="top"><td>class</td><td>Class</td><td>Type</td></tr></tbody></table><para>The WOX serializer produces the same XML representation for any object, provided that their fields
        are only the Java and C# data types listed in Table 1, or any nested objects of user-defined classes which 
        have fields of those data types. This also includes the list and map data types from the collection APIs 
        of both programming languages.</para></section><section><title>Simple object with primitive types</title><para>In this subsection we illustrate the XML representation of WOX primitive types, which include: 
        <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, 
        <code>double</code>, <code>char</code>, and <code>boolean</code>. The complete list of the data types 
        supported by WOX is shown in Table 1.</para><para><xref linkend="FigProductClass"/> shows the <code>Product</code> class, which has five fields of primitive types: <code>name</code> 
        of type <code>string</code>, <code>price</code> of type <code>double</code>, <code>grams</code> of type 
        <code>int</code>, <code>reg</code> of type <code>boolean</code>, and <code>categ</code> of type <code>char</code>.</para><figure xml:id="FigProductClass"><title>Product class</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-004.jpg"/></imageobject></mediaobject><caption><para>Product class with primitive fields.</para></caption></figure><para>The XML representation in WOX of a <code>Product</code> object is shown below. The XML is simple and clean.     
<programlisting xml:space="preserve">&lt;object type="Product" id="0"&gt;
   &lt;field name="name" type="string" value="Corn" /&gt;
   &lt;field name="price" type="double" value="3.98" /&gt;
   &lt;field name="grams" type="int" value="500" /&gt;
   &lt;field name="reg" type="boolean" value="true" /&gt;
   &lt;field name="categ" type="char" value="\u0041" /&gt;
&lt;/object&gt;</programlisting>      
      </para><para>The root of the XML document is an <code>object</code> element, with its <code>type</code> attribute 
        equals <code>Product</code>, which is the class of the object. The <code>id</code> attribute is used to handle 
        object references (in this case we only have one object - the <code>product</code> object). Every field in the 
        <code>product</code> object is represented by <code>field</code> elements, which have the following attributes: 
        <code>name</code> (the name of the field in the class), <code>type</code> (the WOX data type of the field), 
        and <code>value</code> (the value of the field for that particular object). Primitive types are represented in 
        WOX as <code>field</code> elements.</para><para>Observe that the <code>categ</code> field is of type <code>char</code>. WOX data type <code>char</code> 
        is represented as a Unicode value.</para></section><section><title>Uni-dimensional primitive arrays</title><para>Uni-dimensional primitive arrays contain primitives as their elements. Primitives include the following 
        data types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, 
        <code>double</code>, <code>char</code>, and <code>boolean</code>. For a complete list of the data types supported 
        by WOX see the Data types mapping table.</para><para>Primitive arrays are treated differently from other arrays, because they are serialized in a very efficient way. 
        We will show two examples of the XML representation for primitive arrays. The first one is a stand-alone array, 
        in which the array itself is the root object. In the second example, the primitive array is part of an object (it 
        is declared as a field in a class).</para><para>The XML representation of a stand-alone primitive array is shown below. The XML is simple and efficient. The 
        root is an <code>object</code> element, with its <code>type</code> attribute equals <code>array</code>, which 
        indicates that the object represented in this case is an array. The <code>elementType</code> attribute provides the 
        data type of the primitive array, and the <code>length</code> attribute indicates the number of elements in the array. 
        The <code>id</code> attribute is used to handle object references (in this example we only have one object - the 
        array itself). The elements of the array are separated by spaces, and presented as only one string.
<programlisting xml:space="preserve">&lt;object type="array" elementType="double" length="5" id="0"&gt;
   12.45 878.98 987.98 435.87 537.87
&lt;/object&gt;</programlisting>
      </para><para>The XML representation of an object that contains three uni-dimensional primitive arrays as fields is shown 
        below. The primitive arrays are declared as fields of the <code>TestArray</code> class, which is illustrated in 
        <xref linkend="FigTestArrayClass"/>.</para><figure xml:id="FigTestArrayClass"><title>TestArray class</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-005.jpg"/></imageobject></mediaobject><caption><para>TestArray class with three primitive array.</para></caption></figure><para>In this case, the arrays are not root objects, but they are now fields of the root object. The <code>codes</code> 
        field is a primitive array of <code>char</code> elements, the <code>values</code> field is a primitive array of 
        <code>int</code> elements, and the <code>answers</code> field is a primitive array of <code>boolean</code> elements. 
        It should be noticed that arrays are also objects with their <code>type</code> attribute equals <code>array</code>.
<programlisting xml:space="preserve">&lt;object type="TestArray" id="0"&gt;
   &lt;field name="codes"&gt;
      &lt;object type="array" elementType="char" length="5" id="1"&gt;
         \u0065 \u0074 \u0072 \u0067 \u0077
      &lt;/object&gt;
   &lt;/field&gt;
   &lt;field name="values"&gt;
      &lt;object type="array" elementType="int" length="5" id="2"&gt;
         23 56 78 33 69
      &lt;/object&gt;
   &lt;/field&gt;
   &lt;field name="answers"&gt;
      &lt;object type="array" elementType="bool" length="5" id="3"&gt;
         true false true false false
      &lt;/object&gt;
   &lt;/field&gt;
&lt;/object&gt;</programlisting>
      </para><para>The root is an <code>object</code> element, with the <code>type</code> attribute equals <code>TestArray</code>, 
        which is the class of the root object. The root element has three field elements as children, which correspond to 
        the three primitive arrays. Each array is a field of the root object, and they are treated as <code>object</code> 
        elements, with <code>type</code>, <code>elementType</code>, <code>lenght</code>, and <code>id</code> attributes. The 
        elements of each array are separated by spaces and written as one simple string.</para></section><section><title>Multi-dimensional primitive arrays</title><para>Multi-dimensional primitive arrays can also be serialized as stand-alone arrays, or as part of an object. Below 
        we show the XML representation of an object of the <code>TestMultiArray</code> class. The <code>TestMultiArray</code>
        class, which is illustrated in <xref linkend="FigTestMultiArrayClass"/>, has one bi-dimensional array of <code>int</code> elements as its field.
<programlisting xml:space="preserve">&lt;object type="TestMultiArray" id="0"&gt;
   &lt;field name="matrix"&gt;
      &lt;object type="array" elementType="int[]" length="3" id="1"&gt;
         &lt;object type="array" elementType="int" length="5" id="2"&gt;23 56 89 36 68&lt;/object&gt;
         &lt;object type="array" elementType="int" length="4" id="3"&gt;87 64 88 32&lt;/object&gt;
         &lt;object type="array" elementType="int" length="6" id="4"&gt;78 80 21 29 34 67&lt;/object&gt;
      &lt;/object&gt;
   &lt;/field&gt;
&lt;/object&gt;</programlisting>
      </para><figure xml:id="FigTestMultiArrayClass"><title>TestMultiArray class</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-006.jpg"/></imageobject></mediaobject><caption><para>TestMultiArray class with one multi-dimensional primitive array as field.</para></caption></figure><para>We can observe that the root is an <code>object</code> element, with its <code>type</code> attribute equals 
        <code>TestMultiArray</code>, which is the class of the root object. The root element has only one child: a 
        <code>field</code> element, which is a bi-dimensional primitive array. Since this is a bi-dimensional array, it 
        is actually serialized as an array of arrays. It is an array of three elements of type <code>int[]</code>, where 
        every element is an array of type <code>int</code>. The first array has five elements, the second array has four 
        elements, and the last array has six elements. The elements of each array are separated by spaces and presented 
        as one simple string.</para><para>It should be noted that every <code>object</code> element has an <code>id</code> attribute, which is used to 
        handle object references. Arrays of more than two dimensions (multi-dimensional) are represented in XML following the 
        same idea shown in this subsection.</para></section><section><title>Object arrays</title><para>The main difference between primitive arrays and object arrays is that the elements in primitive arrays are 
        serialized to a simple string with spaces to separate each element; whereas in object arrays their elements are 
        treated as individual and separate objects.</para><para>Object arrays can also be uni-dimensional or multi-dimensional, just like primitive arrays. We will only illustrate 
        the XML representation of a uni-dimensional object array. We will use the <code>Product</code> class shown previously 
        in <xref linkend="FigProductClass"/>. The XML representation of an array with three <code>Product</code> objects is 
        shown below.
<programlisting xml:space="preserve">&lt;object type="array" elementType="Product" length="3" id="0"&gt;
   &lt;object type="Product" id="1"&gt;
      &lt;field name="name" type="string" value="Beans" /&gt;
      &lt;field name="price" type="double" value="1.75" /&gt;
      &lt;field name="grams" type="int" value="250" /&gt;
      &lt;field name="reg" type="boolean" value="true" /&gt;
      &lt;field name="categ" type="char" value="\u0042" /&gt;
   &lt;/object&gt;
   &lt;object type="Product" id="2"&gt;
      &lt;field name="name" type="string" value="Rice" /&gt;
      &lt;field name="price" type="double" value="3.89" /&gt;
      &lt;field name="grams" type="int" value="750" /&gt;
      &lt;field name="reg" type="boolean" value="true" /&gt;
      &lt;field name="categ" type="char" value="\u0052" /&gt;
   &lt;/object&gt;
   &lt;object type="Product" id="3"&gt;
      &lt;field name="name" type="string" value="Bread" /&gt;
      &lt;field name="price" type="double" value="1.06" /&gt;
      &lt;field name="grams" type="int" value="300" /&gt;
      &lt;field name="reg" type="boolean" value="false" /&gt;
      &lt;field name="categ" type="char" value="\u0048" /&gt;
   &lt;/object&gt;
&lt;/object&gt;</programlisting>
      </para><para>The root is an <code>object</code> element, which is the array of three <code>Product</code> objects. 
        The <code>elementType</code> attribute specifies the date type of the array, and the <code>length</code> attribute 
        indicates the number of elements in the array.</para><para>Each <code>product</code> in the array has <code>type</code> and <code>id</code> attributes, and five <code>field</code> 
        elements (children) to represent the five fields in a <code>Product</code> object: <code>name</code>, <code>price</code>, 
        <code>grams</code>, <code>reg</code>, and <code>categ</code>. Every <code>field</code> element specifies the <code>name</code>, 
        <code>type</code>, and <code>value</code> attributes.</para></section><section><title>Lists</title><para><code>Lists</code> are similar to arrays in WOX. A <code>List</code> in WOX is the equivalent to 
        <code>java.util.ArrayList</code> in Java, and <code>System.Collections.ArrayList</code> in C#, as can be seen in Table 1 
        previously shown. A <code>List</code> in WOX is represented in a simple form, and can be de-serialized either to Java or C#.</para><para>The XML representation of a list of <code>Course</code> objects is shown below. The <code>Course</code> class, which is 
        illustrated in <xref linkend="FigCourseClass"/>, has three fields: <code>code</code> of type <code>int</code>, <code>name</code> of type 
        <code>string</code>, and <code>term</code> of type <code>int</code>.
<programlisting xml:space="preserve">&lt;object type="list" elementType="Object" length="3" id="0"&gt;
   &lt;object type="Course" id="1"&gt;
      &lt;field name="code" type="int" value="6756" /&gt;
      &lt;field name="name" type="string" value="XML" /&gt;
      &lt;field name="term" type="int" value="3" /&gt;
   &lt;/object&gt;
   &lt;object type="Course" id="2"&gt;
      &lt;field name="code" type="int" value="9865" /&gt;
      &lt;field name="name" type="string" value="DB" /&gt;
      &lt;field name="term" type="int" value="2" /&gt;
   &lt;/object&gt;
   &lt;object type="Course" id="3"&gt;
      &lt;field name="code" type="int" value="1134" /&gt;
      &lt;field name="name" type="string" value="Java" /&gt;
      &lt;field name="term" type="int" value="2" /&gt;
   &lt;/object&gt;
&lt;/object&gt;</programlisting>
      </para><figure xml:id="FigCourseClass"><title>Course class</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-007.jpg"/></imageobject></mediaobject><caption><para>Course class with three fields.</para></caption></figure><para>The root is an <code>object</code> element, which represents the list of three <code>Course</code> objects. Each 
        <code>course</code> has its <code>type</code>, and <code>id</code> attributes, and its three <code>field</code> elements 
        (children): <code>code</code>, <code>name</code>, and <code>term</code>. Every <code>field</code> element specifies its 
        <code>name</code>, <code>type</code>, and <code>value</code> attributes.</para></section><section><title>Maps</title><para>A <code>Map</code> is an object that maps keys to values. A map cannot contain duplicate keys, and each key can map 
        to at most one value. A <code>Map</code> in WOX is the equivalent to <code>java.util.HashMap</code> in Java, and 
        <code>System.Collections.Hashtable</code> in C#, as can be seen in Table 1 previously shown. A <code>Map</code> in WOX 
        is represented in a simple form, and can be de-serialized either to Java or C#.</para><para>The XML representation of a map of <code>Course</code> objects is shown below. The <code>Course</code> class, 
        which is illustrated in <xref linkend="FigCourseClass"/>, has three fields: <code>code</code> of type <code>int</code>, <code>name</code> of type 
        <code>string</code>, and <code>term</code> of type <code>int</code>.
<programlisting xml:space="preserve">&lt;object type="map" id="0"&gt;
   &lt;object type="entry"&gt;
      &lt;object type="int" value="1134" id="1" /&gt;
      &lt;object type="Course" id="2"&gt;
         &lt;field name="code" type="int" value="1134" /&gt;
         &lt;field name="name" type="string" value="Java"/&gt;
         &lt;field name="term" type="int" value="2" /&gt;
      &lt;/object&gt;
   &lt;/object&gt;
   &lt;object type="entry"&gt;
      &lt;object type="int" value="6756" id="3" /&gt;
      &lt;object type="Course" id="4"&gt;
         &lt;field name="code" type="int" value="6756" /&gt;
         &lt;field name="name" type="string" value="XML" /&gt;
         &lt;field name="term" type="int" value="3" /&gt;
      &lt;/object&gt;
   &lt;/object&gt;
   &lt;object type="entry"&gt;
      &lt;object type="int" value="9865" id="5" /&gt;
      &lt;object type="Course" id="8"&gt;
         &lt;field name="code" type="int" value="9865" /&gt;
         &lt;field name="name" type="string" value="DB" /&gt;
         &lt;field name="term" type="int" value="2" /&gt;
      &lt;/object&gt;
   &lt;/object&gt;
&lt;/object&gt;</programlisting>
      </para><para>The root is an <code>object</code> element, which is the map of four <code>entry</code> objects. Each 
        <code>entry</code> object has two children: the first object represents the key, and the second object is the value 
        associated with that key. The <code>key</code> is an object of type <code>int</code>, and the <code>value</code> is an 
        object of type <code>Course</code>. The XML representation of a <code>Course</code> object was previously explained.</para></section><section><title>Object references</title><para>In order to avoid duplicate objects in the XML representation of an object, the WOX serializer uses object references, 
        which are handled by using id and idref attributes. <xref linkend="FigReferences"/> shows an array of <code>Product</code> 
        objects with duplicates.</para><figure xml:id="FigReferences"><title>Object references</title><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol7/graphics/Jaimez01/Jaimez01-008.jpg"/></imageobject></mediaobject><caption><para>Array of Product objects with duplicates.</para></caption></figure><para>The use of object references in the XML representation of this array of <code>Product</code> objects is illustrated 
        below. The <code>Product</code> class was introduced previously, which has five attributes: <code>name</code> 
        of type <code>string</code>, <code>price</code> of type <code>double</code>, <code>grams</code> of type <code>int</code>, 
        <code>reg</code> of type <code>boolean</code>, and <code>categ</code> of type <code>char</code>.
<programlisting xml:space="preserve">&lt;object type="array" elementType="Product" length="6" id="0"&gt;
   &lt;object type="Product" id="1"&gt;
      &lt;field name="name" type="string" value="Beans" /&gt;
      &lt;field name="price" type="double" value="1.75" /&gt;
      &lt;field name="grams" type="int" value="250" /&gt;
      &lt;field name="reg" type="bool" value="true" /&gt;
      &lt;field name="categ" type="char" value="\u0042" /&gt;
   &lt;/object&gt;
   &lt;object type="Product" id="2"&gt;
      &lt;field name="name" type="string" value="Rice" /&gt;
      &lt;field name="price" type="double" value="3.89" /&gt;
      &lt;field name="grams" type="int" value="750" /&gt;
      &lt;field name="reg" type="bool" value="true" /&gt;
      &lt;field name="categ" type="char" value="\u0052" /&gt;
   &lt;/object&gt;
   &lt;object idref="1" /&gt;
   &lt;object type="Product" id="3"&gt;
      &lt;field name="name" type="string" value="Bread" /&gt;
      &lt;field name="price" type="double" value="1.06" /&gt;
      &lt;field name="grams" type="int" value="300" /&gt;
      &lt;field name="reg" type="bool" value="false" /&gt;
      &lt;field name="categ" type="char" value="\u0048" /&gt;
   &lt;/object&gt;
   &lt;object idref="3" /&gt;
   &lt;object idref="1" /&gt;
&lt;/object&gt;</programlisting>
      </para><para>The duplicated <code>Product</code> objects in the array are not duplicated in the XML representation that WOX 
        generates. They are referenced by using the <code>idref</code> attribute, which actually refers to the unique 
        <code>id</code> given to every object. It can be observed that the XML representation of the array has the three 
        object references for the duplicated objects (two for product <code>p1</code> identified by <code>id="1"</code>, 
        and one for product <code>p3</code>, identified by <code>id="3"</code>.</para></section></section><section><title>Conclusions and Further Work</title><para>In this paper we have presented Web Objects in XML (WOX), an efficient and easy to use XML serializer for 
      interoperability between the C# and Java programming languages. The WOX serializer is a stand-alone library based on XML 
      which is able to serialize Java and C# objects to XML and back again. One of its main features is the generation of standard 
      XML, which is language independent. This means that if we serialize a Java object to XML, we could take the generated XML 
      to reconstruct the object back to C#; and viceversa. Our serialization approach does not need code annotations or any other 
      type of configuration from the user in order to serialize objects.</para><para>We have made our WOX serializer publicly available as an open-source project, which can be downloaded from 
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://woxserializer.sourceforge.net/</link>. As a consequence of this work, 
      the MSDN Magazine (a Microsoft Magazine) published an article, in its October 2010 issue [Khan 2010], about interoperability between 
      Java and .NET, where they mention and recommend the use of our work for interoperability between applications. We consider this as a 
      valuable example that demonstrates that our work has had an impact on the MSDN community.</para><para>In this paper we described the main features and uses of the WOX serializer, and we also dedicated a section to give its implementation
      details. We showed the XML representation for the most representative structures and objects in both Java and C#, along with 
      some examples. We believe that the XML object representation that WOX uses is efficient, clean, easy to understand, and can 
      represent objects in other object-oriented programming languages. Further work is needed to develop our XML serializer in other 
      object-oriented programming languages, and allow interoperability among them. We have already started our analysis to develop 
      a WOX serializer for the C++ object-oriented programming language.</para></section><bibliography><title>Bibliography</title><bibliomixed xml:id="mul301" xreflabel="Castor 2010">Castor. The Castor Project, 2010, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.castor.org/</link>.</bibliomixed><bibliomixed xml:id="mul302" xreflabel="SOAP 2003">WWW Consortium. Latest SOAP Versions, 2003, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/tr/soap/</link>.</bibliomixed><bibliomixed xml:id="mul303" xreflabel="Jaimez 2007">Jaimez, C., Lucas, S., Implementing a State-based Application Using Web Objects in XML,
       In Proceedings of the 9th International Symposium on Distributed Objects, Middleware, and Applications (DOA 2007), 
       Lecture Notes in Computer Science, Volume 4803/2007, pp. 577-594, 
       Vilamoura, Algarve, Portugal, 25-30 November 2007, available at
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.springerlink.com/content/u842871w0l551002/</link>.</bibliomixed><bibliomixed xml:id="mul304" xreflabel="Jaimez 2011">Jaimez, C., Lucas, S., Interoperability of Java and C# with Web Objects in XML,
       In Proceedings of the IADIS International Conference e-Society (ES 2011), pp. 518-522, 
       Avila, Spain, 10-13 March 2011, available at
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.iadisportal.org/e-society-2011-proceedings</link>.</bibliomixed><bibliomixed xml:id="mul305" xreflabel="JAXB 2010">JAXB: The Java Architecture for XML Binding, 2010, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">https://jaxb.dev.java.net/</link>.</bibliomixed><bibliomixed xml:id="mul306" xreflabel="JSX 2002">JSX: Java Serialization to XML, 2002, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://jsx.org/</link>.</bibliomixed><bibliomixed xml:id="mul307" xreflabel="Khan 2010">Khan, I., Interoperability: Runtime Data Sharing Through an Enterprise Distributed Cache, 
       MSDN Magazine, October 2010, available at <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://msdn.microsoft.com/en-us/magazine/gg232763.aspx</link>.</bibliomixed><bibliomixed xml:id="mul308" xreflabel="Koala 1998">Koala XML serialization, 1998, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://old.koalateam.com/xml/serialization/</link>.</bibliomixed><bibliomixed xml:id="mul309" xreflabel="Winer 1999">Winer D. XML-RPC specification, 1999, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.xmlrpc.com/spec</link>.</bibliomixed><bibliomixed xml:id="mul310" xreflabel="XMOP 2000">XMOP: XML Metadata Object Persistence, 2000, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.openhealth.org/documents/xmop.htm/</link>.</bibliomixed><bibliomixed xml:id="mul311" xreflabel="XStream 2010">XStream: A Java Library to Serialize Objects to XML, 2010, available at 
       <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://xstream.codehaus.org/index.html/</link>.</bibliomixed></bibliography></article>