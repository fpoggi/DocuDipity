<?xml version="1.0" encoding="UTF-8"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0-subset Balisage-1.2" xml:id="Bal2008poul0610"><title>Properties of schema mashups: dynamicity, semantic, mixins, hyperschemas</title><info><confgroup><conftitle>Balisage: The Markup Conference 2008</conftitle><confdates>August 12 - 15, 2008</confdates></confgroup><abstract><para>W3C XML Schemas specifications were published in 2001, but a large community still uses DTDs.
Perhaps they didn't adopt new schema technologies because they are still awaiting some missing features ?
What kind of feature would be useful to DTD users and schema practitioners ?</para><para>Let's transpose the buzzword "mashups" to schema technologies: mashups of several schema languages and mashups of schema languages with non-schema languages.
From this bazaar, we'll discuss some of the emerging features that could make what would be the next generation of schema languages:
dynamicity, semantic, mixins, and hyperschemas.</para></abstract><author><personname><firstname>Philippe</firstname><surname>Poulard</surname></personname><personblurb><para>Philippe Poulard is a software engineer at INRIA (french national institute for
research in computer science and control) where he is involved in Web-oriented
problematics. He has been specialized in XML technologies and e-documentation
for 10 years. During this period, he has developed XML and SGML-based solutions
and prototypes on behalf of the French Army and INRIA. More recently he has
designed and implemented a set of XML technologies named "Active Tags"
(http://ns.inria.org/active-tags/). He also teaches
XML and Java at Nice/Sophia-Antipolis university and Aix/Marseille university.
He has an engineer degree (M.Sc) from the Conservatoire National des Arts et
Metiers.</para></personblurb><affiliation><orgname>INRIA</orgname></affiliation><email>philippe.poulard@sophia.inria.fr</email></author><legalnotice><para>Copyright Â© 2008 Philippe Poulard. Used by permission.</para></legalnotice><keywordset role="author"><keyword>Schemas</keyword><keyword>Active Tags</keyword><keyword>Active Schema Language</keyword><keyword>Active Catalog</keyword><keyword>W3C XML Schema</keyword><keyword>Relx NG</keyword><keyword>Schematron</keyword><keyword>DTD</keyword><keyword>Hyperschema</keyword><keyword>data types</keyword></keywordset></info><section><title>Introduction</title><para>The <xref linkend="WXS-11"/> specification is in a "last call working draft" status.
One of the most significant change is perhaps the support of co-occurrence constraints that was missing in 1.0 and expected by the community.
For the other missing stuffs -who knows what they are- we have to wait for W3C XML Schema 1.2 and so on.
In this paper, we'll have a prospective approach: we examine some features that the author has already implemented as a demonstration,
and imagine others that lead us to consider new usages of schema technologies.</para><para>For this purpose, we introduce an experimental but innovative schema technology: the Active Schema Language, or <xref linkend="ASL"/>.
The strength of ASL comes from its runtime environment: the <xref linkend="ActiveTags"/> engine that was presented last year at Extreme Markup Languages in Montreal (<xref linkend="Poulard"/>).
Active Tags can host several runnable tag libraries and a schema language like ASL is just another library like other tag libraries,
but built on top of this framework that offers to ASL lots of valuable services that make it much more simple, powerful and expressive than
the serie of W3C XML Schema 1.x as well as other schema technologies.</para><para>Firstly, we will expose the foundations of the system. In the next chapters, we will explore 4 simple use cases:</para><itemizedlist><listitem><para>Since an Active Tags engine can make cohabit several tag libraries, even declarative languages like schema languages,
we'll see hereafter how to design a schema that can build dynamically its content models (named active content model)
by interweaving imperative instructions with declarative ones, in order to solve issues that other schema technologies can't address.</para></listitem><listitem><para>Next, we'll focus on XML data types and the lack of support of semantic data types in schema languages.
A simple example will show how ASL can define simply such a data type, and the advantage got for applications that have to deal with XML datas.</para></listitem><listitem><para>We'll go on with the concept of mixins (borrowed to other kind of languages) adapted to schema languages.
Here, we'll mix several schema technologies for extending an attribute definition of a DTD with a data type (other than CDATA, of course).</para></listitem><listitem><para>Finally, we'll discuss about the validation of software components represented with declarative XML languages.
Although schemas languages can validate the static representation of an assembly of components, they are not designed to validate pieces of components assembled at runtime.
An hyperschema would act at this higher level.</para></listitem></itemizedlist><para>We will conclude that designing XML languages in a framework such as Active Tags is extremely valuable.
Even (or especially) for declarative languages such as ASL.</para></section><section><title>Foundations of the system</title><para>In this section, we present an overview of the system and its basic functioning.</para><para>Basically, an <xref linkend="XSLT"/> processor or a schema validator are doing the same things:
first, since they are languages that rely on XML, instances are parsed, then unmarshalled
to instances of some classes and assembled, and finally processed according to the intended
semantic of the tags encountered. This is where the differences occurs.
Processing those steps in a pipeline mode or generating some code in a target language are only implementation details.
We can simply consider XSLT, <xref linkend="WXS"/>, <xref linkend="RelaxNG"/>, <xref linkend="SCXML"/>, <xref linkend="XMLCatalogs"/>
and other markup languages designed for processing purpose as tag libraries,
but none of them rely on a common system.
Yet, some systems are based on tag libraries such as <xref linkend="JSP"/>/<xref linkend="JSTL"/> and <xref linkend="Jelly"/> but the former
is runnable exclusively within a Web server and both are very far from XML problematics: for example, instead of using XPath
they rely on the <xref linkend="UEL"/> and are tightly coupled to Java.</para><para>Active Tags is a system that considers that XML languages designed for processing purpose like those mentionned are tag libraries
runnable in an XML-based environment.
Active Tags offers to runnable XML languages a set of basic services such as handling XML datas
and non-XML datas with <xref linkend="XPath"/>, using templates, defining macros, and mapping tags to their
implementations. This allows a programmer to focus on its implementation without worrying about the plumbing details.</para><para>In the same way that XSLT scripts are called "<emphasis>stylesheets</emphasis>", Active Tags ones are called "<emphasis>active sheets</emphasis>".
Like XSLT, it is XPath centric, and <emphasis>active sheets</emphasis> will contain both instructions (the so-called <emphasis>active tags</emphasis>) and XML litterals.
The main difference is that instead of having a single instruction set, an <emphasis>active sheet</emphasis> may contain severals, each bound to a namespace URI.
One of the core module of the system is the XML Control Language, or <xref linkend="XCL"/>, that supplies a set of tags that covers many common features:</para><itemizedlist><listitem><para>Usual control structure actions, such as alternative (<code>&lt;xcl:if&gt;</code> <code>&lt;xcl:then&gt;</code> <code>&lt;xcl:else&gt;</code>)
    or iterative actions (<code>&lt;xcl:for-each&gt;</code>).</para></listitem><listitem><para>XML oriented actions, such as XML parsing (<code>&lt;xcl:parse&gt;</code>) and XSLT transforming (<code>&lt;xcl:parse-stylesheet&gt;</code> and <code>&lt;xcl:transform&gt;</code>);
    these actions deal with entity and URI resolving, passing parameters (<code>&lt;xcl:param&gt;</code>),
    error handling and many other options used to tune XML processes.</para></listitem><listitem><para>XML document creation (<code>&lt;xcl:document&gt;</code>, <code>&lt;xcl:element&gt;</code>, <code>&lt;xcl:attribute&gt;</code> etc)
    and high level Active Update implementation, that allow to perform update operations on XML objects and X-operable objects<footnote><para>X-operable objects are objects that are exposing their inherent properties as XML properties (name, attributes, children, parent...) and can be processed
    with XML-related operations and traversed with XPath. For example, one can apply <code>//*</code> on a directory of a file system
    to get all the files and directories under the tree.</para></footnote>
    (<code>&lt;xcl:delete&gt;</code>, <code>&lt;xcl:append&gt;</code>, <code>&lt;xcl:update&gt;</code> etc).</para></listitem></itemizedlist><para>The reader is sent back to <xref linkend="RefleX"/>, a Java implementation of Active Tags,
where numbers examples are available and runnable. RefleX supplies a command line interface and
a servlet, and offer means to query relational databases with SQL, XML databases with <xref linkend="XQuery"/>, or LDAP repositories.
Moreover, he will find in RefleX all the standard modules that go along with Active Tags (I/O, System, Web, etc) and specific modules
for designing XML-based test suites (<xref linkend="XUnit"/>) and test suites for Web applications (<xref linkend="WUnit"/>).</para><para>In this first example, XCL is used in a sequence of three operations for parsing a file and transforming it with XSLT:</para><programlisting xml:space="preserve">
&lt;xcl:active-sheet xmlns:xcl="http://ns.inria.org/active-tags/xcl"&gt;
    &lt;xcl:parse name="input" source="file:///path/to/document.xml"/&gt;
    &lt;xcl:parse-stylesheet name="xslt" source="file:///path/to/stylesheet.xsl"/&gt;
    &lt;!--XPath expressions appear in curly braces--&gt;
    &lt;xcl:transform output="file:///path/to/result.html" source="{ $input }"
    stylesheet="{ $xslt }"/&gt;
&lt;/xcl:active-sheet&gt;</programlisting><para><emphasis>Active sheets</emphasis> can use a single module (like above) or several ones, can be procedural (like above once again) or declarative or both like we'll see in the next section.</para><para>Other core modules include means to bind an implementation to an active tag (i.e. which is not an XML litteral):</para><programlisting xml:space="preserve">
    &lt;!--bind a Java class to an active tag of the XCL module--&gt;
    &lt;exp:element name="xcl:transform"
    source="res:org.inria.ns.reflex.processor.xcl.TransformAction"/&gt;
    &lt;!--the "res" URI scheme refers to resources found in the classpath;
            this is specific to the RefleX implementation in Java--&gt;
</programlisting><para>...and means to lookup for resources such as the actual modules:</para><programlisting xml:space="preserve">
    &lt;!--declare 2 entries related to XCL in the main catalog--&gt;
    &lt;cat:group xml:base="res:///org/inria/ns/reflex/processor/"&gt;
        &lt;!--where to find the XCL module--&gt;
        &lt;cat:resource name="http://ns.inria.org/active-tags/xcl" uri="xcl/module.exp"
        selector="exp:module"/&gt;
        &lt;!--where to find the XCL schema--&gt;
        &lt;cat:resource name="http://ns.inria.org/active-tags/xcl" uri="xcl/schema.asl"
        selector="asl:schema"/&gt;
    &lt;/cat:group&gt;</programlisting><para>When an <emphasis>active sheet</emphasis> is launched, the engine will look in the main catalog (and custom catalogs if any)
if there is a module for each XML tag it encounters, and load the implementation provided by the relevant module, otherwise the actual tag
stands for a litteral.</para><para>The so-called <xref linkend="ActiveCatalog"/> used in Active Tags like shown above is a compatible extension to OASIS XML Catalog: the former is designed
to retrieve resources whereas the latter just to map an URI to another URI. When the engine launches a "module request", the reference specified by the entry in the catalog, tagged with the
appropriate role (<code>selector="exp:module"</code>), will be unmarshalled to the relevant component (the module expected).</para><para>Other core modules and custom modules can be declared and registered to the engine as well.
So far, nothing about schemas were mentionned; in the same way, there is a module definition for ASL
that bind ASL elements to their implementation, and an entry in the main catalog so that ASL is ready to use
by the engine. Therefore, we are able to design schema instances with ASL, and write <emphasis>active sheets</emphasis>
for validating XML instances with our schema. We'll see hereafter how to combine XCL and ASL to express dynamic content models in a schema.</para></section><section><title>Dynamicity, or building active content models</title><para>Schema processors are building an abstract tree from a schema instance. With a traditional grammar-based schema (DTD, W3C XML Schema, Relax NG),
as the schema instance is hard-coded, the abstract tree is static, making the expressiveness of the schema limited to what is allowed by the grammar.
The flaw with grammars in XML is that they only allow to constraint content models in a declarative manner,
which is in essence very concise and expressive, but when the limits of the declarative syntax are reached, there is no way out;
it is still possible to add a new tag to express the missing declarative tag, but the limit still exists a single step further, at the cost of upgrading the language.</para><para>ASL has been designed in order to be much more expressive without adding tags again and again.
The immediate benefit is to avoid to compromise a user's XML structure just because some constraints can't be expressed by grammar-based schemata,
which happens often with traditional schema languages.
ASL contains similar constructs than others schema languages: an element declaration is still made of sequences (<code>&lt;asl:sequence&gt;</code>) or choices
(<code>&lt;asl:choice&gt;</code>) of element references (<code>&lt;asl:element ref-name="..."&gt;</code>),
texts (<code>&lt;asl:text value="..."&gt;</code>) or attributes (<code>&lt;asl:attribute&gt;</code>), but they can be mixed with imperative constructs.
As the content models are computed at runtime while validating, the result abstract tree becomes dynamic,
increasing dramatically the expressiveness of the schema: the content models can adapt themselves to the incoming data to validate in an extreme flexible way.
Additionally, ASL allows to compute dynamically thanks to XPath expressions occurrence constraints, that are at best hard-coded in existing schema languages.</para><para>The following document is an instance of a purchase-order:</para><programlisting xml:space="preserve">
&lt;purchase-order
    xmlns="http://www.example.com/purchase-order"
    ship-date="2008-08-14"&gt;

  &lt;items total="188.93"&gt;

    &lt;item partNum="872-AA"&gt;
      &lt;productName&gt;Lawnmower&lt;/productName&gt;
      &lt;quantity&gt;1&lt;/quantity&gt;
      &lt;USPrice&gt;148.95&lt;/USPrice&gt;
    &lt;/item&gt;

    &lt;item partNum="926-AA"&gt;
      &lt;productName&gt;Baby Monitor&lt;/productName&gt;
      &lt;quantity&gt;1&lt;/quantity&gt;
      &lt;USPrice&gt;39.98&lt;/USPrice&gt;
    &lt;/item&gt;

    &lt;free-item partNum="261-ZZ"&gt;
      &lt;productName&gt;Kamasutra for dummies&lt;/productName&gt;
      &lt;quantity&gt;1&lt;/quantity&gt;
    &lt;/free-item&gt;

  &lt;/items&gt;

&lt;/purchase-order&gt;
</programlisting><para>It is constrained by structual rules and business rules, in the circumstances a <code>&lt;free-item&gt;</code> element is allowed only if the total amount exceeds 500$
(which makes the above document invalid).
Due to the lack of expressiveness of existing schema languages, the best we can do is to relax some constraints and ignore the business rule.
The content model of the <code>&lt;items&gt;</code> element would be expressed like this in a DTD:</para><programlisting xml:space="preserve">&lt;!ELEMENT items (item+,free-item?)&gt;</programlisting><para>Unfortunately, an instance like the previous one violates our business rule although it is valid regarding the DTD.
Other schema languages can't do much more better, except <xref linkend="Schematron"/> that we will talk about hereinafter.</para><para>ASL allows to write the business rule exactly as it has been expressed, by injecting imperative instructions from the XML Control Language within the content model definition:</para><programlisting xml:space="preserve">
&lt;asl:active-schema
    xmlns:xcl="http://ns.inria.org/active-tags/xcl"
    xmlns:asl="http://ns.inria.org/active-schema"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:po="http://www.example.com/purchase-order"
    target="po"
&gt;

  &lt;!--the root element of a purchase order--&gt;
  &lt;asl:element name="po:purchase-order" root="always"&gt;
    &lt;asl:attribute name="ship-date" type="xs:date"/&gt;
    &lt;asl:sequence&gt;
      &lt;asl:element ref-elem="po:items"/&gt;
    &lt;/asl:sequence&gt;
  &lt;/asl:element&gt;

  &lt;!--a dynamic content model--&gt;
  &lt;asl:element name="po:items" root="never"&gt;
    &lt;asl:attribute name="total" type="xs:decimal"/&gt;
    &lt;!--a variable sequence--&gt;
    &lt;asl:sequence&gt;
      &lt;asl:element
          ref-elem="po:item"
          min-occurs="1"
          max-occurs="unbounded"/&gt;
      &lt;!--the test that introduces variability
          asl:element() refers to the current element, actually a &lt;po:items&gt;--&gt;
      &lt;xcl:if test="{ asl:element()/@total &amp;gt; 500 }"&gt;
        &lt;xcl:then&gt;
          &lt;asl:element
              ref-elem="po:free-item"
              min-occurs="0"
              max-occurs="1"/&gt;
        &lt;/xcl:then&gt;
      &lt;/xcl:if&gt;
    &lt;/asl:sequence&gt;
  &lt;/asl:element&gt;

  &lt;asl:element name="po:item" root="never"&gt;
    &lt;!--content model here--&gt;
  &lt;/asl:element&gt;

  &lt;asl:element name="po:free-item" root="never"&gt;
    &lt;!--content model here--&gt;
  &lt;/asl:element&gt;

  &lt;!--other element definitions here--&gt;

&lt;/asl:active-schema&gt;
</programlisting><para>This schema demonstrates that an imperative operation is used to build the content model during the validation.
The content model of the <code>&lt;items&gt;</code> element will vary according to the total amount found in the incoming document.
Each of the "realizations" or "instanciations" of the element definition and illustrated by the picture below leads to a different abstract tree of the grammar.
But all are expressed in a single self-adaptative schema.
A program that would generate a schema wouldn't have the same expressiveness:
a content model designed on the fly won't necessary produce the same result each time it is traversed.
In fact, the system works like if it was a program that locally build fragments of content models while it is traversed during the validation.
The injection of imperative instructions doesn't change the nature of ASL which is declarative.</para><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol1/graphics/Poulard01/Poulard01-001.jpg" width="100%"/></imageobject></mediaobject><para>Schematron (as well as assertions in W3C XML Schema 1.1) is a technology that offers similar services;
however, there is a fundamental difference: Schematron act outside content models whereas ASL defines them.
Schematron will report constraints violations after grammar-based validation.
A tool such as an editor will propose to the user to insert a <code>&lt;free-item&gt;</code> whereas Schematron will reject it after the insertion !
ASL will introduce it in the content model only when the conditions are fulfilled, and the editor won't propose it to the user if it doesn't have to.</para><para>The reader is encouraged to experiment himself dynamic content models by referring to the RefleX web site:
for example how an algorithmic rule can act on a content model and other various use cases that are available in RefleX.</para></section><section><title>Semantic, or enhancing the meaning of data types</title><para><xref linkend="DTLL"/>, a language for the creation of data type libraries,
provides a rather good support for data types. But neither DTLL nor W3C XML Schema nor XML technologies in general
offer means to design semantic data types.
The semantic of a data type is related to its level of abstractions: <xref linkend="Murata"/> defines the following 4 models with different levels of abstractions (we add a 5th at the bottom):</para><itemizedlist><listitem><para>Model 4: semantic view: 68Â° Fahrenheit</para></listitem><listitem><para>Model 3: data type view: <code>#xs:decimal temp=68</code></para></listitem><listitem><para>Model 2: XML view:</para><mediaobject><imageobject><imagedata format="jpg" fileref="../../../vol1/graphics/Poulard01/Poulard01-002.jpg" width="80%"/></imageobject></mediaobject></listitem><listitem><para>Model 1: string view: <code>&lt;?xml version="1.0"?&gt;&lt;weather-report temp="68" unit="Â°F"&gt;</code></para></listitem><listitem><para>Model 0: byte view: <code>3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E 3D 22 31 2E 30 22 3F 3E 3C 77 65 61 74 68 65 72 2D 72 65 70 6F 72 74 20 74 65 6D 70 3D 22 36 38 22 20 75 6E 69 74 3D 22 B0 46 22 3E</code></para></listitem></itemizedlist><para>The Model 4 is of course the closest to the concerns of a human being. It is available for systems like Active Tags that can express reliationships between datas.</para><para>Unfortunately, XML technologies stop at Model 3, got thanks to a schema; what's happenned if we have to sort the following weather report by temperature ?</para><programlisting xml:space="preserve">
&lt;weather-report&gt;
    &lt;city name="Paris"  temp="19" unit="Â°C"/&gt;
    &lt;city name="Rome"   temp="22" unit="Â°C"/&gt;
    &lt;city name="Berlin" temp="32" unit="Â°F"/&gt;&lt;!-- 32Â°F = 0Â°C --&gt;
    &lt;city name="Madrid" temp="23" unit="Â°C"/&gt;
    &lt;city name="London" temp="68" unit="Â°F"/&gt;&lt;!-- 68Â°F = 20Â°C --&gt;
&lt;/weather-report&gt;
</programlisting><para>In Java, a simple class with a compator interface would convert the temperature units properly.
With XML technologies you won't be able to get the right result;
an inadmissible fact face to other technologies that are able to address this issue.
Actually, although there are classes of applications where XML is unmarshalled to objects of another language that takes the relay to address
this issue, other classes of applications that relies on the XML data model (<xref linkend="XDM"/>) such as XSLT and XQuery can't go without such data types<footnote><para>It might be possible to create the target XML result with XQuery, but not to operate the input XDM properly as expected
if it doesn't support such data types. Such a query would be like a procedure aside from the typed data, whereas ASL can define
a type where the datas and the behaviour are bundled together, like in OO designs.</para></footnote>.
The environment where typed datas are exposed in surface has to play a fundamental role: if OO languages are able to process them,
native XML languages (XSLT, XQuery, Active Tags) should support them as well.</para><para>The Active Schema Language supplies means to define data types.
As expected after validation, an <emphasis>active sheet</emphasis> will be able to process the actual typed datas.
With the help of XCL, we are able to augment the amount of informations of an XML document the way we like:</para><programlisting xml:space="preserve">
&lt;asl:active-schema
    xmlns:xcl="http://ns.inria.org/active-tags/xcl"
    xmlns:asl="http://ns.inria.org/active-schema"
    xmlns:xs="http://www.w3.org/2001/XMLSchema-datatypes"
    target=""
&gt;

  &lt;!--the root element of a weather report--&gt;
  &lt;asl:element name="weather-report" root="always"&gt;
    &lt;asl:sequence&gt;
      &lt;asl:element
          ref-elem="city"
          min-occurs="1"
          max-occurs="unbounded"/&gt;
    &lt;/asl:sequence&gt;
  &lt;/asl:element&gt;

  &lt;!--a &lt;city&gt; contains only attributes--&gt;
  &lt;asl:element name="city"&gt;
    &lt;asl:attribute name="name" ref-type="xs:string"/&gt;
    &lt;!--the @temp attribute refers to our custom type--&gt;
    &lt;asl:attribute name="temp" ref-type="temperature"/&gt;
    &lt;asl:attribute name="unit"&gt;
      &lt;asl:text value="Â°C"/&gt;
      &lt;asl:text value="Â°F"/&gt;
    &lt;/asl:attribute&gt;
  &lt;/asl:element&gt;

  &lt;!--#temperature is our custom type
         it will build a typed data based on a #xs:decimal--&gt;
  &lt;asl:type name="temperature" base="xs:decimal" init="{.}"&gt;
    &lt;!--asl:element() refers to the current element, actually a &lt;city&gt;--&gt;
    &lt;xcl:if test="{ asl:element()/@unit='Â°F' }"&gt;
      &lt;xcl:then&gt;
        &lt;!--if @unit="Â°F", the value of the typed data is updated
            $asl:data is the structure bound to the attribute that handles
            the current typed data
            "." is the current data, an #xs:decimal--&gt;
        &lt;xcl:update
            referent="{ $asl:data }"
            operand="{ (value(.) - 32) * 5 div 9 }"/&gt;
      &lt;/xcl:then&gt;
    &lt;/xcl:if&gt;
  &lt;/asl:type&gt;

&lt;/asl:active-schema&gt;
</programlisting><para>The Active Schema Language (ASL) can defines content models and data types like other schema technologies, and also unlike them !
In the above instance, the typed data that will be bound to the attribute will vary according to the temperature unit used in the XML input document.
The following <emphasis>active sheet</emphasis> will sort our weather report correctly:</para><programlisting xml:space="preserve">
&lt;xcl:active-sheet
    xmlns:xcl="http://ns.inria.org/active-tags/xcl"
    xmlns:asl="http://ns.inria.org/active-schema"&gt;

  &lt;xcl:parse
      name="wr"
      source="weather-report.xml"/&gt;
  &lt;asl:parse-schema
      name="wr-schema"
      source="weather-report.asl"/&gt;
  &lt;!--the "augment" attribute indicates to bind typed datas to XML items in the XDM--&gt;
  &lt;asl:validate
      schema="{ $wr-schema }"
      node="{ $wr }"
      augment="yes"
      deep="yes"/&gt;
  &lt;xcl:echo
      value="List of cities, sorted in temperature order:"/&gt;
  &lt;xcl:for-each
      name="city"
      select="{ xcl:sort( $wr/*/city, @temp ) }"&gt;
    &lt;xcl:echo
        value="{ $city/@temp }{ $city/@unit } { $city/@name }"/&gt;
  &lt;/xcl:for-each&gt;

&lt;/xcl:active-sheet&gt;
</programlisting><para>In the result, we notice that the attribute value remains the same, whereas the bound typed data was involved in the sort operation:</para><programlisting xml:space="preserve">
List of cities, sorted in temperature order:
32Â°F Berlin
19Â°C Paris
68Â°F London
22Â°C Rome
23Â°C Madrid
</programlisting><para>Notice that as explained in the foundations of the system, the engine could also be launched with a custom catalog that refer to our schema;
the <code>&lt;asl:parse-schema&gt;</code> instruction would then be discarded,
and the <code>&lt;asl:validate&gt;</code> instruction wouldn't refer to it.</para><para>To go further, we could also imagine another semantic data type that would handle a temperature followed immediately with its scale:</para><programlisting xml:space="preserve">&lt;city name="London" temp="68Â°F"/&gt;</programlisting><para>...and why not allow a mix of the 2 formats in the same document ? ASL support as well this type and types expressed in terms of a choice between several other candidate types.</para><para>Those variants are also available at the RefleX web site. The reader is invited to consult the Active Schema Language specification for further informations about semantic data types and polymorphic data types.</para></section><section><title>Mixins, or collecting schema flavors</title><para>Schema mixins can be understand as the ability to mix several schemas. Several solutions, tools, and techniques are already available:</para><itemizedlist><listitem><para><xref linkend="NVDL"/> (Namespace-based Validation Dispatching Language) consist on separating the input document to validate
according to the namespaces encountered and validating each chunk with the appropriate schema.
Although several different schema technologies can be involved, for example Relax NG + W3C XML Schema,
each will act on a single namespace URI separately.</para></listitem><listitem><para>W3C XML Schema has a mechanism for importing and including other pieces of schema.
But those external parts must be themselves W3C XML Schema.</para></listitem><listitem><para>Schematron can be embedded inside a W3C XML Schema, but they are not helping each other.
Each does its job independently of the other.</para></listitem><listitem><para><xref linkend="MSV"/> is a Java tool that makes various schema languages converging to a common representation.
This allows the same engine to work with DTD, W3C XML Schema, and Relax NG.</para></listitem><listitem><para><xref linkend="DSDLp9"/> is a draft that brings data types and namespace URIs to DTD. But it is an extension to the DTD language.</para></listitem><listitem><para>Relax NG and ASL (as shown in the previous sections) can use W3C XML Schema datatypes.</para></listitem></itemizedlist><para>In all that cases, schemas mixins are partially supported. We can't in the same namespace design two parts of a schema with two different schema technologies. What does it serves for ? Well, some people are addicted to DTDs that after all are part of the XML specifications, and DTD content models are in some cases powerful enough. So why moving to W3C XML Schema ? Perhaps to gain a little in expressivity, or to take the benefits of data types. However, even for this last reason, DTD are still used, the more often simply because they are already written. So, we expect from schema mixins a deeper entanglement of several schema technologies.</para><para>Let's take back our previous example: a compatible schema could be also expressed with a DTD:</para><programlisting xml:space="preserve">
&lt;!--FILE: weather-report-legacy.dtd--&gt;
&lt;!ELEMENT weather-report (city)+&gt;
&lt;!ELEMENT city EMPTY&gt;
&lt;!ATTLIST city name CDATA #REQUIRED
               temp CDATA #REQUIRED
               unit CDATA #REQUIRED&gt;
</programlisting><para>The constraints that has been relaxed in this DTD are:</para><itemizedlist><listitem><para>the temperature is not numeric</para></listitem><listitem><para>the unit can't be expressed with an enumeration of values because Â°C and Â°F are not valid XML tokens</para></listitem><listitem><para>the relationship between Â°C and Â°F can't be expressed</para></listitem></itemizedlist><para>As seen previously, we can design apart with ASL the expected types:</para><programlisting xml:space="preserve">
&lt;!--FILE: weather-report-datatypes.asl--&gt;
&lt;asl:active-schema
    xmlns:xcl="http://ns.inria.org/active-tags/xcl"
    xmlns:asl="http://ns.inria.org/active-schema"
    xmlns:xs="http://www.w3.org/2001/XMLSchema-datatypes"
    target=""
&gt;

  &lt;!--#temp-units is the type for temperature units--&gt;
  &lt;asl:type name="temp-units"&gt;
    &lt;asl:choice&gt;
      &lt;asl:text value="Â°C"/&gt;
      &lt;asl:text value="Â°F"/&gt;
    &lt;/asl:choice&gt;
  &lt;/asl:element&gt;

  &lt;!--#temperature is the type introduced in the previous section--&gt;
  &lt;asl:type name="temperature" base="xs:decimal" init="{.}"&gt;
    &lt;!--asl:element() refers to the current element, actually a &lt;city&gt;--&gt;
    &lt;xcl:if test="{ asl:element()/@unit='Â°F' }"&gt;
      &lt;xcl:then&gt;
        &lt;!--if @unit="Â°F", the value of the typed data is updated
            $asl:data is the structure bound to the attribute that handles
            the current typed data
            "." is the current data, an #xs:decimal--&gt;
        &lt;xcl:update
            referent="{ $asl:data }"
            operand="{ (value(.) - 32) * 5 div 9 }"/&gt;
      &lt;/xcl:then&gt;
    &lt;/xcl:if&gt;
  &lt;/asl:type&gt;

&lt;/asl:active-schema&gt;
</programlisting><para>The last piece of the puzzle is to "patch" the DTD with ASL. For this purpose, a third schema specifies how to override the definitions of the DTD:</para><programlisting xml:space="preserve">
&lt;!--FILE: weather-report-master.asl--&gt;
&lt;asl:active-schema
    xmlns:xcl="http://ns.inria.org/active-tags/xcl"
    xmlns:asl="http://ns.inria.org/active-schema"
    xmlns:xs="http://www.w3.org/2001/XMLSchema-datatypes"
    target=""
&gt;

  &lt;!--redefine only what needed--&gt;
  &lt;asl:element name="city"&gt;
    &lt;asl:attribute name="temp" ref-type="temperature"/&gt;
    &lt;asl:attribute name="unit" ref-type="temp-units"/&gt;
    &lt;!--other definitions are preserved--&gt;
    &lt;asl:apply-definition/&gt;
  &lt;/asl:element&gt;

&lt;/asl:active-schema&gt;
</programlisting><para>Of course, the two ASL schemas could be merged in a single schema,
but having two shemas allow a rather good independence between the definitions of the custom types and their usages (the patch operation).</para><para>As explained previously, an Active Catalog is used to declare the relevant schemas:</para><programlisting xml:space="preserve">&lt;cat:catalog
    xmlns:cat="http://ns.inria.org/active-catalog"
    xmlns:asl="http://ns.inria.org/active-schema"&gt;
    &lt;!--if our XML structure had a namespace URI,
        the name attribute below would contain it litteraly--&gt;
    &lt;cat:resource name="" uri="weather-report-master.asl" selector="asl:schema"/&gt;
    &lt;cat:resource name="" uri="weather-report-datatypes.asl" selector="asl:schema"/&gt;
    &lt;!--asl:schema is the selector for all kind of schemas: DTD, ASL, W3C XML Schema,
    Relax NG, others --&gt;
    &lt;cat:resource name="" uri="weather-report-legacy.dtd" selector="asl:schema"/&gt;
&lt;/cat:catalog&gt;
</programlisting><para>We have already seen that an <emphasis>active sheet</emphasis> that performs a
validation don't need to refer to a parsed schema: the engine will lookup in its catalogs for
the relevant resources. With RefleX, the command line interface and the servlet allow to run
an <emphasis>active sheets</emphasis> with a given set of catalogs.
Notice that the order where the resources appear is important: the definitions in the master
schema mask those in the legacy DTD. This is a strategy proper to schema lookup, and other
kind of resources (modules) have their own lookup strategy. Details are available in the
Active Catalog specification.</para><para>Other features are available: for example, before applying or after applying the definitions of the DTD,
some content models might be prepend or append to the content model of the DTD if needed.
But a more complex refactorisation of the content model expressed in the DTD wouldn't be possible without overwriting it entirely.</para><para>Unlike the previous examples, mixins are in progress in ASL and are not covered by the implementation.</para><para>Basically, they work like imports and includes in W3C XML Schema but it demonstrates clearly that a system based on schema cooperation allow to deal with legacy schemas.
Moreover, this is a not intrusive technique unlike ISO/DSDL part 9 mentioned earlier that require to rewrite DTD interpreters.
Additionally, with the help of catalogs, we have a schema machinery that prefer to rely on dedicated components rather than trying to do everything itself.</para></section><section><title>Hyperschemas, or validating high-level XML components</title><para>In the same way that there is a Relax NG schema for Relax NG, a W3C XML Schema schema for W3C XML Schema, let's try to write the ASL schema of ASL.</para><para>An element definition is composed of attribute definitions or references, choices, sequences, etc. Let's start to write it:</para><programlisting xml:space="preserve">
&lt;asl:active-schema
    xmlns:asl="http://ns.inria.org/active-schema"
    xmlns:xs="http://www.w3.org/2001/XMLSchema-datatypes"
    target="asl"
&gt;

  &lt;asl:element name="asl:element"&gt;
    &lt;asl:attribute name="name" ref-type="xs:string"/&gt;
    &lt;asl:choice min-occurs="0" max-occurs="unbounded"&gt;
      &lt;asl:element ref-elem="asl:attribute"/&gt;
      &lt;asl:element ref-elem="asl:choice"/&gt;
      &lt;asl:element ref-elem="asl:sequence"/&gt;
      &lt;!--other stuff here--&gt;
    &lt;/asl:choice&gt;
  &lt;/asl:element&gt;

&lt;/asl:active-schema&gt;
</programlisting><para>However, we have seen that ASL doesn't work alone: we can inject foreign instructions that the engine will use to build the content model.
We could then append in the <code>&lt;asl:choice&gt;</code> a reference to the XCL namespace, which can be written like this:</para><programlisting xml:space="preserve">
      &lt;!--any element in the XCL namespace--&gt;
      &lt;asl:element ref-ns="xcl"
                      xmlns:xcl="http://ns.inria.org/active-tags/xcl"/&gt;
</programlisting><para>...but it is not enough. In fact, since we don't know how the user will define its content model, almost anything should be allowed:
we can't make assumptions about which tag will help him and which one won't. The content model would become:</para><programlisting xml:space="preserve">
  &lt;asl:element name="asl:element"&gt;
    &lt;asl:attribute name="name" ref-type="xs:string"/&gt;
    &lt;asl:choice min-occurs="0" max-occurs="unbounded"&gt;
      &lt;asl:element ref-ns="#any"/&gt;
    &lt;/asl:choice&gt;
  &lt;/asl:element&gt;
</programlisting><para>...which means basically: well, everything is accepted. Not so useful.
This is the downside of the system: since almost everything is dynamic, we can't predict which tag will come.
Yet some are acceptable, others aren't.</para><para>On the opposite, we do know after running the content model (not this one but those with the if-then-else statement shown in the chapter about dynamicity) that the realization of the schema must conform to the schema that we started to write above (not those with ref-ns="#any", but the one before). Unfortunately, it is designed to validate XML (its static representation), not to validate the underlying software components (its dynamic representation): element definitions, sequences, choices are software components whose relationships are expressed with XML tags. We know how to express constraints on XML tags, but we don't know how to express constraints on such pluggable components because although they are exposed as XML tags they are no longer XML tags at runtime.</para><para>ASL doesn't face this kind of validation. We could imagine schemas that would act on a higher dimension of validation -hyperschemas- and schemas that would act on both level, multidimensional schemas. This is a funny thought that was encountered while designing Active Tags, and that of course can be generalized for components that are not related to schemas: in many cases, the author had to express components contents in terms of parts that are static and validable with a schema, and parts that are dynamic and validable with an hyperschema.</para><para>So far, no acceptable solution was found.</para></section><section><title>Conclusion and perspectives</title><para>Hyperschemas don't have obviously a practical field of application out of the scope of Active Tags. However, they pose the right questions to similar systems that would need more flexibility and dynamicity in software components assembly.</para><para>On the opposite, the other use cases exposed (dynamic content models, semantic typed data, and mixins) are more pragmatic since they address elegantly and efficiently common issues in schema technologies.</para><para>We have seen that active content models enhance the expressiveness of schemas, that if a data has some meaning for you, it should have some meaning too for the applications that process it, and that mixins allow DTD-nostalgic people to leverage their usage.</para><para>Through those few manifestations of "schemas mashups", we have to admit that there are better solutions than running schemas alone. Actually, ASL is not so different from other schema technologies (DTD, W3C XML Schema, Relax NG, Schematron) but immensely more powerful. By extension, ASL should opens the perspective for declarative languages in general: Active Tags combine a bunch of XML technologies that would help significantly the designers of runnable markup languages.</para></section><bibliography><title>Bibliography</title><bibliomixed xml:id="ActiveCatalog" xreflabel="Active Catalog">Poulard, P. <emphasis>Active Catalog</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://ns.inria.fr/active-tags/active-catalog/active-catalog.html</link>.</bibliomixed><bibliomixed xml:id="ActiveTags" xreflabel="Active Tags">Poulard, P. <emphasis>Active Tags technologies</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://ns.inria.org/active-tags/</link>.</bibliomixed><bibliomixed xml:id="ASL" xreflabel="ASL">Poulard, P. <emphasis>The Active Schema Language</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://ns.inria.fr/active-tags/active-schema/active-schema.html</link>.</bibliomixed><bibliomixed xml:id="DSDLp9" xreflabel="ISO/DSDL part 9"><emphasis>DSDL (Document Schema Definition Languages) â Part 9: Namespace- and datatype-aware DTDs</emphasis>, ISO/IEC CD 19757-9.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://dsdl.org/dsdl-9-rev061103.pdf</link>.</bibliomixed><bibliomixed xml:id="DTLL" xreflabel="DTLL">Tennison J. (2006). <emphasis>Datatypes for XML: the Datatyping Library Language (DTLL)</emphasis>. In Proceedings of Extreme Markup Languages, MontrÃ©al, Canada. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.idealliance.org/papers/extreme/proceedings/html/2006/Tennison01/EML2006Tennison01.html</link>.</bibliomixed><bibliomixed xml:id="Jelly" xreflabel="Jelly"><emphasis>Jelly: Executable XML</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://jakarta.apache.org/commons/jelly/</link>.</bibliomixed><bibliomixed xml:id="JSP" xreflabel="JSP"><emphasis>JSP: JavaServer Pages Technology</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://java.sun.com/products/jsp/</link>.</bibliomixed><bibliomixed xml:id="JSTL" xreflabel="JSTL"><emphasis>JSTL: JavaServer Pages Standard Tag Library</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://java.sun.com/products/jsp/jstl/</link>.</bibliomixed><bibliomixed xml:id="Murata" xreflabel="Murata">Murata, M. (2002). <emphasis>Principles of Schema Languages</emphasis>. In H. Maruyama (Ed.), <emphasis>XML and Java (2nd ed.)</emphasis> (pp. 592-601). Boston, MA: Pearson Education.</bibliomixed><bibliomixed xml:id="MSV" xreflabel="MSV">Kawaguchi, K. <emphasis>Sun Multi-Schema Validator</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">https://msv.dev.java.net/</link>.</bibliomixed><bibliomixed xml:id="NVDL" xreflabel="NVDL"><emphasis>NVDL: Namespace-based Validation Dispatching Language</emphasis>, ISO/IEC 19757-4 NVDL. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.nvdl.org/</link>.</bibliomixed><bibliomixed xml:id="XMLCatalogs" xreflabel="OASIS XML Catalogs">Walsh, N. (2005). <emphasis>XML Catalogs</emphasis>, OASIS Standard V1.1.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html</link>.</bibliomixed><bibliomixed xml:id="Poulard" xreflabel="Poulard">Poulard, P. (2007). <emphasis>Active Tags: Mastering XML with XML</emphasis>. In Proceedings of Extreme Markup Languages, MontrÃ©al, Canada. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.idealliance.org/papers/extreme/proceedings/html/2007/Poulard01/EML2007Poulard01.html</link>.</bibliomixed><bibliomixed xml:id="RefleX" xreflabel="RefleX">Poulard, P. <emphasis>RefleX: An Active Tags engine in Java</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://reflex.gforge.inria.fr/</link>.</bibliomixed><bibliomixed xml:id="RelaxNG" xreflabel="Relax NG"><emphasis>Relax NG: Regular-grammar-based validation</emphasis>, ISO/IEC FDIS 19757-2.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.y12.doe.gov/sgml/sc34/document/0362_files/relaxng-is.pdf</link>.</bibliomixed><bibliomixed xml:id="SCXML" xreflabel="SCXML"><emphasis>SCXML: State Machine Notation for Control Abstraction</emphasis>, W3C Working Draft. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/scxml/</link>.</bibliomixed><bibliomixed xml:id="Schematron" xreflabel="Schematron">Jelliffe, R. <emphasis>Schematron: A language for making assertions about patterns found in XML documents</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.schematron.com/spec.html</link>.</bibliomixed><bibliomixed xml:id="UEL" xreflabel="UEL"><emphasis>UEL: Unified Expression Language</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://java.sun.com/products/jsp/reference/techart/unifiedEL.html</link>.</bibliomixed><bibliomixed xml:id="WUnit" xreflabel="WUnit">Poulard, P. <emphasis>WUnit: Unit tests for Web applications</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://reflex.gforge.inria.fr/wunit.html</link>.</bibliomixed><bibliomixed xml:id="WXS" xreflabel="W3C XML Schema"><emphasis>XML Schema Part 1: Structures Second Edition</emphasis>, W3C Recommendation.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</link>.</bibliomixed><bibliomixed xml:id="WXS-D" xreflabel="W3C XML Schema: Datatypes"><emphasis>XML Schema Part 2: Datatypes (2nd ed.)</emphasis>, W3C Recommendation. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</link>.</bibliomixed><bibliomixed xml:id="WXS-11" xreflabel="W3C XML Schema 1.1"><emphasis>W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures</emphasis>, W3C Working Draft.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema11-1/</link>.</bibliomixed><bibliomixed xml:id="XCL" xreflabel="XCL">Poulard, P. <emphasis>The XML Control Language</emphasis>.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://ns.inria.org/active-tags/xcl/xcl.html</link>.</bibliomixed><bibliomixed xml:id="XDM" xreflabel="XDM"><emphasis>XQuery/XPath Data Model (XDM) 1.0</emphasis>, W3C Recommendation. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</link>.</bibliomixed><bibliomixed xml:id="XPath" xreflabel="XPath"><emphasis>XML Path Language</emphasis>, W3C Recommendation. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xpath</link>.</bibliomixed><bibliomixed xml:id="XProc" xreflabel="XProc"><emphasis>XProc: An XML Pipeline Language</emphasis>, W3C Working Draft.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/2006/WD-xproc-20061117/</link>.</bibliomixed><bibliomixed xml:id="XQuery" xreflabel="XQuery"><emphasis>XQuery 1.0: An XML Query Language</emphasis>, W3C Recommendation. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</link>.</bibliomixed><bibliomixed xml:id="XSLT" xreflabel="XSLT">Clark, J. (1999). <emphasis>XSL Transformations (XSLT) 1.0</emphasis>, W3C Recommendation.<link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</link>.</bibliomixed><bibliomixed xml:id="XUnit" xreflabel="XUnit">Poulard, P. <emphasis>XUnit: XML-based unit tests</emphasis>. <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://reflex.gforge.inria.fr/xunit.html</link>.</bibliomixed></bibliography></article>