<?xml version="1.0" encoding="UTF-8"?><article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" version="5.0-subset Balisage-1.3"><title>Indexing Queries in Lux</title><info><confgroup><conftitle>Balisage: The Markup Conference 2013</conftitle><confdates>August 6 - 9, 2013</confdates></confgroup><abstract><para>
        Query optimizers often mystify database users: sometimes queries
        run quickly and sometimes they don’t. An intuitive grasp of what
        will work well in an optimizer is often gained only after trial,
        error, inductive logic (i.e. educated guessing), and sometimes
        propitiatory sacrifice. This paper tries to lift the veil by
        describing work on Lux, a new indexed XQuery search engine built
        using Saxon and Lucene, which is freely available under an
        open-source license. Lux optimizes queries by rewriting them as
        equivalent (but usually faster) indexed queries, so its results are
        easier for a user to understand than the abstract query plans
        produced by some optimizers. Lucene-based QName and path indexes
        prove useful in speeding up XQuery execution by Saxon.
      </para></abstract><author><personname><firstname>Michael</firstname><surname>Sokolov</surname></personname><personblurb><para>
        Michael Sokolov is a software developer and data architect.  He has
        been creating online reference and reading platforms since 1999,
        first at iFactory, and since 2013 as part of Safari Books Online.
        He is fascinated by the ways humans interact with large texts via
        computer and works on document and text processing, indexing, and
        search. Michael was the data and search architect for the OED
        online's relaunch in 2010, and in previous lives worked on speech
        recognition, internationalization, object databases, and in the
        remote past, computer vision.
      </para></personblurb><affiliation><jobtitle>Senior Architect</jobtitle><orgname>Safari Books Online</orgname></affiliation><email>sokolov@falutin.net</email><link xlink:href="http://luxdb.org/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://luxdb.org/</link></author><legalnotice><para>Copyright © V. Michael Sokolov 2013</para></legalnotice></info><section><title>Why another XML search engine?</title><para>
      So first: why? There are a number of excellent XQuery databases
      available, both commercial and free ones, even open source.  Some of
      our motivation was historical; for a variety of reasons we ended up
      with a number of applications built on top of a Solr/Lucene data store.
      We keep XML in these indexes, and we can define XPath indexes, but our
      query syntax is limited to Lucene's simple query languages, which are
      not at all XML aware.  So we wanted to be able to use XQuery in an
      efficient way with these pre-existing data stores.
    </para><para>
      <mediaobject><imageobject><imagedata fileref="../../../vol10/graphics/Sokolov01/Sokolov01-001.png" format="png"/></imageobject></mediaobject>
      The diagram shows the PubFactory architecture.  Interactions with the
      DB are done using its native API.  For MarkLogic and eXist, this is
      all XQuery.  Solr's APIs are a mixture of Lucene query language and a
      thin Java API that wraps a number of HTTP REST calls.  When using an
      XML-aware database, The XML Indexer component is not required.  We
      created this component to work with Solr, which provides full text
      indexes and typed indexes (for strings, numbers, dates, geolocations
      and so on).
    </para><para>
      This system design has a lot of nice features: it enabled us to
      accomplish most of what we needed with a leaner technology stack, and
      we gained a degree of power and flexibility by doing so, since we had
      Java programmers on staff who could fill in the missing bits.  But
      having done this we also had to grapple with some missing conveniences
      that those programmers were somewhat reliant on.
    </para><para>
      We knew from the beginning that we would miss the <emphasis>ad
      hoc</emphasis> query capabilities that both MarkLogic, and eXist,
      which we had been using, provided.  We had come to rely on CQ and the
      eXist sandbox: what would take their place?  The Solr admin query
      interface is a truly impoverished replacement for these.  In fact it
      has recently gotten a facelift, but the query interface is
      essentially unchanged: you have no opportunity to operate on the
      results beyond selecting which fields are returned.  Worse still, all
      of our indexes would have to be computed in advance.  MarkLogic
      provides a great feature for <emphasis>ad hoc</emphasis> querying,
      which I think they call the "universal index." This index provides
      for lookup by word (ie full text search) and value (exact match)
      constrained by the name of containing elements and attributes.
    </para><para>
      So Lux was really born out of this need for an <emphasis>ad
      hoc</emphasis> query capability, something akin to what Micah Dubinko
      presented at Balisage last year in <link xlink:href="http://www.balisage.net/Proceedings/vol8/html/Dubinko01/BalisageVol8-Dubinko01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Exploring
      the Unknown</link>.  Our first thought was something like this: "Hey,
      Saxon provides an XQuery capability, and Solr provides indexing and
      storage: all we need to do is marry them, and presto! We'll have an
      indexed XQuery tool." It turned out though that there was a lot more
      work required to produce a usable version of that than it appeared at
      first blush.  This is the story.
    </para></section><section><title>Lux Architecture</title><para>
      A quick overview of the Lux internal software design provides context
      for the XQuery indexing optimizations that are the main topic of this
      paper.
    </para><mediaobject><imageobject><imagedata fileref="../../../vol10/graphics/Sokolov01/Sokolov01-002.png" format="png"/></imageobject></mediaobject><variablelist><varlistentry><term>Evaluator</term><listitem><para>the highest-level abstraction in Lux.  It contains the
        other objects listed below (and the underlying Saxon objects) and
        provides a central access point for all Lux functionality, but in
        particular provides the evaluate(query) method.
      </para></listitem></varlistentry><varlistentry><term>Compiler</term><listitem><para>compiles XQuery expressions into an executable form</para></listitem></varlistentry><varlistentry><term>SaxonTranslator</term><listitem><para>translates expressions from Saxon's internal Expression
        tree structure to Lux's AbstractExpression tree structure.</para></listitem></varlistentry><varlistentry><term>PathOptimizer</term><listitem><para>rewrites AbstractExpression to make use of Lux indexes</para></listitem></varlistentry><varlistentry><term>FunctionLibrary</term><listitem><para>Provides index-aware XQuery functions</para></listitem></varlistentry><varlistentry><term>XmlIndexer</term><listitem><para>Indexes XML documents, generating Lucene field values</para></listitem></varlistentry><varlistentry><term>Searcher</term><listitem><para>Searches the Lucene index, returning matching documents stored there</para></listitem></varlistentry><varlistentry><term>XML Highlighter</term><listitem><para>Highlights terms in a document matching a search query</para></listitem></varlistentry><varlistentry><term>Query Parser</term><listitem><para>Parses queries in Lux's extended Lucene query language and its XML form</para></listitem></varlistentry></variablelist></section><section><title>Query optimization with indexes</title><para>
      When executing queries in a setting with a large amount of data,
      indexes are critical.  A properly indexed query may execute in less
      than a millisecond while the same query, unoptimized, could easily
      take so long that it would effectively never complete.  In Lux,
      queries are implicitly executed with the entire contents of the index
      as their context: more precisely, wherever there is an absolute
      expression (a path rooted at "/"), Lux inserts, conceptually, a call
      to <code>collection()</code>, the function that returns all
      documents.  This approach has been adopted in other databases; we've
      attempted to provide a familiar environment.
    </para><para>
      Sometimes users exercise control over the indexes that are generated
      and how they are used to resolve queries.  XSLT's key functionality
      is an example of this.  In other cases, like SQL databases, users
      specify the indexes and hope they've chosen the right ones that will
      nudge the optimizer to speed up their queries. And sometimes indexes
      are created and used with little or no user intervention at all. This
      is an ideal situation when it works, but nearly impossible to get
      right all the time in a general case where queries are expressed in a
      complex language such as XQuery. There are two main difficulties:
      knowing which indexes might be useful enough to justify the cost of
      creating them, and then actually applying those indexes to optimize
      queries.
    </para><para>
      Our philosophy is to provide as much automatic help as possible, so
      the user doesn't have to think, but to get out of the way when the
      user tells us they want manual control.
      <orderedlist><listitem><para>
          Provide basic indexes that can be applied automatically and
          relied on to provide value for a wide range of queries.
        </para></listitem><listitem><para>
          Give the user clear information about the output of the
          optimizer. Sometimes the optimizer can be tricked by otherwise
          insignificant syntactic constructs, like variables. If the user
          is made aware of this, they can often rectify the situation by
          rewriting their queries.
        </para></listitem><listitem><para>
          Allow the user to specify indexes explicitly: users can be relied
          on to know when there are especially interesting sequences to be
          indexed.
        </para></listitem><listitem><para>
          Provide users with query constructs that reference the indexes
          directly. This way users can take over when the optimizer fails.
        </para></listitem></orderedlist>
      This paper addresses the first point primarily, exploring some
      challenges we overcame providing the built-in indexes and optimizing
      queries to use them, but it's important not to lose sight of the
      bigger picture as well.
    </para><para>
      It has become standard practice to index XML with the following kinds of
      indexes:
      <itemizedlist><listitem><para>QName indexes</para></listitem><listitem><para>Path indexes</para></listitem><listitem><para>Full text indexes</para></listitem><listitem><para>QName value and/or text indexes</para></listitem><listitem><para>XPath indexes</para></listitem></itemizedlist>
      These kinds of indexes are provided by <link xlink:href="http://docs.marklogic.com/guide/admin/text_index#chapter" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">MarkLogic</link>,
      <link xlink:href="http://exist-db.org/exist/apps/doc/indexing.xml" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">eXist</link>
      and <link xlink:href="http://docs.basex.org/wiki/Indexes#Resource_Index" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">BaseX</link>,
      <link xlink:href="http://msdn.microsoft.com/en-us/library/ms191497.aspx" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">SQL
      Server</link> (Primary XML index covers paths and values; full text
      is available, and Secondary index provides XPath), <link xlink:href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28369/xdb_indexing.htm#CHDFCGGI" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Oracle</link>
      and <link xlink:href="http://pic.dhe.ibm.com/infocenter/dzichelp/v2r2/topic/com.ibm.db2z10.doc.xml/src/tpc/db2z_indexxml.htm" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">DB2</link>,
      to name a few popular systems.  A review of the indexing capabilities
      of these and other tools is beyond the scope of this paper, but it is
      apparent that the index types described above are well-represented in
      the field.
    </para><para>
      Lux currently provides path, full text, element/attribute full text,
      and xpath indexes.  We've done some work on an element/attribute
      value index as well.  The optimizer generates search expressions
      using the path indexes, and in some cases, the full text indexes and
      XPath indexes.  The user can make explicit use of all the indexes for
      search, optimized counting, and sorting by calling index-aware
      functions provided in the Lux function library.
    </para><para>
      There are a variety of optimizations using indexes we could imagine
      applying in order to make a query go faster: Filtering the input
      collection to include only "relevant" documents is the main one, and
      it sounds simple enough, but there are a lot of specific cases to be
      considered, and there is a real danger of over-optimizing and getting
      incorrect results.  Optimizations tend to have a patchwork character,
      and in order to stay on top of things, it's important to have a
      formal framework we can use to prove to ourselves that the
      optimizations are correct; that they preserve the correct results.
    </para><section><title>Formal setting</title><para>
        Because XQuery is a functional language, it's natural to think of
        queries as functions, and to apply the formalisms of functional
        logic. In this light, query optimizations can be described formally
        as a special kind of homomorphism <footnote><para>A homomorphism is
        a kind of mapping that preserves structure.</para></footnote> over
        the space of all queries.  A function is generally defined as a
        mapping from one set to another: in this case from sequences of
        documents to sequences of items. So in this terminology, two
        queries are homomorphic if they represent the same mapping from
        documents to items.  We won't take this formal setup very far, but
        we note that homomorphism is preserved by composition. In other
        words if two optimizations are "correct" independently, applying
        both of them will still be "correct", in the sense of preserving
        correct results, and we can apply them in whichever order we
        choose.  This is important because it enables us to work on query
        transformations independently, without worrying that making changes
        in one place will suddenly cause problems to crop up somewhere
        completely different.
      </para><para>
        Defining optimization as a mapping from queries to queries has
        another nice property: it means we can fairly easily show the user
        what the optimized query is: it's just a different (hopefully
        faster) query that returns the same result.  This is different from
        the situation in some systems, where optimizations are completely
        opaque to the user, or are presented as a kind of abstract "query
        plan" that bears little or no resemblance to an actual query.  Of
        course the user needs to be able to understand the optimized XQuery
        form, but given that they wrote the original XQuery, it shouldn't
        be too much of a stretch for them.
      </para></section><section><title>Filtering the context</title><para>
        It is often the case that query expressions return an empty sequence
        when evaluated in the context of a given document.  For example, the
        query <code>//chapter[.//videoobject]/title</code> returns the titles
        of all (DocBook) chapters containing references to videos.  Suppose
        our database contains 1000 books broken into a document for every
        chapter.  Only a small fraction of these may actually contain videos,
        but a naïve unoptimized implementation might have to load every one
        of those documents into memory, parse them, evaluate the query on
        them, only to return nothing. One of the main goals of the optimizer
        is to filter the context early in the process, using indexes, so that
        all this unnecessary work can be avoided.
      </para><para>
        We said that we operate on the whole database by replacing "/" with
        collection().  We can think of every query to be optimized then as
        some function whose single argument is the sequence of all
        documents.  What we'd like to be able to do is to filter out all
        documents from that sequence that have no chance of contributing to
        the query results.  Intuitively we know that the result of

        <blockquote><para><code>
          collection()//chapter[.//videoobject]/title
        </code></para></blockquote>

        will be the same as the result of:

        <blockquote><para><code>
          collection('chapters with videos (and titles)')//chapter[.//videoobject]/title
        </code></para></blockquote>

        Some XQuery expressions, and in particular path expressions, have
        the nice property of commuting with sequences: that is, their
        result sequence will be the sequence formed by applying the
        expression to each element of the input sequence in turn.  Or, more
        concisely:

        <blockquote><para><code>
          f(s1,s2,s3,...) === (f(s1), f(s2), f(s3), ...)
        </code></para></blockquote>

        Combining this with the fact that sequences don't nest, we get that
        (for these functions):

        <blockquote><para><code>
          f(S) === f(s∈S | f(s) is not empty) 
        </code></para></blockquote>

        which just basically says that we only need to run the query on
        documents that will return results - we can skip all the other ones
        since they are irrelevant.

      </para><para>
        This is very useful.  What it means is that if we can come up with
        some index query that selects only those documents that return
        results for a given XQuery, then we can use that to filter the
        documents "up front," and save a lot of processing.  Actually it's
        OK to retrieve more documents than we need, but the game is to
        retrieve as few as possible without missing any important ones.  
      </para><para>
        So that's goal #1 of the optimizer: for any XQuery, produce an
        index query that minimizes the number of documents required to be
        retrieved.  How do we do that?  The strategy is to devise indexes,
        and queries, that match XQuery primitives like QNames and simple
        comparisons, and then to combine those primitive queries when they
        appear as part of more complex, composite expressions, like
        sequences, boolean operators, set operators, FLWOR expressions and
        so on. In particular what the Lux optimizer does is to perform a
        depth-first walk of the syntax tree of a query, pushing, popping,
        and combining index queries on a stack as it goes.  The
        pseudo-logic of <code>optimize(xquery)</code> goes something like
        this:

        <programlisting xml:space="preserve">
            if (xquery has no children)
              push a corresponding primitive index query
            else 
              let current-query = match-all
              for each child expression
                pop the child-query
                if (child is absolute (contains a Root sub-expression: /))
                  replace the Root with search(child-query)
                else
                  let current query = combine (current-query, child-query)
              push current-query
        </programlisting>
      </para></section><section><title>Path Indexes</title><para>
        Let's look more closely at optimizing queries with path expressions
        in them, since these expressions are uniquely characteristic of
        querying tree-structured data like XML.  We've implemented
        different kinds of structure-related indexes, and it's interesting
        to compare what each one buys, and what it costs.
      </para><para>
        The most basic approach that captures some document structure is
        just to index all the names of all the elements and attributes (the
        QNames) in each document.  If we do that, we can easily make sure
        not to go looking for videos in documents that don't have them.  
      </para><para>
        But the simple QName index doesn't really capture anything about
        relationships of nodes within a document.  It feels like it ought
        to be possible to search chapter titles independently from
        searching book titles or section titles, for example, even if they
        are all tagged with &lt;title&gt;, as in DocBook.  A natural thing
        to do is to index the complete path of every named node. We've done
        this by treating each path as a kind of "sentence" in which each
        node name is a single word or token. Then using phrase queries and
        similar queries based on token-proximity, we can express
        constraints like <code>a/child::b</code>, <code>a//b</code> (and
        others) much more precisely.  With the simple QName index, it isn't
        possible to write a query even for <code>//a//b</code> that won't
        match other irrelevant documents as well (such as
        <code>&lt;b&gt;&lt;a/&gt;&lt;/b&gt;</code>).
      </para><para>
        Here's a concrete example:
      </para><mediaobject><imageobject><imagedata fileref="../../../vol10/graphics/Sokolov01/Sokolov01-003.png" format="png"/></imageobject></mediaobject><para>
        The figure shows a syntax tree for the example expression roughly
        as it would be expressed by the Saxon parser, in blue rectangles,
        and in orange it shows the corresponding Lucene pseudo-query that
        is generated by Lux.  Parent queries are formed by joining together
        child queries using the recursive process described above.  The
        combine() method alluded to there is somewhat complex for path
        queries.  Its job is to characterize the relationship between two
        child expressions and to generate as precisely as possible (ie
        matching as few documents as possible, without missing any) a query
        corresponding to the parent expression.  For the simple boolean
        queries that are generated when only QName indexes are in use, this
        is generally just a matter of deciding whether the children should
        be AND-ed together or OR-ed together.  The choice is typically
        dictated by the character of the parent expression: most are
        restrictive and generate AND-queries, but some, like "or", "|", and
        "union" conjoin their child expressions and generate OR-queries.
      </para><para>
        Joining path queries also requires computing a distance between two
        subexpressions.  The optimizer computes this distance when visiting
        path expressions (a/b) and predicates (a[b]), translating
        non-adjacent path axes like descendant, and intervening wildcard
        steps like /*/*/ into corresponding phrase distances in the Lucene
        proximity query.
      </para><para>
        Once the optimizer has generated a Lucene query corresponding to an
        XQuery expression, it replaces the collection() (or /) expression
        with a call to Lux's search function, passing it the generated query
        as its argument.
      </para><para>
        One benefit of the Lux architecture is that it optimizes
        expression trees that have already been optimized to some extent by
        Saxon.  Saxon reduces a number of equivalent expressions to a
        simpler canonical form, making it easier to perform the analysis
        needed for optimization.  There are some drawbacks to this approach
        as well: Saxon converts some expressions (like atomized sequences)
        into internal forms that have no direct correspondence with
        XQuery expressions, so some clever inferencing is required in those
        cases to create an equivalent XQuery.
      </para><para>
        Of course we can keep on devising more and more precise indexes.
        Consider indexing every occurrence of every path, so that we keep a
        count of each path as well: that should give us a handle on queries
        involving positional predicates like <code>//title[2]</code>.  We
        often want to know if there is a second same-named element since it
        might violate a schema that requires a singleton.  Indexing paths
        as phrases in Lucene doesn't really lend itself well to maintaining
        this kind of statistic since the tokens in that case are QNames.
        But if we index each complete path as a token (i.e. "/a/b/c" as a
        single token, rather than "a b c" as three tokens associated by
        position-proximity), then the index will maintain a term count for
        us.
      </para><para>
        We have made some experiments with these "path occurrence" queries.
        The path queries become token queries, possibly involving
        wildcards, rather than phrase queries.  The performance of the
        resulting queries is roughly the same as the phrase-like queries
        described before.  The promise of indexing positional predicates
        proves difficult to realize, though.  In Lucene, the primary
        function of term frequency counts is to compute relevance-ranking
        scores: using them to <emphasis>filter</emphasis> queries is much more involved,
        requiring some deeper spelunking into Lucene's internals, but this
        is a promising avenue for future work.
      </para></section><section><title>Other optimizations</title><para>The optimizer knows a few other tricks, beyond simply ignoring
      irrelevant documents.
      </para><section><title>Special Functions</title><para>
          In general, function calls are opaque to the optimizer, but it
          does apply special optimizations for a few built-in XPath
          functions: <code>root()</code>, <code>exists()</code>,
          <code>empty()</code>, <code>count()</code> and
          <code>subsequence()</code>.
        </para><para>
          <code>count()</code>, <code>exists()</code>, and
          <code>empty()</code> can be evaluated using indexes only, without
          loading documents, when it can be determined that their arguments
          are faithfully modeled by an appropriate query.  When this
          inference can be made, the speedup is are often dramatic, so we
          go to some lengths to track a few properties that characterize
          the precision of the Lucene query that the optimizer generates.
        </para><para>
          If we can prove that a given Lucene query retrieves *only* the
          documents that produce XQuery results, no more and no fewer, then
          we call the query <emphasis>minimal</emphasis>.  A minimal query
          is the best we can do in terms of filtering the context set for
          the query.  When their arguments' queries are minimal,
          <code>exists()</code> and <code>empty()</code> are replaced by an
          index-aware analogue, <code>lux:exists()</code>, which simply
          checks whether any documents match a (Lucene) query (or its
          negation, in the case of empty()).
        </para><para>
          Another useful property that some queries have is that they only
          return one result per document.  We call these
          <emphasis>singular</emphasis>.  It's useful to track singularity
          since a minimal, singular query can be counted efficiently, using
          indexes only.  It's not always possible to tell whether a query's
          result will be singular, but in some cases it is.  In particular,
          if a query returns only documents (or root element nodes), then
          it will be singular.  Lux recognizes that the <code>root()</code>
          function is singular, and counts paths ending with
          <code>/root()</code> in an efficient manner.
        </para><para>
          The <code>subsequence($seq,$start,$length)</code> function provides
          a fixed window into a larger sequence.  We can rely on the XQuery
          processor's lazy evaluation to avoid retrieving documents beyond
          the right edge of the window.  When the windowed sequence is
          singular, we can also avoid loading the documents to the left of
          the window by telling the Lucene searcher to skip the number of
          documents indicated by subsequence's second argument.  Also note
          that Saxon does us the favor of translating numeric predicates
          ($sequence[10]) into subsequence function calls, so the same
          optimization applies to those.
        </para></section><section><title>Sorting</title><para>
          Sorting a sequence using an XQuery "order by" clause typically
          requires the entire sequence to be loaded into memory in order to
          evaluate the ordering expression for use in sorting, even if only
          a subset of the documents will eventually contribute to the
          overall query result (they may be filtered by subsequence() for
          example). We can do better when the ordering expression has been
          indexed.
        </para><para>
          Lux can populate a Lucene field for any user-supplied XPath
          expression, and exposes these fields in XQuery via the
          <code>lux:key</code> (formerly <code>lux:field-values</code>)
          function.  When the optimizer finds a
          <code>lux:key($field)</code> call used as an ordering expression,
          the field argument is used to order the Lucene query result.  In
          general results can be ordered much more quickly this way.  Such
          optimizations are applicable for single-valued fields with string
          and numeric values.  They support empty least/greatest, and can
          handle multiple fields.
        </para></section><section><title>Range Comparisons</title><para>
          Lux optimizes range comparisons (=, !=, &lt;, &lt;=, &gt;, &gt;=, eq,
          ne, gt, ge, le, lt) when one of the operands is a constant, and
          the other is a call to lux:key() or can be proven to match an
          indexed expression.  For example, if there is a string-valued
          index called "book-id" on <code>//book/@id</code>, the expression
          <code>//book[@id="isbn9780123456789"]</code> would be optimized
          into something like:
          <code>lux:search("book-id:isbn9780123456789")</code>, and
          evaluated using indexed lookup. There will be additional clauses
          to the generated query, such as path constraints.  Also, equality
          tests may be optimized using the built-in full text indexes.  In
          the example above, a word-based query such as:
          <code>&lt;@id:isbn9780123456789</code> would be generated, which
          would find the given isbn, ignoring text normalizations such as
          case, in any id attribute.  These text queries are less selective
          than the query based on the XPath index, but can often be
          selective enough, depending on the structure of the documents.
        </para></section><section><title>FLWOR expressions and variables</title><para>
          There are no special optimizations related to these constructs,
          but they do present special problems.  Lux doesn't make any
          attempt to apply constraints from where clauses, but since Saxon
          converts most where clauses to predicates, this isn't a
          significant drawback.  Variables are handled by keeping track of
          variable bindings while the try is being optimized, and applying
          any query constraints from a variable's bound expression to its
          containing expression as if it were simply expanded in place.
        </para></section></section><section><title>Results</title><section><title>Correctness</title><para>
          It's critical to ensure that an "optimized" query returns the same
          results as the original, but it's not always so easy to prove that
          a given optimization is homomorphic.  Sometimes we think we've done
          so, but a counterexample arises. If we were better mathematicians,
          perhaps we wouldn't need to, but as engineers, we take a pragmatic
          approach and build lots of tests.
        </para><para>
          XQTS was a great help, in resolving query translation issues, and
          somewhat helpful in testing the optimizer.  But it isn't targeted
          at testing queries to be run over large numbers of documents, so
          we created our own test suite to ensure that our optimizations do
          in fact improve query speed. In the course of doing this, we
          uncovered numerous bugs, even though we had a nearly 100% pass
          rate on XQTS.  You just can't have enough unit tests.
        </para></section><section><title>Indexing Performance</title><para>
          Of course the whole point of this exercise is to improve query
          performance.  No paper about optimization would be complete
          without some measurements.  And we have been able to make
          improvements.  In some ways it's uninteresting to look at
          specific performance comparisons with and without index
          optimizations, since the improvement (when there is one) can
          usually be made arbitrarily large simply by adding more documents
          to the database.  There are a few inferences to be drawn from the
          numbers, though.
        </para><para>
          Note on the test data: we used Jon Bosak's hamlet.xml (courtesy
          of ibiblio.org) to generate a set of 6636 documents, one for each
          element in the play's markup.  So there are a single PLAY
          document, five ACT documents, and so on, in our test set.
        </para><para>
          We evaluated the cost, in bytes, of enabling various indexing
          options.  The size of the indexes is an important consideration
          since it has an effect on memory consumption and on the amount of
          disk I/O the system will need to perform when updating and
          merging.  For the Hamlet test set, the relative sizes of the
          index fields are given in the following table, in bytes, and as a
          percentage of the size required to store the XML documents.
        </para><informaltable><thead><tr><td>Index Option</td><td>Size (in bytes)</td><td>% of xml</td></tr></thead><tr><td>XML Storage</td><td>1,346,560</td><td>100%</td></tr><tr><td>Full Text</td><td>1,765,376</td><td>100%</td></tr><tr><td>Node Text</td><td>1,770,496</td><td>100%</td></tr><tr><td>Paths</td><td>122,880</td><td>100%</td></tr><tr><td>QNames</td><td>88,064</td><td>100%</td></tr></informaltable><para>
          The Full Text index includes all of the text, but no node name
          information.  The Node Text index indexes each text token
          together with its element (or attribute) context.  Note that the
          sizes of the QName and Path indexes are fairly low relative to
          the size of the documents themselves (also: the QName index isn't
          needed if we have a Path index).  The next section shows the
          effect of these indexes on query performance.
        </para></section><section><title>Query Performance</title><para> 
          The table below shows the time, in milliseconds, to evaluate a
          certain query with different indexes enabled.  The queries were
          repeated 500 times in order to smooth out the noise in the
          measurements.  The column labeled <emphasis>baseline</emphasis>
          represents an unfiltered baseline where every query is evaluated
          against every document.  The <emphasis>qname</emphasis> column
          filtered documents using qname indexes, and the
          <emphasis>path</emphasis> shows results for path indexes.  The
          <emphasis>%change</emphasis> and <emphasis>difference</emphasis>
          columns show the difference between qname and path indexing;
          positive values indicate greater times for qname indexes.  The
          queries have been sorted in descending order by this difference.
        </para><informaltable><thead><tr><td>query</td><td>baseline</td><td>qname</td><td>path</td><td>%change</td><td>difference</td></tr></thead><tr><td>/LINE</td><td>444</td><td>262</td><td>185</td><td>29.19</td><td>76.48</td></tr><tr><td>//ACT/TITLE/root()//SCENE/TITLE/root()//SPEECH/TITLE/root()</td><td>338</td><td>31</td><td>2</td><td>92.01</td><td>28.52</td></tr><tr><td>/ACT['content'=SCENE]</td><td>318</td><td>32</td><td>8</td><td>75.12</td><td>24.04</td></tr><tr><td>/ACT//SCENE</td><td>366</td><td>40</td><td>18</td><td>55.62</td><td>22.25</td></tr><tr><td>/ACT[SCENE='content']</td><td>372</td><td>29</td><td>8</td><td>70.46</td><td>20.43</td></tr><tr><td>/ACT[.='content']</td><td>360</td><td>30</td><td>9</td><td>68.08</td><td>20.42</td></tr><tr><td>/ACT/SCENE[.='content']</td><td>333</td><td>29</td><td>9</td><td>67.47</td><td>19.57</td></tr><tr><td>/ACT/SCENE</td><td>359</td><td>35</td><td>15</td><td>55.61</td><td>19.46</td></tr><tr><td>count(//ACT/SCENE/ancestor::document-node())</td><td>151</td><td>20</td><td>0</td><td>95.59</td><td>19.12</td></tr><tr><td>number((/ACT/SCENE)[1])</td><td>17</td><td>23</td><td>5</td><td>74.62</td><td>17.16</td></tr><tr><td>/ACT/text()</td><td>379</td><td>18</td><td>8</td><td>56.25</td><td>10.13</td></tr><tr><td>/*[self::ACT/SCENE/self::*='content']</td><td>366</td><td>16</td><td>6</td><td>60.85</td><td>9.74</td></tr><tr><td>/ACT//*</td><td>323</td><td>20</td><td>10</td><td>47.62</td><td>9.52</td></tr><tr><td>/ACT</td><td>342</td><td>17</td><td>9</td><td>46.84</td><td>7.96</td></tr><tr><td>/*[self::ACT/SCENE='content']</td><td>321</td><td>13</td><td>5</td><td>60.95</td><td>7.92</td></tr><tr><td>//ACT|//SCENE</td><td>497</td><td>37</td><td>35</td><td>7.69</td><td>2.85</td></tr><tr><td>//ACT</td><td>334</td><td>24</td><td>21</td><td>11.47</td><td>2.75</td></tr><tr><td>//ACT[exists(SCENE)]</td><td>334</td><td>21</td><td>18</td><td>11.97</td><td>2.51</td></tr><tr><td>(/)[.//ACT]</td><td>390</td><td>35</td><td>33</td><td>7.07</td><td>2.47</td></tr><tr><td>//ACT[empty(SCENE)]</td><td>521</td><td>27</td><td>24</td><td>8.86</td><td>2.39</td></tr><tr><td>for $doc in //ACT order by lux:field-values('sortkey', $doc) return $doc</td><td>385</td><td>39</td><td>37</td><td>5.27</td><td>2.06</td></tr><tr><td>for $doc in //ACT order by $doc/lux:field-values('sortkey'),
            $doc/lux:field-values('sk2') return $doc</td><td>525</td><td>26</td><td>24</td><td>7</td><td>1.82</td></tr><tr><td>//ACT[.//SCENE]</td><td>328</td><td>37</td><td>36</td><td>4.17</td><td>1.54</td></tr><tr><td>//ACT/@*</td><td>265</td><td>21</td><td>20</td><td>6.27</td><td>1.32</td></tr><tr><td>subsequence (//ACT, 1, 10)</td><td>275</td><td>18</td><td>17</td><td>5.96</td><td>1.07</td></tr><tr><td>(//ACT)[1]</td><td>8</td><td>14</td><td>13</td><td>7.54</td><td>1.06</td></tr><tr><td>//ACT[not(SCENE)]</td><td>291</td><td>19</td><td>18</td><td>4.51</td><td>0.86</td></tr><tr><td>not(//ACT/root()//SCENE)</td><td>169</td><td>1</td><td>0</td><td>50.89</td><td>0.51</td></tr><tr><td>(for $doc in collection() return string ($doc/*/TITLE))[2]</td><td>8</td><td>10</td><td>10</td><td>3.9</td><td>0.39</td></tr><tr><td>//ACT/SCENE[1]</td><td>416</td><td>22</td><td>21</td><td>1.08</td><td>0.24</td></tr><tr><td>for $doc in //ACT order by $doc/lux:field-values('sortkey') return $doc</td><td>280</td><td>24</td><td>24</td><td>0.84</td><td>0.20</td></tr><tr><td>not(//ACT)</td><td>16</td><td>1</td><td>1</td><td>18.88</td><td>0.19</td></tr><tr><td>/node()</td><td>236</td><td>157</td><td>157</td><td>0.1</td><td>0.16</td></tr><tr><td>/*/ACT</td><td>314</td><td>22</td><td>21</td><td>0.15</td><td>0.03</td></tr><tr><td>(/)[.//*/@attr]</td><td>459</td><td>0</td><td>0</td><td>-180.29</td><td>0.00</td></tr><tr><td>//*[@attr]</td><td>414</td><td>0</td><td>0</td><td>-6.53</td><td>0.00</td></tr><tr><td>//*/@attr</td><td>322</td><td>0</td><td>0</td><td>53.42</td><td>0.00</td></tr><tr><td>//ACT/@id</td><td>338</td><td>0</td><td>0</td><td>27.49</td><td>0.00</td></tr><tr><td>//AND</td><td>382</td><td>0</td><td>0</td><td>-18.86</td><td>0.00</td></tr><tr><td>//lux:foo</td><td>455</td><td>0</td><td>0</td><td>75.42</td><td>0.00</td></tr><tr><td>//node()/@attr</td><td>322</td><td>0</td><td>0</td><td>32.51</td><td>0.00</td></tr><tr><td>/ACT[@id=123]</td><td>435</td><td>0</td><td>1</td><td>-135.83</td><td>0.00</td></tr><tr><td>/ACT[SCENE/@id=123]</td><td>452</td><td>0</td><td>0</td><td>-24.56</td><td>0.00</td></tr><tr><td>count(/)</td><td>287</td><td>0</td><td>1</td><td>-197.15</td><td>0.00</td></tr><tr><td>count(//ACT/ancestor::document-node())</td><td>152</td><td>0</td><td>0</td><td>66.07</td><td>0.00</td></tr><tr><td>count(//ACT/root())</td><td>165</td><td>0</td><td>0</td><td>-49.56</td><td>0.00</td></tr><tr><td>empty((/)[.//ACT and .//SCENE])</td><td>15</td><td>0</td><td>0</td><td>67.55</td><td>0.00</td></tr><tr><td>empty(/)</td><td>13</td><td>0</td><td>0</td><td>-176.63</td><td>0.00</td></tr><tr><td>empty(//ACT)</td><td>14</td><td>0</td><td>0</td><td>-377.25</td><td>0.00</td></tr><tr><td>empty(//ACT) and empty(//SCENE)</td><td>14</td><td>0</td><td>0</td><td>-67.5</td><td>0.00</td></tr><tr><td>empty(//ACT/root())</td><td>470</td><td>0</td><td>0</td><td>37.91</td><td>0.00</td></tr><tr><td>empty(//ACT/root()//SCENE)</td><td>448</td><td>0</td><td>0</td><td>-78.32</td><td>0.00</td></tr><tr><td>exists((/)[.//ACT and .//SCENE])</td><td>10</td><td>0</td><td>0</td><td>-185.37</td><td>0.00</td></tr><tr><td>exists(/)</td><td>13</td><td>0</td><td>0</td><td>69.54</td><td>0.00</td></tr><tr><td>exists(//ACT)</td><td>10</td><td>0</td><td>0</td><td>-53.78</td><td>0.00</td></tr><tr><td>exists(//ACT) and exists(//SCENE)</td><td>11</td><td>0</td><td>0</td><td>64.64</td><td>0.00</td></tr><tr><td>exists(//ACT/root())</td><td>363</td><td>0</td><td>0</td><td>0.86</td><td>0.00</td></tr><tr><td>exists(//ACT/root()//SCENE)</td><td>377</td><td>0</td><td>0</td><td>79.15</td><td>0.00</td></tr><tr><td>not((/)[.//ACT and .//SCENE])</td><td>4</td><td>0</td><td>0</td><td>4.59</td><td>0.00</td></tr><tr><td>not(//ACT) and empty(//SCENE)</td><td>5</td><td>0</td><td>1</td><td>-205.65</td><td>0.00</td></tr><tr><td>not(//ACT/root())</td><td>352</td><td>0</td><td>0</td><td>-17.33</td><td>0.00</td></tr><tr><td>(for $doc in collection() return data($doc//TITLE))[2]</td><td>15</td><td>9</td><td>9</td><td>-0.69</td><td>-0.06</td></tr><tr><td>subsequence (//ACT, 1, 1)</td><td>13</td><td>11</td><td>11</td><td>-1.52</td><td>-0.17</td></tr><tr><td>//ACT[exists(.//SCENE)]</td><td>347</td><td>34</td><td>35</td><td>-0.9</td><td>-0.31</td></tr><tr><td>not(/)</td><td>15</td><td>1</td><td>2</td><td>-35.76</td><td>-0.36</td></tr><tr><td>//ACT[not(empty(.//SCENE))]</td><td>340</td><td>23</td><td>23</td><td>-1.84</td><td>-0.42</td></tr><tr><td>//*/ACT/SCENE</td><td>396</td><td>35</td><td>35</td><td>-1.4</td><td>-0.49</td></tr><tr><td>(/)[.//ACT][.//SCENE]</td><td>340</td><td>24</td><td>24</td><td>-2.89</td><td>-0.69</td></tr><tr><td>count(//ACT/root()//SCENE)</td><td>315</td><td>34</td><td>35</td><td>-3.99</td><td>-1.36</td></tr><tr><td>//ACT[SCENE='content']</td><td>324</td><td>32</td><td>33</td><td>-4.3</td><td>-1.38</td></tr><tr><td>//SCENE[last()]</td><td>623</td><td>45</td><td>46</td><td>-3.24</td><td>-1.46</td></tr><tr><td>//SCENE[1]</td><td>626</td><td>37</td><td>39</td><td>-4.57</td><td>-1.69</td></tr><tr><td>/ancestor-or-self::node()</td><td>285</td><td>239</td><td>241</td><td>-0.77</td><td>-1.84</td></tr><tr><td>//ACT/TITLE | //SCENE/TITLE| //SPEECH/TITLE</td><td>425</td><td>55</td><td>57</td><td>-3.87</td><td>-2.13</td></tr><tr><td>/PLAY/(ACT|PERSONAE)/TITLE</td><td>342</td><td>19</td><td>21</td><td>-11.31</td><td>-2.15</td></tr><tr><td>/*</td><td>288</td><td>310</td><td>312</td><td>-0.73</td><td>-2.26</td></tr><tr><td>count(//ACT)</td><td>222</td><td>19</td><td>21</td><td>-12.14</td><td>-2.31</td></tr><tr><td>//SCENE[2]</td><td>571</td><td>57</td><td>60</td><td>-4.65</td><td>-2.65</td></tr><tr><td>//ACT[count(SCENE) = 0]</td><td>253</td><td>18</td><td>21</td><td>-17.2</td><td>-3.10</td></tr><tr><td>/descendant-or-self::SCENE[1]</td><td>452</td><td>26</td><td>30</td><td>-13.43</td><td>-3.49</td></tr><tr><td>//ACT[.='content']</td><td>368</td><td>27</td><td>31</td><td>-13.13</td><td>-3.55</td></tr><tr><td>/self::node()</td><td>292</td><td>309</td><td>314</td><td>-1.58</td><td>-4.88</td></tr><tr><td>number((/descendant-or-self::ACT)[1])</td><td>364</td><td>19</td><td>25</td><td>-30.09</td><td>-5.72</td></tr><tr><td>/</td><td>312</td><td>347</td><td>362</td><td>-4.45</td><td>-15.44</td></tr><tr><td/><td>288.23</td><td>34.52</td><td>31.15</td><td>9.76</td><td/></tr></informaltable><para>
          It is clear that the path index is providing some benefit when
          the queries contain paths with multiple named steps.  In other
          cases there is sometimes some increase in query time - it's not
          entirely clear why, but the absolute value of this increase tends
          to be small.  It may be that there is some further improvement
          possible by avoiding the use of positional queries when there are
          not any useful path constraints in the query.
        </para></section><section><title>Note on benchmarking</title><para>
          Some reviewers expressed the desire for comparative performance
          benchmarks with other database systems.  We've known <link xlink:href="http://www.phrases.org.uk/meanings/Comparisons%20are%20odious.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">since
          at least 1440</link> that "comparisons are odious," or, according
          to Dogberry, in a later gloss, "odorous."  One would like the
          data, but we don't feel well-placed to provide an objective
          benchmark comparing our system against others.  The best I can
          offer is that we observe comparable performance with other
          indexed XQuery systems, and simply note that the key factor for
          performance is to extend the cases where indexes can be applied.
        </para></section></section></section><section><title>Conclusions</title><para>
      We described an XML search engine, Lux, based on Saxon and Lucene.
      We gave an overview of how it optimizes queries, and we explored its
      Path indexes in more depth.  Measurements show a substantial benefit
      from using these indexes. For many queries the Path index can provide
      additional benefit beyond what the QName index does, with a small
      additional cost in terms of index size.  We also described some other
      index-based optimizations that Lux applies.
    </para><para>
      The indexing techniques described here are not unique to
      Lux. Although we're not aware of any existing use of proximity
      queries to match path constraints, it's a natural enough idea and is
      almost certainly in use in other systems as well. The main innovation
      here is the application of XML-unaware indexing technology to
      accelerate XML-aware queries, and the new combination of existing
      open source software packages to provide a reliable and powerful
      indexing and query system.  Leveraging existing technology decreases
      the amount of code that needs to be maintained and tested, and leads
      to a high quality product with less effort than might otherwise be
      required.
    </para></section><bibliography><title>Bibliography</title><bibliomixed>
      <link xlink:href="http://www.balisage.net/Proceedings/vol8/html/Dubinko01/BalisageVol8-Dubinko01.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Exploring
      the Unknown</link>, Micah Dubinko, 2012 Balisage conference proceedings, doi:<biblioid class="doi">10.4242/BalisageVol8.Dubinko01</biblioid>.
    </bibliomixed><bibliomixed>
      <link xlink:href="http://docs.marklogic.com/guide/admin/text_index#chapter" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">MarkLogic Admin Guide</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://exist-db.org/exist/apps/doc/indexing.xml" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">eXist indexing documentation</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://docs.basex.org/wiki/Indexes#Resource_Index" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">BaseX Indexes</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://msdn.microsoft.com/en-us/library/ms191497.aspx" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">SQL
      Server XML index documentation</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28369/xdb_indexing.htm#CHDFCGGI" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Oracle XML index documentation</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://www.ibiblio.org/xml/examples/shakespeare/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Shakespeare in XML</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://luxdb.org/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Lux web site (high-level
      documentation)</link>
    </bibliomixed><bibliomixed>
      <link xlink:href="http://github.com/msokolov/lux/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Lux repository (source code and documentation)</link>
    </bibliomixed></bibliography></article>