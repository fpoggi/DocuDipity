<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">icXML:  Accelerating a Commercial XML
     Parser Using SIMD and Multicore Technologies</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2013</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 6 - 9, 2013</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Prior research on the acceleration of XML processing using single-instruction
	   multiple-data (SIMD) and multi-core
            parallelism has lead to a number of interesting research prototypes. This work is
	    the first to investigate to the extent to which the techniques underlying these prototypes 
	    could result
            in systematic performance benefits when fully integrated into a commercial XML parser
            The widely used Xerces-C++ parser of the Apache Software Foundation was chosen as the
            foundation for the study. A systematic restructuring of the parser was undertaken, while
            maintaining the existing API for application programmers. Using SIMD techniques alone,
            an increase in parsing speed of at least 50% was observed in a range of applications.
            When coupled with pipeline parallelism on dual core processors, improvements of 2x and
            beyond were realized. 
	    
	    icXML is intended as an important industrial contribution in its own right as well
	    as an important case study for the underlying Parabix parallel processing framework.
	    Based on the success of the icXML development, there is a strong case for continued
	    development of that framework as well as for the application of that framework
	    to other important XML technology stacks.   An important area for further work is
	    the extension of Parabix technology to accelerate Java-based implementations as
	    well as ones based on C/C++.
	    
	    </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Nigel</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Medforth</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Nigel Medforth is a M.Sc. student at Simon Fraser University and the lead
               developer of icXML. He earned a Bachelor of Technology in Information Technology at
               Kwantlen Polytechnic University in 2009 and was awarded the Deanâ€™s Medal for
               Outstanding Achievement.</textual></para><para class="po-block e14 e14"><textual class="po-textual">Nigel is currently researching ways to leverage both the Parabix framework and
               stream-processing models to further accelerate XML parsing within icXML.</textual></para></personblurb><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Developer</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">International Characters Inc.</textual></orgname></affiliation><affiliation class="po-record e18 e18"><jobtitle class="po-field e19 e19"><textual class="po-textual">Graduate Student</textual></jobtitle><orgname class="po-block e20 e20"><textual class="po-textual">School of Computing Science, Simon Fraser University </textual></orgname></affiliation><email class="po-field e21 e21"><textual class="po-textual">nmedfort@sfu.ca</textual></email></author><author class="po-record e22 e22"><personname class="po-record e23 e23"><firstname class="po-field e24 e24"><textual class="po-textual">Dan</textual></firstname><surname class="po-field e25 e25"><textual class="po-textual">Lin</textual></surname></personname><personblurb class="po-container e26 e26"><para class="po-block e27 e27"><textual class="po-textual">Dan Lin is a Ph.D student at Simon Fraser University. She earned a Master of Science
	     in Computing Science at Simon Fraser University in 2010. Her research focus on on high 
	     performance algorithms that exploit parallelization strategies on various multicore platforms.
	   </textual></para></personblurb><affiliation class="po-record e28 e28"><jobtitle class="po-field e29 e29"><textual class="po-textual">Graduate Student</textual></jobtitle><orgname class="po-block e30 e30"><textual class="po-textual">School of Computing Science, Simon Fraser University </textual></orgname></affiliation><email class="po-field e31 e31"><textual class="po-textual">lindanl@sfu.ca</textual></email></author><author class="po-record e32 e32"><personname class="po-record e33 e33"><firstname class="po-field e34 e34"><textual class="po-textual">Kenneth</textual></firstname><surname class="po-field e35 e35"><textual class="po-textual">Herdy</textual></surname></personname><personblurb class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual"> Ken Herdy completed an Advanced Diploma of Technology in Geographical Information
               Systems at the British Columbia Institute of Technology in 2003 and earned a Bachelor
               of Science in Computing Science with a Certificate in Spatial Information Systems at
               Simon Fraser University in 2005. </textual></para><para class="po-block e38 e38"><textual class="po-textual"> Ken is currently pursuing PhD studies in Computing Science at Simon Fraser
               University with industrial scholarship support from the Natural Sciences and
               Engineering Research Council of Canada, the Mathematics of Information Technology and
               Complex Systems NCE, and the BC Innovation Council. His research focus is an analysis
               of the principal techniques that may be used to improve XML processing performance in
               the context of the Geography Markup Language (GML). </textual></para></personblurb><affiliation class="po-record e39 e39"><jobtitle class="po-field e40 e40"><textual class="po-textual">Graduate Student</textual></jobtitle><orgname class="po-block e41 e41"><textual class="po-textual">School of Computing Science, Simon Fraser University </textual></orgname></affiliation><email class="po-field e42 e42"><textual class="po-textual">ksherdy@sfu.ca</textual></email></author><author class="po-record e43 e43"><personname class="po-record e44 e44"><firstname class="po-field e45 e45"><textual class="po-textual">Rob</textual></firstname><surname class="po-field e46 e46"><textual class="po-textual">Cameron</textual></surname></personname><personblurb class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Dr. Rob Cameron is Professor of Computing Science and Associate Dean of Applied
               Sciences at Simon Fraser University. His research interests include programming
               language and software system technology, with a specific focus on high performance
               text processing using SIMD and multicore parallelism. He is the developer of the REX
               XML shallow parser as well as the parallel bit stream (Parabix) framework for SIMD
               text processing. </textual></para></personblurb><affiliation class="po-record e49 e49"><jobtitle class="po-field e50 e50"><textual class="po-textual">Professor of Computing Science</textual></jobtitle><orgname class="po-block e51 e51"><textual class="po-textual">Simon Fraser University</textual></orgname></affiliation><affiliation class="po-record e52 e52"><jobtitle class="po-field e53 e53"><textual class="po-textual">Chief Technology Officer</textual></jobtitle><orgname class="po-block e54 e54"><textual class="po-textual">International Characters, Inc.</textual></orgname></affiliation><email class="po-field e55 e55"><textual class="po-textual">cameron@cs.sfu.ca</textual></email></author><author class="po-record e56 e56"><personname class="po-record e57 e57"><firstname class="po-field e58 e58"><textual class="po-textual">Arrvindh</textual></firstname><surname class="po-field e59 e59"><textual class="po-textual">Shriraman</textual></surname></personname><personblurb class="po-container e60 e60"><para class="po-block e61 e61"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e62 e62"><jobtitle class="po-field e63 e63"><textual class="po-textual">Assistant Professor</textual></jobtitle><orgname class="po-block e64 e64"><textual class="po-textual">School of Computing Science, Simon Fraser University</textual></orgname></affiliation><email class="po-field e65 e65"><textual class="po-textual">ashriram.cs.sfu.ca</textual></email></author><legalnotice class="po-container e66 e66"><para class="po-block e67 e67"><textual class="po-textual">This work is licensed under a Creative Commons Attribution-Noncommercial-No Derivative
            Works 2.5 Canada License (</textual><link class="po-inline e68 e68" xlink:actuate="onRequest" xlink:href="http://creativecommons.org/licenses/by-nc-nd/2.5/ca/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://creativecommons.org/licenses/by-nc-nd/2.5/ca/</textual></link><textual class="po-textual">).</textual></para></legalnotice></info><section class="po-hcontainer e69 e69"><title class="po-block e70 e70"><textual class="po-textual">Introduction</textual></title><para class="po-block e71 e71"><textual class="po-textual">    
	Parallelization and acceleration of XML parsing is a widely
	studied problem that has seen the development of a number
	of interesting research prototypes using both single-instruction
	   multiple-data (SIMD) and
	multi-core parallelism.   Most works have investigated
	data parallel solutions on multicore
	architectures using various strategies to break input
	documents into segments that can be allocated to different cores.
	For example, one possibility for data
	parallelization is to add a pre-parsing step to compute
	a skeleton tree structure of an  XML document </textual><citation class="po-atom e72 e72" linkend="GRID2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	The parallelization of the pre-parsing stage itself can be tackled with 
	  state machines </textual><citation class="po-atom e73 e73" linkend="E-SCIENCE2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, </textual><citation class="po-atom e74 e74" linkend="IPDPS2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	Methods without pre-parsing have used speculation </textual><citation class="po-atom e75 e75" linkend="HPCC2011"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> or post-processing that 
	combines the partial results </textual><citation class="po-atom e76 e76" linkend="ParaDOM2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	A hybrid technique that combines data and pipeline parallelism was proposed to 
	hide the latency of a "job" that has to be done sequentially </textual><citation class="po-atom e77 e77" linkend="ICWS2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
      </textual></para><para class="po-block e78 e78"><textual class="po-textual">
	Fewer efforts have investigated SIMD parallelism, although this approach
	has the potential advantage of improving single core performance as well
	as offering savings in energy consumption </textual><citation class="po-atom e79 e79" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	Intel introduced specialized SIMD string processing instructions in the SSE 4.2 instruction set extension 
	and showed how they can be used to improve the performance of XML parsing </textual><citation class="po-atom e80 e80" linkend="XMLSSE42"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	The Parabix framework uses generic SIMD extensions and bit parallel methods to 
	process hundreds of XML input characters simultaneously </textual><citation class="po-atom e81 e81" linkend="Cameron2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> </textual><citation class="po-atom e82 e82" linkend="cameron-EuroPar2011"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
	Parabix prototypes have also combined SIMD methods with thread-level parallelism to 
	achieve further acceleration on multicore systems </textual><citation class="po-atom e83 e83" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">.
      </textual></para><para class="po-block e84 e84"><textual class="po-textual">
	In this paper, we move beyond research prototypes to consider
	the detailed integration of both SIMD and multicore parallelism into the 
	Xerces-C++ parser of the Apache Software Foundation, an existing
	standards-compliant open-source parser that is widely used
	in commercial practice.    The challenge of this work is
	to parallelize the Xerces parser in such a way as to
	preserve the existing APIs as well as offering worthwhile 
	end-to-end acceleration of XML processing.    
	To achieve the best results possible, we undertook
	a nine-month comprehensive restructuring of the Xerces-C++ parser,
	seeking to expose as many critical aspects of XML parsing
	as possible for parallelization, the result of which we named icXML.   
	Overall, we employed Parabix-style methods of transcoding, tokenization
	and tag parsing, parallel string comparison methods in symbol
	resolution, bit parallel methods in namespace processing, 
	as well as staged processing using pipeline parallelism to take advantage of
	multiple cores.
      </textual></para><para class="po-block e85 e85"><textual class="po-textual">
	The remainder of this paper is organized as follows.   
	  </textual><xref class="po-milestone e86 e86" linkend="background"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> discusses the structure of the Xerces and Parabix XML parsers and the fundamental
	differences between the two parsing models.   
	</textual><xref class="po-milestone e87 e87" linkend="architecture"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> then presents the icXML design based on a restructured Xerces architecture to 
	incorporate SIMD parallelism using Parabix methods.   
	</textual><xref class="po-milestone e88 e88" linkend="multithread"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> moves on to consider the multithreading of the icXML architecture
	using the pipeline parallelism model.  
	</textual><xref class="po-milestone e89 e89" linkend="performance"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> analyzes the performance of both the single-threaded and
	multi-threaded versions of icXML in comparison to original Xerces,
	demonstrating substantial end-to-end acceleration of
	a GML-to-SVG translation application written against the Xerces API.
	  </textual><xref class="po-milestone e90 e90" linkend="conclusion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> concludes the paper with a discussion of future work and the potential for 
	applying the techniques discussed herein in other application domains.
      </textual></para></section><section class="po-hcontainer e91 e91" xml:id="background"><title class="po-block e92 e92"><textual class="po-textual">Background</textual></title><section class="po-hcontainer e93 e93" xml:id="background-xerces"><title class="po-block e94 e94"><textual class="po-textual">Xerces C++ Structure</textual></title><para class="po-block e95 e95"><textual class="po-textual"> The Xerces C++ parser is a widely-used standards-conformant
            XML parser produced as open-source software
             by the Apache Software Foundation.
            It features comprehensive support for a variety of character encodings both
            commonplace (e.g., UTF-8, UTF-16) and rarely used (e.g., EBCDIC), support for multiple
            XML vocabularies through the XML namespace mechanism, as well as complete
            implementations of structure and data validation through multiple grammars declared
            using either legacy DTDs (document type definitions) or modern XML Schema facilities.
            Xerces also supports several APIs for accessing parser services, including event-based
            parsing using either pull parsing or SAX/SAX2 push-style parsing as well as a DOM
            tree-based parsing interface. </textual></para><para class="po-block e96 e96"><textual class="po-textual">
            Xerces,
            like all traditional parsers, processes XML documents sequentially a byte-at-a-time from
            the first to the last byte of input data. Each byte passes through several processing
            layers and is classified and eventually validated within the context of the document
            state. This introduces implicit dependencies between the various tasks within the
            application that make it difficult to optimize for performance. As a complex software
	      system, no one feature dominates the overall parsing performance. </textual><xref class="po-milestone e97 e97" linkend="xerces-profile"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
	    shows the execution time profile of the top ten functions in a
            typical run. Even if it were possible, Amdahl's Law dictates that tackling any one of
            these functions for parallelization in isolation would only produce a minute improvement
            in performance. Unfortunately, early investigation into these functions found that
            incorporating speculation-free thread-level parallelization was impossible and they were
            already performing well in their given tasks; thus only trivial enhancements were
            attainable. In order to obtain a systematic acceleration of Xerces, it should be
            expected that a comprehensive restructuring is required, involving all aspects of the
            parser. </textual></para><table class="po-container e98 e98" xml:id="xerces-profile"><caption class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">Execution Time of Top 10 Xerces Functions</textual></para></caption><colgroup class="po-null e101 e101" span="1"><col align="left" class="po-meta e102 e102" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e103 e103" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e104 e104"><tr class="po-table e105 e105"><th class="po-field e106 e106"><textual class="po-textual">Time (%) </textual></th><th class="po-field e107 e107"><textual class="po-textual"> Function Name </textual></th></tr></thead><tbody class="po-table e108 e108"><tr class="po-table e109 e109" valign="top"><td class="po-block e110 e110"><textual class="po-textual">13.29	</textual></td><td class="po-block e111 e111"><textual class="po-textual">XMLUTF8Transcoder::transcodeFrom </textual></td></tr><tr class="po-table e112 e112" valign="top"><td class="po-block e113 e113"><textual class="po-textual">7.45	</textual></td><td class="po-block e114 e114"><textual class="po-textual">IGXMLScanner::scanCharData </textual></td></tr><tr class="po-table e115 e115" valign="top"><td class="po-block e116 e116"><textual class="po-textual">6.83	</textual></td><td class="po-block e117 e117"><textual class="po-textual">memcpy </textual></td></tr><tr class="po-table e118 e118" valign="top"><td class="po-block e119 e119"><textual class="po-textual">5.83	</textual></td><td class="po-block e120 e120"><textual class="po-textual">XMLReader::getNCName </textual></td></tr><tr class="po-table e121 e121" valign="top"><td class="po-block e122 e122"><textual class="po-textual">4.67	</textual></td><td class="po-block e123 e123"><textual class="po-textual">IGXMLScanner::buildAttList </textual></td></tr><tr class="po-table e124 e124" valign="top"><td class="po-block e125 e125"><textual class="po-textual">4.54	</textual></td><td class="po-block e126 e126"><textual class="po-textual">RefHashTableO&lt;&gt;::findBucketElem </textual></td></tr><tr class="po-table e127 e127" valign="top"><td class="po-block e128 e128"><textual class="po-textual">4.20	</textual></td><td class="po-block e129 e129"><textual class="po-textual">IGXMLScanner::scanStartTagNS </textual></td></tr><tr class="po-table e130 e130" valign="top"><td class="po-block e131 e131"><textual class="po-textual">3.75	</textual></td><td class="po-block e132 e132"><textual class="po-textual">ElemStack::mapPrefixToURI </textual></td></tr><tr class="po-table e133 e133" valign="top"><td class="po-block e134 e134"><textual class="po-textual">3.58	</textual></td><td class="po-block e135 e135"><textual class="po-textual">ReaderMgr::getNextChar </textual></td></tr><tr class="po-table e136 e136" valign="top"><td class="po-block e137 e137"><textual class="po-textual">3.20	</textual></td><td class="po-block e138 e138"><textual class="po-textual">IGXMLScanner::basicAttrValueScan </textual></td></tr></tbody></table></section><section class="po-hcontainer e139 e139"><title class="po-block e140 e140"><textual class="po-textual">The Parabix Framework</textual></title><para class="po-block e141 e141"><textual class="po-textual"> The Parabix (parallel bit stream) framework is a transformative approach to XML
            parsing (and other forms of text processing.) The key idea is to exploit the
            availability of wide SIMD registers (e.g., 128-bit) in commodity processors to represent
            data from long blocks of input data by using one register bit per single input byte. To
            facilitate this, the input data is first transposed into a set of basis bit streams. 
	      For example, </textual><xref class="po-milestone e142 e142" linkend="xml-bytes"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows  the ASCII bytes for the string "</textual><code class="po-atom e143 e143"><textual class="po-textual">b7&lt;A</textual></code><textual class="po-textual">" with
		the corresponding  8 basis bit streams, b</textual><subscript class="po-atom e144 e144"><textual class="po-textual">0</textual></subscript><textual class="po-textual"> through  b</textual><subscript class="po-atom e145 e145"><textual class="po-textual">7</textual></subscript><textual class="po-textual"> shown in  </textual><xref class="po-milestone e146 e146" linkend="xml-bits"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. 
            The bits used to construct b</textual><subscript class="po-atom e147 e147"><textual class="po-textual">7</textual></subscript><textual class="po-textual"> have been highlighted in this example.
	      Boolean-logic operations (âˆ§, âˆ¨ and Â¬ denote the
	      boolean AND, OR and NOT operators) are used to classify the input bits into a set of
               </textual><emphasis class="po-inline e148 e148" role="ital"><textual class="po-textual">character-class bit streams</textual></emphasis><textual class="po-textual">, which identify key
            characters (or groups of characters) with a </textual><code class="po-atom e149 e149"><textual class="po-textual">1</textual></code><textual class="po-textual">. For example, one of the
            fundamental characters in XML is a left-angle bracket. A character is an
               </textual><code class="po-atom e150 e150"><textual class="po-textual">'&lt;' if and only if
               Â¬(b</textual><subscript class="po-atom e151 e151"><textual class="po-textual">0</textual></subscript><textual class="po-textual"> âˆ¨ b</textual><subscript class="po-atom e152 e152"><textual class="po-textual">1</textual></subscript><textual class="po-textual">)
               âˆ§ (b</textual><subscript class="po-atom e153 e153"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> âˆ§ b</textual><subscript class="po-atom e154 e154"><textual class="po-textual">3</textual></subscript><textual class="po-textual">)
               âˆ§ (b</textual><subscript class="po-atom e155 e155"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> âˆ§ b</textual><subscript class="po-atom e156 e156"><textual class="po-textual">5</textual></subscript><textual class="po-textual">)
               âˆ§ Â¬ (b</textual><subscript class="po-atom e157 e157"><textual class="po-textual">6</textual></subscript><textual class="po-textual"> âˆ¨
               b</textual><subscript class="po-atom e158 e158"><textual class="po-textual">7</textual></subscript><textual class="po-textual">) = 1</textual></code><textual class="po-textual">. Similarly, a character is numeric, </textual><code class="po-atom e159 e159"><textual class="po-textual">[0-9]
               if and only if Â¬(b</textual><subscript class="po-atom e160 e160"><textual class="po-textual">0</textual></subscript><textual class="po-textual"> âˆ¨
               b</textual><subscript class="po-atom e161 e161"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) âˆ§ (b</textual><subscript class="po-atom e162 e162"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> âˆ§
                  b</textual><subscript class="po-atom e163 e163"><textual class="po-textual">3</textual></subscript><textual class="po-textual">) âˆ§ Â¬(b</textual><subscript class="po-atom e164 e164"><textual class="po-textual">4</textual></subscript><textual class="po-textual">
               âˆ§ (b</textual><subscript class="po-atom e165 e165"><textual class="po-textual">5</textual></subscript><textual class="po-textual"> âˆ¨
            b</textual><subscript class="po-atom e166 e166"><textual class="po-textual">6</textual></subscript><textual class="po-textual">))</textual></code><textual class="po-textual">. An important observation here is that ranges of
            characters may require fewer operations than individual characters and
            </textual><textual class="po-textual"> multiple
            classes can share the classification cost. </textual></para><table class="po-container e167 e167" xml:id="xml-bytes"><caption class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual">XML Source Data</textual></para></caption><colgroup class="po-null e170 e170" span="1"><col align="right" class="po-meta e171 e171" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e172 e172" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e173 e173" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e174 e174" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e175 e175" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e176 e176"><tr class="po-table e177 e177"><td class="po-block e178 e178"><textual class="po-textual">String </textual></td><td class="po-block e179 e179"><textual class="po-textual"> </textual><code class="po-atom e180 e180"><textual class="po-textual">b</textual></code><textual class="po-textual"> </textual></td><td class="po-block e181 e181"><textual class="po-textual"> </textual><code class="po-atom e182 e182"><textual class="po-textual">7</textual></code><textual class="po-textual"> </textual></td><td class="po-block e183 e183"><textual class="po-textual"> </textual><code class="po-atom e184 e184"><textual class="po-textual">&lt;</textual></code><textual class="po-textual"> </textual></td><td class="po-block e185 e185"><textual class="po-textual"> </textual><code class="po-atom e186 e186"><textual class="po-textual">A</textual></code><textual class="po-textual"> </textual></td></tr><tr class="po-table e187 e187"><td class="po-block e188 e188"><textual class="po-textual">ASCII </textual></td><td class="po-block e189 e189"><textual class="po-textual"> </textual><code class="po-atom e190 e190"><textual class="po-textual">0110001</textual></code><emphasis class="po-inline e191 e191" role="bold"><code class="po-atom e192 e192"><textual class="po-textual">0</textual></code></emphasis><textual class="po-textual"> </textual></td><td class="po-block e193 e193"><textual class="po-textual"> </textual><code class="po-atom e194 e194"><textual class="po-textual">0011011</textual></code><emphasis class="po-inline e195 e195" role="bold"><code class="po-atom e196 e196"><textual class="po-textual">1</textual></code></emphasis></td><td class="po-block e197 e197"><textual class="po-textual"> </textual><code class="po-atom e198 e198"><textual class="po-textual">0011110</textual></code><emphasis class="po-inline e199 e199" role="bold"><code class="po-atom e200 e200"><textual class="po-textual">0</textual></code></emphasis></td><td class="po-block e201 e201"><textual class="po-textual"> </textual><code class="po-atom e202 e202"><textual class="po-textual">0100000</textual></code><emphasis class="po-inline e203 e203" role="bold"><code class="po-atom e204 e204"><textual class="po-textual">1</textual></code></emphasis></td></tr></tbody></table><table class="po-container e205 e205" xml:id="xml-bits"><caption class="po-container e206 e206"><para class="po-block e207 e207"><textual class="po-textual">8-bit ASCII Basis Bit Streams</textual></para></caption><colgroup class="po-null e208 e208" span="1"><col align="center" class="po-meta e209 e209" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e210 e210" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e211 e211" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e212 e212" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e213 e213" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e214 e214" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e215 e215" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e216 e216" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e217 e217"><tr class="po-table e218 e218"><td class="po-block e219 e219"><textual class="po-textual"> b</textual><subscript class="po-atom e220 e220"><textual class="po-textual">0</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e221 e221"><textual class="po-textual"> b</textual><subscript class="po-atom e222 e222"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e223 e223"><textual class="po-textual"> b</textual><subscript class="po-atom e224 e224"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e225 e225"><textual class="po-textual"> b</textual><subscript class="po-atom e226 e226"><textual class="po-textual">3</textual></subscript></td><td class="po-block e227 e227"><textual class="po-textual"> b</textual><subscript class="po-atom e228 e228"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e229 e229"><textual class="po-textual"> b</textual><subscript class="po-atom e230 e230"><textual class="po-textual">5</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e231 e231"><textual class="po-textual"> b</textual><subscript class="po-atom e232 e232"><textual class="po-textual">6</textual></subscript><textual class="po-textual"> </textual></td><td class="po-block e233 e233"><textual class="po-textual"> b</textual><subscript class="po-atom e234 e234"><textual class="po-textual">7</textual></subscript><textual class="po-textual"> </textual></td></tr><tr class="po-table e235 e235"><td class="po-block e236 e236"><textual class="po-textual"> </textual><code class="po-atom e237 e237"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e238 e238"><textual class="po-textual"> </textual><code class="po-atom e239 e239"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e240 e240"><textual class="po-textual"> </textual><code class="po-atom e241 e241"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e242 e242"><textual class="po-textual"> </textual><code class="po-atom e243 e243"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e244 e244"><textual class="po-textual"> </textual><code class="po-atom e245 e245"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e246 e246"><textual class="po-textual"> </textual><code class="po-atom e247 e247"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e248 e248"><textual class="po-textual"> </textual><code class="po-atom e249 e249"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e250 e250"><textual class="po-textual"> </textual><emphasis class="po-inline e251 e251" role="bold"><code class="po-atom e252 e252"><textual class="po-textual">0</textual></code></emphasis><textual class="po-textual"> </textual></td></tr><tr class="po-table e253 e253"><td class="po-block e254 e254"><textual class="po-textual"> </textual><code class="po-atom e255 e255"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e256 e256"><textual class="po-textual"> </textual><code class="po-atom e257 e257"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e258 e258"><textual class="po-textual"> </textual><code class="po-atom e259 e259"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e260 e260"><textual class="po-textual"> </textual><code class="po-atom e261 e261"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e262 e262"><textual class="po-textual"> </textual><code class="po-atom e263 e263"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e264 e264"><textual class="po-textual"> </textual><code class="po-atom e265 e265"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e266 e266"><textual class="po-textual"> </textual><code class="po-atom e267 e267"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e268 e268"><textual class="po-textual"> </textual><emphasis class="po-inline e269 e269" role="bold"><code class="po-atom e270 e270"><textual class="po-textual">1</textual></code></emphasis><textual class="po-textual"> </textual></td></tr><tr class="po-table e271 e271"><td class="po-block e272 e272"><textual class="po-textual"> </textual><code class="po-atom e273 e273"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e274 e274"><textual class="po-textual"> </textual><code class="po-atom e275 e275"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e276 e276"><textual class="po-textual"> </textual><code class="po-atom e277 e277"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e278 e278"><textual class="po-textual"> </textual><code class="po-atom e279 e279"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e280 e280"><textual class="po-textual"> </textual><code class="po-atom e281 e281"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e282 e282"><textual class="po-textual"> </textual><code class="po-atom e283 e283"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e284 e284"><textual class="po-textual"> </textual><code class="po-atom e285 e285"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e286 e286"><textual class="po-textual"> </textual><emphasis class="po-inline e287 e287" role="bold"><code class="po-atom e288 e288"><textual class="po-textual">0</textual></code></emphasis><textual class="po-textual"> </textual></td></tr><tr class="po-table e289 e289"><td class="po-block e290 e290"><textual class="po-textual"> </textual><code class="po-atom e291 e291"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e292 e292"><textual class="po-textual"> </textual><code class="po-atom e293 e293"><textual class="po-textual">1</textual></code><textual class="po-textual"> </textual></td><td class="po-block e294 e294"><textual class="po-textual"> </textual><code class="po-atom e295 e295"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e296 e296"><textual class="po-textual"> </textual><code class="po-atom e297 e297"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e298 e298"><textual class="po-textual"> </textual><code class="po-atom e299 e299"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e300 e300"><textual class="po-textual"> </textual><code class="po-atom e301 e301"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e302 e302"><textual class="po-textual"> </textual><code class="po-atom e303 e303"><textual class="po-textual">0</textual></code><textual class="po-textual"> </textual></td><td class="po-block e304 e304"><textual class="po-textual"> </textual><emphasis class="po-inline e305 e305" role="bold"><code class="po-atom e306 e306"><textual class="po-textual">1</textual></code></emphasis><textual class="po-textual"> </textual></td></tr></tbody></table><para class="po-block e307 e307"><textual class="po-textual"> Consider, for example, the XML source data stream shown in the first line of </textual><xref class="po-milestone e308 e308" linkend="derived"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
The remaining lines of this figure show
            several parallel bit streams that are computed in Parabix-style parsing, with each bit
            of each stream in one-to-one correspondence to the source character code units of the
            input stream. For clarity, 1 bits are denoted with 1 in each stream and 0 bits are
            represented as underscores. The first bit stream shown is that for the opening angle
            brackets that represent tag openers in XML. The second and third streams show a
            partition of the tag openers into start tag marks and end tag marks depending on the
            character immediately following the opener (i.e., "</textual><code class="po-atom e309 e309"><textual class="po-textual">/</textual></code><textual class="po-textual">") or
            not. The remaining three lines show streams that can be computed in subsequent parsing
            (using the technique of bitstream addition </textual><citation class="po-atom e310 e310" linkend="cameron-EuroPar2011"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">), namely streams
            marking the element names, attribute names and attribute values of tags. </textual></para><table class="po-container e311 e311" xml:id="derived"><caption class="po-container e312 e312"><para class="po-block e313 e313"><textual class="po-textual">XML Source Data and Derived Parallel Bit Streams</textual></para></caption><colgroup class="po-null e314 e314" span="1"><col align="center" class="po-meta e315 e315" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e316 e316" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e317 e317"><tr class="po-table e318 e318"><td class="po-block e319 e319"><textual class="po-textual"> Source Data </textual></td><td class="po-block e320 e320"><textual class="po-textual"> </textual><code class="po-atom e321 e321"><textual class="po-textual"> &lt;document&gt;fee&lt;element a1='fie' a2 = 'foe'&gt;&lt;/element&gt;fum&lt;/document&gt; </textual></code></td></tr><tr class="po-table e322 e322"><td class="po-block e323 e323"><textual class="po-textual"> Tag Openers </textual></td><td class="po-block e324 e324"><textual class="po-textual"> </textual><code class="po-atom e325 e325"><textual class="po-textual">1____________1____________________________1____________1__________</textual></code></td></tr><tr class="po-table e326 e326"><td class="po-block e327 e327"><textual class="po-textual"> Start Tag Marks </textual></td><td class="po-block e328 e328"><textual class="po-textual"> </textual><code class="po-atom e329 e329"><textual class="po-textual">_1____________1___________________________________________________</textual></code></td></tr><tr class="po-table e330 e330"><td class="po-block e331 e331"><textual class="po-textual"> End Tag Marks </textual></td><td class="po-block e332 e332"><textual class="po-textual"> </textual><code class="po-atom e333 e333"><textual class="po-textual">___________________________________________1____________1_________</textual></code></td></tr><tr class="po-table e334 e334"><td class="po-block e335 e335"><textual class="po-textual"> Empty Tag Marks </textual></td><td class="po-block e336 e336"><textual class="po-textual"> </textual><code class="po-atom e337 e337"><textual class="po-textual">__________________________________________________________________</textual></code></td></tr><tr class="po-table e338 e338"><td class="po-block e339 e339"><textual class="po-textual"> Element Names </textual></td><td class="po-block e340 e340"><textual class="po-textual"> </textual><code class="po-atom e341 e341"><textual class="po-textual">_11111111_____1111111_____________________________________________</textual></code></td></tr><tr class="po-table e342 e342"><td class="po-block e343 e343"><textual class="po-textual"> Attribute Names </textual></td><td class="po-block e344 e344"><textual class="po-textual"> </textual><code class="po-atom e345 e345"><textual class="po-textual">______________________11_______11_________________________________</textual></code></td></tr><tr class="po-table e346 e346"><td class="po-block e347 e347"><textual class="po-textual"> Attribute Values </textual></td><td class="po-block e348 e348"><textual class="po-textual"> </textual><code class="po-atom e349 e349"><textual class="po-textual">__________________________111________111__________________________</textual></code></td></tr></tbody></table><para class="po-block e350 e350"><textual class="po-textual"> Two intuitions may help explain how the Parabix approach can lead to improved XML
            parsing performance. The first is that the use of the full register width offers a
            considerable information advantage over sequential byte-at-a-time parsing. That is,
            sequential processing of bytes uses just 8 bits of each register, greatly limiting the
            processor resources that are effectively being used at any one time. The second is that
            byte-at-a-time loop scanning loops are actually often just computing a single bit of
            information per iteration: is the scan complete yet? Rather than computing these
            individual decision-bits, an approach that computes many of them in parallel (e.g., 128
            bytes at a time using 128-bit registers) should provide substantial benefit. </textual></para><para class="po-block e351 e351"><textual class="po-textual"> Previous studies have shown that the Parabix approach improves many aspects of XML
            processing, including transcoding </textual><citation class="po-atom e352 e352" linkend="Cameron2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, character classification and
            validation, tag parsing and well-formedness checking. The first Parabix parser used
            processor bit scan instructions to considerably accelerate sequential scanning loops for
            individual characters </textual><citation class="po-atom e353 e353" linkend="CameronHerdyLin2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. Recent work has incorporated a method
            of parallel scanning using bitstream addition </textual><citation class="po-atom e354 e354" linkend="cameron-EuroPar2011"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, as well as
            combining SIMD methods with 4-stage pipeline parallelism to further improve throughput
            </textual><citation class="po-atom e355 e355" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. Although these research prototypes handled the full syntax of
            schema-less XML documents, they lacked the functionality required by full XML parsers. </textual></para><para class="po-block e356 e356"><textual class="po-textual"> Commercial XML processors support transcoding of multiple character sets and can
            parse and validate against multiple document vocabularies. Additionally, they provide
            API facilities beyond those found in research prototypes, including the widely used SAX,
            SAX2 and DOM interfaces. </textual></para></section><section class="po-hcontainer e357 e357"><title class="po-block e358 e358"><textual class="po-textual">Sequential vs. Parallel Paradigm</textual></title><para class="po-block e359 e359"><textual class="po-textual"> Xercesâ€”like all traditional XML parsersâ€”processes XML documents
            sequentially. Each character is examined to distinguish between the XML-specific markup,
            such as a left angle bracket </textual><code class="po-atom e360 e360"><textual class="po-textual">"&lt;"</textual></code><textual class="po-textual">, and the content held within the
            document. As the parser progresses through the document, it alternates between markup
            scanning, validation and content processing modes. </textual></para><para class="po-block e361 e361"><textual class="po-textual"> In other words, Xerces belongs to an equivalence class of applications termed FSM
	   applications.</textual><footnote class="po-popup e362 e362" xml:id="FSM"><para class="po-block e363 e363"><textual class="po-textual">Herein FSM applications are considered software systems whose
            behaviour is defined by the inputs, current state and the events associated with
	      transitions of states.</textual></para></footnote><textual class="po-textual"> Each state transition indicates the processing context of
            subsequent characters. Unfortunately, textual data tends to be unpredictable and any
            character could induce a state transition. </textual></para><para class="po-block e364 e364"><textual class="po-textual"> Parabix-style XML parsers utilize a concept of layered processing. A block of source
            text is transformed into a set of lexical bitstreams, which undergo a series of
            operations that can be grouped into logical layers, e.g., transposition, character
            classification, and lexical analysis. Each layer is pipeline parallel and require
            neither speculation nor pre-parsing stages </textual><citation class="po-atom e365 e365" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. To meet the API requirements
            of the document-ordered Xerces output, the results of the Parabix processing layers must
            be interleaved to produce the equivalent behaviour. </textual></para></section></section><section class="po-hcontainer e366 e366" xml:id="architecture"><title class="po-block e367 e367"><textual class="po-textual">Architecture</textual></title><section class="po-hcontainer e368 e368"><title class="po-block e369 e369"><textual class="po-textual">Overview</textual></title><para class="po-block e370 e370"><textual class="po-textual"> icXML is more than an optimized version of Xerces. Many components were grouped,
            restructured and rearchitected with pipeline parallelism in mind. In this section, we
            highlight the core differences between the two systems. As shown in Figure
	      </textual><xref class="po-milestone e371 e371" linkend="xerces-arch"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Xerces is comprised of five main modules: the transcoder, reader,
            scanner, namespace binder, and validator. The </textual><emphasis class="po-inline e372 e372" role="ital"><textual class="po-textual">Transcoder</textual></emphasis><textual class="po-textual"> converts source data into UTF-16 before Xerces parses it as XML;
            the majority of the character set encoding validation is performed as a byproduct of
            this process. The </textual><emphasis class="po-inline e373 e373" role="ital"><textual class="po-textual">Reader</textual></emphasis><textual class="po-textual"> is responsible for the
            streaming and buffering of all raw and transcoded (UTF-16) text. It tracks the current
            line/column position,
            </textual><textual class="po-textual">
            performs line-break normalization and validates context-specific character set issues,
            such as tokenization of qualified-names. The </textual><emphasis class="po-inline e374 e374" role="ital"><textual class="po-textual">Scanner</textual></emphasis><textual class="po-textual">
            pulls data through the reader and constructs the intermediate representation (IR) of the
            document; it deals with all issues related to entity expansion, validates the XML
            well-formedness constraints and any character set encoding issues that cannot be
            completely handled by the reader or transcoder (e.g., surrogate characters, validation
            and normalization of character references, etc.) The </textual><emphasis class="po-inline e375 e375" role="ital"><textual class="po-textual">Namespace
               Binder</textual></emphasis><textual class="po-textual"> is a core piece of the element stack. It handles namespace scoping
            issues between different XML vocabularies. This allows the scanner to properly select
            the correct schema grammar structures. The </textual><emphasis class="po-inline e376 e376" role="ital"><textual class="po-textual">Validator</textual></emphasis><textual class="po-textual">
            takes the IR produced by the Scanner (and potentially annotated by the Namespace Binder)
            and assesses whether the final output matches the user-defined DTD and schema grammar(s)
            before passing it to the end-user. </textual></para><figure class="po-container e377 e377" xml:id="xerces-arch"><title class="po-block e378 e378"><textual class="po-textual">Xerces Architecture</textual></title><mediaobject class="po-container e379 e379"><imageobject class="po-container e380 e380"><imagedata class="po-meta e381 e381" fileref="../../../vol10/graphics/Cameron01/Cameron01-001.png" format="png" width="155cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e382 e382"><textual class="po-textual"> In icXML functions are grouped into logical components. As shown in 
             </textual><xref class="po-milestone e383 e383" linkend="xerces-arch"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, two major categories exist: (1) the Parabix Subsystem and (2) the
	       Markup Processor. All tasks in (1) use the Parabix Framework </textual><citation class="po-atom e384 e384" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, which
            represents data as a set of parallel bitstreams. The </textual><emphasis class="po-inline e385 e385" role="ital"><textual class="po-textual">Character Set
	      Adapter</textual></emphasis><textual class="po-textual">, discussed in </textual><xref class="po-milestone e386 e386" linkend="character-set-adapter"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, mirrors
            Xerces's Transcoder duties; however instead of producing UTF-16 it produces a set of
	      lexical bitstreams, similar to those shown in </textual><xref class="po-milestone e387 e387" linkend="CameronHerdyLin2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. These lexical
            bitstreams are later transformed into UTF-16 in the Content Stream Generator, after
            additional processing is performed. The first precursor to producing UTF-16 is the
               </textual><emphasis class="po-inline e388 e388" role="ital"><textual class="po-textual">Parallel Markup Parser</textual></emphasis><textual class="po-textual"> phase. It takes the lexical
            streams and produces a set of marker bitstreams in which a 1-bit identifies significant
            positions within the input data. One bitstream for each of the critical piece of
            information is created, such as the beginning and ending of start tags, end tags,
            element names, attribute names, attribute values and content. Intra-element
            well-formedness validation is performed as an artifact of this process. Like Xerces,
            icXML must provide the Line and Column position of each error. The </textual><emphasis class="po-inline e389 e389" role="ital"><textual class="po-textual">Line-Column Tracker</textual></emphasis><textual class="po-textual"> uses the lexical information to keep track of the
            document position(s) through the use of an optimized population count algorithm,
	      described in </textual><xref class="po-milestone e390 e390" linkend="errorhandling"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. From here, two data-independent
            branches exist: the Symbol Resolver and Content Preparation Unit. </textual></para><para class="po-block e391 e391"><textual class="po-textual"> A typical XML file contains few unique element and attribute namesâ€”but
            each of them will occur frequently. icXML stores these as distinct data structures,
            called symbols, each with their own global identifier (GID). Using the symbol marker
            streams produced by the Parallel Markup Parser, the </textual><emphasis class="po-inline e392 e392" role="ital"><textual class="po-textual">Symbol
               Resolver</textual></emphasis><textual class="po-textual"> scans through the raw data to produce a sequence of GIDs, called
            the </textual><emphasis class="po-inline e393 e393" role="ital"><textual class="po-textual">symbol stream</textual></emphasis><textual class="po-textual">. </textual></para><para class="po-block e394 e394"><textual class="po-textual"> The final components of the Parabix Subsystem are the </textual><emphasis class="po-inline e395 e395" role="ital"><textual class="po-textual">Content
               Preparation Unit</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e396 e396" role="ital"><textual class="po-textual">Content Stream
            Generator</textual></emphasis><textual class="po-textual">. The former takes the (transposed) basis bitstreams and selectively
            filters them, according to the information provided by the Parallel Markup Parser, and
	    the latter transforms the filtered streams into the tagged UTF-16 </textual><emphasis class="po-inline e397 e397" role="ital"><textual class="po-textual">content stream</textual></emphasis><textual class="po-textual">, discussed in </textual><xref class="po-milestone e398 e398" linkend="contentstream"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. </textual></para><para class="po-block e399 e399"><textual class="po-textual"> Combined, the symbol and content stream form icXML's compressed IR of the XML
            document. The </textual><emphasis class="po-inline e400 e400" role="ital"><textual class="po-textual">Markup Processor</textual></emphasis><textual class="po-textual">
	    parses the IR to
            validate and produce the sequential output for the end user. The </textual><emphasis class="po-inline e401 e401" role="ital"><textual class="po-textual">Final WF checker</textual></emphasis><textual class="po-textual"> performs inter-element well-formedness validation that
            would be too costly to perform in bit space, such as ensuring every start tag has a
            matching end tag. Xerces's namespace binding functionality is replaced by the </textual><emphasis class="po-inline e402 e402" role="ital"><textual class="po-textual">Namespace Processor</textual></emphasis><textual class="po-textual">. Unlike Xerces, it is a discrete phase
            that produces a series of URI identifiers (URI IDs), the </textual><emphasis class="po-inline e403 e403" role="ital"><textual class="po-textual">URI
               stream</textual></emphasis><textual class="po-textual">, which are associated with each symbol occurrence. This is
		 discussed in </textual><xref class="po-milestone e404 e404" linkend="namespace-handling"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Finally, the </textual><emphasis class="po-inline e405 e405" role="ital"><textual class="po-textual">Validation</textual></emphasis><textual class="po-textual"> layer implements the Xerces's validator. However,
            preprocessing associated with each symbol greatly reduces the work of this stage. </textual></para><figure class="po-container e406 e406" xml:id="icxml-arch"><title class="po-block e407 e407"><textual class="po-textual">icXML Architecture</textual></title><mediaobject class="po-container e408 e408"><imageobject class="po-container e409 e409"><imagedata class="po-meta e410 e410" fileref="../../../vol10/graphics/Cameron01/Cameron01-002.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></section><section class="po-hcontainer e411 e411" xml:id="character-set-adapter"><title class="po-block e412 e412"><textual class="po-textual">Character Set Adapters</textual></title><para class="po-block e413 e413"><textual class="po-textual"> In Xerces, all input is transcoded into UTF-16 to simplify the parsing costs of
            Xerces itself and provide the end-consumer with a single encoding format. In the
            important case of UTF-8 to UTF-16 transcoding, the transcoding costs can be significant,
            because of the need to decode and classify each byte of input, mapping variable-length
            UTF-8 byte sequences into 16-bit UTF-16 code units with bit manipulation operations. In
            other cases, transcoding may involve table look-up operations for each byte of input. In
            any case, transcoding imposes at least a cost of buffer copying. </textual></para><para class="po-block e414 e414"><textual class="po-textual"> In icXML, however, the concept of Character Set Adapters (CSAs) is used to minimize
            transcoding costs. Given a specified input encoding, a CSA is responsible for checking
            that input code units represent valid characters, mapping the characters of the encoding
            into the appropriate bitstreams for XML parsing actions (i.e., producing the lexical
            item streams), as well as supporting ultimate transcoding requirements. All of this work
            is performed using the parallel bitstream representation of the source input. </textual></para><para class="po-block e415 e415"><textual class="po-textual"> An important observation is that many character sets are an extension to the legacy
            7-bit ASCII character set. This includes the various ISO Latin character sets, UTF-8,
            UTF-16 and many others. Furthermore, all significant characters for parsing XML are
            confined to the ASCII repertoire. Thus, a single common set of lexical item calculations
            serves to compute lexical item streams for all such ASCII-based character sets. </textual></para><para class="po-block e416 e416"><textual class="po-textual"> A second observation is thatâ€”regardless of which character set is
            usedâ€”quite often all of the characters in a particular block of input will be
            within the ASCII range. This is a very simple test to perform using the bitstream
            representation, simply confirming that the bit 0 stream is zero for the entire block.
            For blocks satisfying this test, all logic dealing with non-ASCII characters can simply
            be skipped. Transcoding to UTF-16 becomes trivial as the high eight bitstreams of the
            UTF-16 form are each set to zero in this case. </textual></para><para class="po-block e417 e417"><textual class="po-textual"> A third observation is that repeated transcoding of the names of XML elements,
            attributes and so on can be avoided by using a look-up mechanism. That is, the first
            occurrence of each symbol is stored in a look-up table mapping the input encoding to a
            numeric symbol ID. Transcoding of the symbol is applied at this time. Subsequent look-up
            operations can avoid transcoding by simply retrieving the stored representation. As
            symbol look up is required to apply various XML validation rules, there is achieves the
            effect of transcoding each occurrence without additional cost. </textual></para><para class="po-block e418 e418"><textual class="po-textual"> The cost of individual character transcoding is avoided whenever a block of input is
            confined to the ASCII subset and for all but the first occurrence of any XML element or
            attribute name. Furthermore, when transcoding is required, the parallel bitstream
            representation supports efficient transcoding operations. In the important case of UTF-8
            to UTF-16 transcoding, the corresponding UTF-16 bitstreams can be calculated in bit
	      parallel fashion based on UTF-8 streams </textual><citation class="po-atom e419 e419" linkend="Cameron2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, and all but the final bytes
            of multi-byte sequences can be marked for deletion as discussed in the following
            subsection. In other cases, transcoding within a block only need be applied for
            non-ASCII bytes, which are conveniently identified by iterating through the bit 0 stream
            using bit scan operations. </textual></para></section><section class="po-hcontainer e420 e420" xml:id="par-filter"><title class="po-block e421 e421"><textual class="po-textual">Combined Parallel Filtering</textual></title><para class="po-block e422 e422"><textual class="po-textual"> As just mentioned, UTF-8 to UTF-16 transcoding involves marking all but the last
            bytes of multi-byte UTF-8 sequences as positions for deletion. For example, the two
            Chinese characters </textual><code class="po-atom e423 e423"><textual class="po-textual">ä½ å¥½</textual></code><textual class="po-textual"> are represented as two
            three-byte UTF-8 sequences </textual><code class="po-atom e424 e424"><textual class="po-textual">E4 BD A0</textual></code><textual class="po-textual"> and </textual><code class="po-atom e425 e425"><textual class="po-textual">E5 A5 BD</textual></code><textual class="po-textual"> while the
            UTF-16 representation must be compressed down to the two code units </textual><code class="po-atom e426 e426"><textual class="po-textual">4F60</textual></code><textual class="po-textual">
            and </textual><code class="po-atom e427 e427"><textual class="po-textual">597D</textual></code><textual class="po-textual">. In the bit parallel representation, this corresponds to a
            reduction from six bit positions representing UTF-8 code units (bytes) down to just two
            bit positions representing UTF-16 code units (double bytes). This compression may be
            achieved by arranging to calculate the correct UTF-16 bits at the final position of each
            sequence and creating a deletion mask to mark the first two bytes of each 3-byte
            sequence for deletion. In this case, the portion of the mask corresponding to these
            input bytes is the bit sequence </textual><code class="po-atom e428 e428"><textual class="po-textual">110110</textual></code><textual class="po-textual">. Using this approach, transcoding
            may then be completed by applying parallel deletion and inverse transposition of the
            UTF-16 bitstreams </textual><citation class="po-atom e429 e429" linkend="Cameron2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. </textual></para><para class="po-block e430 e430"><textual class="po-textual"> Rather than immediately paying the costs of deletion and transposition just for
            transcoding, however, icXML defers these steps so that the deletion masks for several
            stages of processing may be combined. In particular, this includes core XML requirements
            to normalize line breaks and to replace character reference and entity references by
            their corresponding text. In the case of line break normalization, all forms of line
            breaks, including bare carriage returns (CR), line feeds (LF) and CR-LF combinations
            must be normalized to a single LF character in each case. In icXML, this is achieved by
            first marking CR positions, performing two bit parallel operations to transform the
            marked CRs into LFs, and then marking for deletion any LF that is found immediately
            after the marked CR as shown by the Pablo source code in 
	      </textual><xref class="po-milestone e431 e431" linkend="fig-LBnormalization"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.
	      </textual><figure class="po-container e432 e432" xml:id="fig-LBnormalization"><title class="po-block e433 e433"><textual class="po-textual">Line Break Normalization Logic</textual></title><programlisting class="po-block e434 e434" xml:space="preserve"><textual class="po-textual">
# XML 1.0 line-break normalization rules.
if lex.CR:
# Modify CR (#x0D) to LF (#x0A)
  u16lo.bit_5 ^= lex.CR
  u16lo.bit_6 ^= lex.CR
  u16lo.bit_7 ^= lex.CR
  CRLF = pablo.Advance(lex.CR) &amp; lex.LF
  callouts.delmask |= CRLF
# Adjust LF streams for line/column tracker
  lex.LF |= lex.CR
  lex.LF ^= CRLF
</textual></programlisting></figure><textual class="po-textual">
         </textual></para><para class="po-block e435 e435"><textual class="po-textual"> In essence, the deletion masks for transcoding and for line break normalization each
            represent a bitwise filter; these filters can be combined using bitwise-or so that the
            parallel deletion algorithm need only be applied once. </textual></para><para class="po-block e436 e436"><textual class="po-textual"> A further application of combined filtering is the processing of XML character and
	   entity references. Consider, for example, the references </textual><code class="po-atom e437 e437"><textual class="po-textual">&amp;amp;</textual></code><textual class="po-textual"> or
	     </textual><code class="po-atom e438 e438"><textual class="po-textual">&amp;#x3C;</textual></code><textual class="po-textual"> which must be replaced in XML processing with the single
               </textual><code class="po-atom e439 e439"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e440 e440"><textual class="po-textual">&lt;</textual></code><textual class="po-textual"> characters, respectively. The
            approach in icXML is to mark all but the first character positions of each reference for
            deletion, leaving a single character position unmodified. Thus, for the references
               </textual><code class="po-atom e441 e441"><textual class="po-textual">&amp;amp;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e442 e442"><textual class="po-textual">&amp;#x3C;</textual></code><textual class="po-textual"> the masks </textual><code class="po-atom e443 e443"><textual class="po-textual">01111</textual></code><textual class="po-textual"> and
               </textual><code class="po-atom e444 e444"><textual class="po-textual">011111</textual></code><textual class="po-textual"> are formed and combined into the overall deletion mask. After the
            deletion and inverse transposition operations are finally applied, a post-processing
            step inserts the proper character at these positions. One note about this process is
            that it is speculative; references are assumed to generally be replaced by a single
            UTF-16 code unit. In the case, that this is not true, it is addressed in
            post-processing. </textual></para><para class="po-block e445 e445"><textual class="po-textual"> The final step of combined filtering occurs during the process of reducing markup
            data to tag bytes preceding each significant XML transition as described in
	      </textual><xref class="po-milestone e446 e446" linkend="contentstream"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Overall, icXML avoids separate buffer copying
            operations for each of the these filtering steps, paying the cost of parallel deletion
            and inverse transposition only once. Currently, icXML employs the parallel-prefix
            compress algorithm of Steele </textual><citation class="po-atom e447 e447" linkend="HackersDelight"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. Performance is independent of the
            number of positions deleted. Future versions of icXML are expected to take advantage of
            the parallel extract operation </textual><citation class="po-atom e448 e448" linkend="HilewitzLee2006"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> that Intel is now providing in its
            Haswell architecture. </textual></para></section><section class="po-hcontainer e449 e449" xml:id="contentstream"><title class="po-block e450 e450"><textual class="po-textual">Content Stream</textual></title><para class="po-block e451 e451"><textual class="po-textual"> A relatively-unique concept for icXML is the use of a filtered content stream.
            Rather that parsing an XML document in its original format, the input is transformed
            into one that is easier for the parser to iterate through and produce the sequential
            output. In </textual><xref class="po-milestone e452 e452" linkend="fig-parabix2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the source data
	     </textual><code class="po-atom e453 e453"><textual class="po-textual"> &lt;document&gt;fee&lt;element a1='fie' a2 = 'foe'&gt;&lt;/element&gt;fum&lt;/document&gt;</textual></code><textual class="po-textual">
	     is transformed into 
           
         </textual><emphasis class="po-inline e454 e454" role="ital"><code class="po-atom e455 e455"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e456 e456"><textual class="po-textual">fee</textual></code><emphasis class="po-inline e457 e457" role="ital"><code class="po-atom e458 e458"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e459 e459"><textual class="po-textual">=fie</textual></code><emphasis class="po-inline e460 e460" role="ital"><code class="po-atom e461 e461"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e462 e462"><textual class="po-textual">=foe</textual></code><emphasis class="po-inline e463 e463" role="ital"><code class="po-atom e464 e464"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e465 e465"><textual class="po-textual">&gt;</textual></code><emphasis class="po-inline e466 e466" role="ital"><code class="po-atom e467 e467"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e468 e468"><textual class="po-textual">/fum</textual></code><emphasis class="po-inline e469 e469" role="ital"><code class="po-atom e470 e470"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e471 e471"><textual class="po-textual">/</textual></code><textual class="po-textual">
   </textual><textual class="po-textual">
            through the parallel filtering algorithm, described in </textual><xref class="po-milestone e472 e472" linkend="par-filter"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. </textual></para><table class="po-container e473 e473" xml:id="fig-parabix2"><caption class="po-container e474 e474"><para class="po-block e475 e475"><textual class="po-textual">XML Source Data and Derived Parallel Bit Streams</textual></para></caption><colgroup class="po-null e476 e476" span="1"><col align="center" class="po-meta e477 e477" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e478 e478" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e479 e479"><tr class="po-table e480 e480"><td class="po-block e481 e481"><textual class="po-textual"> Source Data </textual></td><td class="po-block e482 e482"><textual class="po-textual">
	                            </textual><code class="po-atom e483 e483"><textual class="po-textual"> &lt;document&gt;fee&lt;element a1='fie' a2 = 'foe'&gt;&lt;/element&gt;fum&lt;/document&gt; </textual></code></td></tr><tr class="po-table e484 e484"><td class="po-block e485 e485"><textual class="po-textual"> String Ends </textual></td><td class="po-block e486 e486"><textual class="po-textual"> </textual><code class="po-atom e487 e487"><textual class="po-textual">1____________1_______________1__________1_1____________1__________</textual></code></td></tr><tr class="po-table e488 e488"><td class="po-block e489 e489"><textual class="po-textual"> Markup Identifiers </textual></td><td class="po-block e490 e490"><textual class="po-textual">         </textual><code class="po-atom e491 e491"><textual class="po-textual">_________1______________1_________1______1_1____________1_________</textual></code></td></tr><tr class="po-table e492 e492"><td class="po-block e493 e493"><textual class="po-textual"> Deletion Mask </textual></td><td class="po-block e494 e494"><textual class="po-textual">              </textual><code class="po-atom e495 e495"><textual class="po-textual">_11111111_____1111111111_1____1111_11_______11111111_____111111111</textual></code></td></tr><tr class="po-table e496 e496"><td class="po-block e497 e497"><textual class="po-textual"> Undeleted Data </textual></td><td class="po-block e498 e498"><textual class="po-textual"> </textual><emphasis class="po-inline e499 e499" role="ital"><code class="po-atom e500 e500"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e501 e501"><textual class="po-textual">________&gt;fee</textual></code><emphasis class="po-inline e502 e502" role="ital"><code class="po-atom e503 e503"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e504 e504"><textual class="po-textual">__________=_fie</textual></code><emphasis class="po-inline e505 e505" role="ital"><code class="po-atom e506 e506"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e507 e507"><textual class="po-textual">____=__foe</textual></code><emphasis class="po-inline e508 e508" role="ital"><code class="po-atom e509 e509"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e510 e510"><textual class="po-textual">&gt;</textual></code><emphasis class="po-inline e511 e511" role="ital"><code class="po-atom e512 e512"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e513 e513"><textual class="po-textual">/________fum</textual></code><emphasis class="po-inline e514 e514" role="ital"><code class="po-atom e515 e515"><textual class="po-textual">0</textual></code></emphasis><code class="po-atom e516 e516"><textual class="po-textual">/_________</textual></code><textual class="po-textual">
   </textual><textual class="po-textual">
</textual></td></tr></tbody></table><para class="po-block e517 e517"><textual class="po-textual"> Combined with the symbol stream, the parser traverses the content stream to
            effectively reconstructs the input document in its output form. The initial </textual><emphasis class="po-inline e518 e518" role="ital"><textual class="po-textual">0</textual></emphasis><textual class="po-textual"> indicates an empty content string. The following
               </textual><code class="po-atom e519 e519"><textual class="po-textual">&gt;</textual></code><textual class="po-textual"> indicates that a start tag without any attributes is the first
            element in this text and the first unused symbol, </textual><code class="po-atom e520 e520"><textual class="po-textual">document</textual></code><textual class="po-textual">, is the element
            name. Succeeding that is the content string </textual><code class="po-atom e521 e521"><textual class="po-textual">fee</textual></code><textual class="po-textual">, which is null-terminated
            in accordance with the Xerces API specification. Unlike Xerces, no memory-copy
            operations are required to produce these strings, which as
	      </textual><xref class="po-milestone e522 e522" linkend="xerces-profile"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows accounts for 6.83% of Xerces's execution time.
            Additionally, it is cheap to locate the terminal character of each string: using the
            String End bitstream, the Parabix Subsystem can effectively calculate the offset of each
            null character in the content stream in parallel, which in turn means the parser can
            directly jump to the end of every string without scanning for it. </textual></para><para class="po-block e523 e523"><textual class="po-textual"> Following </textual><code class="po-atom e524 e524"><textual class="po-textual">'fee'</textual></code><textual class="po-textual"> is a </textual><code class="po-atom e525 e525"><textual class="po-textual">=</textual></code><textual class="po-textual">, which marks the
            existence of an attribute. Because all of the intra-element was performed in the Parabix
            Subsystem, this must be a legal attribute. Since attributes can only occur within start
            tags and must be accompanied by a textual value, the next symbol in the symbol stream
            must be the element name of a start tag, and the following one must be the name of the
            attribute and the string that follows the </textual><code class="po-atom e526 e526"><textual class="po-textual">=</textual></code><textual class="po-textual"> must be its value. However, the
            subsequent </textual><code class="po-atom e527 e527"><textual class="po-textual">=</textual></code><textual class="po-textual"> is not treated as an independent attribute because the parser
            has yet to read a </textual><code class="po-atom e528 e528"><textual class="po-textual">&gt;</textual></code><textual class="po-textual">, which marks the end of a start tag. Thus only
            one symbol is taken from the symbol stream and it (along with the string value) is added
            to the element. Eventually the parser reaches a </textual><code class="po-atom e529 e529"><textual class="po-textual">/</textual></code><textual class="po-textual">, which marks the
            existence of an end tag. Every end tag requires an element name, which means they
            require a symbol. Inter-element validation whenever an empty tag is detected to ensure
            that the appropriate scope-nesting rules have been applied. </textual></para></section><section class="po-hcontainer e530 e530" xml:id="namespace-handling"><title class="po-block e531 e531"><textual class="po-textual">Namespace Handling</textual></title><para class="po-block e532 e532"><textual class="po-textual"> In XML, namespaces prevents naming conflicts when multiple vocabularies are used
            together. It is especially important when a vocabulary application-dependant meaning,
            such as when XML or SVG documents are embedded within XHTML files. Namespaces are bound
            to uniform resource identifiers (URIs), which are strings used to identify specific
            names or resources. On line 1 in </textual><xref class="po-milestone e533 e533" linkend="namespace-ex"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the </textual><code class="po-atom e534 e534"><textual class="po-textual">xmlns</textual></code><textual class="po-textual">
            attribute instructs the XML processor to bind the prefix </textual><code class="po-atom e535 e535"><textual class="po-textual">p</textual></code><textual class="po-textual"> to the URI
               '</textual><code class="po-atom e536 e536"><textual class="po-textual">pub.net</textual></code><textual class="po-textual">' and the default (empty) prefix to
               </textual><code class="po-atom e537 e537"><textual class="po-textual">book.org</textual></code><textual class="po-textual">. Thus to the XML processor, the </textual><code class="po-atom e538 e538"><textual class="po-textual">title</textual></code><textual class="po-textual"> on line 2
            and </textual><code class="po-atom e539 e539"><textual class="po-textual">price</textual></code><textual class="po-textual"> on line 4 both read as
            </textual><code class="po-atom e540 e540"><textual class="po-textual">"book.org":title</textual></code><textual class="po-textual"> and
               </textual><code class="po-atom e541 e541"><textual class="po-textual">"book.org":price</textual></code><textual class="po-textual"> respectively, whereas on line 3 and
            5, </textual><code class="po-atom e542 e542"><textual class="po-textual">p:name</textual></code><textual class="po-textual"> and </textual><code class="po-atom e543 e543"><textual class="po-textual">price</textual></code><textual class="po-textual"> are seen as
               </textual><code class="po-atom e544 e544"><textual class="po-textual">"pub.net":name</textual></code><textual class="po-textual"> and
               </textual><code class="po-atom e545 e545"><textual class="po-textual">"pub.net":price</textual></code><textual class="po-textual">. Even though the actual element name
               </textual><code class="po-atom e546 e546"><textual class="po-textual">price</textual></code><textual class="po-textual">, due to namespace scoping rules they are viewed as two
            uniquely-named items because the current vocabulary is determined by the namespace(s)
            that are in-scope. </textual></para><table class="po-container e547 e547" xml:id="namespace-ex"><caption class="po-container e548 e548"><para class="po-block e549 e549"><textual class="po-textual">XML Namespace Example</textual></para></caption><colgroup class="po-null e550 e550" span="1"><col align="center" class="po-meta e551 e551" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e552 e552" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e553 e553"><tr class="po-table e554 e554"><td class="po-block e555 e555"><textual class="po-textual">1. </textual></td><td class="po-block e556 e556"><textual class="po-textual">&lt;book xmlns:p="pub.net" xmlns="book.org"&gt; </textual></td></tr><tr class="po-table e557 e557"><td class="po-block e558 e558"><textual class="po-textual">2. </textual></td><td class="po-block e559 e559"><textual class="po-textual">  &lt;title&gt;BOOK NAME&lt;/title&gt; </textual></td></tr><tr class="po-table e560 e560"><td class="po-block e561 e561"><textual class="po-textual">3. </textual></td><td class="po-block e562 e562"><textual class="po-textual">  &lt;p:name&gt;PUBLISHER NAME&lt;/p:name&gt; </textual></td></tr><tr class="po-table e563 e563"><td class="po-block e564 e564"><textual class="po-textual">4. </textual></td><td class="po-block e565 e565"><textual class="po-textual">  &lt;price&gt;X&lt;/price&gt; </textual></td></tr><tr class="po-table e566 e566"><td class="po-block e567 e567"><textual class="po-textual">5. </textual></td><td class="po-block e568 e568"><textual class="po-textual">  &lt;price xmlns="publisher.net"&gt;Y&lt;/price&gt; </textual></td></tr><tr class="po-table e569 e569"><td class="po-block e570 e570"><textual class="po-textual">6. </textual></td><td class="po-block e571 e571"><textual class="po-textual">&lt;/book&gt; </textual></td></tr></tbody></table><para class="po-block e572 e572"><textual class="po-textual"> In both Xerces and icXML, every URI has a one-to-one mapping to a URI ID. These
            persist for the lifetime of the application through the use of a global URI pool. Xerces
            maintains a stack of namespace scopes that is pushed (popped) every time a start tag
            (end tag) occurs in the document. Because a namespace declaration affects the entire
            element, it must be processed prior to grammar validation. This is a costly process
            considering that a typical namespaced XML document only comes in one of two forms: (1)
            those that declare a set of namespaces upfront and never change them, and (2) those that
            repeatedly modify the namespaces in predictable patterns. </textual></para><para class="po-block e573 e573"><textual class="po-textual"> For that reason, icXML contains an independent namespace stack and utilizes bit
            vectors to cheaply perform </textual><textual class="po-textual">
            </textual><textual class="po-textual"> When a prefix is
            declared (e.g., </textual><code class="po-atom e574 e574"><textual class="po-textual">xmlns:p="pub.net"</textual></code><textual class="po-textual">), a namespace binding
            is created that maps the prefix (which are assigned Prefix IDs in the symbol resolution
            process) to the URI. Each unique namespace binding has a unique namespace id (NSID) and
            every prefix contains a bit vector marking every NSID that has ever been associated with
	      it within the document. For example, in </textual><xref class="po-milestone e575 e575" linkend="namespace-ex"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the prefix binding
            set of </textual><code class="po-atom e576 e576"><textual class="po-textual">p</textual></code><textual class="po-textual"> and </textual><code class="po-atom e577 e577"><textual class="po-textual">xmlns</textual></code><textual class="po-textual"> would be </textual><code class="po-atom e578 e578"><textual class="po-textual">01</textual></code><textual class="po-textual"> and
            </textual><code class="po-atom e579 e579"><textual class="po-textual">11</textual></code><textual class="po-textual"> respectively. To resolve the in-scope namespace binding for each prefix,
            a bit vector of the currently visible namespaces is maintained by the system. By ANDing
            the prefix bit vector with the currently visible namespaces, the in-scope NSID can be
            found using a bit-scan intrinsic. A namespace binding table, similar to 
            </textual><xref class="po-milestone e580 e580" linkend="namespace-binding"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, provides the actual URI ID. </textual></para><table class="po-container e581 e581" xml:id="namespace-binding"><caption class="po-container e582 e582"><para class="po-block e583 e583"><textual class="po-textual">Namespace Binding Table Example</textual></para></caption><colgroup class="po-null e584 e584" span="1"><col align="center" class="po-meta e585 e585" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e586 e586" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e587 e587" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e588 e588" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e589 e589" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><thead class="po-container e590 e590"><tr class="po-table e591 e591"><th class="po-field e592 e592"><textual class="po-textual">NSID </textual></th><th class="po-field e593 e593"><textual class="po-textual"> Prefix </textual></th><th class="po-field e594 e594"><textual class="po-textual"> URI </textual></th><th class="po-field e595 e595"><textual class="po-textual"> Prefix ID </textual></th><th class="po-field e596 e596"><textual class="po-textual"> URI ID </textual></th></tr></thead><tbody class="po-table e597 e597"><tr class="po-table e598 e598"><td class="po-block e599 e599"><textual class="po-textual">0 </textual></td><td class="po-block e600 e600"><textual class="po-textual"> </textual><code class="po-atom e601 e601"><textual class="po-textual"> p</textual></code><textual class="po-textual"> </textual></td><td class="po-block e602 e602"><textual class="po-textual"> </textual><code class="po-atom e603 e603"><textual class="po-textual"> pub.net</textual></code><textual class="po-textual"> </textual></td><td class="po-block e604 e604"><textual class="po-textual"> 0 </textual></td><td class="po-block e605 e605"><textual class="po-textual"> 0 </textual></td></tr><tr class="po-table e606 e606"><td class="po-block e607 e607"><textual class="po-textual">1 </textual></td><td class="po-block e608 e608"><textual class="po-textual"> </textual><code class="po-atom e609 e609"><textual class="po-textual"> xmlns</textual></code><textual class="po-textual"> </textual></td><td class="po-block e610 e610"><textual class="po-textual"> </textual><code class="po-atom e611 e611"><textual class="po-textual"> books.org</textual></code><textual class="po-textual"> </textual></td><td class="po-block e612 e612"><textual class="po-textual"> 1 </textual></td><td class="po-block e613 e613"><textual class="po-textual"> 1 </textual></td></tr><tr class="po-table e614 e614"><td class="po-block e615 e615"><textual class="po-textual">2 </textual></td><td class="po-block e616 e616"><textual class="po-textual"> </textual><code class="po-atom e617 e617"><textual class="po-textual"> xmlns</textual></code><textual class="po-textual"> </textual></td><td class="po-block e618 e618"><textual class="po-textual"> </textual><code class="po-atom e619 e619"><textual class="po-textual"> pub.net</textual></code><textual class="po-textual"> </textual></td><td class="po-block e620 e620"><textual class="po-textual"> 1 </textual></td><td class="po-block e621 e621"><textual class="po-textual"> 0 </textual></td></tr></tbody></table><para class="po-block e622 e622"><textual class="po-textual">
            </textual><textual class="po-textual">
            </textual><textual class="po-textual">
            </textual><textual class="po-textual">
            </textual><textual class="po-textual">
         </textual></para><para class="po-block e623 e623"><textual class="po-textual"> To ensure that scoping rules are adhered to, whenever a start tag is encountered,
            any modification to the currently visible namespaces is calculated and stored within a
            stack of bit vectors denoting the locally modified namespace bindings. When an end tag
            is found, the currently visible namespaces is XORed with the vector at the top of the
            stack. This allows any number of changes to be performed at each scope-level with a
            constant time.
            </textual><textual class="po-textual">
         </textual></para></section><section class="po-hcontainer e624 e624" xml:id="errorhandling"><title class="po-block e625 e625"><textual class="po-textual">Error Handling</textual></title><para class="po-block e626 e626"><textual class="po-textual">
            </textual><textual class="po-textual">
            Xerces outputs error messages in two ways: through the programmer API and as thrown
            objects for fatal errors. As Xerces parses a file, it uses context-dependant logic to
            assess whether the next character is legal; if not, the current state determines the
            type and severity of the error. icXML emits errors in the similar mannerâ€”but
            how it discovers them is substantially different. Recall that in Figure
            </textual><xref class="po-milestone e627 e627" linkend="icxml-arch"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, icXML is divided into two sections: the Parabix Subsystem and
            Markup Processor, each with its own system for detecting and producing error messages. </textual></para><para class="po-block e628 e628"><textual class="po-textual"> Within the Parabix Subsystem, all computations are performed in parallel, a block at
            a time. Errors are derived as artifacts of bitstream calculations, with a 1-bit marking
            the byte-position of an error within a block, and the type of error is determined by the
            equation that discovered it. The difficulty of error processing in this section is that
            in Xerces the line and column number must be given with every error production. Two
            major issues exist because of this: (1) line position adheres to XML white-normalization
            rules; as such, some sequences of characters, e.g., a carriage return followed by a line
            feed, are counted as a single new line character. (2) column position is counted in
            characters, not bytes or code units; thus multi-code-unit code-points and surrogate
            character pairs are all counted as a single column position. Note that typical XML
            documents are error-free but the calculation of the line/column position is a constant
            overhead in Xerces. </textual><textual class="po-textual"> To
            reduce this, icXML pushes the bulk cost of the line/column calculation to the occurrence
            of the error and performs the minimal amount of book-keeping necessary to facilitate it.
            icXML leverages the byproducts of the Character Set Adapter (CSA) module and amalgamates
            the information within the Line Column Tracker (LCT). One of the CSA's major
            responsibilities is transcoding an input text.
            </textual><textual class="po-textual"> During this process,
            white-space normalization rules are applied and multi-code-unit and surrogate characters
            are detected and validated. A </textual><emphasis class="po-inline e629 e629" role="ital"><textual class="po-textual">line-feed bitstream</textual></emphasis><textual class="po-textual">,
            which marks the positions of the normalized new lines characters, is a natural
            derivative of this process. Using an optimized population count algorithm, the line
            count can be summarized cheaply for each valid block of text.
            </textual><textual class="po-textual"> Column position is more
            difficult to calculate. It is possible to scan backwards through the bitstream of new
            line characters to determine the distance (in code-units) between the position between
            which an error was detected and the last line feed. However, this distance may exceed
            than the actual character position for the reasons discussed in (2). To handle this, the
            CSA generates a </textual><emphasis class="po-inline e630 e630" role="ital"><textual class="po-textual">skip mask</textual></emphasis><textual class="po-textual"> bitstream by ORing together
            many relevant bitstreams, such as all trailing multi-code-unit and surrogate characters,
            and any characters that were removed during the normalization process. When an error is
            detected, the sum of those skipped positions is subtracted from the distance to
            determine the actual column number. </textual></para><para class="po-block e631 e631"><textual class="po-textual"> The Markup Processor is a state-driven machine. As such, error detection within it
            is very similar to Xerces. However, reporting the correct line/column is a much more
            difficult problem. The Markup Processor parses the content stream, which is a series of
            tagged UTF-16 strings. Each string is normalized in accordance with the XML
            specification. All symbol data and unnecessary whitespace is eliminated from the stream;
            thus its impossible to derive the current location using only the content stream. To
            calculate the location, the Markup Processor borrows three additional pieces of
            information from the Parabix Subsystem: the line-feed, skip mask, and a </textual><emphasis class="po-inline e632 e632" role="ital"><textual class="po-textual">deletion mask stream</textual></emphasis><textual class="po-textual">, which is a bitstream denoting the
            (code-unit) position of every datum that was suppressed from the source during the
            production of the content stream. Armed with these, it is possible to calculate the
            actual line/column using the same system as the Parabix Subsystem until the sum of the
            negated deletion mask stream is equal to the current position. </textual></para></section></section><section class="po-hcontainer e633 e633" xml:id="multithread"><title class="po-block e634 e634"><textual class="po-textual">Multithreading with Pipeline Parallelism</textual></title><para class="po-block e635 e635"><textual class="po-textual"> As discussed in section </textual><xref class="po-milestone e636 e636" linkend="background-xerces"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, Xerces can be considered a FSM
         application. These are "embarrassingly
         sequential."</textual><citation class="po-atom e637 e637" linkend="Asanovic-EECS-2006-183"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> and notoriously difficult to
         parallelize. However, icXML is designed to organize processing into logical layers. In
         particular, layers within the Parabix Subsystem are designed to operate over significant
         segments of input data before passing their outputs on for subsequent processing. This fits
         well into the general model of pipeline parallelism, in which each thread is in charge of a
         single module or group of modules. </textual></para><para class="po-block e638 e638"><textual class="po-textual"> The most straightforward division of work in icXML is to separate the Parabix Subsystem
         and the Markup Processor into distinct logical layers into two separate stages. The
         resultant application, </textual><emphasis class="po-inline e639 e639" role="ital"><textual class="po-textual">icXML-p</textual></emphasis><textual class="po-textual">, is a course-grained
         software-pipeline application. In this case, the Parabix Subsystem thread
               </textual><code class="po-atom e640 e640"><textual class="po-textual">T</textual><subscript class="po-atom e641 e641"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual"> reads 16k of XML input </textual><code class="po-atom e642 e642"><textual class="po-textual">I</textual></code><textual class="po-textual"> at a
         time and produces the content, symbol and URI streams, then stores them in a pre-allocated
         shared data structure </textual><code class="po-atom e643 e643"><textual class="po-textual">S</textual></code><textual class="po-textual">. The Markup Processor thread
            </textual><code class="po-atom e644 e644"><textual class="po-textual">T</textual><subscript class="po-atom e645 e645"><textual class="po-textual">2</textual></subscript></code><textual class="po-textual"> consumes </textual><code class="po-atom e646 e646"><textual class="po-textual">S</textual></code><textual class="po-textual">, performs well-formedness
         and grammar-based validation, and the provides parsed XML data to the application through
         the Xerces API. The shared data structure is implemented using a ring buffer, where every
         entry contains an independent set of data streams. In the examples of
	   </textual><xref class="po-milestone e647 e647" linkend="threads_timeline1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, the ring buffer has four entries. A
         lock-free mechanism is applied to ensure that each entry can only be read or written by one
         thread at the same time. In  </textual><xref class="po-milestone e648 e648" linkend="threads_timeline1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> the processing time of
               </textual><code class="po-atom e649 e649"><textual class="po-textual">T</textual><subscript class="po-atom e650 e650"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual"> is longer than
         </textual><code class="po-atom e651 e651"><textual class="po-textual">T</textual><subscript class="po-atom e652 e652"><textual class="po-textual">2</textual></subscript></code><textual class="po-textual">; thus </textual><code class="po-atom e653 e653"><textual class="po-textual">T</textual><subscript class="po-atom e654 e654"><textual class="po-textual">2</textual></subscript></code><textual class="po-textual"> always
         waits for </textual><code class="po-atom e655 e655"><textual class="po-textual">T</textual><subscript class="po-atom e656 e656"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual"> to write to the shared memory.  
	 </textual><xref class="po-milestone e657 e657" linkend="threads_timeline2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> illustrates the scenario in which
         </textual><code class="po-atom e658 e658"><textual class="po-textual">T</textual><subscript class="po-atom e659 e659"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual"> is faster and must wait for
            </textual><code class="po-atom e660 e660"><textual class="po-textual">T</textual><subscript class="po-atom e661 e661"><textual class="po-textual">2</textual></subscript></code><textual class="po-textual"> to finish reading the shared data before it can
         reuse the memory space. </textual></para><para class="po-block e662 e662"><textual class="po-textual">
	</textual><figure class="po-container e663 e663" xml:id="threads_timeline1"><title class="po-block e664 e664"><textual class="po-textual">Thread Balance in Two-Stage Pipelines: Stage 1 Dominant</textual></title><mediaobject class="po-container e665 e665"><imageobject class="po-container e666 e666"><imagedata class="po-meta e667 e667" fileref="../../../vol10/graphics/Cameron01/Cameron01-003.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
 	</textual><figure class="po-container e668 e668" xml:id="threads_timeline2"><title class="po-block e669 e669"><textual class="po-textual">Thread Balance in Two-Stage Pipelines: Stage 2 Dominant</textual></title><mediaobject class="po-container e670 e670"><imageobject class="po-container e671 e671"><imagedata class="po-meta e672 e672" fileref="../../../vol10/graphics/Cameron01/Cameron01-004.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e673 e673"><textual class="po-textual"> Overall, our design is intended to benefit a range of applications. Conceptually, we
         consider two design points. The first, the parsing performed by the Parabix Subsystem
         dominates at 67% of the overall cost, with the cost of application processing (including
         the driver logic within the Markup Processor) at 33%. The second is almost the opposite
         scenario, the cost of application processing dominates at 60%, while the cost of XML
         parsing represents an overhead of 40%. </textual></para><para class="po-block e674 e674"><textual class="po-textual"> Our design is predicated on a goal of using the Parabix framework to achieve a 50% to
         100% improvement in the parsing engine itself. In a best case scenario, a 100% improvement
         of the Parabix Subsystem for the design point in which XML parsing dominates at 67% of the
         total application cost. In this case, the single-threaded icXML should achieve a 1.5x
         speedup over Xerces so that the total application cost reduces to 67% of the original.
         However, in icXML-p, our ideal scenario gives us two well-balanced threads each performing
         about 33% of the original work. In this case, Amdahl's law predicts that we could expect up
         to a 3x speedup at best. </textual></para><para class="po-block e675 e675"><textual class="po-textual"> At the other extreme of our design range, we consider an application in which core
         parsing cost is 40%. Assuming the 2x speedup of the Parabix Subsystem over the
         corresponding Xerces core, single-threaded icXML delivers a 25% speedup. However, the most
         significant aspect of our two-stage multi-threaded design then becomes the ability to hide
         the entire latency of parsing within the serial time required by the application. In this
         case, we achieve an overall speedup in processing time by 1.67x. </textual></para><para class="po-block e676 e676"><textual class="po-textual"> Although the structure of the Parabix Subsystem allows division of the work into
         several pipeline stages and has been demonstrated to be effective for four pipeline stages
         in a research prototype </textual><citation class="po-atom e677 e677" linkend="HPCA2012"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, our analysis here suggests that the further
         pipelining of work within the Parabix Subsystem is not worthwhile if the cost of
         application logic is little as 33% of the end-to-end cost using Xerces. To achieve benefits
         of further parallelization with multi-core technology, there would need to be reductions in
         the cost of application logic that could match reductions in core parsing cost. </textual></para></section><section class="po-hcontainer e678 e678" xml:id="performance"><title class="po-block e679 e679"><textual class="po-textual">Performance</textual></title><para class="po-block e680 e680"><textual class="po-textual"> We evaluate Xerces-C++ 3.1.1, icXML, icXML-p against two benchmarking applications: the
         Xerces C++ SAXCount sample application, and a real world GML to SVG transformation
         application. We investigated XML parser performance using an Intel Core i7 quad-core (Sandy
         Bridge) processor (3.40GHz, 4 physical cores, 8 threads (2 per core), 32+32 kB (per core)
         L1 cache, 256 kB (per core) L2 cache, 8 MB L3 cache) running the 64-bit version of Ubuntu
         12.04 (Linux). </textual></para><para class="po-block e681 e681"><textual class="po-textual"> We analyzed the execution profiles of each XML parser using the performance counters
         found in the processor. We chose several key hardware events that provide insight into the
         profile of each application and indicate if the processor is doing useful work. The set of
         events included in our study are: processor cycles, branch instructions, branch
         mispredictions, and cache misses. The Performance Application Programming Interface (PAPI)
         Version 5.5.0 </textual><citation class="po-atom e682 e682" linkend="papi"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> toolkit was installed on the test system to facilitate the
         collection of hardware performance monitoring statistics. In addition, we used the Linux
         perf </textual><citation class="po-atom e683 e683" linkend="perf"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> utility to collect per core hardware events. </textual></para><section class="po-hcontainer e684 e684"><title class="po-block e685 e685"><textual class="po-textual">Xerces C++ SAXCount</textual></title><para class="po-block e686 e686"><textual class="po-textual"> Xerces comes with sample applications that demonstrate salient features of the
            parser. SAXCount is the simplest such application: it counts the elements, attributes
            and characters of a given XML file using the (event based) SAX API and prints out the
            totals. </textual></para><para class="po-block e687 e687"><textual class="po-textual"> </textual><xref class="po-milestone e688 e688" linkend="XMLdocs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows the document characteristics of the XML input files
            selected for the Xerces C++ SAXCount benchmark. The jaw.xml represents document-oriented
            XML inputs and contains the three-byte and four-byte UTF-8 sequence required for the
            UTF-8 encoding of Japanese characters. The remaining data files are data-oriented XML
            documents and consist entirely of single byte encoded ASCII characters. 
  </textual><table class="po-container e689 e689" xml:id="XMLdocs"><caption class="po-container e690 e690"><para class="po-block e691 e691"><textual class="po-textual">XML Document Characteristics</textual></para></caption><colgroup class="po-null e692 e692" span="1"><col align="left" class="po-meta e693 e693" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e694 e694" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e695 e695" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e696 e696" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="center" class="po-meta e697 e697" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col></colgroup><tbody class="po-table e698 e698"><tr class="po-table e699 e699"><td class="po-block e700 e700"><textual class="po-textual">File Name 		</textual></td><td class="po-block e701 e701"><textual class="po-textual"> jaw.xml	 	</textual></td><td class="po-block e702 e702"><textual class="po-textual"> road.gml 	</textual></td><td class="po-block e703 e703"><textual class="po-textual"> po.xml	</textual></td><td class="po-block e704 e704"><textual class="po-textual"> soap.xml </textual></td></tr><tr class="po-table e705 e705"><td class="po-block e706 e706"><textual class="po-textual">File Type 		</textual></td><td class="po-block e707 e707"><textual class="po-textual"> document 		</textual></td><td class="po-block e708 e708"><textual class="po-textual"> data		</textual></td><td class="po-block e709 e709"><textual class="po-textual"> data		</textual></td><td class="po-block e710 e710"><textual class="po-textual"> data	 </textual></td></tr><tr class="po-table e711 e711"><td class="po-block e712 e712"><textual class="po-textual">File Size (kB) 		</textual></td><td class="po-block e713 e713"><textual class="po-textual"> 7343 			</textual></td><td class="po-block e714 e714"><textual class="po-textual"> 11584 	</textual></td><td class="po-block e715 e715"><textual class="po-textual"> 76450		</textual></td><td class="po-block e716 e716"><textual class="po-textual"> 2717 </textual></td></tr><tr class="po-table e717 e717"><td class="po-block e718 e718"><textual class="po-textual">Markup Item Count 	</textual></td><td class="po-block e719 e719"><textual class="po-textual"> 74882 		</textual></td><td class="po-block e720 e720"><textual class="po-textual"> 280724  	</textual></td><td class="po-block e721 e721"><textual class="po-textual"> 4634110	</textual></td><td class="po-block e722 e722"><textual class="po-textual"> 18004 </textual></td></tr><tr class="po-table e723 e723"><td class="po-block e724 e724"><textual class="po-textual">Markup Density 		</textual></td><td class="po-block e725 e725"><textual class="po-textual"> 0.13 			</textual></td><td class="po-block e726 e726"><textual class="po-textual"> 0.57  	</textual></td><td class="po-block e727 e727"><textual class="po-textual"> 0.76		</textual></td><td class="po-block e728 e728"><textual class="po-textual"> 0.87	</textual></td></tr></tbody></table><textual class="po-textual">           
</textual></para><para class="po-block e729 e729"><textual class="po-textual"> A key predictor of the overall parsing performance of an XML file is markup
	   density</textual><footnote class="po-popup e730 e730"><para class="po-block e731 e731"><textual class="po-textual">Markup Density: the ratio of markup bytes used to define the structure
	     of the document vs. its file size.</textual></para></footnote><textual class="po-textual">. This metric has substantial influence on the
            performance of traditional recursive descent XML parsers because it directly corresponds
            to the number of state transitions that occur when parsing a document. We use a mixture
            of document-oriented and data-oriented XML files to analyze performance over a spectrum
            of markup densities. </textual></para><para class="po-block e732 e732"><textual class="po-textual"> </textual><xref class="po-milestone e733 e733" linkend="perf_SAX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> compares the performance of Xerces, icXML and pipelined icXML
            in terms of CPU cycles per byte for the SAXCount application. The speedup for icXML over
            Xerces is 1.3x to 1.8x. With two threads on the multicore machine, icXML-p can achieve
            speedup up to 2.7x. Xerces is substantially slowed by dense markup but icXML is less
            affected through a reduction in branches and the use of parallel-processing techniques.
            icXML-p performs better as markup-density increases because the work performed by each
            stage is well balanced in this application. </textual></para><para class="po-block e734 e734"><textual class="po-textual">
	</textual><figure class="po-container e735 e735" xml:id="perf_SAX"><title class="po-block e736 e736"><textual class="po-textual">SAXCount Performance Comparison</textual></title><mediaobject class="po-container e737 e737"><imageobject class="po-container e738 e738"><imagedata class="po-meta e739 e739" fileref="../../../vol10/graphics/Cameron01/Cameron01-005.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
         </textual></para></section><section class="po-hcontainer e740 e740"><title class="po-block e741 e741"><textual class="po-textual">GML2SVG</textual></title><para class="po-block e742 e742"><textual class="po-textual">	 As a more substantial application of XML processing, the GML-to-SVG (GML2SVG) application
was chosen.   This application transforms geospatially encoded data represented using 
an XML representation in the form of Geography Markup Language (GML) </textual><citation class="po-atom e743 e743" linkend="lake2004geography"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> 
into a different XML format  suitable for displayable maps: 
Scalable Vector Graphics (SVG) format </textual><citation class="po-atom e744 e744" linkend="lu2007advances"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">. In the GML2SVG benchmark, GML feature elements 
and GML geometry elements tags are matched. GML coordinate data are then extracted 
and transformed to the corresponding SVG path data encodings. 
Equivalent SVG path elements are generated and output to the destination 
SVG document.  The GML2SVG application is thus considered typical of a broad
class of XML applications that parse and extract information from 
a known XML format for the purpose of analysis and restructuring to meet
the requirements of an alternative format.</textual></para><para class="po-block e745 e745"><textual class="po-textual">Our GML to SVG data translations are executed on GML source data 
modelling the city of Vancouver, British Columbia, Canada. 
The GML source document set 
consists of 46 distinct GML feature layers ranging in size from approximately 9 KB to 125.2 MB 
and with an average document size of 18.6 MB. Markup density ranges from approximately 0.045 to 0.719 
and with an average markup density of 0.519. In this performance study, 
213.4 MB of source GML data generates 91.9 MB of target SVG data.</textual></para><figure class="po-container e746 e746" xml:id="perf_GML2SVG"><title class="po-block e747 e747"><textual class="po-textual">Performance Comparison for GML2SVG</textual></title><mediaobject class="po-container e748 e748"><imageobject class="po-container e749 e749"><imagedata class="po-meta e750 e750" fileref="../../../vol10/graphics/Cameron01/Cameron01-006.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e751 e751"><xref class="po-milestone e752 e752" linkend="perf_GML2SVG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> compares the performance of the GML2SVG application linked against
the Xerces, icXML and icXML-p.   
On the GML workload with this application, single-thread icXML
achieved about a 50% acceleration over Xerces, 
increasing throughput on our test machine from 58.3 MB/sec to 87.9 MB/sec.   
Using icXML-p, a further throughput increase to 111 MB/sec was recorded, 
approximately a 2X speedup.</textual></para><para class="po-block e753 e753"><textual class="po-textual">An important aspect of icXML is the replacement of much branch-laden
sequential code inside Xerces with straight-line SIMD code using far
fewer branches.  </textual><xref class="po-milestone e754 e754" linkend="branchmiss_GML2SVG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows the corresponding
improvement in branching behaviour, with a dramatic reduction in branch misses per kB.
It is also interesting to note that icXML-p goes even further.   
In essence, in using pipeline parallelism to split the instruction 
stream onto separate cores, the branch target buffers on each core are
less overloaded and able to increase the successful branch prediction rate.</textual></para><figure class="po-container e755 e755" xml:id="branchmiss_GML2SVG"><title class="po-block e756 e756"><textual class="po-textual">Comparative Branch Misprediction Rate</textual></title><mediaobject class="po-container e757 e757"><imageobject class="po-container e758 e758"><imagedata class="po-meta e759 e759" fileref="../../../vol10/graphics/Cameron01/Cameron01-007.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e760 e760"><textual class="po-textual">The behaviour of the three versions with respect to L1 cache misses per kB is shown
in </textual><xref class="po-milestone e761 e761" linkend="cachemiss_GML2SVG"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.   Improvements are shown in both instruction-
and data-cache performance with the improvements in instruction-cache
behaviour the most dramatic.   Single-threaded icXML shows substantially improved
performance over Xerces on both measures.   
Although icXML-p is slightly worse with respect to data-cache performance, 
this is more than offset by a further dramatic reduction in instruction-cache miss rate.
Again partitioning the instruction stream through the pipeline parallelism model has 
significant benefit.</textual></para><figure class="po-container e762 e762" xml:id="cachemiss_GML2SVG"><title class="po-block e763 e763"><textual class="po-textual">Comparative Cache Miss Rate</textual></title><mediaobject class="po-container e764 e764"><imageobject class="po-container e765 e765"><imagedata class="po-meta e766 e766" fileref="../../../vol10/graphics/Cameron01/Cameron01-008.png" format="png" width="500cm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e767 e767"><textual class="po-textual">One caveat with this study is that the GML2SVG application did not exhibit 
a relative balance of processing between application code and Xerces library
code reaching the 33% figure.  This suggests that for this application and
possibly others, further separating the logical layers of the
icXML engine into different pipeline stages could well offer significant benefit.
This remains an area of ongoing work.</textual></para></section></section><section class="po-hcontainer e768 e768" xml:id="conclusion"><title class="po-block e769 e769"><textual class="po-textual">Conclusion and Future Work</textual></title><para class="po-block e770 e770"><textual class="po-textual"> This paper is the first case study documenting the significant performance benefits
         that may be realized through the integration of parallel bitstream technology into existing
         widely-used software libraries. In the case of the Xerces-C++ XML parser, the combined
         integration of SIMD and multicore parallelism was shown capable of dramatic producing
         dramatic increases in throughput and reductions in branch mispredictions and cache misses.
         The modified parser, going under the name icXML is designed to provide the full
         functionality of the original Xerces library with complete compatibility of APIs. Although
         substantial re-engineering was required to realize the performance potential of parallel
         technologies, this is an important case study demonstrating the general feasibility of
         these techniques. </textual></para><para class="po-block e771 e771"><textual class="po-textual"> The further development of icXML to move beyond 2-stage pipeline parallelism is
         ongoing, with realistic prospects for four reasonably balanced stages within the library.
         For applications such as GML2SVG which are dominated by time spent on XML parsing, such a
         multistage pipelined parsing library should offer substantial benefits. </textual></para><para class="po-block e772 e772"><textual class="po-textual"> The example of XML parsing may be considered prototypical of finite-state machines
         applications which have sometimes been considered "embarassingly
         sequential" and so difficult to parallelize that "nothing
         works." So the case study presented here should be considered an important data
         point in making the case that parallelization can indeed be helpful across a broad array of
         application types. </textual></para><para class="po-block e773 e773"><textual class="po-textual"> To overcome the software engineering challenges in applying parallel bitstream
         technology to existing software systems, it is clear that better library and tool support
         is needed. The techniques used in the implementation of icXML and documented in this paper
         could well be generalized for applications in other contexts and automated through the
         creation of compiler technology specifically supporting parallel bitstream programming.
      </textual></para><para class="po-block e774 e774"><textual class="po-textual">Given the success of the icXML development, there is a strong case for continued
	    development of the Parabix framework as well as for the application of Parabix
	    to other important XML technology stacks.   In particular, an important area for further 
	    work is to extend the benefits of SIMD and multicore parallelism to the acceleration
	    of Java-based XML processors. 
      </textual></para></section><bibliography class="po-hcontainer e775 e775"><title class="po-block e776 e776"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e777 e777" xml:id="CameronHerdyLin2008" xreflabel="Parabix1 2008"><textual class="po-textual">Cameron, Robert D., Herdy, Kenneth S. and Lin, Dan. High performance XML parsing using parallel bit stream technology. CASCON'08: Proc. 2008 conference of the center for advanced studies on collaborative research. Richmond Hill, Ontario, Canada. 2008.</textual></bibliomixed><bibliomixed class="po-block e778 e778" xml:id="papi" xreflabel="PAPI"><textual class="po-textual">Innovative Computing Laboratory, University of Texas. Performance Application Programming Interface. </textual><link class="po-inline e779 e779" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://icl.cs.utk.edu/papi/</textual></link></bibliomixed><bibliomixed class="po-block e780 e780" xml:id="perf" xreflabel="perf"><textual class="po-textual">Eranian, Stephane, Gouriou, Eric, Moseley, Tipp and Bruijn, Willem de. Linux kernel profiling with perf. </textual><link class="po-inline e781 e781" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">https://perf.wiki.kernel.org/index.php/Tutorial</textual></link></bibliomixed><bibliomixed class="po-block e782 e782" xml:id="Cameron2008" xreflabel="u8u16 2008"><textual class="po-textual">Cameron, Robert D.. A case study in SIMD text processing with parallel bit streams: UTF-8 to UTF-16 transcoding. Proc. 13th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming. Salt Lake City, USA. 2008. doi:</textual><biblioid class="po-atom e783 doi e783"><textual class="po-textual">10.1145/1345206.1345222</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e784 e784" xml:id="ParaDOM2009" xreflabel="Shah and Rao 2009"><textual class="po-textual">Shah, Bhavik, Rao, Praveen, Moon, Bongki and Rajagopalan, Mohan. A Data Parallel Algorithm for XML DOM Parsing. Database and XML Technologies. 2009.</textual></bibliomixed><bibliomixed class="po-block e785 e785" xml:id="XMLSSE42" xreflabel="Lei 2008"><textual class="po-textual">Lei, Zhai. XML Parsing Accelerator with Intel Streaming SIMD Extensions 4 (Intel SSE4). </textual><link class="po-inline e786 e786" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">Intel Software Network</textual></link><textual class="po-textual">.  2008.</textual></bibliomixed><bibliomixed class="po-block e787 e787" xml:id="Cameron2009" xreflabel="Balisage 2009"><textual class="po-textual">Cameron, Rob, Herdy, Ken and Amiri, Ehsan Amiri. Parallel Bit Stream Technology as a Foundation for XML Parsing Performance. Int'l Symposium on Processing XML Efficiently: Overcoming Limits on Space, Time, or Bandwidth. Montreal, Quebec, Canada.  2009. doi:</textual><biblioid class="po-atom e788 doi e788"><textual class="po-textual">10.4242/BalisageVol4.Cameron01</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e789 e789" xml:id="HilewitzLee2006" xreflabel="Hilewitz and Lee 2006"><textual class="po-textual">Hilewitz, Yedidya and Lee, Ruby B.. Fast Bit Compression and Expansion with Parallel Extract and Parallel Deposit Instructions. ASAP '06: Proc. IEEE 17th Int'l Conference on Application-specific Systems, Architectures and Processors. Steamboat Springs, Colorado, USA.  2006.</textual></bibliomixed><bibliomixed class="po-block e790 e790" xml:id="Asanovic-EECS-2006-183" xreflabel="Asanovic et al. 2006"><textual class="po-textual">Asanovic, Krste and others. The Landscape of Parallel Computing Research: A View from Berkeley. EECS Department, University of California, Berkeley.  2006.</textual></bibliomixed><bibliomixed class="po-block e791 e791" xml:id="GRID2006" xreflabel="Lu and Chiu 2006"><textual class="po-textual">Lu, Wei, Chiu, Kenneth and Pan, Yinfei. A Parallel Approach to XML Parsing. Proceedings of the 7th IEEE/ACM International Conference on Grid Computing. Barcelona, Spain.  2006.</textual></bibliomixed><bibliomixed class="po-block e792 e792" xml:id="cameron-EuroPar2011" xreflabel="Parabix2 2011"><textual class="po-textual">Cameron, Robert D., Amiri, Ehsan, Herdy, Kenneth S., Lin, Dan, Shermer, Thomas C. and Popowich, Fred P.. Parallel Scanning with Bitstream Addition: An XML Case Study. Euro-Par 2011, LNCS 6853, Part II.  Bordeaux, Frane. 2011.</textual></bibliomixed><bibliomixed class="po-block e793 e793" xml:id="HPCA2012" xreflabel="Lin and Medforth 2012"><textual class="po-textual">Lin, Dan, Medforth, Nigel, Herdy, Kenneth S., Shriraman, Arrvindh and Cameron, Rob. Parabix: Boosting the efficiency of text processing on commodity processors. International Symposium on High-Performance Computer Architecture. New Orleans, LA. 2012. doi:</textual><biblioid class="po-atom e794 doi e794"><textual class="po-textual">10.1109/HPCA.2012.6169041</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e795 e795" xml:id="HPCC2011" xreflabel="You and Wang 2011"><textual class="po-textual">You, Cheng-Han and Wang, Sheng-De. A Data Parallel Approach to XML Parsing and Query. 10th IEEE International Conference on High Performance Computing and Communications. Banff, Alberta, Canada. 2011.</textual></bibliomixed><bibliomixed class="po-block e796 e796" xml:id="E-SCIENCE2007" xreflabel="Pan and Zhang 2007"><textual class="po-textual">Pan, Yinfei, Zhang, Ying, Chiu, Kenneth and Lu, Wei. Parallel XML Parsing Using Meta-DFAs. International Conference on e-Science and Grid Computing.   Bangalore, India.  2007.</textual></bibliomixed><bibliomixed class="po-block e797 e797" xml:id="ICWS2008" xreflabel="Pan and Zhang 2008a"><textual class="po-textual">Pan, Yinfei, Zhang, Ying and Chiu, Kenneth. Hybrid Parallelism for XML SAX Parsing. IEEE International Conference on Web Services. Beijing, China.  2008.</textual></bibliomixed><bibliomixed class="po-block e798 e798" xml:id="IPDPS2008" xreflabel="Pan and Zhang 2008b"><textual class="po-textual">Pan, Yinfei, Zhang, Ying and Chiu, Kenneth. Simultaneous transducers for data-parallel XML parsing. International Parallel and Distributed Processing Symposium. Miami, Florida, USA.  2008.</textual></bibliomixed><bibliomixed class="po-block e799 e799" xml:id="HackersDelight" xreflabel="Warren 2002"><textual class="po-textual">Warren, Henry S.. Hacker's Delight. Addison-Wesley Professional. 2003.</textual></bibliomixed><bibliomixed class="po-block e800 e800" xml:id="lu2007advances" xreflabel="Lu and Dos Santos 2007"><textual class="po-textual">Lu, C.T., Dos Santos, R.F., Sripada, L.N. and Kou, Y.. Advances in GML for geospatial applications. Geoinformatica 11:131-157.  2007. doi:</textual><biblioid class="po-atom e801 doi e801"><textual class="po-textual">10.1007/s10707-006-0013-9</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e802 e802" xml:id="lake2004geography" xreflabel="Lake and Burggraf 2004"><textual class="po-textual">Lake, R., Burggraf, D.S., Trninic, M. and Rae, L.. Geography mark-up language (GML) [foundation for the geo-web]. Wiley.  Chichester.  2004.</textual></bibliomixed></bibliography></article></classedDocument>