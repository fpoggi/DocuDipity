<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="AHR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Test Assertions on steroids for XML artifacts</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2009</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 11 - 14, 2009</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Testing of XML material – either XML-native business documents, or XML-formatted inputs from various sources – involves more than syntactic or semantic validation of a document. It often requires checking consistency with other documents, and verifying assumptions about the quality of these. Consequently - like for any complex system - the design and execution of test units have to be composed and ordered. This in turns requires a testing method and tool with more flexibility - in test expression and test usage - than provided by validation tools such as OWL reasoner or Schematron. A test method is presented that relies on a general test assertion model from OASIS. This test model (and its XML markup) is extended with XPath in order to make test assertions directly executable after XSLT translation, by a forward-chaining engine itself written in XSLT. Test assertions may refer to other test assertions either for chaining or for composing test results. The resulting test model and processing is contrasted with other approaches (XBRL test suite, OWL reasoner, Schematron). Results and learnings from a real test suite are presented, as well as a proposed implementation model based on generating the XSLT engine specific to a test suite, rather than using a generic engine. Observations are made about features in the latest versions of underlying technologies (XPath2.0, XSLT2.0) that were critical to this implementation.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Jacques</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Durand</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Jacques Durand is software architect at Fujitsu America, Inc. with a long-time involvement in XML standard organizations, member of the OASIS Technical Advisory Board, contributor to XML user consortiums such as RosettaNet, OAGI. He has extensive experience in XML-related testing, is chair of the Test Assertions Guideline OASIS committee and of the Testing and Monitoring of Internet Exchanges (TaMIE) committee. He has been leading testing activities for years in the WS-Interoperability consortium and in the ebXML technical committee. He earned a Ph.D. in rule-based systems and logic-programming from Nancy Univ., France.
	</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Senior architect, R and D dir.</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Fujitsu America, Inc.</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">jdurand@us.fujitsu.com</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Stephen</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">Green</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">Stephen Green is an Associate Director of Document Engineering Services, an international consortium of experts supporting universal business interoperability through the use of open standards. His expertise is in finance, business documents and software development for business and financial applications. He has specialized in legacy systems and modern electronic business trends and their impact on small and medium sized enterprises. Stephen has been active in the Organization for the Advancement of Structured Information Standards (OASIS) for seven years, serving on as many technical committees.
	  He is currently editing the Test Assertions Guidelines of the OASIS technical committee of that name. He previously led the first efforts to provide a small business subset conformance profile for the OASIS Universal Business Language, version 1.0."
	</textual></para></personblurb><affiliation class="po-record e24 e24"><jobtitle class="po-field e25 e25"><textual class="po-textual">Associate Director</textual></jobtitle><orgname class="po-block e26 e26"><textual class="po-textual">Document Engineering Services</textual></orgname></affiliation><email class="po-field e27 e27"><textual class="po-textual">stephen.green@documentengineeringservices.com</textual></email></author><author class="po-record e28 e28"><personname class="po-record e29 e29"><firstname class="po-field e30 e30"><textual class="po-textual">Serm</textual></firstname><surname class="po-field e31 e31"><textual class="po-textual">Kulvatunyou</textual></surname></personname><personblurb class="po-container e32 e32"><para class="po-block e33 e33"><textual class="po-textual">Serm Kulvatunyou is currently a Standard and Product Architect at the Oracle's Application Integration Architecture (AIA) division. Formerly, he was a guest researcher the at the Manufacturing Systems Integration Division, National Institute of Standards and Technology (NIST) from the Oak Ridge National Laboratory. At NIST, he has designed and implemented semantics testing and frameworks for design of document model and instance validation in the contenxt of an e-business testbed using XML and related technologies.  He has been an active participants in several standard bodies such as UN/CEFACT and OASIS. His current interests are in architecture and best practices methodology to enterprise data model for reusable and interoperable Service-Oriented Architecture. He received his Ph.D. in Industrial Engineering from the Pennsylvania State University, University Park, in 2001.
	</textual></para></personblurb><affiliation class="po-record e34 e34"><jobtitle class="po-field e35 e35"><textual class="po-textual">Standard and Product Architect</textual></jobtitle><orgname class="po-block e36 e36"><textual class="po-textual">Oracle</textual></orgname></affiliation><email class="po-field e37 e37"><textual class="po-textual">serm.kulvatunyou@oracle.com</textual></email></author><author class="po-record e38 e38"><personname class="po-record e39 e39"><firstname class="po-field e40 e40"><textual class="po-textual">Tom</textual></firstname><surname class="po-field e41 e41"><textual class="po-textual">Rutt</textual></surname></personname><personblurb class="po-container e42 e42"><para class="po-block e43 e43"><textual class="po-textual">Tom Rutt is Standards Manager at Fujitsu America, Inc. with a long-time involvement in XML standard organizations and participates in several Web Services standard committees. He has extensive experience in XML-related testing, and has been involved in the WS-Interoperability consortium for years, more recently designing and developing testing tools for profile conformance. He is also member of the OMG Architecture Board.
	</textual></para></personblurb><affiliation class="po-record e44 e44"><jobtitle class="po-field e45 e45"><textual class="po-textual">Standards Manager</textual></jobtitle><orgname class="po-block e46 e46"><textual class="po-textual">Fujitsu America, Inc.</textual></orgname></affiliation><email class="po-field e47 e47"><textual class="po-textual">tom@coastin.com</textual></email></author><legalnotice class="po-container e48 e48"><para class="po-block e49 e49"><textual class="po-textual">Copyright © Fujitsu America, Inc., Document Engineering Services, Oracle: Used by permission.</textual></para></legalnotice><keywordset class="po-table e50 e50" role="author"><keyword class="po-field e51 e51"><textual class="po-textual">Document Testing</textual></keyword><keyword class="po-field e52 e52"><textual class="po-textual">Test Assertion</textual></keyword></keywordset></info><section class="po-hcontainer e53 e53"><title class="po-block e54 e54"><textual class="po-textual">Introduction</textual></title><para class="po-block e55 e55"><textual class="po-textual">
      Testing of XML material – either XML-native business documents, or various XML-formatted inputs – often involves more than single document validation. The notion of validation may depend on a context involving other documents. Validation against a schema is just an an example of this. Behind XML document testing it is often a processor generating or editing this document, that is being tested. This is the case with XBRL test suites (for XBRL processors), with WS-I test suites (testing Web service instances) and also the ODF test suite (targeting document processors). As a consequence, the notion of validity depends on a context made of diverse other documents, that represent various inputs to these processors as well as traces that capture their behavior and relate all documents associated with the same test case. Roughly, two categories of documents can make up such context: (a) metadata documents, and (b) scenario documents.
    </textual></para><itemizedlist class="po-table e56 e56"><listitem class="po-container e57 e57"><para class="po-block e58 e58"><textual class="po-textual">
	Metadata documents may involve various business rules, reference documents and templates, contractual documents, configuration artifacts. XML schemas are just an example of these, and they may be involved in quite diverse validation patterns [1] beyond conventional schema-validation of instances.
      </textual></para></listitem><listitem class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Scenario documents reflect on operations over a system under test  - such as an XML transcript of an electronic exchange with the system under test, a log converted into XML, or the script a sequence of operations to be performed by a test driver. </textual></para></listitem></itemizedlist><para class="po-block e61 e61"><textual class="po-textual">
      In such cases, testing is as much about verifying that each one of these XML artifacts is individually correct, as it is about verifying that some combinations of these are consistent (e.g. a Web service message must conform to its definition in WSDL, or the output of an ODF processor is consistent with the operation performed and the previous state of the document). In some cases it is not even a main document that is under test relative to some context, but rather a sequence of documents, e.g. a message choreography for a business transaction combining business payloads, message protocols and service interfaces that is tested for conformance [2]. The dependency between a document and its transactional context (exchange protocol) has also been analyzed in [3].
    </textual></para><para class="po-block e62 e62"><textual class="po-textual">
      Such testing requirements are in fact closer to conventional system or software testing requirements than to document testing in a narrow sense - while also requiring same XML testing capabilities as known today for single documents. Because each type of artifact may have its own validation rules and test suites, tests must be grouped into modules, the execution of which is conditioned by the results of other test modules. Chaining of test cases becomes an important feature, across modules or within modules.
    </textual></para><para class="po-block e63 e63"><textual class="po-textual">
      This diversity of these test requirements poses a challenge to a test environment:
      </textual><itemizedlist class="po-table e64 e64"><listitem class="po-container e65 e65"><para class="po-block e66 e66"><textual class="po-textual">Rules and constraints (Schematron, OWL Reasoning, RuleML) are often limited in either one of two ways: (a) their expressive power is often traded for ease of processing, (b) their decision model (e.g. predicate logic) often enforces a Boolean outcome missing the nuances expected in a test report.</textual></para></listitem><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">Test suites - and test engines – often exceed the scope of dedicated tools such as Schematron (e.g. XBRL test suite). As a result they are architected and developed in an ad-hoc manner, regardless of how well they leverage XML technologies.</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e69 e69"><textual class="po-textual">
      This paper describes a more integrated XML testing paradigm which supports flexible composition of test cases (chaining, parameterization) and test suites (modules, reuse). The resulting implementation makes the best of XPath2.0 and XSLT2.0 to provide on one hand a test script model able to express predicates crossing over such diverse inputs and to handle a richer spectrum of outcomes, and on the other hand a test engine able to compose and chain test assertions in a way that was usually considered requiring specialized rule engines written in conventional programming languages or dedicated AI languages such as Prolog or LISP.
    </textual></para></section><section class="po-hcontainer e70 e70"><title class="po-block e71 e71"><textual class="po-textual">XML Test Assertions for XML</textual></title><para class="po-block e72 e72"><textual class="po-textual">
      In this section the authors argue that the best approach for testing XML material – given the integrated aspect of such testing - is one that builds on conventional test methodologies, augmented with a proper integration of XML-processing techniques (here XPath2.0, XSLT2.0).
    </textual></para><section class="po-hcontainer e73 e73"><title class="po-block e74 e74"><textual class="po-textual">Test Assertion Model</textual></title><para class="po-block e75 e75"><textual class="po-textual">
	Test assertions (TA) is a familiar concept for QA engineers and test developers. A test assertion is a testable or measurable statement for evaluating the adherence of part of an implementation to a normative statement in a specification. Test assertions provide a link between the narrative of a specification (i.e. rules, schema, requirements, system definition) and the test suites that assess conformance of implementations. Test assertions have been mostly used in the domain of software engineering, and less often in more specialized domains such as XML artifacts, where ad-hoc solutions - and also very specialized tools - have flourished instead. Test assertions are usually declarative (logical) statements that are written as a blueprint for test cases, the latter being the actual executable tests.
      </textual></para><para class="po-block e76 e76"><textual class="po-textual">
	A major benefit in writing test assertions, is that they represent a "conformance contract" understandable by all parties involved - domain experts, test writers, end-users. An additional interest in the XML space - where all material under test is in XML format, is that test assertions can be directly scripted using such dialects as XPath or XQuery, thus becoming themselves executable test cases. A general-purpose model for test assertions has recently been developed in the OASIS Test Assertions Guidelines (TAG) OASIS committee [8]. In this model, a test assertion (TA) is a well-structured object defined as follows:
      </textual></para><para class="po-block e77 e77"><textual class="po-textual">
	</textual><itemizedlist class="po-table e78 e78"><listitem class="po-container e79 e79"><para class="po-block e80 e80"><emphasis class="po-inline e81 e81" role="bold"><textual class="po-textual">TA Id</textual></emphasis><textual class="po-textual">: the identifier of the Test Assertion.</textual></para></listitem><listitem class="po-container e82 e82"><para class="po-block e83 e83"><emphasis class="po-inline e84 e84" role="bold"><textual class="po-textual">Source</textual></emphasis><textual class="po-textual">: the normative conformance requirement that this test assertion is addressing</textual></para></listitem><listitem class="po-container e85 e85"><para class="po-block e86 e86"><emphasis class="po-inline e87 e87" role="bold"><textual class="po-textual">Target</textual></emphasis><textual class="po-textual">: a Test Assertion always targets instances of a specific artifact type, for example, a line item fragment in a purchase order document, a SOAP Envelope, a WSDL port binding, etc. The Target element identifies this artifact type. </textual></para></listitem><listitem class="po-container e88 e88"><para class="po-block e89 e89"><emphasis class="po-inline e90 e90" role="bold"><textual class="po-textual">Prerequisite</textual></emphasis><textual class="po-textual">: a pre-condition that must be satisfied over the Target instance in order for this instance to qualify for evaluation under this TA. The Prerequisite may refer to other test assertions. If the Prerequisite evaluates to “false”, then the outcome of the TA for this Target will be “notQualified” in the test report.</textual></para></listitem><listitem class="po-container e91 e91"><para class="po-block e92 e92"><emphasis class="po-inline e93 e93" role="bold"><textual class="po-textual">Predicate</textual></emphasis><textual class="po-textual">: a logical expression over the Target. The Predicate is only evaluated if the Target instance is qualified, i.e. if the Prerequisite – if any – has already evaluated to “true”. If the Predicate result is “true” then the Target instance fulfills the related conformance requirement and violates it otherwise.</textual></para></listitem><listitem class="po-container e94 e94"><para class="po-block e95 e95"><emphasis class="po-inline e96 e96" role="bold"><textual class="po-textual">Prescription Level</textual></emphasis><textual class="po-textual">: a keyword reflecting how imperative it is to fulfill the (Source) requirement: mandatory / preferred / permitted.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e97 e97"><textual class="po-textual">
	The authors have profiled and extended this model so that test assertions become directly executable over XML artifacts, thus becoming "test cases" grouped in test suites.
      </textual></para><para class="po-block e98 e98"><textual class="po-textual">
	The profiling consists of the following:

	</textual><orderedlist class="po-table e99 e99" numeration="arabic"><listitem class="po-container e100 e100"><para class="po-block e101 e101"><textual class="po-textual">Use XPath expressions to define Target, Prerequisite and Predicate.</textual></para></listitem><listitem class="po-container e102 e102"><para class="po-block e103 e103"><textual class="po-textual">Define how the instances of a particular target type are identified. This is defined by another XPath expression that returns a unique ID, possibly resulting from aggregation of several fields relevant to this target type. This ID will show in the test report, but also used when chaining test assertions over a same target instance during test execution.</textual></para></listitem><listitem class="po-container e104 e104"><para class="po-block e105 e105"><textual class="po-textual">Add references (XPath) to a combination of artifacts that represent contextual documents, over which Prerequisite and Predicate may operate.</textual></para></listitem><listitem class="po-container e106 e106"><para class="po-block e107 e107"><textual class="po-textual">Add a new Reporting element that determines the outcome of the test assertion over a target instance.</textual></para></listitem><listitem class="po-container e108 e108"><para class="po-block e109 e109"><textual class="po-textual">Add secondary output mostly for human readers: error messages, diagnostic data.</textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e110 e110"><title class="po-block e111 e111"><textual class="po-textual">The Test Target and its Context</textual></title><para class="po-block e112 e112"><textual class="po-textual">A test assertion will always focus on a “primary” target instance, but may need to access contextual material in order to test this target. This "side" material is identified in "variables" added to the TA. A simple example of this is schema-validation of a document. In the target scripting below, the test assertion will refer to the contextual document (a schema) while targeting a purchase order line item:
	</textual><programlisting class="po-block e113 e113" xml:space="preserve"><textual class="po-textual">&lt;testAssertion id="1234" lg=”xpath20” &gt;
	  &lt;var name=”poschema” type="string"&gt;http://www.mysupplychain_xyz.com/2009/04/12/po.xsd&lt;/var&gt;
	  &lt;target&gt;//xyz:purchaseOrder/xyz:lineItem&lt;/target&gt;
	  &lt;predicate&gt;$target instance of schema-element($poschema, xyz:lineItem) &lt;/predicate&gt;
	  ...
	  &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	The predicate validating a lineItem element will refer to this contextual document using the conventional variable notation ($). The predicate expressions will be pre-processed into executable XPath.
	The above test assertion applies to every line item of any purchase order.
	Variable expressions (&lt;var&gt;) may refer to any contextual material - either inside the same document or external. An XPath variable notations($) may then be used either to parameterize the location of a document, or to refer to the current value of the target expression:
	</textual><programlisting class="po-block e114 e114" xml:space="preserve"><textual class="po-textual">&lt;testAssertion id="2345" lg=”xpath20”&gt;
	  &lt;var name=”herbooks” &gt;document($allbooks)/book[@author = $target/name]&lt;/var&gt;
	  &lt;var name=”herpublishers” &gt;document($allpublishers)
	  //directory/publisher[fn:index-of( fn:distinct-values(
	  ‘for $bk in $herbooks return $bk/@publisher’), @name) gt 0 ]&lt;/var&gt;

	  &lt;target&gt;//whoswho/arts[@section='literature']/biographies/author&lt;/target&gt;
	  ...
	  &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	In the above, "$allbooks" and "$allpublishers" are references to a documents that have been defined outside the test assertion. The variable "$herbooks" denotes the subset of books from this author. The variable "$herpublishers" is the subset of publishers this author has been dealing with. The target expression is matched against a third document, the main input.
	A predicate for the above target may express a condition over the author (the target), her related list of books ($herbooks) and of publishers ($herpublishers).
      </textual></para></section><section class="po-hcontainer e115 e115"><title class="po-block e116 e116"><textual class="po-textual">Reporting Test Outcomes</textual></title><para class="po-block e117 e117"><textual class="po-textual">
	The additional Reporting element added to the test assertion structure may override the default outcome which is:
	</textual><itemizedlist class="po-table e118 e118"><listitem class="po-container e119 e119"><para class="po-block e120 e120"><emphasis class="po-inline e121 e121" role="bold"><textual class="po-textual">notQualified</textual></emphasis><textual class="po-textual"> (if Prerequisite = “false”)</textual></para></listitem><listitem class="po-container e122 e122"><para class="po-block e123 e123"><emphasis class="po-inline e124 e124" role="bold"><textual class="po-textual">pass</textual></emphasis><textual class="po-textual"> (if Prerequisite = “true” and Predicate = “true”)</textual></para></listitem><listitem class="po-container e125 e125"><para class="po-block e126 e126"><emphasis class="po-inline e127 e127" role="bold"><textual class="po-textual">fail</textual></emphasis><textual class="po-textual"> (if Prerequisite = “true” and Predicate = “false”)</textual></para></listitem></itemizedlist><textual class="po-textual">
	Indeed, other possible outcomes are:
	</textual><itemizedlist class="po-table e128 e128"><listitem class="po-container e129 e129"><para class="po-block e130 e130"><emphasis class="po-inline e131 e131" role="bold"><textual class="po-textual">missingInput</textual></emphasis><textual class="po-textual"> (a contextual document or XML fragment is missing in order to pursue the evaluation)</textual></para></listitem><listitem class="po-container e132 e132"><para class="po-block e133 e133"><emphasis class="po-inline e134 e134" role="bold"><textual class="po-textual">warning</textual></emphasis><textual class="po-textual"> (the Predicate may not be indicative enough of either violation or fulfillment, but has detected a situation calling for further attention.)</textual></para></listitem><listitem class="po-container e135 e135"><para class="po-block e136 e136"><emphasis class="po-inline e137 e137" role="bold"><textual class="po-textual">undetermined</textual></emphasis><textual class="po-textual"> (e.g. the Predicate is only designed to detect some kinds of violation, when “false”, and has no particular conformance meaning when “true”)</textual></para></listitem></itemizedlist><textual class="po-textual">
	These outcomes are not only intended for a final test report. They can also be tested and influence the test suite execution if the test assertion that produces them is referred to in predicates and prerequisites of subsequent test assertions.
      </textual></para></section><section class="po-hcontainer e138 e138"><title class="po-block e139 e139"><textual class="po-textual">Inheritance and Composition</textual></title><para class="po-block e140 e140"><textual class="po-textual">
	An important benefit of clearly identifying target categories, is the ability to leverage inheritance and composition relationships between targets. Targets often belong to a class system, in the object-oriented sense (a target may be part of an other target, may be a subclass of another target, etc.). This leads to an enhanced test execution model that is able to leverage such relationships. In particular:</textual></para><itemizedlist class="po-table e141 e141"><listitem class="po-container e142 e142"><para class="po-block e143 e143"><emphasis class="po-inline e144 e144" role="bold"><textual class="po-textual">Inheritance</textual></emphasis><textual class="po-textual">: The test engine is able to determine that a test assertion will apply not only to all instances of its Target class, but also to all instances of its Target sub-classes. In other words, a target inherits the test assertions of its super-classes.
	</textual></para></listitem><listitem class="po-container e145 e145"><para class="po-block e146 e146"><emphasis class="po-inline e147 e147" role="bold"><textual class="po-textual">Composition</textual></emphasis><textual class="po-textual">: The test engine is able to handle cases where the prerequisite expression of TA t1 includes references to TA t2, and yet t1 and t2 do not have the same Target class - not even in a sub-class relationship - but have a component relationship. For example, t1 target - say a "binding definition" - is a part of t2 target - say a WSDL file. Before verifying that the binding satisfies some rules (TA t1) one may want to verify that the embedding WSDL file is schema-valid (TA t2). In such cases, the component relationship can be defined once as an access expression from t1 to t2 on the ancestor axis (XPath), reusable by any TA.
	</textual></para></listitem></itemizedlist><para class="po-block e148 e148"><textual class="po-textual">
	The authors are in favor of supporting two modes of representation for such a model:  (1) "inline" relationship information can be embedded in each test assertion as needed. (2) a different mark-up separate from test assertions will hold target model information. While (2) is a more rational and scalable approach (avoid redundant information from on test assertion to the other, etc.), (1) is a convenient approach well suited for the test assertion development phase.
	Examples of inline model information are shown below. The target element uses a qualification notation to indicate the super-class (message) of SOAPmessage target class. </textual></para><programlisting class="po-block e149 e149" xml:space="preserve"><textual class="po-textual">
	&lt;target type="message:SOAPmessage" &gt; ... &lt;/target&gt;
      </textual></programlisting><para class="po-block e150 e150"><textual class="po-textual">The composition link between the main target of a test assertion - here a WSDL binding - and the related embedding target of a prerequisite reference - here the WSDL file itself - is indicated using an XPath expression relative to the selected target node ($target) as "argument" of the test assertion reference (tag:BP2703):</textual></para><programlisting class="po-block e151 e151" xml:space="preserve"><textual class="po-textual">
	&lt;testAssertion id="BP2403"&gt;
	&lt;target type="binding" idscheme="..." &gt;//wsdl:definitions/wsdl:binding&lt;/target&gt;
	&lt;prerequisite&gt; tag:BP2703($target/..) = 'pass' &lt;/prerequisite&gt;
	...
	&lt;/testAssertion&gt;
      </textual></programlisting><para class="po-block e152 e152"><textual class="po-textual">Another major attribute of a Target class, is the ID scheme itself an XPath expression that will return a unique ID string for each target instance, to appear in the test report.
      </textual></para></section><section class="po-hcontainer e153 e153"><title class="po-block e154 e154"><textual class="po-textual">Chained Test Assertions</textual></title><para class="po-block e155 e155"><textual class="po-textual">
	A powerful aspect of the otherwise simple TAG model, is that a test assertion (TA) may refer to other test assertions. It may do so in two ways:
	</textual><orderedlist class="po-table e156 e156" numeration="loweralpha"><listitem class="po-container e157 e157"><para class="po-block e158 e158"><textual class="po-textual">by using TA references in the Prerequisite element. Such references are just parts of the logical expression, e.g. (in a simplified notation) :
	      </textual><programlisting class="po-block e159 e159" xml:space="preserve"><textual class="po-textual">Prerequisite of TA3: (TA1 = “pass”) and (TA2 = “pass”)</textual></programlisting><textual class="po-textual">
	      means that it is expected that the target passed TA1 and TA2 before even being tested for TA3. TA-referencing in a Prerequisite is commonly used when the test expression (Predicate) in a TA can be greatly simplified by assuming that the target already passed other test assertions, or simply when the test itself is irrelevant in case some other (prerequisite) tests have failed.
	  </textual></para></listitem><listitem class="po-container e160 e160"><para class="po-block e161 e161"><textual class="po-textual">by using TA references in the Predicate element. This allows for writing meta-level test assertions that evaluate a composition of the results of other TAs. This is often needed when defining various "conformance profiles" related to the same type of document (e.g. a category of insurance claims, a purchase order of class 'urgent'). For example: “to comply with conformance profile P, a document must “pass” the set of test assertions {TA1, TA2, TA3} and at least must NOT “fail” the set of test assertions {TA4, TA5}.” In such a case, a single TA will summarize the composition test to be made over the results of all TAs involved in assessing the conformance profile P. The predicate will be:
	      </textual><programlisting class="po-block e162 e162" xml:space="preserve"><textual class="po-textual">Predicate of TA6: (TA1 = “pass”) and (TA2 = “pass”) and (TA3 = “pass”)
		and  not(TA4 = “fail”) and not(TA5 = “fail”)</textual></programlisting><textual class="po-textual">
	      This summary TA (TA6) may in turn be referred to from the Prerequisite of another TA. This is an essential feature when dealing with contextual documents: in most cases, one must first ensure that the contextual document is itself “conforming” before using it in a test case over the “main” document. These expressions are pre-processed by the test engine into equivalent XPath boolean expressions.
	  </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para><para class="po-block e163 e163"><textual class="po-textual">
	There are two main reasons for chaining test assertions as described in (a) above:</textual></para><para class="po-block e164 e164"><textual class="po-textual">(a1) When a set of tests should logically be done in a particular order, meaning that every single test should only be executed if the target instance passed the previous tests. For example, the following sequence of tests is expected to be done in this order, regarding a Web service definition:
	  </textual><orderedlist class="po-table e165 e165" numeration="arabic"><listitem class="po-container e166 e166"><para class="po-block e167 e167"><textual class="po-textual">Normative statement: "The wsdl:definitions MUST be a well-formed XML 1.0 document. The wsdl:definitions namespace MUST have value: http://schemas.xmlsoap.org/wsdl/." This is verified by the test assertion BP2703 below.
	      </textual><programlisting class="po-block e168 e168" xml:space="preserve"><textual class="po-textual">
		&lt;testAssertion id="BP2703" lg=”xpath20” &gt;
		&lt;target&gt;//wsil:descriptionFile[fn:prefix-from-QName
		(fn:node-name(*:definitions)) eq 'wsdl' or wsdl:definitions]&lt;/target&gt;
		&lt;predicate&gt;$target instance of schema-element($wsdlschema) &lt;/predicate&gt;
		...
		&lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	    </textual></para></listitem><listitem class="po-container e169 e169"><para class="po-block e170 e170"><textual class="po-textual">Normative statement: "The wsdl:binding element MUST have a wsoap12:binding child element." This is verified by the test assertion BP2402 below.
	      </textual><programlisting class="po-block e171 e171" xml:space="preserve"><textual class="po-textual">
		&lt;testAssertion id="BP2402" lg=”xpath20” &gt;
		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding&lt;/target&gt;
		&lt;prerequisite&gt;tag:BP2703($target/../..) eq 'pass'&lt;/prerequisite&gt;
		&lt;predicate&gt;child::wsoap12:binding&lt;/predicate&gt;
		...
		&lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	    </textual></para></listitem><listitem class="po-container e172 e172"><para class="po-block e173 e173"><textual class="po-textual">Normative statement: "The contained soap binding element MUST have a 'transport' attribute." This is verified by the test assertion BP2403 below.
	      </textual><programlisting class="po-block e174 e174" xml:space="preserve"><textual class="po-textual">
		&lt;testAssertion id="BP2403" lg=”xpath20” &gt;
		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding&lt;/target&gt;
		&lt;prerequisite&gt;tag:BP2402($target) eq 'pass'&lt;/prerequisite&gt;
		&lt;predicate&gt;not(wsoap12:binding[not(@transport)])&lt;/predicate&gt;
		...
		&lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	    </textual></para></listitem><listitem class="po-container e175 e175"><para class="po-block e176 e176"><textual class="po-textual">Normative statement: "The 'transport' attribute - if any - of the soap binding element MUST have value:
	      http://schemas.xmlsoap.org/soap/http." This is verified by the test assertion BP2404 below.
	      </textual><programlisting class="po-block e177 e177" xml:space="preserve"><textual class="po-textual">
		&lt;testAssertion id="BP2404" lg=”xpath20” &gt;
		&lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding[wsoap12:binding]
		&lt;/target&gt;
		&lt;prerequisite&gt;tag:BP2403($target) eq 'pass'&lt;/prerequisite&gt;
		&lt;predicate&gt;not(wsoap12:binding[@transport ne
		'http://schemas.xmlsoap.org/soap/http'])&lt;/predicate&gt;
		...
		&lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	    </textual></para></listitem></orderedlist><textual class="po-textual">
	  These four test assertions are chained via their prerequisite elements. This chaining means that if one fails, the subsequent tests will not be performed: whatever their outcome is, it might not make any sense or would at best produce an unnecessary distraction in the test report.
	</textual></para><para class="po-block e178 e178"><textual class="po-textual">(a2) In order to "reuse" (both at scripting time and at run-time) a complex expression outcome that has already been handled by another TA. For example in the Web services basic profile, a wsdl:binding must either be an rpc-literal binding or a document-literal binding. The test for ensuring this is not a simple one:
	  </textual><programlisting class="po-block e179 e179" xml:space="preserve"><textual class="po-textual">
	    &lt;testAssertion id="BP2017" lg=”xpath20” &gt;
	    &lt;target&gt;//wsil:descriptionFile/wsdl:definitions/wsdl:binding
	    [wsoap12:binding]&lt;/target&gt;
	    &lt;prerequisite&gt;tag:BP2404($target) eq 'pass'&lt;/prerequisite&gt;
	    &lt;predicate&gt;not(.//wsoap12:body/@use != 'literal')
	    and (count(.//wsoap12:body) = count(.//wsoap12:body/@use)) and
	    ((not(.//wsoap12:*/@style != 'rpc') and
	    not(.//wsoap12:operation[not(@style) and not(../../wsoap12:binding/@style)]))
	    or (not(.//wsoap12:*/@style != 'document')))&lt;/predicate&gt;
	    ...
	    &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	  Several test assertions relate only to document-literal type. Once it is known that a binding is of either above type, the test to distinguish an rpc-literal from a document-literal is fairly simple. In the following test assertion that applies only to document-literal type, this simple test - used here in the target expression - guarantees that only document-literal bindings will be selected:
	  </textual><programlisting class="po-block e180 e180" xml:space="preserve"><textual class="po-textual">
	    &lt;testAssertion id="BP2111" lg=”xpath20” &gt;
	    &lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding
	    [not(.//wsoap12:*[@style = 'rpc'])]&lt;/target&gt;
	    &lt;prerequisite&gt;tag:BP2017($target) eq 'pass'&lt;/prerequisite&gt;
	    &lt;predicate&gt;not(.//wsoap12:body[@parts and contains(@parts," ")])&lt;/predicate&gt;
	    ...
	    &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e181 e181"><textual class="po-textual">The other form of chaining (b) is done in the Predicate expression. This allows for defining "meta-level" test assertions that wrap entire groups of test assertions by summarizing their expected outcome in a single logical expression. Such a meta-level test assertion can then be referred by other test assertions in their prerequisite condition, when this entire group of tests must be passed.
	For example, consider BP1214 listed in the next section. This test assertion targets a SOAP message, but needs to access a contextual document: the interface binding definition that governs the content of this message. Before executing BP1214, it is clear that the binding definition must be verified. A meta-level test assertion can "summarize" all the tests that ensure this correctness for rpc-literal bindings:
	</textual><programlisting class="po-block e182 e182" xml:space="preserve"><textual class="po-textual">
	  &lt;testAssertion id="BP-rpc-bindings" lg=”xpath20” &gt;
	  &lt;target&gt;//wsil:descriptionFile/*:definitions/wsdl:binding
	  [.//wsoap12:*[@style = 'rpc']]&lt;/target&gt;
	  &lt;prerequisite&gt;tag:BP2017($target) eq 'pass'&lt;/prerequisite&gt;
	  &lt;predicate&gt;(tag:BP2404($target) eq 'pass') and
	  (tag:BP2406($target) eq 'pass') and (tag:BP2020($target) eq 'pass') and
	  (tag:BP2120b($target) eq 'pass') and (tag:BP2117($target) eq 'pass') and
	  (tag:BP2118($target) eq 'pass')
	  &lt;/predicate&gt;
	  ...
	  &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">

	The above test assertion may then be used as prerequisite for BP1214, over the binding definition related to its message target, i.e. the "binding" element parent of the "operation" element selected by the XPath expression in the variable $myOpBinding:
	</textual><programlisting class="po-block e183 e183" xml:space="preserve"><textual class="po-textual">
	  &lt;testAssertion id="BP1214"&gt;
	  &lt;var name="myOpBinding"&gt; ...&lt;/var&gt;
	  &lt;prerequisite&gt;tag:BP-rpc-bindings($myOpBinding/..) eq 'pass'&lt;/prerequisite&gt;
	  &lt;target type="message:SOAPmessage" &gt;/wsil:testLog/wsil:messageLog/wsil:message[...]
	  &lt;/target&gt;
	  ...
	  &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e184 e184"><title class="po-block e185 e185"><textual class="po-textual">Execution Semantics</textual></title><para class="po-block e186 e186"><textual class="po-textual">
	The general mode of execution for above TAs, is of a conventional forward-chaining rule engine. This is indeed necessary due to the chaining of test assertions, and departs radically from how other XPath-based rules systems are processed (e.g. Schematron or CAM do not handle chaining). The set of test assertions that have no references to other TAs is executed first over all candidate targets. This first set of test results for all possible target instances is recorded. In the next iteration of the engine, only TAs that have all their references resolved over the first set of results are executed in turn. Their results are added to the initial result set. Subsequent iterations add to the previous result set until iterations cannot augment anymore this result set which is considered stable. At this point, all possible validations have been made over the material under test, and they are ready for an (html) test report generation.
      </textual></para><para class="po-block e187 e187"><textual class="po-textual">
	In the XPath-extended XML markup of the TAG model, test assertions can be conditionally chained as rules to create dynamic test suites, the result of which can also be manipulated by higher-level test assertions. This approach is addressing the need to integrate validation of various XML artifacts, with validation of combinations of such artifacts (consistency across documents). Indeed, this requires composing and orchestrating test cases and test suites in a modular way.
      </textual></para></section><section class="po-hcontainer e188 e188"><title class="po-block e189 e189"><textual class="po-textual">Implementation Considerations</textual></title><para class="po-block e190 e190"><textual class="po-textual">
	The automation of TAG methodology is leveraging both XLST2.0 and XPath2.0. However, end-users (TA designers) only need to know about XPath to write test assertions. XSLT is only used for the execution engine.
	A two-phase processing of above test assertions has been implemented by the authors, as often used when XSLT is the target execution language.</textual></para><itemizedlist class="po-table e191 e191"><title class="po-block e192 e192"><textual class="po-textual">Phase 1:</textual></title><listitem class="po-container e193 e193"><para class="po-block e194 e194"><textual class="po-textual">input = set of test assertions (type: xml + XPath2.0)</textual></para></listitem><listitem class="po-container e195 e195"><para class="po-block e196 e196"><textual class="po-textual">processor = TAG engine generator (type: XSLT2.0)</textual></para></listitem><listitem class="po-container e197 e197"><para class="po-block e198 e198"><textual class="po-textual">output = test assertions engine for this set (type: XSLT2.0)</textual></para></listitem></itemizedlist><itemizedlist class="po-table e199 e199"><title class="po-block e200 e200"><textual class="po-textual">Phase 2:</textual></title><listitem class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">input = documents under test and context (xml)</textual></para></listitem><listitem class="po-container e203 e203"><para class="po-block e204 e204"><textual class="po-textual">processor = test assertions engine in output of Phase 1 (type: XSLT2.0)</textual></para></listitem><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">output = final test report (type: xml)</textual></para></listitem></itemizedlist><para class="po-block e207 e207"><textual class="po-textual">The first phase amounts to generating an XSLT-hardcoded test suite for a particular set of test assertions. The second phase amounts to executing this test suite. In addition to increased performance, the two-phase approach allows for advanced parameterization features in test assertions at different levels, with the use of variables:
	</textual><itemizedlist class="po-table e208 e208"><listitem class="po-container e209 e209"><para class="po-block e210 e210"><textual class="po-textual">“Generation" (or "Phase 1") variables: these are given a value during Phase 1. Such value assignments are hardcoded in the output of Phase 1.  Examples are those identifying contextual documents in a previous example (e.g. $allbooks, $allpublishers).</textual></para></listitem><listitem class="po-container e211 e211"><para class="po-block e212 e212"><textual class="po-textual">"Run-time" (or “Phase 2”) variables: these may have a different value at each execution of the test assertion. Such variables are used to break down complex expressions for Target, Prerequisite and Predicate, or to point at contextual documents that may vary from one target to the other. In the example below, the Target is a SOAP message, and the variable "myOpBinding" identifies the definition of the Web service operation (here the WSDL file is in the same log as the message trace) associated with this target instance (referred to using the pseudo variable "$target"): </textual></para></listitem></itemizedlist><textual class="po-textual">
	</textual><programlisting class="po-block e213 e213" xml:space="preserve"><textual class="po-textual">
	  &lt;testAssertion id="BP1214"&gt;
	  &lt;var name="myOpBinding"&gt;//wsil:descriptionFile/wsdl:definitions/wsdl:binding
	  [.//wsoap12:*[@style = 'rpc']]/wsdl:operation
	  [@name =  fn:local-name-from-QName(node-name($target/soap12:Body/*[1]))]&lt;/var&gt;
	  &lt;target type="message:SOAPmessage" &gt;/wsil:testLog/wsil:messageLog/wsil:message[...]
	  &lt;/target&gt;
	  ...
	  &lt;/testAssertion&gt;</textual></programlisting><textual class="po-textual">
	This test assertion verifies that the message is conforming to some aspect of its binding definition.
      </textual></para><para class="po-block e214 e214"><textual class="po-textual">
	Two of the authors have developed test suites for Web Services profiles developed by the WS-Interoperability consortium (http://www.ws-i.org) using the XPath2.0-extended TAG model.  These test suites include test cases that involve a combination of documents (WSDL, Schemas) and sequences of messages. About 250 test assertions were developed for three WS profiles. The entire test suite execution process (Phase 1 + Phase 2 + html rendering of the test report) is handled by stylesheets.
      </textual></para><para class="po-block e215 e215"><textual class="po-textual">
	Prior to this one author had been leading a similar test tool development process for WS-I based on conventional programming languages (Java, C#) [4]. The advantage of the recent approach using XPath and XSL are:
	</textual><itemizedlist class="po-table e216 e216"><listitem class="po-container e217 e217"><para class="po-block e218 e218"><textual class="po-textual">Reliance on specialized XML dialects that have been developed over various platforms and have been tested for consistency across these platforms, removes platform-dependency of test tools (e.g. .NET, Java).</textual></para></listitem><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">Visibility of the TA logic (test assertion definitions are currently embedded in the WS-I Profile document and readable by end-users and developers who need to comply with these profiles). In the previous approach, the logic of tests was buried in the binaries of the test tools.</textual></para></listitem><listitem class="po-container e221 e221"><para class="po-block e222 e222"><textual class="po-textual">A modest but real gain in test suite design and overall development effort and the related QA cycles.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e223 e223"><textual class="po-textual">
	Originally, the authors attempted to use XPath1.0 as expression language for TAs. This was not sufficient to handle complex correlations of XML-fragment (either intra-document or cross-document) required by WS-I test suites. XPath2.0 provided new features that significantly enhanced the expressive power of target / prerequisite / predicate expressions, such as quantified expressions, iterations and an extensive library of functions. Advanced correlation patterns inside Predicate could be expressed in a declarative way as a set of nested quantified expressions, making it possible to assign and reuse variables at each level.
      </textual></para><para class="po-block e224 e224"><textual class="po-textual">
	XSLT2.0 proved a suitable script language to implement a forward-chaining test assertion engine thanks to features such as next-match(), while the authors have not been successful at trying this with XSLT1.0.
      </textual></para><para class="po-block e225 e225"><textual class="po-textual">
	Along the line of managing complexity by leveraging the composability of test assertions and of their execution (chaining of test assertions, parameterization, meta-level assertions), a future enhancement will allow a test assertion to define “byproducts” , i.e. XML fragments produced by their execution (in addition to the main outcome “pass”, “fail” etc.) that can be reused in Prerequisite or Predicate of referring test assertions.
      </textual></para></section></section><section class="po-hcontainer e226 e226"><title class="po-block e227 e227"><textual class="po-textual">Other Works in Semantic Validation of Documents</textual></title><section class="po-hcontainer e228 e228"><title class="po-block e229 e229"><textual class="po-textual">Schematron</textual></title><para class="po-block e230 e230"><textual class="po-textual">
  	        Schematron is a simple pattern and rule language well-focused on document testing. It leverages XPath functions and expressions, and can be implemented using XSLT. Rules in Schematron can be seen as serving similar purpose as test assertions. However the authors, after initially attempting to develop WS-I test suites with Schematron 1.5, had to give up mostly due to its restricted rule execution semantics: there is no support for "logical" rule chaining, and in a pattern only one rule - the first that matches the context - will execute. This form of "if-then-else" chaining  applies to the context matching and not to the result of the rule itself, unlike what is expected in conventional rule-based systems.
  	</textual></para><para class="po-block e231 e231"><textual class="po-textual">
  	        Schematron has been designed around the idea that the entity under test is the document, while in our test assertion engine it is before all an XML fragment, subset of some document. Each fragment (target) is systematically identified according to a well-defined scheme for its target type. This identity - defined by an XPath expression - is not only used for detailed diagnostic information in the test report, but is central to the rule chaining mechanism of the test engine, i.e. for deciding of the order of the tests on this target. Schematron allows for detailed and dynamic diagnostic information that has the ability to fully identify a subset of a document, but this does not play any role in the rule processing mechanism. Some valuable convenience feature had to be added to test assertions in the form of variables, for handling of complex Predicate expressions or to parameterize test assertions. Such variables are also supported in Schematron 1.6. On the modeling side, Schematron introduces a hierarchy of constructs (assertion, rule, pattern, phase). In contrast, the presented approach is based on a flat model relying on a single construct - test assertion - composable at different levels, but subject to the same execution semantics.
  	</textual></para><para class="po-block e232 e232"><textual class="po-textual">
  	        Although Schematron can be written against any XML document, it is primarily intended for XML instances. Namespace handling becomes difficult when writing rules against an XML schema, and when there is a namespace prefix in a value of an attribute or element. Schemas often need be tested against naming and design rules [5]. Rules are label specific, i.e., there is no inheritance. If there is a type hierarchy, separate rules have to be written for every type even if the intention is the same. In Schematron 1.5 rules cannot be reused or combined programmatically, although ISO Schematron has more provision for reusability such as abstract pattern and include statement.
  	</textual></para><para class="po-block e233 e233"><textual class="po-textual">
  	         In conclusion, although Schematron is well-positioned for document validation through its lifecycle and is sufficient for many test cases, it has been designed more in the spirit of validating content in a type-checking mode (an extended schema). Its rules are intended for detecting patterns in documents and not to be executed along a test suite processing model requiring tight control on which tests are executed and when based on previous tests results. We believe the concept of test suite is appropriate when considering a combination of diverse XML artifacts including XML-formatted data of non XML source.
  	</textual></para></section><section class="po-hcontainer e234 e234"><title class="po-block e235 e235"><textual class="po-textual">OWL</textual></title><para class="po-block e236 e236"><textual class="po-textual">
	OWL by itself is not a rule or test language. It rather allows for declarative semantic models. The handling and mapping of ontologies is an important aspect of validation [6]. OWL reasoner can determine if there is a conflict based on the characteristics of a particular object instance – in our context, a test target - based on a semantic definition of class membership. OWL's “open world assumption” makes it difficult to use it to validate documents. The open world assumption states that even if an object instance has not declared one of its property, the reasoner cannot assume that it does not exist. Typically, a programming routine needs to be written to “close the world” by explicitly asserting that this object instance has no such property.
      </textual></para><para class="po-block e237 e237"><textual class="po-textual">
	Because OWL is designed for acceptable computational time, its expressivity has been limited. Even in OWL Full (the most expressive level of OWL language), the semantic expressivity is limited to constraints around cardinalities and a few relationships between class and properties such as transitive, inverse, and uniqueness. Expressing arithmetic relationships between properties is virtually impossible. There are also few reasoner that can perform OWL Full reasoning and more importantly datatype reasoning (particularly user defined datatype necessary to validate against a range of values or a code list). OWL reasoners typically process data in triple representation, which is memory-greedy. Validating a few megabytes of document on a typical desktop with one to two gigabytes of memory almost becomes impossible (industrial strength reasoning engine and memory or storage management - such as Oracle RDF database - would be needed).
      </textual></para></section><section class="po-hcontainer e238 e238"><title class="po-block e239 e239"><textual class="po-textual">XBRL</textual></title><para class="po-block e240 e240"><textual class="po-textual">
	The XBRL conformance test suite is worth consideration more as a typical use case than a reusable tool. It is an example of validating a (set of) complex document(s) with advanced semantics, that must comply with various rules in addition to schema compliance. It also encompasses the testing of processors supposed to produce such documents, illustrating how document-testing and processor-testing are intertwined.
	The “minimal” conformance suite focuses on the document validation while “full” conformance targets XBRL processors. Full conformance involves other documents than the main document being processed, and relies on output documents (Post-Taxonomy Validation infosets) that reflect the processing semantics. Minimal conformance generally contains at least one test for each appearance in the specification of ‘MUST’ that are not already enforced by XML Schema validation.
	The structure of the test suite is based on the OASIS XSL Conformance Suite.  The structure of each individual test is simple:
	</textual><itemizedlist class="po-table e241 e241"><listitem class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">.xsd or .xml input material to the XBRL processor (schema, linkbase, instance)</textual></para></listitem><listitem class="po-container e244 e244"><para class="po-block e245 e245"><textual class="po-textual">A test case file (.xml)</textual></para></listitem><listitem class="po-container e246 e246"><para class="po-block e247 e247"><textual class="po-textual">An expected output .xml</textual></para></listitem></itemizedlist><textual class="po-textual">
	Each test case is described by a "meta-level" XML file that refers to associated test material. Some XML files are describing the expected outputs for each test case. The overall test engine is an ad-hoc stylesheet that runs the tests. The pass / fail decision for each case is based on the comparison of canonical forms of actual output and expected output.
	 A first assessment allows to conclude that each test case could be scripted as a test assertion. When specialized operations are needed (like file canonicalization using infoset.xsl, or file comparison) these could be wrapped as xsl functions used in the test assertion expressions. Assuming a two-phase testing process (running XBRL processor, then validating results), the test assertion engine described here could handle the validation phase, which relies on XML documents.
      </textual></para></section></section><section class="po-hcontainer e248 e248"><title class="po-block e249 e249"><textual class="po-textual">Conclusion</textual></title><para class="po-block e250 e250"><textual class="po-textual">
      A general-purpose test methodology based on a formal notion of test assertion (originally not intended exclusively for XML input) has proved adequate for the testing of XML artifacts where contextual material of various kinds need be taken into account. When extended and implemented with XML dialects such as XPath2.0 and XSLT2.0, this method has proved more powerful for such XML inputs than dedicated test tools. The resulting test model does not introduce a hierarchy of constructs, but uses a flexible notion of test assertion as the main construct for expressing atomic test results as well as for chaining and composing test units.
    </textual></para><para class="po-block e251 e251"><textual class="po-textual">
      Another benefit of the proposed approach is to keep XSLT “under the hood” and not make it part of the definition language of test cases. There is also no need to develop an XSLT test program specific to a test suite. This contrasts with ad-hoc test suites such as XBRL’s. With a robust test assertion model, only XPath needs be mastered by test developers.
    </textual></para><para class="po-block e252 e252"><textual class="po-textual">
      Future plans include standardization of the TAG mark-up and its XPath extension, along with an open-source - style availability of the XSLT-based engine technology that supports it.
    </textual></para></section><bibliography class="po-hcontainer e253 e253"><title class="po-block e254 e254"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e255 e255" xml:id="A1" xreflabel="1"><textual class="po-textual">Holman, K., Green, S., Bosak, J., McGrath, T., Schlegel, S. ; </textual><emphasis class="po-inline e256 e256" role="ital"><textual class="po-textual">Use of XPath to apply constraints to an XML Schema to produce a subset conformance profile ;</textual></emphasis><textual class="po-textual"> UBL 1.0 Small Business Subset; 2006 </textual><link class="po-inline e257 e257" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oasis-open.org/ubl/cs-UBL-1.0-SBS-1.0/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e258 e258" xml:id="A2" xreflabel="2"><textual class="po-textual">Durand, J., Kulvatunyou,  S., Woo  J.,and Martin, M. ; </textual><emphasis class="po-inline e259 e259" role="ital"><textual class="po-textual">Testing and Monitoring E-Business using the Event-driven Test Scripting Language ;</textual></emphasis><textual class="po-textual"> proceedings I-ESA (Interoperability of Enterprise Systems and Applications), April 2007
    </textual></bibliomixed><bibliomixed class="po-block e260 e260" xml:id="A3" xreflabel="3"><textual class="po-textual">Glushko, R., and McGrath, T. ; </textual><emphasis class="po-inline e261 e261" role="ital"><textual class="po-textual">Analyzing and Designing Documents for Business Informatics and Web Services ;</textual></emphasis><textual class="po-textual"> MIT Press, March 2008
    </textual></bibliomixed><bibliomixed class="po-block e262 e262" xml:id="A4" xreflabel="4"><textual class="po-textual">Durand, J. ; </textual><emphasis class="po-inline e263 e263" role="ital"><textual class="po-textual">"Will Your SOA Systems Work in the Real World?”  ;</textual></emphasis><textual class="po-textual"> STAR-East, Software Testing Analysis and Review Conference, May 2007
    </textual></bibliomixed><bibliomixed class="po-block e264 e264" xml:id="A5" xreflabel="5"><textual class="po-textual">Lubell, J., Kulvatunyou, B., Morris, K.C., Harvey, B. ; </textual><emphasis class="po-inline e265 e265" role="ital"><textual class="po-textual">A Tool Kit for Implementing XML Schema Naming and Design Rules ;</textual></emphasis><textual class="po-textual"> Extreme Markup Languages Conference, August 2006, Montreal, Canada.
    </textual></bibliomixed><bibliomixed class="po-block e266 e266" xml:id="A6" xreflabel="6"><textual class="po-textual">Anicic, N. , Marjanovic, Z. , Ivezic, N. , Jones, A. W. ; </textual><emphasis class="po-inline e267 e267" role="ital"><textual class="po-textual">Semantic Enterprise Application Integration Standards ;</textual></emphasis><textual class="po-textual">  International Journal of Manufacturing Technology and Management (IJMTM) , April, 2006
    </textual></bibliomixed><bibliomixed class="po-block e268 e268" xml:id="A7" xreflabel="7"><textual class="po-textual">Green, S., Holman, K.; </textual><emphasis class="po-inline e269 e269" role="ital"><textual class="po-textual">The Universal Business Language and the Needs of Small Business;</textual></emphasis><textual class="po-textual"> iTSC Synthesis Journal 2004.
    </textual></bibliomixed><bibliomixed class="po-block e270 e270" xml:id="A8" xreflabel="8"><emphasis class="po-inline e271 e271" role="ital"><textual class="po-textual">Test Assertions Guidelines;</textual></emphasis><textual class="po-textual"> OASIS TAG technical Committee, February 2009.</textual><link class="po-inline e272 e272" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oasis-open.org/committees/document.php?document_id=31076</textual></link><textual class="po-textual">
    </textual></bibliomixed></bibliography></article></classedDocument>