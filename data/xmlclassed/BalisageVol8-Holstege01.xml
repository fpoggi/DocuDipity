<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Type Introspection in XQuery</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Type introspection gives a program the ability to determine the
type of object at runtime and manipulate the type of the object as an object
in its own right. It can be used as a basis for generic and flexible services,
meta-programming, runtime adaptation, and data exploration and discovery. This
paper explores providing some type introspection capabilities to XQuery,
looking at some design and implementation issues, and demonstrating the
application of type introspection in various ways.
        </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Mary</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Holstege</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Mary Holstege is Principal Engineer at MarkLogic
Corporation.  She has worked as a software engineer in and around markup
technologies for over 20 years.  She is a member of the W3C XML Schema and XML
Query working groups, and an editor of the W3C XML Schema Component Designators
and the XML Query Full Text specifications.  Mary Holstege holds a Ph.D. from
Stanford University in Computer Science, for a thesis on document
representation.</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Principal Engineer</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">MarkLogic Corporation</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">mary.holstege@marklogic.com</textual></email></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Copyright Â© 2012 Mary Holstege</textual></para></legalnotice></info><section class="po-hcontainer e20 e20"><title class="po-block e21 e21"><textual class="po-textual">Introduction</textual></title><para class="po-block e22 e22"><textual class="po-textual">Type introspection gives a program the ability to determine the
type of data item at runtime and manipulate the type as a data item in
its own right. It allows the creation of more generic and flexible
data-processing frameworks, and allows operations to be constructed in a
more data-driven way. Type introspection also enables data exploration and
discovery. This paper explores one way of providing type introspection
capabilities to XQuery, looks at some design and implementation issues, and
shows the application of type introspection in various ways.
       </textual></para><para class="po-block e23 e23"><textual class="po-textual">It may seem odd to talk about type introspection in the context of
XQuery, given that it is not an object-oriented language, and meta-classes and
type introspection are object-oriented concepts. However, XQuery does have the
concept of a type hierarchy with subtypes and supertypes. Instance variables
can be statically identified as being of one type, while being
dynamically instances of some subtype. Instead of
classic objects and base types, XQuery has XML nodes and base (atomic) types.
Adding structural type introspection to XQuery brings powerful
meta-programming patterns to XML.
      </textual></para><para class="po-block e24 e24"><textual class="po-textual">Many programming languages offer some kind of reflection or
introspection. These terms are frequently used somewhat
interchangeably. Gabriel 
et al </textual><citation class="po-atom e25 e25" linkend="clos"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> define reflection as "the ability of a program
to manipulate as data something representing the state of the program during
its own execution", and divide it into two parts: introspection and
effectuation. Introspection is the observational aspect of reflection;
effectuation is the active aspect, the making of changes to the program state. 
Singh </textual><citation class="po-atom e26 e26" linkend="introc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> usefully distinguishes between
type identification, structural introspection, and behavioural introspection.
Type identification allows a program to determine whether an object is an
instance of a particular class (or type). Structural introspection provides the
programmatic means to examine attributes of the class, such as its
base class and members. Behavioural introspection allows for the examination of
the runtime operations of a program. In this paper, we are concerned with type
introspection, and so we will not address behavioural introspection further.
       </textual></para><para class="po-block e27 e27"><textual class="po-textual">Some form of type identification is common
to many programming languages. For example, the Java or PHP
</textual><code class="po-atom e28 e28"><textual class="po-textual">instanceof</textual></code><textual class="po-textual">, the C++ </textual><code class="po-atom e29 e29"><textual class="po-textual">dynamic_cast</textual></code><textual class="po-textual">, the Perl
</textual><code class="po-atom e30 e30"><textual class="po-textual">isa</textual></code><textual class="po-textual"> all provide for type identification, where 
the reference type is named statically and must be known at compile time.
XQuery </textual><citation class="po-atom e31 e31" linkend="xq30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> provides for this form of type
identification too, through the </textual><code class="po-atom e32 e32"><textual class="po-textual">instance of</textual></code><textual class="po-textual"> keyword pair.
      </textual></para><figure class="po-container e33 e33" xml:id="fig_type_id"><title class="po-block e34 e34"><textual class="po-textual">Type Identification Examples</textual></title><programlisting class="po-block e35 e35" xml:space="preserve"><textual class="po-textual">
/* C++ example */
QName* name = dynamic_cast&lt;QName*&gt;(&amp;value);
if (name != 0) {
  cout &lt;&lt; name-&gt;namespaceURI();
}

/* Java example */
if (value instanceof QName) {
  QName qn = (QName)value;
  System.out.println(qn.namespaceURI());
}

(: XQuery example :)
if ($value instance of xs:QName) {
  fn:namespace-uri-from-QName($value)
}
      </textual></programlisting><caption class="po-container e36 e36"><para class="po-block e37 e37"><textual class="po-textual">Examples of type identification in several languages.</textual></para></caption></figure><para class="po-block e38 e38"><textual class="po-textual">XQuery allows for named types to be applied in several ways:
through the use of the </textual><code class="po-atom e39 e39"><textual class="po-textual">instance of</textual></code><textual class="po-textual">, </textual><code class="po-atom e40 e40"><textual class="po-textual">cast as</textual></code><textual class="po-textual">, 
</textual><code class="po-atom e41 e41"><textual class="po-textual">treat as</textual></code><textual class="po-textual">, and (in XQuery 3.0) </textual><code class="po-atom e42 e42"><textual class="po-textual">validate as</textual></code><textual class="po-textual">
constructs, and through the use of sequence type matching in 
</textual><code class="po-atom e43 e43"><textual class="po-textual">typeswitch</textual></code><textual class="po-textual"> and argument or variable binding constructs. A program
can use the constructs to ensure that data is properly typed in accordance with
the assumptions of processing and dispatch to the appropriate processing for
the type. </textual></para><para class="po-block e44 e44"><textual class="po-textual">Consider, for example, writing some code to analyze dates in
documents of various kinds, where the documents may use different kinds of
dates. Suppose further the documents come in a variety of forms and we do not
necessarily have schemas for every document, although we do have schemas
defining each date format. If a document has a schema, then a
</textual><code class="po-atom e45 e45"><textual class="po-textual">typeswitch</textual></code><textual class="po-textual"> or </textual><code class="po-atom e46 e46"><textual class="po-textual">instance of</textual></code><textual class="po-textual"> test could be used to
determine which analysis function to apply, and type sequence matching could be
used to ensure that the analysis code is applied properly to ensure
correctness. In other cases </textual><code class="po-atom e47 e47"><textual class="po-textual">castable as</textual></code><textual class="po-textual"> and </textual><code class="po-atom e48 e48"><textual class="po-textual">cast as</textual></code><textual class="po-textual">
can be used to perform this job.
</textual><xref class="po-milestone e49 e49" linkend="fig_dateex_1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a fragment of XQuery dispatching to the
appropriate analysis code along these lines.</textual></para><figure class="po-container e50 e50" xml:id="fig_dateex_1"><title class="po-block e51 e51"><textual class="po-textual">XQuery Type-Based Dispatch</textual></title><programlisting class="po-block e52 e52" xml:space="preserve"><textual class="po-textual">
import module iso="http://example.com/dates/iso";
import module vat="http://example.com/dates/vatican";
...

declare function my:process-date($date) 
{
  if ($date castable as iso:date) 
  then iso:process-date($date cast as iso:date)
  else if ($date castable as vat:date)
  then vat:process-date($date cast as vat:date)
  (: etc. one for each format :)
  ...
};  
      </textual></programlisting><caption class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">XQuery fragment for dispatching based on hard-coded type
tests and functions.</textual></para></caption></figure><para class="po-block e55 e55"><textual class="po-textual">
In all the XQuery constructs, the type must be a named type,
and its properties cannot be inspected, compared, or reapplied. In particular,
any annotations or facets associated with the type are not accessible to the
program directly. One cannot ask
for the type of one item and use it in any way to construct a new instance of
that type. The code must explicitly reference the names of any types it needs.
      </textual></para><para class="po-block e56 e56"><textual class="po-textual">Many languages also provide for structural introspection as well as
type identification. Java's </textual><code class="po-atom e57 e57"><textual class="po-textual">Class</textual></code><textual class="po-textual"> class and the reflection API
</textual><citation class="po-atom e58 e58" linkend="java"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> and Perl 6's </textual><citation class="po-atom e59 e59" linkend="perl"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> class traits
and methods allow for structural reflection.
Use of a meta-class in this way is the common pattern
for providing structural introspection. It generally also allows for more
dynamic type introspection, as well as dynamic instance construction.
XQuery does not provide for this kind of type introspection. The rest of this
paper explores adding structural type introspection to XQuery.
      </textual></para><figure class="po-container e60 e60" xml:id="fig_struct_intro"><title class="po-block e61 e61"><textual class="po-textual">Structural Introspection Examples</textual></title><programlisting class="po-block e62 e62" xml:space="preserve"><textual class="po-textual">
Class myClass = value.class;
Class paramTypes[] new Class[1];
paramTypes[0] = String.TYPE;
Constructor ct = myClass.getConstructor(paramTypes);
Object args[] = new Object[1];
args[0] = new String("Hello World");
Object newObject ct.newInstance(args);
      </textual></programlisting><caption class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">Example of Java structural introspection. We get the class
of a particular value, find a constructor that takes a string argument, and
construct a new instance of the class.</textual></para></caption></figure><para class="po-block e65 e65"><textual class="po-textual">XQuery 3.0 introduces a couple of new features that interact well
with type introspection: function items and the simple mapping operator
(represented with the ! character). Function items allow functions to be
treated as values, assigned to variables, and passed as arguments to
functions. As we will see below, in some cases we will treat types as function
items for some purposes. Beyond that, however, putting function names in schema
annotations makes it possible to write generic data-driven processing
frameworks, by using the introspection API to obtain the name of the function
to perform some particular operation, and the function lookup and function
application features to execute that operation. The simple mapping operator
allows for mapping of non-node values in streamlined path-like
expressions. Many of the examples that follow use one or the other of these
constructs. Expressions involving the simple mapping operator could be
rewritten in other ways, but use of function items cannot be readily
replaced in an XQuery 1.0 setting. I will point out alternatives where they
exist. 
    </textual></para></section><section class="po-hcontainer e66 e66"><title class="po-block e67 e67"><textual class="po-textual">Types as Values</textual></title><para class="po-block e68 e68"><textual class="po-textual">Where should XQuery meta-classes fit into the existing classes in
the type hierarchy? What do the classes look like?
XQuery has a complex type system, integrating simple and complex types from
XML Schema </textual><citation class="po-atom e69 e69" linkend="xsd11dt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, node kinds from the XQuery and XPath
data model </textual><citation class="po-atom e70 e70" linkend="xq30dm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual">, as well as special item
types such as function items. 
      </textual></para><figure class="po-container e71 e71" xml:id="fig_xq30"><title class="po-block e72 e72"><textual class="po-textual">XQuery 3.0 Type Hierarchy</textual></title><mediaobject class="po-container e73 e73"><imageobject class="po-container e74 e74"><imagedata class="po-meta e75 e75" fileref="../../../vol8/graphics/Holstege01/Holstege01-001.png" format="png" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e76 e76"><para class="po-block e77 e77"><textual class="po-textual">The diagram shows the main branches in the XQuery 3.0 type
hierarchy. Diamonds represent abstract types.  See the XPath data model </textual><citation class="po-atom e78 e78" linkend="xq30dm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> for more details.</textual></para></caption></figure><para class="po-block e79 e79"><textual class="po-textual">XML Schema </textual><citation class="po-atom e80 e80" linkend="xsd11st"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> defines a complex set of
schema component types. Each schema component has its own collection of
properties, some of which are components themselves. For example, among the
properties on a simple type definition are its name, a base type definition, a
primitive type definition, an indicator of constraints on deriving new
subtypes, whether it is a list or union type, and a variety of facets
indicating additional constraints such as the maximum permitted value.
      </textual></para><para class="po-block e81 e81"><textual class="po-textual">For our purposes, adding richer type introspection to XQuery
amounts to creating values that represent schema components and providing
mechanisms for accessing those components and their their properties.
      </textual></para><para class="po-block e82 e82"><textual class="po-textual">Values representing types have some similarities with nodes
and function items. Like nodes, schema components are complex objects with many
properties, such as names. However, most of the accessors for nodes do not
apply to schema components and most operations on nodes do not apply to schema
components. In XQuery, every simple type also creates an implicit constructor
function. In this sense, simple types act as function items. We could perhaps 
make type values a kind of function item. However, type values are different
from function items in every other way, and other schema components are not
like functions at all. Values representing key schema components will be placed
in the XQuery type hierarchy as a new kind of item. 
      </textual></para><para class="po-block e83 e83"><textual class="po-textual">
There are two kinds of type definition component: simple type definitions and
complex type definitions. Corresponding to each of these components is a
component value, one for simple type definitions and one for complex type
definitions. Since the distinction
between a simple type and a complex type matters in some cases (values can
only be cast to simple types, for example), but not in others (when we don't
know whether a particular element has a simple type definition or a complex
type definition, but we want to know its name, regardless), we introduce a
superclass "type definition" that encompasses both simple type definitions and
complex type definitions. 
      </textual></para><figure class="po-container e84 e84" xml:id="fig_type"><title class="po-block e85 e85"><textual class="po-textual">Type Values</textual></title><mediaobject class="po-container e86 e86"><imageobject class="po-container e87 e87"><imagedata class="po-meta e88 e88" fileref="../../../vol8/graphics/Holstege01/Holstege01-002.png" format="png" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e89 e89"><para class="po-block e90 e90"><textual class="po-textual">Type values as component values, a new kind of item()</textual></para></caption></figure><para class="po-block e91 e91"><textual class="po-textual">Integrating these new value types into XQuery involves:
      </textual><itemizedlist class="po-table e92 e92"><listitem class="po-container e93 e93"><para class="po-block e94 e94"><textual class="po-textual">Defining sequence type tests</textual></para></listitem><listitem class="po-container e95 e95"><para class="po-block e96 e96"><textual class="po-textual">Defining the means to obtain type values from other values</textual></para></listitem><listitem class="po-container e97 e97"><para class="po-block e98 e98"><textual class="po-textual">Determining how existing functions and operators apply to type values</textual></para></listitem><listitem class="po-container e99 e99"><para class="po-block e100 e100"><textual class="po-textual">Defining useful functions and operators over type values</textual></para></listitem><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">Defining accessors on type values</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e103 e103"><textual class="po-textual">Let's look at each of these steps in turn.</textual></para><section class="po-hcontainer e104 e104"><title class="po-block e105 e105"><textual class="po-textual">Type Tests for Type Values</textual></title><para class="po-block e106 e106"><textual class="po-textual">For each kind of component value there is a sequence type test that
matches values of that kind. Since types might have names, sequence type tests
for type values can have a QName and will match if either the type has that
name or it has a base type that matches.
      </textual></para><figure class="po-container e107 e107" xml:id="fig_type_tests"><title class="po-block e108 e108"><textual class="po-textual">Sequence Type Tests: Types</textual></title><variablelist class="po-table e109 e109"><varlistentry class="po-record e110 e110"><term class="po-block e111 e111"><code class="po-atom e112 e112"><textual class="po-textual">component()</textual></code></term><listitem class="po-container e113 e113"><para class="po-block e114 e114"><textual class="po-textual">Matches any component value.</textual></para></listitem></varlistentry><varlistentry class="po-record e115 e115"><term class="po-block e116 e116"><code class="po-atom e117 e117"><textual class="po-textual">type()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e118 e118"><textual class="po-textual">type(*)</textual></code></term><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">Matches any type component value.</textual></para></listitem></varlistentry><varlistentry class="po-record e121 e121"><term class="po-block e122 e122"><code class="po-atom e123 e123"><textual class="po-textual">type(q:name)</textual></code></term><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">Matches any type component whose name matches the
  given QName, or which is a subtype of a component with that type.</textual></para></listitem></varlistentry><varlistentry class="po-record e126 e126"><term class="po-block e127 e127"><code class="po-atom e128 e128"><textual class="po-textual">simple-type()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e129 e129"><textual class="po-textual">simple-type(*)</textual></code></term><listitem class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual">Matches any simple type component value.</textual></para></listitem></varlistentry><varlistentry class="po-record e132 e132"><term class="po-block e133 e133"><code class="po-atom e134 e134"><textual class="po-textual">simple-type(q:name)</textual></code></term><listitem class="po-container e135 e135"><para class="po-block e136 e136"><textual class="po-textual">Matches any simple type component whose name matches the
  given QName, or which is a subtype of a component with that type.</textual></para></listitem></varlistentry><varlistentry class="po-record e137 e137"><term class="po-block e138 e138"><code class="po-atom e139 e139"><textual class="po-textual">complex-type()</textual></code><textual class="po-textual"> or </textual><code class="po-atom e140 e140"><textual class="po-textual">complex-type(*)</textual></code></term><listitem class="po-container e141 e141"><para class="po-block e142 e142"><textual class="po-textual">Matches any complex type component value.</textual></para></listitem></varlistentry><varlistentry class="po-record e143 e143"><term class="po-block e144 e144"><code class="po-atom e145 e145"><textual class="po-textual">complex-type(q:name)</textual></code></term><listitem class="po-container e146 e146"><para class="po-block e147 e147"><textual class="po-textual">Matches any complex type component whose name matches the
  given QName, or which is a subtype of a component with that type.</textual></para></listitem></varlistentry></variablelist></figure></section><section class="po-hcontainer e148 e148"><title class="po-block e149 e149"><textual class="po-textual">Obtaining Type Values</textual></title><para class="po-block e150 e150"><textual class="po-textual">Linkage functions get component values from various kinds of
items. They are defined over all kinds of items, returning the empty sequence
if necessary. These functions all take any item as a parameter and have a
zero-argument form that applies to the context item. This is a small usability
feature, but makes such expressions as
</textual><code class="po-atom e151 e151"><textual class="po-textual">/root/child/sc:simple-type()</textual></code><textual class="po-textual"> possible.
      </textual></para><para class="po-block e152 e152"><textual class="po-textual">In this paper, the schema component linkage and accessor functions
are all defined as being in the namespace bound to the prefix </textual><code class="po-atom e153 e153"><textual class="po-textual">sc</textual></code><textual class="po-textual">
which the examples assume to be predefined. The specific namespace chosen is
not important. The experimental implementation used
</textual><code class="po-atom e154 e154"><textual class="po-textual">http://marklogic.com/xdmp/schema-components</textual></code><textual class="po-textual">. 
      </textual></para><figure class="po-container e155 e155" xml:id="fig_linkage_api"><title class="po-block e156 e156"><textual class="po-textual">Accessors Linking from Items to Component Values</textual></title><variablelist class="po-table e157 e157"><varlistentry class="po-record e158 e158"><term class="po-block e159 e159"><code class="po-atom e160 e160"><textual class="po-textual">sc:type([$context as item()]) as type()?</textual></code></term><listitem class="po-container e161 e161"><para class="po-block e162 e162"><textual class="po-textual">Get the type of the item as a value.</textual></para></listitem></varlistentry><varlistentry class="po-record e163 e163"><term class="po-block e164 e164"><code class="po-atom e165 e165"><textual class="po-textual">sc:simple-type([$context as item()]) as simple-type()?</textual></code></term><listitem class="po-container e166 e166"><para class="po-block e167 e167"><textual class="po-textual">Get the simple type of the item as a value.</textual></para></listitem></varlistentry><varlistentry class="po-record e168 e168"><term class="po-block e169 e169"><code class="po-atom e170 e170"><textual class="po-textual">sc:complex-type([$context as item()]) as complex-type()?</textual></code></term><listitem class="po-container e171 e171"><para class="po-block e172 e172"><textual class="po-textual">Get the complex type of the item as a value.</textual></para></listitem></varlistentry></variablelist></figure><para class="po-block e173 e173"><textual class="po-textual">XQuery introduces an interesting wrinkle that is not found in most
other programming language type systems: some data may be untyped. The special
types </textual><code class="po-atom e174 e174"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual"> and </textual><code class="po-atom e175 e175"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual"> represent such
untyped complex and simple content.
      </textual></para><para class="po-block e176 e176"><textual class="po-textual">For atomic values that are instances of a particular simple type,
the </textual><code class="po-atom e177 e177"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual"> linkage function returns that simple type as a
component value. If the atomic type is untyped, then a simple type definition value
for </textual><code class="po-atom e178 e178"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual"> is returned. The accessor
</textual><code class="po-atom e179 e179"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual"> operates on attribute nodes in a similar fashion.
The operation on element nodes is similar, except that if
the element is an instance of a complex type, </textual><code class="po-atom e180 e180"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual">
returns the empty sequence. For other kinds of items, the empty sequence is returned.
      </textual></para><para class="po-block e181 e181"><textual class="po-textual">The linkage function </textual><code class="po-atom e182 e182"><textual class="po-textual">sc:complex-type</textual></code><textual class="po-textual"> works analogously
like </textual><code class="po-atom e183 e183"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual"> except atomic values and attributes can never
be instances of a complex type, so </textual><code class="po-atom e184 e184"><textual class="po-textual">sc:complex-type</textual></code><textual class="po-textual"> is only useful
for element nodes. If an element node is an instance of a specific
complex type, the value will be that complex type as a component value. If the
element node is untyped, </textual><code class="po-atom e185 e185"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual"> will be returned as a complex type
component value. When an element is an instance of a simple type,
</textual><code class="po-atom e186 e186"><textual class="po-textual">sc:complex-type</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e187 e187"><textual class="po-textual">xs:anyType</textual></code><textual class="po-textual"> as a complex type component
value. For other items, the empty sequence is returned.
      </textual></para><para class="po-block e188 e188"><textual class="po-textual">The </textual><code class="po-atom e189 e189"><textual class="po-textual">sc:type</textual></code><textual class="po-textual"> accessor combines certain aspects of the
</textual><code class="po-atom e190 e190"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual"> and </textual><code class="po-atom e191 e191"><textual class="po-textual">sc:complex-type</textual></code><textual class="po-textual"> accessors. It
returns a type definition of the appropriate kind. For untyped element nodes,
</textual><code class="po-atom e192 e192"><textual class="po-textual">xs:anyType</textual></code><textual class="po-textual"> is returned as a type definition value.
      </textual></para></section><section class="po-hcontainer e193 e193"><title class="po-block e194 e194"><textual class="po-textual">Functions and Operators on Type Values</textual></title><para class="po-block e195 e195"><textual class="po-textual">Obtaining types as values is well and good, but what can we do with
them other than perform sequence type tests on them? At a minimum, equality
operators should work on these values: </textual><code class="po-atom e196 e196"><textual class="po-textual">equals</textual></code><textual class="po-textual">, </textual><code class="po-atom e197 e197"><textual class="po-textual">=</textual></code><textual class="po-textual">, and
</textual><code class="po-atom e198 e198"><textual class="po-textual">!=</textual></code><textual class="po-textual">. It is also useful to be able to test whether one type is a
subtype of another. 
      </textual></para><figure class="po-container e199 e199" xml:id="fig_operator_api"><title class="po-block e200 e200"><textual class="po-textual">Operators</textual></title><variablelist class="po-table e201 e201"><varlistentry class="po-record e202 e202"><term class="po-block e203 e203"><code class="po-atom e204 e204"><textual class="po-textual">equals</textual></code><textual class="po-textual">, </textual><code class="po-atom e205 e205"><textual class="po-textual">=</textual></code><textual class="po-textual">, </textual><code class="po-atom e206 e206"><textual class="po-textual">!=</textual></code></term><listitem class="po-container e207 e207"><para class="po-block e208 e208"><textual class="po-textual">Test component equality.</textual></para></listitem></varlistentry><varlistentry class="po-record e209 e209"><term class="po-block e210 e210"><code class="po-atom e211 e211"><textual class="po-textual">subtype of</textual></code></term><listitem class="po-container e212 e212"><para class="po-block e213 e213"><textual class="po-textual">Returns true if the first type is a subtype of the second.</textual></para></listitem></varlistentry></variablelist></figure><programlisting class="po-block e214 e214" xml:space="preserve"><textual class="po-textual">
declare function my:spaceship-operator ($t1 as type(), $t2 as type()) 
{
  if ($t1 subtype of $t2) then -1
  else if ($t1 = $t2) then 0
  else if ($t1 subtype of $t2) then 1
  else xs:double("NaN")
};
       </textual></programlisting><para class="po-block e215 e215"><textual class="po-textual">XQuery </textual><citation class="po-atom e216 e216" linkend="xqfo30"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> defines a large number of
functions. However, only a few 
apply to all items. The sequence functions, such as </textual><code class="po-atom e217 e217"><textual class="po-textual">fn:subsequence</textual></code><textual class="po-textual">
can work on sequences of component values with no problem. 
The general functions </textual><code class="po-atom e218 e218"><textual class="po-textual">fn:string</textual></code><textual class="po-textual">,
</textual><code class="po-atom e219 e219"><textual class="po-textual">fn:boolean</textual></code><textual class="po-textual"> and </textual><code class="po-atom e220 e220"><textual class="po-textual">fn:not</textual></code><textual class="po-textual"> don't really apply and will
raise errors if applied to component values.</textual></para><para class="po-block e221 e221"><textual class="po-textual">If we have equality on type component values, then not only can we
define </textual><code class="po-atom e222 e222"><textual class="po-textual">fn:deep-equal</textual></code><textual class="po-textual"> over them, we can define 
</textual><code class="po-atom e223 e223"><textual class="po-textual">fn:deep-equal</textual></code><textual class="po-textual"> with them. </textual><xref class="po-milestone e224 e224" linkend="fig_deepeq1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows a
version of </textual><code class="po-atom e225 e225"><textual class="po-textual">deep-equal</textual></code><textual class="po-textual"> that is stronger than that defined by
XQuery: it requires type equality as well as structural equality.
      </textual></para><figure class="po-container e226 e226" xml:id="fig_deepeq1"><title class="po-block e227 e227"><textual class="po-textual">Implementing deep-equal with Type Values</textual></title><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">
declare function my:deep-equal ($p1 as item()*, $p2 as item()*, $coll as xs:string) 
as xs:boolean
{
   let $c1 := count($p1)
   let $c2 := count($p2)
   return
   if ($c1 != $c2) then false()
   else if ($c1 != 1) then 
     every $i1 at $i in $p1 satisfies my:deep-equal($i1, $p2[$i], $coll)
   else if (exists(sc:simple-type($p1)) and exists(sc:simple-type($p2))) then
     sc:simple-type($p1) eq sc:simple-type($p2) and
     if (($p1 instance of xs:string) and ($p2 instance of xs:string))
     then compare($p1, $p2, $coll) eq 0
     else
     try {
       let $v := $p1 eq $p2
       return ($p1 eq $p1) or (($p1 ne $p1) and ($p2 ne $p2)) (: NaN :)
     } catch  * {
       false()
     }
   else typeswitch ($p1)
   case document-node() return 
      (typeswitch ($p2) 
       case document-node() return true() default return false()) and
      my:deep-equal($p1/(*|text()), $p2/(*|text()), $coll)
   case element() return
      (typeswitch ($p2) 
       case element() return true() default return false()) and
      node-name($p1) eq node-name($p2) and
      exists(sc:type($p1)) and exists(sc:type($p2)) and 
      sc:type($p1) eq sc:type($p2) and
      my:deep-equal( for $a1 in $p1/@* order by name($a1), 
                     for $a2 in $p1/@* order by name($a2), $coll ) and
      if (exists(sc:simple-type($p1)))
      then my:deep-equal(data($p1), data($p2), $coll)
      else my:deep-equal($p1/(*|text()), $p2/(*|text()), $coll)
   case attribute() return
      (typeswitch ($p2) 
       case attribute() return true() default return false()) and
      node-name($p1) eq node-name($p2) and 
      my:deep-equal(data($p1),data($p2),$coll)
   case processing-instruction() return
      (typeswitch ($p2) 
       case processing-instruction() return true() default return false()) and
      node-name($p1) eq node-name($p2) and 
      compare(string($p1), string($p2), $coll)
   case namespace-node() return
      (typeswitch ($p2) 
       case namespace-node() return true() default return false()) and
      my:deep-equal(node-name($p1), node-name($p2), $coll) and
      compare( string($p1), string($p2), $coll ) eq 0
   case text() return
      (typeswitch ($p2) case text() return true() default return false()) and
      compare( string($p1), string($p2), $coll ) eq 0
   case comment() return 
      (typeswitch ($p2) case comment() return true() default return false()) and 
      compare(string($p1), string($p2), $coll)
   case function() return error("err:FOTY0015")
   case component() return $p1 eq $p2
   default return false()
};
      </textual></programlisting></figure><para class="po-block e229 e229"><textual class="po-textual">Once types are available as values, they can be returned in place
of type names to perform introspection on functions, for example.</textual></para><figure class="po-container e230 e230" xml:id="fig_misc_api"><title class="po-block e231 e231"><textual class="po-textual">Miscellaneous Introspection Functions</textual></title><variablelist class="po-table e232 e232"><varlistentry class="po-record e233 e233"><term class="po-block e234 e234"><code class="po-atom e235 e235"><textual class="po-textual">sc:type-named($qname as xs:QName) as type()</textual></code></term><listitem class="po-container e236 e236"><para class="po-block e237 e237"><textual class="po-textual">Return a type value for type with the given name, if
any. Raises an undefined type error otherwise.</textual></para></listitem></varlistentry><varlistentry class="po-record e238 e238"><term class="po-block e239 e239"><code class="po-atom e240 e240"><textual class="po-textual">sc:function-return-type([$f as function(*)]) as type()</textual></code></term><listitem class="po-container e241 e241"><para class="po-block e242 e242"><textual class="po-textual">Return a type value for the declared return type of
the given function.</textual></para></listitem></varlistentry><varlistentry class="po-record e243 e243"><term class="po-block e244 e244"><code class="po-atom e245 e245"><textual class="po-textual">sc:function-parameter-type([$f as function(*)],[$argNum as numeric]) as type()</textual></code></term><listitem class="po-container e246 e246"><para class="po-block e247 e247"><textual class="po-textual">Return a type value for the declared type of
indicated parameter of the given function. Raises an error if there is no such parameter.</textual></para></listitem></varlistentry></variablelist></figure><section class="po-hcontainer e248 e248"><title class="po-block e249 e249"><textual class="po-textual">Type Values as Functions</textual></title><para class="po-block e250 e250"><textual class="po-textual">In XQuery, there is a constructor function for each in-scope (named)
atomic type derived from a primitive type, whether the type is user-defined or
built-in. This excludes list and union types. Given that we have a schema
component value in our hands, there is no particular reason to require the type
to have a name, or even be atomic. Indeed, if one generalizes the concept of
the "constructor" function to mean obtaining a typed value of the given type
or raising an error if that is not possible, there is no particular reason 
not to define functions for complex types as as well, where the "constructor"
function for a complex type validates an item against that type. The
only types where this doesn't make sense is the "untyped" types
(</textual><code class="po-atom e251 e251"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual"> and </textual><code class="po-atom e252 e252"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">), which can be
applied as no-ops. A function can be defined to perform this typed-value
fabrication operation:
      </textual></para><figure class="po-container e253 e253" xml:id="fig_type_apply"><title class="po-block e254 e254"><textual class="po-textual">Types as functions</textual></title><variablelist class="po-table e255 e255"><varlistentry class="po-record e256 e256"><term class="po-block e257 e257"><code class="po-atom e258 e258"><textual class="po-textual">sc:type-apply($t as type(), $item as item()*) as item()*</textual></code></term><listitem class="po-container e259 e259"><para class="po-block e260 e260"><textual class="po-textual">Apply the type to the item, to obtain a typed value
or an error.</textual></para></listitem></varlistentry></variablelist></figure><figure class="po-container e261 e261" xml:id="fig_type_function_alt"><title class="po-block e262 e262"><textual class="po-textual">Example of applying a Type</textual></title><programlisting class="po-block e263 e263" xml:space="preserve"><textual class="po-textual">
declare function local:check($old as item(), $new as item())
{
   let $f := $old/sc:type()
   return sc:type-apply($f,$new)
};

local:check(doc("config.xml")/config/language, "en"),
local:check(doc("config.xml")/config/encoding, "utf-8")
        </textual></programlisting></figure><para class="po-block e264 e264"><textual class="po-textual">With the XQuery 3.0 data model, we can go further, as function
items are defined as values. Then we can just treat types as function items and
apply them directly, as shown in </textual><xref class="po-milestone e265 e265" linkend="fig_type_function"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. Note that
this might be an </textual><emphasis class="po-inline e266 e266"><textual class="po-textual">anonymous</textual></emphasis><textual class="po-textual"> type just as well as a named
type, unlike the type identification features that are part of standard XQuery.
      </textual></para><figure class="po-container e267 e267" xml:id="fig_type_function"><title class="po-block e268 e268"><textual class="po-textual">Example of applying a type as an XQuery 3.0 function item</textual></title><programlisting class="po-block e269 e269" xml:space="preserve"><textual class="po-textual">
declare function local:check($old as item(), $new as item())
{
   let $f := $old/sc:type()
   return $f($new)
};

local:check(doc("config.xml")/config/language, "en"),
local:check(doc("config.xml")/config/encoding, "utf-8")
        </textual></programlisting></figure><para class="po-block e270 e270"><textual class="po-textual">Combined with some of the introspection functions, we can get even
more powerful and flexible effects. The function </textual><code class="po-atom e271 e271"><textual class="po-textual">run-plugin</textual></code><textual class="po-textual"> can
guarantee that a plugin function executed for some particular piece of the
framework has the expected type, without having to know a priori what that type
is. 
      </textual></para><figure class="po-container e272 e272" xml:id="fig_fn_ex"><title class="po-block e273 e273"><textual class="po-textual">Using Type Introspection in Plugin Framework</textual></title><programlisting class="po-block e274 e274" xml:space="preserve"><textual class="po-textual">
declare my:run-plugin($config as element(), $plugin as function(*), $args as item()*)
{   
   let $expected := sc:type-named(data($config))
   if (sc:return-type($plugin) = $expected)
     $plugin($args)
   else 
     $expected($plugin($args))
};
      </textual></programlisting></figure></section><section class="po-hcontainer e275 e275"><title class="po-block e276 e276"><textual class="po-textual">Component Accessors</textual></title><para class="po-block e277 e277"><textual class="po-textual">For true meta-programming, being able to access some of the details
of the type components is important. Schema components are complex and have many
interconnections and properties. Attempting to provide a clean API to access
all these properties is beyond the scope of this paper. We will content
ourselves with defining a few basic accessors.
      </textual></para><para class="po-block e278 e278"><textual class="po-textual">Component accessors work analogously to accessors for nodes in the
data model: they apply to all component types, returning the
empty sequence where necessary. As with the linkage functions, these functions
have a zero-argument form that applies to the context item. This will make
chaining them together a little more usable.
      </textual></para><figure class="po-container e279 e279" xml:id="fig_accessor_api"><title class="po-block e280 e280"><textual class="po-textual">Basic Component Accessors</textual></title><variablelist class="po-table e281 e281"><varlistentry class="po-record e282 e282"><term class="po-block e283 e283"><code class="po-atom e284 e284"><textual class="po-textual">sc:name([$context as component()]) as xs:QName?</textual></code></term><listitem class="po-container e285 e285"><para class="po-block e286 e286"><textual class="po-textual">Return the name of the component, if any.</textual></para></listitem></varlistentry><varlistentry class="po-record e287 e287"><term class="po-block e288 e288"><code class="po-atom e289 e289"><textual class="po-textual">sc:annotations([$context as component()]) as element()*</textual></code></term><listitem class="po-container e290 e290"><para class="po-block e291 e291"><textual class="po-textual">Return annotations on the component as a sequence
of </textual><code class="po-atom e292 e292"><textual class="po-textual">xs:annotation</textual></code><textual class="po-textual"> element information items.</textual></para></listitem></varlistentry><varlistentry class="po-record e293 e293"><term class="po-block e294 e294"><code class="po-atom e295 e295"><textual class="po-textual">sc:base-type([$context as component()]) as type()</textual></code></term><listitem class="po-container e296 e296"><para class="po-block e297 e297"><textual class="po-textual">Return the base type of the component, if any.</textual></para></listitem></varlistentry></variablelist></figure><para class="po-block e298 e298"><textual class="po-textual">Getting at schema annotations from instances has many applications. 
For example, schema annotations can be used to define business rules, widget bindings for
generic UI generation, associating help text with input components, defining
special indexing for certain content, defining XML mapping rules, and so on. 
      </textual></para><figure class="po-container e299 e299" xml:id="fig_ann_ex"><title class="po-block e300 e300"><textual class="po-textual">Some Schema Annotations</textual></title><programlisting class="po-block e301 e301" xml:space="preserve"><textual class="po-textual">
&lt;xs:simpleType name="address"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A numeric internet address.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value="[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:element name="address" type="address"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The server socket bind numeric internet address.
    &lt;/xs:documentation&gt;
    &lt;xs:appinfo&gt;
      &lt;admin:default&gt;"0.0.0.0"&lt;/admin:default&gt;
      &lt;admin:cold-restart/&gt;
      &lt;admin:help xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;span class="help-text"&gt;&lt;span style="color:#800000"&gt;address&lt;/span&gt; 
      specifies the IP address for the App Server.&lt;/span&gt;
      &lt;/admin:help&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;

        </textual></programlisting><caption class="po-container e302 e302"><para class="po-block e303 e303"><textual class="po-textual">Schema annotations from a real product.</textual></para></caption></figure><para class="po-block e304 e304"><textual class="po-textual">One key difference between XML types and classes in an
object-oriented programming language is that classes have methods as well as
data. Combining function items with annotation accessors can bring methods to
XML types as well, in a way.</textual></para><figure class="po-container e305 e305" xml:id="fig_oo_xq"><title class="po-block e306 e306"><textual class="po-textual">Function Items Named in Annotations as Methods</textual></title><para class="po-block e307 e307"><textual class="po-textual">The schema:</textual></para><programlisting class="po-block e308 e308" xml:space="preserve"><textual class="po-textual">
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:record="http://example.com/meta/records"
           xmlns:base="http://example.com/meta"
           targetNamespace="http://example.com/meta/records"
           elementFormDefault="qualified"&gt;

&lt;xs:import namespace="http://example.com/meta"
           schemaLocation="meta.xsd"/&gt;

&lt;xs:simpleType name="studio"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo&gt;
      &lt;base:input-handler&gt;record:normalize-studio&lt;/base:input-handler&gt;
      &lt;base:formatter&gt;record:format-studio&lt;/base:formatter&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:string"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:complexType name="record-metadata"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="base:metadata"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="studio" type="studio"/&gt;
      &lt;/xs:sequence&gt;
    &lt;xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
    </textual></programlisting><para class="po-block e309 e309"><textual class="po-textual">Formatter function using metadata "methods":</textual></para><programlisting class="po-block e310 e310" xml:space="preserve"><textual class="po-textual">
declare function base:format-metadata ($metadata as element())
{
  for $meta in $metadata/*
  let $methods := $meta/sc:element-decl()!sc:annotations()/xs:appinfo
  let $formatter := function-lookup($methods/base:formatter, 1)
  return $formatter($meta)
};
    </textual></programlisting></figure></section></section></section><section class="po-hcontainer e311 e311"><title class="po-block e312 e312"><textual class="po-textual">Other Schema Component Values</textual></title><section class="po-hcontainer e313 e313"><title class="po-block e314 e314"><textual class="po-textual">Facets</textual></title><para class="po-block e315 e315"><textual class="po-textual">Accessing facet information is important for working with simple
types. </textual><xref class="po-milestone e316 e316" linkend="fig_facet_decls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> summarizes the additional type tests
and accessors for working with facets. The </textual><code class="po-atom e317 e317"><textual class="po-textual">sc:facets</textual></code><textual class="po-textual"> accessor
returns sequences of facet component values when applied to simple type
components; it returns the empty sequence otherwise. The accessors already
defined apply to facet component values as well. The </textual><code class="po-atom e318 e318"><textual class="po-textual">sc:name</textual></code><textual class="po-textual">
accessor returns the name of the element used to define the facet
(e.g. xs:enumeration for the enumeration facet), and the standard accessor
</textual><code class="po-atom e319 e319"><textual class="po-textual">fn:data</textual></code><textual class="po-textual"> returns the value of the facet.</textual></para><figure class="po-container e320 e320" xml:id="fig_facet_decls"><title class="po-block e321 e321"><textual class="po-textual">Additions for Facet Values</textual></title><variablelist class="po-table e322 e322"><varlistentry class="po-record e323 e323"><term class="po-block e324 e324"><code class="po-atom e325 e325"><textual class="po-textual">facet() or facet(*)</textual></code></term><listitem class="po-container e326 e326"><para class="po-block e327 e327"><textual class="po-textual">Type test matching any facet value.</textual></para></listitem></varlistentry><varlistentry class="po-record e328 e328"><term class="po-block e329 e329"><code class="po-atom e330 e330"><textual class="po-textual">facet(q:name)</textual></code></term><listitem class="po-container e331 e331"><para class="po-block e332 e332"><textual class="po-textual">Type test matching any facet value whose name
matches the given QName. For example, a pattern facet matches 'facet(xs:pattern)'.</textual></para></listitem></varlistentry><varlistentry class="po-record e333 e333"><term class="po-block e334 e334"><code class="po-atom e335 e335"><textual class="po-textual">sc:facets([$context as item()]) as facet()*</textual></code></term><listitem class="po-container e336 e336"><para class="po-block e337 e337"><textual class="po-textual">Get all the facets of the item, if any. Only simple
types have facets.</textual></para></listitem></varlistentry></variablelist></figure><para class="po-block e338 e338"><textual class="po-textual">Let's return to the date example from the introduction 
(</textual><xref class="po-milestone e339 e339" linkend="fig_dateex_1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). With access to types and their facets, as
well as function lookup and function application, we can create a generic
framework for processing dates without having to hardcode any type or function
names. A fragment of this framework is shown in 
</textual><xref class="po-milestone e340 e340" linkend="fig_dateex_2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e341 e341" xml:id="fig_dateex_2"><title class="po-block e342 e342"><textual class="po-textual">Generic XQuery Type-Based Dispatch</textual></title><programlisting class="po-block e343 e343" xml:space="preserve"><textual class="po-textual">
...
declare function my:process-date($date)
{
  for $date-type in fn:collection("templates")/date/sc:simple-type() 
  let $date-pattern := sc:facets($date-type)[. instance of facet(xs:pattern)]
  let $process-func := 
     fn:function-lookup(fn:data(sc:annotations($date-type)//my:date-func), 1)
  where fn:exists($date-pattern) and
        fn:exists($process-func) and
        fn:matches($date, fn:data($date-pattern))
  return $process-func($date-type($date))
};

      </textual></programlisting><caption class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">XQuery fragment using schema annotations and function
lookup to create a generic date-processing framework.</textual></para></caption></figure></section><section class="po-hcontainer e346 e346"><title class="po-block e347 e347"><textual class="po-textual">Element and Attribute Declarations</textual></title><para class="po-block e348 e348"><textual class="po-textual">As the example in </textual><xref class="po-milestone e349 e349" linkend="fig_ann_ex"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows, 
it is frequently more natural to obtain the annotations from element and
attribute declarations rather than from the types associated with those
declarations, Annotations often have more to do with the use of a type in a
particular context than with the type itself. Adding accessors to obtain element and attribute
declarations from element and attribute nodes, and defining the component
accessors over these new component types allows for these use cases. 
</textual><xref class="po-milestone e350 e350" linkend="fig_decls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> summarizes the additional type tests and
accessors for working with element and attribute declarations. The
</textual><code class="po-atom e351 e351"><textual class="po-textual">sc:element-decl</textual></code><textual class="po-textual"> and </textual><code class="po-atom e352 e352"><textual class="po-textual">sc:attribute-decl</textual></code><textual class="po-textual"> 
accessors return component values when applied to element and attribute nodes,
respectively; otherwise they return empty sequence. In addition, the accessors
already defined apply to these new declaration component values as well. The
</textual><code class="po-atom e353 e353"><textual class="po-textual">sc:type</textual></code><textual class="po-textual">, </textual><code class="po-atom e354 e354"><textual class="po-textual">sc:complex-type</textual></code><textual class="po-textual">, and
</textual><code class="po-atom e355 e355"><textual class="po-textual">sc:simple-type</textual></code><textual class="po-textual"> accessors return the type associated with the declaration.
      </textual></para><figure class="po-container e356 e356" xml:id="fig_decls"><title class="po-block e357 e357"><textual class="po-textual">Additions for Element and Attribute Declaration Values</textual></title><variablelist class="po-table e358 e358"><varlistentry class="po-record e359 e359"><term class="po-block e360 e360"><code class="po-atom e361 e361"><textual class="po-textual">element-decl() or element-decl(*)</textual></code></term><listitem class="po-container e362 e362"><para class="po-block e363 e363"><textual class="po-textual">Type test matching any element declaration value.</textual></para></listitem></varlistentry><varlistentry class="po-record e364 e364"><term class="po-block e365 e365"><code class="po-atom e366 e366"><textual class="po-textual">element-decl(q:name)</textual></code></term><listitem class="po-container e367 e367"><para class="po-block e368 e368"><textual class="po-textual">Type test matching any element declaration value
whose name matches the given QName, or which is in the substitution group with
an element with the given QName as its head.</textual></para></listitem></varlistentry><varlistentry class="po-record e369 e369"><term class="po-block e370 e370"><code class="po-atom e371 e371"><textual class="po-textual">attribute-decl() or attribute-decl(*)</textual></code></term><listitem class="po-container e372 e372"><para class="po-block e373 e373"><textual class="po-textual">Type test matching any attribute declaration value.</textual></para></listitem></varlistentry><varlistentry class="po-record e374 e374"><term class="po-block e375 e375"><code class="po-atom e376 e376"><textual class="po-textual">attribute-decl(q:name)</textual></code></term><listitem class="po-container e377 e377"><para class="po-block e378 e378"><textual class="po-textual">Type test matching any attribute declaration value
whose name matches the given QName.</textual></para></listitem></varlistentry><varlistentry class="po-record e379 e379"><term class="po-block e380 e380"><code class="po-atom e381 e381"><textual class="po-textual">sc:element-decl([$context as item()]) as element-decl()?</textual></code></term><listitem class="po-container e382 e382"><para class="po-block e383 e383"><textual class="po-textual">Get the element declaration of the item, if any.</textual></para></listitem></varlistentry><varlistentry class="po-record e384 e384"><term class="po-block e385 e385"><code class="po-atom e386 e386"><textual class="po-textual">sc:attribute-decl([$context as item()]) as attribute-decl()?</textual></code></term><listitem class="po-container e387 e387"><para class="po-block e388 e388"><textual class="po-textual">Get the attribute declaration of the item, if any.</textual></para></listitem></varlistentry></variablelist></figure><para class="po-block e389 e389"><textual class="po-textual">Fitting element declaration values into the type hierarchy leads us
to go still further: element declarations are but one kind of term in a content
model, along with wildcards and model groups. Given that we already have
element declaration values, it makes sense to expose the content model of a
type in general. Given that we already have attribute declaration values, it
makes sense to expose the attributes declared on a complex type.</textual></para><para class="po-block e390 e390"><textual class="po-textual">The XML Schema component model creates some complexity in this area
and we need to decide how to expose the information in the a usable way.
That model makes a distinction between particles and terms,
where the particle carries occurrence information.
It also makes an analogous distinction between attribute uses and attribute
declarations, where attribute uses carry value constraints. Attribute uses and
particles also can be used to carry local context-specific annotations. 
    </textual></para><figure class="po-container e391 e391" xml:id="fig_decl_accessor"><title class="po-block e392 e392"><textual class="po-textual">More Accessors</textual></title><variablelist class="po-table e393 e393"><varlistentry class="po-record e394 e394"><term class="po-block e395 e395"><code class="po-atom e396 e396"><textual class="po-textual">sc:particles([$context as component()]) as particle()*</textual></code></term><listitem class="po-container e397 e397"><para class="po-block e398 e398"><textual class="po-textual">Return the particles within a model group or complex
type's content type as values.</textual></para></listitem></varlistentry><varlistentry class="po-record e399 e399"><term class="po-block e400 e400"><code class="po-atom e401 e401"><textual class="po-textual">sc:term([$context as component()]) as term()</textual></code></term><listitem class="po-container e402 e402"><para class="po-block e403 e403"><textual class="po-textual">Get the term for a particle.</textual></para></listitem></varlistentry><varlistentry class="po-record e404 e404"><term class="po-block e405 e405"><code class="po-atom e406 e406"><textual class="po-textual">sc:attributes([$context as component()]) as attribute-use()*</textual></code></term><listitem class="po-container e407 e407"><para class="po-block e408 e408"><textual class="po-textual">Return the attributes uses from a complex type.</textual></para></listitem></varlistentry></variablelist></figure><para class="po-block e409 e409"><textual class="po-textual">In addition to the new accessors listed in </textual><xref class="po-milestone e410 e410" linkend="fig_decls"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, 
the </textual><code class="po-atom e411 e411"><textual class="po-textual">sc:attribute-decl</textual></code><textual class="po-textual"> accessor applies to attribute use component
values.
    </textual></para><figure class="po-container e412 e412" xml:id="fig_comp_hier"><title class="po-block e413 e413"><textual class="po-textual">Declaration and Particle Values</textual></title><mediaobject class="po-container e414 e414"><imageobject class="po-container e415 e415"><imagedata class="po-meta e416 e416" fileref="../../../vol8/graphics/Holstege01/Holstege01-003.png" format="png" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></section></section><section class="po-hcontainer e417 e417"><title class="po-block e418 e418"><textual class="po-textual">Implementation Considerations</textual></title><para class="po-block e419 e419"><textual class="po-textual">It is difficult to generalize about different
implementations of a language. Overall implementing the accessors, type
tests and operators discussed here on top of an existing XQuery implementation
was not difficult. 
    </textual></para><para class="po-block e420 e420"><textual class="po-textual">XQuery is notoriously sensitive to syntactic extensions.
The use of functional syntax made the integration with an existing
XQuery lexer and parser more straight-forward than it would have been if new
syntactic constructs had been required. The new sequence type tests and the
</textual><code class="po-atom e421 e421"><textual class="po-textual">subtype of</textual></code><textual class="po-textual"> operator did require additions to the lexer and parser
rules. The </textual><code class="po-atom e422 e422"><textual class="po-textual">subtype of</textual></code><textual class="po-textual"> operator was added as an additional kind of
comparison expression; the new sequence type tests were added in parallel to
XPath kind tests. Adding the component kind tests required the same kind of
special handling already required for other names that appear in a similar
context, such as </textual><code class="po-atom e423 e423"><textual class="po-textual">element</textual></code><textual class="po-textual"> or </textual><code class="po-atom e424 e424"><textual class="po-textual">document-node</textual></code><textual class="po-textual">.
    </textual></para><para class="po-block e425 e425"><textual class="po-textual">The values themselves were implemented as classes providing
faÃades over existing data structures used to implement XML Schema
components. These data structures were already present to support validation
and type assignment. An implementation that lacked such data structures would
clearly find exposing types as values more challenging. It is unclear, however,
whether a direct reflection of the schema component model is the right
approach. It may be better to step back and design a cleaner API, and provide
values over that model instead. Such a strategy would bring a higher
implementation burden. 
    </textual></para><para class="po-block e426 e426"><textual class="po-textual">Applying types as functions depended on a prior foundation
of XQuery 3.0 function items, and would be much more difficult to accomplish
without that foundation. Given that foundation, applying simple types as
functions is trivial, and applying complex types as functions only slightly
more so. The existing infrastructure to support schema validation was a
necessary prerequisite to applying complex types as functions, however.</textual></para><para class="po-block e427 e427"><textual class="po-textual">The most challenging part of the implementation was
providing access to annotations. The existing data structures did not preserve
annotations as data model instances, as they were irrelevant for validation and
type assignment and there was no existing API that provided access to the
schema components. A surprising amount of work needed to be
done in order to preserve annotations and expose them as nodes.</textual></para><para class="po-block e428 e428"><textual class="po-textual">Finally, the experimental implementation actually did allow schema
component values to be added as children to data model instances, primarily for
debugging purposes. Adding a schema component value as a child added it as the
XML Schema serialization. In addition, </textual><code class="po-atom e429 e429"><textual class="po-textual">fn:string</textual></code><textual class="po-textual"> was also
implemented over these values to provide a terse representation of them, again,
for debugging purposes. About half the implementation code went into these
debugging APIs.
    </textual></para></section><section class="po-hcontainer e430 e430"><title class="po-block e431 e431"><textual class="po-textual">Future Directions</textual></title><section class="po-hcontainer e432 e432"><title class="po-block e433 e433"><textual class="po-textual">More Accessors, Functions, and Operators</textual></title><para class="po-block e434 e434"><textual class="po-textual">This paper has focused mainly on exposing types as values in
XQuery with a few basic accessors, with some forays into some related
schema components. Some meta-programming techniques rely on being able to
examine the full richness of the schema component model â terms,
particles, attribute uses, schema component affiliations, abstractness, and so
on. The program to provide such full access is similar to what was outlined
here: define type tests for the component, define linkage functions or
accessors to get to that component, define accessors to get at the component
properties, and define whatever other useful functions and operators seem
appropriate. 
       </textual></para><para class="po-block e435 e435"><textual class="po-textual">More extensive additions to the syntax of XQuery to allow
variables to be used as the operand of </textual><code class="po-atom e436 e436"><textual class="po-textual">instance of</textual></code><textual class="po-textual"> and </textual><code class="po-atom e437 e437"><textual class="po-textual">cast
as</textual></code><textual class="po-textual"> expressions would improve usability further:</textual></para><programlisting class="po-block e438 e438" xml:space="preserve"><textual class="po-textual">
declare function my:filter-by-type($t as type(), $nodes as node()*)
{
  for $n in $nodes where $n instance of $t return $n
};
       </textual></programlisting></section><section class="po-hcontainer e439 e439"><title class="po-block e440 e440"><textual class="po-textual">Relationship to Schema Component Paths</textual></title><para class="po-block e441 e441"><textual class="po-textual">Once we embark on the program of providing full access to all the
schema components and their properties, the use of schema component paths
arises. Schema component paths define an
XPath-like syntax for describing and navigating W3C XML Schema </textual><citation class="po-atom e442 e442" linkend="xsd11st"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></citation><textual class="po-textual"> component models. Abbreviated syntax is defined
for some path steps, and certain axes that skip over intermediate components
can provide effective ways of navigating through content models, or selecting
multiple components with a since path.
      </textual></para><para class="po-block e443 e443"><textual class="po-textual">Schema component paths navigate through the schema component graph
of an assembled schema. As with XPath, each step in the path consists of an
axis combined with some kind of test and perhaps with a predicate. In schema
component paths, the test is a name test (possibly a wildcarded name test, and
possibly a test for an anonymous component), and the only predicate defined is
a positional predicate (selecting the Nth of like components). There are no
accessors for non-component properties: the axes act as accessor for component
properties, just like in XPath. About two dozen axes are defined, for each of
the component-to-component relationships in the graph. For example, the
</textual><code class="po-atom e444 e444"><textual class="po-textual">annotation::</textual></code><textual class="po-textual"> axis corresponds to the </textual><code class="po-atom e445 e445"><textual class="po-textual">sc:annotations</textual></code><textual class="po-textual">
accessor.
      </textual></para><figure class="po-container e446 e446" xml:id="fig_scp1"><title class="po-block e447 e447"><textual class="po-textual">Some Schema Component Paths</textual></title><programlisting class="po-block e448 e448" xml:space="preserve"><textual class="po-textual">
/schemaElement::p:outer/type::0/schemaAttribute::p:inner
/p:outer/~0/@p:inner
/type::p:second/model::sequence/schemaElement::p:duplicate[2]/type::*
/~p:second/model::sequence/p:duplicate[2]/~*
      </textual></programlisting></figure><para class="po-block e449 e449"><xref class="po-milestone e450 e450" linkend="fig_scp1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows some schema component paths
rooted at the component for the schema as a whole. The first path starts 
at the root of the assembled schema (</textual><code class="po-atom e451 e451"><textual class="po-textual">/</textual></code><textual class="po-textual">). It then traverses the
schemaElement axis (</textual><code class="po-atom e452 e452"><textual class="po-textual">schemaElement::</textual></code><textual class="po-textual">) with a name test
(</textual><code class="po-atom e453 e453"><textual class="po-textual">p:outer</textual></code><textual class="po-textual">), selecting a global 
element declaration with the name </textual><code class="po-atom e454 e454"><textual class="po-textual">outer</textual></code><textual class="po-textual">. The path continues
through the type axis (</textual><code class="po-atom e455 e455"><textual class="po-textual">type::</textual></code><textual class="po-textual">) with a name test (</textual><code class="po-atom e456 e456"><textual class="po-textual">0</textual></code><textual class="po-textual">)
that in this case matches a type definition with no name (</textual><code class="po-atom e457 e457"><textual class="po-textual">0</textual></code><textual class="po-textual"> being
the indicator for this case). The path to this point will select the locally
declared anonymous type of the element declaration 'outer'. Finally the path
concludes by traversing the schemaAttribute axis
(</textual><code class="po-atom e458 e458"><textual class="po-textual">schemaAttribute::</textual></code><textual class="po-textual">) with a name test (</textual><code class="po-atom e459 e459"><textual class="po-textual">p:inner</textual></code><textual class="po-textual">), 
selecting an attribute declaration whose name is 'inner' within the anonymous
type definition. As a whole then, this path selects a particular attribute
declaration of a particular element declaration. The second path means the same
thing, but uses abbreviated syntax.
       </textual></para><para class="po-block e460 e460"><textual class="po-textual">The third path again starts at the root of the assembled schema
(</textual><code class="po-atom e461 e461"><textual class="po-textual">/</textual></code><textual class="po-textual">). This time it traverses through the type axis
(</textual><code class="po-atom e462 e462"><textual class="po-textual">type::</textual></code><textual class="po-textual">) with a name test (</textual><code class="po-atom e463 e463"><textual class="po-textual">p:second</textual></code><textual class="po-textual">), thus selecting
a global type definition with the name 'second'. The path then traverses the
model axis (</textual><code class="po-atom e464 e464"><textual class="po-textual">model::</textual></code><textual class="po-textual">) with a name test (</textual><code class="po-atom e465 e465"><textual class="po-textual">sequence</textual></code><textual class="po-textual">),
thus selecting the model group in the content model of the type, 
but only if it is a sequence. The path continues along the schemaElement axis
(</textual><code class="po-atom e466 e466"><textual class="po-textual">schemaElement::</textual></code><textual class="po-textual">) with a name test (</textual><code class="po-atom e467 e467"><textual class="po-textual">p:duplicate</textual></code><textual class="po-textual">) and
a positional constraint (</textual><code class="po-atom e468 e468"><textual class="po-textual">[2]</textual></code><textual class="po-textual">), thus selecting an element
declaration within the sequence that has a name of 'duplicate', but referring
to the second such element within the content model. Finally, the path
traverses the type axis (</textual><code class="po-atom e469 e469"><textual class="po-textual">type::</textual></code><textual class="po-textual">) with a 
wildcard (</textual><code class="po-atom e470 e470"><textual class="po-textual">*</textual></code><textual class="po-textual">), selecting the type of the given element declaration,
whatever it might be. The fourth path means the same thing, but uses
abbreviated syntax. 
       </textual></para><para class="po-block e471 e471"><textual class="po-textual">How does this compare to the accessors we have
defined above?</textual></para><para class="po-block e472 e472"><textual class="po-textual">The accessors operate not on components but on
XQuery values. For example, </textual><code class="po-atom e473 e473"><textual class="po-textual">sc:element-decl</textual></code><textual class="po-textual"> applies to nodes.
Some accessors, such as </textual><code class="po-atom e474 e474"><textual class="po-textual">sc:type</textual></code><textual class="po-textual">, apply to component values
also, and so behave somewhat like the schema component axes. 
To get the full range of axes available in schema component paths, it would be
necessary to define an accessor function corresponding to each axis, and allow
it to apply to component values. To get the effect of the name tests, XPath
predicates must be applied to the results of the accessor. Some accessors
return simple properties of the components, such as its name. Schema component
paths do not provide for access to the non-component properties. Finally,
schema component paths use the slash (</textual><code class="po-atom e475 e475"><textual class="po-textual">/</textual></code><textual class="po-textual">) as a syntactic separator
between steps. Since schema components are not nodes, XQuery forbids using them
inside a path (although they can be the last step of a path). A FLWOR
expression, nested function call, or the XQuery 3.0 simple mapping operator
(</textual><code class="po-atom e476 e476"><textual class="po-textual">!</textual></code><textual class="po-textual">) must be used instead. 
       </textual></para><table border="5" class="po-container e477 e477" frame="border" rules="rows"><caption class="po-container e478 e478"><para class="po-block e479 e479"><textual class="po-textual">Summary of Comparison of Schema Component Accessors and Schema Component Paths</textual></para></caption><tr class="po-table e480 e480"><th class="po-field e481 e481"><textual class="po-textual">Schema Component Paths</textual></th><th class="po-field e482 e482"><textual class="po-textual">Schema Component Accessors</textual></th></tr><tr class="po-table e483 e483"><td class="po-block e484 e484"><textual class="po-textual">operate on schema components</textual></td><td class="po-block e485 e485"><textual class="po-textual">operate on XQuery values</textual></td></tr><tr class="po-table e486 e486"><td class="po-block e487 e487"><textual class="po-textual">apply to schema in isolation</textual></td><td class="po-block e488 e488"><textual class="po-textual">can link between date model
items and schema component values</textual></td></tr><tr class="po-table e489 e489"><td class="po-block e490 e490"><textual class="po-textual">start at particular schema component, either root of schema or contextually supplied schema component</textual></td><td class="po-block e491 e491"><textual class="po-textual">apply to particular item(), not rooted at top of schema</textual></td></tr><tr class="po-table e492 e492"><td class="po-block e493 e493"><textual class="po-textual">path step selects component-valued component properties only</textual></td><td class="po-block e494 e494"><textual class="po-textual">acccessor selects various kinds of properties</textual></td></tr><tr class="po-table e495 e495"><td class="po-block e496 e496"><textual class="po-textual">steps combine axis with name test directly</textual></td><td class="po-block e497 e497"><textual class="po-textual">component or name test separate from accessor</textual></td></tr><tr class="po-table e498 e498"><td class="po-block e499 e499"><textual class="po-textual">steps combined with slash</textual></td><td class="po-block e500 e500"><textual class="po-textual">chains of accessors cannot be
combined with slash: must nest function calls, use FLWOR expressions, or use
XQuery 3.0 simple mapping operator instead</textual></td></tr><tr class="po-table e501 e501"><td class="po-block e502 e502"><textual class="po-textual">path syntax and semantics similar to XPath, but is not XPath</textual></td><td class="po-block e503 e503"><textual class="po-textual">syntax and semantics are standard XPath</textual></td></tr></table><para class="po-block e504 e504"><textual class="po-textual">Since schema component accessors do not apply to schemas in
isolation, it is not possible to construct XQuery expressions that are exactly
equivalent to the schema component paths given previously. However, we can give
some expressions that are roughly equivalent, to give some sense of how they
compare.
      </textual></para><figure class="po-container e505 e505" xml:id="fig_scp_equiv"><title class="po-block e506 e506"><textual class="po-textual">Rough Equivalents to Schema Component Paths</textual></title><programlisting class="po-block e507 e507" xml:space="preserve"><textual class="po-textual">
$context/sc:schema()!
  sc:element-decl()[sc:name(.)=xs:QName('p:outer')]!
    sc:type()[empty(sc:name(.))]!
      sc:attribute-decl()[sc:name(.)=xs:QName('p:inner')]

$context/sc:schema()!
  sc:type()[sc:name(.)=xs:QName('p:second')]!
    sc:particles()[
      typeswitch (sc:term(.)) 
      case model-group(xs:sequence) return true()
      default return false()]!
        sc:particles()[
          typeswitch (sc:term(.)) 
          case particle(p:duplicate) return true() 
          default return false()][2]!
            sc:type()
       </textual></programlisting></figure><para class="po-block e508 e508"><xref class="po-milestone e509 e509" linkend="fig_scp_equiv"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows XQuery expressions using the
accessors that are roughly equivalent to the schema component paths shown in
</textual><xref class="po-milestone e510 e510" linkend="fig_scp1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. These
expressions have to be grounded on some XQuery item (</textual><code class="po-atom e511 e511"><textual class="po-textual">$context</textual></code><textual class="po-textual">),
and it was necessary to invent a new accessor to link to the root of the
assembled schema governing the type information for that item
(</textual><code class="po-atom e512 e512"><textual class="po-textual">sc:schema</textual></code><textual class="po-textual">). 
       </textual></para><para class="po-block e513 e513"><textual class="po-textual">Schema component paths clearly express traversal
through a schema component graph more compactly than the accessor and linkage
functions do, in that they combine the accessor and the type test in one path
step. In addition, schema component paths generally elide the distinction
between terms and particles, which the chained accessors do not.
      </textual></para><para class="po-block e514 e514"><textual class="po-textual">On the other hand, schema component paths do not provide a complete
answer, however. They do not provide access to non-component
information, nor do they bridge the boundary between schema components and
nodes or other item types. 
      </textual></para><para class="po-block e515 e515"><textual class="po-textual">We could imagine allowing schema component paths to mix directly
with normal XPath paths to provide that linkage. Then a path such as 
</textual><code class="po-atom e516 e516"><textual class="po-textual">/book/chapter/title/type::*/annotation::*/xs:appinfo/my:special-stuff/@my:type</textual></code><textual class="po-textual">
would switch back and forth between XPaths and schema component paths. Under
this scheme the type axis in the fourth step of the path would start a relative
schema component path with some component as the default. In this case,
the context is the element declaration component for the </textual><code class="po-atom e517 e517"><textual class="po-textual">title</textual></code><textual class="po-textual">
element. 
      </textual></para><para class="po-block e518 e518"><textual class="po-textual">Mixing schema component paths with normal XPaths directly in this
way is apt to be very confusing, however. The rules governing the slash are
very different. In addition, abbreviated schema component paths in this mixed
context confuses interpretation tremendously. Is the </textual><code class="po-atom e519 e519"><textual class="po-textual">@my:type</textual></code><textual class="po-textual"> at
the end of the path a normal attribute node on the
</textual><code class="po-atom e520 e520"><textual class="po-textual">my:special-stuff</textual></code><textual class="po-textual"> element or is it an attribute declaration?
Careful specification of the switching rules may eliminate ambiguities,
but it won't eliminate confusion for humans reading and writing such
paths. The similarity of schema component paths to XPaths that helps make them
more intuitive in isolation causes difficulty when used in the same context as
XPath. This confusion also makes implementation more difficult: higher levels
of analysis would be required to determine what kinds of operations are
allowable, or to optimize node paths properly.
      </textual></para><para class="po-block e521 e521"><textual class="po-textual">Keeping schema component paths and XPaths clearly separated
provides the power of both, without the confusion. Wrapping schema component
paths within some kind of scoping expression and providing the rich set of
accessor functions seems the best way to achieve this.
      </textual></para><figure class="po-container e522 e522" xml:id="fig_scd_type"><title class="po-block e523 e523"><textual class="po-textual">Example Integration of Schema Component Paths and Type Values</textual></title><programlisting class="po-block e524 e524" xml:space="preserve"><textual class="po-textual">
/book/chapter/title/sc:element-decl() ! 
  scp {type::*/annotation::*}/
     xs:appinfo/my:special-stuff/@my:type
      </textual></programlisting><caption class="po-container e525 e525"><para class="po-block e526 e526"><textual class="po-textual">Schema component paths are wrapped inside special
syntactic for to keep them clearly separated from normal XPaths.</textual></para></caption></figure><para class="po-block e527 e527"><textual class="po-textual">In summary, both schema component paths and the XQuery linkage and
accessor functions both have their place. Schema component paths are suited to
navigating through schema component graphs or pointing to specific schema
components for schema analysis or reporting. The accessor functions are more
useful to exposing the schema information relevant to a particular XQuery item
in the context of some operations over data.
      </textual></para></section></section><section class="po-hcontainer e528 e528"><title class="po-block e529 e529"><textual class="po-textual">Summary and Conclusions</textual></title><para class="po-block e530 e530"><textual class="po-textual">This paper has explored adding schema types as values into XQuery,
providing some measure of structural type introspection. In an XQuery context,
a type is an XML Schema type, and to provide even basic structural type
introspection requires pulling in quite a bit of the complexity of the XML
schema component model. Nevertheless, implementation need not be too
challenging, and only modest changes to the XQuery data model and existing 
syntax are required. It is possible to take an incremental approach to adding additional capabilities, but even some basic abilities can provide significant 
coding power and flexibility. 
    </textual></para><para class="po-block e531 e531"><textual class="po-textual">Schema component paths can be used in combination with linkage
function if they are integrated with care, to avoid confusion. Schema component
paths satisfy use cases where deep analysis of the schema is required, while
simple accessor and linkage functions work well for getting at basic metadata
about the types of the data being operated on.
    </textual></para></section><bibliography class="po-hcontainer e532 e532"><title class="po-block e533 e533"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e534 e534" xml:id="cplus" xreflabel="C++"><textual class="po-textual">
   American National Standards Institute, 1430 Broadway, New York, NY 10018, USA.
   </textual><emphasis class="po-inline e535 e535"><textual class="po-textual">The ANSI C++ Standard (ISO/IEC 14882)</textual></emphasis><textual class="po-textual">, 2002.
   </textual></bibliomixed><bibliomixed class="po-block e536 e536" xml:id="clos" xreflabel="Gabriel91"><textual class="po-textual">
   Richard P. Gabriel, Jon L. White, and Daniel G. Bobrow. 
   </textual><emphasis class="po-inline e537 e537"><textual class="po-textual">Clos: Integrating Object-Oriented and Functional Programming.</textual></emphasis><textual class="po-textual">
     Communications of the ACM, 34(9):29â38, 1991. doi:</textual><biblioid class="po-atom e538 doi e538"><textual class="po-textual">10.1145/114669.114671</textual></biblioid><textual class="po-textual">.
   </textual></bibliomixed><bibliomixed class="po-block e539 e539" xml:id="php" xreflabel="Gabrysiak"><textual class="po-textual">
   Gregor Gabrysiak, Stefan Marr, and Falko Menge. 
   </textual><emphasis class="po-inline e540 e540"><textual class="po-textual">Meta Programming and Reflection in PHP</textual></emphasis><textual class="po-textual">
   </textual><link class="po-inline e541 e541" xlink:actuate="onRequest" xlink:href="http://instantsvc.sourceforge.net/docs/metaprogramming-and-reflection-with-php-paper.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://instantsvc.sourceforge.net/docs/metaprogramming-and-reflection-with-php-paper.pdf</textual></link><textual class="po-textual">
    Accessed 2012-03-29.
    </textual></bibliomixed><bibliomixed class="po-block e542 e542" xml:id="xsd11st" xreflabel="XSD11.1"><textual class="po-textual">
    W3C: Shudi (Sandy) Gao é«æ®é, C.M. Sperberg-McQueen, and 
Henry S. Thompson, editors.  
    </textual><emphasis class="po-inline e543 e543"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures </textual></emphasis><textual class="po-textual">.
    W3C, April 2012. 
    </textual><link class="po-inline e544 e544" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-11-1/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-11-1/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e545 e545" xml:id="scds" xreflabel="SCD"><textual class="po-textual">
    W3C: Mary Holstege and Asir S. Vedamuthu, editors.
    </textual><emphasis class="po-inline e546 e546"><textual class="po-textual">W3C XML Schema Definition Language (XSD): Component Designators.</textual></emphasis><textual class="po-textual">
    Candidate Recommendation. W3C, January 2010.
    </textual><link class="po-inline e547 e547" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2010/CR-xmlschema-ref-20100119/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e548 e548" xml:id="xqfo30" xreflabel="F&amp;O30"><textual class="po-textual">
    W3C: Michael Kay, editor.
    </textual><emphasis class="po-inline e549 e549"><textual class="po-textual">XPath and XQuery Functions and Operators 3.0</textual></emphasis><textual class="po-textual">
    Last Call Working Draft. W3C, December 2011.
    </textual><link class="po-inline e550 e550" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-functions-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-functions-30/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e551 e551" xml:id="java" xreflabel="Java"><textual class="po-textual">
    Oracle Corporation.
    </textual><emphasis class="po-inline e552 e552"><textual class="po-textual">Java TM Platform Standard Ed. 7 API Documentation.</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e553 e553" xlink:actuate="onRequest" xlink:href="http://docs.oracle.com/javase/7/docs/api/index.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.oracle.com/javase/7/docs/api/index.html</textual></link><textual class="po-textual">.
Accessed 2012-04-01.
    </textual></bibliomixed><bibliomixed class="po-block e554 e554" xml:id="xsd11dt" xreflabel="XSD11.2"><textual class="po-textual">
    W3C: David Peterson, Shudi (Sandy) Gao é«æ®é, Ashok Malhotra,
C.M. Sperberg-McQueen, and Henry S. Thompson, editors.  
    </textual><emphasis class="po-inline e555 e555"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes.</textual></emphasis><textual class="po-textual">
    W3C. April 2012.
    </textual><link class="po-inline e556 e556" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema11-2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema11-2/</textual></link><textual class="po-textual">
	</textual></bibliomixed><bibliomixed class="po-block e557 e557" xml:id="xq30" xreflabel="XQuery30"><textual class="po-textual">
    W3C: Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, editors.
    </textual><emphasis class="po-inline e558 e558"><textual class="po-textual">XQuery 3.0: An XML Query Language</textual></emphasis><textual class="po-textual">
    Last Call Working Draft. W3C, December 2011.
    </textual><link class="po-inline e559 e559" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery-30/</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e560 e560" xml:id="introc" xreflabel="Singh04"><textual class="po-textual">
    Hermanpreet Singh.
    </textual><emphasis class="po-inline e561 e561"><textual class="po-textual">Introspective C++</textual></emphasis><textual class="po-textual">.
    Masters Thesis, Virginia Polytechnic Institute, 2004.
    </textual></bibliomixed><bibliomixed class="po-block e562 e562" xml:id="perl" xreflabel="Perl6"><textual class="po-textual">
    Larry Wall.
    </textual><emphasis class="po-inline e563 e563"><textual class="po-textual">Apocalypse 12: Objects; number 12 version 8.</textual></emphasis><textual class="po-textual">
    </textual><link class="po-inline e564 e564" xlink:actuate="onRequest" xlink:href="http://www.perl6.org/archive/doc/design/apo/A12.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.perl6.org/archive/doc/design/apo/A12.html</textual></link><textual class="po-textual">
    May 2006. Accessed 2012-04-01.
    </textual></bibliomixed><bibliomixed class="po-block e565 e565" xml:id="xq30dm" xreflabel="DM30"><textual class="po-textual">
    W3C: Norman Walsh, Anders Berglund, and John Snelson, editors.
    </textual><emphasis class="po-inline e566 e566"><textual class="po-textual">XQuery and XPath Data Model 3.0</textual></emphasis><textual class="po-textual">
    Last Call Working Draft. W3C, December 2011.
    </textual><link class="po-inline e567 e567" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-datamodel-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">
    </textual></bibliomixed></bibliography></article></classedDocument>