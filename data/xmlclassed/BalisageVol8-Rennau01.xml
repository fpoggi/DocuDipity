<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">From XML to UDL: a unified document language, supporting multiple markup languages</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">
        A proposal is made how to extend the XML node model in order to be compatible with JSON markup as
        well as XML markup. As XML processing technology (XPath, XQuery, XSLT, XProc) sees instances
        of the node model, but does not see syntax, it is thus enabled to handle JSON as well as XML. 
        The extended node model is dubbed a Unified Document Language, as it defines the 
        construction of documents from building blocks (nodes)
        which can be encoded in various markup languages (XML, JSON, HTML).      
      </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Hans-Jürgen</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Rennau</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Senior Java developer</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Traveltainment GmbH</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">hrennau@yahoo.de</textual></email></author><legalnotice class="po-container e18 e18"><para class="po-block e19 e19"><textual class="po-textual">Copyright © 2012 by the author. Used with permission.</textual></para></legalnotice><keywordset class="po-table e20 e20" role="author"><keyword class="po-field e21 e21"><textual class="po-textual">UDL</textual></keyword><keyword class="po-field e22 e22"><textual class="po-textual">XML</textual></keyword><keyword class="po-field e23 e23"><textual class="po-textual">JSON&gt;</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">Markup integration</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">XDM</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">XPath</textual></keyword><keyword class="po-field e27 e27"><textual class="po-textual">XQuery</textual></keyword><keyword class="po-field e28 e28"><textual class="po-textual">XSLT</textual></keyword></keywordset></info><section class="po-hcontainer e29 e29" xml:id="introduction"><title class="po-block e30 e30"><textual class="po-textual">Introduction</textual></title><para class="po-block e31 e31"><textual class="po-textual">
      Is an XML document a string or a tree of nodes? Although in many situations it can be 
      regarded as both, the “node view” is certainly more essential. It ignores syntax and 
      sees the information content. Specialized programs (parser and serializer) provide for 
      the translation between document string and node tree. General processing technologies – 
      e.g. XQuery - ignore syntax. This principle is the very foundation of their power. 
      Technologically speaking, the name “extensible markup language” is questionable, as it 
      emphasizes the surface, rather than the content.
    </textual></para><para class="po-block e32 e32"><textual class="po-textual">
      The node view of XML is the result of an evolutionary process. The XML specification 
      [</textual><xref class="po-milestone e33 e33" linkend="W3C-XML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (1998) itself does not use the word “node”. The tree 
      structure is still implicit, hidden behind the rules of well-formedness. The 
      infoset specification [</textual><xref class="po-milestone e34 e34" linkend="W3C-INFOSET"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (2004) defined the XML document 
      as a tree of information items, which is similar to a tree of nodes.
      The XDM [</textual><xref class="po-milestone e35 e35" linkend="W3C-XDM"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (2007) rounded the tree model 
      off, pruning it and extending it by replacing character children by a further node kind, 
      the text node. This completed node model was at the heart of the technological leap which 
      led to XPath 2.0, XSLT 2.0 and XQuery 1.0.
    </textual></para><para class="po-block e36 e36"><textual class="po-textual">
      Taking the evolution into consideration, one might wonder about the relationship between 
      XML and JSON. It is an obvious fact that they are two markup languages. But if XML is 
      essentially not a syntax, but an information language backed by a syntax – then we should 
      regard JSON as an information language plus syntax, too, and we should explore the 
      relationships between their information models, rather than dwell on the difference of 
      syntax. 
    </textual></para><para class="po-block e37 e37"><textual class="po-textual">
      Both models are tree models for hierarchical data. Why don’t we have one single, unified 
      model for hierarchical data? If we had one, XML and JSON would not be two languages, but 
      two syntactical styles – a difference that ceases to exist during data processing, between 
      parsing and serializing the data. A uniform data model would enable unified data design 
      approaches, and data processing could be handled by one single set of technologies. XML 
      and JSON parsers would act like adapters. Unfortunately, such a unified model does not 
      exist, due to incompatibilities. Although the XML model is larger and more complex, it 
      is not a superset of the JSON model. XML lacks arrays and maps and XML names cannot 
      be arbitrary strings.
    </textual></para><para class="po-block e38 e38"><textual class="po-textual">
      These incompatibilities throw a new light on XML. In 2011 Jonathan Robie 
      concluded [</textual><xref class="po-milestone e39 e39" linkend="ROBIE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]:
         </textual><blockquote class="po-container e40 e40"><para class="po-block e41 e41"><emphasis class="po-inline e42 e42" role="ital"><textual class="po-textual">
           The dream of one universal markup language is now past. JSON is clearly here to 
           stay, and it is becoming the format of choice for data interchange.
         </textual></emphasis></para></blockquote><textual class="po-textual">
    </textual></para><para class="po-block e43 e43"><textual class="po-textual">
      A possible response to this perception is a new dream: the dream of one universal 
      information language, backed by several syntax variants aka markup languages. 
      If XML is not as universal as it looked a few years ago – might we extend the 
      language (no pun intended), restoring the universality? This dream is an illusion 
      if we regard XML as a final version. In past years, any considered 
      improvements of XML were too insignificant to warrant the disruptions which a new 
      version might entail. But now we face new proportions, dealing with the issue of 
      universality. We should explore our chances to regain universality by extending 
      the XML model in a moderate, backward compatible way. Eventually, the lessons JSON 
      taught and teaches us might be to a huge benefit of XML – if we attempt to learn 
      them and act accordingly.
    </textual></para></section><section class="po-hcontainer e44 e44" xml:id="distinction-between-markup-and-document-language"><title class="po-block e45 e45"><textual class="po-textual">Distinction between markup and document language</textual></title><para class="po-block e46 e46"><textual class="po-textual">
      XML processing technology operates on node trees which capture 
      the information content of XML documents. The nodes may be constructed 
      from XML markup text, or in other ways. An XML document 
      </textual><emphasis class="po-inline e47 e47" role="ital"><textual class="po-textual">is</textual></emphasis><textual class="po-textual"> a tree of nodes, 
      and it may be </textual><emphasis class="po-inline e48 e48" role="ital"><textual class="po-textual">represented</textual></emphasis><textual class="po-textual"> by markup. 
      Therefore one might distinguish a </textual><emphasis class="po-inline e49 e49" role="bold"><textual class="po-textual">document language</textual></emphasis><textual class="po-textual">
      from a </textual><emphasis class="po-inline e50 e50" role="bold"><textual class="po-textual">markup language</textual></emphasis><textual class="po-textual">. The former is a 
      system which defines basic 
      units of information, possible relationships between such units and rules how 
      they can be combined into composite entities, the document. A markup language 
      is a set of rules how to encode a document as a string. To complete the picture, one might 
      add the concept of an </textual><emphasis class="po-inline e51 e51" role="bold"><textual class="po-textual">information language</textual></emphasis><textual class="po-textual">, 
      which models information in a more 
      general way – documents and their building blocks, the material 
      that may be inserted into or extracted from a document, and perhaps yet
      other forms of information. The triple XML / Infoset /
      XDM may be viewed as a stack consisting of a markup language, a document language 
      and an information language. 
      This stack of languages is the foundation of technologies – XPath, XQuery, 
      XSLT, XProc – which enable to address and process information with amazing 
      simplicity and efficiency. 
    </textual></para><para class="po-block e52 e52"><textual class="po-textual">
      </textual><note class="po-container e53 e53"><title class="po-block e54 e54"><textual class="po-textual">Use of the term "node model"</textual></title><para class="po-block e55 e55"><textual class="po-textual">
          The node sub model of the XDM can be regarded as a refactoring of the 
          infoset. The existence of two very similar, yet  distinct tree models – 
          a tree of information items, and a tree of nodes representing the 
          information items – is not really necessary and probably due to a 
          historical process. In this paper, it is the XDM/nodes sub model what 
          is regarded as the document model, rather than the infoset. The term 
          used will be “XML node model”, or simply “node model”.
        </textual></para></note><textual class="po-textual">
    </textual></para><para class="po-block e56 e56"><textual class="po-textual">
      Nevertheless, JSON has begun to replace XML in many applications. JSON is a 
      simpler and terser markup language, and it is perfectly integrated with 
      JavaScript objects. In many situations, JSON has clear advantages, when 
      neither the loss of expressive power, nor the lack of processing 
      technologies hurt. There is a growing awareness of the need to be 
      flexible, to avoid overhead and use the right tools: the necessity to adapt 
      the choice of markup language to the task at hand [</textual><xref class="po-milestone e57 e57" linkend="TENNISON"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
    </textual></para><para class="po-block e58 e58"><textual class="po-textual">
      Doubtless, the technological support for JSON will continuously evolve. 
      Very doubtful, however, it is if it can ever achieve the level attained 
      by XQuery 3.0 and XSLT 3.0. Maybe this will not be possible without a 
      similar evolution, adding to the markup language a document language 
      and an information language on which to base technology. I cannot 
      image that this would be possible without reinventing many wheels, with 
      the end result – in the best case – of a more limited version of XQuery and XSLT.
    </textual></para><para class="po-block e59 e59"><textual class="po-textual">
      Let us explore the alternative: loosen the tight coupling between the 
      XML markup language and the XML document language, extending the latter 
      to become a unified document language (“UDL”) supporting multiple markup 
      languages – XML, JSON, HTML, …
    </textual></para></section><section class="po-hcontainer e60 e60" xml:id="the-main-idea"><title class="po-block e61 e61"><textual class="po-textual">
      The main idea
    </textual></title><para class="po-block e62 e62"><textual class="po-textual">
      This section presents the main idea of UDL – Unified Document Language -
      in a suggestive way and without any precision. It should provide a 
      conceptual backdrop for the remaining sections. What is a document 
      from the “UDL point of view”?
    </textual></para><para class="po-block e63 e63"><textual class="po-textual">
      A document is a tree of elements. An element has content, which is either 
      text, or other elements, or both. An element has also two properties 
      designed to identify individual elements and to indicate the semantics 
      of the content. One property is the 
      </textual><emphasis class="po-inline e64 e64" role="bold"><textual class="po-textual">element name</textual></emphasis><textual class="po-textual">, the other one the 
      </textual><emphasis class="po-inline e65 e65" role="bold"><textual class="po-textual">element key</textual></emphasis><textual class="po-textual">. The name is a QName 
      and can be chosen irrespective of the sibling names; the key is an 
      arbitrary string and must not be equal to any sibling key.
      This duality implies three different styles how a document may be 
      designed:
      </textual><itemizedlist class="po-table e66 e66"><listitem class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">
            name oriented – the elements are identified and described by names
          </textual></para></listitem><listitem class="po-container e69 e69"><para class="po-block e70 e70"><textual class="po-textual">
            key oriented – the elements are identified and described by keys
          </textual></para></listitem><listitem class="po-container e71 e71"><para class="po-block e72 e72"><textual class="po-textual">
            mixed – making use of both, names and keys
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e73 e73"><textual class="po-textual">
      A document can be represented as a string, using a markup language. 
      XML is a markup language well-suited for name oriented documents; 
      JSON, on the other hand, is good at representing key oriented documents. 
      JSON is limited in this respect that it cannot represent arbitrary documents. 
      Only documents meeting certain constraints (using only unspecific standard 
      names, no attributes, no mixed content) can be represented by JSON. 
      XML, on the other hand, can represent any document, though not very 
      elegantly in the case of key oriented documents. 
    </textual></para><para class="po-block e74 e74"><textual class="po-textual">
      The foundation of document processing is the XPath language, with a core 
      designed for selecting nodes within a document. Its query syntax supports 
      a stepwise navigation across the document, where each step filters a set 
      of candidate nodes by a so-called node test. One node test – the name 
      test - refers to the name property. Example:
      </textual><programlisting class="po-block e75 e75" xml:space="preserve"><textual class="po-textual">
  a/b[.//c]</textual></programlisting><textual class="po-textual">
      This is a selection wholly based on element names. Another node test –
      the key test – refers to the key property. Example:
      </textual><programlisting class="po-block e76 e76" xml:space="preserve"><textual class="po-textual">
  #a/#b[.//#c]</textual></programlisting><textual class="po-textual">
      This selection is based on element keys, rather than names. 
      Apart from that, the logic is exactly the same. Of course, node tests 
      and key tests can be mixed:
      </textual><programlisting class="po-block e77 e77" xml:space="preserve"><textual class="po-textual">
  a/b[.//#c]</textual></programlisting><textual class="po-textual">
    </textual></para><para class="po-block e78 e78"><textual class="po-textual">
      To generalize, element name and element key are just two properties 
      which XPath expressions and languages built upon XPath (XQuery, XSLT,
      XProc) can reference in a similar way. XML documents and JSON 
      documents are alternative styles of how to represent a UDL document 
      as text string. A parser translates XML documents and JSON documents 
      into UDL documents. A serializer translates a UDL document into an 
      XML document or a JSON document. The translation into XML is always 
      possible without loss of information. The translation into JSON 
      deals with any loss of information as prescribed by 
      serialization parameters. 
    </textual></para><para class="po-block e79 e79"><textual class="po-textual">
      The remaining sections present a detailed proposal how to implement 
      the UDL by very limited extensions of the XML node model, XML markup, 
      XPath and XQuery.
    </textual></para></section><section class="po-hcontainer e80 e80" xml:id="goals-and-non-goals"><title class="po-block e81 e81"><textual class="po-textual">Goals and non-goals</textual></title><para class="po-block e82 e82"><textual class="po-textual">
      The XML node model shall be turned into a
      unified document language, so that XML
      processing technology - which is built on
      the node model, not on markup - 
      becomes a unified processing technology. In particular,
      the document language must support JSON so that
      the processing technology (XPath, XQuery, XSLT, XProc)
      becomes applicable to JSON data as well as to XML data.
    </textual></para><para class="po-block e83 e83"><textual class="po-textual">From this high-level objective 
      several goals are derived.
    </textual></para><para class="po-block e84 e84"><textual class="po-textual">
      </textual><itemizedlist class="po-table e85 e85"><listitem class="po-container e86 e86"><para class="po-block e87 e87"><textual class="po-textual">Extend the XML node model, enabling it to represent the information 
            content of JSON documents as a tree of nodes.</textual></para></listitem><listitem class="po-container e88 e88"><para class="po-block e89 e89"><textual class="po-textual">Define the serialization to/deserialization from JSON markup.</textual></para></listitem><listitem class="po-container e90 e90"><para class="po-block e91 e91"><textual class="po-textual">Extend the XML markup language, enabling it to express the 
            extended node model completely.</textual></para></listitem><listitem class="po-container e92 e92"><para class="po-block e93 e93"><textual class="po-textual">Extend the XML markup language, enabling the combination of 
            XML and non-XML markup.</textual></para></listitem><listitem class="po-container e94 e94"><para class="po-block e95 e95"><textual class="po-textual">Extend the XPath language, enabling navigation of JSON documents with the 
            same degree of terseness and flexibility.</textual></para></listitem><listitem class="po-container e96 e96"><para class="po-block e97 e97"><textual class="po-textual">Extend the XQuery language, adding shorthand notation for the construction
            of JSON data.</textual></para></listitem><listitem class="po-container e98 e98"><para class="po-block e99 e99"><textual class="po-textual">Make any changes to the XML node model in a backwards compatible way.</textual></para></listitem><listitem class="po-container e100 e100"><para class="po-block e101 e101"><textual class="po-textual">Make any changes to the XML markup language in a backwards compatible way.</textual></para></listitem><listitem class="po-container e102 e102"><para class="po-block e103 e103"><textual class="po-textual">Make any changes to the XPath language in a backwards compatible way.</textual></para></listitem><listitem class="po-container e104 e104"><para class="po-block e105 e105"><textual class="po-textual">Make any changes to the XQuery language in a backwards compatible way.</textual></para></listitem></itemizedlist><textual class="po-textual">
      These are non-goals.
      </textual><itemizedlist class="po-table e106 e106"><listitem class="po-container e107 e107"><para class="po-block e108 e108"><textual class="po-textual">
            Do not attempt to define a mapping from JSON markup to 
            XML markup (rather, define deserialization from / 
            serialization to JSON).

          </textual></para></listitem><listitem class="po-container e109 e109"><para class="po-block e110 e110"><textual class="po-textual">
            Do not attempt to achieve elegance concerning the XML markup 
            representation of a node tree derived from a JSON document.
          </textual></para></listitem><listitem class="po-container e111 e111"><para class="po-block e112 e112"><textual class="po-textual">
            Do not attempt to support characters which are valid in JSON but are 
            not valid in XML.
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para></section><section class="po-hcontainer e113 e113" xml:id="concepts"><title class="po-block e114 e114"><textual class="po-textual">Concepts</textual></title><para class="po-block e115 e115"><textual class="po-textual">
      The proposed approach is an elaboration of a small number of concepts.
    </textual></para><section class="po-hcontainer e116 e116" xml:id="the-node-model-as-a-unified-document-language"><title class="po-block e117 e117"><textual class="po-textual">
        The node model as a unified document language
      </textual></title><para class="po-block e118 e118"><textual class="po-textual">
         </textual><orderedlist class="po-table e119 e119"><listitem class="po-container e120 e120"><para class="po-block e121 e121"><textual class="po-textual">
                 The XML node model is extended in such a way that any 
                 JSON document can be translated into a node tree
                 and back again without loss of information.
               </textual></para></listitem><listitem class="po-container e122 e122"><para class="po-block e123 e123"><textual class="po-textual">
                 XML markup continues to represent the complete node model – 
                 an extension of the node model must be accompanied by an 
                 extension of the XML markup language.
               </textual></para></listitem><listitem class="po-container e124 e124"><para class="po-block e125 e125"><textual class="po-textual">
                 As JSON markup represents a subset of the node model, 
                 the concept of serialization is elaborated, defining distinct 
                 modes characterized by the acceptable loss of information.
               </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e126 e126" xml:id="the-node-representation-of-json-markup"><title class="po-block e127 e127"><textual class="po-textual">
        The node representation of JSON markup
      </textual></title><para class="po-block e128 e128"><textual class="po-textual">
         </textual><orderedlist class="po-table e129 e129"><listitem class="po-container e130 e130"><para class="po-block e131 e131"><textual class="po-textual">
                 JSON structures (objects and arrays) and their members are modelled 
                 as element nodes and their child elements, thus enabling continuous 
                 navigation along the descendant axis.
               </textual></para></listitem><listitem class="po-container e132 e132"><para class="po-block e133 e133"><textual class="po-textual">
                 As JSON names can be arbitrary strings and must be unique among
                 sibling name/value pairs, they must not represent node 
                 names, which are QNames and need not be unique among
                 sibling elements. Rather, JSON names correspond to a new 
                 node property, [key]. As a consequence, 
                 element nodes have two properties 
                 related to discovery and content semantics: a required [name] property and an 
                 optional [key] property.
               </textual></para></listitem><listitem class="po-container e134 e134"><para class="po-block e135 e135"><textual class="po-textual">
                 The contradiction implied by the facts that node names are required and 
                 JSON is incapable of encoding node names is solved by the concept of 
                 </textual><emphasis class="po-inline e136 e136" role="ital"><textual class="po-textual">defaulted node names</textual></emphasis><textual class="po-textual">: the nodes 
                 represented by JSON markup do have a name which is an unspecific 
                 standard name that depends on the content model of the 
                 node (representing an object, an array, a simple value or a null value). 
                 A node which has been constructed from JSON markup can afterwards be 
                 renamed without constraints, like any node constructed in any way.
               </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e137 e137" xml:id="concepts-extensions-of-the-xml-markup-language"><title class="po-block e138 e138"><textual class="po-textual">
        Extensions of the XML markup language
      </textual></title><para class="po-block e139 e139"><textual class="po-textual">
         </textual><orderedlist class="po-table e140 e140"><listitem class="po-container e141 e141"><para class="po-block e142 e142"><textual class="po-textual">
                 The necessary extension of the XML markup language avoids new 
                 syntactical constructs – it completely relies on the semantics 
                 of predefined QNames (e.g. </textual><code class="po-atom e143 e143"><textual class="po-textual">udl:key</textual></code><textual class="po-textual">) used in pseudo-attributes 
                 (constructs which look like an attribute but do not represent a node) 
                 and pseudo-tags (which look like an element but do 
                 not represent a node).
               </textual></para></listitem><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">
                 XML markup should be “opened”, permitting the local insertion of non-XML markup.
               </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e146 e146" xml:id="concepts-extensions-of-the-xpath-language"><title class="po-block e147 e147"><textual class="po-textual">
        Extensions of the XPath language
      </textual></title><para class="po-block e148 e148"><textual class="po-textual">
        </textual><orderedlist class="po-table e149 e149"><listitem class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">
              The XPath language is extended by a third node test – the 
              </textual><emphasis class="po-inline e152 e152" role="ital"><textual class="po-textual">key test</textual></emphasis><textual class="po-textual">, which checks whether 
              the candidate node has a given key. In a path step, the key test 
              can be used as alternative to a name test or kind test, which 
              means that key tests are freely combinable with navigational axes.
            </textual></para></listitem><listitem class="po-container e153 e153"><para class="po-block e154 e154"><textual class="po-textual">
              The syntax of a key test should be as simple as the syntax of a name test.
            </textual></para></listitem></orderedlist><textual class="po-textual">        
      </textual></para></section><section class="po-hcontainer e155 e155" xml:id="concepts-extensions-of-the-xquery-language"><title class="po-block e156 e156"><textual class="po-textual">
        Extensions of the XQuery language
      </textual></title><para class="po-block e157 e157"><textual class="po-textual">
        </textual><orderedlist class="po-table e158 e158"><listitem class="po-container e159 e159"><para class="po-block e160 e160"><textual class="po-textual">
              Extensions of the XQuery language are not essential, as JSON
              data are element nodes and thus can be processed without any
              restrictions. 
            </textual></para></listitem><listitem class="po-container e161 e161"><para class="po-block e162 e162"><textual class="po-textual">
              Nevertheless, the addition of some abbreviated
              syntax for the construction of  "JSON style nodes" 
              would be quite helpful.
            </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section></section><section class="po-hcontainer e163 e163" xml:id="proposal-extensions-of-xml-xpath-and_xquery"><title class="po-block e164 e164"><textual class="po-textual">
      Proposal: extensions of XML, XPath and XQuery
    </textual></title><para class="po-block e165 e165"><textual class="po-textual">
       This section describes the proposed extensions of XML, XPath and XQuery in detail.
    </textual></para><section class="po-hcontainer e166 e166" xml:id="extensions-of-the-xml-node-model"><title class="po-block e167 e167"><textual class="po-textual">
        Extensions of the XML node model
      </textual></title><para class="po-block e168 e168"><textual class="po-textual">
        The XML node model is extended by two new node properties, [model] 
        and [key]. The result of these changes is a unified node model 
        which can represent XML documents, JSON documents as well as nested 
        combinations of JSON and XML fragments as a tree of nodes which 
        is accessible to XPath navigation and, by implication, XQuery 
        and XSLT processing.
      </textual></para><para class="po-block e169 e169"><textual class="po-textual">
        </textual><emphasis class="po-inline e170 e170" role="bold"><emphasis class="po-inline e171 e171" role="ital"><textual class="po-textual">
          Details
        </textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><orderedlist class="po-table e172 e172"><listitem class="po-container e173 e173"><para class="po-block e174 e174"><textual class="po-textual">
            The node model is extended by a further node property: the 
            </textual><emphasis class="po-inline e175 e175" role="bold"><textual class="po-textual">[key] property</textual></emphasis><textual class="po-textual">. Only element 
            nodes have a [key], which is possibly empty. The [key] must not
            be empty if the [parent] is an element whose
            [model] property (see below) has a value of "map". In any other
            case (i.e. if [parent] is empty, or is not an element node,
            or is an element whose [model] is "sequence")
            the [key] must be empty. The [key] of an element must not be
            equal to the [key] of any sibling element.
          </textual></para></listitem><listitem class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual">
            The node model is extended by a further node property: the 
            </textual><emphasis class="po-inline e178 e178" role="bold"><textual class="po-textual">[model] property</textual></emphasis><textual class="po-textual">. Only
            element nodes have a [model], the value of which must be
            either "sequence" or "map". If the
            value is "sequence", the child nodes are an ordered
            collection and child elements must not have a [key]. Conversely, 
            if the value is "map", the child nodes are an unordered
            collection, every child element must have a [key] and there
            must not be text node children containing a non-whitespace
            character. Note that the [model] can be regarded as a
            switch selecting one of two possible content models:
            sequence based (property value "sequence") or
            key based (property value "map"). In the former case
            element content is a sequence of child nodes; in the
            latter case element content is a map of
            child elements, using the child [key]s as map keys.
            The former case corresponds to "conventional XML", 
            where content is always ordered by position.
          </textual></para></listitem><listitem class="po-container e179 e179"><para class="po-block e180 e180"><textual class="po-textual">
            </textual><emphasis class="po-inline e181 e181" role="bold"><textual class="po-textual">JSON simple values</textual></emphasis><textual class="po-textual">
            are represented by (not nilled) element nodes which have simple 
            content, or (in the case of a zero-length string)
            empty content and a [schema-type] xs:untypedAtomic.
          </textual></para></listitem><listitem class="po-container e182 e182"><para class="po-block e183 e183"><textual class="po-textual">
            </textual><emphasis class="po-inline e184 e184" role="bold"><textual class="po-textual">JSON null values</textual></emphasis><textual class="po-textual"> are represented 
            by nilled elements.
          </textual></para></listitem><listitem class="po-container e185 e185"><para class="po-block e186 e186"><textual class="po-textual">
            </textual><emphasis class="po-inline e187 e187" role="bold"><textual class="po-textual">JSON objects</textual></emphasis><textual class="po-textual"> 
            are represented by (not nilled) element nodes 
            with [model] equal "map". By implication, such
            elements may or may not have child elements, but
            they have no text node children containing
            non-whitespace characters.
            The name/value pairs contained by the object are represented by 
            the element children. Other child nodes (e.g. comments or 
            whitespace-only text nodes) do not correspond to name/value pairs.
            Note that an empty object is represented by an element
            with [model] equal "map" and no child elements.
         </textual></para></listitem><listitem class="po-container e188 e188"><para class="po-block e189 e189"><textual class="po-textual">
            </textual><emphasis class="po-inline e190 e190" role="bold"><textual class="po-textual">JSON arrays</textual></emphasis><textual class="po-textual"> are represented by 
            (not nilled) element nodes satisfying these constraints: (a)
            [model] equal "sequence",
            (b) the content is either empty or contains at least one child element; 
            (c) there are no text node children containing non-whitespace characters. 
            The array members are represented by the element children. 
            Other child nodes (e.g. comments or whitespace-only text nodes) 
            do not correspond to array members.
          </textual></para></listitem><listitem class="po-container e191 e191"><para class="po-block e192 e192"><textual class="po-textual">
            </textual><emphasis class="po-inline e193 e193" role="bold"><textual class="po-textual">JSON names</textual></emphasis><textual class="po-textual"> are represented by 
            the [key] property of element nodes.
          </textual></para></listitem><listitem class="po-container e194 e194"><para class="po-block e195 e195"><textual class="po-textual">
            When a node tree is constructed from a JSON document, null values, 
            simple values, arrays and objects are represented by elements which 
            have </textual><emphasis class="po-inline e196 e196" role="bold"><textual class="po-textual">default node-names</textual></emphasis><textual class="po-textual"> (
            </textual><code class="po-atom e197 e197"><textual class="po-textual">udl:null</textual></code><textual class="po-textual">, 
            </textual><code class="po-atom e198 e198"><textual class="po-textual">udl:value</textual></code><textual class="po-textual">, 
            </textual><code class="po-atom e199 e199"><textual class="po-textual">udl:array</textual></code><textual class="po-textual"> and 
            </textual><code class="po-atom e200 e200"><textual class="po-textual">udl:map</textual></code><textual class="po-textual">). 
            As any element names in XML, these names do not have any 
            built-in semantics: they do not signal that the element has
            been constructed from a JSON value, and they do not imply specific 
            values of any node properties. 
            After an update or if the node tree is constructed in any other way, 
            the elements representing null values, simple values, arrays and objects 
            may have any valid node name.
          </textual></para><para class="po-block e201 e201"><textual class="po-textual">
            Note that JSON names and XML names correspond to two distinct node 
            properties which are utterly independent of each other. And also 
            note the asymmetry: whereas JSON names are represented in XML markup 
            by keys (via the </textual><code class="po-atom e202 e202"><textual class="po-textual">udl:key</textual></code><textual class="po-textual"> 
            pseudo-attribute, see next section), XML names cannot 
            be represented in JSON markup at all. Lossless information mapping in 
            both directions is nevertheless enabled by arbitrarily defining 
            JSON markup to represent nodes with default names which are
            implied by other node properties.
          </textual></para></listitem></orderedlist></section><section class="po-hcontainer e203 e203" xml:id="extensions-of-the-xml-markup-language"><title class="po-block e204 e204"><textual class="po-textual">
        Extensions of the XML markup language
      </textual></title><para class="po-block e205 e205"><textual class="po-textual">
        The extensions have two purposes: (a) express the 
        new node properties; (b) support the use of non-XML markup within XML 
        documents.
      </textual></para><section class="po-hcontainer e206 e206" xml:id="expressing-the-new-node-properties"><title class="po-block e207 e207"><textual class="po-textual">
          Expressing the new node properties
        </textual></title><para class="po-block e208 e208"><textual class="po-textual">
          The XML markup language is extended by rules how to represent the new 
          node properties.
        </textual></para><para class="po-block e209 e209"><textual class="po-textual">
          </textual><emphasis class="po-inline e210 e210" role="bold"><emphasis class="po-inline e211 e211" role="ital"><textual class="po-textual">
            Details
          </textual></emphasis></emphasis><textual class="po-textual">
        </textual></para><orderedlist class="po-table e212 e212"><listitem class="po-container e213 e213"><para class="po-block e214 e214"><textual class="po-textual">
              A pseudo-attribute (</textual><code class="po-atom e215 e215"><textual class="po-textual">udl:model</textual></code><textual class="po-textual">) is introduced which indicates 
              the value of the </textual><emphasis class="po-inline e216 e216" role="bold"><textual class="po-textual">[model] property</textual></emphasis><textual class="po-textual">. 
              Possible values are "sequence" and
              "map". The default value is "sequence", unless the element has an
              ancestor element with a pseudo-attribute </textual><code class="po-atom e217 e217"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual">,
              in which case the default is specified by the nearest ancestor 
              with a </textual><code class="po-atom e218 e218"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual"> pseudo-attribute.
            </textual></para></listitem><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">
              A pseudo-attribute (</textual><code class="po-atom e221 e221"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual">) is introduced which 
              sets the default value of [model] for the element itself and its
              descendants. The default value applies to the element itself and
              to its descendant elements unless the element in question has
              simple content (in which case [model] is always "sequence"),
              or has a [model] pseudo-attribute (which overrides the default)
              or has a nearer ancestor with a 
              </textual><code class="po-atom e222 e222"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual"> pseudo-attribute (which shadows
              any outer default values).
            </textual></para></listitem><listitem class="po-container e223 e223"><para class="po-block e224 e224"><textual class="po-textual">
              A pseudo-attribute (</textual><code class="po-atom e225 e225"><textual class="po-textual">udl:key</textual></code><textual class="po-textual">) is introduced which indicates 
              the value of the </textual><emphasis class="po-inline e226 e226" role="bold"><textual class="po-textual">[key] property</textual></emphasis><textual class="po-textual">. 
              If an element without </textual><code class="po-atom e227 e227"><textual class="po-textual">udl:key</textual></code><textual class="po-textual"> is child of an 
              element whose [model] is "map", the [key] defaults to the local
              name of the element. Example:
              </textual><programlisting class="po-block e228 e228" xml:space="preserve"><textual class="po-textual">
   &lt;foo udl:model="map"&gt;
      &lt;bar udl:key="bar"&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</textual></programlisting><textual class="po-textual">
              is equivalent to:
              </textual><programlisting class="po-block e229 e229" xml:space="preserve"><textual class="po-textual">
   &lt;foo udl:model="map"&gt;
      &lt;bar&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</textual></programlisting><textual class="po-textual">
              Note that non-empty [key]s are only allowed for elements
              with [parent].[model] equal "map". Accordingly, only such
              elements may have a </textual><code class="po-atom e230 e230"><textual class="po-textual">udl:key</textual></code><textual class="po-textual"> pseudo-attribute.
              Example: if in the following markup
              </textual><programlisting class="po-block e231 e231" xml:space="preserve"><textual class="po-textual">
   &lt;foo udl:model="map"&gt;
      &lt;bar udl:key="21"&gt;abc&lt;/foo&gt;
   &lt;/foo&gt;</textual></programlisting><textual class="po-textual">
              the value of </textual><code class="po-atom e232 e232"><textual class="po-textual">udl:model</textual></code><textual class="po-textual"> were changed to
              "sequence", the markup would cease to be well-formed.
            </textual></para></listitem></orderedlist></section><section class="po-hcontainer e233 e233" xml:id="supporting-non-xml-markup"><title class="po-block e234 e234"><textual class="po-textual">
          Supporting non-XML markup
        </textual></title><para class="po-block e235 e235"><textual class="po-textual">
          The extensions enable the use of non-XML markup either embedded 
          in XML markup or completely replacing it.
        </textual></para><para class="po-block e236 e236"><textual class="po-textual">
          </textual><emphasis class="po-inline e237 e237" role="bold"><emphasis class="po-inline e238 e238" role="ital"><textual class="po-textual">
            Details
          </textual></emphasis></emphasis><textual class="po-textual">
        </textual></para><orderedlist class="po-table e239 e239"><listitem class="po-container e240 e240"><para class="po-block e241 e241"><textual class="po-textual">
              The XML syntax model is extended by permitting 
              </textual><emphasis class="po-inline e242 e242" role="bold"><textual class="po-textual">alternative markup languages</textual></emphasis><textual class="po-textual">. 
              An alternative language can be used in three 
              different scopes: (a) the content of an element, (b)  
              a document section of arbitrary length, representing any
              number of sibling nodes, 
              (c) the complete document. Three languages are supported: 
              </textual><code class="po-atom e243 e243"><textual class="po-textual">xml</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e244 e244"><textual class="po-textual">json</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e245 e245"><textual class="po-textual">telem</textual></code><textual class="po-textual">,
              a slightly simplified version of XML 
              using JSON-like constructs for simple elements meeting 
              certain constraints. See 
              </textual><xref class="po-milestone e246 e246" linkend="mixing-markup-styles"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for details.
            </textual></para></listitem><listitem class="po-container e247 e247"><para class="po-block e248 e248"><textual class="po-textual">
              The XML syntax model is extended by a pseudo-attribute, 
              </textual><code class="po-atom e249 e249"><textual class="po-textual">udl:markup</textual></code><textual class="po-textual">, which specifies the markup 
              language used to represent the content of an element. 
              If the value is not </textual><code class="po-atom e250 e250"><textual class="po-textual">xml</textual></code><textual class="po-textual">, the child nodes
              of the element
              are the nodes constructed from the markup found in the
              text content.
              Only element tags and the pseudo-tag </textual><code class="po-atom e251 e251"><textual class="po-textual">udl:markupSection</textual></code><textual class="po-textual">
              (see below) may have this 
              pseudo-attribute. Possible values are: 
              </textual><code class="po-atom e252 e252"><textual class="po-textual">xml</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e253 e253"><textual class="po-textual">json</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e254 e254"><textual class="po-textual">telem</textual></code><textual class="po-textual">; 
              default value is </textual><code class="po-atom e255 e255"><textual class="po-textual">xml</textual></code><textual class="po-textual">. Example:
              </textual><programlisting class="po-block e256 e256" xml:space="preserve"><textual class="po-textual">
   &lt;temperatures y="2012" 
                 udl:markup="json"&gt;&lt;![CDATA[
      "2012-08-01" : 33.2,
      "2012-08-02" : 28.9,
      "2012-08-03" : 30.0,
      "sites" : ["AB", "DK", "PP"],
      "anno" : {"automatic" : true, "reference" : false}
   ]]&gt;&lt;/temperatures&gt;</textual></programlisting><textual class="po-textual">
              Note that the scope of the alternative 
              markup language is the content of an element and 
              that the alternative representation is preceded and 
              followed by the XML start and end tag of the element. 
              Thus the markup of the example corresponds to an 
              element with name “temperatures”, which has one attribute 
              and five child elements. An XML document can use 
              different markup languages in different elements. 
            </textual></para></listitem><listitem class="po-container e257 e257"><para class="po-block e258 e258"><textual class="po-textual">
              The XML syntax model is extended by a pseudo-tag 
              </textual><code class="po-atom e259 e259"><textual class="po-textual">udl:markupSection</textual></code><textual class="po-textual">, which delimits a 
              markup section, a section of the document text which 
              uses a particular markup language. 
              When constructing the node tree, the pseudo-tag and 
              its contents represent the nodes constructed from 
              the contained markup. The markup language is identified 
              by the </textual><code class="po-atom e260 e260"><textual class="po-textual">udl:markup</textual></code><textual class="po-textual"> pseudo-attribute 
              contained by the pseudo-tag. In the following 
              example, the pseudo-tag represents five nodes 
              which are constructed from the JSON markup:          
              </textual><programlisting class="po-block e261 e261" xml:space="preserve"><textual class="po-textual">
   &lt;udl:markupSection udl:markup="JSON"&gt;&lt;![CDATA[
      "2012-08-01" : 33.2,
      "2012-08-02" : 28.9,
      "2012-08-03" : 30.0,
      "sites" : ["AB", "DK", "PP"],
      "anno" : {"automatic" : true, "reference" : false}
   ]]&gt;&lt;/udl:markupSection&gt;</textual></programlisting><textual class="po-textual">
              Note that the pseudo-tag does itself not represent a node – 
              it has a purely delimiting function.
              Any non-XML markup may be used which is supported by the 
              parser. Besides JSON, a parser may support an 
              implementation-defined set of further markup languages 
              or domain specific languages.
            </textual></para></listitem><listitem class="po-container e262 e262"><para class="po-block e263 e263"><textual class="po-textual">
              The </textual><emphasis class="po-inline e264 e264" role="bold"><textual class="po-textual">XML declaration</textual></emphasis><textual class="po-textual"> is 
              extended by a further field: </textual><code class="po-atom e265 e265"><textual class="po-textual">markup</textual></code><textual class="po-textual">. Possible 
              values are: 
              </textual><code class="po-atom e266 e266"><textual class="po-textual">xml</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e267 e267"><textual class="po-textual">json</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e268 e268"><textual class="po-textual">html</textual></code><textual class="po-textual">; 
              default is </textual><code class="po-atom e269 e269"><textual class="po-textual">xml</textual></code><textual class="po-textual">. Depending on the value, 
              the text following the XML declaration will be 
              interpreted as XML markup, JSON markup or HTML markup. 
              Example:
              </textual><programlisting class="po-block e270 e270" xml:space="preserve"><textual class="po-textual">
   &lt;?xml markup="json" encoding="ISO-8859-1"?&gt;
   {
      "title" : "JSON and XML",
      "year" : 2012
   }</textual></programlisting><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e271 e271"><para class="po-block e272 e272"><textual class="po-textual">
              The XML markup language is augmented by a rule how to parse a 
              </textual><emphasis class="po-inline e273 e273" role="bold"><textual class="po-textual">non-XML document without
              XML declaration</textual></emphasis><textual class="po-textual">. If the first non-whitespace character 
              of the text is not the “&lt;” character, the document text is 
              interpreted as non-XML markup. More precisely, it is 
              interpreted as the default non-XML markup which is expected 
              to be JSON, although implementation-defined alternatives 
              might be considered. Example: the text
              </textual><programlisting class="po-block e274 e274" xml:space="preserve"><textual class="po-textual">
   {
      "title" : "JSON and XML",
      "year" : 2012
   }</textual></programlisting><textual class="po-textual">
              is a valid UDL document.
            </textual></para></listitem></orderedlist></section></section><section class="po-hcontainer e275 e275" xml:id="extensions-of-the-xml-serialization-model"><title class="po-block e276 e276"><textual class="po-textual">
        Extensions of the XML serialization model
      </textual></title><para class="po-block e277 e277"><textual class="po-textual">
        The serialization model must be extended in order to support JSON output.
        </textual><orderedlist class="po-table e278 e278"><listitem class="po-container e279 e279"><para class="po-block e280 e280"><textual class="po-textual">
              When the serialization method is </textual><code class="po-atom e281 e281"><textual class="po-textual">xml</textual></code><textual class="po-textual">, 
              serialization produces conventional XML markup, 
              augmented by the pseudo-attributes 
              </textual><code class="po-atom e282 e282"><textual class="po-textual">udl:key</textual></code><textual class="po-textual">, </textual><code class="po-atom e283 e283"><textual class="po-textual">udl:model</textual></code><textual class="po-textual"> 
              and </textual><code class="po-atom e284 e284"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual"> where appropriate.
            </textual></para></listitem><listitem class="po-container e285 e285"><para class="po-block e286 e286"><textual class="po-textual">
              When the serialization method is </textual><code class="po-atom e287 e287"><textual class="po-textual">xml</textual></code><textual class="po-textual">, the serialization 
              may nevertheless insert non-XML markup into the document text, 
              depending on serialization parameters. The non-XML markup is 
              constrained to represent element contents – that is, every 
              chunk of non-XML markup is scoped to represent the content 
              of an element whose start and end tag delimit the chunk.
            </textual></para></listitem><listitem class="po-container e288 e288"><para class="po-block e289 e289"><textual class="po-textual">
              When the serialization method is </textual><code class="po-atom e290 e290"><textual class="po-textual">xml</textual></code><textual class="po-textual">, additional 
              serialization parameters control the use of alternative markup 
              within selected elements. Parameter 
              </textual><code class="po-atom e291 e291"><textual class="po-textual">json-content-elements</textual></code><textual class="po-textual"> contains a list of expanded 
              QNames, identifying the elements whose content shall be 
              represented as JSON markup. In a similar way, parameter 
              </textual><code class="po-atom e292 e292"><textual class="po-textual">telem-content-elements</textual></code><textual class="po-textual"> identifies the elements 
              to be rendered using the </textual><code class="po-atom e293 e293"><textual class="po-textual">telem</textual></code><textual class="po-textual"> style. 
              (For details see 
              </textual><xref class="po-milestone e294 e294" linkend="mixing-markup-styles"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
            </textual></para></listitem><listitem class="po-container e295 e295"><para class="po-block e296 e296"><textual class="po-textual">
              The value range of serialization parameter 
              </textual><code class="po-atom e297 e297"><textual class="po-textual">method</textual></code><textual class="po-textual"> is extended by the value 
              </textual><code class="po-atom e298 e298"><textual class="po-textual">json</textual></code><textual class="po-textual">. This value lets the 
              complete document be serialized as JSON markup.
            </textual></para></listitem><listitem class="po-container e299 e299"><para class="po-block e300 e300"><textual class="po-textual">
              A new serialization parameter 
              </textual><code class="po-atom e301 e301"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> specifies how to handle 
              information loss implied by the serialization.
              Special values relate to 
              situations where JSON markup should be produced but a 
              node to be serialized contains information which cannot 
              be expressed by a JSON representation. (There are three cases:
              (i) mixed content,
              (ii) the use of attributes,
              (iii) the use of non-standard element names.) 
              Three parameter values are supported: 
              </textual><code class="po-atom e302 e302"><textual class="po-textual">json.strict</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e303 e303"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual">, and 
              </textual><code class="po-atom e304 e304"><textual class="po-textual">json.projection</textual></code><textual class="po-textual">. In case of </textual><code class="po-atom e305 e305"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> the 
              serialization must be aborted; the value 
              </textual><code class="po-atom e306 e306"><textual class="po-textual">json.projection</textual></code><textual class="po-textual"> mandates a projection 
              which simply ignores any information which cannot 
              be represented; 
              and the value </textual><code class="po-atom e307 e307"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual"> means that the 
              QNames of XML elements are ignored, but any other 
              incompatibility with the JSON model 
              (e.g. the use of attributes) 
              produces an unrecoverable error. (For details see
              </textual><xref class="po-milestone e308 e308" linkend="serialization-controlling-the-loss-of-information"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.)
            </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e309 e309" xml:id="extensions-of-the-xpath-language"><title class="po-block e310 e310"><textual class="po-textual">
         Extensions of the XPath language
       </textual></title><para class="po-block e311 e311"><textual class="po-textual">
         The extensions are designed to make the processing of
         JSON data as powerful and convenient as the processing
         of XML data. Namely, the [key] property can be checked
         by a </textual><emphasis class="po-inline e312 e312" role="ital"><textual class="po-textual">key test</textual></emphasis><textual class="po-textual">, 
         similarly to the checking of the node name by a
         node test.
       </textual></para><orderedlist class="po-table e313 e313"><listitem class="po-container e314 e314"><para class="po-block e315 e315"><textual class="po-textual">
           The XPath language is extended by a new node test, 
           an alternative to the existing name test and kind test: 
           the </textual><emphasis class="po-inline e316 e316" role="bold"><textual class="po-textual">key test</textual></emphasis><textual class="po-textual">. A key test 
           checks for the candidate node if it has a key equal to 
           a given key value. In path expressions, key tests can be 
           combined with XPath axes in the same way as kind tests 
           and name tests. The syntax of a key test is a # character           
           immediately followed by the key value delimited by single
           or double quotes. If the key value contains only name characters,
           the quotes can be omitted. If quotes are used, occurrences
           of the actual quote character within the key value
           must be escaped by an entity or character reference.
           The characters </textual><code class="po-atom e317 e317"><textual class="po-textual">&amp;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e318 e318"><textual class="po-textual">&lt;</textual></code><textual class="po-textual">
           must always be escaped.
           Examples of path steps containing a key test:
           </textual><programlisting class="po-block e319 e319" xml:space="preserve"><textual class="po-textual">
  #key1
  #"key1"
  #”key 2”
  self::"#key 2"
  descendant::#key3
  parent::#"#key4"
  ancestor::#'++14085! &amp;amp; O&amp;apos;Neill'</textual></programlisting><textual class="po-textual">
           </textual></para></listitem><listitem class="po-container e320 e320"><para class="po-block e321 e321"><textual class="po-textual">
             A new XPath function </textual><code class="po-atom e322 e322"><textual class="po-textual">fn:node-key</textual></code><textual class="po-textual"> returns 
             the [key] of a given node, or the empty sequence 
             if the node has no [key]: 
             </textual><programlisting class="po-block e323 e323" xml:space="preserve"><textual class="po-textual">
  fn:node-key($node as node()?) as xs:string?</textual></programlisting><textual class="po-textual">
             Example: the expression
             </textual><programlisting class="po-block e324 e324" xml:space="preserve"><textual class="po-textual">
  string-join($x/ancestor-or-self::*/(concat(‘#’, fn:node-key(.)), ‘/’)</textual></programlisting><textual class="po-textual">
             might return a result like </textual><code class="po-atom e325 e325"><textual class="po-textual">#a/#b/#c</textual></code><textual class="po-textual">.
           </textual></para></listitem><listitem class="po-container e326 e326"><para class="po-block e327 e327"><textual class="po-textual">
             A new XPath function </textual><code class="po-atom e328 e328"><textual class="po-textual">fn:node-model</textual></code><textual class="po-textual"> returns 
             the [model] of a given node, or the empty sequence
             if the node is not an element node. The [model] is 
             represented as a string
             which is either "sequence" or "map": 
             </textual><programlisting class="po-block e329 e329" xml:space="preserve"><textual class="po-textual">
  fn:node-model($node as node()?) as xs:string?</textual></programlisting><textual class="po-textual">
           </textual></para></listitem><listitem class="po-container e330 e330"><para class="po-block e331 e331"><textual class="po-textual">
             The semantics of function </textual><code class="po-atom e332 e332"><textual class="po-textual">fn:deep-equal</textual></code><textual class="po-textual">
             is modified as follows: (a) if the arguments are element
             nodes with different [key]s or with different
             [models]s, the function returns "false"; (b) if both 
             arguments are element nodes with [model] equal "map",
             the comparison ignores non-element children and
             ignores the order of element children.
           </textual></para></listitem><listitem class="po-container e333 e333"><para class="po-block e334 e334"><textual class="po-textual">
             The </textual><emphasis class="po-inline e335 e335" role="ital"><textual class="po-textual">abbreviated syntax</textual></emphasis><textual class="po-textual"> 
             is extended by a more intuitive
             syntax for accessing array members by index, which hides
             the fact that array members are child nodes:
             </textual><programlisting class="po-block e336 e336" xml:space="preserve"><textual class="po-textual">
  foo~[expr] </textual></programlisting><textual class="po-textual">
             is equal to

             </textual><programlisting class="po-block e337 e337" xml:space="preserve"><textual class="po-textual">
  foo/*[expr]</textual></programlisting><textual class="po-textual">
           </textual></para></listitem></orderedlist></section><section class="po-hcontainer e338 e338" xml:id="extensions-of-the-xquery-language"><title class="po-block e339 e339"><textual class="po-textual">
        Extensions of the XQuery language
      </textual></title><para class="po-block e340 e340"><textual class="po-textual">
        As JSON items correspond to element nodes, there is no principal
        need to introduce new constructor expressions. In element
        constructors, the pseudo-attributse </textual><code class="po-atom e341 e341"><textual class="po-textual">udl:key</textual></code><textual class="po-textual"> 
        and </textual><code class="po-atom e342 e342"><textual class="po-textual">udl:model</textual></code><textual class="po-textual"> are used in the same way as they are
        used in XML markup. In order to reduce verbosity,
        however, several abbreviated variants of element constructors
        are introduced.
        </textual><orderedlist class="po-table e343 e343"><listitem class="po-container e344 e344"><para class="po-block e345 e345"><textual class="po-textual">
              </textual><emphasis class="po-inline e346 e346" role="bold"><textual class="po-textual">Map constructors</textual></emphasis><textual class="po-textual">
              are a shorthand for constructing element nodes 
              with name </textual><code class="po-atom e347 e347"><textual class="po-textual">udl:map</textual></code><textual class="po-textual"> and [model] equal "map". Syntax:
              </textual><programlisting class="po-block e348 e348" xml:space="preserve"><textual class="po-textual">
{ Expr }

   is equivalent to:

&lt;udl:map udl:model="map"&gt;{ Expr }&lt;/udl:map&gt;</textual></programlisting><textual class="po-textual">
            </textual></para><para class="po-block e349 e349"><textual class="po-textual">
              The children of the newly constructed </textual><code class="po-atom e350 e350"><textual class="po-textual">udl:map</textual></code><textual class="po-textual">
              element are obtained by (a) evaluating the
              content expession to an item sequence, (b) replacing
              in this sequence any document node by its document element,
              (c) replacing in the resulting sequence any element
              without a key by a copy which has a key equal to
              its local name. An error is raised if the result 
              sequence contains atomic or text node items, or if
              it contains two elements with the same key. Otherwise,
              the expression value is guaranteed to be an element
              which can be serialized to JSON without information loss.
            </textual></para></listitem><listitem class="po-container e351 e351"><para class="po-block e352 e352"><textual class="po-textual">
              </textual><emphasis class="po-inline e353 e353" role="bold"><textual class="po-textual">Array constructors</textual></emphasis><textual class="po-textual">
              are a shorthand for constructing element nodes 
              which correspond to a JSON array. Syntax:
              </textual><programlisting class="po-block e354 e354" xml:space="preserve"><textual class="po-textual">
[ Expr ]

   is equivalent to the following code
   (where p:copy-without-key denotes a pseudo function creating an element copy without [key]):

&lt;udl:array&gt;{
  for $item in Expr return 
    typeswitch($item)
    case document-node()  return $item/*/p:copy-without-key(.)
    case element()        return $item/p:copy-without-key(.)
    case text()           return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
    case xs:anyAtomicType return &lt;udl:value&gt;{$item}&lt;/udl:value&gt;
    default               return ()
}&lt;/udl:array&gt;</textual></programlisting><textual class="po-textual">
              </textual></para><para class="po-block e355 e355"><textual class="po-textual">
              The children of the newly constructed
              </textual><code class="po-atom e356 e356"><textual class="po-textual">udl:array</textual></code><textual class="po-textual"> element are obtained by (a) evaluating
              the content expression to an item sequence, 
              (b) replacing in this sequence any document nodes by 
              their element children, 
              (c) replacing in the resulting sequence any element
              with a key by a copy which does not have a key, 
              (d) replacing in the resulting sequence any atomic values
              by a </textual><code class="po-atom e357 e357"><textual class="po-textual">udl:value</textual></code><textual class="po-textual"> element containing the value as text. 
              The expression value is guaranteed to be an element which can
              be serialized to a JSON array without information loss.
            </textual></para></listitem><listitem class="po-container e358 e358"><para class="po-block e359 e359"><textual class="po-textual">
              </textual><emphasis class="po-inline e360 e360" role="bold"><textual class="po-textual">Key-oriented constructors</textual></emphasis><textual class="po-textual">
              are a shorthand for constructing element nodes with a 
              non-empty [key]. 
              They have the following syntax:
              </textual><programlisting class="po-block e361 e361" xml:space="preserve"><textual class="po-textual">
   Expr ':' Expr

   Examples:
   "title" : "XML and JSON"
   $ti     : $tnode
   "title" : //title
   "times" : [ "2012-01-01", "2012-03-31" ],
   "time" : { "begin" : "2012-01-01", "end" : "2012-03-31" }</textual></programlisting><textual class="po-textual">
              The value of this expression is determined as follows.
              </textual><itemizedlist class="po-table e362 e362"><listitem class="po-container e363 e363"><para class="po-block e364 e364"><textual class="po-textual">
                     Evaluate the expression to the left of the
                     colon; the result must be a single item; 
                     determine its string value S. 
                   </textual></para></listitem><listitem class="po-container e365 e365"><para class="po-block e366 e366"><textual class="po-textual">
                     Evaluate the expression to the right of the
                     colon; the result R must be either the
                     empty sequence or a single item.
                   </textual></para></listitem><listitem class="po-container e367 e367"><para class="po-block e368 e368"><textual class="po-textual">
                     If R is the empty sequence, the value of
                     the constructor expression is an element
                     node with name </textual><code class="po-atom e369 e369"><textual class="po-textual">udl:null</textual></code><textual class="po-textual">,
                     a [key] property equal S and a
                     [nilled] property equal true.
                   </textual></para></listitem><listitem class="po-container e370 e370"><para class="po-block e371 e371"><textual class="po-textual">
                     If R is a node, the value of the constructor expression
                     is a node obtained by making a copy of R
                     and setting its [key] property to S.
                   </textual></para></listitem><listitem class="po-container e372 e372"><para class="po-block e373 e373"><textual class="po-textual">
                     Otherwise (that is, if R is an atomic value)
                     the value of the constructor expression is an element 
                     node with the name </textual><code class="po-atom e374 e374"><textual class="po-textual">udl:value</textual></code><textual class="po-textual">,
                     a [key] property equal S and a single
                     text node child whose string value is 
                     the string value of R. (Special case:
                     empty content if the string value of R
                     is a zero-length string.)
                     The resulting element has a type annotation
                     which depends on the type of R. If R
                     has a number type, the type annotation is
                     one of these:
                     </textual><code class="po-atom e375 e375"><textual class="po-textual">xs:double</textual></code><textual class="po-textual">,
                     </textual><code class="po-atom e376 e376"><textual class="po-textual">xs:decimal</textual></code><textual class="po-textual">,
                     </textual><code class="po-atom e377 e377"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">, 
                     whatever is closest to the type of R.
                     If R has a boolean type, the type annotation is
                     </textual><code class="po-atom e378 e378"><textual class="po-textual">xs:boolean</textual></code><textual class="po-textual">. If R is a zero-length
                     string, the type annotation is 
                     </textual><code class="po-atom e379 e379"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">. Otherwise, the
                     default type annotation is used (
                     </textual><code class="po-atom e380 e380"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual">).
                   </textual></para></listitem></itemizedlist><textual class="po-textual">
            </textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para></section></section><section class="po-hcontainer e381 e381" xml:id="checking-use-cases"><title class="po-block e382 e382"><textual class="po-textual">Checking use cases</textual></title><para class="po-block e383 e383"><textual class="po-textual">
      The proposal made in this paper is motivated by several main use cases. In each of
      these, a significant simplification of the task should be achieved.
    </textual></para><itemizedlist class="po-table e384 e384"><listitem class="po-container e385 e385"><para class="po-block e386 e386"><textual class="po-textual">
          JSON documents must be queried.
        </textual></para></listitem><listitem class="po-container e387 e387"><para class="po-block e388 e388"><textual class="po-textual">
          JSON documents must be transformed into other JSON documents.
        </textual></para></listitem><listitem class="po-container e389 e389"><para class="po-block e390 e390"><textual class="po-textual">
          JSON documents must be transformed into XML documents.
        </textual></para></listitem><listitem class="po-container e391 e391"><para class="po-block e392 e392"><textual class="po-textual">
          JSON documents must be transformed into HTML documents.
        </textual></para></listitem><listitem class="po-container e393 e393"><para class="po-block e394 e394"><textual class="po-textual">
          JSON documents must be transformed into other formats (e.g. CSV).
        </textual></para></listitem><listitem class="po-container e395 e395"><para class="po-block e396 e396"><textual class="po-textual">
          JSON documents must be created from XML documents.
        </textual></para></listitem><listitem class="po-container e397 e397"><para class="po-block e398 e398"><textual class="po-textual">
          JSON documents must be created from other formats (e.g. CSV).
        </textual></para></listitem></itemizedlist><para class="po-block e399 e399"><textual class="po-textual">
      The fact that XML standard technologies - XPath, XQuery, XSLT, XProc -
      now accept JSON documents as input suggests a great advantage.
      We should however take a closer look at how the processing of JSON
      data looks. Somewhat arbitrarily, these main aspects may be 
      distinguished:
      </textual><itemizedlist class="po-table e400 e400"><listitem class="po-container e401 e401"><para class="po-block e402 e402"><textual class="po-textual">
            Selecting JSON data
          </textual></para></listitem><listitem class="po-container e403 e403"><para class="po-block e404 e404"><textual class="po-textual">
            The use of JSON data within XPath/XQuery expressions
            and XSLT instructions
          </textual></para></listitem><listitem class="po-container e405 e405"><para class="po-block e406 e406"><textual class="po-textual">
            Creating JSON data
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e407 e407"><textual class="po-textual">
      The </textual><emphasis class="po-inline e408 e408" role="bold"><textual class="po-textual">selection of data</textual></emphasis><textual class="po-textual"> 
      is a crucial operation, underlying
      virtually all forms of data processing. This is the domain
      of XPath, so we shall take a look at how XPath deals with JSON
      data. 
      The proposal avoids the creation of special item types -
      all JSON data reside in element nodes. Therefore it can
      be expected that the </textual><emphasis class="po-inline e409 e409" role="bold"><textual class="po-textual">
      use of JSON data in expressions</textual></emphasis><textual class="po-textual">
      and XSLT instructions is indistinguishable from 
      the use of any other element nodes.
      The </textual><emphasis class="po-inline e410 e410" role="bold"><textual class="po-textual">creation of JSON data</textual></emphasis><textual class="po-textual"> 
      amounts to the creation of
      element nodes, so that again we may expect the same
      ease when creating JSON data as when creating any
      other element nodes.
    </textual></para><para class="po-block e411 e411"><textual class="po-textual">
    Let us contemplate a few examples. As input we use the following
    JSON document:
    </textual></para><programlisting class="po-block e412 e412" xml:space="preserve"><textual class="po-textual">
[
   {
      "year" : 2011, 
      "title" : "JSON", 
      "author" : [
         {"last" : "Legoux", "first" : "C."}
      ], 
      "price" : 35.95,
      "sigs" : ["LL1002"]
   }, 
   {
      "year" : 2012, 
      "title" : "XML", 
      "author" : [
         {"last" : "Legoux", "first" : "C."}, 
         {"last" : "Berlin", "first" : "D."}
      ], 
      "price" : 29.95,
      "sigs" : []
   },
   {
      "year" : 2012, 
      "title" : "UDL", 
      "author" : [
         {"last" : "Legoux", "first" : "C."},
         {"last" : "Okuda", "first" : "J."}, 
         {"last" : "Berlin", "first" : "D."}
      ], 
      "price" : 49.95,
      "sigs" : ["KL4005", "KL4011"]
   }
]</textual></programlisting><para class="po-block e413 e413"><textual class="po-textual">
      The following table shows a series of 
      </textual><emphasis class="po-inline e414 e414" role="ital"><textual class="po-textual">data selections</textual></emphasis><textual class="po-textual"> with
      XPath/XQuery. The expressions typically use key tests (#foo) 
      instead of name tests. Apart from that there is no difference
      compared to conventional uses of XPath. 
      Writing the expressions, one must keep in mind that object members
      (the name/value pairs) and array members are represented by child
      elements of the element representing the object or array,
      respectively.
    </textual></para><para class="po-block e415 e415"><textual class="po-textual">
      </textual><table class="po-container e416 e416"><caption class="po-container e417 e417"><para class="po-block e418 e418"><textual class="po-textual">
            </textual><emphasis class="po-inline e419 e419" role="bold"><emphasis class="po-inline e420 e420" role="ital"><textual class="po-textual">
              Selecting JSON data with XPath/XQuery.
            </textual></emphasis></emphasis><textual class="po-textual">
          </textual></para></caption><col align="left" class="po-meta e421 e421" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e422 e422" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e423 e423"><tr class="po-table e424 e424" valign="top"><th align="left" class="po-field e425 e425" valign="top"><textual class="po-textual">task</textual></th><th align="left" class="po-field e426 e426" valign="top"><textual class="po-textual">expression</textual></th><th align="left" class="po-field e427 e427" valign="top"><textual class="po-textual">result</textual></th></tr></thead><tbody class="po-table e428 e428"><tr class="po-table e429 e429" valign="top"><td class="po-block e430 e430"><textual class="po-textual">count books</textual></td><td class="po-block e431 e431"><code class="po-atom e432 e432"><textual class="po-textual">count(/*/*)</textual></code></td><td class="po-block e433 e433"><textual class="po-textual">3</textual></td></tr><tr class="po-table e434 e434" valign="top"><td class="po-block e435 e435"><textual class="po-textual">maximum price</textual></td><td class="po-block e436 e436"><code class="po-atom e437 e437"><textual class="po-textual">max(//#price/xs:decimal(.))</textual></code></td><td class="po-block e438 e438"><textual class="po-textual">
              </textual><para class="po-block e439 e439"><textual class="po-textual">49.95</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e440 e440" valign="top"><td class="po-block e441 e441"><textual class="po-textual">first book title</textual></td><td class="po-block e442 e442"><code class="po-atom e443 e443"><textual class="po-textual">/*/*[1]/#title/string()</textual></code></td><td class="po-block e444 e444"><textual class="po-textual">JSON</textual></td></tr><tr class="po-table e445 e445" valign="top"><td class="po-block e446 e446"><textual class="po-textual">all publication years</textual></td><td class="po-block e447 e447"><code class="po-atom e448 e448"><textual class="po-textual">distinct-values(//#year/string())</textual></code></td><td class="po-block e449 e449"><textual class="po-textual">2011 2012</textual></td></tr><tr class="po-table e450 e450" valign="top"><td class="po-block e451 e451"><textual class="po-textual">books about UDL</textual></td><td class="po-block e452 e452"><code class="po-atom e453 e453"><textual class="po-textual">//#title[contains(., 'UDL')]/string()</textual></code></td><td class="po-block e454 e454"><textual class="po-textual">UDL</textual></td></tr><tr class="po-table e455 e455" valign="top"><td class="po-block e456 e456"><textual class="po-textual">books above 30$</textual></td><td class="po-block e457 e457"><code class="po-atom e458 e458"><textual class="po-textual">//#title[../#price/xs:decimal(.) gt 30]/string()</textual></code></td><td class="po-block e459 e459"><textual class="po-textual">
              </textual><para class="po-block e460 e460"><textual class="po-textual">JSON UDL</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e461 e461" valign="top"><td class="po-block e462 e462"><textual class="po-textual">books with a single author</textual></td><td class="po-block e463 e463"><code class="po-atom e464 e464"><textual class="po-textual">//#title[count(../#author/*) eq 1]</textual></code></td><td class="po-block e465 e465"><textual class="po-textual">
              </textual><para class="po-block e466 e466"><textual class="po-textual">JSON</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e467 e467" valign="top"><td class="po-block e468 e468"><textual class="po-textual">books without signature</textual></td><td class="po-block e469 e469"><code class="po-atom e470 e470"><textual class="po-textual">//#title[empty(../#sigs/*)]</textual></code></td><td class="po-block e471 e471"><textual class="po-textual">
              </textual><para class="po-block e472 e472"><textual class="po-textual">XML</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e473 e473" valign="top"><td class="po-block e474 e474"><textual class="po-textual">books written by Legoux</textual></td><td class="po-block e475 e475"><code class="po-atom e476 e476"><textual class="po-textual">/*/*[.//#last = 'Legoux']/#title/string()</textual></code></td><td class="po-block e477 e477"><textual class="po-textual">
              </textual><para class="po-block e478 e478"><textual class="po-textual">JSON XML UDL</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e479 e479" valign="top"><td class="po-block e480 e480"><textual class="po-textual">coauthors of Legoux</textual></td><td class="po-block e481 e481"><code class="po-atom e482 e482"><textual class="po-textual">distinct-values(//#last[. eq 'Legoux']/../../*/#last[. ne 'Legoux'])</textual></code></td><td class="po-block e483 e483"><textual class="po-textual">
              </textual><para class="po-block e484 e484"><textual class="po-textual">Berlin Okuda</textual></para><textual class="po-textual">
            </textual></td></tr><tr class="po-table e485 e485" valign="top"><td class="po-block e486 e486"><textual class="po-textual">duplicate signatures</textual></td><td class="po-block e487 e487"><textual class="po-textual">
              </textual><para class="po-block e488 e488"><code class="po-atom e489 e489"><textual class="po-textual">for $s in distinct-values(//#sigs/*)</textual></code></para><textual class="po-textual">
              </textual><para class="po-block e490 e490"><code class="po-atom e491 e491"><textual class="po-textual">where count(//#sigs[* = $s]) gt 1</textual></code></para><textual class="po-textual">
              </textual><para class="po-block e492 e492"><code class="po-atom e493 e493"><textual class="po-textual">return $s</textual></code></para><textual class="po-textual">
            </textual></td><td class="po-block e494 e494"><textual class="po-textual">
              </textual><para class="po-block e495 e495"><textual class="po-textual">LL1002</textual></para><textual class="po-textual">
            </textual></td></tr></tbody></table><textual class="po-textual">
    </textual></para><para class="po-block e496 e496"><textual class="po-textual">
      In order to get a feeling how selected JSON data can be 
      </textual><emphasis class="po-inline e497 e497" role="ital"><textual class="po-textual">used in expressions</textual></emphasis><textual class="po-textual">
      and how JSON data can be 
      </textual><emphasis class="po-inline e498 e498" role="ital"><textual class="po-textual">constructed</textual></emphasis><textual class="po-textual">, 
      we build a report that transforms the input
      data into a new structure. The report shall list for each author
      all titles he or she has authored, along with the 
      publication year. An XML version of the report might look 
      like this:
      </textual><programlisting class="po-block e499 e499" xml:space="preserve"><textual class="po-textual">
&lt;authors&gt;
   &lt;author name="Legoux, C."&gt;
      &lt;book title="JSON" year="2011"/&gt;
      &lt;book title="UDL" year="2012"/&gt;
      &lt;book title="XML" year="2012"/&gt;
   &lt;/author&gt;
   &lt;author name="Okuda, J."&gt;
      &lt;book title="UDL" year="2012"/&gt;
   &lt;/author&gt;
   &lt;author name="Berlin, D."&gt;
      &lt;book title="UDL" year="2012"/&gt;
      &lt;book title="XML" year="2012"/&gt;
   &lt;/author&gt;
&lt;/authors&gt;
</textual></programlisting><textual class="po-textual">
      and a JSON version like this:
      </textual><programlisting class="po-block e500 e500" xml:space="preserve"><textual class="po-textual">
[
   {
      "author" : "Legoux, C.", 
      "books" : [
         {"title" : "JSON", "year" : "2011"}, 
         {"title" : "UDL",  "year" : "2012"}, 
         {"title" : "XML", "year" : "2012"}
      ]
   }, 
   {
      "author" : "Okuda, J.", 
      "books" : [
         {"title" : "UDL", "year" : "2012"}
      ]
   }, 
   {
      "author" : "Berlin, D.", 
      "books" : [
         {"title" : "UDL", "year" : "2012"}, 
         {"title" : "XML", "year" : "2012"}
      ]
   }
]</textual></programlisting><textual class="po-textual">
      The XML report can be produced with this query:
      </textual><programlisting class="po-block e501 e501" xml:space="preserve"><textual class="po-textual">
&lt;authors&gt;{
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      &lt;author name="{$author}"&gt;{
         for $book in $books
         order by $book/#title
         return 
            &lt;book title="{$book/#title}" year="{$book/#year}" /&gt;
      }&lt;/author&gt;   
}&lt;/authors&gt;
</textual></programlisting><textual class="po-textual">
      and the JSON version can be produced with this query:
      </textual><programlisting class="po-block e502 e502" xml:space="preserve"><textual class="po-textual">
&lt;udl:array&gt;{
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      &lt;udl:map udl:model="map"&gt;{
         &lt;udl:value udl:key="author"&gt;{$author}&lt;/udl:value&gt;,
         &lt;udl:array udl:key="books"&gt;{
            for $book in $books
            order by $book/#title
            return 
            &lt;udl:map udl:model="map"&gt;{
               &lt;udl:value udl:key="title"&gt;{$book/#title/string()}&lt;/udl:value&gt;,
               &lt;udl:value udl:key="year"&gt;{$book/#year/string()}&lt;/udl:value&gt;
            }&lt;/udl:map&gt;
         }&lt;/udl:array&gt;
      }&lt;/udl:map&gt;   
}&lt;/udl:array&gt;</textual></programlisting><textual class="po-textual">
      The element constructors required to create JSON nodes
      are somewhat verbose, and the code is not very readable
      as the distinctive information - the key - is embedded
      in stereotyped markup 
      (e.g. 
      </textual><code class="po-atom e503 e503"><textual class="po-textual">&lt;udl:map udl:key="..."&gt;</textual></code><textual class="po-textual">
      The situation can be amended by resorting to the 
      abbreviated constructors for maps and arrays along with
      the key-oriented constructors 
      (see </textual><xref class="po-milestone e504 e504" linkend="extensions-of-the-xquery-language"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">):
      </textual><programlisting class="po-block e505 e505" xml:space="preserve"><textual class="po-textual">
[
   for $author in distinct-values(//#author/*/concat(#last , ', ', #first))
   let $books := //#author[*/concat( #last , ', ', #first ) = $author]/..
   order by $author 
   return
      {
         "author" : $author,
         "books" : [
            for $book in $books
            order by $book/#title
            return 
               {
                  "title" : $book/#title/string(),
                  "year" : $book/#year/string()
               }
         ]
      }
]</textual></programlisting><textual class="po-textual">
      The code examples demonstrated that the processing of JSON data
      with XPath and XQuery is comparable to the processing of XML 
      data. For all use cases
      one may expect from XPath/XQuery/XSLT/XProc 
      the same level of support which one is used to get when 
      dealing with similar problems related to XML without JSON.
      This may be taken as encouragement to explore
      the proposal in greater detail.
    </textual></para></section><section class="po-hcontainer e506 e506" xml:id="various-details"><title class="po-block e507 e507"><textual class="po-textual">
      Various details
    </textual></title><section class="po-hcontainer e508 e508" xml:id="udl-pseudo-attributes-and-pseudo-tags"><title class="po-block e509 e509"><textual class="po-textual">
        UDL - pseudo-attributes and pseudo-tags
      </textual></title><para class="po-block e510 e510"><textual class="po-textual">
        Pseudo-attributes are syntactical constructs which have the lexical 
        form of attributes but can be distinguished from them by the use of 
        a reserved QName. Pseudo-attributes do not represent an attribute node.
        Instead, they represent a node property 
        (</textual><code class="po-atom e511 e511"><textual class="po-textual">udl:key</textual></code><textual class="po-textual">, </textual><code class="po-atom e512 e512"><textual class="po-textual">udl:model</textual></code><textual class="po-textual">) or 
        a default value of a property 
        (</textual><code class="po-atom e513 e513"><textual class="po-textual">udl:defaultModel</textual></code><textual class="po-textual">), or they identify the markup language
        used locally (</textual><code class="po-atom e514 e514"><textual class="po-textual">udl:markup</textual></code><textual class="po-textual">).
      </textual></para><para class="po-block e515 e515"><textual class="po-textual">
        Pseudo-tags are syntactical constructs which have the lexical form 
        of element tags but can be distinguished from them by the use of a 
        reserved QName. One pseudo-tag is introduced 
        (</textual><code class="po-atom e516 e516"><textual class="po-textual">udl:markupSection</textual></code><textual class="po-textual">) which delimits a section 
        of non-XML markup.
      </textual></para><para class="po-block e517 e517"><textual class="po-textual">
        Four further names from the UDL namespace are used as 
        default element names, given to the nodes constructed 
        from JSON values. It is important to note that these 
        names have no specific semantics and can be used 
        as node name without restrictions like any other 
        QName. The only specific 
        treatment of these names is when serializing to JSON 
        using the </textual><code class="po-atom e518 e518"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> mode. In this case a node 
        name which is different from the default name expected 
        (according to the node properties)
        is considered information that would be lost during
        serialization (see 
        </textual><xref class="po-milestone e519 e519" linkend="serialization-controlling-the-loss-of-information"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
      </textual></para><para class="po-block e520 e520"><textual class="po-textual">
        The following table summarizes the use of QNames from the UDL 
        namespace.
      </textual></para><para class="po-block e521 e521"><textual class="po-textual">
          </textual><table class="po-container e522 e522" xml:id="table-reserved-names"><caption class="po-container e523 e523"><para class="po-block e524 e524"><textual class="po-textual">
                </textual><emphasis class="po-inline e525 e525" role="bold"><emphasis class="po-inline e526 e526" role="ital"><textual class="po-textual">
                  Names in the 
                  </textual><code class="po-atom e527 e527"><textual class="po-textual">udl</textual></code><textual class="po-textual"> namespace and their usage.
                </textual></emphasis></emphasis><textual class="po-textual">
              </textual></para></caption><col align="left" class="po-meta e528 e528" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e529 e529" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e530 e530"><tr class="po-table e531 e531" valign="top"><th align="left" class="po-field e532 e532" valign="top"><textual class="po-textual">Name</textual></th><th align="left" class="po-field e533 e533" valign="top"><textual class="po-textual">Usage category</textual></th><th align="left" class="po-field e534 e534" valign="top"><textual class="po-textual">Meaning</textual></th></tr></thead><tbody class="po-table e535 e535"><tr class="po-table e536 e536" valign="top"><td class="po-block e537 e537"><code class="po-atom e538 e538"><textual class="po-textual">udl:null</textual></code></td><td class="po-block e539 e539"><textual class="po-textual">element name</textual></td><td class="po-block e540 e540"><textual class="po-textual">
                  a standard name available for nilled elements with an unspecific name
                </textual></td></tr><tr class="po-table e541 e541" valign="top"><td class="po-block e542 e542"><code class="po-atom e543 e543"><textual class="po-textual">udl:value</textual></code></td><td class="po-block e544 e544"><textual class="po-textual">element name</textual></td><td class="po-block e545 e545"><textual class="po-textual">
                  a standard name available for a simple content element with an unspecific name
                </textual></td></tr><tr class="po-table e546 e546" valign="top"><td class="po-block e547 e547"><code class="po-atom e548 e548"><textual class="po-textual">udl:array</textual></code></td><td class="po-block e549 e549"><textual class="po-textual">element name</textual></td><td class="po-block e550 e550"><textual class="po-textual">
                  a standard name available for a complex element with [model] equal "sequence"
                </textual></td></tr><tr class="po-table e551 e551" valign="top"><td class="po-block e552 e552"><code class="po-atom e553 e553"><textual class="po-textual">udl:map</textual></code></td><td class="po-block e554 e554"><textual class="po-textual">element name</textual></td><td class="po-block e555 e555"><textual class="po-textual">
                  a standard name available for a complex element with [model] equal "map"
                </textual></td></tr><tr class="po-table e556 e556" valign="top"><td class="po-block e557 e557"><code class="po-atom e558 e558"><textual class="po-textual">udl:markupSection</textual></code></td><td class="po-block e559 e559"><textual class="po-textual">pseudo tag</textual></td><td class="po-block e560 e560"><textual class="po-textual">
                  delimits a markup section containing markup which may 
                  be non-XML; the section represents the nodes resulting 
                  from parsing the contained markup text
                </textual></td></tr><tr class="po-table e561 e561" valign="top"><td class="po-block e562 e562"><code class="po-atom e563 e563"><textual class="po-textual">udl:markup</textual></code></td><td class="po-block e564 e564"><textual class="po-textual">pseudo attribute</textual></td><td class="po-block e565 e565"><textual class="po-textual">
                  indicates the markup language used within element content, or 
                  within a markup section
                </textual></td></tr><tr class="po-table e566 e566" valign="top"><td class="po-block e567 e567"><code class="po-atom e568 e568"><textual class="po-textual">udl:model</textual></code></td><td class="po-block e569 e569"><textual class="po-textual">pseudo attribute</textual></td><td class="po-block e570 e570"><textual class="po-textual">
                  represents the [model] property value
                </textual></td></tr><tr class="po-table e571 e571" valign="top"><td class="po-block e572 e572"><code class="po-atom e573 e573"><textual class="po-textual">udl:defaultModel</textual></code></td><td class="po-block e574 e574"><textual class="po-textual">pseudo attribute</textual></td><td class="po-block e575 e575"><textual class="po-textual">
                  sets a default value for the [model] property
                </textual></td></tr><tr class="po-table e576 e576" valign="top"><td class="po-block e577 e577"><code class="po-atom e578 e578"><textual class="po-textual">udl:key</textual></code></td><td class="po-block e579 e579"><textual class="po-textual">pseudo attribute</textual></td><td class="po-block e580 e580"><textual class="po-textual">
                  represents the [key] property value
                </textual></td></tr></tbody></table><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e581 e581" xml:id="mixing-markup-styles"><title class="po-block e582 e582"><textual class="po-textual">
        Mixing markup styles
      </textual></title><para class="po-block e583 e583"><textual class="po-textual">
        The UDL defines a unified document model which can be 
        represented by different markup languages. This unified 
        content of heterogeneous outward shape invites not only 
        a free choice of the markup language actually used. It 
        also implies that markup languages might be mixed within 
        a document, based on simple rules how to delimit the 
        various chunks of markup. These rules are provided 
        by the </textual><code class="po-atom e584 e584"><textual class="po-textual">udl:markup</textual></code><textual class="po-textual"> pseudo-attribute and the 
        </textual><code class="po-atom e585 e585"><textual class="po-textual">udl:markupSection </textual></code><textual class="po-textual">
        pseudo-tag (see 
        </textual><xref class="po-milestone e586 e586" linkend="supporting-non-xml-markup"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">).
      </textual></para><para class="po-block e587 e587"><textual class="po-textual">
        Occasionally there may be good reasons to use mixed 
        styles. Consider the case that the document as a 
        whole cannot be represented as JSON (e.g. because 
        of attributes and namespaces), but subtrees 
        represent JSON documents (perhaps imported from 
        pure JSON sources, e.g. logged messages). 
        Without the mixing of markup 
        styles, the resulting serialization would be 
        difficult to read, due to the very verbose
        XML representation of JSON nodes. It should
        of course be remembered that this mixing of
        markup styles has no impact on the
        information content of the UDL document,
        which is exclusively defined in terms of nodes
        and their properties.
      </textual></para><para class="po-block e588 e588"><textual class="po-textual">  
        The following section describes in detail an 
        additional markup style, which amounts to
        a "small-scale mixing" of XML and JSON, dubbed 
        </textual><code class="po-atom e589 e589"><textual class="po-textual">telem</textual></code><textual class="po-textual"> (text notation for 
        simple elements).
      </textual></para></section><section class="po-hcontainer e590 e590" xml:id="xml-syntax-variant-telem"><title class="po-block e591 e591"><textual class="po-textual">
        XML syntax variant: </textual><code class="po-atom e592 e592"><textual class="po-textual">telem</textual></code><textual class="po-textual">
      </textual></title><para class="po-block e593 e593"><textual class="po-textual">
        XML markup representing JSON data is 
        ugly. Typically it contains many elements which
        correspond to simple values and are 
        tiresome to read. The 
        </textual><emphasis class="po-inline e594 e594" role="ital"><textual class="po-textual">distinctive</textual></emphasis><textual class="po-textual"> property 
        of the elements is shifted from the 
        eye-catching node name to a pseudo-attribute, 
        and the markup is often inflated
        by explicit type annotations:
        </textual><programlisting class="po-block e595 e595" xml:space="preserve"><textual class="po-textual">
  &lt;udl:value udl:key=”foo”&gt;someContent&lt;/udl:value&gt;
  &lt;udl:value udl:key=”bar” xsi:type="xs:integer"&gt;99&lt;/udl:value&gt;
  &lt;udl:value udl:key=”foobar” xsi:type="xs:boolean"&gt;true&lt;/udl:value</textual></programlisting><textual class="po-textual">
        whereas the JSON representation could not be more succinct:
        </textual><programlisting class="po-block e596 e596" xml:space="preserve"><textual class="po-textual">
  "foo" : "someContent",
  ”bar”" : 99,
  "foobar” : true</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e597 e597"><textual class="po-textual">
        Fragments containing </textual><emphasis class="po-inline e598 e598" role="ital"><textual class="po-textual">only</textual></emphasis><textual class="po-textual">
        JSON nodes can best be represented by switching to JSON. But
        sometimes such JSON values occur interspersed with conventional
        XML elements which have specific names, have attributes, etc.
        In such cases it is attractive to apply the JSON
        style to the simple values and retain XML style for
        the fragment as a whole. This option is provided by
        the </textual><code class="po-atom e599 e599"><textual class="po-textual">telem</textual></code><textual class="po-textual"> markup style. 
      </textual></para><para class="po-block e600 e600"><textual class="po-textual">
        This style is XML markup augmented by a shorthand representation
        of simple elements meeting several constraints: 
        </textual><itemizedlist class="po-table e601 e601"><listitem class="po-container e602 e602"><para class="po-block e603 e603"><textual class="po-textual">
              element name is the standard name </textual><code class="po-atom e604 e604"><textual class="po-textual">udl:value</textual></code><textual class="po-textual">
            </textual></para></listitem><listitem class="po-container e605 e605"><para class="po-block e606 e606"><textual class="po-textual">
              simple content or nilled
            </textual></para></listitem><listitem class="po-container e607 e607"><para class="po-block e608 e608"><textual class="po-textual">
              no attributes
            </textual></para></listitem><listitem class="po-container e609 e609"><para class="po-block e610 e610"><textual class="po-textual">
              [schema-type] is one of these:
              </textual><code class="po-atom e611 e611"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e612 e612"><textual class="po-textual">xs:decimal</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e613 e613"><textual class="po-textual">xs:double</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e614 e614"><textual class="po-textual">xs:boolean</textual></code><textual class="po-textual">,
              </textual><code class="po-atom e615 e615"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">, 
              </textual><code class="po-atom e616 e616"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual">
            </textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e617 e617"><textual class="po-textual">
        The syntax corresponds to the JSON representation of a simple 
        or null value, or of a name/value pair with simple or null
        value, depending on whether the element has a [key]. 
        If consecutive element children are represented in 
        </textual><code class="po-atom e618 e618"><textual class="po-textual">telem</textual></code><textual class="po-textual"> style, these representations are 
        separated by a comma. If the value is not put in quotes, it 
        must be a number or one of the constants 
        </textual><code class="po-atom e619 e619"><textual class="po-textual">true</textual></code><textual class="po-textual">, 
        </textual><code class="po-atom e620 e620"><textual class="po-textual">false</textual></code><textual class="po-textual"> or 
        </textual><code class="po-atom e621 e621"><textual class="po-textual">null</textual></code><textual class="po-textual">, which will be interpreted as implicit type 
        information, following the JSON rules. Example: the following fragment
        </textual><programlisting class="po-block e622 e622" xml:space="preserve"><textual class="po-textual">
   &lt;e udl:model="map"&gt;
      &lt;udl:value udl:key="mode"&gt;repeated&lt;/udl:value&gt;
      &lt;udl:value udl:key="nrep" xsi:type=”xs:integer”&gt;52076&lt;/udl:value&gt;
      &lt;udl:value udl:key="eval" xs:type=”xs:boolean”&gt;true&lt;/udl:value&gt;
      &lt;locInfo udl:key="cities"&gt;
        &lt;udl:value&gt;Paris&lt;/udl:value&gt;
        &lt;udl:value&gt;London&lt;/udl:value&gt;
        &lt;udl:value&gt;Manchester&lt;/udl:value&gt;
      &lt;/locInfo&gt;
   &lt;/e&gt;</textual></programlisting><textual class="po-textual">
        may be alternatively represented this way:
        </textual><programlisting class="po-block e623 e623" xml:space="preserve"><textual class="po-textual">
   &lt;e udl:model="map" udl:markup=”telem”&gt;
      "mode" : “repeated”,
      "nrep" : 52076,
      “eval” : true
      &lt;locInfo udl:key="cities"&gt;
        "Paris",
        "London",
        "Mancester"
      &lt;/locInfo&gt;
   &lt;/e&gt;</textual></programlisting><textual class="po-textual">
        Both representations have the same information content.
      </textual></para></section><section class="po-hcontainer e624 e624" xml:id="deserializing-from-serializing-to-json"><title class="po-block e625 e625"><textual class="po-textual">
        Deserializing from / serializing to JSON
      </textual></title><para class="po-block e626 e626"><textual class="po-textual">
        The exact rules for translating JSON into UDL (deserialization) and for 
        translating UDL into JSON (serialization) are listed in the appendix 
        (</textual><xref class="po-milestone e627 e627" linkend="appendix-deserialization"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
        and </textual><xref class="po-milestone e628 e628" linkend="appendix-serialization"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). 
        In this section, the principles are summarized.
      </textual></para><section class="po-hcontainer e629 e629" xml:id="deserialization"><title class="po-block e630 e630"><textual class="po-textual">
          Deserialization
        </textual></title><para class="po-block e631 e631"><textual class="po-textual">
          During deserialization every JSON “item” (object, array, 
          simple value, null) is translated into a UDL element node whose 
          name and content are determined by the kind of the JSON 
          item (see 
          </textual><xref class="po-milestone e632 e632" linkend="table-deserialization"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). 
          If the JSON item is associated with 
          a name, the name is copied into the [key] property of the 
          element node; otherwise the element node has no [key].
        </textual></para><para class="po-block e633 e633"><textual class="po-textual">
          Numbers and Boolean constants are translated into 
          simple elements with a [schema-type] property reflecting 
          the source item (one of: 
          </textual><code class="po-atom e634 e634"><textual class="po-textual">xs:integer</textual></code><textual class="po-textual">,
          </textual><code class="po-atom e635 e635"><textual class="po-textual">xs:decimal</textual></code><textual class="po-textual">,
          </textual><code class="po-atom e636 e636"><textual class="po-textual">xs:double</textual></code><textual class="po-textual">,
          </textual><code class="po-atom e637 e637"><textual class="po-textual">xs:boolean</textual></code><textual class="po-textual">).
          A string which has non-zero length is translated into
          a simple element with [schema-type] </textual><code class="po-atom e638 e638"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual">.
          A zero-length string is translated into an 
          empty element node with
          [schema-type] </textual><code class="po-atom e639 e639"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">,
          so as to make it distinguishable from a node 
          constructed from an empty array or object.
        </textual></para><para class="po-block e640 e640"><textual class="po-textual">
          </textual><table class="po-container e641 e641" xml:id="table-deserialization"><caption class="po-container e642 e642"><para class="po-block e643 e643"><textual class="po-textual">
                </textual><emphasis class="po-inline e644 e644" role="bold"><emphasis class="po-inline e645 e645" role="ital"><textual class="po-textual">
                  Deserialization - translating JSON items into
                  UDL nodes.
                </textual></emphasis></emphasis><textual class="po-textual">
              </textual></para></caption><col align="left" class="po-meta e646 e646" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e647 e647" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e648 e648"><tr class="po-table e649 e649" valign="top"><th align="left" class="po-field e650 e650" rowspan="2" valign="top"><textual class="po-textual">JSON item</textual></th><th align="center" class="po-field e651 e651" colspan="3" valign="top"><textual class="po-textual">UDL node properties</textual></th><th align="left" class="po-field e652 e652" rowspan="2" valign="top"><textual class="po-textual">remarks</textual></th></tr><tr class="po-table e653 e653" valign="top"><th align="left" class="po-field e654 e654" valign="top"><textual class="po-textual">node-name</textual></th><th align="left" class="po-field e655 e655" valign="top"><textual class="po-textual">model</textual></th><th align="left" class="po-field e656 e656" valign="top"><textual class="po-textual">children</textual></th></tr></thead><tbody class="po-table e657 e657"><tr class="po-table e658 e658" valign="top"><td class="po-block e659 e659"><textual class="po-textual">name/value pair</textual></td><td class="po-block e660 e660"><textual class="po-textual">see below</textual></td><td class="po-block e661 e661"><textual class="po-textual">see below</textual></td><td class="po-block e662 e662"><textual class="po-textual">see below</textual></td><td class="po-block e663 e663"><textual class="po-textual">
                  </textual><para class="po-block e664 e664"><textual class="po-textual">
                    the JSON value can be any item kind (null, 
                    simple value, object, array);
                  </textual></para><textual class="po-textual">
                  </textual><para class="po-block e665 e665"><textual class="po-textual">
                    all node properties – except 
                    for the [key] – depend on the item kind; 
                  </textual></para><textual class="po-textual">
                  </textual><para class="po-block e666 e666"><textual class="po-textual">
                    the [key] is set to the JSON name 
                  </textual></para><textual class="po-textual">
                </textual></td></tr><tr class="po-table e667 e667" valign="top"><td class="po-block e668 e668"><textual class="po-textual">null</textual></td><td class="po-block e669 e669"><code class="po-atom e670 e670"><textual class="po-textual">udl:null</textual></code></td><td class="po-block e671 e671"><textual class="po-textual">sequence</textual></td><td class="po-block e672 e672"><textual class="po-textual">none</textual></td><td class="po-block e673 e673"><textual class="po-textual">element is nilled</textual></td></tr><tr class="po-table e674 e674" valign="top"><td class="po-block e675 e675"><textual class="po-textual">object</textual></td><td class="po-block e676 e676"><code class="po-atom e677 e677"><textual class="po-textual">udl:map</textual></code></td><td class="po-block e678 e678"><textual class="po-textual">map</textual></td><td class="po-block e679 e679"><textual class="po-textual">elements, one for each name/value</textual></td><td class="po-block e680 e680"><textual class="po-textual">all child elements have a [key]</textual></td></tr><tr class="po-table e681 e681" valign="top"><td class="po-block e682 e682"><textual class="po-textual">array</textual></td><td class="po-block e683 e683"><code class="po-atom e684 e684"><textual class="po-textual">udl:array</textual></code></td><td class="po-block e685 e685"><textual class="po-textual">sequence</textual></td><td class="po-block e686 e686"><textual class="po-textual">elements, one for each member</textual></td><td class="po-block e687 e687"><textual class="po-textual">all child elements without a [key]</textual></td></tr><tr class="po-table e688 e688" valign="top"><td class="po-block e689 e689"><textual class="po-textual">string (non-empty)</textual></td><td class="po-block e690 e690"><code class="po-atom e691 e691"><textual class="po-textual">udl:value</textual></code></td><td class="po-block e692 e692"><textual class="po-textual">sequence</textual></td><td class="po-block e693 e693"><textual class="po-textual">text node</textual></td><td class="po-block e694 e694"><textual class="po-textual">
                  </textual><para class="po-block e695 e695"><textual class="po-textual">
                    [schema-type] is xs:untyped
                  </textual></para><textual class="po-textual">
                </textual></td></tr><tr class="po-table e696 e696" valign="top"><td class="po-block e697 e697"><textual class="po-textual">zero-length string</textual></td><td class="po-block e698 e698"><code class="po-atom e699 e699"><textual class="po-textual">udl:value</textual></code></td><td class="po-block e700 e700"><textual class="po-textual">sequence</textual></td><td class="po-block e701 e701"><textual class="po-textual">none</textual></td><td class="po-block e702 e702"><textual class="po-textual">
                  [schema-type] is xs:untypedAtomic
                </textual></td></tr><tr class="po-table e703 e703" valign="top"><td class="po-block e704 e704"><textual class="po-textual">number</textual></td><td class="po-block e705 e705"><code class="po-atom e706 e706"><textual class="po-textual">udl:value</textual></code></td><td class="po-block e707 e707"><textual class="po-textual">sequence</textual></td><td class="po-block e708 e708"><textual class="po-textual">text node</textual></td><td class="po-block e709 e709"><textual class="po-textual">
                  [schema-type] is one of: xs:integer, xs:decimal, xs:double
                </textual></td></tr><tr class="po-table e710 e710" valign="top"><td class="po-block e711 e711"><textual class="po-textual">true|false</textual></td><td class="po-block e712 e712"><code class="po-atom e713 e713"><textual class="po-textual">udl:value</textual></code></td><td class="po-block e714 e714"><textual class="po-textual">sequence</textual></td><td class="po-block e715 e715"><textual class="po-textual">text node</textual></td><td class="po-block e716 e716"><textual class="po-textual">
                  [schema-type] is xs:boolean
                </textual></td></tr></tbody></table><textual class="po-textual">
        </textual></para></section><section class="po-hcontainer e717 e717" xml:id="serialization"><title class="po-block e718 e718"><textual class="po-textual">
          Serialization
        </textual></title><para class="po-block e719 e719"><textual class="po-textual">
          The translation of UDL nodes into JSON items does not depend on node 
          names; rather, it is wholly determined by the element content 
          (empty / element children / text child) and several properties 
          ([key], [model], [nilled], [schema-type]). The 
          node name is however checked if the serialization parameter 
          </textual><code class="po-atom e720 e720"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is </textual><code class="po-atom e721 e721"><textual class="po-textual">json.strict</textual></code><textual class="po-textual">. 
          In this case, the actual node name is compared with the 
          default node name associated with the given element content 
          and properties, and an unrecoverable error is raised if 
          actual node name and expected node name are not the same.
        </textual></para><para class="po-block e722 e722"><textual class="po-textual">
          See </textual><xref class="po-milestone e723 e723" linkend="serialization-controlling-the-loss-of-information"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> 
          for details about how serialization may accept or reject loss of 
          information, dependent on serialization 
          parameter </textual><code class="po-atom e724 e724"><textual class="po-textual">info-loss</textual></code><textual class="po-textual">.
        </textual></para><para class="po-block e725 e725"><textual class="po-textual">
          </textual><table class="po-container e726 e726"><caption class="po-container e727 e727"><para class="po-block e728 e728"><textual class="po-textual">
                </textual><emphasis class="po-inline e729 e729" role="bold"><emphasis class="po-inline e730 e730" role="ital"><textual class="po-textual">
                  Serialization - translating UDL nodes into JSON items. CT =
                  complex type with complex content; ST = simple type.
                </textual></emphasis></emphasis><textual class="po-textual">
              </textual></para></caption><col align="left" class="po-meta e731 e731" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e732 e732" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e733 e733"><tr class="po-table e734 e734" valign="top"><th align="center" class="po-field e735 e735" colspan="4" valign="top"><textual class="po-textual">node properties</textual></th><th align="center" class="po-field e736 e736" valign="top"><textual class="po-textual">JSON item</textual></th></tr><tr class="po-table e737 e737" valign="top"><th align="left" class="po-field e738 e738" valign="top"><textual class="po-textual">children</textual></th><th align="left" class="po-field e739 e739" valign="top"><textual class="po-textual">model</textual></th><th align="left" class="po-field e740 e740" valign="top"><textual class="po-textual">nilled</textual></th><th align="left" class="po-field e741 e741" valign="top"><textual class="po-textual">schema-type</textual></th><th align="left" class="po-field e742 e742" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></th></tr></thead><tbody class="po-table e743 e743"><tr class="po-table e744 e744" valign="top"><td class="po-block e745 e745"><textual class="po-textual">empty</textual></td><td class="po-block e746 e746"><textual class="po-textual">sequence</textual></td><td class="po-block e747 e747"><textual class="po-textual">false</textual></td><td class="po-block e748 e748"><code class="po-atom e749 e749"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual"> or CT</textual></td><td class="po-block e750 e750"><textual class="po-textual">array (empty)</textual></td></tr><tr class="po-table e751 e751" valign="top"><td class="po-block e752 e752"><textual class="po-textual">empty</textual></td><td class="po-block e753 e753"><textual class="po-textual">sequence</textual></td><td class="po-block e754 e754"><textual class="po-textual">false</textual></td><td class="po-block e755 e755"><code class="po-atom e756 e756"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual"> or ST</textual></td><td class="po-block e757 e757"><textual class="po-textual">string (zero-length)</textual></td></tr><tr class="po-table e758 e758" valign="top"><td class="po-block e759 e759"><textual class="po-textual">empty</textual></td><td class="po-block e760 e760"><textual class="po-textual">map</textual></td><td class="po-block e761 e761"><textual class="po-textual">false</textual></td><td class="po-block e762 e762"><textual class="po-textual">any</textual></td><td class="po-block e763 e763"><textual class="po-textual">object (empty)</textual></td></tr><tr class="po-table e764 e764" valign="top"><td class="po-block e765 e765"><textual class="po-textual">empty</textual></td><td class="po-block e766 e766"><textual class="po-textual">sequence</textual></td><td class="po-block e767 e767"><textual class="po-textual">true</textual></td><td class="po-block e768 e768"><textual class="po-textual">any</textual></td><td class="po-block e769 e769"><textual class="po-textual">null</textual></td></tr><tr class="po-table e770 e770" valign="top"><td class="po-block e771 e771"><textual class="po-textual">element children</textual></td><td class="po-block e772 e772"><textual class="po-textual">sequence</textual></td><td class="po-block e773 e773"><textual class="po-textual">false</textual></td><td class="po-block e774 e774"><textual class="po-textual">any</textual></td><td class="po-block e775 e775"><textual class="po-textual">array</textual></td></tr><tr class="po-table e776 e776" valign="top"><td class="po-block e777 e777"><textual class="po-textual">element children</textual></td><td class="po-block e778 e778"><textual class="po-textual">map</textual></td><td class="po-block e779 e779"><textual class="po-textual">false</textual></td><td class="po-block e780 e780"><textual class="po-textual">any</textual></td><td class="po-block e781 e781"><textual class="po-textual">object</textual></td></tr><tr class="po-table e782 e782" valign="top"><td class="po-block e783 e783"><textual class="po-textual">text node</textual></td><td class="po-block e784 e784"><textual class="po-textual">sequence</textual></td><td class="po-block e785 e785"><textual class="po-textual">false</textual></td><td class="po-block e786 e786"><code class="po-atom e787 e787"><textual class="po-textual">xs:double</textual></code></td><td class="po-block e788 e788"><textual class="po-textual">number</textual></td></tr><tr class="po-table e789 e789" valign="top"><td class="po-block e790 e790"><textual class="po-textual">text node</textual></td><td class="po-block e791 e791"><textual class="po-textual">sequence</textual></td><td class="po-block e792 e792"><textual class="po-textual">false</textual></td><td class="po-block e793 e793"><code class="po-atom e794 e794"><textual class="po-textual">xs:decimal</textual></code></td><td class="po-block e795 e795"><textual class="po-textual">number</textual></td></tr><tr class="po-table e796 e796" valign="top"><td class="po-block e797 e797"><textual class="po-textual">text node</textual></td><td class="po-block e798 e798"><textual class="po-textual">sequence</textual></td><td class="po-block e799 e799"><textual class="po-textual">false</textual></td><td class="po-block e800 e800"><code class="po-atom e801 e801"><textual class="po-textual">xs:integer</textual></code></td><td class="po-block e802 e802"><textual class="po-textual">number</textual></td></tr><tr class="po-table e803 e803" valign="top"><td class="po-block e804 e804"><textual class="po-textual">text node</textual></td><td class="po-block e805 e805"><textual class="po-textual">sequence</textual></td><td class="po-block e806 e806"><textual class="po-textual">false</textual></td><td class="po-block e807 e807"><code class="po-atom e808 e808"><textual class="po-textual">xs:boolean</textual></code></td><td class="po-block e809 e809"><code class="po-atom e810 e810"><textual class="po-textual">true</textual></code><textual class="po-textual">|</textual><code class="po-atom e811 e811"><textual class="po-textual">false</textual></code></td></tr><tr class="po-table e812 e812" valign="top"><td class="po-block e813 e813"><textual class="po-textual">text node</textual></td><td class="po-block e814 e814"><textual class="po-textual">sequence</textual></td><td class="po-block e815 e815"><textual class="po-textual">false</textual></td><td class="po-block e816 e816"><code class="po-atom e817 e817"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual"> or ST</textual></td><td class="po-block e818 e818"><textual class="po-textual">string</textual></td></tr></tbody></table><textual class="po-textual">
        </textual></para></section></section><section class="po-hcontainer e819 e819" xml:id="serialization-controlling-the-loss-of-information"><title class="po-block e820 e820"><textual class="po-textual">
        Serialization: controlling the loss of information
      </textual></title><para class="po-block e821 e821"><textual class="po-textual">
        Serialization of a document to a markup language should 
        preserve all information so that the serialization is a 
        complete representation from which the document may be 
        reconstructed. Such a lossless serialization of a UDL 
        document is always possible for XML markup; it is only 
        in special cases possible for JSON markup. For example, 
        any attributes or non-default element names are lost 
        when serializing to JSON.
      </textual></para><para class="po-block e822 e822"><textual class="po-textual">
        However, it depends on circumstances whether such loss 
        of information renders the serialization result worthless. 
        If, for example, the loss consists of element names only 
        and these names were only introduced in order to facilitate 
        document creation or processing, with an understanding that they will 
        get lost during later processing steps – then a serialization 
        which loses element names might be as valuable as a lossless 
        serialization. Such considerations suggest a refinement of 
        the serialization model: a new serialization parameter might 
        control what losses are acceptable and what losses are not 
        acceptable.
      </textual></para><para class="po-block e823 e823"><textual class="po-textual">
        The proposal of a unified document language includes such a 
        new serialization parameter: 
        </textual><code class="po-atom e824 e824"><textual class="po-textual">info-loss</textual></code><textual class="po-textual">. Presently the parameter 
        is only relevant when serializing to JSON. Three values are 
        defined:
        </textual><itemizedlist class="po-table e825 e825"><listitem class="po-container e826 e826"><para class="po-block e827 e827"><textual class="po-textual">
              </textual><code class="po-atom e828 e828"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> – any information loss causes 
              an unrecoverable error
            </textual></para></listitem><listitem class="po-container e829 e829"><para class="po-block e830 e830"><textual class="po-textual">
              </textual><code class="po-atom e831 e831"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual"> – element names are ignored, 
              but any other information loss causes an unrecoverable 
              error
            </textual></para></listitem><listitem class="po-container e832 e832"><para class="po-block e833 e833"><textual class="po-textual">
              </textual><code class="po-atom e834 e834"><textual class="po-textual">json.projection</textual></code><textual class="po-textual"> – any information that JSON 
              cannot represent is simply ignored
            </textual></para></listitem></itemizedlist><textual class="po-textual">
        In particular, </textual><code class="po-atom e835 e835"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> equal 
        </textual><code class="po-atom e836 e836"><textual class="po-textual">json.projection</textual></code><textual class="po-textual"> means:
        </textual><itemizedlist class="po-table e837 e837"><listitem class="po-container e838 e838"><para class="po-block e839 e839"><textual class="po-textual">
              element names are ignored
            </textual></para></listitem><listitem class="po-container e840 e840"><para class="po-block e841 e841"><textual class="po-textual">
              attributes are ignored
            </textual></para></listitem><listitem class="po-container e842 e842"><para class="po-block e843 e843"><textual class="po-textual">
              text node siblings of element nodes are ignored (that is, mixed content
              is projected onto the element children)
            </textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e844 e844" xml:id="udl-and-xsd"><title class="po-block e845 e845"><textual class="po-textual">
        UDL and XSD
      </textual></title><para class="po-block e846 e846"><textual class="po-textual">
        The proposed extensions of the XML node model amount to 
        the introduction of two new node properties. Obviously, 
        they require also an extension of the XSD language. In 
        particular, constraints concerning the [key] property should 
        be supported. However, such changes are 
        out of scope of this paper.
      </textual></para></section></section><section class="po-hcontainer e847 e847" xml:id="limitations-and-future-research"><title class="po-block e848 e848"><textual class="po-textual">
      Limitations and future research
    </textual></title><para class="po-block e849 e849"><textual class="po-textual">
      UDL defines the information content of JSON text in terms 
      of a node tree and provides the rules for translating between 
      text and tree, that is, parsing and serialization. This makes 
      JSON data accessible to / producible by XML processing technologies, 
      but there are also important use cases which are not addressed: 
      </textual><orderedlist class="po-table e850 e850"><listitem class="po-container e851 e851"><para class="po-block e852 e852"><textual class="po-textual">
            given a JSON document, a well-readable XML representation 
            is required
          </textual></para></listitem><listitem class="po-container e853 e853"><para class="po-block e854 e854"><textual class="po-textual">
            given an arbitrary XML document, a JSON representation is 
            required
          </textual></para></listitem><listitem class="po-container e855 e855"><para class="po-block e856 e856"><textual class="po-textual">
            round-tripping XML - JSON - XML
          </textual></para></listitem></orderedlist><textual class="po-textual">
      As will be shown below, these are operations which require 
      some change of information content in the formal sense (in terms of 
      nodes and properties), necessary to create a “semantic” equivalence. 
      Such a change of information content cannot be achieved based on 
      parsing/serialization alone. This section explores the basic limitation 
      and makes a suggestion how an extension of the current UDL proposal 
      might look.
    </textual></para><section class="po-hcontainer e857 e857" xml:id="mapping-arbitrary-xml-to-json"><title class="po-block e858 e858"><textual class="po-textual">
        Issue: mapping arbitrary XML to JSON
      </textual></title><para class="po-block e859 e859"><textual class="po-textual">
        A serialization of arbitrary XML documents to JSON is usually 
        not possible without a loss of information, as JSON cannot 
        natively express element names, the distinction between 
        attributes and elements, mixed content and the occurrence 
        of siblings with the same name. This does not mean that JSON 
        could not be used to represent the complete information content 
        of an arbitrary XML document. This representation would however 
        not be a serialization of the XML document tree to JSON, but 
        the (serialized) result of a 
        </textual><emphasis class="po-inline e860 e860" role="ital"><textual class="po-textual">transformation</textual></emphasis><textual class="po-textual">, 
        a different node tree, adhering to a specific format which 
        is designed to capture the content of arbitrary XML 
        documents (e.g. [</textual><xref class="po-milestone e861 e861" linkend="JSONML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] ). 
        The equivalence between the 
        resulting JSON (or the node tree it represents) and 
        the original XML document is not based on the data model, 
        but established on the level of a specific mapping 
        application (as a set of rules). 
      </textual></para></section><section class="po-hcontainer e862 e862" xml:id="mapping-json-to-readable-xml"><title class="po-block e863 e863"><textual class="po-textual">
        Issue: mapping JSON to readable XML
      </textual></title><para class="po-block e864 e864"><textual class="po-textual">
        A similar problem concerns the translation of JSON documents 
        into readable XML documents: the documents created by parsing 
        JSON as defined by UDL are well-suited for processing (e.g. 
        per XPath, XQuery, XSLT), but when serialized into XML text 
        look hardly readable. The practical need to obtain a well 
        readable XML representation of a given JSON document, however, 
        cannot be denied. (Think, for example, of a web service which 
        may at user option deliver XML or JSON results). Again, it is 
        a transformation from one tree to a different tree what is 
        required, as opposed to serializations into alternative 
        formats. 
      </textual></para></section><section class="po-hcontainer e865 e865" xml:id="round-tripping-xml-json-xml"><title class="po-block e866 e866"><textual class="po-textual">
        Issue: Round-tripping XML - JSON - XML
      </textual></title><para class="po-block e867 e867"><textual class="po-textual">
        The impossibility of serializing arbitrary XML to JSON 
        of course implies that round-tripping XML-JSON-XML is 
        not generally possible solely based on serialization and parsing.
      </textual></para></section><section class="po-hcontainer e868 e868" xml:id="integration-of-standardized-mappings"><title class="po-block e869 e869"><textual class="po-textual">
        Conceivable extension of UDL: integration of standardized mappings
      </textual></title><para class="po-block e870 e870"><textual class="po-textual">
        Given the scope of UDL’s main goal – a unified document 
        language supporting multiple markup languages – it may be questioned 
        if the UDL concept is complete if not addressing fundamental 
        mapping tasks, too. A conceivable extension of UDL might 
        include two parts: (a) the definition of 
        </textual><emphasis class="po-inline e871 e871" role="ital"><textual class="po-textual">mappings</textual></emphasis><textual class="po-textual">, which 
        are standardized transformations (XML to JSON, lossless; 
        JSON to readable XML; (b) the integration of these mappings 
        with parsing / serialization into new “first-class” operations, 
        “</textual><emphasis class="po-inline e872 e872" role="ital"><textual class="po-textual">mparse</textual></emphasis><textual class="po-textual">” (parse &amp; map) and 
        “</textual><emphasis class="po-inline e873 e873" role="ital"><textual class="po-textual">mserialize</textual></emphasis><textual class="po-textual">” (map &amp; serialize). 
        The appendix contains a first step in this direction 
        [</textual><xref class="po-milestone e874 e874" linkend="appendix-b"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
        which is, however, limited to the use case of JSON documents 
        in which all names are NCNames. Another limitation is that it 
        does not yet support attributes in the mapping result, which 
        probably cannot be the last say.  
      </textual></para><para class="po-block e875 e875"><textual class="po-textual">
        The mapping between XML and JSON is a question to which 
        already many answers have been given (e.g. 
        [</textual><xref class="po-milestone e876 e876" linkend="LEE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
        [</textual><xref class="po-milestone e877 e877" linkend="PEMBERTON"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
        [</textual><xref class="po-milestone e878 e878" linkend="COUTHURES"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
        [</textual><xref class="po-milestone e879 e879" linkend="JSONML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
        [</textual><xref class="po-milestone e880 e880" linkend="BASEX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]). 
        The diversity is mainly due to differences between the 
        exact goals which the solutions pursue (concerning mapping 
        direction, losslessness, readability, configurability, …). 
        It is unclear if the suggested extension of UDL, which 
        involves standardized mappings between XML and JSON, is a 
        realistic task. But it is not hopeless, neither. First, the 
        unified node model provides a conceptual base which other 
        mapping approaches did not have. Second, the goals can be 
        defined precisely, which greatly removes competition between 
        existent solutions and a new standard. And finally, the 
        use of other, non-standard mappings would always remain 
        possible.
      </textual></para></section></section><section class="po-hcontainer e881 e881" xml:id="alternatives-to-udl"><title class="po-block e882 e882"><textual class="po-textual">
      Alternatives to UDL
    </textual></title><para class="po-block e883 e883"><textual class="po-textual">
      How to process XML and JSON data in a unified way? The approach taken 
      by UDL should be compared with published alternatives. These fall 
      into two categories.
      </textual><itemizedlist class="po-table e884 e884"><listitem class="po-container e885 e885"><para class="po-block e886 e886"><textual class="po-textual">
            mapping approach – map JSON data to an XML representation and 
            process the latter
          </textual></para></listitem><listitem class="po-container e887 e887"><para class="po-block e888 e888"><textual class="po-textual">
            XDM extension – extend the XDM by new item types which can 
            represent JSON data
          </textual></para></listitem></itemizedlist><textual class="po-textual">
      The second category contains two variants:
      </textual><itemizedlist class="po-table e889 e889"><listitem class="po-container e890 e890"><para class="po-block e891 e891"><textual class="po-textual">
            extend the XDM by JSON-specific item types (JSONiq)
          </textual></para></listitem><listitem class="po-container e892 e892"><para class="po-block e893 e893"><textual class="po-textual">
            extend the XDM by generic item types (W3C XSL Working Group proposal)
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e894 e894"><textual class="po-textual">
      The next three sections attempt to clarify the relationships between 
      these approaches and UDL.
    </textual></para><section class="po-hcontainer e895 e895" xml:id="the-mapping-approach"><title class="po-block e896 e896"><textual class="po-textual">
      The mapping approach
    </textual></title><para class="po-block e897 e897"><textual class="po-textual">
      The mapping approach (e.g. </textual><xref class="po-milestone e898 e898" linkend="BASEX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e899 e899" linkend="PEMBERTON"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) 
      is based on an XML 
      representation of JSON data. It uses a simple processing model:
      </textual><itemizedlist class="po-table e900 e900"><listitem class="po-container e901 e901"><para class="po-block e902 e902"><textual class="po-textual">
            preprocessing: JSON =&gt; XML
          </textual></para></listitem><listitem class="po-container e903 e903"><para class="po-block e904 e904"><textual class="po-textual">
            processing: applied to XML data
          </textual></para></listitem><listitem class="po-container e905 e905"><para class="po-block e906 e906"><textual class="po-textual">
            optional postprocessing: serialization (possibly to JSON)
          </textual></para></listitem></itemizedlist><textual class="po-textual">

      This is a clean solution, provided the XML representation preserves all 
      information contained in the JSON data, and the mapping rule can be 
      applied bidirectionally without loss of information. To define such a 
      mapping is not very difficult, as one can use reserved element names and 
      introduce helper attributes in order to exclude any information loss 
      (see </textual><xref class="po-milestone e907 e907" linkend="table-mapping-approach-reserved-names"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> for examples).       

      </textual><table class="po-container e908 e908" xml:id="table-mapping-approach-reserved-names"><caption class="po-container e909 e909"><para class="po-block e910 e910"><textual class="po-textual">
            </textual><emphasis class="po-inline e911 e911" role="bold"><emphasis class="po-inline e912 e912" role="ital"><textual class="po-textual">
              The use of reserved element names and 
              helper attributes 
              to assist in the
              mapping of JSON to/from XML (examples).
            </textual></emphasis></emphasis><textual class="po-textual">
          </textual></para></caption><col align="left" class="po-meta e913 e913" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e914 e914" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e915 e915"><tr class="po-table e916 e916" valign="top"><th align="left" class="po-field e917 e917" valign="top"><textual class="po-textual">source</textual></th><th align="left" class="po-field e918 e918" valign="top"><textual class="po-textual">elements</textual></th><th align="left" class="po-field e919 e919" valign="top"><textual class="po-textual">attributes</textual></th></tr></thead><tbody class="po-table e920 e920"><tr class="po-table e921 e921" valign="top"><td class="po-block e922 e922"><xref class="po-milestone e923 e923" linkend="BASEX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></td><td class="po-block e924 e924"><code class="po-atom e925 e925"><textual class="po-textual">json, value</textual></code></td><td class="po-block e926 e926"><code class="po-atom e927 e927"><textual class="po-textual">arrays, booleans, nulls, numbers, objects, type </textual></code></td></tr><tr class="po-table e928 e928" valign="top"><td class="po-block e929 e929"><xref class="po-milestone e930 e930" linkend="COUTHURES"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></td><td class="po-block e931 e931"><code class="po-atom e932 e932"><textual class="po-textual">exml:anonymous</textual></code></td><td class="po-block e933 e933"><code class="po-atom e934 e934"><textual class="po-textual">exml:fullname, exml:maxOccurs</textual></code></td></tr><tr class="po-table e935 e935" valign="top"><td class="po-block e936 e936"><xref class="po-milestone e937 e937" linkend="HUNTER"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></td><td class="po-block e938 e938"><code class="po-atom e939 e939"><textual class="po-textual">json, item</textual></code></td><td class="po-block e940 e940"><code class="po-atom e941 e941"><textual class="po-textual">boolean, type</textual></code></td></tr><tr class="po-table e942 e942" valign="top"><td class="po-block e943 e943"><xref class="po-milestone e944 e944" linkend="PEMBERTON"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></td><td class="po-block e945 e945"><code class="po-atom e946 e946"><textual class="po-textual">json</textual></code></td><td class="po-block e947 e947"><code class="po-atom e948 e948"><textual class="po-textual">name, starts, type</textual></code></td></tr></tbody></table><textual class="po-textual">
        Outwardly, UDL looks similar to such a 
        mapping-for-the-sake-of-processing; it is tempting to 
        classify it as yet another mapping variant. But that would 
        be a mistake. Mapping approaches treat the problem as an 
        XML </textual><emphasis class="po-inline e949 e949" role="ital"><textual class="po-textual">application</textual></emphasis><textual class="po-textual">: 
        introduce a specific XML dialect designed to achieve a particular
        goal. Like any application, 
        these approaches are free to require the use 
        of application-specific element names and 
        the addition of attributes with application-specific semantics,
        to be evaluated by application code. The 
        </textual><code class="po-atom e950 e950"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute, for example, used in 
        [</textual><xref class="po-milestone e951 e951" linkend="BASEX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is a helper attribute which clearly 
        duplicates 
        </textual><code class="po-atom e952 e952"><textual class="po-textual">xsi:type</textual></code><textual class="po-textual"> 
        for certain values, yet nevertheless
        had to be introduced as additional attribute, because 
        the value range includes values 
        </textual><code class="po-atom e953 e953"><textual class="po-textual">array</textual></code><textual class="po-textual"> and </textual><code class="po-atom e954 e954"><textual class="po-textual">object</textual></code><textual class="po-textual">
        with ad hoc semantics dictated by the mapping 
        task. Such attributes reveal the fact that the
        current XML node model does not support a bidirectional
        mapping into JSON markup. To enable such a mapping,
        the node tree must contain special items with
        serialization semantics.
        This is at odds with the basic principle of serialization
        being a process solely controlled by serialization
        parameters, without a need to interfere with
        the information content of the node tree.
    </textual></para><para class="po-block e955 e955"><textual class="po-textual">
      UDL does not </textual><emphasis class="po-inline e956 e956" role="ital"><textual class="po-textual">map</textual></emphasis><textual class="po-textual">
      XML nodes to JSON structures.
      It redefines JSON to </textual><emphasis class="po-inline e957 e957" role="ital"><textual class="po-textual">be</textual></emphasis><textual class="po-textual">
      a representation of nodes. As a consequence, it need not
      "inject" any ad hoc items into the data tree for
      the sake of controlling a serialization to JSON.
      None of the reserved element and attribute names in
      </textual><xref class="po-milestone e958 e958" linkend="table-reserved-names"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
      have anything to do with JSON or serialization.
      Rather, they represent standard names without semantics,
      reflect node properties
      or signal the markup language currently used
      within a well-defined scope.
      The extended node model 
      is expressive enough to represent JSON structures 
      natively. 
    </textual></para><para class="po-block e959 e959"><textual class="po-textual">
      The main difference between UDL and mapping 
      approaches concerns the handling of JSON names. Mapping 
      approaches represent JSON names as element names if possible, 
      and if not, resort to one of two possible solutions: either 
      place the JSON name in an additional attribute (e.g. 
      </textual><xref class="po-milestone e960 e960" linkend="PEMBERTON"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), or define a bidirectional 
      name mapping 
      (e.g. </textual><xref class="po-milestone e961 e961" linkend="BASEX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">). 
      But there are three differences between 
      the concepts of JSON names and XML names:
      </textual><itemizedlist class="po-table e962 e962"><listitem class="po-container e963 e963"><para class="po-block e964 e964"><textual class="po-textual">
            a JSON name has no namespace component
          </textual></para></listitem><listitem class="po-container e965 e965"><para class="po-block e966 e966"><textual class="po-textual">
            a JSON name can use arbitrary characters
          </textual></para></listitem><listitem class="po-container e967 e967"><para class="po-block e968 e968"><textual class="po-textual">
            a JSON name must be unique amongst the JSON names of all 
            siblings
          </textual></para></listitem></itemizedlist><textual class="po-textual">
      Note that the last point (the uniqueness 
      constraint) means that a JSON name resembles an 
      </textual><code class="po-atom e969 e969"><textual class="po-textual">xml:id</textual></code><textual class="po-textual"> attribute more than an element name.
      It can be compared to a locally scoped 
      </textual><code class="po-atom e970 e970"><textual class="po-textual">xml:id</textual></code><textual class="po-textual"> attribute (uniqueness among all element 
      children of an element). 
      For these reasons UDL distinguishes
      the concepts of names and keys. It thus enables
      native relationships between nodes and
      XML markup on the one hand and JSON markup on
      the other hand. As a result it becomes possible
      to regard JSON markup and XML markup as alternative
      representations of an information content
      which is defined in terms of nodes and their
      properties.
      Remembering Plato, 
      one kind of “thing” is inferred from - or may cast -
      two different "shadows".
    </textual></para><para class="po-block e971 e971"><textual class="po-textual">
      Should we not keep things simple - do we 
      </textual><emphasis class="po-inline e972 e972" role="ital"><textual class="po-textual">need</textual></emphasis><textual class="po-textual"> to 
      extend the document model and introduce new node properties? Imagine this alternative:
      </textual><itemizedlist class="po-table e973 e973"><listitem class="po-container e974 e974"><para class="po-block e975 e975"><textual class="po-textual">
            the W3C publishes a small specification defining a standardized bi-directional 
            mapping between arbitrary strings and QNames
          </textual></para></listitem><listitem class="po-container e976 e976"><para class="po-block e977 e977"><textual class="po-textual">
            the XPath language syntax is slightly extended, introducing a second 
            notation of a name test (e.g. </textual><code class="po-atom e978 e978"><textual class="po-textual">#foo</textual></code><textual class="po-textual">)
            which is interpreted as a string which is 
            </textual><emphasis class="po-inline e979 e979" role="ital"><textual class="po-textual">automatically mapped</textual></emphasis><textual class="po-textual"> 
            to a QName according to the standard name mapping:
            </textual><programlisting class="po-block e980 e980" xml:space="preserve"><textual class="po-textual">
   a/b/#c       equivalent to:   a/b/c
   a/b/#c_d     equivalent to:   a/b/c__D
   a/b/#1       equivalent to:   a/b/_1
   a/b/#”1 2”   equivalent to:   a/b/_1_00322	   
</textual></programlisting><textual class="po-textual">
          </textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e981 e981"><textual class="po-textual">
      This is an attractive scenario: one can formulate the XPath expressions 
      without a mental translation, just using the names one 
      </textual><emphasis class="po-inline e982 e982" role="ital"><textual class="po-textual">sees</textual></emphasis><textual class="po-textual"> in the source data. The net 
      result is an elegant approach 
      to the processing of JSON data with XML tools. 
    </textual></para><para class="po-block e983 e983"><textual class="po-textual">
      The approach would be a good – and perhaps 
      a better – alternative to UDL if the processing of JSON documents
      with XML tools were the only goal. However, UDL's design
      aims at a unified document model which expresses the entities
      represented by dominant markup languages in
      a native way. Only this way can information content and
      representation (markup) be decoupled and can the latter
      be switched easily at various scales (whole documents, sections
      or single elements) and in various contexts (data and
      program code).
    </textual></para></section><section class="po-hcontainer e984 e984" xml:id="jsoniq"><title class="po-block e985 e985"><textual class="po-textual">
      JSONiq
    </textual></title><para class="po-block e986 e986"><textual class="po-textual">
      JSONiq 
      [</textual><xref class="po-milestone e987 e987" linkend="JSONIQ"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
      [</textual><xref class="po-milestone e988 e988" linkend="JSONIQSPEC"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is an extension of the XQuery 
      language designed to add support for JSON data. Like UDL, 
      JSONiq extends the XDM in order to accommodate JSON structures. 
      However, JSONiq does not change the node sub model of the XDM. 
      Rather, two new item types are introduced, designed to represent 
      JSON data:
      </textual><itemizedlist class="po-table e989 e989"><listitem class="po-container e990 e990"><para class="po-block e991 e991"><textual class="po-textual">object</textual></para></listitem><listitem class="po-container e992 e992"><para class="po-block e993 e993"><textual class="po-textual">array</textual></para></listitem></itemizedlist><textual class="po-textual">      
    </textual></para><para class="po-block e994 e994"><textual class="po-textual">
      It is interesting to note the parallel: both, JSONiq and 
      UDL extend the XDM in order to accommodate JSON data; but 
      the changes UDL proposes are 
      </textual><emphasis class="po-inline e995 e995" role="ital"><textual class="po-textual">within</textual></emphasis><textual class="po-textual"> the node sub model, 
      whereas JSONiq adds a second sub model for structured data,
      in parallel to the node model. Using the terms proposed in 
      </textual><xref class="po-milestone e996 e996" linkend="distinction-between-markup-and-document-language"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">:
      JSONiq keeps the XML 
      document language, but extends the XML information language, 
      whereas UDL shifts the changes into the very document language, 
      refraining from changes outside of the node model.
    </textual></para><para class="po-block e997 e997"><textual class="po-textual">
      An advantage UDL offers is to represent JSON data as node 
      trees and thus expose them to XPath navigation. JSONiq, 
      on the other hand, might be easier to accept exactly because 
      it does not introduce any change to the document language 
      and therefore restricts itself to the extension of a query 
      language, rather than an extension of XML.
    </textual></para></section><section class="po-hcontainer e998 e998" xml:id="map-items"><title class="po-block e999 e999"><textual class="po-textual">
      Map items
    </textual></title><para class="po-block e1000 e1000"><textual class="po-textual">
      The W3C XSL Working Group has made a proposal for extending
      the XDM by a new item type: map items
      [</textual><xref class="po-milestone e1001 e1001" linkend="W3C-XSLT-3.0"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. They represent 
      generic containers, but nevertheless can represent
      JSON data. One should note the
      relationship between JSONiq and the map proposal:
      both approaches mandate new item types which 
      are not nodes and yet can represent structured
      data; but one (JSONiq) resorts to JSON-specific
      items, whereas the other advocates
      generic containers.
    </textual></para><para class="po-block e1002 e1002"><textual class="po-textual">
      Not being nodes, map items
      are lightweight containers which can collect
      items without requiring or imposing a structural relationship.
      Therefore node relationships between container and members 
      are not possible. This contrasts sharply with the UDL approach 
      which models JSON containers and their members as nodes and
      their child nodes. Only this way can JSON data be seamlessly 
      integrated into the navigational system based on axes and 
      node tests.
    </textual></para><para class="po-block e1003 e1003"><textual class="po-textual">
      This is not to say that such lightweight containers 
      would not be very useful extensions of XDM. Lightweight 
      containers and nodes cannot replace each other. 
      A node model is required for the navigational power of XPath. 
      Lightweight containers are required to model node relationships 
      independently from their structural relationship. And among 
      other benefits they enable a mapping of keys to node references, 
      rather than the nodes themselves, which is a highly desirable
      feature.
    </textual></para><para class="po-block e1004 e1004"><textual class="po-textual">
      It is interesting to note a conceptual relationship between
      UDL and the "map proposal": the content of an element with
      [model] equal "map" can be described as a map item
      constrained in the following way: 
      (a) every map value is a child element; (b) every map key
      is the [key] of the associated value.
    </textual></para></section></section><section class="po-hcontainer e1005 e1005" xml:id="discussion"><title class="po-block e1006 e1006"><textual class="po-textual">
      Discussion
    </textual></title><para class="po-block e1007 e1007"><textual class="po-textual">
      There is a growing awareness in the XML community that other
      markup languages do, will and should coexist with XML.
      So integration is a crucial task. Being determined
      to integrate, one may look at XML - as well as other
      markup languages - as both: markup, and information
      content represented by markup.
    </textual></para><para class="po-block e1008 e1008"><textual class="po-textual">
      We happen to be in the possession of a rigorous, formal
      definition of the information content of XML data. 
      If this model is only approximately, but not quite
      capable of expressing what new markup languages
      have to say (compare 
      </textual><xref class="po-milestone e1009 e1009" linkend="the-mapping-approach"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">),
      this may reflect the circumstances
      when those formal definitions 
      were set down: a point in time when XML 
      structure was the only thing that had to be expressed. 
      But </textual><emphasis class="po-inline e1010 e1010" role="ital"><textual class="po-textual">now</textual></emphasis><textual class="po-textual"> 
      it seems a natural course
      to consider extending the model cautiously,
      turning it into a unified document language. When
      infoset and XDM became recommendations, there was nothing to unify,
      now there is.       
    </textual></para><para class="po-block e1011 e1011"><textual class="po-textual">
      UDL might change our perception of markup languages:
      they are freely exchangeable 
      in various contexts -
      both in data resources and in program code 
      (within XQuery and XSLT constructors) - 
      and at various scales -
      whole document, document section, single element.
      This becomes possible when different
      markup is seen as alternative representation
      of unified content.
    </textual></para><para class="po-block e1012 e1012"><textual class="po-textual">
       An evaluation of the UDL proposal may profit from making
       two distinctions. The first distinction is between UDL's 
       central idea and its translation into technical details.
       The idea is to relate multiple markup languages to a single, 
       unified node model, which turns XML processing 
       technologies into general information processing 
       technologies. For this purpose, the node model was
       extended in a particular way (e.g. adding a new node
       property, [key]). Doubtless,
       other approaches how to extend the node model are conceivable,
       too. An evaluation of the UDL proposal might modify
       or even replace the model extensions by alternatives,
       preserving the central idea as such.
    </textual></para><para class="po-block e1013 e1013"><textual class="po-textual">
      The second distinction is between what UDL does achieve and
      what is deliberately left to a future extension (or to
      complementary components). UDL does not yet
      offer support for certain transformations ("mappings")
      which are acknowledged to be important in the context of markup
      integration. In other words: the existence of
      a unified document language does not yet mean
      comprehensive support for all use cases in the context
      of integrating multiple markup languages.
      An evaluation of the UDL proposal 
      should regard the unified document language as 
      a </textual><emphasis class="po-inline e1014 e1014" role="ital"><textual class="po-textual">foundation</textual></emphasis><textual class="po-textual"> for
      mapping support - not as a substitute.
    </textual></para></section><section class="po-hcontainer e1015 e1015"><title class="po-block e1016 e1016"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e1017 e1017"><textual class="po-textual">
      Cordial thanks to David A. Lee who read an earlier version of this paper 
      and gave me most valuable feedback. Without David's criticism
      I would not have realized that a further elaboration 
      of the basic concept was necessary. 
    </textual></para></section><appendix class="po-hcontainer e1018 e1018" xml:id="appendix-a"><title class="po-block e1019 e1019"><textual class="po-textual">Deserializing from / serializing to JSON</textual></title><para class="po-block e1020 e1020"><textual class="po-textual">
      This appendix contains the precise rules how to deserialize 
      a JSON document to a tree of nodes and how to serialize a 
      tree of nodes to a JSON document.
    </textual></para><section class="po-hcontainer e1021 e1021" xml:id="appendix-deserialization"><title class="po-block e1022 e1022"><textual class="po-textual">
        Deserialization
      </textual></title><para class="po-block e1023 e1023"><textual class="po-textual">
        </textual><informaltable class="po-container e1024 e1024"><tr class="po-table e1025 e1025" valign="top"><td class="po-block e1026 e1026"><emphasis class="po-inline e1027 e1027" role="bold"><textual class="po-textual">JSON null</textual></emphasis><textual class="po-textual"> =&gt; node</textual></td></tr><tr class="po-table e1028 e1028" valign="top"><th align="left" class="po-field e1029 e1029"><textual class="po-textual">property</textual></th><th align="left" class="po-field e1030 e1030"><textual class="po-textual">value</textual></th></tr><tr class="po-table e1031 e1031" valign="top"><td class="po-block e1032 e1032"><textual class="po-textual">name</textual></td><td class="po-block e1033 e1033"><code class="po-atom e1034 e1034"><textual class="po-textual">udl:null</textual></code></td></tr><tr class="po-table e1035 e1035" valign="top"><td class="po-block e1036 e1036"><textual class="po-textual">key</textual></td><td class="po-block e1037 e1037"><textual class="po-textual">                  
                if the null is the value of a name/value pair – 
                the name; empty, otherwise
              </textual></td></tr><tr class="po-table e1038 e1038" valign="top"><td class="po-block e1039 e1039"><textual class="po-textual">model</textual></td><td class="po-block e1040 e1040"><textual class="po-textual">sequence</textual></td></tr><tr class="po-table e1041 e1041" valign="top"><td class="po-block e1042 e1042"><textual class="po-textual">nilled</textual></td><td class="po-block e1043 e1043"><textual class="po-textual">true</textual></td></tr><tr class="po-table e1044 e1044" valign="top"><td class="po-block e1045 e1045"><textual class="po-textual">schema type</textual></td><td class="po-block e1046 e1046"><code class="po-atom e1047 e1047"><textual class="po-textual">xs:untyped</textual></code></td></tr></informaltable><textual class="po-textual">

        </textual><informaltable class="po-container e1048 e1048"><tr class="po-table e1049 e1049" valign="top"><td class="po-block e1050 e1050"><emphasis class="po-inline e1051 e1051" role="bold"><textual class="po-textual">JSON object</textual></emphasis><textual class="po-textual"> =&gt; node</textual></td></tr><tr class="po-table e1052 e1052" valign="top"><th align="left" class="po-field e1053 e1053"><textual class="po-textual">property</textual></th><th align="left" class="po-field e1054 e1054"><textual class="po-textual">value</textual></th></tr><tr class="po-table e1055 e1055" valign="top"><td class="po-block e1056 e1056"><textual class="po-textual">name</textual></td><td class="po-block e1057 e1057"><code class="po-atom e1058 e1058"><textual class="po-textual">udl:map</textual></code></td></tr><tr class="po-table e1059 e1059" valign="top"><td class="po-block e1060 e1060"><textual class="po-textual">key</textual></td><td class="po-block e1061 e1061"><textual class="po-textual">                  
                if the object is the value of a name/value pair – 
                the name; empty, otherwise
              </textual></td></tr><tr class="po-table e1062 e1062" valign="top"><td class="po-block e1063 e1063"><textual class="po-textual">model</textual></td><td class="po-block e1064 e1064"><textual class="po-textual">map</textual></td></tr><tr class="po-table e1065 e1065" valign="top"><td class="po-block e1066 e1066"><textual class="po-textual">content</textual></td><td class="po-block e1067 e1067"><textual class="po-textual">
                the collection of element nodes created by deserializing the 
                name/value pairs
              </textual></td></tr><tr class="po-table e1068 e1068" valign="top"><td class="po-block e1069 e1069"><textual class="po-textual">schema type</textual></td><td class="po-block e1070 e1070"><code class="po-atom e1071 e1071"><textual class="po-textual">xs:untyped</textual></code></td></tr></informaltable><textual class="po-textual">

        </textual><informaltable class="po-container e1072 e1072"><tr class="po-table e1073 e1073" valign="top"><td class="po-block e1074 e1074"><emphasis class="po-inline e1075 e1075" role="bold"><textual class="po-textual">JSON array</textual></emphasis><textual class="po-textual"> =&gt; node</textual></td></tr><tr class="po-table e1076 e1076" valign="top"><th align="left" class="po-field e1077 e1077"><textual class="po-textual">property</textual></th><th align="left" class="po-field e1078 e1078"><textual class="po-textual">value</textual></th></tr><tr class="po-table e1079 e1079" valign="top"><td class="po-block e1080 e1080"><textual class="po-textual">name</textual></td><td class="po-block e1081 e1081"><code class="po-atom e1082 e1082"><textual class="po-textual">udl:array</textual></code></td></tr><tr class="po-table e1083 e1083" valign="top"><td class="po-block e1084 e1084"><textual class="po-textual">key</textual></td><td class="po-block e1085 e1085"><textual class="po-textual">                  
                if the array is the value of a name/value pair – 
                the name; empty, otherwise
              </textual></td></tr><tr class="po-table e1086 e1086" valign="top"><td class="po-block e1087 e1087"><textual class="po-textual">model</textual></td><td class="po-block e1088 e1088"><textual class="po-textual">sequence</textual></td></tr><tr class="po-table e1089 e1089" valign="top"><td class="po-block e1090 e1090"><textual class="po-textual">content</textual></td><td class="po-block e1091 e1091"><textual class="po-textual">
                the collection of element nodes created by deserializing the 
                array members
              </textual></td></tr><tr class="po-table e1092 e1092" valign="top"><td class="po-block e1093 e1093"><textual class="po-textual">schema type</textual></td><td class="po-block e1094 e1094"><code class="po-atom e1095 e1095"><textual class="po-textual">xs:untyped</textual></code></td></tr></informaltable><textual class="po-textual">

        </textual><informaltable class="po-container e1096 e1096"><tr class="po-table e1097 e1097" valign="top"><td class="po-block e1098 e1098"><emphasis class="po-inline e1099 e1099" role="bold"><textual class="po-textual">JSON simple value</textual></emphasis><textual class="po-textual"> =&gt; node</textual></td></tr><tr class="po-table e1100 e1100" valign="top"><th align="left" class="po-field e1101 e1101"><textual class="po-textual">property</textual></th><th align="left" class="po-field e1102 e1102"><textual class="po-textual">value</textual></th></tr><tr class="po-table e1103 e1103" valign="top"><td class="po-block e1104 e1104"><textual class="po-textual">name</textual></td><td class="po-block e1105 e1105"><code class="po-atom e1106 e1106"><textual class="po-textual">udl:value</textual></code></td></tr><tr class="po-table e1107 e1107" valign="top"><td class="po-block e1108 e1108"><textual class="po-textual">key</textual></td><td class="po-block e1109 e1109"><textual class="po-textual">                  
                if the value is part of a name/value pair – 
                the name; empty, otherwise
              </textual></td></tr><tr class="po-table e1110 e1110" valign="top"><td class="po-block e1111 e1111"><textual class="po-textual">model</textual></td><td class="po-block e1112 e1112"><textual class="po-textual">sequence</textual></td></tr><tr class="po-table e1113 e1113" valign="top"><td class="po-block e1114 e1114"><textual class="po-textual">content</textual></td><td class="po-block e1115 e1115"><textual class="po-textual">
                if the value is not a zero-length string: a text node 
                containing the text representation of the value; 
                empty content, otherwise
              </textual></td></tr><tr class="po-table e1116 e1116" valign="top"><td class="po-block e1117 e1117"><textual class="po-textual">schema type</textual></td><td class="po-block e1118 e1118"><textual class="po-textual">
                    </textual><itemizedlist class="po-table e1119 e1119"><listitem class="po-container e1120 e1120"><para class="po-block e1121 e1121"><textual class="po-textual">
                          if the JSON value is a number: 
                          </textual><code class="po-atom e1122 e1122"><textual class="po-textual">xs:integer/xs:decimal/xs:double</textual></code><textual class="po-textual"> –
                          depending on the lexical form 
                        </textual></para></listitem><listitem class="po-container e1123 e1123"><para class="po-block e1124 e1124"><textual class="po-textual">
                          if the JSON value is one of the constants 
                          </textual><code class="po-atom e1125 e1125"><textual class="po-textual">true</textual></code><textual class="po-textual"> or </textual><code class="po-atom e1126 e1126"><textual class="po-textual">false</textual></code><textual class="po-textual">: 
                          </textual><code class="po-atom e1127 e1127"><textual class="po-textual">xs:boolean</textual></code><textual class="po-textual">
                        </textual></para></listitem><listitem class="po-container e1128 e1128"><para class="po-block e1129 e1129"><textual class="po-textual">
                          if the JSON value is a zero-length string: 
                          </textual><code class="po-atom e1130 e1130"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">
                        </textual></para></listitem><listitem class="po-container e1131 e1131"><para class="po-block e1132 e1132"><textual class="po-textual">
                          otherwise: </textual><code class="po-atom e1133 e1133"><textual class="po-textual">xs:untyped</textual></code><textual class="po-textual">
                        </textual></para></listitem></itemizedlist><textual class="po-textual">
              </textual></td></tr></informaltable><textual class="po-textual">
      </textual></para><para class="po-block e1134 e1134"><textual class="po-textual">
          Note: The XML representation of a zero-length JSON string 
          is an empty element with type annotation 
          </textual><code class="po-atom e1135 e1135"><textual class="po-textual">xs:untypedAtomic</textual></code><textual class="po-textual">. The type annotation
          makes the node distinguishable from empty elements
          corresponding to empty arrays or objects.
      </textual></para></section><section class="po-hcontainer e1136 e1136" xml:id="appendix-serialization"><title class="po-block e1137 e1137"><textual class="po-textual">
        Serialization
      </textual></title><para class="po-block e1138 e1138"><textual class="po-textual">
        </textual><emphasis class="po-inline e1139 e1139" role="bold"><emphasis class="po-inline e1140 e1140" role="ital"><textual class="po-textual">
          Handling attributes
        </textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e1141 e1141"><textual class="po-textual">
        If attributes are encountered, the behaviour depends on the 
        serialization parameter
        </textual><code class="po-atom e1142 e1142"><textual class="po-textual">info-loss</textual></code><textual class="po-textual">: if the value is 
        </textual><code class="po-atom e1143 e1143"><textual class="po-textual">json.projection</textual></code><textual class="po-textual">, the attributes are
        ignored; otherwise, a non-recoverable error is raised.
      </textual></para><para class="po-block e1144 e1144"><textual class="po-textual">
        </textual><emphasis class="po-inline e1145 e1145" role="bold"><emphasis class="po-inline e1146 e1146" role="ital"><textual class="po-textual">
          Handling of processing instructions and comments
        </textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e1147 e1147"><textual class="po-textual">
        Processing instructions and comments are ignored.
      </textual></para><para class="po-block e1148 e1148"><textual class="po-textual">
        </textual><emphasis class="po-inline e1149 e1149" role="bold"><emphasis class="po-inline e1150 e1150" role="ital"><textual class="po-textual">
          Handling elements
        </textual></emphasis></emphasis><textual class="po-textual">
      </textual></para><para class="po-block e1151 e1151"><textual class="po-textual">
        The handling of elements depends on various properties:
        </textual><itemizedlist class="po-table e1152 e1152"><listitem class="po-container e1153 e1153"><para class="po-block e1154 e1154"><textual class="po-textual">
              the [nilled] property
            </textual></para></listitem><listitem class="po-container e1155 e1155"><para class="po-block e1156 e1156"><textual class="po-textual">
              the [model] property
            </textual></para></listitem><listitem class="po-container e1157 e1157"><para class="po-block e1158 e1158"><textual class="po-textual">
              the presence of element children
            </textual></para></listitem><listitem class="po-container e1159 e1159"><para class="po-block e1160 e1160"><textual class="po-textual">
              the presence of text node children
            </textual></para></listitem><listitem class="po-container e1161 e1161"><para class="po-block e1162 e1162"><textual class="po-textual">
              the [schema-type] property
            </textual></para></listitem></itemizedlist><textual class="po-textual">
        The following table shows all details.
      </textual></para><para class="po-block e1163 e1163"><textual class="po-textual">
        </textual><table class="po-container e1164 e1164"><caption class="po-container e1165 e1165"><para class="po-block e1166 e1166"><textual class="po-textual">
              </textual><emphasis class="po-inline e1167 e1167" role="bold"><emphasis class="po-inline e1168 e1168" role="ital"><textual class="po-textual">
                Serialization - translating UDL nodes into JSON items.
              </textual></emphasis></emphasis><textual class="po-textual">
            </textual></para></caption><col align="left" class="po-meta e1169 e1169" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><col align="left" class="po-meta e1170 e1170" span="1" valign="top"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><thead class="po-container e1171 e1171"><tr class="po-table e1172 e1172" valign="top"><th align="left" class="po-field e1173 e1173" rowspan="2" valign="top"><textual class="po-textual">UDL element node</textual></th><th align="left" class="po-field e1174 e1174" colspan="3" valign="top"><textual class="po-textual">JSON item</textual></th></tr></thead><tbody class="po-table e1175 e1175"><tr class="po-table e1176 e1176" valign="top"><td class="po-block e1177 e1177"><textual class="po-textual">[nilled] is </textual><code class="po-atom e1178 e1178"><textual class="po-textual">true</textual></code></td><td class="po-block e1179 e1179"><textual class="po-textual">
                </textual><para class="po-block e1180 e1180"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1181 e1181"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1182 e1182"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element name is not 
                  </textual><code class="po-atom e1183 e1183"><textual class="po-textual">udl:null</textual></code><textual class="po-textual">, a non-recoverable error is 
                  raised. Otherwise the element is serialized as a 
                  JSON null value.
                </textual></para><textual class="po-textual">
                 </textual></td></tr><tr class="po-table e1184 e1184" valign="top"><td class="po-block e1185 e1185" valign="top"><textual class="po-textual">
                </textual><para class="po-block e1186 e1186"><textual class="po-textual">[model] = "map"</textual></para><textual class="po-textual">
              </textual></td><td class="po-block e1187 e1187"><textual class="po-textual">
                </textual><para class="po-block e1188 e1188"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1189 e1189"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1190 e1190"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element 
                  name is not 
                  </textual><code class="po-atom e1191 e1191"><textual class="po-textual">udl:map</textual></code><textual class="po-textual">, a non-recoverable error is raised. 
                  Otherwise the element is serialized as a JSON object. 
                  The contained name/value pairs are obtained by serializing 
                  the element children. An error is raised if
                  the element has a text node child with 
                  non-whitespace content.
                </textual></para><textual class="po-textual">
              
              </textual></td></tr><tr class="po-table e1192 e1192" valign="top"><td class="po-block e1193 e1193"><textual class="po-textual">
                </textual><para class="po-block e1194 e1194"><textual class="po-textual">
                  [model] = "sequence";
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1195 e1195"><textual class="po-textual">
                  at least one element child
                </textual></para><textual class="po-textual">
              </textual></td><td class="po-block e1196 e1196"><textual class="po-textual">
                </textual><para class="po-block e1197 e1197"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1198 e1198"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1199 e1199"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element 
                  name is not 
                  </textual><code class="po-atom e1200 e1200"><textual class="po-textual">udl:array</textual></code><textual class="po-textual">, a non-recoverable error is raised. 
                  Otherwise the element is serialized as a JSON array. 
                  The array members are obtained by serializing 
                  the element children. An error is raised if 
                  the element has a text node child with 
                  non-whitespace content.
                </textual></para><textual class="po-textual">
               
              </textual></td></tr><tr class="po-table e1201 e1201" valign="top"><td class="po-block e1202 e1202"><textual class="po-textual">
                </textual><para class="po-block e1203 e1203"><textual class="po-textual">
                  [model] = "sequence";
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1204 e1204"><textual class="po-textual">
                  no element children;
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1205 e1205"><textual class="po-textual">
                  at least one text node child
                </textual></para><textual class="po-textual">
              </textual></td><td class="po-block e1206 e1206"><textual class="po-textual">
                </textual><para class="po-block e1207 e1207"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1208 e1208"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1209 e1209"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element 
                  name is not 
                  </textual><code class="po-atom e1210 e1210"><textual class="po-textual">udl:value</textual></code><textual class="po-textual">, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as a JSON simple value.
                  The string values of the text nodes are concatenated and the 
                  result is used to construct a simple JSON value whose type
                  depends on the node's [schema-type]: number (if [schema-type]
                  is equal to or derived from xs:double or xs:decimal),
                  Boolean (if [schema-type] is equal to or derived from xs:boolean)
                  or a string (otherwise).
                </textual></para><textual class="po-textual">
                            </textual></td></tr><tr class="po-table e1211 e1211" valign="top"><td class="po-block e1212 e1212"><textual class="po-textual">
                </textual><para class="po-block e1213 e1213"><textual class="po-textual">
                  [model] = "sequence";
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1214 e1214"><textual class="po-textual">
                  no element children;
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1215 e1215"><textual class="po-textual">
                  no text node child;
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1216 e1216"><textual class="po-textual">
                  [schema-type] is an atomic type
                </textual></para><textual class="po-textual">
              </textual></td><td class="po-block e1217 e1217"><textual class="po-textual">
                </textual><para class="po-block e1218 e1218"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1219 e1219"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1220 e1220"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element 
                  name is not 
                  </textual><code class="po-atom e1221 e1221"><textual class="po-textual">udl:value</textual></code><textual class="po-textual">, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as a JSON string 
                  value of zero length.
                </textual></para><textual class="po-textual">
              
              </textual></td></tr><tr class="po-table e1222 e1222" valign="top"><td class="po-block e1223 e1223"><textual class="po-textual">
                </textual><para class="po-block e1224 e1224"><textual class="po-textual">
                  [model] = "sequence";
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1225 e1225"><textual class="po-textual">
                  no element children;
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1226 e1226"><textual class="po-textual">
                  no text node child;
                </textual></para><textual class="po-textual">
                </textual><para class="po-block e1227 e1227"><textual class="po-textual">
                  [schema-type] is not atomic
                </textual></para><textual class="po-textual">
              
              </textual></td><td class="po-block e1228 e1228"><textual class="po-textual">
                </textual><para class="po-block e1229 e1229"><textual class="po-textual">
                  If serialization parameter 
                  </textual><code class="po-atom e1230 e1230"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> is 
                  </textual><code class="po-atom e1231 e1231"><textual class="po-textual">json.strict</textual></code><textual class="po-textual"> and the element 
                  name is not 
                  </textual><code class="po-atom e1232 e1232"><textual class="po-textual">udl:array</textual></code><textual class="po-textual">, a non-recoverable error is raised. 
                  Otherwise, the element is serialized as an empty JSON array.
                </textual></para><textual class="po-textual">
              
              </textual></td></tr></tbody></table><textual class="po-textual">
      </textual></para></section></appendix><appendix class="po-hcontainer e1233 e1233" xml:id="appendix-b"><title class="po-block e1234 e1234"><textual class="po-textual">Additional support for "NCName-only JSON"</textual></title><para class="po-block e1235 e1235"><textual class="po-textual">
      This appendix describes an extension of the UDL proposal which 
      provides additional support for processing JSON documents in 
      which every name is an NCName. This extension is presented as 
      an appendix as it has a more tentative character than the core 
      parts of the proposal and is more likely to be modified, removed 
      or replaced by alternatives, should the UDL proposal be evaluated 
      as a whole.
    </textual></para><section class="po-hcontainer e1236 e1236" xml:id="appendix-b-introduction"><title class="po-block e1237 e1237"><textual class="po-textual">
        Introduction
      </textual></title><para class="po-block e1238 e1238"><textual class="po-textual">
        UDL does not map JSON documents to XML documents, but defines 
        the information content of a JSON document as an UDL node tree. 
        Such a node tree can be serialized as both, JSON or XML. The 
        XML representation of a JSON document is ugly and not meant 
        for human consumption. The UDL proposal regards the readability 
        of this XML representation as a non-goal and concentrates on 
        the node tree which is designed to enable a JSON processing 
        as powerful and elegant as XML processing. The developer is 
        expected to design his JSON processing code while regarding 
        the JSON serialization, not the XML serialization.
      </textual></para><para class="po-block e1239 e1239"><textual class="po-textual">  
        The poor readability of XML-encoded JSON documents is caused by 
        the fact than JSON names are captured as node keys, rather than 
        node names. The [key] property was introduced because the 
        alternative approach of regarding JSON names as node names 
        would introduce a dependence of the node model’s name 
        representation on whether the JSON name happens to be an 
        NCName: NCNames are preserved, and non-NCNames are changed 
        into the result of a name mapping which is either generic 
        and non-semantic (e.g. “2012” to “_2012”) or semantic and 
        application specific (e.g. “2012” to “year-2012”). A 
        semantic mapping is certainly an interesting solution in 
        many situations (compare for example [</textual><xref class="po-milestone e1240 e1240" linkend="LEE"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), 
        but it gives up the advantages of a unified document 
        language. The purely technical mapping which 
        replaces inacceptable characters, on 
        the other hand, is unnatural, as it amounts to the perspective 
        that “_2012” is the essential information content, whereas 
        “2012” is some deviating representation.
      </textual></para></section><section class="po-hcontainer e1241 e1241" xml:id="njson-nnjson"><title class="po-block e1242 e1242"><textual class="po-textual">
        Definition of UDL document styles: nJSON, nnJSON
      </textual></title><para class="po-block e1243 e1243"><textual class="po-textual">
        Nevertheless it cannot be denied that in some situations 
        one would like to have available both, a readable JSON 
        representation and a readable XML representation. For example,
        an increasing number of web services is expected to deliver both,
        XML and JSON, at user option. In this scenario, UDL’s 
        XML representation of a JSON document is downright inappropriate. 
        What is needed is an XML representation whose element names 
        mirror as good as possible the JSON names. If the JSON document 
        contains non-NCName names, the mapping problem arises - but 
        what if all JSON names </textual><emphasis class="po-inline e1244 e1244" role="ital"><textual class="po-textual">are</textual></emphasis><textual class="po-textual"> 
        NCNames? Let us define an 
        </textual><emphasis class="po-inline e1245 e1245" role="bold"><textual class="po-textual">nJSON</textual></emphasis><textual class="po-textual"> 
        document as a JSON document in which all names are NCNames.
        An XML representation of an nJSON document may 
        then reuse the JSON names as element names (the local part of it), 
        and yet represent a JSON document without any ambiguity: 
        JSON-serialization using the serialization parameter 
        </textual><code class="po-atom e1246 e1246"><textual class="po-textual">info-loss</textual></code><textual class="po-textual"> with a value 
        </textual><code class="po-atom e1247 e1247"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual"> will yield 
        the same document as the strict JSON-serialization of the 
        counterpart which sticks to unspecific names. Let us further 
        introduce the notion of 
        </textual><emphasis class="po-inline e1248 e1248" role="bold"><textual class="po-textual">nnJSON</textual></emphasis><textual class="po-textual"> 
        documents defined as follows: 
      </textual></para><orderedlist class="po-table e1249 e1249"><listitem class="po-container e1250 e1250"><para class="po-block e1251 e1251"><textual class="po-textual">
            every name is an NCName (indicated by the first “n”)
          </textual></para></listitem><listitem class="po-container e1252 e1252"><para class="po-block e1253 e1253"><textual class="po-textual">
            every element with a key has a local name equal to the key (the second “n“)
          </textual></para></listitem><listitem class="po-container e1254 e1254"><para class="po-block e1255 e1255"><textual class="po-textual">
            the document is JSON-serializable using </textual><code class="po-atom e1256 e1256"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual"> (the “JSON”)
          </textual></para></listitem></orderedlist><para class="po-block e1257 e1257"><textual class="po-textual">
        Note that (3) implies further constraints: no attributes and no 
        mixed content. At the same time this definition leaves considerable 
        freedom: namespaces and the names of key-less elements can be 
        chosen arbitrarily. nnJSON documents can be regarded as augmented 
        nJSON documents – the additional information consisting of element 
        names which can later be used or discarded, dependent on purpose.
      </textual></para><para class="po-block e1258 e1258"><textual class="po-textual">
        nnJSON documents have a remarkable property: they represent 
        an unambiguously determined nJSON document, to whose JSON text 
        they can be serialized, using </textual><code class="po-atom e1259 e1259"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual">; 
        and they can also be serialized to a well-readable XML 
        representation of that JSON document. 
        When dealing with nJSON documents, nnJSON can 
        be used as a normalization of information which enables unified 
        processing code: code that is used no matter if the input is 
        JSON or XML and whether the output is JSON or XML. This 
        unified code consumes an nnJSON tree and it produces an 
        nnJSON tree. The UDL extensions discussed so far ensure that 
        the nnJSON output can be alternatively serialized as readable 
        XML or nJSON. The extensions do however not enable the parsing 
        of both, nJSON text (JSON)  and nnJSON text (XML) into an nnJSON 
        tree. After all, the information content of nJSON and nnJSON 
        is different and parsing by definition does not change the 
        information content: parsing alone will always produce one 
        kind of tree or the other. The processing pattern just 
        sketched – “read and write nnJSON” - therefore has to rely 
        on a translation of an nJSON text or node tree into an nnJSON 
        node tree.
      </textual></para></section><section class="po-hcontainer e1260 e1260" xml:id="support-for-njson"><title class="po-block e1261 e1261"><textual class="po-textual">
        Special support for the processing of nJSON documents – a further extension of XPath
      </textual></title><para class="po-block e1262 e1262"><textual class="po-textual">
        After parsing an nJSON document (</textual><code class="po-atom e1263 e1263"><textual class="po-textual">doc("foo.json")</textual></code><textual class="po-textual">) 
        it can easily be transformed into an nnJSON document, e.g. with 
        a simple stylesheet. nJSON documents are however so important 
        that they warrant a built-in support supplied by the UDL 
        extensions. Therefore the present proposal adds a 
        special-purpose-function which combines the JSON parsing 
        and its transformation to an equivalent nnJSON document:
      </textual></para><programlisting class="po-block e1264 e1264" xml:space="preserve"><textual class="po-textual">
  nnjson($uri as xs:anyURI) as document-node()</textual></programlisting><para class="po-block e1265 e1265"><textual class="po-textual">
        Further signatures allow for control of several aspects 
        of the result document which are not constrained by the 
        definition of nnJSON documents. These  are:
        </textual><orderedlist class="po-table e1266 e1266"><listitem class="po-container e1267 e1267"><para class="po-block e1268 e1268"><textual class="po-textual">
              the element namespaces
            </textual></para></listitem><listitem class="po-container e1269 e1269"><para class="po-block e1270 e1270"><textual class="po-textual">
              the node name of the root element
            </textual></para></listitem><listitem class="po-container e1271 e1271"><para class="po-block e1272 e1272"><textual class="po-textual">
              the node names of other elements without a key
            </textual></para></listitem></orderedlist><textual class="po-textual">
        Consider an example. Let the following nJSON document 
        be a response to a “getWeather”  service request:
        </textual><programlisting class="po-block e1273 e1273" xml:space="preserve"><textual class="po-textual">
  {
     "date" : "2012-08-06",
     "place" : " London",
     "temperatures" : ["12", "21"]
  }</textual></programlisting><textual class="po-textual">
        Here comes a matching nnJSON document:
        </textual><programlisting class="po-block e1274 e1274" xml:space="preserve"><textual class="po-textual">
  &lt;getWeatherRS xmlns="http://example.com" udl:model="map"&gt;
   &lt;date&gt;2012-08-06&lt;/date&gt;
   &lt;place&gt;London&lt;/place&gt;
   &lt;temperatures&gt;
      &lt;t&gt;12&lt;/t&gt;
      &lt;t&gt;21&lt;/t&gt;
   &lt;/temperatures&gt;  
&lt;/getWeatherRS&gt;</textual></programlisting><textual class="po-textual">
        This document looks as a fairly natural representation of 
        the original JSON document, and it can be serialized 
        to the original JSON document using 
        </textual><code class="po-atom e1275 e1275"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual">. Note 
        the use of an arbitrary namespace and the choice of 
        intuitive element names for key-less elements. A 
        second signature of the </textual><code class="po-atom e1276 e1276"><textual class="po-textual">nnjson</textual></code><textual class="po-textual"> 
        function enables control of these customizations:
        </textual><programlisting class="po-block e1277 e1277" xml:space="preserve"><textual class="po-textual">
  nnjson($uri as xs:anyURI, 
         $namespace as xs:anyURI?, 
         $rootName as xs:string, 
         $patternsAndNames as item()*)</textual></programlisting><textual class="po-textual">
        The </textual><code class="po-atom e1278 e1278"><textual class="po-textual">patternsAndNames</textual></code><textual class="po-textual"> parameter expects an alternating 
        sequence of XSLT pattern values and an element name; when 
        renaming a key-less element, the first matching pattern is 
        located and the name is taken from the item following the 
        pattern item. Our example could be produced by the 
        following call:
        </textual><programlisting class="po-block e1279 e1279" xml:space="preserve"><textual class="po-textual">
   nnjson("rsp.json", 
          "http://example.com", 
          "getWeatherRS", 
          ("#temperatures/*", "t")
         )</textual></programlisting><textual class="po-textual">
        Using the simple signature without control paramters, on the other hand:
        </textual><programlisting class="po-block e1280 e1280" xml:space="preserve"><textual class="po-textual">nnjson("rsp.json")</textual></programlisting><textual class="po-textual">
        produces a document without namespace and with 
        some unspecific element names:
        </textual><programlisting class="po-block e1281 e1281" xml:space="preserve"><textual class="po-textual">
&lt;udl:map udl:model="map"&gt;
   &lt;date&gt;2012-08-06&lt;/date&gt;
   &lt;place&gt;London&lt;/place&gt;
   &lt;temperatures&gt;
      &lt;udl:value&gt;12&lt;/udl:value&gt;
      &lt;udl:value&gt;21&lt;/udl:value&gt;
   &lt;/udl:temperatures&gt;  
&lt;/udl:map&gt;</textual></programlisting><textual class="po-textual">
        The </textual><code class="po-atom e1282 e1282"><textual class="po-textual">nnjson</textual></code><textual class="po-textual"> function is a convenience function which 
        combines the parsing of an nJSON document with a 
        transformation of particular interest. The transformation 
        is defined in such a way that the changes of information 
        content do not interfere with a subsequent JSON-serialization 
        (using </textual><code class="po-atom e1283 e1283"><textual class="po-textual">json.ignore-names</textual></code><textual class="po-textual">). This curious mixture 
        of parsing and transformation is regarded as a first-class 
        operation deserving a built-in XPath function because of 
        a well-defined relationship between the resulting 
        XML document and the original JSON document.
      </textual></para></section></appendix><bibliography class="po-hcontainer e1284 e1284"><title class="po-block e1285 e1285"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e1286 e1286" xml:id="BASEX" xreflabel="BaseX"><textual class="po-textual">Gruen, Christian, et al. 
      BaseX Documentation Version 7.2, section "JSON Module", p. 125-127. 
      </textual><link class="po-inline e1287 e1287" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://docs.basex.org/wiki/Main_Page</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1288 e1288" xml:id="COUTHURES" xreflabel="Couthures"><textual class="po-textual">Couthures, Alain. 
      JSON for XForms - adding JSON support in XForms data instances. 
      XML Prague 2011, Conference Proceedings, p. 13-24.
      </textual><link class="po-inline e1289 e1289" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1290 e1290" xml:id="JSON" xreflabel="JSON"><textual class="po-textual">Web resource without source information: Introducing JSON.
      </textual><link class="po-inline e1291 e1291" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://json.org</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1292 e1292" xml:id="JSONIQ" xreflabel="JSONiq"><textual class="po-textual">Robie, Jonathan, Mathias Brantner,
      Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq - XQuery for JSON,
      JSON for XQuery. XML Prague 2012, Conference Proceedings, p. 63-72.
      </textual><link class="po-inline e1293 e1293" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1294 e1294" xml:id="JSONIQSPEC" xreflabel="JSONiq Specification"><textual class="po-textual">Robie, Jonathan, Mathias Brantner,
      Daniela Florescu, Ghislain Fourny and Till Westmann. JSONiq: Language Specification.
      </textual><link class="po-inline e1295 e1295" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://jsoniq.com/docs/spec/en-US/html/index.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1296 e1296" xml:id="HUNTER" xreflabel="Hunter"><textual class="po-textual">Hunter, Jason. 
      A JSON facade on MarkLogic Server. XML Prague 2011, Conference Proceedings, p. 25-34.
      </textual><link class="po-inline e1297 e1297" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2011/files/xmlprague-2011-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1298 e1298" xml:id="JSONML" xreflabel="JsonML"><textual class="po-textual">Web resource without source 
      information: JSON Markup Language (JsonML). 
      </textual><link class="po-inline e1299 e1299" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.jsonml.org/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1300 e1300" xml:id="LEE" xreflabel="Lee"><textual class="po-textual">Lee, David A. JXON: an Architecture for 
     Schema and Annotation Driven JSON/XML Bidirectional Transformations. Presented at 
     Balisage: The Markup Conference 2011, Montréal, Canada, August 2 - 5, 2011. 
     In Proceedings of Balisage: The Markup Conference 2011. Balisage Series on 
     Markup Technologies, vol. 7 (2011). doi:</textual><biblioid class="po-atom e1301 doi e1301"><textual class="po-textual">10.4242/BalisageVol7.Lee01</textual></biblioid><textual class="po-textual">.
     </textual><link class="po-inline e1302 e1302" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol7/html/Lee01/BalisageVol7-Lee01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1303 e1303" xml:id="PEMBERTON" xreflabel="Pemberton"><textual class="po-textual">Pemberton, Steven. 
      Treating JSON as a subset of XML. XML Prague 2012, 
      Conference Proceedings, p. 81-90.
      </textual><link class="po-inline e1304 e1304" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlprague.cz/2012/files/xmlprague-2012-proceedings.pdf</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1305 e1305" xml:id="ROBIE" xreflabel="Robie"><textual class="po-textual">Robie, Jonathan. A universal
      markup language and a universal query language. A contribution to the discussion of 
      Google group JSONiq, 18 October 2011.
      </textual><link class="po-inline e1306 e1306" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://groups.google.com/group/jsoniq</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1307 e1307" xml:id="TENNISON" xreflabel="Tennison"><textual class="po-textual">Tennison, Jeni. Opening keynote -
      collisions, chimera and consonance in web content. A presentation at
      xmlprague 2012. </textual><link class="po-inline e1308 e1308" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.slideshare.net/JeniT/collisions-chimera-and-consonance-in-web-content</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1309 e1309" xml:id="W3C-INFOSET" xreflabel="W3C Information Set"><textual class="po-textual">John Cowan and Richard Tobin, eds. 
      XML Information Set. W3C Recommendation 4 February 2004.
      </textual><link class="po-inline e1310 e1310" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml-infoset/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1311 e1311" xml:id="W3C-XDM" xreflabel="W3C XDM"><textual class="po-textual">Mary Fernandez et al, eds. 
      XQuery 1.0 and XPath 2.0 Data Model (XDM). W3C Recommendation 23 January 2007.
      </textual><link class="po-inline e1312 e1312" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1313 e1313" xml:id="W3C-XDM-3.0" xreflabel="W3C XDM 3.0"><textual class="po-textual">Norman Walsh et al, eds. 
      XQuery and XPath Data Model 3.0. W3C Working Draft 14 June 2011.
      </textual><link class="po-inline e1314 e1314" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-datamodel-30/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1315 e1315" xml:id="W3C-XML" xreflabel="W3C XML"><textual class="po-textual">Tim Bray et al, eds. 
      Extensible Markup Language (XML) 1.0 (Fifth Edition). W3C Recommendation 26 November 2008.
      </textual><link class="po-inline e1316 e1316" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1317 e1317" xml:id="W3C-XSLT-3.0" xreflabel="W3C XSLT 3.0"><textual class="po-textual">Michael Kay, ed. 
      XSL Transformations (XSLT) Version 3.0. W3C Working Draft 10 July 2012.
      </textual><link class="po-inline e1318 e1318" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt-30/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>