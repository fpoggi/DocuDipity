<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">TagAl</textual></title><subtitle class="po-block e2 e2"><textual class="po-textual">A tag algebra for document markup</textual></subtitle><info class="po-record e3 e3"><confgroup class="po-record e4 e4"><conftitle class="po-field e5 e5"><textual class="po-textual">Balisage: The Markup Conference 2011</textual></conftitle><confdates class="po-field e6 e6"><textual class="po-textual">August 2 - 5, 2011</textual></confdates></confgroup><abstract class="po-container e7 e7"><para class="po-block e8 e8"><textual class="po-textual"> This paper takes its point of departure in an overview of the overlap problem, and of
        proposed solutions to that problem. We then look at some analogies between bracketed markup
        notations and rules for well-formedness and structuring of simple parenthetical expressions.
        We propose a method for building lattices from marked up documents with and without overlap,
        and for generating, from these lattices, document models in the form of trees for XML
        documents, and in the form of GODDAGs for documents with overlap. It turns out that one and
        the same method can be used for generating both kinds of models, and we argue that lattices
        can also be used to implement well-formedness constraints for both kinds of documents.
        Finally, we discuss and compare some of the algebraic features of the document models, and
        the relations between them. </textual></para></abstract><author class="po-record e9 e9"><personname class="po-record e10 e10"><firstname class="po-field e11 e11"><textual class="po-textual">Lars</textual></firstname><othername class="po-field e12 e12"><textual class="po-textual">G</textual></othername><surname class="po-field e13 e13"><textual class="po-textual">Johnsen</textual></surname></personname><personblurb class="po-container e14 e14"><para class="po-block e15 e15"><textual class="po-textual">Lars G. Johnsen is Associate Professor of linguistics at the University of Bergen,
          Norway.</textual></para></personblurb><email class="po-field e16 e16"><textual class="po-textual">hfolg@uib.no</textual></email><affiliation class="po-record e17 e17"><jobtitle class="po-field e18 e18"><textual class="po-textual">Associate Professor</textual></jobtitle><orgname class="po-block e19 e19"><textual class="po-textual">University of Bergen, Norway</textual></orgname></affiliation></author><author class="po-record e20 e20"><personname class="po-record e21 e21"><firstname class="po-field e22 e22"><textual class="po-textual">Claus</textual></firstname><surname class="po-field e23 e23"><textual class="po-textual">Huitfeldt</textual></surname></personname><personblurb class="po-container e24 e24"><para class="po-block e25 e25"><textual class="po-textual">Claus Huitfeldt is Associate Professor at the Department of Philosophy of the
          University of Bergen, Norway.</textual></para></personblurb><affiliation class="po-record e26 e26"><jobtitle class="po-field e27 e27"><textual class="po-textual">Associate Professor </textual></jobtitle><orgname class="po-block e28 e28"><textual class="po-textual">University of Bergen</textual></orgname></affiliation><email class="po-field e29 e29"><textual class="po-textual">claus.huitfeldt@uib.no</textual></email></author><legalnotice class="po-container e30 e30"><para class="po-block e31 e31"><textual class="po-textual">Copyright © 2011 by the authors.  Used with permission.</textual></para></legalnotice></info><section class="po-hcontainer e32 e32"><title class="po-block e33 e33"><textual class="po-textual">Digital documents: Representational forms and operations</textual></title><para class="po-block e34 e34"><textual class="po-textual">When computers were first used for purposes of text processing, documents were typically
      represented as linear sequences of characters. This format lends reasonable support to basic
      operations on documents, such as visual presentation, editing, retrieval, content extraction,
      linguistic and quantitative analysis, and various forms of transformation. </textual></para><para class="po-block e35 e35"><textual class="po-textual">However, the objects of such operations are not always most naturally thought of, or not
      easily identified, in terms of character sequences. Some operations are performed on
      structural partitions of documents such as sections, paragraphs, or sentences. Objects defined
      in terms of their thematic, linguistic, rhetorical or other properties, such as names, foreign
      words, high-lighted phrases etc. may also be the target of operations to be performed.
      Sometimes such objects can be identified at least indirectly in terms of properties of
      character sequences, but seldom reliably, </textual><footnote class="po-popup e36 e36"><para class="po-block e37 e37"><textual class="po-textual">Simple examples in point are sentences, quotations, and proper names</textual></para></footnote><textual class="po-textual"> and often not at all. </textual></para><para class="po-block e38 e38"><textual class="po-textual">Document markup can be seen as a response to these problems: when candidate objects of
      operations are explicitly marked, text processing applications are relieved of the burden of
      identifying them, and developers of such applications may concentrate on the operations to be
      performed rather than on the identification of the objects to be processed. Thus, marked up
      documents provide improved support for text processing, compared to documents without markup. </textual></para><para class="po-block e39 e39"><textual class="po-textual"> Therefore, it is perhaps only natural that with the introduction of document markup, the
      number and kinds of document objects that became subject of interest for processing increased.
      Markup languages and tools were developed not only for general purpose document publication
      and analysis, but also for more specialized purposes and document types. </textual></para><para class="po-block e40 e40"><textual class="po-textual">For a number of reasons, the markup languages which became most widely used, and the
      grammars which ultimately acquired the status of international standards for those languages,
      such as SGML and XML, </textual><footnote class="po-popup e41 e41"><para class="po-block e42 e42"><textual class="po-textual">For convenience, we will allow ourselves to use the term "XML" in the rest of this
          paper, also when for historical or other reasons the correct reference would be either to
          XML, or to SGML, or to both.</textual></para></footnote><textual class="po-textual"> were based on context-free grammars. One obvious reason was that representations
      based on context-free grammars were processable according to well known and computationally
      efficient algorithms. Over the years a plethora of general as well as special-purpose software
      for XML document processing has become available. </textual></para><para class="po-block e43 e43"><textual class="po-textual"> Such markup languages invite an abstract view of document structure and content, in which
      the "artifacts" of markup in the document in its serial form are represented in a more
      conspicuous way. Many or most XML processors do not actually perform operations on the
      document in its serialized form, but only (or largely) on a model of the document, usually in
      the form of a labeled directed acyclic graph. The graph is constructed from the serialized
      form of the document, and reserialized only for purposes of storage and exchange. Since one
      and the same graph may be represented in the form of more than one serialization, focus tends
      to be transferred on the graph (or, in XML terms, the document object model), rather than the
      serial form of the document. </textual></para></section><section class="po-hcontainer e44 e44"><title class="po-block e45 e45"><textual class="po-textual">The Overlap Problem</textual></title><para class="po-block e46 e46"><textual class="po-textual"> The coincidence of the two factors mentioned above (i.e. the increasing interest in
      marking up more and more aspects of documents, and the fact that available systems were based
      on context-free grammars) lead to a number of closely related problems which are now commonly
      referred to as "the overlap problem". </textual><footnote class="po-popup e47 e47"><para class="po-block e48 e48"><textual class="po-textual">The one problem which has received most attention in the literature is the difficulty
          or inconvenience of representing overlapping elements in XML. There are related problems
          pertaining to the representation of discontinuous elements and alternate ordering of
          elements, which we do not address in this paper. We do believe, however, that the general
          strategy outlined here could also be adopted in order to get a better grip on these
          problems.</textual></para></footnote><textual class="po-textual"> On the one hand, the obvious advantages of markup lead to interest in marking up a
      wide variety of aspects of document structure, often necessitating different segmentations of
      one and the same document. On the other hand, standard markup systems did not provide a
      straight-forward and natural way of representing such competing or conflicting segmentations. </textual><footnote class="po-popup e49 e49"><para class="po-block e50 e50"><textual class="po-textual"> An important exception on this point is the SGML CONCUR feature, which did provide a
          mechanism for the encoding of concurrent hierarchies. Unfortunately, CONCUR was never
          widely supported by SGML implementations, and was not carried over to XML. However see
            [</textual><xref class="po-milestone e51 e51" linkend="Schonefeld2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. </textual></para></footnote><textual class="po-textual"> So although marked up documents provide better support for a broad range of
      processing purposes than documents without markup, the introduction of markup also lead to a
      number of problems one did not have much means or motivation to identify or formulate before
      the introduction of markup. </textual></para><para class="po-block e52 e52"><textual class="po-textual">The so-called overlap problem was identified fairly early, and the literature of proposed
      solutions goes more than 30 years back in time. </textual><footnote class="po-popup e53 e53"><para class="po-block e54 e54"><textual class="po-textual">See e.g. [</textual><xref class="po-milestone e55 e55" linkend="Barnardetal.1988"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e56 e56" linkend="Barnardetal.1995"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e57 e57" linkend="DeRose2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and [</textual><xref class="po-milestone e58 e58" linkend="Witt2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
          We cannot and do not attempt a full overview of the literature in this paper, but only to
          point to some of the main courses among various approaches to the problem. </textual></para></footnote><textual class="po-textual"> The responses to the problem may be said to fall largely in four groups: 1)
      Alternate linear forms, 2) Alternate document models, 3) Stand-off markup, and 4)
      Transformation algorithms. </textual></para><section class="po-hcontainer e59 e59"><title class="po-block e60 e60"><textual class="po-textual">Alternate linear forms</textual></title><para class="po-block e61 e61"><textual class="po-textual"> Since the syntax of XML enforces a strict hierarchical nesting of XML elements, it
        seems like a tempting solution simply to lift or soften this restriction. A large number of
        such proposals have been made. </textual></para><para class="po-block e62 e62"><textual class="po-textual">Some notable examples are SGML CONCUR [</textual><xref class="po-milestone e63 e63" linkend="Goldfarb1990"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], XCONCUR
          [</textual><xref class="po-milestone e64 e64" linkend="Schonefeld2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], MECS [</textual><xref class="po-milestone e65 e65" linkend="Huitfeldt1998"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],
        TexMecs [</textual><xref class="po-milestone e66 e66" linkend="HuitfeldtandSperberg-McQueen2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and LMNL [</textual><xref class="po-milestone e67 e67" linkend="TennisonandPiez2002"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. </textual></para><para class="po-block e68 e68"><textual class="po-textual">The advantages of most of these proposals is that they provide what for human readers
        seems like a more natural and easily readable linear representation of overlapping elements
        than is provided by alternative proposals adhering to XML syntax. They may also provide
        better support for certain operations on overlapping elements. However, for the most part it
        is unclear how to perform anything like a full range of standard operations on their markup
        constructs, and there are unresolved issues of processability, expressive power etc. </textual></para></section><section class="po-hcontainer e69 e69"><title class="po-block e70 e70"><textual class="po-textual">Alternate document models</textual></title><para class="po-block e71 e71"><textual class="po-textual"> Some proposals provide alternatives to what is commonly perceived as the XML document
        model, i.e. tree-shaped graphs like XDM or XML DOM, either in combination with or
        independently of proposals for alternative linear forms. </textual></para><para class="po-block e72 e72"><textual class="po-textual">Some notable examples are LMNL [</textual><xref class="po-milestone e73 e73" linkend="TennisonandPiez2002"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], Goddag
          [</textual><xref class="po-milestone e74 e74" linkend="Sperberg-McQueenandHuitfeldt2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], multi-colored trees [</textual><xref class="po-milestone e75 e75" linkend="Jagadishetal.2004"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and Multi-Document Graphs [</textual><xref class="po-milestone e76 e76" linkend="SchmidtandColomb2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. </textual></para><para class="po-block e77 e77"><textual class="po-textual">Although these solutions in general provide better support for at least certain
        operations on overlapping elements, the question of how to perform other standard operations
        is mostly unclear or not systematically addressed. For some of the proposals it is also
        unclear whether, or to what extent, it is possible to support roundtripping between the
        proposed document model and its form, or even what such roundtripping would amount to. (This
        is the case, for example, concerning the relation between Goddag and TexMecs.) Again, there
        are in general unresolved issues of processability, expressive power etc. </textual></para></section><section class="po-hcontainer e78 e78"><title class="po-block e79 e79"><textual class="po-textual">Stand-off markup</textual></title><para class="po-block e80 e80"><textual class="po-textual">Quite early on, it was suggested that many or most of the problems related to overlap
        can be seen as a result of the general limitations of embedded markup. [</textual><xref class="po-milestone e81 e81" linkend="Raymondetal1992"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e82 e82" linkend="Raymondetal1995"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] Thus, the idea
        of separating the markup from the document to be marked up, in the form of so-called
        "stand-off" markup has received considerable attention and adoption. </textual></para><para class="po-block e83 e83"><textual class="po-textual">Some notable examples are xStandoff [</textual><xref class="po-milestone e84 e84" linkend="StührenbergandJettka2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],
        Nite [</textual><xref class="po-milestone e85 e85" linkend="Carlettaetal.2005"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], Earmark [</textual><xref class="po-milestone e86 e86" linkend="DiIorioetal.2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and (as an interesting limiting case) Multix [</textual><xref class="po-milestone e87 e87" linkend="Chattietal.2007"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. TEI [</textual><xref class="po-milestone e88 e88" linkend="TEIP5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] also contains recommendation for stand-off
        markup. </textual></para><para class="po-block e89 e89"><textual class="po-textual">Stand-off markup does indeed provide potentially very strong expressive power and might
        seem to be the one sweeping solution to all problems related to overlap. And perhaps it is. </textual><footnote class="po-popup e90 e90"><para class="po-block e91 e91"><textual class="po-textual">In addition, stand-off markup may provide solutions to problems related to the
            representation of document change histories, of multi-versioned documents, and to
            dynamic document editing. These problems often coincide with, but are in our view
            distinct from, the overlap problem. Common objections to stand-off markup concern data
            integrity under document editing. This is indeed a serious concern, but one which lies
            outside the scope of this paper.</textual></para></footnote><textual class="po-textual"> We note, however, that standoff markup either has been used, or could be used,
        in combination with any or all of the linear formats and document models referred to above.
        Thus, all the unclarities that pertain to those, and to the relationships between them,
        pertain also to stand-off markup. </textual></para></section><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">Transformation algorithms</textual></title><para class="po-block e94 e94"><textual class="po-textual">Since there is such a multitude of proposals for alternate linear forms and document
        models, since they all have their pros and cons, and since no universal agreement on a
        unified solution seems to be forthcoming, it has been proposed that one should instead try
        to provide a common framework of algorithms for transformation between different linear
        forms and/or document models. </textual><footnote class="po-popup e95 e95"><para class="po-block e96 e96"><textual class="po-textual">Requests and proposals for transformation tools are abundant in the literature, but
            we know of only one proposal which recommends the establishment of a common framework of
            transformation algorithms as a general solution: [</textual><xref class="po-milestone e97 e97" linkend="Marinellietal.2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></footnote><textual class="po-textual">
      </textual></para><para class="po-block e98 e98"><textual class="po-textual">The advantages of this approach may be as obvious as its disadvantages: A major
        advantage is that, to the extent that transformations may be performed without loss of
        information, it makes all the strengths of all of the solutions above available to the
        users. Major disadvantages are: First, for every alternate serial form and/or document model
        introduced, the number of required transformation algorithms increases exponentially. Second
        (and perhaps most importantly), there seems to be no established and agreed-upon way of
        deciding whether or not any given transformation algorithm introduces information
      loss.</textual></para></section></section><section class="po-hcontainer e99 e99"><title class="po-block e100 e100"><textual class="po-textual">The idea of a tag algebra</textual></title><para class="po-block e101 e101"><textual class="po-textual"> There seems to be no consensus neither on whether the basic elements of marked up
      documents are most suitably regarded as partitions of a character stream (tags, elements etc.)
      or nodes of a graph of some kind, nor on what the basic operations on these elements are and
      how they are to be defined. As long as these issues are not clear, it is hard to compare and
      evaluate the various approaches to the overlap problem. </textual></para><para class="po-block e102 e102"><textual class="po-textual">Elementary algebra assumes that numbers are the same whether written in Arabic or Roman
      notation, or, for that matter, whether we use a decimal, a digital or a hexadecimal numeral
      system, and that the sum of two numbers is the same irrespective of which algorithm we employ
      to calculate it. Certainly, some notations may seem less intuitive than others, and some
      notations require the use of more complex algorithms than others in order to perform certain
      operations. However, while important enough, such issues have no bearing on the question of
      what the correct result of an operation is. There is one and only one answer to the question
      of what the sum of two numbers are, irrespective of which notation and algorithm one might
      choose to use in computing that sum.</textual></para><para class="po-block e103 e103"><textual class="po-textual">Similarly, a tag algebra should be able to tell us whether two representations of a
      document marked up using different notations are representations of the same document or not,
      and what the result of adding or subtracting a specific element to or from that document
      should be. In what follows, we hope to establish at common basis for the solution of at least
      the first of these problems. We believe this basis will also be useful for defining operations
      on marked up documents, although we do not get that far in this paper. </textual></para></section><section class="po-hcontainer e104 e104"><title class="po-block e105 e105"><textual class="po-textual">Bracketed notations and matching</textual></title><para class="po-block e106 e106"><textual class="po-textual"> In the rest of this paper, we will explore the relationship between markup without
      overlap and markup with overlap by way of comparing XML to another, imaginary markup language.
      This other markup language, which we may call O-XML, is exactly like XML, except that in O-XML
      overlap is allowed. </textual><footnote class="po-popup e107 e107"><para class="po-block e108 e108"><textual class="po-textual">For all relevant purposes, therefore, O-XML is equivalent to what Yves Marcoux termed
          "overlap-only TexMECS" in [</textual><xref class="po-milestone e109 e109" linkend="Marcoux2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Note that, like
          "overlap-only TexMECS" and some other notations, but unlike yet other notations allowing
          for overlap, O-XML does not allow for self-overlap.</textual></para></footnote><textual class="po-textual"> So whereas nesting structures like
      </textual><programlisting class="po-block e110 e110" xml:space="preserve"><textual class="po-textual">&lt;a&gt;...&lt;b&gt;...&lt;/b&gt;...&lt;/a&gt;</textual></programlisting><textual class="po-textual"> are well-formed in both
      XML and O-XML, overlapping structures like
      </textual><programlisting class="po-block e111 e111" xml:space="preserve"><textual class="po-textual">&lt;a&gt;...&lt;b&gt;...&lt;/a&gt;...&lt;/b&gt;</textual></programlisting><textual class="po-textual"> are ill-formed in XML,
      but well-formed in O-XML. As we are concerned exclusively with element structure, we ignore
      all other features or mechanisms of XML such as attributes, entities, comments, declarations,
      cdata sections, processing instructions, etc. </textual></para><para class="po-block e112 e112"><textual class="po-textual">We may start with the observation that in XML all elements nest, while in documents with
      overlap not all of them do. </textual><footnote class="po-popup e113 e113"><para class="po-block e114 e114"><textual class="po-textual">The latter may seem like a tautology, as it merely says that in documents with overlap
          some elements overlap. Note that in the sense we are using the term overlap here, XML
          documents do not have overlap, whereas documents in notations like O-XML, such as MECS,
          TexMecs, LMNL, xConcur etc. may have.</textual></para></footnote><textual class="po-textual"> We may also observe that the element structure of XML documents can be deduced
      without looking at the generic identifiers of end tags, </textual><footnote class="po-popup e115 e115"><para class="po-block e116 e116"><textual class="po-textual">This may be one of the reasons for the complaints about the verbosity of XML as
          compared to e.g. SGML, which allows for the omission of generic identifiers on end
        tags.</textual></para></footnote><textual class="po-textual"> whereas in notations allowing overlap this information is essential. We might
      summarize this by saying that in XML the start and end tags of nesting elements always match,
      whereas in other notations they do not always match. </textual></para><para class="po-block e117 e117"><textual class="po-textual">But there is something puzzling about this way of putting the matter. Exactly what do we
      mean by the terms </textual><quote class="po-inline e118 e118"><textual class="po-textual">nesting</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e119 e119"><textual class="po-textual">element</textual></quote><textual class="po-textual">, and </textual><quote class="po-inline e120 e120"><textual class="po-textual">match</textual></quote><textual class="po-textual">? We
      observe that whereas there is no overlap in
      </textual><programlisting class="po-block e121 e121" xml:space="preserve"><textual class="po-textual">&lt;a&gt;...&lt;b&gt;...&lt;/b&gt;...&lt;/a&gt;</textual></programlisting><textual class="po-textual"> and there is overlap in
      </textual><programlisting class="po-block e122 e122" xml:space="preserve"><textual class="po-textual">&lt;a&gt;...&lt;b&gt;...&lt;/a&gt;...&lt;/b&gt;</textual></programlisting><textual class="po-textual"> the difference between
      them disappears if we leave out the generic identifiers:
      </textual><programlisting class="po-block e123 e123" xml:space="preserve"><textual class="po-textual">&lt; &gt;...&lt; &gt;...&lt;/ &gt;...&lt;/ &gt;</textual></programlisting><textual class="po-textual"> Our guess is that it
      probably seems natural to most readers to assume that the element structure of the last
      example above is identical to the first, rather than the second. But is this necessarily so,
      and if so, why? Let us pursue the similarities between the nesting of start and end tags and
      the nesting of simple parentheses a bit further. </textual></para><para class="po-block e124 e124"><textual class="po-textual">Consider any string consisting of left (i.e. start, or open) and right (i.e. end, or
      close) parentheses. One common assumption is that there should be a one to one correspondence
      between left and right parentheses, so that they are equal in number. This ensures that the
      string </textual><code class="po-atom e125 e125"><textual class="po-textual">((()))</textual></code><textual class="po-textual"> is to be regarded as well-formed, while the string
      </textual><code class="po-atom e126 e126"><textual class="po-textual">((())</textual></code><textual class="po-textual"> is not. Another common assumption is that for every left parenthesis there
      is a succeeding right parenthesis. This ensures that the string </textual><code class="po-atom e127 e127"><textual class="po-textual">)()(</textual></code><textual class="po-textual"> is not to be
      regarded as well-formed. In the following, we will refer to these two assumptions as "basic".</textual></para><para class="po-block e128 e128"><textual class="po-textual"> The two basic assumptions do not by themselves imply any specific answer to the question
      which of the left parentheses correspond to which of the right parentheses in the well-formed
      cases. The intuitively most plausible (or common) reading of the string </textual><code class="po-atom e129 e129"><textual class="po-textual">(())</textual></code><textual class="po-textual"> may
      be in accordance with a "nesting" convention, to the effect that the first left parenthesis
      corresponds to the last right parenthesis. According to this convention, the structure of the
      expression </textual><code class="po-atom e130 e130"><textual class="po-textual">()(())</textual></code><textual class="po-textual"> looks like this, where subscripts indicate correspondence: </textual><blockquote class="po-container e131 e131"><para class="po-block e132 e132"><textual class="po-textual">
          </textual><code class="po-atom e133 e133"><textual class="po-textual">(</textual><subscript class="po-atom e134 e134"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e135 e135"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> (</textual><subscript class="po-atom e136 e136"><textual class="po-textual">2</textual></subscript><textual class="po-textual">
              (</textual><subscript class="po-atom e137 e137"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e138 e138"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e139 e139"><textual class="po-textual">2</textual></subscript></code><textual class="po-textual">
        </textual></para></blockquote><textual class="po-textual"> However, nothing in the two basic assumptions as stated stops us from adopting
      other conventions. We might imagine a "mirroring" convention, where the first left parenthesis
      corresponds to the first right, the second left parenthesis to the second right, and so on. A
      "mirroring" convention for the same expression may look like this: </textual><blockquote class="po-container e140 e140"><para class="po-block e141 e141"><textual class="po-textual">
          </textual><code class="po-atom e142 e142"><textual class="po-textual">(</textual><subscript class="po-atom e143 e143"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e144 e144"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> (</textual><subscript class="po-atom e145 e145"><textual class="po-textual">2</textual></subscript><textual class="po-textual">
              (</textual><subscript class="po-atom e146 e146"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e147 e147"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e148 e148"><textual class="po-textual">3</textual></subscript></code><textual class="po-textual">
        </textual></para></blockquote><textual class="po-textual"> (Note the "overlap" between parentheses subscripted </textual><quote class="po-inline e149 e149"><textual class="po-textual">2</textual></quote><textual class="po-textual"> and
        </textual><quote class="po-inline e150 e150"><textual class="po-textual">3</textual></quote><textual class="po-textual"> here. </textual><footnote class="po-popup e151 e151"><para class="po-block e152 e152"><textual class="po-textual">Nesting and mirroring agrees on single level coordinate structures, for example
            </textual><code class="po-atom e153 e153"><textual class="po-textual">()()</textual></code><textual class="po-textual">.</textual></para></footnote><textual class="po-textual">)</textual></para><para class="po-block e154 e154"><textual class="po-textual">Other conventions may be imagined in which some parentheses are selected according to
      specific rules, while the rest follow some general scheme like nesting or mirroring. </textual><footnote class="po-popup e155 e155"><para class="po-block e156 e156"><textual class="po-textual"> Imagine speakers of two dialects Nest and Mirr of the language Parenthesian, a
          language forming subsets of well-formed parentheses. In dialect Nest the semantics follows
          nested brackets, in Mirr matches are a mix of mirrored and nested parenthesis. In both
          dialects the word for walk is </textual><code class="po-atom e157 e157"><textual class="po-textual">"()"</textual></code><textual class="po-textual"> and the word for dog is "(())". The rule
          for forming "verb+subject" sentences in dialect Nest is to wrap the verb inside the first
          parenthesis of the noun, so that "dog walks" becomes </textual><code class="po-atom e158 e158"><textual class="po-textual">"(()())"</textual></code><textual class="po-textual">. Using
          subscripted d's to indicate "dog" the structure is:</textual><code class="po-atom e159 e159"><textual class="po-textual">
              (</textual><subscript class="po-atom e160 e160"><textual class="po-textual">d</textual></subscript><textual class="po-textual">()(</textual><subscript class="po-atom e161 e161"><textual class="po-textual">d</textual></subscript><textual class="po-textual">)</textual><subscript class="po-atom e162 e162"><textual class="po-textual">d</textual></subscript><textual class="po-textual">)</textual><subscript class="po-atom e163 e163"><textual class="po-textual">d</textual></subscript><textual class="po-textual">.
          </textual></code><textual class="po-textual"> Dialect Mirr has a different rule for forming sentences (verb+subject): wrap the
          last parenthesis of the verb around the first parenthesis of the noun, resulting in the
          configuration </textual><code class="po-atom e164 e164"><textual class="po-textual">"(()())"</textual></code><textual class="po-textual">. Surprisingly, this is exactly the same expression as
          above, although it now has a different structure: </textual><code class="po-atom e165 e165"><textual class="po-textual">
              ((</textual><subscript class="po-atom e166 e166"><textual class="po-textual">d</textual></subscript><textual class="po-textual">)(</textual><subscript class="po-atom e167 e167"><textual class="po-textual">d</textual></subscript><textual class="po-textual">)</textual><subscript class="po-atom e168 e168"><textual class="po-textual">d</textual></subscript><textual class="po-textual">)</textual><subscript class="po-atom e169 e169"><textual class="po-textual">d</textual></subscript><textual class="po-textual">.
          </textual></code></para></footnote><textual class="po-textual">
    </textual></para><para class="po-block e170 e170"><textual class="po-textual"> Thus, the two basic assumptions concerning the well-formedness of parenthetical
      expressions are compatible with alternate ways of assigning structure to those expressions.
      This important fact is easy to overlook, because one common method of testing for
      well-formedness, namely the use of rewrite grammars, also lends itself very easily to the
      assignment of a structure in accordance with the "nesting" convention above. The following
      example will illustrate this. </textual></para><para class="po-block e171 e171"><textual class="po-textual">A rewrite grammar for generating strings of parentheses which obey the two basic
      assumptions may look like this: </textual><variablelist class="po-table e172 e172"><varlistentry class="po-record e173 e173"><term class="po-block e174 e174"><textual class="po-textual">Base step</textual></term><listitem class="po-container e175 e175"><para class="po-block e176 e176"><textual class="po-textual">
              </textual><code class="po-atom e177 e177"><textual class="po-textual">P→()</textual></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e178 e178"><term class="po-block e179 e179"><textual class="po-textual">Subordination step</textual></term><listitem class="po-container e180 e180"><para class="po-block e181 e181"><textual class="po-textual">
              </textual><code class="po-atom e182 e182"><textual class="po-textual">P→(P)</textual></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e183 e183"><term class="po-block e184 e184"><textual class="po-textual">Coordination step</textual></term><listitem class="po-container e185 e185"><para class="po-block e186 e186"><textual class="po-textual">
              </textual><code class="po-atom e187 e187"><textual class="po-textual">P→PP</textual></code><textual class="po-textual">
            </textual></para></listitem></varlistentry></variablelist><textual class="po-textual">A string is well-formed, in accordance with the two basic assumptions, if and
      only if it can be generated by this grammar, which generates strings like </textual><code class="po-atom e188 e188"><textual class="po-textual">()</textual></code><textual class="po-textual">,
        </textual><code class="po-atom e189 e189"><textual class="po-textual">()(()())</textual></code><textual class="po-textual"> and </textual><code class="po-atom e190 e190"><textual class="po-textual">((()))</textual></code><textual class="po-textual">
      </textual><footnote class="po-popup e191 e191"><para class="po-block e192 e192"><textual class="po-textual"> If we allow for the use of regular expressions in grammar rules, the base and
          coordination steps can be merged to: </textual><code class="po-atom e193 e193"><textual class="po-textual">P→P*</textual></code><textual class="po-textual">
        </textual></para></footnote><textual class="po-textual">
    </textual></para><para class="po-block e194 e194"><textual class="po-textual"> As mentioned, this grammar may also be used in order to assign a structure to the
      expressions in accordance with the "nesting" convention. This may be done by associating with
      each other the two parentheses that are generated together in each of the subordination or
      base steps. Selecting an index from the sequence number of rule application, the string
        </textual><code class="po-atom e195 e195"><textual class="po-textual">(()())</textual></code><textual class="po-textual"> could be derived with indicated associations as follows, where each rule
      selects a </textual><code class="po-atom e196 e196"><textual class="po-textual">P</textual></code><textual class="po-textual"> in the string coming from the immediately preceding rule application,
      and substitutes it with the right hand side of the →: </textual><variablelist class="po-table e197 e197"><varlistentry class="po-record e198 e198"><term class="po-block e199 e199"><textual class="po-textual"> 0th step, start symbol</textual></term><listitem class="po-container e200 e200"><para class="po-block e201 e201"><textual class="po-textual">
              </textual><code class="po-atom e202 e202"><textual class="po-textual">P</textual></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e203 e203"><term class="po-block e204 e204"><textual class="po-textual">1st step, subordination</textual></term><listitem class="po-container e205 e205"><para class="po-block e206 e206"><textual class="po-textual">
              </textual><code class="po-atom e207 e207"><textual class="po-textual">(</textual><subscript class="po-atom e208 e208"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> P )</textual><subscript class="po-atom e209 e209"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e210 e210"><term class="po-block e211 e211"><textual class="po-textual">2nd step, coordination step</textual></term><listitem class="po-container e212 e212"><para class="po-block e213 e213"><textual class="po-textual">
              </textual><code class="po-atom e214 e214"><textual class="po-textual">(</textual><subscript class="po-atom e215 e215"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> P P )</textual><subscript class="po-atom e216 e216"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e217 e217"><term class="po-block e218 e218"><textual class="po-textual">3rd step, base step </textual></term><listitem class="po-container e219 e219"><para class="po-block e220 e220"><textual class="po-textual">
              </textual><code class="po-atom e221 e221"><textual class="po-textual">(</textual><subscript class="po-atom e222 e222"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> (</textual><subscript class="po-atom e223 e223"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e224 e224"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> P )</textual><subscript class="po-atom e225 e225"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual">
            </textual></para></listitem></varlistentry><varlistentry class="po-record e226 e226"><term class="po-block e227 e227"><textual class="po-textual">4th step, base step</textual></term><listitem class="po-container e228 e228"><para class="po-block e229 e229"><textual class="po-textual">
              </textual><code class="po-atom e230 e230"><textual class="po-textual">(</textual><subscript class="po-atom e231 e231"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> (</textual><subscript class="po-atom e232 e232"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e233 e233"><textual class="po-textual">3</textual></subscript><textual class="po-textual">(</textual><subscript class="po-atom e234 e234"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e235 e235"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> )</textual><subscript class="po-atom e236 e236"><textual class="po-textual">1</textual></subscript></code><textual class="po-textual">
            </textual></para></listitem></varlistentry></variablelist><textual class="po-textual"> After the fourth step, there are no non-terminals left in the expression, and
      the process halts. As can be seen from the last line, the structure that has been assigned to
      the expression is in exact accordance with the "nesting" convention. </textual></para><para class="po-block e237 e237"><textual class="po-textual">This confirms that rewrite grammars may be used for assigning structure as well as for
      checking well-formedness. However, one may very well use a rewrite grammar to check for
      well-formedness </textual><emphasis class="po-inline e238 e238" role="ital"><textual class="po-textual">without</textual></emphasis><textual class="po-textual"> using that same grammar for assigning
      structure. Moreover, there are other ways both of checking well-formedness and of assigning
      structure than using rewrite grammars.</textual></para><para class="po-block e239 e239"><textual class="po-textual">This should make clear that well-formedness is separate from structure. In the appendix we
      prove that well-formedness is preserved even when inserting randomly any left parenthesis,
      succeeded by another randomly inserted right parenthesis, into a well-formed string. </textual></para><para class="po-block e240 e240"><textual class="po-textual">We observe that the rule for matching of start and end tags in XML is identical to what we
      called a "nesting" convention for simple parenthetical expressions above. We also observe that
      this seems to be the "default" rule for matching of start and end tags in markup languages
      which allow overlap, such as O-XML. In such languages, however, deviations from the default
      rule are allowed, and they are signaled by the selection of generic identifiers for end tags. </textual></para><para class="po-block e241 e241"><textual class="po-textual">This explains why, as we noted above, the element structure of XML documents can be
      identified independently of information about the generic identifiers of start and end tags,
      whereas in O-XML this information is essential. In the following sections we will exploit
      these observations in order to look at alternate ways of describing the difference between
      nesting and overlap.</textual></para></section><section class="po-hcontainer e242 e242"><title class="po-block e243 e243"><textual class="po-textual">Document lattices</textual></title><para class="po-block e244 e244"><textual class="po-textual">We believe that lattice theory [</textual><xref class="po-milestone e245 e245" linkend="Grätzer1971"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] may usefully be
      applied to the construction of document models from marked-up documents. Lattice theory, like
      graph theory, is a way of reasoning over ordering relations. The theory has two components,
      one is a theory of order, the other of algebraic operations defined in terms of that order. In
      this section we will consider the order aspect, while algebraic operations will be discussed
      in the next section ("Algebraic characterization"). </textual></para><para class="po-block e246 e246"><textual class="po-textual">A lattice is a partially ordered set of objects, here referred to as nodes, which will
      provide the elements of document models. Not all nodes will find their way into a document
      model, only those that do may also be referred to as elements, in agreement with the use of
      this term in XML and XSLT. A key requirement for an ordered collection of nodes to constitute
      a lattice, is that there should be one unique largest and one unique smallest node in the
      collection. If there is only a largest (or smallest) node, it is what is called a
      semi-lattice. </textual><footnote class="po-popup e247 e247"><para class="po-block e248 e248"><textual class="po-textual">In the following, this distinction will not always be important, and we may
          occasionally refer to lattices and semi-lattices indiscriminately as "lattices".</textual></para></footnote><textual class="po-textual"> Examples of lattices so constructed abound. Any society ordered by social rank (or
      constitutional order) is a semi-lattice, with e.g president or monarch at the top. XML trees
      are semi lattices, with a root node on the top and text nodes at the bottom. </textual></para><para class="po-block e249 e249"><textual class="po-textual"> We analyze the stream of characters making up a document morphologically into a series of
      typed objects consisting of start tags, end tags, and simples.</textual><footnote class="po-popup e250 e250"><para class="po-block e251 e251"><textual class="po-textual">As noted above, the only difference between XML and O-XML is that O-XML allows
          overlapping elements. Therefore, element structures of some other markup languages, such
          as the suspend and resume tags of TexMecs, are not taken into consideration.</textual></para></footnote><textual class="po-textual"> The terms "start tag" and "end tag" should require no further explanation. We will
      used XML notation in specifying them. </textual></para><para class="po-block e252 e252"><textual class="po-textual">The term "simples" refers to PCDATA. Informally, we might say that a simple is whatever
      occurs between two tags. </textual><footnote class="po-popup e253 e253"><para class="po-block e254 e254"><textual class="po-textual">Excluding other markup constructs, such as comments, processing instructions or
          declarations, cf. the remark above. It does not matter whether the tags separating two
          simples are start tags, end tags, or a combination of start and end tags.</textual></para></footnote><textual class="po-textual">
    </textual></para><para class="po-block e255 e255"><textual class="po-textual">Empty elements are treated as a start tag followed by an end tag, without any intervening
      simple. </textual></para><para class="po-block e256 e256"><textual class="po-textual">We assume a linear order on the morphological constituents. This order is derived directly
      from the serialized form of the document.</textual></para><para class="po-block e257 e257"><textual class="po-textual">Consider the following XML sample document, D</textual><subscript class="po-atom e258 e258"><textual class="po-textual">1</textual></subscript><textual class="po-textual">:</textual><figure class="po-container e259 e259"><title class="po-block e260 e260"><textual class="po-textual">Sample document 1 (D</textual><subscript class="po-atom e261 e261"><textual class="po-textual">1</textual></subscript><textual class="po-textual">)</textual></title><para class="po-block e262 e262"><textual class="po-textual">
          </textual><code class="po-atom e263 e263"><textual class="po-textual">&lt;a&gt;X&lt;b&gt;Y&lt;/b&gt;&lt;c&gt;Z&lt;/c&gt;&lt;/a&gt;</textual></code><textual class="po-textual">
        </textual></para></figure><textual class="po-textual"> According to the definitions just given, this document is a linearly ordered set of
      token objects, consisting of the following morphological constituents with the properties
      indicated in this table, along with position indexes which, for our purpose, serve as token
      indexes for the types: </textual><table border="1" cellpadding="10" cellspacing="0" class="po-container e264 e264"><tr class="po-table e265 e265"><td class="po-block e266 e266"><textual class="po-textual">Constituent</textual></td><td class="po-block e267 e267"><textual class="po-textual">&lt;a&gt;</textual></td><td class="po-block e268 e268"><textual class="po-textual">X</textual></td><td class="po-block e269 e269"><textual class="po-textual">&lt;b&gt;</textual></td><td class="po-block e270 e270"><textual class="po-textual">Y</textual></td><td class="po-block e271 e271"><textual class="po-textual">&lt;/b&gt;</textual></td><td class="po-block e272 e272"><textual class="po-textual">&lt;c&gt;</textual></td><td class="po-block e273 e273"><textual class="po-textual">Z</textual></td><td class="po-block e274 e274"><textual class="po-textual">&lt;/c&gt;</textual></td><td class="po-block e275 e275"><textual class="po-textual">&lt;/a&gt;</textual></td></tr><tr class="po-table e276 e276"><td class="po-block e277 e277"><textual class="po-textual">Type</textual></td><td class="po-block e278 e278"><textual class="po-textual">start</textual></td><td class="po-block e279 e279"><textual class="po-textual">simple</textual></td><td class="po-block e280 e280"><textual class="po-textual">start</textual></td><td class="po-block e281 e281"><textual class="po-textual">simple</textual></td><td class="po-block e282 e282"><textual class="po-textual">end</textual></td><td class="po-block e283 e283"><textual class="po-textual">start</textual></td><td class="po-block e284 e284"><textual class="po-textual">simple</textual></td><td class="po-block e285 e285"><textual class="po-textual">end</textual></td><td class="po-block e286 e286"><textual class="po-textual">end</textual></td></tr><tr class="po-table e287 e287"><td class="po-block e288 e288"><textual class="po-textual">N</textual></td><td class="po-block e289 e289"><textual class="po-textual">1</textual></td><td class="po-block e290 e290"><textual class="po-textual">2</textual></td><td class="po-block e291 e291"><textual class="po-textual">3</textual></td><td class="po-block e292 e292"><textual class="po-textual">4</textual></td><td class="po-block e293 e293"><textual class="po-textual">5</textual></td><td class="po-block e294 e294"><textual class="po-textual">6</textual></td><td class="po-block e295 e295"><textual class="po-textual">7</textual></td><td class="po-block e296 e296"><textual class="po-textual">8</textual></td><td class="po-block e297 e297"><textual class="po-textual">9</textual></td></tr></table><textual class="po-textual">
    </textual></para><para class="po-block e298 e298"><textual class="po-textual">For any document D, let S be the set of all start tag tokens and E the set of all end tag
      tokens in the document. Take the Cartesian product (all possible combinations) of S and E, and
      subtract all pairs for which the position of the end tag does not succeed the start tag. This
      object then represents all the possibilities for a start tag to match up with an end tag. Add
      the simples, and name the result L(D). </textual></para><para class="po-block e299 e299"><textual class="po-textual">L(D</textual><subscript class="po-atom e300 e300"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) now consists of the following nodes: </textual><table border="1" cellpadding="15" cellspacing="0" class="po-container e301 e301"><tr class="po-table e302 e302"><td class="po-block e303 e303"><textual class="po-textual">&lt;a&gt;</textual></td><td class="po-block e304 e304"><textual class="po-textual">&lt;/b&gt;</textual></td><td class="po-block e305 e305"><textual class="po-textual">1</textual></td><td class="po-block e306 e306"><textual class="po-textual">5</textual></td></tr><tr class="po-table e307 e307"><td class="po-block e308 e308"><textual class="po-textual">&lt;a&gt;</textual></td><td class="po-block e309 e309"><textual class="po-textual">&lt;/c&gt;</textual></td><td class="po-block e310 e310"><textual class="po-textual">1</textual></td><td class="po-block e311 e311"><textual class="po-textual">8</textual></td></tr><tr class="po-table e312 e312"><td class="po-block e313 e313"><textual class="po-textual">&lt;a&gt;</textual></td><td class="po-block e314 e314"><textual class="po-textual">&lt;/a&gt;</textual></td><td class="po-block e315 e315"><textual class="po-textual">1</textual></td><td class="po-block e316 e316"><textual class="po-textual">9</textual></td></tr><tr class="po-table e317 e317"><td class="po-block e318 e318"><textual class="po-textual">&lt;b&gt;</textual></td><td class="po-block e319 e319"><textual class="po-textual">&lt;/b&gt;</textual></td><td class="po-block e320 e320"><textual class="po-textual">3</textual></td><td class="po-block e321 e321"><textual class="po-textual">5</textual></td></tr><tr class="po-table e322 e322"><td class="po-block e323 e323"><textual class="po-textual">&lt;b&gt;</textual></td><td class="po-block e324 e324"><textual class="po-textual">&lt;/c&gt;</textual></td><td class="po-block e325 e325"><textual class="po-textual">3</textual></td><td class="po-block e326 e326"><textual class="po-textual">8</textual></td></tr><tr class="po-table e327 e327"><td class="po-block e328 e328"><textual class="po-textual">&lt;b&gt;</textual></td><td class="po-block e329 e329"><textual class="po-textual">&lt;/a&gt;</textual></td><td class="po-block e330 e330"><textual class="po-textual">3</textual></td><td class="po-block e331 e331"><textual class="po-textual">9</textual></td></tr><tr class="po-table e332 e332"><td class="po-block e333 e333"><textual class="po-textual">&lt;c&gt;</textual></td><td class="po-block e334 e334"><textual class="po-textual">&lt;/c&gt;</textual></td><td class="po-block e335 e335"><textual class="po-textual">6</textual></td><td class="po-block e336 e336"><textual class="po-textual">8</textual></td></tr><tr class="po-table e337 e337"><td class="po-block e338 e338"><textual class="po-textual">&lt;c&gt;</textual></td><td class="po-block e339 e339"><textual class="po-textual">&lt;/a&gt;</textual></td><td class="po-block e340 e340"><textual class="po-textual">6</textual></td><td class="po-block e341 e341"><textual class="po-textual">9</textual></td></tr><tr class="po-table e342 e342"><td class="po-block e343 e343"><textual class="po-textual">X</textual></td><td class="po-block e344 e344"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e345 e345"><textual class="po-textual">2</textual></td><td class="po-block e346 e346"><textual class="po-textual">2</textual></td></tr><tr class="po-table e347 e347"><td class="po-block e348 e348"><textual class="po-textual">Y</textual></td><td class="po-block e349 e349"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e350 e350"><textual class="po-textual">4</textual></td><td class="po-block e351 e351"><textual class="po-textual">4</textual></td></tr><tr class="po-table e352 e352"><td class="po-block e353 e353"><textual class="po-textual">Z</textual></td><td class="po-block e354 e354"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></td><td class="po-block e355 e355"><textual class="po-textual">7</textual></td><td class="po-block e356 e356"><textual class="po-textual">7</textual></td></tr></table><textual class="po-textual">
    </textual></para><para class="po-block e357 e357"><textual class="po-textual">The reader may be puzzled by the fact that we include non-matching pairs of tags, i.e.
      nodes with start and end tags with different generic identifiers (GIs), among the nodes of the
      lattice. This is simply because the point of the exercise at this stage is to see how far we
      are able to build document models without taking the generic identifiers of tags into
      consideration.</textual></para><para class="po-block e358 e358"><textual class="po-textual"> We define a hierarchical order relation between nodes in terms of
      </textual><emphasis class="po-inline e359 e359"><textual class="po-textual">containment</textual></emphasis><textual class="po-textual"> as follows: A node x is larger than a node y if and only if
      the start position of x is smaller or equal to that of y, and the end position of x is greater
      or equal to that of y (viewed as strings the larger, or higher, node contains the other). </textual><footnote class="po-popup e360 e360"><para class="po-block e361 e361"><textual class="po-textual">This would mean that nodes contain each other if their start and end positions are
          identical, -- however this situation cannot occur in the current context, since a position
          index functions as token index.</textual></para></footnote><textual class="po-textual"> This relation is asymmetric and transitive, so it is a partial order. </textual><footnote class="po-popup e362 e362"><para class="po-block e363 e363"><textual class="po-textual"> We observe that these concepts are parallel to the concepts of sequence and range of
          Core Range Algebra [</textual><xref class="po-milestone e364 e364" linkend="Nicol2002a"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. There is a connection between the
          approach adopted here, and Core Range Algebra, but we leave a discussion of that
          connection for future work.</textual></para></footnote></para><para class="po-block e365 e365"><textual class="po-textual">With this order in place, L(D</textual><subscript class="po-atom e366 e366"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) as given in the table above is a semi-lattice. It
      has a top node, namely the pair consisting of the first start tag and last end tag
        </textual><code class="po-atom e367 e367"><textual class="po-textual">&lt;a&gt;₁&lt;/a&gt;₉</textual></code><textual class="po-textual">. It also has a set of minimal nodes, the
      simples. Each pair of tag tokens is a node in the semilattice. Lattice structures are
      displayed using Hasse-diagrams (familiar from tree structures).</textual><orderedlist class="po-table e368 e368"><listitem class="po-container e369 e369"><para class="po-block e370 e370"><textual class="po-textual">Nodes are positioned vertically according to their position in the hierarchy, with
            the more inclusive nodes at the top and the less inclusive further down. </textual></para></listitem><listitem class="po-container e371 e371"><para class="po-block e372 e372"><textual class="po-textual">Nodes at the same vertical level are positioned from left to right according to
            their linear order in the document. </textual></para></listitem></orderedlist><textual class="po-textual">
    </textual></para><para class="po-block e373 e373"><textual class="po-textual">The lattice structure for L(D</textual><subscript class="po-atom e374 e374"><textual class="po-textual">1</textual></subscript><textual class="po-textual">): </textual><figure class="po-container e375 e375" xml:id="L" xreflabel="Lattice         L(D₁)"><title class="po-block e376 e376"><textual class="po-textual">Lattice L</textual></title><mediaobject class="po-container e377 e377"><imageobject class="po-container e378 e378"><imagedata class="po-meta e379 e379" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-001.png" format="png" width="330px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
    </textual></para><para class="po-block e380 e380"><textual class="po-textual">As mentioned, the hierarchical order is transitive. According to the conventions of
      diagrams like these, however, lines are drawn only between nodes immediately ordered. </textual></para><para class="po-block e381 e381"><textual class="po-textual">Before we proceed, we need to define a relation we call </textual><emphasis class="po-inline e382 e382" role="ital"><textual class="po-textual">relatives</textual></emphasis><textual class="po-textual">: Two nodes are relatives if they share a token start or end tag. This is
      a reflexive, symmetric and non-transitive relation. </textual></para><para class="po-block e383 e383"><textual class="po-textual">We also need to define a concept which has already been introduced implicitly, the concept
      of a </textual><emphasis class="po-inline e384 e384" role="ital"><textual class="po-textual">minimal node</textual></emphasis><textual class="po-textual">: A node is minimal if it is lowest in the
      hierarchy, i.e. if it contains no other node.</textual></para></section><section class="po-hcontainer e385 e385"><title class="po-block e386 e386"><textual class="po-textual">Building document models from lattices</textual></title><section class="po-hcontainer e387 e387"><title class="po-block e388 e388"><textual class="po-textual">Modeling documents without overlap</textual></title><para class="po-block e389 e389"><textual class="po-textual">In what follows, we will show how what we may call a "standard" document model can be
        built on the basis of the lattice. In building this model, we will rely on distinguishing
        between nodes only in terms of the morphology introduced earlier, i.e. on the basis of which
        start tags, end tags, or simple tokens they contain. In particular, we do </textual><emphasis class="po-inline e390 e390" role="ital"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> take the GIs of tags into consideration in the building of this
        model. </textual></para><para class="po-block e391 e391"><textual class="po-textual">A document model for D</textual><subscript class="po-atom e392 e392"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> from the lattice L(D</textual><subscript class="po-atom e393 e393"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) is built through a
        number of steps by selecting subsets from L(D</textual><subscript class="po-atom e394 e394"><textual class="po-textual">1</textual></subscript><textual class="po-textual">). Hence, the model building process
        can be viewed as a filtering process. We start from the bottom of the lattice and identify
        all the lowest-level minimal nodes. We copy these minimal nodes, i.e. the nodes labeled
        X₂, Y₄ and Z₇, from L and transfer them to a subset of L(D</textual><subscript class="po-atom e395 e395"><textual class="po-textual">1</textual></subscript><textual class="po-textual">)
        which we call S</textual><subscript class="po-atom e396 e396"><textual class="po-textual">0</textual></subscript><textual class="po-textual">. </textual><figure class="po-container e397 e397" xml:id="D0" xreflabel="subset           S₀"><title class="po-block e398 e398"><textual class="po-textual">Subset S</textual><subscript class="po-atom e399 e399"><textual class="po-textual">0</textual></subscript></title><para class="po-block e400 e400"><textual class="po-textual">
            </textual><code class="po-atom e401 e401"><textual class="po-textual">X₂ Y₄ Z₇</textual></code><textual class="po-textual">
          </textual></para></figure><textual class="po-textual"> We then delete these minimal nodes from L(D</textual><subscript class="po-atom e402 e402"><textual class="po-textual">1</textual></subscript><textual class="po-textual">), </textual><footnote class="po-popup e403 e403"><para class="po-block e404 e404"><textual class="po-textual">These minimal nodes happen to have no relatives, otherwise we would have had to
            delete those as well. See next step.</textual></para></footnote><textual class="po-textual"> and call the result L</textual><subscript class="po-atom e405 e405"><textual class="po-textual">0</textual></subscript><textual class="po-textual">. </textual><figure class="po-container e406 e406" xml:id="L0" xreflabel="Lattice L0"><title class="po-block e407 e407"><textual class="po-textual">Subset L</textual><subscript class="po-atom e408 e408"><textual class="po-textual">0</textual></subscript></title><mediaobject class="po-container e409 e409"><imageobject class="po-container e410 e410"><imagedata class="po-meta e411 e411" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-002.png" format="png" width="330px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e412 e412"><textual class="po-textual">We repeat the process of selecting minimal nodes, now from L</textual><subscript class="po-atom e413 e413"><textual class="po-textual">0</textual></subscript><textual class="po-textual">,
        and add them to S</textual><subscript class="po-atom e414 e414"><textual class="po-textual">0</textual></subscript><textual class="po-textual">, naming the result S</textual><subscript class="po-atom e415 e415"><textual class="po-textual">1</textual></subscript><textual class="po-textual">. In
        this case the minimal nodes are those labeled &lt;b&gt;₃&lt;/b&gt;₅ and
        &lt;c&gt;₆&lt;/c&gt;₈. S</textual><subscript class="po-atom e416 e416"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> inherits the order from L, and looks like
        this: </textual><figure class="po-container e417 e417" xml:id="S1" xreflabel="Lattice S1"><title class="po-block e418 e418"><textual class="po-textual">Subset S</textual><subscript class="po-atom e419 e419"><textual class="po-textual">1</textual></subscript></title><mediaobject class="po-container e420 e420"><imageobject class="po-container e421 e421"><imagedata class="po-meta e422 e422" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-003.png" format="png" width="310px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual"> Next, we delete these minimal nodes, </textual><emphasis class="po-inline e423 e423" role="ital"><textual class="po-textual">as well as all their
          relatives</textual></emphasis><textual class="po-textual">, from L</textual><subscript class="po-atom e424 e424"><textual class="po-textual">0</textual></subscript><textual class="po-textual">, and call the result
        L</textual><subscript class="po-atom e425 e425"><textual class="po-textual">1</textual></subscript><textual class="po-textual">. </textual></para><para class="po-block e426 e426"><textual class="po-textual">Removal of the relatives assures that a tag can only enter into a relationship once. As
        soon as a node is selected for the model, neither the start nor the end tag of that node can
        enter into another node of the model. The relatives of &lt;b&gt;₃&lt;/b&gt;₅
        in L(D</textual><subscript class="po-atom e427 e427"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) are the following nodes </textual><figure class="po-container e428 e428" xml:id="rel1" xreflabel="relatives           b/b"><title class="po-block e429 e429"><textual class="po-textual">Relatives of &lt;b&gt;₃&lt;/b&gt;₅</textual></title><mediaobject class="po-container e430 e430"><imageobject class="po-container e431 e431"><imagedata class="po-meta e432 e432" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-004.png" format="png" width="250px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
        </textual><footnote class="po-popup e433 e433"><para class="po-block e434 e434"><textual class="po-textual">Remember that the relatives of a node are defined as the set of other nodes with the
            same start or end tag </textual><emphasis class="po-inline e435 e435" role="ital"><textual class="po-textual">token</textual></emphasis><textual class="po-textual">. If there had been further
            nodes with tokens of the start tag &lt;b&gt; or the end tag &lt;/b&gt; in the lattice,
            they would still not have been relatives of &lt;b&gt;₃&lt;/b&gt;₅. In
            other words, we are still ignoring information derivable from GIs.</textual></para></footnote><textual class="po-textual">
      </textual></para><para class="po-block e436 e436"><textual class="po-textual">L</textual><subscript class="po-atom e437 e437"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> looks like this:</textual><figure class="po-container e438 e438" xml:id="L1" xreflabel="Lattice L1"><title class="po-block e439 e439"><textual class="po-textual">Lattice L</textual><subscript class="po-atom e440 e440"><textual class="po-textual">1</textual></subscript></title><para class="po-block e441 e441"><textual class="po-textual">&lt;a&gt;₁&lt;/a&gt;₉</textual></para></figure><textual class="po-textual">
      </textual></para><para class="po-block e442 e442"><textual class="po-textual">As L</textual><subscript class="po-atom e443 e443"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> only contains the single node
        &lt;a&gt;₁&lt;/a&gt;₉ a repetition of the step above, which copies this
        minimal node to S</textual><subscript class="po-atom e444 e444"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> resulting in S</textual><subscript class="po-atom e445 e445"><textual class="po-textual">2</textual></subscript><textual class="po-textual">, will
        terminate the process. </textual><footnote class="po-popup e446 e446"><para class="po-block e447 e447"><textual class="po-textual">The above process can be defined inductively using the functions
            </textual><emphasis class="po-inline e448 e448"><textual class="po-textual">min</textual></emphasis><textual class="po-textual"> that selects the minimal nodes from a lattice, and
              </textual><emphasis class="po-inline e449 e449"><textual class="po-textual">rel</textual></emphasis><textual class="po-textual"> which selects the relatives of its argument. Recall that the
            latter relation is reflexive, which means that rel(S) has S as a subset. The induction
            stops when </textual><emphasis class="po-inline e450 e450"><textual class="po-textual">L</textual></emphasis><subscript class="po-atom e451 e451"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is empty. </textual><variablelist class="po-table e452 e452"><varlistentry class="po-record e453 e453"><term class="po-block e454 e454"><textual class="po-textual">Base step for S:</textual></term><listitem class="po-container e455 e455"><para class="po-block e456 e456"><textual class="po-textual">S</textual><subscript class="po-atom e457 e457"><textual class="po-textual">0</textual></subscript><textual class="po-textual"> =
                  </textual><emphasis class="po-inline e458 e458"><textual class="po-textual">min</textual></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e459 e459"><textual class="po-textual">L</textual></emphasis><textual class="po-textual">)</textual></para></listitem></varlistentry><varlistentry class="po-record e460 e460"><term class="po-block e461 e461"><textual class="po-textual">Base step for L:</textual></term><listitem class="po-container e462 e462"><para class="po-block e463 e463"><emphasis class="po-inline e464 e464"><textual class="po-textual"> L</textual><subscript class="po-atom e465 e465"><textual class="po-textual">0</textual></subscript></emphasis><textual class="po-textual"> = </textual><emphasis class="po-inline e466 e466"><textual class="po-textual">L</textual></emphasis><textual class="po-textual"> -
                      rel(S</textual><subscript class="po-atom e467 e467"><textual class="po-textual">0</textual></subscript><textual class="po-textual">)</textual></para></listitem></varlistentry><varlistentry class="po-record e468 e468"><term class="po-block e469 e469"><textual class="po-textual">Induction step for S:</textual></term><listitem class="po-container e470 e470"><para class="po-block e471 e471"><textual class="po-textual">S</textual><subscript class="po-atom e472 e472"><textual class="po-textual">i+1</textual></subscript><textual class="po-textual"> =
                        </textual><emphasis class="po-inline e473 e473"><textual class="po-textual">min</textual></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e474 e474"><textual class="po-textual">L</textual><subscript class="po-atom e475 e475"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">)
                    ∪ S</textual><subscript class="po-atom e476 e476"><textual class="po-textual">i</textual></subscript></para></listitem></varlistentry><varlistentry class="po-record e477 e477"><term class="po-block e478 e478"><textual class="po-textual">Induction step for L:</textual></term><listitem class="po-container e479 e479"><para class="po-block e480 e480"><emphasis class="po-inline e481 e481"><textual class="po-textual">L</textual><subscript class="po-atom e482 e482"><textual class="po-textual">i+1</textual></subscript></emphasis><textual class="po-textual"> =
                      </textual><emphasis class="po-inline e483 e483"><textual class="po-textual">L</textual><subscript class="po-atom e484 e484"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> -
                    rel(D</textual><subscript class="po-atom e485 e485"><textual class="po-textual">i</textual></subscript><textual class="po-textual">) </textual></para></listitem></varlistentry></variablelist><textual class="po-textual">
          </textual></para><para class="po-block e486 e486"><textual class="po-textual">This method bears a resemblance to cascaded finite state transducers, used in
            natural language processing </textual><xref class="po-milestone e487 e487" linkend="abney97"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. A finite state transducer
            F, may scan a string over the symbols "(" and ")" replacing each occurrence of "()" (i.e
            the innermost, or minimal elements) with the empty string. Then repeat the process on
            the output (the cascading). When nothing is left, the process stops and the parentheses
            that are removed together can be taken to match. Even though the language over
            parentheses itself is context free, a cascaded approach using finite state transducers
            can in principle analyze it.</textual></para></footnote><textual class="po-textual"> There are now no more nodes to select, and the process stops with the following
        candidate model M of D</textual><subscript class="po-atom e488 e488"><textual class="po-textual">1</textual></subscript><textual class="po-textual">: </textual><figure class="po-container e489 e489" xml:id="D2" xreflabel="Lattice D2"><title class="po-block e490 e490"><textual class="po-textual">subset S</textual><subscript class="po-atom e491 e491"><textual class="po-textual">2</textual></subscript><textual class="po-textual">=M(D</textual><subscript class="po-atom e492 e492"><textual class="po-textual">1</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e493 e493"><imageobject class="po-container e494 e494"><imagedata class="po-meta e495 e495" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-005.png" format="png" width="310px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></para><para class="po-block e496 e496"><textual class="po-textual">What we find in S</textual><subscript class="po-atom e497 e497"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> is, mutatis mutandis, identical to the
        "standard" XML document tree for the document we started with: </textual><figure class="po-container e498 e498" xml:id="D3" xreflabel="Lattice D3"><title class="po-block e499 e499"><textual class="po-textual">Standard document model of D</textual><subscript class="po-atom e500 e500"><textual class="po-textual">1</textual></subscript></title><mediaobject class="po-container e501 e501"><imageobject class="po-container e502 e502"><imagedata class="po-meta e503 e503" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-006.png" format="png" width="160px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e504 e504"><textual class="po-textual"> While GIs have been left out of consideration during the building, the candidate model
        will also be subjected to a well-formedness check: </textual><emphasis class="po-inline e505 e505"><textual class="po-textual">For each node in the model, the
          GI of the start tag must be identical to the GI of the end tag.</textual></emphasis><textual class="po-textual">. For this
        model, this is the case. </textual></para><para class="po-block e506 e506"><textual class="po-textual">We conclude that with the method described here, lattices can be used to generate
        "standard" models of XML documents in the form of conventional XML document trees. Recall
        that we may also refer to nodes that are members of the model as elements. The claim that these constitue trees will be
        substantiated below, where we will show that the model building procedure indeed
        guarantees production of tree structures only.</textual></para></section><section class="po-hcontainer e507 e507"><title class="po-block e508 e508"><textual class="po-textual">Modeling documents with overlap</textual></title><para class="po-block e509 e509"><textual class="po-textual">In this section, we will show that lattices can also be used in order to generate models
        of O-XML documents in the form of GODDAGs [</textual><xref class="po-milestone e510 e510" linkend="Sperberg-McQueenandHuitfeldt2000"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Consider the following O-XML sample document, D</textual><subscript class="po-atom e511 e511"><textual class="po-textual">2</textual></subscript><textual class="po-textual">: </textual><figure class="po-container e512 e512"><title class="po-block e513 e513"><textual class="po-textual">Sample document 2 (D</textual><subscript class="po-atom e514 e514"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></title><para class="po-block e515 e515"><textual class="po-textual">
            </textual><code class="po-atom e516 e516"><textual class="po-textual">&lt;a&gt;&lt;b&gt;X&lt;c&gt;Y&lt;/b&gt;Z&lt;/c&gt;&lt;/a&gt;</textual></code><textual class="po-textual">
          </textual></para></figure><textual class="po-textual">
      </textual></para><para class="po-block e517 e517"><textual class="po-textual">The lattice L(D</textual><subscript class="po-atom e518 e518"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) for this document is as follows (while we have used capital M
        to designate document models for XML documents, we will use capital O to designate document
        models for O-XML models): </textual><figure class="po-container e519 e519" xml:id="O" xreflabel="Lattice O"><title class="po-block e520 e520"><textual class="po-textual">Lattice L(D</textual><subscript class="po-atom e521 e521"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e522 e522"><imageobject class="po-container e523 e523"><imagedata class="po-meta e524 e524" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-007.png" format="png" width="330px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e525 e525"><textual class="po-textual">An application of the method described in the previous section to this lattice, yields
        the following candidate model: </textual><figure class="po-container e526 e526" xml:id="P" xreflabel="Lattice P"><title class="po-block e527 e527"><textual class="po-textual">Candidate model of D</textual><subscript class="po-atom e528 e528"><textual class="po-textual">2</textual></subscript><textual class="po-textual">, M(D</textual><subscript class="po-atom e529 e529"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e530 e530"><imageobject class="po-container e531 e531"><imagedata class="po-meta e532 e532" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-008.png" format="png" width="170px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e533 e533"><textual class="po-textual">It easy enough to see that something must have gone wrong here, as there is disagreement
        between the GIs of the start and end tags for the nodes &lt;b&gt;₂&lt;/c&gt;₈ and
        &lt;c&gt;₄&lt;/b&gt;₆. Now D</textual><subscript class="po-atom e534 e534"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> is not a well-formed XML document, and we have used the
        same procedure for generating M(D</textual><subscript class="po-atom e535 e535"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) from D</textual><subscript class="po-atom e536 e536"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> (which is a well-formed O-XML document
        with overlap, but not a well-formed XML document) as we did for building M(D</textual><subscript class="po-atom e537 e537"><textual class="po-textual">1</textual></subscript><textual class="po-textual">) from
        D</textual><subscript class="po-atom e538 e538"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> (which is a well-formed XML document). The method will build document models for
        well-formed as well as ill-formed documents. However, the ill-formedness of D</textual><subscript class="po-atom e539 e539"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> will be
        captured by the well-formedness condition introduced above.</textual></para><para class="po-block e540 e540"><textual class="po-textual">In constructing O(D</textual><subscript class="po-atom e541 e541"><textual class="po-textual">2</textual></subscript><textual class="po-textual">), it suffices to introduce one single modification to the
        procedure described in the previous section: Before performing any other operations on
        L(D</textual><subscript class="po-atom e542 e542"><textual class="po-textual">2</textual></subscript><textual class="po-textual">), we remove all nodes that have start and end tags with different GIs. Once
        this rule is introduced, the application of the procedure produces the following candidate
        model: </textual><figure class="po-container e543 e543" xml:id="Q" xreflabel="Lattice           Q"><title class="po-block e544 e544"><textual class="po-textual">Subset O(D</textual><subscript class="po-atom e545 e545"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e546 e546"><imageobject class="po-container e547 e547"><imagedata class="po-meta e548 e548" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-009.png" format="png" width="280px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e549 e549"><textual class="po-textual">What we find here is, mutatis mutandis, identical to the GODDAG document model of the
        document: </textual><figure class="po-container e550 e550" xml:id="R" xreflabel="Lattice R"><title class="po-block e551 e551"><textual class="po-textual">GODDAG model of D</textual><subscript class="po-atom e552 e552"><textual class="po-textual">2</textual></subscript></title><mediaobject class="po-container e553 e553"><imageobject class="po-container e554 e554"><imagedata class="po-meta e555 e555" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-010.png" format="png" width="270px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e556 e556"><textual class="po-textual">We conclude that with the method described here, lattices can also be used for
        generating document models of O-XML documents with overlap in the form of GODDAGs. Since the
        extra rule that we introduced in this section does not affect the result for XML documents,
        one and the same method can be used for generating XML trees from XML documents and GODDAGs
        from O-XML documents. In other words, if D is a well-formed XML document M(D)=O(D). However,
        O(D) does not have any built-in well-formedness check. </textual></para></section><section class="po-hcontainer e557 e557"><title class="po-block e558 e558"><textual class="po-textual">Well-formedness</textual></title><para class="po-block e559 e559"><textual class="po-textual">In the previous section we noticed, in passing, that of the proposed method for building
        models from XML and O-XML documents, only M-models carry a well-formedness constraint. By
        introducing the rule that all nodes with different GIs on start and end tags should be
        deleted from the lattice, we effectively made sure that O(D) fulfills one well-formedness
        constraint on documents. The difference between the M- and O-constructions is subtle: The
        M-construction will always produce trees, while the O-construction will not necessarily
        produce trees. That issue is discussed in a subsequent section. The question to be asked
        here is: Can document lattices be used to capture the full set of well-formedness
        constraints? </textual></para><para class="po-block e560 e560"><textual class="po-textual">The model building in itself may work even if document D starts with and end tag or ends
        with a start tag. The process will just ignore them. If they are taken into account as e.g.
        simples, the requirement that L(D) is a lattice will rule them out, since they will be
        ordered on the same level as the widest start tag/end tag pair. </textual></para><para class="po-block e561 e561"><textual class="po-textual">Another source of ill-formedness stems from unbalanced parenthesis. For M(D) this is
        taken care of by requiring that the top node of L(D) is also the top node of M(D). The
        reason for this is that the top node of L(D) will be the widest start/end tag pair. If that
        pair is not a node it will be because all the tags are used up, so to speak, before it is
        reached, as the model building moves inside out. Consider this ill-formed document</textual><blockquote class="po-container e562 e562"><para class="po-block e563 e563"><textual class="po-textual">
            </textual><code class="po-atom e564 e564"><textual class="po-textual">&lt;a&gt;₁&lt;b&gt;₂&lt;/b&gt;₃</textual></code><textual class="po-textual">
          </textual></para></blockquote><textual class="po-textual"> The top node for L(D) is </textual><code class="po-atom e565 e565"><textual class="po-textual">&lt;a&gt;₁&lt;/b&gt;₃</textual></code><textual class="po-textual">
        but this node will be removed from M(D) as a relative of the minimal
          </textual><code class="po-atom e566 e566"><textual class="po-textual">&lt;b&gt;₂&lt;/b&gt;₃</textual></code><textual class="po-textual">. </textual></para><para class="po-block e567 e567"><textual class="po-textual">For O(D) this doesn't work since the removal process looks at tag GI, so if the document
        is this </textual><blockquote class="po-container e568 e568"><para class="po-block e569 e569"><textual class="po-textual">
            </textual><code class="po-atom e570 e570"><textual class="po-textual">&lt;a&gt;₁&lt;b&gt;₂&lt;/a&gt;₃</textual></code><textual class="po-textual">
          </textual></para></blockquote><textual class="po-textual"> it is &lt;b&gt;₂&lt;/a&gt;₃ which is left out. So we cannot
        pin the requirement on the top node. However, we take it that for any document, including O-XML,
        that each tag should find a partner. Clearly &lt;b&gt;₂ in this document does
        not have one. </textual></para><para class="po-block e571 e571"><textual class="po-textual">We conjecture that, in addition to the already introduced rule of deleting nodes with
        non-matching GIs on start and end tags, the following rule should suffice to capture all
        remaining well-formedness constraints on O-XML: </textual></para><para class="po-block e572 e572"><textual class="po-textual"> For any x.start or x.end in L(D) there must be an element E in M(D) or O(D) such that
        E.start=x.start or E.end=x.end.</textual></para><para class="po-block e573 e573"><textual class="po-textual">This should make sure that every tag in L(D) finds a match in M(D) or O(D). Moreover, ff
        M(D) is constructed without first removing non macthin GIs, the GI agreement constraint
        mentioned above will rule out any overlap.</textual></para><para class="po-block e574 e574"><textual class="po-textual">If this conjecture is correct, it means that checking for well-formedness as well as
        asignment of document structure can be accomplished by using document lattices, and without
        the use of rewrite grammars.</textual></para></section><section class="po-hcontainer e575 e575"><title class="po-block e576 e576"><textual class="po-textual">Concluding remarks</textual></title><para class="po-block e577 e577"><textual class="po-textual">We believe that the proposed use of document lattices for building document models from
        marked up documents provides a unified account of the assignment of structure to documents
        with and without overlap. If our conjecture about well-formedness is correct, this account
        is also able to capture all well-formedness constraints on both types of markup.</textual></para><para class="po-block e578 e578"><textual class="po-textual">The proposed method exploits the observations made about possible alternative
        conventions for the assignment of structure to simple parenthetical expressions made
        earlier. In building models for both kinds of documents, XML and O-XML, we rely on the
        "nesting" convention. The difference is that for XML documents, information about the GIs of
        tags may be ignored, whereas for O-XML documents this information is essential. </textual></para><para class="po-block e579 e579"><textual class="po-textual">In introducing O-XML, we said that the only difference between XML and O-XML is that
        O-XML allows overlapping elements, whereas XML does not. What about so-called self-overlap,
        discontinuous elements and virtual elements, mechanisms which have been proposed in for
        example TexMECS, LMNL and other alternative markup languages? We believe that the handling
        of self-overlap with document lattices is just a question of adjusting the basic morphology.
        Whether, or to what extent, document lattices can also be used for markup languages with
        discontinuous or virtual elements we simply do not know.</textual></para></section></section><section class="po-hcontainer e580 e580"><title class="po-block e581 e581"><textual class="po-textual">Algebraic characterization</textual></title><section class="po-hcontainer e582 e582"><title class="po-block e583 e583"><textual class="po-textual">Meet and join</textual></title><para class="po-block e584 e584"><textual class="po-textual">The meet and join operations are a central part of lattice theory. In our context, they
        may serve to characterize the difference between the models for XML and O-XML, and their
        relationship to the lattice L. </textual></para><para class="po-block e585 e585"><textual class="po-textual"> The meet operation selects the largest node below its operands, while join selects the
        smallest above its operands. A requirement for lattices is that any two nodes have a meet
        and a join. </textual></para><para class="po-block e586 e586"><textual class="po-textual">Since we are dealing not primarily with lattices in the strict sense, but mostly with
        semi-lattices, we need to lighten this requirement for the meet operation: two nodes are
        allowed not to have any meet if they do not have any common nodes below them at all. </textual></para><para class="po-block e587 e587"><textual class="po-textual">We indicate the vertical ordering of nodes in a lattice by using the symbols ⊒
        and ⊑, so that the opening is faced towards the larger node. In other words,
        x⊒y means that x is higher in the lattice than y, while x⊑y means that y
        is higher than x.</textual></para><para class="po-block e588 e588"><textual class="po-textual">We can now define the meet operation, indicated by the operator ⊓, and the
        join operation, indicated by the operator ⊔, as follows: </textual><variablelist class="po-table e589 e589"><varlistentry class="po-record e590 e590"><term class="po-block e591 e591"><textual class="po-textual">meet:</textual></term><listitem class="po-container e592 e592"><para class="po-block e593 e593"><textual class="po-textual">x⊓y=z iff, for all u, whenever u⊑x and u⊑y then
                u⊑z. </textual></para></listitem></varlistentry><varlistentry class="po-record e594 e594"><term class="po-block e595 e595"><textual class="po-textual">join:</textual></term><listitem class="po-container e596 e596"><para class="po-block e597 e597"><textual class="po-textual">x⊔y=z iff, for all u, whenever u⊒x and u⊒y then
                u⊒z. </textual></para></listitem></varlistentry></variablelist><textual class="po-textual">
      </textual></para><para class="po-block e598 e598"><textual class="po-textual">The meet and join operations can also be characterized in terms of tag configurations.
        Let the start and end tag for a node x be written as x.start and x.end. The meet operation
        can be captured by saying that whenever z=x⊓y then z.start=max(x.start, y.start)
        and z.end=min(x.end,y.end). Similarly, the join operation can be captured by saying that
        whenever z=x⊔y then z.start=min(x.start,y.start) and z.end=max(x.end, y.end). </textual><footnote class="po-popup e599 e599"><para class="po-block e600 e600"><textual class="po-textual"> To see that this is so, consider first the case of ⊓. Any node that is
            below x must have a start tag occurring after or at x.start and an end tag at or before
            x.end, and similarly for any node below y. Thus, any node u, such that u⊑x and
            u⊑y, must satisfy that u.start ≥ x.start and that u.start ≥
            y.start, and both of u.end ≤ x.end and u.end ≤y.end. Consequently, any
            such u will therefore also satisfy u⊑z so z must be equal to x⊓y in
            accordance with the definition for ⊓. A similar argument can be applied to
            ⊔. As simples are minimal, they cannot have a meet, while their join will be
            discussed below.</textual></para></footnote><textual class="po-textual">
      </textual></para></section><section class="po-hcontainer e601 e601"><title class="po-block e602 e602"><textual class="po-textual">Are M(D) and O(D) lattices?</textual></title><para class="po-block e603 e603"><textual class="po-textual">The first step of the method we have proposed consists in constructing, on the basis of
        a marked up document D, a lattice L(D). The construction method ensures that L(D) always is
        a lattice, i.e. that it has a unique largest node, that every pair of nodes has a join, and
        that every pair of non-minimal nodes has a meet. The document models, M(D) for XML documents
        and O(D) for O-XML documents, however, are derived from L(D) through a filtering process.
        Therefore, it is appropriate to ask whether M(D) and O(D) are also lattices, or not. </textual></para><para class="po-block e604 e604"><textual class="po-textual">In this section we will argue that M(D) is not only guaranteed to be a lattice, it is
        also guaranteed to be a tree. O(D), however, is obviously not guaranteed to be a tree, but
        it is also not guaranteed to be a lattice.</textual></para><para class="po-block e605 e605"><textual class="po-textual"> We have earlier observed the similarity between the document model M(D) and XML trees.
        The following argument will show that this is necessarily the case for any model M(D). In
        XML, whenever both x.start&lt;y.start and y.start&lt;x.end is true, it is safe to conclude
        that y.end&lt;x.end (in other words, there is no overlap). This is also true for the
        relationships in M(D). </textual></para><para class="po-block e606 e606"><textual class="po-textual"> To see why, consider x and y, both elements of a model M(D), with the assumption that
        x.start&lt;y.start and y.start&lt;x.end. We want to show that it will always be the case
        that y.end&lt;x.end under these circumstances. So suppose for contradiction that this is not
        so, and that x.end&lt;y.end. Then there exists a node z=(y.start,x.end) in L(D), since
        y.start&lt;x.end (recall that L(D) contains all pairs of start tags followed by end tags).
        It is also clear that z is not a member of M(D). Further, from z's definition, we note that
        z is smaller than both x and y, and also a relative of both. This is enough to contradict
        the selection assumption for M(D): if z is smaller than x, then, since z=(y.start, x.end), z
        cannot have been removed in the model building process as a candidate for x, because any
        node is below all the relatives it removes, and by assumption z&lt;x . So z must then have
        been removed as candidate for M(D) considered as a relative of y. But this contradicts the
        assumption that z&lt;y, since y&lt;z for z to be removed. We can therefore conclude that
        assuming that x.end&lt;y.end is not tenable, and therefore that y.end&lt;x.end. This means
        that if ⊓ is confined to elements of M(D), u⊓v is either one of u or v (if it
        has a value at all); if u strictly comes after v, they would not share any nodes. A
        consequence of this is that any element x must have a unique parent (if it has one at all):
        if both u and v where distinct parents in M(D) (i.e. smallest nodes above x), x⊑u and
        x⊑v, which would mean that x⊑u⊓v=u (or v). We can therefore conclude that
        M(D) is a tree. </textual></para><para class="po-block e607 e607"><textual class="po-textual"> The above argument does not hold for O(D) which models overlap structures. The example
        GODDAG in </textual><xref class="po-milestone e608 e608" linkend="R"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> shows that the structure is not a tree, as the simple Y has
        two parents. Also, the join may be undefined when restricted to O(D) (that is, redefined
        within O(D) and not computed within L(D)). In O(D) two elemnts do not necessarily have a
        unique smallest dominating element, even if there are elements above them. For example, two
        elements x and y may be dominated by elementss a and b, and neither of these dominate the
        other if they overlap. In this example it is therefore impossible to select a smallest
        dominating element to serve as the join of x and y. </textual></para></section><section class="po-hcontainer e609 e609"><title class="po-block e610 e610"><textual class="po-textual">Closure</textual></title><para class="po-block e611 e611"><textual class="po-textual"> In this section and the ones that follow, we will look at the differences between O-
        and M-models in terms of meet and join. This also brings us to regard M(D) and O(D) as
        subsets of L(D), and consider ways of adding nodes to them in order to make them satisfy
        certain requirements. </textual></para><para class="po-block e612 e612"><textual class="po-textual"> When M(D) and O(D) are seen as subsets of L(D), with meet and join computed in L(D),
        there are a number of differences between them that were not captured above, when we limited
        ourselves to look at their structures only. Our first question is whether the meet and join
        operations are closed in M(D) and O(D). (An operation is closed in a subset A if the result
        of the operation stays in A when operating on elements of A.) </textual></para><para class="po-block e613 e613"><textual class="po-textual">One defining difference between O(D) and M(D) in terms of closure is that while the meet
        operation is closed in M(D), it is not in O(D). As we saw above, given two elements x and y
        in M(D), their meet is either x or y, which is still in M(D). If u and v in O(D) are
        distinct and overlapping, which means that u.start&lt;v.start while u.end&lt;v.end, their
        meet is w=(v.start,u.end), which is not an element of O(D). (It is a node in L(D), but since
        it is a relative of both u and v, it is not a member of O(D)). </textual></para><para class="po-block e614 e614"><textual class="po-textual">The join operation will not always be closed, neither in M(D) nor in O(D). If x precedes
        y with both tags of x before y.start, their join is (x.start,y.end). This node cannot be any
        element neither of M(D) nor of O(D), since it is a relative of both x and y, but not
        identical to any of them. </textual></para><para class="po-block e615 e615"><textual class="po-textual">An observation concerning M(D) is that there are nested documents that are closed under
        both join and meet. Documents where no node precedes another are of that type, like for
        example </textual><code class="po-atom e616 e616"><textual class="po-textual">&lt;r&gt;&lt;a&gt;X&lt;/a&gt;&lt;r&gt;</textual></code><textual class="po-textual">. In a document like this, where ⊑ is a
        total order, it is the case that if x⊔y=x then x⊓y=y and vice versa. A
        document with overlap will in general leak into L(D) for both meet and join.</textual></para><para class="po-block e617 e617"><textual class="po-textual">Consider D</textual><subscript class="po-atom e618 e618"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> from the previous section. The lattice L(D</textual><subscript class="po-atom e619 e619"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) may be used to
        represent M(D</textual><subscript class="po-atom e620 e620"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) as well as O(D</textual><subscript class="po-atom e621 e621"><textual class="po-textual">2</textual></subscript><textual class="po-textual">). D</textual><subscript class="po-atom e622 e622"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> is an O-XML document with overlap, so
        M(D</textual><subscript class="po-atom e623 e623"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) will be ill-formed, but that is not of relevance at this point; M(D</textual><subscript class="po-atom e624 e624"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) will
        simply exhibit the nested view of the document. In the figure below, showing the lattice
        L(</textual><subscript class="po-atom e625 e625"><textual class="po-textual">2</textual></subscript><textual class="po-textual">), the elements of M(D</textual><subscript class="po-atom e626 e626"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) are indicated with a ✓, while the elements of
        O(D</textual><subscript class="po-atom e627 e627"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) are indicated with a ✗; the simples are members of both models. </textual><figure class="po-container e628 e628" xml:id="OMD2" xreflabel="Lattice OMD2"><title class="po-block e629 e629"><textual class="po-textual">L(D</textual><subscript class="po-atom e630 e630"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) with subsets ✓M(D</textual><subscript class="po-atom e631 e631"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) and ✗O(D</textual><subscript class="po-atom e632 e632"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e633 e633"><imageobject class="po-container e634 e634"><imagedata class="po-meta e635 e635" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-011.png" format="png" width="330px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e636 e636"><textual class="po-textual">We write M(D)* for the closure of M(D). It is obtained by collecting all nodes
        x⊓y and x⊔y in L(D) where x, y are elements of M(D), with recombinations.
        Similarly, we write O(D)* for the closure of O(D). The new nodes that are added in this way
        are called semi-elements, distinct from the elements of M(D) or O(D).</textual></para><para class="po-block e637 e637"><textual class="po-textual">Here is what the O-XML document D</textual><subscript class="po-atom e638 e638"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> with overlap looks like with semi-elements
        added. The semi-elements are indicated with a check mark, ✓. Note that the
        semi-elements are precisely the candidate elements for M(D</textual><subscript class="po-atom e639 e639"><textual class="po-textual">2</textual></subscript><textual class="po-textual">), an observation we return
        to below.</textual><figure class="po-container e640 e640" xml:id="oOMD2" xreflabel="Lattice oOMD2"><title class="po-block e641 e641"><textual class="po-textual">O(D</textual><subscript class="po-atom e642 e642"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)* with semi-elements check marked.</textual></title><mediaobject class="po-container e643 e643"><imageobject class="po-container e644 e644"><imagedata class="po-meta e645 e645" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-012.png" format="png" width="277px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e646 e646"><textual class="po-textual"> The semi-elements are considered nameless, they may be annotated with an algebraic
        formula having that node as value. </textual><figure class="po-container e647 e647" xml:id="oOMD2s" xreflabel="Lattice oOMD2s"><title class="po-block e648 e648"><textual class="po-textual">O(D</textual><subscript class="po-atom e649 e649"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)* </textual></title><mediaobject class="po-container e650 e650"><imageobject class="po-container e651 e651"><imagedata class="po-meta e652 e652" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-013.png" width="222px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e653 e653"><textual class="po-textual"> The reader may check that the above diagram represents the closure of O(D</textual><subscript class="po-atom e654 e654"><textual class="po-textual">2</textual></subscript><textual class="po-textual">). Here
        are all possible combinations alongside their value, not including combinations involving
        elements x and y such that x≤y. </textual><table class="po-container e655 e655"><caption class="po-container e656 e656"><para class="po-block e657 e657"><textual class="po-textual">All possible meet and join combinations for O(D</textual><subscript class="po-atom e658 e658"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)</textual></para></caption><col align="left" class="po-meta e659 e659" span="1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></col><tr class="po-table e660 e660"><td class="po-block e661 e661"><textual class="po-textual">X₃⊔Y₅ = b = &lt;b&gt;₂&lt;/b&gt;₆</textual></td></tr><tr class="po-table e662 e662"><td class="po-block e663 e663"><textual class="po-textual">X₃⊔Z₇ = b⊔c = &lt;b&gt;₂&lt;/c&gt;₈</textual></td></tr><tr class="po-table e664 e664"><td class="po-block e665 e665"><textual class="po-textual">Z₇⊔Y₅ = c = &lt;c&gt;₄&lt;/c&gt;₈</textual></td></tr><tr class="po-table e666 e666"><td class="po-block e667 e667"><textual class="po-textual">b⊓c = &lt;c&gt;₄&lt;/b&gt;₆</textual></td></tr></table><textual class="po-textual">
      </textual></para><para class="po-block e668 e668"><textual class="po-textual"> It was noted above that M(D</textual><subscript class="po-atom e669 e669"><textual class="po-textual">2</textual></subscript><textual class="po-textual">) was a subset of O(D</textual><subscript class="po-atom e670 e670"><textual class="po-textual">2</textual></subscript><textual class="po-textual">)*. We want to demonstrate
        that it holds for any document D that M(D) is a subset of O(D)*, even though M(D) and O(D)
        need only have the top element in common. The converse does not hold. A consequence of this
        is that O-XML documents with overlap cannot be reached from algebraic manipulations on M(D),
        but that the corresponding XML document without overlap can be reached from O(D)*.</textual></para><para class="po-block e671 e671"><textual class="po-textual"> For this to make sense, D must be a well-formed overlapping O-XML document. If D has no
        overlap, it will also be a well-formed XML document for which we have already established
        that O(D)=M(D). Hence, in that case M(D) will automatically be a subset of O(D)* (=M(D)*).
        Further, we take it without argument that if O(D) contains an element x that does not
        overlap with any other element y in O(D), x will also be a member of M(D). It doesn't matter
        if x contains, or is contained, in an overlap configuration as long x does not itself
        overlap with another element. To illustrate, the a and b elements of the following document
        D</textual><subscript class="po-atom e672 e672"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> will be elements of both M(D</textual><subscript class="po-atom e673 e673"><textual class="po-textual">4</textual></subscript><textual class="po-textual">) and O(D</textual><subscript class="po-atom e674 e674"><textual class="po-textual">4</textual></subscript><textual class="po-textual">), even though c and d overlaps.
        The latter two will obviously not be members of M(D</textual><subscript class="po-atom e675 e675"><textual class="po-textual">4</textual></subscript><textual class="po-textual">):
        </textual><programlisting class="po-block e676 e676" xml:space="preserve"><textual class="po-textual">&lt;a&gt;&lt;d&gt;X&lt;c&gt;&lt;b&gt;Y&lt;/b&gt;&lt;/d&gt;Z&lt;/c&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual"> In
        addition to the simples, the elements of M(D</textual><subscript class="po-atom e677 e677"><textual class="po-textual">4</textual></subscript><textual class="po-textual">) will be these (token indexes are skipped
        since the GIs serve to uniquely identify token tags), where the linear order of the elements
        also reflects the hierarchical order:
        </textual><programlisting class="po-block e678 e678" xml:space="preserve"><textual class="po-textual">(&lt;a&gt;,&lt;/a&gt;) (&lt;d&gt;,&lt;/c&gt;) (&lt;c&gt;,&lt;/d&gt;) (&lt;b&gt;,&lt;/b&gt;)</textual></programlisting><textual class="po-textual">
        So the odd elements here, which are not elements of O(D</textual><subscript class="po-atom e679 e679"><textual class="po-textual">4</textual></subscript><textual class="po-textual">), are these two
        </textual><programlisting class="po-block e680 e680" xml:space="preserve"><textual class="po-textual">(&lt;d&gt;,&lt;/c&gt;) (&lt;c&gt;,&lt;/d&gt;)</textual></programlisting><textual class="po-textual"> It can be seen that these
        two nodes are semi-elements of O(D</textual><subscript class="po-atom e681 e681"><textual class="po-textual">4</textual></subscript><textual class="po-textual">)* given the equations </textual><programlisting class="po-block e682 e682" xml:space="preserve"><textual class="po-textual">(&lt;d&gt;,&lt;/c&gt;)=(&lt;d&gt;,&lt;/d&gt;)⊔(&lt;c&gt;,&lt;/c&gt;)</textual></programlisting><textual class="po-textual">
        </textual><programlisting class="po-block e683 e683" xml:space="preserve"><textual class="po-textual">(&lt;c&gt;,&lt;/d&gt;)=(&lt;d&gt;,&lt;/d&gt;)⊓(&lt;c&gt;,&lt;/c&gt;)</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e684 e684"><textual class="po-textual">The above equations hold also in the general case. Consider an O-XML document D, and an
        element m in M(D), so m may possibly not have matching tags. Then it will be the case that either m
        is in O(D), or else there will be elements in O(D) so that m is their join, their meet or a
        combination of join and meet. To see this, note that m will either be well-formed according
        to XML (checked through the GI-identity constraint) or it will not, but still well-formed
        according to O-XML. So it is like either </textual><code class="po-atom e685 e685"><textual class="po-textual">(&lt;a&gt;,&lt;/a&gt;)</textual></code><textual class="po-textual"> or
          </textual><code class="po-atom e686 e686"><textual class="po-textual">(&lt;d&gt;,&lt;/c&gt;)</textual></code><textual class="po-textual"> of M(D</textual><subscript class="po-atom e687 e687"><textual class="po-textual">4</textual></subscript><textual class="po-textual">). If m is a member of O(D), it will also be in
        O(D)*. So consider the case where m is not an element in O(D). Then there must be distinct
        elements a and b in O(D) so that a.start=m.start and b.end=m.end, this because of the
        constraint which says all tag tokens must be part of an element. Now there are three cases
        to consider: </textual><orderedlist class="po-table e688 e688"><listitem class="po-container e689 e689"><para class="po-block e690 e690"><textual class="po-textual">a.start&lt;b.start and a.end&lt;b.end (this subsumes overlap and
              sequencing)</textual></para></listitem><listitem class="po-container e691 e691"><para class="po-block e692 e692"><textual class="po-textual">b.start&lt;a.start and b.end&lt;a.end (overlap only)</textual></para></listitem><listitem class="po-container e693 e693"><para class="po-block e694 e694"><textual class="po-textual">a.start&lt;b.start and b.end&lt;a.end (nesting)</textual></para></listitem></orderedlist><textual class="po-textual">
      </textual></para><para class="po-block e695 e695"><textual class="po-textual"> In the first case m=a⊔b, while in the second, m=a⊓b, parallel to the case
        for D</textual><subscript class="po-atom e696 e696"><textual class="po-textual">4</textual></subscript><textual class="po-textual">.The third case, the nesting case is a bit trickier. The tag configuration for a and
        b is now </textual><programlisting class="po-block e697 e697" xml:space="preserve"><textual class="po-textual">...&lt;a&gt;...&lt;b&gt;....&lt;/b&gt;...</textual></programlisting><textual class="po-textual"> where
          m=</textual><code class="po-atom e698 e698"><textual class="po-textual">(&lt;a&gt;,&lt;/b&gt;</textual></code><textual class="po-textual">), another way of stating that m=(a.start, b.end). Recall
        that the M-models are constructed without looking at GIs, so for m to be an element of M(D),
        all the tags between a.start(=m.start) and b.end(=m.end) must match up. In particular there
        must be an equal number of start tags and end tags between a.start and b.end. Since we
        already have b.start in there, we know there must be at least one extra end tag between
        a.start and b.end. That end tag must be matched in O(D) by a start tag outside of the
        (a.start, b.end) configuration. Which means that there must be an element c of O(D) such
        that c.end is between a.start and b.end and such that c.start is outside of the pair, that
        is c.start&lt;a.start. Now m can be written on the form m=a⊓c⊔b, and so is a
        semi-element of O(D)*. </textual><footnote class="po-popup e699 e699"><para class="po-block e700 e700"><textual class="po-textual">Note in passing that there must be an end tag positioned between b.start and b.end.
            This is so because m as a member of M(D) do not allow overlap, and with b.start between
            its start and end tags, b.start must match up with a tag in M(D) that comes before b.end
            itself. If c does not serve this purpose, there will be additional tags between a.start
            and b.end</textual></para></footnote><textual class="po-textual"> </textual></para><para class="po-block e701 e701"><textual class="po-textual">This result, that M(D) is a subset of O(D)*, but not vice versa, pinpoints an asymmetry
        between overlapping and nesting documents. Nested documents can be recovered, so to speak,
        from overlapping documents, but there are overlapping documents that cannot be described
        algebraicly in terms of nested documents. </textual></para></section><section class="po-hcontainer e702 e702"><title class="po-block e703 e703"><textual class="po-textual">Spurious overlap</textual></title><para class="po-block e704 e704"><textual class="po-textual">Closure models may be help in representing certain cases so-called spurious overlap as discussed in [</textual><xref class="po-milestone e705 e705" linkend="HuitfeldtandSperberg-McQueen2003"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Roughly, spurious overlap occurs
        whenever two elements a and b overlap, and there is no PCDATA either between the two start
        tags, or between the two end tags, or between the start tag of a and the end tag of b. The
        following O-XML document D</textual><subscript class="po-atom e706 e706"><textual class="po-textual">3</textual></subscript><textual class="po-textual"> may illustrate. </textual><blockquote class="po-container e707 e707"><para class="po-block e708 e708"><textual class="po-textual">
            </textual><code class="po-atom e709 e709"><textual class="po-textual">&lt;a&gt;&lt;b&gt;X&lt;c&gt;&lt;/b&gt;Y&lt;/c&gt;&lt;a&gt;</textual></code><textual class="po-textual">
          </textual></para></blockquote><textual class="po-textual"> Its document model is this </textual><figure class="po-container e710 e710" xml:id="MD3" xreflabel="Spurious           model"><title class="po-block e711 e711"><textual class="po-textual">O(D</textual><subscript class="po-atom e712 e712"><textual class="po-textual">3</textual></subscript><textual class="po-textual">)</textual></title><mediaobject class="po-container e713 e713"><imageobject class="po-container e714 e714"><imagedata class="po-meta e715 e715" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-014.png" width="200px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e716 e716"><textual class="po-textual"> Except for token indexes, it is identical to the document model for the following
        XML document: </textual><blockquote class="po-container e717 e717"><para class="po-block e718 e718"><textual class="po-textual">
            </textual><code class="po-atom e719 e719"><textual class="po-textual">&lt;a&gt;&lt;b&gt;X&lt;/b&gt;&lt;c&gt;Y&lt;/c&gt;&lt;a&gt;</textual></code><textual class="po-textual">
          </textual></para></blockquote><textual class="po-textual"> The closures of the two document models are slightly different, though. The
        document with spurious overlap has this closure: </textual><figure class="po-container e720 e720" xml:id="SCD3" xreflabel="Spurious           closure"><title class="po-block e721 e721"><textual class="po-textual">O(D</textual><subscript class="po-atom e722 e722"><textual class="po-textual">3</textual></subscript><textual class="po-textual">)*</textual></title><mediaobject class="po-container e723 e723"><imageobject class="po-container e724 e724"><imagedata class="po-meta e725 e725" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-015.png" width="200px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual"> while the document without overlap has this closure:</textual><figure class="po-container e726 e726" xml:id="CD3" xreflabel="Nested             closure"><title class="po-block e727 e727"><textual class="po-textual">M(D</textual><subscript class="po-atom e728 e728"><textual class="po-textual">3</textual></subscript><textual class="po-textual">a)*</textual></title><mediaobject class="po-container e729 e729"><imageobject class="po-container e730 e730"><imagedata class="po-meta e731 e731" fileref="../../../vol7/graphics/Johnsen01/Johnsen01-016.png" width="200px"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">
      </textual></para><para class="po-block e732 e732"><textual class="po-textual"> This may serve to illustrate the close relationship between the lattice model and the
        serial form of the marked up document. By the use of closure models with semi-elements,
        documents with spurious overlap can be distinguished from other documents which share the
        same document model.</textual></para></section></section><section class="po-hcontainer e733 e733"><title class="po-block e734 e734"><textual class="po-textual">Conclusion</textual></title><para class="po-block e735 e735"><textual class="po-textual"> We have described a method for building lattices from marked up documents with and
      without overlap, and for generating, from these lattices, document models in the form of trees
      for XML documents, and in the form of GODDAGs for documents with overlap. We have shown that
      one and the same method can be used for generating both kinds of models, and we have given
      reasons to believe that lattices can also be used to implement well-formedness constraints for
      both kinds of documents. In this sense, this is also a step away from relying on context free
      grammars and the like in analyzing documents. As presented here, model building is kept
      separate from grammar, but we leave open the question of how this bears on document
      validation. </textual></para><para class="po-block e736 e736"><textual class="po-textual">We have discussed and compared some of the algebraic features of the document models and
      the relations between them, and pointed out some interesting results. For example, that the
      algebraic operations provide a link between nested documents and overlapping documents. The
      former can be computed by algebraic means from the latter, but not the other way around. We
      have also disussed how the algebraically closed models can be used to distinguish models of
      spurious overlap from nested models, via the introduction of semi-elements.</textual></para><para class="po-block e737 e737"><textual class="po-textual"> Therefore, although many of the details in the work presented here probably are in need
      of correction and revision, we believe that the application of lattices to marked up documents
      may provide a unified account of markup languages with and without overlap.</textual></para></section><section class="po-hcontainer e738 e738"><title class="po-block e739 e739"><textual class="po-textual">Appendix</textual></title><para class="po-block e740 e740"><textual class="po-textual">In the section called "Bracketed notations and matching" we defined the grammar P. We will
      formally prove that any two parentheses (a left then a right) can be added to a well-formed
      parenthetical expression according to this grammar, while preserving well-formedness. We start
      with the following lemma </textual></para><para class="po-block e741 e741"><textual class="po-textual">
      </textual><emphasis class="po-inline e742 e742" role="bold"><textual class="po-textual">Lemma on string splitting</textual></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e743 e743"><textual class="po-textual">Let the string </textual><code class="po-atom e744 e744"><textual class="po-textual">S</textual></code><textual class="po-textual"> over left and right parentheses be derived according to P,
      and decomposed into </textual><code class="po-atom e745 e745"><textual class="po-textual">S=XYZ</textual></code><textual class="po-textual">. Then </textual><code class="po-atom e746 e746"><textual class="po-textual">X</textual></code><textual class="po-textual">, </textual><code class="po-atom e747 e747"><textual class="po-textual">Y</textual></code><textual class="po-textual"> and </textual><code class="po-atom e748 e748"><textual class="po-textual">Z</textual></code><textual class="po-textual">
      can be reduced, by removing non-terminal Ps
      from each of them into </textual><code class="po-atom e749 e749"><textual class="po-textual">X'</textual></code><textual class="po-textual">, </textual><code class="po-atom e750 e750"><textual class="po-textual">Y'</textual></code><textual class="po-textual">, and </textual><code class="po-atom e751 e751"><textual class="po-textual">Z'</textual></code><textual class="po-textual">, such that 
      </textual><code class="po-atom e752 e752"><textual class="po-textual">X'=(</textual><superscript class="po-atom e753 e753"><textual class="po-textual">n</textual></superscript></code><textual class="po-textual"> and
          </textual><code class="po-atom e754 e754"><textual class="po-textual">Y'=)</textual><superscript class="po-atom e755 e755"><textual class="po-textual">m</textual></superscript><textual class="po-textual">(</textual><superscript class="po-atom e756 e756"><textual class="po-textual">p</textual></superscript></code><textual class="po-textual"> and
          </textual><code class="po-atom e757 e757"><textual class="po-textual">Z'=)</textual><superscript class="po-atom e758 e758"><textual class="po-textual">q</textual></superscript></code><textual class="po-textual">, so that </textual><code class="po-atom e759 e759"><textual class="po-textual">S'</textual></code><textual class="po-textual"> is well-formed. </textual></para><para class="po-block e760 e760"><textual class="po-textual">Proof: Since </textual><code class="po-atom e761 e761"><textual class="po-textual">X</textual></code><textual class="po-textual"> is the leftmost string of </textual><code class="po-atom e762 e762"><textual class="po-textual">S</textual></code><textual class="po-textual">, any right
      parenthesis, </textual><code class="po-atom e763 e763"><textual class="po-textual">)</textual></code><textual class="po-textual">, in </textual><code class="po-atom e764 e764"><textual class="po-textual">X</textual></code><textual class="po-textual"> must occur in the pattern </textual><code class="po-atom e765 e765"><textual class="po-textual">(p)</textual></code><textual class="po-textual">, and
      such a pattern can safely be removed without destroying the well-formedness of the expression.
      Thus, </textual><code class="po-atom e766 e766"><textual class="po-textual">X</textual></code><textual class="po-textual"> will in the end be reduced to </textual><code class="po-atom e767 e767"><textual class="po-textual">X'</textual></code><textual class="po-textual"> as a consecutive string of
      left parentheses. A parallel argument goes for </textual><code class="po-atom e768 e768"><textual class="po-textual">Z</textual></code><textual class="po-textual"> and its reduction to
      </textual><code class="po-atom e769 e769"><textual class="po-textual">Z'</textual></code><textual class="po-textual"> as a string of right parentheses. For </textual><code class="po-atom e770 e770"><textual class="po-textual">Y</textual></code><textual class="po-textual"> the story is a bit
      different, since a left or right parenthesis may be generated with a corresponding parenthesis
      in </textual><code class="po-atom e771 e771"><textual class="po-textual">X</textual></code><textual class="po-textual"> or </textual><code class="po-atom e772 e772"><textual class="po-textual">Z</textual></code><textual class="po-textual">. However, we can safely conclude that if all
      </textual><code class="po-atom e773 e773"><textual class="po-textual">P</textual></code><textual class="po-textual">s are removed from Y, then there can be no string of the form </textual><code class="po-atom e774 e774"><textual class="po-textual">(W)</textual></code><textual class="po-textual">
      in </textual><code class="po-atom e775 e775"><textual class="po-textual">Y</textual></code><textual class="po-textual">, since either </textual><code class="po-atom e776 e776"><textual class="po-textual">)</textual></code><textual class="po-textual"> is derived with a corresponding </textual><code class="po-atom e777 e777"><textual class="po-textual">(</textual></code><textual class="po-textual">
      in </textual><code class="po-atom e778 e778"><textual class="po-textual">W</textual></code><textual class="po-textual">, or </textual><code class="po-atom e779 e779"><textual class="po-textual">(</textual></code><textual class="po-textual"> is derived with a corresponding </textual><code class="po-atom e780 e780"><textual class="po-textual">)</textual></code><textual class="po-textual"> in
      </textual><code class="po-atom e781 e781"><textual class="po-textual">W</textual></code><textual class="po-textual">. Thus, Y' must be a string of </textual><code class="po-atom e782 e782"><textual class="po-textual">)</textual></code><textual class="po-textual">'s followed by </textual><code class="po-atom e783 e783"><textual class="po-textual">(</textual></code><textual class="po-textual">'s.
      Since removing a </textual><code class="po-atom e784 e784"><textual class="po-textual">P</textual></code><textual class="po-textual"> from a well-formed string won't affect its well-formedness,
      the string </textual><code class="po-atom e785 e785"><textual class="po-textual">S'=X'Y'Z'</textual></code><textual class="po-textual"> is well-formed.</textual></para><para class="po-block e786 e786"><textual class="po-textual"> This lemma will be used to show that any pair of left and right parentheses can be
      inserted into a well-formed string without affecting its well-formedness. </textual></para><para class="po-block e787 e787"><textual class="po-textual">
      </textual><emphasis class="po-inline e788 e788" role="bold"><textual class="po-textual">Well-formedness of additional parentheses</textual></emphasis><textual class="po-textual">
    </textual></para><para class="po-block e789 e789"><textual class="po-textual">Let the string S be a well-formed parenthetical expression according to P. Inserting a
      left parenthesis anywhere in </textual><code class="po-atom e790 e790"><textual class="po-textual">S</textual></code><textual class="po-textual"> followed by a right parenthesis anywhere after the
      left, will result in a well-formed string according to </textual><code class="po-atom e791 e791"><textual class="po-textual">P</textual></code><textual class="po-textual">.</textual></para><para class="po-block e792 e792"><textual class="po-textual">Proof: Split the string </textual><code class="po-atom e793 e793"><textual class="po-textual">S</textual></code><textual class="po-textual"> into three substrings </textual><code class="po-atom e794 e794"><textual class="po-textual">XYZ</textual></code><textual class="po-textual"> at the
      positions where ( and ) are to be inserted, so that The new string is </textual></para><blockquote class="po-container e795 e795"><para class="po-block e796 e796"><textual class="po-textual">
        </textual><code class="po-atom e797 e797"><textual class="po-textual">S</textual><subscript class="po-atom e798 e798"><textual class="po-textual">1</textual></subscript><textual class="po-textual">=X(Y)Z.</textual></code><textual class="po-textual">
      </textual></para></blockquote><para class="po-block e799 e799"><textual class="po-textual"> Now according to lemma, X Y and Z can be reduced and re-concatenated into the well-formed
      expression</textual></para><blockquote class="po-container e800 e800"><para class="po-block e801 e801"><textual class="po-textual">
        </textual><code class="po-atom e802 e802"><textual class="po-textual">
            (</textual><superscript class="po-atom e803 e803"><textual class="po-textual">n</textual></superscript><textual class="po-textual">)</textual><superscript class="po-atom e804 e804"><textual class="po-textual">m</textual></superscript><textual class="po-textual">(</textual><superscript class="po-atom e805 e805"><textual class="po-textual">p</textual></superscript><textual class="po-textual">)</textual><superscript class="po-atom e806 e806"><textual class="po-textual">q</textual></superscript><textual class="po-textual">
        </textual></code><textual class="po-textual">
      </textual></para></blockquote><para class="po-block e807 e807"><textual class="po-textual"> Inserting the new left-( and right-) into their respective positions, results in </textual><blockquote class="po-container e808 e808"><para class="po-block e809 e809"><textual class="po-textual">
          </textual><code class="po-atom e810 e810"><textual class="po-textual">
              (</textual><superscript class="po-atom e811 e811"><textual class="po-textual">n</textual></superscript><textual class="po-textual">()</textual><superscript class="po-atom e812 e812"><textual class="po-textual">m</textual></superscript><textual class="po-textual">(</textual><superscript class="po-atom e813 e813"><textual class="po-textual">p</textual></superscript><textual class="po-textual">))</textual><superscript class="po-atom e814 e814"><textual class="po-textual">q</textual></superscript><textual class="po-textual">
          </textual></code><textual class="po-textual">
        </textual></para></blockquote><textual class="po-textual"> Now, all that is left to do is just to shift the superscripts to the right and
      left; this expression can be written as </textual><blockquote class="po-container e815 e815"><para class="po-block e816 e816"><textual class="po-textual">
          </textual><code class="po-atom e817 e817"><textual class="po-textual">
              ((</textual><superscript class="po-atom e818 e818"><textual class="po-textual">n</textual></superscript><textual class="po-textual">)</textual><superscript class="po-atom e819 e819"><textual class="po-textual">m</textual></superscript><textual class="po-textual">(</textual><superscript class="po-atom e820 e820"><textual class="po-textual">p</textual></superscript><textual class="po-textual">)</textual><superscript class="po-atom e821 e821"><textual class="po-textual">q</textual></superscript><textual class="po-textual">)
          </textual></code><textual class="po-textual">
        </textual></para></blockquote><textual class="po-textual">
    </textual></para><para class="po-block e822 e822"><textual class="po-textual"> But this is just the expression </textual><code class="po-atom e823 e823"><textual class="po-textual">(X'Y'Z')</textual></code><textual class="po-textual">, and since the </textual><code class="po-atom e824 e824"><textual class="po-textual">X'Y'Z'</textual></code><textual class="po-textual">,
      can be reduced to a sequence of </textual><code class="po-atom e825 e825"><textual class="po-textual">Ps</textual></code><textual class="po-textual">, </textual><textual class="po-textual"> the resulting
      expression is also well-formed, being then on the form </textual><code class="po-atom e826 e826"><textual class="po-textual">(P*)</textual></code><textual class="po-textual">. </textual></para><para class="po-block e827 e827"><textual class="po-textual"> This proposition guarantees that the intended matching of the parentheses is of no
      concern to the well-formedness of the expression. </textual></para></section><bibliography class="po-hcontainer e828 e828"><title class="po-block e829 e829"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e830 e830" xml:id="abney97" xreflabel="Abney 1997"><textual class="po-textual">Abney, Steven, </textual><quote class="po-inline e831 e831"><textual class="po-textual">Partial Parsing via
        Finite-State Cascades</textual></quote><textual class="po-textual">. </textual><emphasis class="po-inline e832 e832" role="ital"><textual class="po-textual">Journal of Natural Language Engineering
        2:337-344.</textual></emphasis></bibliomixed><bibliomixed class="po-block e833 e833" xml:id="Barnardetal.1988" xreflabel="Barnard et al. 1988"><textual class="po-textual">Barnard, David, Ron
      Hayter, Maria Karababa, George Logan, and John McFadden, </textual><quote class="po-inline e834 e834"><textual class="po-textual">SGML-based markup for literary
        texts: Two problems and some solutions</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e835 e835" role="ital"><textual class="po-textual">Computers and the
        Humanities</textual></emphasis><textual class="po-textual">, 22: 265-276. </textual><link class="po-inline e836 e836" xlink:actuate="onRequest" xlink:href="http://www.springerlink.com/content/r1p6t63627663436/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.springerlink.com/content/r1p6t63627663436/</textual></link></bibliomixed><bibliomixed class="po-block e837 e837" xml:id="Barnardetal.1995" xreflabel="Barnard et al. 1995"><textual class="po-textual">Barnard, David; Burnard,
      Lou; Gaspart, Jean-Pierre; Price, Lynne A.; Sperberg-McQueen, C. M.; Varile, Giovanni
      Battista, </textual><quote class="po-inline e838 e838"><textual class="po-textual">Hierarchical Encoding of Text: Technical Problems and SGML Solutions</textual></quote><textual class="po-textual">,
        </textual><emphasis class="po-inline e839 e839" role="ital"><textual class="po-textual">Computers and the Humanities</textual></emphasis><textual class="po-textual">, The Text Encoding Initiative:
      Background and Contents, Guest Editors Nancy Ide and Jean Vèronis, 29/3, 211-231. </textual><link class="po-inline e840 e840" xlink:actuate="onRequest" xlink:href="http://www.springerlink.com/content/p7775247276v88h3/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.springerlink.com/content/p7775247276v88h3/</textual></link></bibliomixed><bibliomixed class="po-block e841 e841" xml:id="Bauman2005" xreflabel="Bauman 2005"><textual class="po-textual">Bauman, Syd, </textual><quote class="po-inline e842 e842"><textual class="po-textual">TEI HORSEing
        around</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e843 e843" role="ital"><textual class="po-textual">Proceedings of Extreme Markup Languages®</textual></emphasis><textual class="po-textual">.
        </textual><link class="po-inline e844 e844" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2005/Bauman01/EML2005Bauman01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2005/Bauman01/EML2005Bauman01.html</textual></link></bibliomixed><bibliomixed class="po-block e845 e845" xml:id="Carlettaetal.2005" xreflabel="Carletta et al. 2005"><textual class="po-textual">Carletta, J.; S. Evert;
      U. Heid; and J. Kilgour, </textual><quote class="po-inline e846 e846"><textual class="po-textual">The NITE XML Toolkit: data model and query</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e847 e847" role="ital"><textual class="po-textual">Language Resources and Evaluation</textual></emphasis><textual class="po-textual">, 39.4: 313-334. </textual><link class="po-inline e848 e848" xlink:actuate="onRequest" xlink:href="http://www.springerlink.com/content/j37h2p15u682075g/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.springerlink.com/content/j37h2p15u682075g/</textual></link></bibliomixed><bibliomixed class="po-block e849 e849" xml:id="Chattietal.2007" xreflabel="Chatti et al. 2007"><textual class="po-textual">Chatti, Noureddine; Suha
      Kaouk; Sylvie Calabretto; and Jean Marie Pinon, </textual><quote class="po-inline e850 e850"><textual class="po-textual">MultiX: an XML-based formalism to
        encode multi-structured documents</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e851 e851" role="ital"><textual class="po-textual">Proceedings of Extreme
        Markup Languages</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e852 e852" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2007/Chatti01/EML2007Chatti01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2007/Chatti01/EML2007Chatti01.html</textual></link></bibliomixed><bibliomixed class="po-block e853 e853" xml:id="DeRose2004" xreflabel="DeRose 2004"><textual class="po-textual">DeRose, Steven J., </textual><quote class="po-inline e854 e854"><textual class="po-textual">Markup
        overlap: A review and a horse</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e855 e855" role="ital"><textual class="po-textual">Proceedings of Extreme Markup
        Languages®</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e856 e856" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2004/DeRose01/EML2004DeRose01.html</textual></link></bibliomixed><bibliomixed class="po-block e857 e857" xml:id="DiIorioetal.2009" xreflabel="Di Iorio et al. 2009"><textual class="po-textual">Di Iorio, Angelo; Silvio
      Peroni; and Fabio Vitali, </textual><quote class="po-inline e858 e858"><textual class="po-textual">Towards markup support for full GODDAGs and beyond: the
        EARMARK approach</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e859 e859" role="ital"><textual class="po-textual">Balisage Series on Markup
        Technologies</textual></emphasis><textual class="po-textual">, vol. 3. </textual><link class="po-inline e860 e860" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Peroni01/BalisageVol3-Peroni01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol3/html/Peroni01/BalisageVol3-Peroni01.html</textual></link></bibliomixed><bibliomixed class="po-block e861 e861" xml:id="Goldfarb1990" xreflabel="Goldfarb 1990"><textual class="po-textual">Charles F. Goldfarb, </textual><emphasis class="po-inline e862 e862" role="ital"><textual class="po-textual">The SGML Handbook</textual></emphasis><textual class="po-textual">, Clandon Press, Oxford. </textual></bibliomixed><bibliomixed class="po-block e863 e863" xml:id="Grätzer1971" xreflabel="Grätser 1971"><textual class="po-textual">Gråtser, George, </textual><emphasis class="po-inline e864 e864" role="ital"><textual class="po-textual">Lattice Theory, first concepts and distributive lattices</textual></emphasis><textual class="po-textual"> San
      Fransisco, Calif., 1971. xv+212 pp. Softcover edition, Dover Publications, 2009. </textual><link class="po-inline e865 e865" xlink:actuate="onRequest" xlink:href="http://server.maths.umanitoba.ca/homepages/gratzer.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://server.maths.umanitoba.ca/homepages/gratzer.html</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e866 e866" xml:id="Hilbertetal.2005" xreflabel="Hilbert et al. 2005"><textual class="po-textual">Hilbert, Mirco; Oliver
      Schonefeld; and Andreas Witt, </textual><quote class="po-inline e867 e867"><textual class="po-textual">Making CONCUR work</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e868 e868" role="ital"><textual class="po-textual">Proceedings of Extreme Markup Languages®</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e869 e869" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2005/Witt01/EML2005Witt01.xml" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2005/Witt01/EML2005Witt01.xml</textual></link></bibliomixed><bibliomixed class="po-block e870 e870" xml:id="Huitfeldt1998" xreflabel="Huitfeldt 1998"><textual class="po-textual">Huitfeldt C, </textual><quote class="po-inline e871 e871"><textual class="po-textual">MECS - A
        Multi-Element Code System</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e872 e872" role="ital"><textual class="po-textual">Working Papers from the
        Wittgenstein Archives at the University of Bergen</textual></emphasis><textual class="po-textual">, No 3, Version October 1998.
        </textual><link class="po-inline e873 e873" xlink:actuate="onRequest" xlink:href="http://helmer.aksis.uib.no/claus/mecs/mecs.htm" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://helmer.aksis.uib.no/claus/mecs/mecs.htm</textual></link></bibliomixed><bibliomixed class="po-block e874 e874" xml:id="HuitfeldtandSperberg-McQueen2003" xreflabel="Huitfeldt and Sperberg-McQueen       2003"><textual class="po-textual">Huitfeldt, Claus; and C. M.
      Sperberg-McQueen, </textual><quote class="po-inline e875 e875"><textual class="po-textual">TexMECS: An experimental markup meta-language for complex
        documents</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e876 e876" role="ital"><textual class="po-textual">Working paper of the project Markup Languages for
        Complex Documents (MLCD)</textual></emphasis><textual class="po-textual">, University of Bergen. </textual><link class="po-inline e877 e877" xlink:actuate="onRequest" xlink:href="http://decentius.aksis.uib.no/mlcd/2003/Papers/texmecs.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://decentius.aksis.uib.no/mlcd/2003/Papers/texmecs.html</textual></link></bibliomixed><bibliomixed class="po-block e878 e878" xml:id="Jagadishetal.2004" xreflabel="Jagadish et al. 2004"><textual class="po-textual">Jagadish, H.V.; Laks V.
      S. Lakshmanan; Monica Scannapieco; Divesh Srivastava; and Nuwee Wiwatwattana, </textual><quote class="po-inline e879 e879"><textual class="po-textual">Colorful
        XML: one hierarchy isn't enough</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e880 e880" role="ital"><textual class="po-textual">Proceedings of the 2004 ACM
        SIGMOD international conference on Management of data</textual></emphasis><textual class="po-textual">, Paris, France: 251-262.
        </textual><link class="po-inline e881 e881" xlink:actuate="onRequest" xlink:href="http://doi.acm.org/10.1145/1007568.1007598" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://doi.acm.org/10.1145/1007568.1007598</textual></link></bibliomixed><bibliomixed class="po-block e882 e882" xml:id="Marcoux2008"><textual class="po-textual">Marcoux, Yves. </textual><quote class="po-inline e883 e883"><textual class="po-textual">Graph characterization of overlap-only
        TexMECS and other overlapping markup formalisms.</textual></quote><textual class="po-textual"> Presented at Balisage: The Markup
      Conference 2008, Montréal, Canada, August 12 - 15, 2008. In </textual><emphasis class="po-inline e884 e884" role="ital"><textual class="po-textual">Proceedings
        of Balisage: The Markup Conference 2008. Balisage Series on Markup Technologies</textual></emphasis><textual class="po-textual">,
      vol. 1 (2008). doi:10.4242/BalisageVol1.Marcoux01. </textual><link class="po-inline e885 e885" xlink:actuate="onRequest" xlink:href="http://balisage.net/Proceedings/vol1/html/Marcoux01/BalisageVol1-Marcoux01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://balisage.net/Proceedings/vol1/html/Marcoux01/BalisageVol1-Marcoux01.html</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e886 e886" xml:id="Marinellietal.2008" xreflabel="Marinelli et al. 2008"><textual class="po-textual">Marinelli, P.,
      Vitali, F., Zacchiroli, S., </textual><quote class="po-inline e887 e887"><textual class="po-textual">Towards the unification of formats for overlapping
        markup</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e888 e888" role="ital"><textual class="po-textual">The New Review of Hypermedia and
      Multimedia</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e889 e889" xlink:actuate="onRequest" xlink:href="http://www.informaworld.com/smpp/ftinterface~content=a903040611~fulltext=713240930" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.informaworld.com/smpp/ftinterface~content=a903040611~fulltext=713240930</textual></link></bibliomixed><bibliomixed class="po-block e890 e890" xml:id="Nicol2002a" xreflabel="Nicol 2002a"><textual class="po-textual">Nicol, Gavin, </textual><quote class="po-inline e891 e891"><textual class="po-textual">Core range
        algebra: Toward a formal theory of markup</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e892 e892" role="ital"><textual class="po-textual">Extreme Markup
        Languages</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e893 e893" xlink:actuate="onRequest" xlink:href="http://www.mind-to-mind.com/library/papers/ara/core-range-algebra-03-2002.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mind-to-mind.com/library/papers/ara/core-range-algebra-03-2002.html</textual></link></bibliomixed><bibliomixed class="po-block e894 e894" xml:id="Nicol2002b" xreflabel="Nicol 2002b"><textual class="po-textual">Gavin Nicol, </textual><quote class="po-inline e895 e895"><textual class="po-textual">Attributed range
        algebra: Extending core range algebra to arbitrary structures</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e896 e896" role="ital"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e897 e897" xlink:actuate="onRequest" xlink:href="http://www.mind-to-mind.com/library/papers/ara/attributed-range-algebra-07-2002.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mind-to-mind.com/library/papers/ara/attributed-range-algebra-07-2002.pdf</textual></link></bibliomixed><bibliomixed class="po-block e898 e898" xml:id="Raymondetal1992" xreflabel="Raymond et al. 1992"><textual class="po-textual"> Raymond, Darrell R;
      Tompa, Frank William, and Wood, Derick: </textual><quote class="po-inline e899 e899"><textual class="po-textual">Markup Reconsidered</textual></quote><textual class="po-textual">. University of
      Western Ontario. </textual><link class="po-inline e900 e900" xlink:actuate="onRequest" xlink:href="www.cs.uwaterloo.ca/~fwtompa/.papers/markup.ps" xlink:show="new" xlink:type="simple"><textual class="po-textual">www.cs.uwaterloo.ca/~fwtompa/.papers/markup.ps</textual></link></bibliomixed><bibliomixed class="po-block e901 e901" xml:id="Raymondetal1995" xreflabel="Raymond et al. 1995"><textual class="po-textual"> Raymond, Darrell R;
      Tompa, Frank William, and Wood, Derick: </textual><quote class="po-inline e902 e902"><textual class="po-textual">From Data Representation to Data Model:
        Meta-Semantic Issues in the Evlution of SGML.</textual></quote><textual class="po-textual">
      </textual><link class="po-inline e903 e903" xlink:actuate="onRequest" xlink:href="http://reference.kfupm.edu.sa/content/f/r/from_data_representation_to_data_model___1594703.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://reference.kfupm.edu.sa/content/f/r/from_data_representation_to_data_model___1594703.pdf</textual></link><textual class="po-textual">
    </textual></bibliomixed><bibliomixed class="po-block e904 e904" xml:id="SchonefeldandWitt2006" xreflabel="Schonefeld and Witt 2006"><textual class="po-textual">Schonefeld,
      Oliver, and Andreas Witt, </textual><quote class="po-inline e905 e905"><textual class="po-textual">Towards validation of concurrent markup</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e906 e906" role="ital"><textual class="po-textual">Proceedings of Extreme Markup Languages®</textual></emphasis><textual class="po-textual">, . </textual><link class="po-inline e907 e907" xlink:actuate="onRequest" xlink:href="http://conferences.idealliance.org/extreme/html/2006/Schonefeld01/EML2006Schonefeld01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://conferences.idealliance.org/extreme/html/2006/Schonefeld01/EML2006Schonefeld01.html</textual></link></bibliomixed><bibliomixed class="po-block e908 e908" xml:id="Schonefeld2007" xreflabel="Schonefeld 2007"><textual class="po-textual">Schonefeld, Oliver Georg Rehm,
      Andreas Witt, Lothar Lemnitzer (eds.), </textual><quote class="po-inline e909 e909"><textual class="po-textual">XCONCUR and XCONCUR-CL: A constraint-based
        approach for the validation of concurrent markup</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e910 e910" role="ital"><textual class="po-textual">Datenstrukturen für linguistische Ressourcen und ihre Anwendungen / Data structures for
        linguistic resources and applications: Proceedings of the Biennial GLDV Conference
        2007</textual></emphasis><textual class="po-textual">, Tübingen: Gunter Narr Verlag. Pp. 347-356. </textual><link class="po-inline e911 e911" xlink:actuate="onRequest" xlink:href="" xlink:show="new" xlink:type="simple"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></link></bibliomixed><bibliomixed class="po-block e912 e912" xml:id="SchmidtandColomb2009" xreflabel="Schmidt and Colomb 2009"><textual class="po-textual">Schmidt, D.,
      Colomb, R., </textual><quote class="po-inline e913 e913"><textual class="po-textual">A data structure for representing multi-version texts online</textual></quote><textual class="po-textual">,
        </textual><emphasis class="po-inline e914 e914" role="ital"><textual class="po-textual">International Journal of Human-Computer Studies</textual></emphasis><textual class="po-textual">, . </textual><link class="po-inline e915 e915" xlink:actuate="onRequest" xlink:href="http://portal.acm.org/citation.cfm?id=1523966" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://portal.acm.org/citation.cfm?id=1523966</textual></link></bibliomixed><bibliomixed class="po-block e916 e916" xml:id="Sperberg-McQueenandHuitfeldt2000" xreflabel="Sperberg-McQueen and Huitfeldt       2000"><textual class="po-textual">Sperberg-McQueen, C. M., and Claus
      Huitfeldt Peter R. King and Ethan V. Munson (eds.), </textual><quote class="po-inline e917 e917"><textual class="po-textual">GODDAG: A Data Structure for
        Overlapping Hierarchies</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e918 e918" role="ital"><textual class="po-textual">Digital documents: systems and
        principles. Lecture Notes in Computer Science 2023</textual></emphasis><textual class="po-textual">, Berlin: Springer, 2004, pp.
      139-160. Paper given at Digital Documents: Systems and Principles. 8th International
      Conference on Digital Documents and Electronic Publishing, DDEP 2000, 5th International
      Workshop on the Principles of Digital Document Processing, PODDP 2000, Munich, Germany,
      September 13-15, 2000.. </textual><link class="po-inline e919 e919" xlink:actuate="onRequest" xlink:href="http://www.w3.org/People/cmsmcq/2000/poddp2000.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/People/cmsmcq/2000/poddp2000.html</textual></link></bibliomixed><bibliomixed class="po-block e920 e920" xml:id="StührenbergandJettka2009" xreflabel="Stührenberg and Jettka 2009"><textual class="po-textual">Stührenberg, Maik; and Daniel Jettka, </textual><quote class="po-inline e921 e921"><textual class="po-textual">A toolkit for multi-dimensional markup: The
        development of SGF to XStandoff</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e922 e922" role="ital"><textual class="po-textual">Proceedings of Balisage: The
        Markup Conference 2009. Balisage Series on Markup Technologies</textual></emphasis><textual class="po-textual">, Vol. 3. </textual><link class="po-inline e923 e923" xlink:actuate="onRequest" xlink:href="http://www.balisage.net/Proceedings/vol3/html/Stuhrenberg01/BalisageVol3-Stuhrenberg01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.balisage.net/Proceedings/vol3/html/Stuhrenberg01/BalisageVol3-Stuhrenberg01.html</textual></link></bibliomixed><bibliomixed class="po-block e924 e924" xml:id="TEIP5" xreflabel="TEI P5"><textual class="po-textual">Lou Burnard and Syd Bauman (eds.),
        </textual><quote class="po-inline e925 e925"><textual class="po-textual">Non-hierarchical Structures</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e926 e926" role="ital"><textual class="po-textual">Guidelines for the
        Encoding and Interchange of Machine-Readable Texts (TEI P5)</textual></emphasis><textual class="po-textual">, The TEI Consortium.
        </textual><link class="po-inline e927 e927" xlink:actuate="onRequest" xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/NH.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.tei-c.org/release/doc/tei-p5-doc/en/html/NH.html</textual></link></bibliomixed><bibliomixed class="po-block e928 e928" xml:id="TennisonandPiez2002" xreflabel="Tennison and Piez 2002"><textual class="po-textual">Tennison, J. and W.
      Piez, </textual><quote class="po-inline e929 e929"><textual class="po-textual">The Layered Markup and Annotation Language (LMNL)</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e930 e930" role="ital"><textual class="po-textual">Proceedings of Extreme Markup Languages®</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e931 e931" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/extreme/proceedings/author-pkg/2002/Tennison02/EML2002Tennison02.zip" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.idealliance.org/papers/extreme/proceedings/author-pkg/2002/Tennison02/EML2002Tennison02.zip</textual></link></bibliomixed><bibliomixed class="po-block e932 e932" xml:id="Witt2005" xreflabel="Witt 2005"><textual class="po-textual">Andreas Witt Stefanie Dipper, Michael
      Götze, and Manfred Stede (eds.), </textual><quote class="po-inline e933 e933"><textual class="po-textual">Multiple Hierarchies: New Aspects of an Old
        Solution</textual></quote><textual class="po-textual">, </textual><emphasis class="po-inline e934 e934" role="ital"><textual class="po-textual">Heterogeneity in Focus: Creating and and Using
        Linguistic Databases</textual></emphasis><textual class="po-textual">, volume 2 of Interdisciplinary Studies on Information
      Structure (ISIS), Working Papers of the SFB 632. University of Potsdam, Germany. (Corrected
      reprint of an Extreme Markup 2004 paper). </textual><link class="po-inline e935 e935" xlink:actuate="onRequest" xlink:href="http://en.scientificcommons.org/42597903" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.scientificcommons.org/42597903</textual></link></bibliomixed></bibliography></article></classedDocument>