<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2" xml:id="HR-23632987-8973"><title class="po-block e1 e1"><textual class="po-textual">Secure Publishing using Schema-level Role-based Access Control Policies for Fragments of XML Documents</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2008</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 12 - 15, 2008</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual"> Popularity of social networks is growing rapidly and secure publishing is an important implementation tool for these networks. At the same time, recent implementations of access control policies (ACPs) for sharing fragments of XML documents have moved from distributing to users numerous sanitized sub-documents to disseminating a single document multi-encrypted with multiple cryptographic keys, in such a way that the stated ACPs are enforced. Any application that uses this implementation of ACPs will incur a high cost of generating keys separately for each document. However, most such applications, such as secure publishing, use similar documents, i.e. documents based on a selected schema. This paper describes RBAC defined at the schema level, (SRBAC), and generation of the minimum number of keys at the schema level. The main advantage of our approach is that for any application that uses a fixed number of schemas, keys can be generated (or even pre-generated) only once, and then reused in all documents valid for the given schema. While in general, key generation at the schema level has to be pessimistic, our approach tries to minimize the number of generated keys. Incoming XML documents are efficiently encrypted using single-pass SAX parsing in such a way that the original structure of these documents is completely hidden. We also describe distributing to each user only keys needed for decrypting accessible nodes, and for applying the minimal number of encryption operations to an XML document required to satisfy the protection requirements of the policy.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Tomasz</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Müldner</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Tomasz Müldner is a professor of computer science at Acadia University in Nova Scotia, one of Canada's top undergraduate universities. He has received numerous teaching awards, including the prestigious Acadia University Alumni Excellence in Teaching Award in 1996. He is the author of several books and numerous research papers. Dr. Müldner received his Ph.D. in mathematics from the Polish Academy of Science in Warsaw, Poland in 1975.  His current research includes XML compression and encryption, and website internationalization.</textual></para></personblurb><affiliation class="po-record e14 e14"><jobtitle class="po-field e15 e15"><textual class="po-textual">Professor</textual></jobtitle><orgname class="po-block e16 e16"><textual class="po-textual">Jodrey School of Computer Science, Acadia University</textual></orgname></affiliation><email class="po-field e17 e17"><textual class="po-textual">tomasz.muldner@acadiau.ca</textual></email></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Robin</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">McNeill</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">Robin McNeill graduated in May of 2008 with a Bachelor of Computer Science degree at Acadia University. He will be returning to Acadia University for the following academic year as a graduate student pursuing his masters degree in computer science.</textual></para></personblurb><affiliation class="po-record e24 e24"><jobtitle class="po-field e25 e25"><textual class="po-textual">Graduate Student</textual></jobtitle><orgname class="po-block e26 e26"><textual class="po-textual">Jodrey School of Computer Science, Acadia University</textual></orgname></affiliation><email class="po-field e27 e27"><textual class="po-textual">063637m@acadiau.ca</textual></email></author><author class="po-record e28 e28"><personname class="po-record e29 e29"><firstname class="po-field e30 e30"><textual class="po-textual">Jan</textual></firstname><othername class="po-field e31 e31"><textual class="po-textual">Krzysztof</textual></othername><surname class="po-field e32 e32"><textual class="po-textual">Miziołek</textual></surname></personname><personblurb class="po-container e33 e33"><para class="po-block e34 e34"><textual class="po-textual">Jan Krzysztof Miziołek works for the University of Warsaw, Poland. Dr. Miziołek received his Ph.D. in mathematics from Technical University of Lodz, Poland in 1981. He worked on design and implementation of a high-level programming language, LOGLAN-82. His current research includes XML compression and encryption.</textual></para></personblurb><affiliation class="po-record e35 e35"><jobtitle class="po-field e36 e36"><textual class="po-textual">Director</textual></jobtitle><orgname class="po-block e37 e37"><textual class="po-textual"> Computing Services Centre for Studies on the Classical Tradition in Poland and East-Central Europe, University of Warsaw, Warsaw, Poland</textual></orgname></affiliation><email class="po-field e38 e38"><textual class="po-textual">jkm@ibi.uw.edu.pl</textual></email></author><legalnotice class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">Copyright © 2008 Tomasz Müldner, Robin McNeill, and Jan Krzysztof Miziołek</textual></para></legalnotice><keywordset class="po-table e41 e41" role="author"><keyword class="po-field e42 e42"><textual class="po-textual">Secure access</textual></keyword><keyword class="po-field e43 e43"><textual class="po-textual">Social networks</textual></keyword><keyword class="po-field e44 e44"><textual class="po-textual">Encryption</textual></keyword><keyword class="po-field e45 e45"><textual class="po-textual">XML Schema</textual></keyword></keywordset></info><section class="po-hcontainer e46 e46"><title class="po-block e47 e47"><textual class="po-textual">Introduction</textual></title><para class="po-block e48 e48"><textual class="po-textual">Recent years have seen the </textual><emphasis class="po-inline e49 e49" role="ital"><textual class="po-textual">eXtensible Markup Language (XML)</textual></emphasis><textual class="po-textual"> expand beyond its origins as a standard for web document authoring to become widely embraced as a data encoding format.  For example, the most recent releases of commercial database systems include utilities for exporting relational data sets into XML format to facilitate data exchange.  This trend has naturally motivated researchers to investigate fine-grained (i.e., element-level) access control models for XML data sets.  While early approaches employed server-side techniques such as materialized security views and query re-writing, there has been some concern as to whether such approaches can scale up to handle applications involving thousands of users and/or complex access control policies.  More recently, attention has been focused on </textual><emphasis class="po-inline e50 e50" role="ital"><textual class="po-textual">secure publishing </textual></emphasis><textual class="po-textual">solutions, in which an XML document is made accessible to all users (e.g., by hosting it on an HTTP server) through possibly insecure channels. The desired </textual><emphasis class="po-inline e51 e51" role="ital"><textual class="po-textual">access control policy (ACP)</textual></emphasis><textual class="po-textual"> is enforced by encrypting regions of the document using cryptographic keys. Each user is assigned, through a secure channel, a set of keys (a keyring) corresponding to the permissions they have been granted under the access control policy, which allows them to decrypt exactly a document fragment consisting of element nodes they have been granted access to.  There are two crucial issues to note under this scenario: (1) the access control policy is only capable of enforcing read operations, as there is nothing preventing an authorized user from altering a data field once they have decrypted it and republishing a new version, and (2) the document owner (author) relinquishes control over the document once it has been published: consequently, any changes to the access control policy, or to the contents of the document can only be imposed by publishing a new version of the document.</textual></para><para class="po-block e52 e52"><textual class="po-textual">
While secure publishing approaches can overcome many of the performance limitations of earlier approaches, some care has to be taken in their implementation to ensure scalability.  A naive attempt to enforce an ACP may use </textual><emphasis class="po-inline e53 e53" role="ital"><textual class="po-textual">super-encryption</textual></emphasis><textual class="po-textual">, where elements residing in the intersection of two or more document paths in an ACP are encrypted with multiple keys, which greatly increases the number of expensive encryption and decryption operations. We use a more efficient </textual><emphasis class="po-inline e54 e54" role="ital"><textual class="po-textual">multi-encryption </textual></emphasis><textual class="po-textual">strategy, in which every node is encrypted with a </textual><emphasis class="po-inline e55 e55" role="ital"><textual class="po-textual">single</textual></emphasis><textual class="po-textual"> key.  Additionally, a naive implementation may end up assigning many keys, effectively trading the problem of view explosion for key proliferation. Key generation is expensive, and requiring each user to handle multiple keys complicates key management.  Hence, one seeks to minimize the number of keys required to enforce a particular access control policy. Since nowadays many documents conform to one or more schemas, it would be more efficient to generate keys once, at the schema level, and then re-use them for multi-encrypting documents valid in those schemas.</textual></para><para class="po-block e56 e56"><textual class="po-textual">
</textual><emphasis class="po-inline e57 e57" role="bold"><textual class="po-textual">Contributions: </textual></emphasis><textual class="po-textual">In this paper, we address the performance issues alluded to earlier.  Our main contribution is a generalization of key generation to the </textual><emphasis class="po-inline e58 e58" role="ital"><textual class="po-textual">schema level</textual></emphasis><textual class="po-textual">, allowing an access control policy to be defined over an entire class of XML documents specified by an XML Schema definition. Specifically, we define SRBAC, Schema-based ACP, based on our specification of grammar paths. This is a departure from previous research on grammar-level ACPs, which have mainly focused on DTDs and require separate key generation for each document valid for the grammar. Our second contribution is a specification of processing the schema S, which generates the keyring K</textual><subscript class="po-atom e59 e59"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, consisting of the minimum number of keys needed. In general, key generation at the schema level has to be pessimistic because it must generate enough keys to correctly encrypt all possible documents valid in the schema. However, because these keys are generated only once, before any document is to be encrypted, the algorithms to determine the minimum number of keys necessary may afford less efficient processing. (This phase roughly resembles program optimization performed by the compiler before the program is executed). Our third contribution is a specification of a </textual><emphasis class="po-inline e60 e60" role="ital"><textual class="po-textual">role-available keyring </textual></emphasis><textual class="po-textual"> K</textual><subscript class="po-atom e61 e61"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R) which, for a given role R in the SRBAC policy, consists of keys that will be made available to the user in role R so that this user can access precisely the fragment of any document D, valid in S, allowed by this policy. Our fourth contribution is an </textual><emphasis class="po-inline e62 e62" role="ital"><textual class="po-textual">efficient multi-encryption </textual></emphasis><textual class="po-textual"> of XML documents in a </textual><emphasis class="po-inline e63 e63" role="ital"><textual class="po-textual">single pass </textual></emphasis><textual class="po-textual"> (using a SAX parser) in such a way that the decryption of multi-encrypted documents results in a well-formed XML document. The encrypted document hides all of the structure of the original document. While the decrypted documents are no longer valid in the original schema, one may create </textual><emphasis class="po-inline e64 e64" role="ital"><textual class="po-textual">sanitized</textual></emphasis><textual class="po-textual"> schema (for which such document will be valid), and use them to efficiently apply XML tools, such as XQuery for XML databases. Our current research concentrates on static documents, but using SAX parsing may allow considering streamed XML documents (which will be a focus of future research). Our fifth contribution is a comparison of the efficiency of our approach and super-encryption. Our last contribution is that our key generation technique applies to </textual><emphasis class="po-inline e65 e65" role="ital"><textual class="po-textual">any</textual></emphasis><textual class="po-textual"> access control model, not only to the role-based model considered in this paper. Note that while encryption is expensive, comparatively speaking, validation is not that expensive and we can't know if a document is valid until it has been completely traversed, so we may perform several costly and wasteful encryptions before discovering that the document is invalid.  In such a case, combining validation and encryption only serves to slow down the validation, while performing two separate passes likely wouldn't take much longer and would avoid wasted encryptions. Therefore, we first validate the document and then encrypt it.
</textual></para><para class="po-block e66 e66"><textual class="po-textual">
There are various areas where the technique described in this paper can be applied. Besides secure publishing mentioned earlier, it can also be used for areas such as providing secure data to medical organizations or social networks.
</textual></para><para class="po-block e67 e67"><textual class="po-textual">
This paper is organized as follows. In Section 2, we describe related work. Section 3 describes RBAC at the document level, (DRBAC), and RBAC at the schema level, (SRBAC). In Section 4, we present our main results concerning SRBAC and key generation at the schema level, and briefly describe the implementation. Finally, in Section 5, we provide results of testing, and in Section 6 we describe conclusions and our future work. </textual></para></section><section class="po-hcontainer e68 e68"><title class="po-block e69 e69"><textual class="po-textual">Related Work </textual></title><para class="po-block e70 e70"><textual class="po-textual">
The increasing popularity of XML as a data encoding format has forced attention on the problem of controlling access to
XML documents [</textual><xref class="po-milestone e71 e71" linkend="mul100"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The majority of approaches to date (e.g. [</textual><xref class="po-milestone e72 e72" linkend="mul94"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],
[</textual><xref class="po-milestone e73 e73" linkend="mul108"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e74 e74" linkend="mul107"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and [</textual><xref class="po-milestone e75 e75" linkend="mul105"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]) have focused on specification of access control policies at the document level, while a smaller number of proposals have additionally considered expression of policies over an entire class of documents at the schema level. [</textual><xref class="po-milestone e76 e76" linkend="mul96"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and [</textual><xref class="po-milestone e77 e77" linkend="mul98"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] , [</textual><xref class="po-milestone e78 e78" linkend="mul99"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] specify  systems in which discretionary access control policies can be expressed over an individual XML document, or over a document type definition (DTD) defining a class of XML documents. [</textual><xref class="po-milestone e79 e79" linkend="mul106"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] defines a secure querying method for annotating a DTD with security policies, from which a security view is generated.  This view consists of a sanitized DTD Dv, which contains only the accessible portions of the original DTD D, and a function f, which specifies how to extract accessible data from instance XML documents conforming to D, in such a way that each query result generates a document conforming to Dv.  By hiding f from clients, the schema and data in the original document remain hidden, while clients are able to issue queries on accessible regions using Dv. </textual></para><para class="po-block e80 e80"><textual class="po-textual">More recent work focuses on the use of XML Schema as the schema specification language, in place of DTDs.
 [</textual><xref class="po-milestone e81 e81" linkend="mul103"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] describes a system which allows role-based access control policies to be defined at either the
 schema or document level.  At the schema level, access permissions are defined on schema objects (definitions of elements). [</textual><xref class="po-milestone e82 e82" linkend="mul110"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] describes RBAC-based policy specifications at the schema level, augmented with policy constraints using Schematron. Note that in all of these works, access control is enforced entirely by a server component, with a customized view of a document, consisting of only the accessible portions of the requested document, being returned to each client in accordance with their access permissions on the original document.  As a customized view must be generated in response to each client access request, in scenarios with complex documents and/or several users, view explosion becomes a problem. </textual></para><para class="po-block e83 e83"><textual class="po-textual">In contrast, our strategy forgoes reliance on a centralized access control and instead publishes a single (partially-) encrypted copy of each XML document, and relies on public-key cryptography to enforce the desired access control permission.  In this sense, it resembles the work of [</textual><xref class="po-milestone e84 e84" linkend="mul107"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and [</textual><xref class="po-milestone e85 e85" linkend="mul108"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. In addition to avoiding the view explosion problem (alluded to earlier) by publishing a single copy of each document, this type of approach is also more suited to deployment within decentralized architectures such as peer-to-peer, as it (1) facilitates the distribution of authentication and access control responsibilities between participating systems, rather than forcing reliance on a centralized component to enforce access control, and (2) is receptive to a variety of document distribution strategies, including broadcast, rather than being restricted to the client pull model. [</textual><xref class="po-milestone e86 e86" linkend="mul95"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]  and [</textual><xref class="po-milestone e87 e87" linkend="mul93"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] describe how to generate keys for documents and for DTDs/Schema; however, since at the schema level some conditions cannot be evaluated, keys must be generated at both the schema and document levels. </textual></para><para class="po-block e88 e88"><textual class="po-textual">
In this paper, we present key generation at the schema level based on the concept of symbolic grammar paths. In [</textual><xref class="po-milestone e89 e89" linkend="mul109"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], we describe the design of parameterized role access control policies, which has recently been implemented. </textual></para></section><section class="po-hcontainer e90 e90"><title class="po-block e91 e91"><textual class="po-textual">Access Control Policies</textual></title><para class="po-block e92 e92"><textual class="po-textual">
This section starts with a definition of ACPs at the document level, and then introduces ACP at the schema level. It also gives several examples that will be used throughout the paper. </textual></para><section class="po-hcontainer e93 e93"><title class="po-block e94 e94"><textual class="po-textual">Documents and Document Paths</textual></title><para class="po-block e95 e95"><textual class="po-textual">
In our approach, document fragments, or views, are described using document paths based on XPath [</textual><xref class="po-milestone e96 e96" linkend="mul112"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. For a document D, by P</textual><subscript class="po-atom e97 e97"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> we denote the set of paths in D. We allow disjunctions of document paths, using the | operator. To simplify the process of defining grammar path, we borrow the following two Unix/C conventions: </textual></para><para class="po-block e98 e98"><textual class="po-textual">

</textual><itemizedlist class="po-table e99 e99"><listitem class="po-container e100 e100"><para class="po-block e101 e101"><textual class="po-textual"> parameterless macros may be declared using the #define command, and then called using $macro-name </textual></para></listitem><listitem class="po-container e102 e102"><para class="po-block e103 e103"><textual class="po-textual"> substitutions of the form
      string</textual><subscript class="po-atom e104 e104"><textual class="po-textual">0</textual></subscript><textual class="po-textual">{string</textual><subscript class="po-atom e105 e105"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, string</textual><subscript class="po-atom e106 e106"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,..., string</textual><subscript class="po-atom e107 e107"><textual class="po-textual">n</textual></subscript><textual class="po-textual">}string</textual></para><para class="po-block e108 e108"><textual class="po-textual">denote</textual></para><para class="po-block e109 e109"><textual class="po-textual">
      string</textual><subscript class="po-atom e110 e110"><textual class="po-textual">0</textual></subscript><textual class="po-textual">string</textual><subscript class="po-atom e111 e111"><textual class="po-textual">1</textual></subscript><textual class="po-textual">string | string</textual><subscript class="po-atom e112 e112"><textual class="po-textual">0</textual></subscript><textual class="po-textual">string</textual><subscript class="po-atom e113 e113"><textual class="po-textual">2</textual></subscript><textual class="po-textual">string |...| string</textual><subscript class="po-atom e114 e114"><textual class="po-textual">0</textual></subscript><textual class="po-textual">string</textual><subscript class="po-atom e115 e115"><textual class="po-textual">n</textual></subscript><textual class="po-textual">string
</textual></para><para class="po-block e116 e116"><textual class="po-textual">
where | denotes the alternative. Nested {} are also supported.</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e117 e117"><textual class="po-textual">
For example</textual></para><programlisting class="po-block e118 e118" xml:space="preserve"><textual class="po-textual">
	#define HP	/H/P
	$HP/{a, b, c/{d,e}}
</textual></programlisting><para class="po-block e119 e119"><textual class="po-textual"> stands for </textual></para><programlisting class="po-block e120 e120" xml:space="preserve"><textual class="po-textual">
      /H/P/a | /H/P/b | /H/P/c/d | /H/P/c/e
</textual></programlisting><para class="po-block e121 e121" xml:id="Ex3.1" xreflabel="Example 3.1"><textual class="po-textual">
</textual><emphasis class="po-inline e122 e122" role="bold"><textual class="po-textual">Example 3.1. </textual></emphasis></para><para class="po-block e123 e123"><textual class="po-textual">
Consider a hospital, where there are three types of tests: basic, confidential and very confidential; and each patient has three attributes: name, Id, and perm (the last attribute determines whether or not patients with negative Ids will have access to very confidential tests). The path P: </textual></para><programlisting class="po-block e124 e124" xml:space="preserve"><textual class="po-textual">
	#define hp	/hospital/patient
	P: $hp{/@Id, /basic/text(), /basic, [@Id&lt;"0" AND @perm="true"]/veryConfidential/text()}
</textual></programlisting><para class="po-block e125 e125"><textual class="po-textual">is a document path for the following document D: </textual></para><programlisting class="po-block e126 e126" xml:space="preserve"><textual class="po-textual">
&lt;?xml version="1.0" encoding="UTF-4"?&gt;
&lt;hospital&gt;
	&lt;patient  name="Kay" Id="-1" perm="true" &gt;
		&lt;basic&gt;B1&lt;/basic&gt;
		&lt;confidential&gt;C1&lt;/confidential&gt;
		&lt;veryConfidential&gt;V1&lt;/veryConfidential&gt;
	&lt;/patient&gt;
	&lt;patient  name="Smith" Id="-2" perm="false" &gt;
		&lt;basic&gt;B2&lt;/basic&gt;
		&lt;confidential&gt;C2&lt;/confidential&gt;
		&lt;veryConfidential&gt;V2&lt;/veryConfidential&gt;
	&lt;/patient&gt;
	&lt;patient  name="Zen" Id="200" perm="true" &gt;
		&lt;basic&gt;B3&lt;/basic&gt;
		&lt;confidential&gt;C3&lt;/confidential&gt;
		&lt;veryConfidential&gt;V3&lt;/veryConfidential&gt;
	&lt;/patient&gt;
&lt;/hospital&gt;
</textual></programlisting><para class="po-block e127 e127"><textual class="po-textual">
The above path P defines a view of D consisting of values of Id for all patients (both attribute and its value), the tagname &lt;basic&gt; and its text values, B1, B2 and B3; and the value of V1.  □ </textual></para><section class="po-hcontainer e128 e128"><title class="po-block e129 e129"><textual class="po-textual">Document-level Access Control Policies, DRBAC</textual></title><para class="po-block e130 e130"><textual class="po-textual">
In this section we define document-level RBAC, DRBAC and the related protection requirement. Here, we use a subset of XPath; a path expression p consists of one or more location steps; each location step operates on the child axis.  A path is then of the form p | not p | p1 intersect p2 | p1 union p2 , and its evaluation produces an ordered sequence of nodes. A valid path is any path which does not evaluate to an empty sequence. </textual></para><para class="po-block e131 e131"><textual class="po-textual">
</textual><emphasis class="po-inline e132 e132" role="bold"><textual class="po-textual">Definition 3.1. </textual></emphasis></para><para class="po-block e133 e133"><textual class="po-textual">
For an XML document D and a finite set Ψ of roles, the document-level RBAC (DRBAC) is a mapping π</textual><subscript class="po-atom e134 e134"><textual class="po-textual">D</textual></subscript><textual class="po-textual">:Ψ→P</textual><subscript class="po-atom e135 e135"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> such that π</textual><subscript class="po-atom e136 e136"><textual class="po-textual">D</textual></subscript><textual class="po-textual">(Ψ) covers the set D; i.e., each element of D belongs to at least one document path that occurs in the policy. Often, the mapping π</textual><subscript class="po-atom e137 e137"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> is tabulated and shown as a tuple [(R</textual><subscript class="po-atom e138 e138"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, P</textual><subscript class="po-atom e139 e139"><textual class="po-textual">1</textual></subscript><textual class="po-textual">),(R</textual><subscript class="po-atom e140 e140"><textual class="po-textual">2</textual></subscript><textual class="po-textual">, P</textual><subscript class="po-atom e141 e141"><textual class="po-textual">2</textual></subscript><textual class="po-textual">),...,(R</textual><subscript class="po-atom e142 e142"><textual class="po-textual">n</textual></subscript><textual class="po-textual">, P</textual><subscript class="po-atom e143 e143"><textual class="po-textual">n</textual></subscript><textual class="po-textual">)] □ </textual></para><para class="po-block e144 e144"><textual class="po-textual">
There are various </textual><emphasis class="po-inline e145 e145" role="ital"><textual class="po-textual">views </textual></emphasis><textual class="po-textual"> of the document D, and each view is defined by π</textual><subscript class="po-atom e146 e146"><textual class="po-textual">D</textual></subscript><textual class="po-textual">(R). The designer of the policy for an XML document D may decide to leave some parts of D unencrypted (accessible to all users) or to make them inaccessible to all users (i.e., to encrypt them, but not to provide the key used for encryption of these nodes to any user). For the former case, the symbol ♥ is used, while for the latter case we use the symbol •. Therefore, the actual definition of the document-level RBAC is that it is pair (π</textual><subscript class="po-atom e147 e147"><textual class="po-textual">D</textual></subscript><textual class="po-textual">, ♦), where ♦ is either ♥ or •.
For simplicity (unless specified otherwise), in the sequel, we omit the second element of this pair, and assume that by default it is always • (i.e. by default, elements of D not covered by D are inaccessible to all users). </textual></para><para class="po-block e148 e148"><textual class="po-textual">
</textual><emphasis class="po-inline e149 e149" role="bold"><textual class="po-textual">Definition 3.2. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e150 e150"><textual class="po-textual">
The document-level protection requirement is said to be satisfied under the following conditions. For an XML document D, a finite set of roles Ψ, and the document-level RBAC π</textual><subscript class="po-atom e151 e151"><textual class="po-textual">D</textual></subscript><textual class="po-textual">:Ψ→P</textual><subscript class="po-atom e152 e152"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> a user in role R can access precisely the set π</textual><subscript class="po-atom e153 e153"><textual class="po-textual">D</textual></subscript><textual class="po-textual">(R), and if the policy uses ♥ also those nodes in D which are not covered by any path.  □ </textual></para><para class="po-block e154 e154"><textual class="po-textual">
</textual><emphasis class="po-inline e155 e155" role="bold"><textual class="po-textual">Example 3.2. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e156 e156" xml:id="Ex3.2" xreflabel="Example 3.2"><textual class="po-textual">
Consider the document D from [</textual><xref class="po-milestone e157 e157" linkend="Ex3.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and a set of roles Ψ = {Nurse, Physician, Resident, Smith}. We define four document paths: </textual></para><programlisting class="po-block e158 e158" xml:space="preserve"><textual class="po-textual">
	#define hp	/hospital/patient
	#define Sname  	$hp[@name="Smith"]
	ND: $hp{/@Id, [@Id&lt;0]/basic/text()}
	PD: $hp/{@Id, @name, basic/text(), confidential/text(), veryConfidential/text()}
	RD: $hp{/@Id, [@Id&gt;"100" AND @perm= "true"]/veryConfidential/text()}
	SD: $Sname/{@perm, basic/text(), confidential/text(), veryConfidential/text() }
</textual></programlisting><para class="po-block e159 e159"><textual class="po-textual">
We now define π</textual><subscript class="po-atom e160 e160"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> as: [(Nurse, ND), (Physician, PD), (Resident, RD), (Smith, SD)], which gives: </textual></para><itemizedlist class="po-table e161 e161"><listitem class="po-container e162 e162"><para class="po-block e163 e163"><textual class="po-textual">the user in role Nurse access to Ids of all patients, and to the textual content of the basic test for patients whose Id is negative; </textual></para></listitem><listitem class="po-container e164 e164"><para class="po-block e165 e165"><textual class="po-textual"> the user in role Physician access to Ids and names of all patients, and to the textual content of the basic, confidential and very confidential tests; </textual></para></listitem><listitem class="po-container e166 e166"><para class="po-block e167 e167"><textual class="po-textual"> the user in role Resident access to Ids of all patients, and to the textual content of the very confidential test for patients whose Id is greater than 100 and perm is set to true;
</textual></para></listitem><listitem class="po-container e168 e168"><para class="po-block e169 e169"><textual class="po-textual"> the user in role Smith access to permissions, and the textual content of the basic, confidential and very confidential test for these patients whose name is Smith </textual></para></listitem></itemizedlist><para class="po-block e170 e170"><textual class="po-textual">
Since by default we use the role •, other elements of D are available to nobody. In </textual><xref class="po-milestone e171 e171" linkend="fig1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, B1, C1, etc. stand for the text contents of the basic tag, confidential tag, etc.; elements accessible to the user in various roles are labeled with dotted boxes containing first letters of the names of these roles; nodes which are not available to any user are not labeled. </textual></para><figure class="po-container e172 e172" floatstyle="1" xml:id="fig1" xreflabel="Figure 1"><mediaobject class="po-container e173 e173"><imageobject class="po-container e174 e174"><imagedata class="po-meta e175 e175" fileref="../../../vol1/graphics/Muldner01/Muldner01-001.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual"> Labeled document tree for the hospital</textual></para></caption></mediaobject></figure><para class="po-block e178 e178"><textual class="po-textual">
Let us now use [</textual><xref class="po-milestone e179 e179" linkend="Ex3.2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] to compare super-encryption and multi-encryption. In the former case, nodes which are on the intersection of document paths would have to be encrypted and then decrypted with several keys. In the latter case, each node will be encrypted and decrypted with a single key. (In Section 6, we provide results of experiments comparing these two techniques.) </textual></para></section></section><section class="po-hcontainer e180 e180"><title class="po-block e181 e181"><textual class="po-textual"> Schemas and Grammar Paths</textual></title><para class="po-block e182 e182"><textual class="po-textual">
In this paper, we consider schema-oriented XML documents which have to follow the grammar rules specified by an associated schema, rather than schema-less documents which merely have to be well-formed according to the XML language specification [</textual><xref class="po-milestone e183 e183" linkend="mul111"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. A commonly used grammar description is XML Schema [</textual><xref class="po-milestone e184 e184" linkend="mul113"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], which we also use in this paper. Throughout this paper, by L</textual><subscript class="po-atom e185 e185"><textual class="po-textual">Σ</textual></subscript><textual class="po-textual"> we denote the language generated by the schema Σ. Specifically, if Σ is the schema of schemas, i.e. the grammar defining schemas, then L</textual><subscript class="po-atom e186 e186"><textual class="po-textual">Σ</textual></subscript><textual class="po-textual"> is the language of all schemas, and for S∈L</textual><subscript class="po-atom e187 e187"><textual class="po-textual">Σ</textual></subscript><textual class="po-textual">, a document D is valid for S iff  D∈L</textual><subscript class="po-atom e188 e188"><textual class="po-textual">S</textual></subscript><textual class="po-textual">. We consider only schemas for which there are no anonymous types (we can do it without a loss of generality because a schema with anonymous types can always have these types replaced by named types.) In the current implementation, we consider only schema with no cycles. By the top-level typename of the schema S, we mean the typename of the root element of any document valid in S. With each schema, we will associate a schema graph. The following examples show two schema and the corresponding graphs. </textual></para><para class="po-block e189 e189" xml:id="Ex3.3" xreflabel="Example 3.3"><textual class="po-textual">
</textual><emphasis class="po-inline e190 e190" role="bold"><textual class="po-textual">Example 3.3. </textual></emphasis></para><para class="po-block e191 e191"><textual class="po-textual">
Consider a reference letter, which provides a specification as to whether or not the letter is confidential, names of a referee and an applicant, and zero, one or more reviews, where each review provides the name of a supervisor, a numeric score, and a comment. The schema T for such a reference letter is given below.
</textual></para><programlisting class="po-block e192 e192" xml:space="preserve"><textual class="po-textual">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
	&lt;xs:element name="letter" type="LetterType"/&gt;
	&lt;xs:complexType name="LetterType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="referee" type="NameType"/&gt;
			&lt;xs:element name="applicant" type="NameType"/&gt;
			&lt;xs:element name="review" type="ReviewType"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="confidential" type="xs:boolean"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="ReviewType" maxOccurs="unbounded"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="supervisorName" type="NameType"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="score" type="xs:integer"/&gt;
		&lt;xs:attribute name="comments" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="NameType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="first" type="xs:string"/&gt;
			&lt;xs:element name="last" type="xs:string"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</textual></programlisting><para class="po-block e193 e193"><textual class="po-textual">
Schema graph for the Schema T (see </textual><xref class="po-milestone e194 e194" linkend="fig2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) replicates nodes that represent elements of the same type. This graph shows </textual><emphasis class="po-inline e195 e195" role="ital"><textual class="po-textual">types</textual></emphasis><textual class="po-textual"> used in the schema. The alternative representation, used by this paper, (see </textual><xref class="po-milestone e196 e196" linkend="fig3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) will focus on </textual><emphasis class="po-inline e197 e197" role="ital"><textual class="po-textual">element names</textual></emphasis><textual class="po-textual"> from the schema, and will </textual><emphasis class="po-inline e198 e198" role="ital"><textual class="po-textual">optionally</textual></emphasis><textual class="po-textual"> show types of these elements (shown in dotted boxes with gray background). </textual></para><figure class="po-container e199 e199" floatstyle="1" xml:id="fig2" xreflabel="Figure 2"><mediaobject class="po-container e200 e200"><imageobject class="po-container e201 e201"><imagedata class="po-meta e202 e202" fileref="../../../vol1/graphics/Muldner01/Muldner01-002.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e203 e203"><para class="po-block e204 e204"><textual class="po-textual"> Schema graph for schema T (based on types) </textual></para></caption></mediaobject></figure><figure class="po-container e205 e205" floatstyle="1" xml:id="fig3" xreflabel="Figure 3"><mediaobject class="po-container e206 e206"><imageobject class="po-container e207 e207"><imagedata class="po-meta e208 e208" fileref="../../../vol1/graphics/Muldner01/Muldner01-003.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e209 e209"><para class="po-block e210 e210"><textual class="po-textual"> Schema graph for schema T (based on element names)</textual></para></caption></mediaobject></figure><para class="po-block e211 e211" xml:id="Ex3.4" xreflabel="Example 3.4"><textual class="po-textual">
</textual><emphasis class="po-inline e212 e212" role="bold"><textual class="po-textual">Example 3.4. </textual></emphasis></para><para class="po-block e213 e213"><textual class="po-textual">
The schema S (see the schema graph in </textual><xref class="po-milestone e214 e214" linkend="fig4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) is a schema for which the document D from [</textual><xref class="po-milestone e215 e215" linkend="Ex3.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] valid. </textual></para><programlisting class="po-block e216 e216" xml:space="preserve"><textual class="po-textual">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
	&lt;xs:element name="hospital" type="HospitalType"/&gt;
	&lt;xs:complexType name="HospitalType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="patient" type="PatientType" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="PatientType"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="basic" type="xs:string"/&gt;
			&lt;xs:element name="confidential" type="xs:string"/&gt;
			&lt;xs:element name="veryConfidential" type="xs:string"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="name" type="xs:string"/&gt;
		&lt;xs:attribute name="Id" type="xs:int"/&gt;
		&lt;xs:attribute name="perm" type="xs:boolean"/&gt;
	&lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</textual></programlisting><figure class="po-container e217 e217" floatstyle="1" xml:id="fig4" xreflabel="Figure 4"><mediaobject class="po-container e218 e218"><imageobject class="po-container e219 e219"><imagedata class="po-meta e220 e220" fileref="../../../vol1/graphics/Muldner01/Muldner01-004.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e221 e221"><para class="po-block e222 e222"><textual class="po-textual"> Schema graph for schema S</textual></para></caption></mediaobject></figure><para class="po-block e223 e223"><textual class="po-textual">
In Section 3.1, we defined views of XML documents using document paths. To define views of a schema S, we introduce </textual><emphasis class="po-inline e224 e224" role="ital"><textual class="po-textual">grammar paths</textual></emphasis><textual class="po-textual">. For a document D valid in S, a grammar path may be </textual><emphasis class="po-inline e225 e225" role="ital"><textual class="po-textual">materialized</textual></emphasis><textual class="po-textual"> to produce the document path for D. This way, views of a schema determine views of documents valid in the schema. Here, we consider only absolute paths, but relative paths can be defined in the same way. We denote by Π</textual><subscript class="po-atom e226 e226"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> the set of all grammar paths for the schema S.  A triple (schema S, grammar path G, document D valid in S) defines a document path denoted by Π</textual><subscript class="po-atom e227 e227"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(G); we refer to this process as a grammar path materialization. </textual></para><para class="po-block e228 e228"><textual class="po-textual">We start by defining an </textual><emphasis class="po-inline e229 e229" role="ital"><textual class="po-textual">atomic grammar path</textual></emphasis><textual class="po-textual">, which is of the form /c</textual><subscript class="po-atom e230 e230"><textual class="po-textual">1</textual></subscript><textual class="po-textual">/c</textual><subscript class="po-atom e231 e231"><textual class="po-textual">2</textual></subscript><textual class="po-textual">/.../c</textual><subscript class="po-atom e232 e232"><textual class="po-textual">n</textual></subscript><textual class="po-textual">. Each c</textual><subscript class="po-atom e233 e233"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is a tag name optionally followed by a predicate in square brackets. (If the predicate is present, then c</textual><subscript class="po-atom e234 e234"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is called the current context node.)  A </textual><emphasis class="po-inline e235 e235" role="ital"><textual class="po-textual">predicate</textual></emphasis><textual class="po-textual"> is formed using standard Boolean operators: &amp;&amp;, ||, and ! (using standard associativity and precedence rules) and atomic predicates. There are three kinds of atomic predicates:
</textual></para><itemizedlist class="po-table e236 e236"><listitem class="po-container e237 e237"><para class="po-block e238 e238"><textual class="po-textual">equality and inequality comparisons for values of attributes of type string or Boolean </textual></para></listitem><listitem class="po-container e239 e239"><para class="po-block e240 e240"><textual class="po-textual">equality and inequality comparisons for the textual content of the current context node, specified using text()
</textual></para></listitem><listitem class="po-container e241 e241"><para class="po-block e242 e242"><textual class="po-textual">arbitrary comparisons for values of numerical attributes
</textual></para></listitem></itemizedlist><para class="po-block e243 e243"><textual class="po-textual">Note that if content of the element is </textual><emphasis class="po-inline e244 e244" role="ital"><textual class="po-textual">mixed</textual></emphasis><textual class="po-textual">, i.e. contains both textual content and sub-elements then text() denotes the concatenation of all textual contents of this element. </textual></para><para class="po-block e245 e245"><textual class="po-textual">
In order to support nested conditions, atomic predicates may also be preceded by one of the following unconditional paths, where the i-th component b</textual><subscript class="po-atom e246 e246"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is a tag name: </textual></para><itemizedlist class="po-table e247 e247"><listitem class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual"> /b</textual><subscript class="po-atom e250 e250"><textual class="po-textual">1</textual></subscript><textual class="po-textual">/b</textual><subscript class="po-atom e251 e251"><textual class="po-textual">2</textual></subscript><textual class="po-textual">/.../b</textual><subscript class="po-atom e252 e252"><textual class="po-textual">n</textual></subscript><textual class="po-textual">/; i.e. the absolute path </textual></para></listitem><listitem class="po-container e253 e253"><para class="po-block e254 e254"><textual class="po-textual"> b</textual><subscript class="po-atom e255 e255"><textual class="po-textual">1</textual></subscript><textual class="po-textual">/b</textual><subscript class="po-atom e256 e256"><textual class="po-textual">2</textual></subscript><textual class="po-textual">/.../b</textual><subscript class="po-atom e257 e257"><textual class="po-textual">n</textual></subscript><textual class="po-textual">/; i.e. the relative path that starts from the current context node
</textual></para></listitem><listitem class="po-container e258 e258"><para class="po-block e259 e259"><textual class="po-textual"> ../b</textual><subscript class="po-atom e260 e260"><textual class="po-textual">1</textual></subscript><textual class="po-textual">/b</textual><subscript class="po-atom e261 e261"><textual class="po-textual">2</textual></subscript><textual class="po-textual">/.../b</textual><subscript class="po-atom e262 e262"><textual class="po-textual">n</textual></subscript><textual class="po-textual">/; i.e. the relative path that starts from the parent of the current context node
</textual></para></listitem></itemizedlist><para class="po-block e263 e263"><textual class="po-textual">
Two examples of atomic grammar paths are:
</textual><programlisting class="po-block e264 e264" xml:space="preserve"><textual class="po-textual">
	/H[@x &gt; "1" || @x &lt; "0" &amp;&amp;  @y = "0"]/P[text() = "John"]
	/H/B[../C/@z &gt; "2" || /H/D/text() = "Mary"]/E
</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e265 e265"><textual class="po-textual">
Atomic paths may have conditions involving nested paths, but they specify only a single node. Often it is convenient to specify subtrees, or parts thereof. Therefore, we define a simple grammar path, which is an atomic grammar path followed by a subtree operator of the form: </textual></para><para class="po-block e266 e266"><textual class="po-textual">
</textual><programlisting class="po-block e267 e267" xml:space="preserve"><textual class="po-textual">
      &lt;text = O3; att = O3; tag = O3&gt;
</textual></programlisting><textual class="po-textual">
</textual></para><para class="po-block e268 e268"><textual class="po-textual">
where</textual></para><para class="po-block e269 e269"><textual class="po-textual">
</textual><itemizedlist class="po-table e270 e270"><listitem class="po-container e271 e271"><para class="po-block e272 e272"><textual class="po-textual">all fields (text, att, and tag) may appear in any order (and are separated by ";")
</textual></para></listitem><listitem class="po-container e273 e273"><para class="po-block e274 e274"><textual class="po-textual">fields are optional, but at least one must be present </textual></para></listitem><listitem class="po-container e275 e275"><para class="po-block e276 e276"><textual class="po-textual">O3 is described below by the following regular expression  </textual></para><para class="po-block e277 e277"><textual class="po-textual">O1=["*" "+"]; i.e. a character class consisting of * and +</textual></para><para class="po-block e278 e278"><textual class="po-textual">O2 = (O1 | ".") | ("text" (O1?)); i.e. O1 or "." or "text" optionally followed by O1</textual></para><para class="po-block e279 e279"><textual class="po-textual">O3 = O2 (","O2)*; ie. one or more O2, separated by";"</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e280 e280"><textual class="po-textual">The meaning of subtree operators is explained in [</textual><xref class="po-milestone e281 e281" linkend="Ex3.5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Finally, a </textual><emphasis class="po-inline e282 e282" role="ital"><textual class="po-textual">grammar path</textual></emphasis><textual class="po-textual"> is an atomic grammar path, or a simple grammar path, or one or more alternatives of such paths. </textual></para><para class="po-block e283 e283"><textual class="po-textual">For a given schema, a grammar path is valid if it satisfies constraints imposed by the Schema, for example that an element name exists (in the given context), or the attribute value is a correct data type. </textual></para><para class="po-block e284 e284" xml:id="Ex3.5" xreflabel="Example 3.5"><textual class="po-textual">
</textual><emphasis class="po-inline e285 e285" role="bold"><textual class="po-textual">Example 3.5. </textual></emphasis></para><para class="po-block e286 e286"><textual class="po-textual"> Below, we use the following terminology: </textual></para><itemizedlist class="po-table e287 e287"><listitem class="po-container e288 e288"><para class="po-block e289 e289"><textual class="po-textual"> all descendants of c, meaning all descendants of c, including c; </textual></para></listitem><listitem class="po-container e290 e290"><para class="po-block e291 e291"><textual class="po-textual"> all proper descendants of c, meaning all descendants of c, excluding c; </textual></para></listitem><listitem class="po-container e292 e292"><para class="po-block e293 e293"><textual class="po-textual"> children of c, meaning only children of c and not grand-children, etc.
</textual></para></listitem></itemizedlist><para class="po-block e294 e294"><textual class="po-textual">In all examples given below c is the last component of a simple grammar path: </textual></para><programlisting class="po-block e295 e295" xml:space="preserve"><textual class="po-textual">
  All text descendants of c:					c&lt;text=*&gt;
  All proper text descendants of c:				c&lt;text=+&gt;
  Text child of c (concatenated for mixed content):		c&lt;text=.&gt;
  All text descendants of c that are equal to "the":		c&lt;text="the"*&gt;
  All proper text descendants of c that are equal to "the":	c&lt;text="the"+&gt;
  Concatenated text children of c that is equal to "the":	c&lt;text="the"&gt;
  All attribute descendants of c:				c&lt;att=*&gt;
  All proper attribute descendants of c:			c&lt;att=+&gt;
  All attribute children (attributes) of c:			c&lt;at =.&gt;
  A specific attribute foo of c:				c&lt;att="foo"&gt;
  All "foo" attribute descendants of c:				c&lt;att="foo"*&gt;
  All proper "foo" attribute descendants of c:			c&lt;att="foo"+&gt;
  The tag of c:							c&lt;tag="."&gt; or c
  All element descendants of c:					c&lt;tag=*&gt;
  All proper element descendants of c:				c&lt;tag=+&gt;
  All element children (sub-elements) of c:			c&lt;tag=.&gt;
  A specific tag foo of c:					c&lt;tag = "foo"&gt;
  All element descendants called "foo" of c:			c&lt;tag="foo"*&gt;
  All proper element descendants called "foo" of c:		c&lt;tag="foo"+&gt;
  All descendants of c:						c&lt;*&gt;
  All proper descendants f c					c&lt;+&gt;
  All children of c						c&lt;.&gt;
Finally, some examples of combined fields:
  All proper text descendants of c and all attributes of c:	c&lt;text=*; att =*&gt;
  Attributes foo and goo of c and the tag of c:			c&lt;att = "foo", "goo"; tag =.&gt;
  All element descendants "foo" and "goo" of c, all "hoo" attribute decendants, and the text of c:
   c&lt;tag="foo"*, "goo"*; att="hoo"*; text=.&gt; □
</textual></programlisting><para class="po-block e296 e296" xml:id="Ex3.6" xreflabel="Example 3.6"><textual class="po-textual">
</textual><emphasis class="po-inline e297 e297" role="bold"><textual class="po-textual">Example 3.6. </textual></emphasis></para><para class="po-block e298 e298"><textual class="po-textual">
Below, we provide three grammar paths R, C, and N for the schema T from [</textual><xref class="po-milestone e299 e299" linkend="Ex3.3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]: </textual></para><para class="po-block e300 e300"><textual class="po-textual">
</textual><programlisting class="po-block e301 e301" xml:space="preserve"><textual class="po-textual">
	R: /letter[review/score/text() &gt; "7"]/referee/last&lt;text=.&gt;
	C: /letter[!(/referee/last/text() = "Smith" ||
           /referee/last/text() = "Kerry")]&lt;att="comments", "score"&gt;
	N: /letter[@confidential = "false"]/{referee, applicant, review/supervisor}&lt;text=+&gt; |
          /letter[@confidential = "true" &amp;&amp; review/score/text() &gt; "5"
             || applicant/last/text() = "Brown"]/review/supervisor&lt;text=+&gt;
</textual></programlisting><textual class="po-textual">
□
</textual></para><section class="po-hcontainer e302 e302"><title class="po-block e303 e303"><textual class="po-textual"> Schema-level Access Control Policies, SRBAC
</textual></title><para class="po-block e304 e304"><textual class="po-textual">
In this section we define schema-level RBAC, SRBAC and the related protection requirement. </textual></para><para class="po-block e305 e305"><textual class="po-textual">
</textual><emphasis class="po-inline e306 e306" role="bold"><textual class="po-textual">Definition 3.3. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e307 e307"><textual class="po-textual">
For a schema S, and a set Ψ of roles, an SRBAC policy is a mapping π</textual><subscript class="po-atom e308 e308"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e309 e309"><textual class="po-textual">S</textual></subscript><textual class="po-textual">.□
</textual></para><para class="po-block e310 e310" xml:id="Ex3.7" xreflabel="Example 3.7"><textual class="po-textual">
</textual><emphasis class="po-inline e311 e311" role="bold"><textual class="po-textual">Example 3.7. </textual></emphasis></para><para class="po-block e312 e312"><textual class="po-textual">
For the schema T from [</textual><xref class="po-milestone e313 e313" linkend="Ex3.3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] we define the SRBAC policy π</textual><subscript class="po-atom e314 e314"><textual class="po-textual">T</textual></subscript><textual class="po-textual">: [(REFEREE, R), (COMMENT, C), (NAME, N)], where R, C and N are grammar paths from [</textual><xref class="po-milestone e315 e315" linkend="Ex3.6"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Here: </textual></para><itemizedlist class="po-table e316 e316"><listitem class="po-container e317 e317"><para class="po-block e318 e318"><textual class="po-textual"> role REFEREE gives access to last names of referees for reviews with the score greater than 7</textual></para></listitem><listitem class="po-container e319 e319"><para class="po-block e320 e320"><textual class="po-textual"> role COMMENT gives access to all comments and scores, provided that the referee last name is neither Smith nor Kerry </textual></para></listitem><listitem class="po-container e321 e321"><para class="po-block e322 e322"><textual class="po-textual"> role NAME gives access to all names for non-confidential letters and for supervisor names provided that the letter is confidential and the score is greater than 5, or last name of the applicant is Brown</textual></para></listitem></itemizedlist><para class="po-block e323 e323" xml:id="Ex3.8" xreflabel="Example 3.8"><textual class="po-textual">
</textual><emphasis class="po-inline e324 e324" role="bold"><textual class="po-textual">Example 3.8.  </textual></emphasis></para><para class="po-block e325 e325"><textual class="po-textual">
For the schema S from [</textual><xref class="po-milestone e326 e326" linkend="Ex3.4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], we define the SRBAC policy π</textual><subscript class="po-atom e327 e327"><textual class="po-textual">S</textual></subscript><textual class="po-textual">: [(Nurse, N), (Physician, P), (Resident, R), (Smith, S)], where roles N, P, R, and S are defined as follows: </textual></para><programlisting class="po-block e328 e328" xml:space="preserve"><textual class="po-textual">
	#define HP	/hospital/patient
	#define HPN	$HP&lt;att="Id"&gt;
	#define SS  	$HP[@name="Smith"]
	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
	R: $HPN | $HP{/confidential&lt;text=.&gt;, [@Id&gt;"100" &amp;&amp;
		@perm="true"]/veryConfidential&lt;text=.&gt; }
	S: $SS/{@perm, basic&lt;text=.&gt;, confidential&lt;text=.&gt;, veryConfidential&lt;text=.&gt;}
</textual></programlisting><para class="po-block e329 e329"><textual class="po-textual">
The above SRBAC policy gives the patient Smith access to her data. Existence of multiple patients who should have this kind of access will result in role proliferation. A solution to this problem is to use parameterized roles, and this is the subject of our current research, see [</textual><xref class="po-milestone e330 e330" linkend="mul109"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. </textual></para><para class="po-block e331 e331"><textual class="po-textual">
For every document valid in the schema S, a schema-based ACP defines document-based ACP for this document</textual></para><para class="po-block e332 e332"><textual class="po-textual">
</textual><emphasis class="po-inline e333 e333" role="bold"><textual class="po-textual">Definition 3.4. </textual></emphasis></para><para class="po-block e334 e334"><textual class="po-textual">
For an XML Schema S, instance document D∈L</textual><subscript class="po-atom e335 e335"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, and the schema-based policy π</textual><subscript class="po-atom e336 e336"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e337 e337"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, we define the schema-induced document policy π</textual><subscript class="po-atom e338 e338"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">:Ψ→P</textual><subscript class="po-atom e339 e339"><textual class="po-textual">D</textual></subscript><textual class="po-textual">,  by materializing grammar paths; i.e. π</textual><subscript class="po-atom e340 e340"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(R)= Π</textual><subscript class="po-atom e341 e341"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(π</textual><subscript class="po-atom e342 e342"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R)), for R∈Ψ.□</textual></para><para class="po-block e343 e343"><textual class="po-textual">
Now, we formulate the schema-level protection requirement in a manner similar to that from Def. 3.2: </textual></para><para class="po-block e344 e344"><textual class="po-textual">
</textual><emphasis class="po-inline e345 e345" role="bold"><textual class="po-textual">Definition 3.5. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e346 e346"><textual class="po-textual">
The </textual><emphasis class="po-inline e347 e347" role="ital"><textual class="po-textual">schema-level protection requirement</textual></emphasis><textual class="po-textual"> is said to be satisfied under the following conditions. For the schema S, the schema-based ACP π</textual><subscript class="po-atom e348 e348"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e349 e349"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> and role R∈Ψ, the user in a role R accessing a document D∈L</textual><subscript class="po-atom e350 e350"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, can read precisely the view π</textual><subscript class="po-atom e351 e351"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(R).   □
</textual></para><para class="po-block e352 e352"><textual class="po-textual">
</textual><emphasis class="po-inline e353 e353" role="bold"><textual class="po-textual">Example 3.9. </textual></emphasis></para><para class="po-block e354 e354"><textual class="po-textual">
For any document D valid in the schema S from [</textual><xref class="po-milestone e355 e355" linkend="Ex3.4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], grammar paths from [</textual><xref class="po-milestone e356 e356" linkend="Ex3.8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] will be materialized as follows: </textual></para><para class="po-block e357 e357"><textual class="po-textual">
</textual><itemizedlist class="po-table e358 e358"><listitem class="po-container e359 e359"><para class="po-block e360 e360"><textual class="po-textual">Π</textual><subscript class="po-atom e361 e361"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(N) consists of Ids of all patients, and the textual content of the basic test for patients whose Id is negative </textual></para></listitem><listitem class="po-container e362 e362"><para class="po-block e363 e363"><textual class="po-textual"> Π</textual><subscript class="po-atom e364 e364"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(P)consists of Ids and names of all patients, and the textual content of the basic, confidential and very confidential tests </textual></para></listitem><listitem class="po-container e365 e365"><para class="po-block e366 e366"><textual class="po-textual">Π</textual><subscript class="po-atom e367 e367"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(R) consists of Ids of all patients, and the textual content of the very confidential test for patients whose Id is greater than 100 and perm is set to true
</textual></para></listitem><listitem class="po-container e368 e368"><para class="po-block e369 e369"><textual class="po-textual"> Π</textual><subscript class="po-atom e370 e370"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(S) gives access to permissions, and the textual content of the basic, confidential and very confidential test for these patients whose name is Smith.
</textual></para></listitem></itemizedlist><textual class="po-textual">
</textual></para><para class="po-block e371 e371"><textual class="po-textual">
For the specific document D from [</textual><xref class="po-milestone e372 e372" linkend="Ex3.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], these materializations will produce respectively paths ND, PD, RD and SD from [</textual><xref class="po-milestone e373 e373" linkend="Ex3.2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and so for the policy π</textual><subscript class="po-atom e374 e374"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> from [</textual><xref class="po-milestone e375 e375" linkend="Ex3.4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], the induced policy π</textual><subscript class="po-atom e376 e376"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual"> is the policy π</textual><subscript class="po-atom e377 e377"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> from [</textual><xref class="po-milestone e378 e378" linkend="Ex3.2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. □
</textual></para></section></section></section><section class="po-hcontainer e379 e379"><title class="po-block e380 e380"><textual class="po-textual">Key Generation and Document Encryption
</textual></title><para class="po-block e381 e381"><textual class="po-textual">
In this section, we describe key generation at the schema level, and also explain how these keys are used to encrypt documents valid in this schema. As we indicated in the introduction, actions that result in key generation at the schema level may afford less efficient processing because they are performed only once, before any document is to be encrypted. In addition, a typical schema definition (and therefore, its schema graph) is quite small; hence, we assume that that the schema graph is stored as a DOM tree in main memory. However, for multi-encrypting documents (which may be very large), we will only consider single pass, SAX-based parsing. In our approach, we generate keys at the schema level. However, one can also use a </textual><emphasis class="po-inline e382 e382" role="ital"><textual class="po-textual">lazy key generation</textual></emphasis><textual class="po-textual">: instead of pre-generating keys at the schema level, key generation will be triggered by the first document to be multi-encrypted. This would generate only the schema-based keys required for multi-encrypting this specific document (and they will be properly recorded). When the subsequent document is to be multi-encrypted, first we would determine if all necessary keys (at the schema level) have already been generated, and only generate any missing keys (at again recorded). </textual></para><para class="po-block e383 e383"><textual class="po-textual">
We start this section with basic definitions.
Then, we provide our most important result, which is a schema-based key generation algorithm,
and we define schema-based role-accessible keyrings.
Next, we describe an annotated schema and proceed to the second most important algorithm
which uses an annotated schema to efficiently multi-encrypt a document valid in this schema.
Our description will frequently refer to the schema S from [</textual><xref class="po-milestone e384 e384" linkend="Ex3.4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
 (which we will call a "running example"), its graph (see </textual><xref class="po-milestone e385 e385" linkend="fig4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), and grammar paths from [</textual><xref class="po-milestone e386 e386" linkend="Ex3.8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><section class="po-hcontainer e387 e387"><title class="po-block e388 e388"><textual class="po-textual">Introduction</textual></title><section class="po-hcontainer e389 e389"><title class="po-block e390 e390"><textual class="po-textual"> Encryption and Keyrings </textual></title><para class="po-block e391 e391"><textual class="po-textual">
There are two kinds of encryption: symmetric encryption, which uses a shared secret key, and asymmetric encryption, which uses a public-private key pair. For asymmetric encryption, we will call the public key part a </textual><emphasis class="po-inline e392 e392" role="ital"><textual class="po-textual">decrypting key</textual></emphasis><textual class="po-textual">, and the private key part an </textual><emphasis class="po-inline e393 e393" role="ital"><textual class="po-textual">encrypting key</textual></emphasis><textual class="po-textual">. If it does not lead to confusion, then by a key we mean a decrypting key in an asymmetric encryption and a key in a symmetric encryption. In our approach, we allow either kind of encryption. When asymmetric encryption is used, the user in role R can only decrypt the document fragment. But, with symmetric encryption, they can also encrypt the decrypted m-document. To avoid this problem, the digital signature of the m-document would have to be made available.
</textual></para><para class="po-block e394 e394"><textual class="po-textual"> </textual><emphasis class="po-inline e395 e395" role="bold"><textual class="po-textual">Definition 4.1. </textual></emphasis><textual class="po-textual">
</textual></para><para class="po-block e396 e396"><textual class="po-textual">
A keyring K is a finite set of keys. For an asymmetric encryption, each key is a triple (key name, encrypting key, decrypting key), and for a symmetric encryption it is a pair (key name, key). By K</textual><subscript class="po-atom e397 e397"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> we denote a schema-level keyring for the schema S and its policy π</textual><subscript class="po-atom e398 e398"><textual class="po-textual">S</textual></subscript><textual class="po-textual">. □</textual></para></section><section class="po-hcontainer e399 e399"><title class="po-block e400 e400"><textual class="po-textual"> Basic Notations </textual></title><para class="po-block e401 e401"><textual class="po-textual">
Let us first consider various ways keys may be assigned to documents.
 Since views may be overlapping, we can not assign keys per view.
Indeed, if we did so, then for two overlapping views V</textual><subscript class="po-atom e402 e402"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> and V</textual><subscript class="po-atom e403 e403"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> we would have two corresponding keys k</textual><subscript class="po-atom e404 e404"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> and k</textual><subscript class="po-atom e405 e405"><textual class="po-textual">2</textual></subscript><textual class="po-textual">, and the intersection of the two views would have to be super-encrypted (assigning keys per view would mean that for i=1,2, the user who has access to the view V</textual><subscript class="po-atom e406 e406"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> would be given a key k</textual><subscript class="po-atom e407 e407"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> and so other options such as encrypting V</textual><subscript class="po-atom e408 e408"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> with one key and V</textual><subscript class="po-atom e409 e409"><textual class="po-textual">2</textual></subscript><textual class="po-textual">-V</textual><subscript class="po-atom e410 e410"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> with the other key would provide access to the part that is not allowed). What we need to do is to partition the set D (and at the same time each view) into disjoint sets, and then assign one key for each set in this partition. Therefore, for an arbitrary partition {P</textual><subscript class="po-atom e411 e411"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, P</textual><subscript class="po-atom e412 e412"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,P</textual><subscript class="po-atom e413 e413"><textual class="po-textual">n</textual></subscript><textual class="po-textual">} of a set D, we need to find a </textual><emphasis class="po-inline e414 e414" role="ital"><textual class="po-textual">disjoint partition</textual></emphasis><textual class="po-textual">. One way to achieve this goal is to create all possible differences of intersections of sets in the partition and remaining unions. Note that in our paper by a </textual><emphasis class="po-inline e415 e415" role="ital"><textual class="po-textual">partition</textual></emphasis><textual class="po-textual"> we mean a family of subsets of a set D that does not necessarily cover D. </textual></para><para class="po-block e416 e416"><textual class="po-textual">
Here, we work at the schema level, rather than at the document level, but we need to generate keys in such a way that </textual><emphasis class="po-inline e417 e417" role="ital"><textual class="po-textual">materialized grammar paths</textual></emphasis><textual class="po-textual"> are disjoint. Since set operations for grammar paths (such as a union) are not defined, we now introduce symbolic grammar paths that allow such operations: </textual></para><para class="po-block e418 e418"><emphasis class="po-inline e419 e419" role="bold"><textual class="po-textual">Definition 4.2. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e420 e420"><textual class="po-textual">
Consider a set {P</textual><subscript class="po-atom e421 e421"><textual class="po-textual">i</textual></subscript><textual class="po-textual">: i=1,2,...,k} of grammar paths. By a </textual><emphasis class="po-inline e422 e422" role="ital"><textual class="po-textual">symbolic grammar path expression</textual></emphasis><textual class="po-textual"> we denote a finite set of string of the form:
</textual><figure class="po-container e423 e423" floatstyle="1" xml:id="eq42" xreflabel="eq42"><mediaobject class="po-container e424 e424"><imageobject class="po-container e425 e425"><imagedata class="po-meta e426 e426" fileref="../../../vol1/graphics/Muldner01/Muldner01-005.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">

</textual></para><para class="po-block e427 e427"><textual class="po-textual">
Since document paths support the above mentioned set operations, symbolic grammar paths can be materialized. </textual></para><para class="po-block e428 e428"><textual class="po-textual">
</textual><emphasis class="po-inline e429 e429" role="bold"><textual class="po-textual">Definition 4.3. </textual></emphasis></para><para class="po-block e430 e430"><textual class="po-textual">
</textual><figure class="po-container e431 e431" floatstyle="1" xml:id="eq43" xreflabel="eq43"><mediaobject class="po-container e432 e432"><imageobject class="po-container e433 e433"><imagedata class="po-meta e434 e434" fileref="../../../vol1/graphics/Muldner01/Muldner01-006.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><textual class="po-textual">□
</textual></para><para class="po-block e435 e435" xml:id="Ex4.1" xreflabel="Example 4.1"><textual class="po-textual">
</textual><emphasis class="po-inline e436 e436" role="bold"><textual class="po-textual">Example 4.1. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e437 e437"><textual class="po-textual">
Consider first two grammar paths from [</textual><xref class="po-milestone e438 e438" linkend="Ex3.8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and recalled below: </textual></para><programlisting class="po-block e439 e439" xml:space="preserve"><textual class="po-textual">
	#define HP	/hospital/patient
	#define HPN	$HP&lt;att="Id"&gt;
	N: $HPN | $HP/[@Id&lt;"0"]/basic&lt;text=.&gt;
	P: /hospital/patient&lt;att="Id","name"; text=*&gt;
</textual></programlisting><para class="po-block e440 e440"><textual class="po-textual">
Here, we have three symbolic grammar paths: N-P, P-N and N*P. To show materializations of the paths, consider the document D valid in S (see </textual><xref class="po-milestone e441 e441" linkend="fig1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">. For this document, we have: </textual></para><figure class="po-container e442 e442" floatstyle="1" xml:id="eq44" xreflabel="eq44"><mediaobject class="po-container e443 e443"><imageobject class="po-container e444 e444"><imagedata class="po-meta e445 e445" fileref="../../../vol1/graphics/Muldner01/Muldner01-007.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><para class="po-block e446 e446"><textual class="po-textual">Note that the above materializations cover the same subset of D as materializations of original grammar paths, but unlike the original grammar paths, they are disjoint. □</textual></para></section></section><section class="po-hcontainer e447 e447"><title class="po-block e448 e448"><textual class="po-textual">Key Generation </textual></title><para class="po-block e449 e449"><textual class="po-textual">
To generate keys for the schema S one can use the following technique. For every symbolic grammar path, generate a key for that path, and then use these keys to multi-encrypt materializations of document valid in S. However, by following this approach, we would not avoid generating keys for symbolic grammar paths that will always be materialized to </textual><emphasis class="po-inline e450 e450" role="ital"><textual class="po-textual">empty document paths</textual></emphasis><textual class="po-textual">. Therefore, we use a different approach, described below. </textual></para><para class="po-block e451 e451"><textual class="po-textual">
A </textual><emphasis class="po-inline e452 e452" role="ital"><textual class="po-textual">target</textual></emphasis><textual class="po-textual"> of a grammar path G is a single node in SG, or a node and a subgraph rooted at the node. An </textual><emphasis class="po-inline e453 e453" role="ital"><textual class="po-textual">abstract value</textual></emphasis><textual class="po-textual"> of G is a list of targets with the associated information about values of conditions that appear in G. Our algorithm finds abstract values of symbolic grammar paths corresponding to grammar paths in the SRBAC policy. We then use these values to avoid generating keys for these symbolic grammar paths whose abstract values are empty. Note that our algorithm additionally avoids creating redundant keys for two or more grammar paths whose abstract values are subsets; for example if the abstract value of G</textual><subscript class="po-atom e454 e454"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> is a subset of the abstract value of G</textual><subscript class="po-atom e455 e455"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> then the symbolic grammar path G</textual><subscript class="po-atom e456 e456"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> - G</textual><subscript class="po-atom e457 e457"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> evaluates to empty. Since at the schema level we </textual><emphasis class="po-inline e458 e458" role="ital"><textual class="po-textual">do not know values of conditions</textual></emphasis><textual class="po-textual"> that appear in grammar paths, we proceed as follows. By a </textual><emphasis class="po-inline e459 e459" role="ital"><textual class="po-textual">configuration</textual></emphasis><textual class="po-textual"> we refer to a bit-vector that represents true/false values of all conditions that appear in symbolic grammar paths (i.e., if the i-th condition evaluates to true, the i-th bit is set to 1, and 0 otherwise). We annotate every node of the schema graph with the list of pairs of the form (configurations, key).
</textual></para></section><section class="po-hcontainer e460 e460"><title class="po-block e461 e461"><textual class="po-textual">Configurations</textual></title><para class="po-block e462 e462"><textual class="po-textual">
A </textual><emphasis class="po-inline e463 e463" role="ital"><textual class="po-textual">configuration</textual></emphasis><textual class="po-textual"> is a binary value of size k that represents true/false values of conditions. For a given grammar path X and a configuration C, values of all conditions in X are known, and therefore we can find an abstract value of X, which consists of one or more targets for the configuration C. A </textual><emphasis class="po-inline e464 e464" role="ital"><textual class="po-textual">configuration index value</textual></emphasis><textual class="po-textual"> is the integer decimal value corresponding to the binary value of this configuration. When it does not lead to confusion, we identify a configuration and its index value. Some configurations should be </textual><emphasis class="po-inline e465 e465" role="ital"><textual class="po-textual">excluded</textual></emphasis><textual class="po-textual"> e.g. if they specify true values for two conditions (involving the same attribute) that cannot be true at the same time (and arbitrary values for other conditions). </textual></para><para class="po-block e466 e466"><textual class="po-textual">
</textual><emphasis class="po-inline e467 e467" role="bold"><textual class="po-textual">Algorithm 4.1</textual></emphasis></para><para class="po-block e468 e468"><textual class="po-textual">
A </textual><emphasis class="po-inline e469 e469" role="ital"><textual class="po-textual">condition</textual></emphasis><textual class="po-textual"> (with k variables) is a Boolean Expression B(x</textual><subscript class="po-atom e470 e470"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,x</textual><subscript class="po-atom e471 e471"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,x</textual><subscript class="po-atom e472 e472"><textual class="po-textual">k</textual></subscript><textual class="po-textual">) built from comparisons of the form: </textual></para><para class="po-block e473 e473"><textual class="po-textual">
x</textual><subscript class="po-atom e474 e474"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> RelationalOperator c; where x</textual><subscript class="po-atom e475 e475"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> and a constant c are of the same data type that supports
linear order (such as real or integer) and three standard Boolean operators: and, or and not,
with the standard associativity and precedence rules, and brackets, and a RelationalOperator is one of: &gt;, &lt;, &lt;=, &gt;=, =, !=.
For example, the expression B(x,y): x&gt;"0" &amp;&amp; y&gt;"100" || x&gt;="4" &amp;&amp; !(x="99") is a condition. </textual></para><para class="po-block e476 e476"><textual class="po-textual">
For given conditions B</textual><subscript class="po-atom e477 e477"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,B</textual><subscript class="po-atom e478 e478"><textual class="po-textual">k</textual></subscript><textual class="po-textual"> with k variables x</textual><subscript class="po-atom e479 e479"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,x</textual><subscript class="po-atom e480 e480"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,x</textual><subscript class="po-atom e481 e481"><textual class="po-textual">k</textual></subscript><textual class="po-textual">, Algorithm 4.1 </textual><emphasis class="po-inline e482 e482" role="ital"><textual class="po-textual">tests</textual></emphasis><textual class="po-textual"> if for any subset
(i</textual><subscript class="po-atom e483 e483"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,...,i</textual><subscript class="po-atom e484 e484"><textual class="po-textual">m</textual></subscript><textual class="po-textual">) with 0&lt;=m&lt;=k of the set (1,...,n)
the expression of the form D(x</textual><subscript class="po-atom e485 e485"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,x</textual><subscript class="po-atom e486 e486"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,x</textual><subscript class="po-atom e487 e487"><textual class="po-textual">k</textual></subscript><textual class="po-textual">) =
B</textual><subscript class="po-atom e488 e488"><textual class="po-textual">i</textual><subscript class="po-atom e489 e489"><textual class="po-textual">1</textual></subscript></subscript><textual class="po-textual">&amp;&amp;B</textual><subscript class="po-atom e490 e490"><textual class="po-textual">i</textual><subscript class="po-atom e491 e491"><textual class="po-textual">2</textual></subscript></subscript><textual class="po-textual">&amp;&amp;...&amp;&amp;B</textual><subscript class="po-atom e492 e492"><textual class="po-textual">i</textual><subscript class="po-atom e493 e493"><textual class="po-textual">m</textual></subscript></subscript><textual class="po-textual">&amp;&amp;!B</textual><subscript class="po-atom e494 e494"><textual class="po-textual">j</textual><subscript class="po-atom e495 e495"><textual class="po-textual">1</textual></subscript></subscript><textual class="po-textual">&amp;&amp;!B</textual><subscript class="po-atom e496 e496"><textual class="po-textual">j</textual><subscript class="po-atom e497 e497"><textual class="po-textual">2</textual></subscript></subscript><textual class="po-textual">&amp;&amp;...&amp;&amp;!B</textual><subscript class="po-atom e498 e498"><textual class="po-textual">j</textual><subscript class="po-atom e499 e499"><textual class="po-textual">r</textual></subscript></subscript><textual class="po-textual"> where {j</textual><subscript class="po-atom e500 e500"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,j</textual><subscript class="po-atom e501 e501"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,j</textual><subscript class="po-atom e502 e502"><textual class="po-textual">r</textual></subscript><textual class="po-textual">} = {1,2,...,k} - {i</textual><subscript class="po-atom e503 e503"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,i</textual><subscript class="po-atom e504 e504"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,i</textual><subscript class="po-atom e505 e505"><textual class="po-textual">m</textual></subscript><textual class="po-textual">}, is a </textual><emphasis class="po-inline e506 e506" role="ital"><textual class="po-textual">falsehood</textual></emphasis><textual class="po-textual">; i.e. is false for all variables x</textual><subscript class="po-atom e507 e507"><textual class="po-textual">1</textual></subscript><textual class="po-textual">,x</textual><subscript class="po-atom e508 e508"><textual class="po-textual">2</textual></subscript><textual class="po-textual">,...,x</textual><subscript class="po-atom e509 e509"><textual class="po-textual">k</textual></subscript><textual class="po-textual">.
</textual></para></section><section class="po-hcontainer e510 e510"><title class="po-block e511 e511"><textual class="po-textual"> Finding abstract values</textual></title><para class="po-block e512 e512"><textual class="po-textual">
An </textual><emphasis class="po-inline e513 e513" role="ital"><textual class="po-textual">abstract value</textual></emphasis><textual class="po-textual"> of a grammar path G is defined to be a list consisting of the pairs (target, list of configuration ids). If this list contains all non-excluded configurations, then it is omitted. </textual></para><para class="po-block e514 e514"><textual class="po-textual">
</textual><emphasis class="po-inline e515 e515" role="bold"><textual class="po-textual">Algorithm 4.2. </textual></emphasis></para><para class="po-block e516 e516"><textual class="po-textual">
Input: A schema S, and an SRBAC policy π</textual><subscript class="po-atom e517 e517"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e518 e518"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, where Π</textual><subscript class="po-atom e519 e519"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> ={G </textual><subscript class="po-atom e520 e520"><textual class="po-textual">i</textual></subscript><textual class="po-textual">: i=1,2,...,n} is a set of grammar paths, and role R</textual><subscript class="po-atom e521 e521"><textual class="po-textual">i</textual></subscript><textual class="po-textual"> is associated with the path G</textual><subscript class="po-atom e522 e522"><textual class="po-textual">i</textual></subscript><textual class="po-textual">. </textual></para><para class="po-block e523 e523"><textual class="po-textual">
Output: A table called Results storing abstract values of symbolic grammar paths. </textual></para><para class="po-block e524 e524"><textual class="po-textual">
Outline of the algorithm. While here we say a "table", the actual implementation may use a different, more efficient data structure. However, in our explanation of the algorithm, we will assume that the table is used.
There are two steps of the algorithm: </textual></para><itemizedlist class="po-table e525 e525"><listitem class="po-container e526 e526"><para class="po-block e527 e527"><textual class="po-textual">Create a list E of all non-excluded conditions C that appear in grammar paths in the policy, using Algorithm 4.1 </textual></para></listitem><listitem class="po-container e528 e528"><para class="po-block e529 e529"><textual class="po-textual"> Compute abstract values of all grammar paths in the SRBAC. (In the description of an abstract value, we skip the list of configuration ids if this list contains every possible configuration.) Here, we compute symbolic products of pairs G</textual><subscript class="po-atom e530 e530"><textual class="po-textual">i</textual></subscript><textual class="po-textual">*G </textual><subscript class="po-atom e531 e531"><textual class="po-textual">j</textual></subscript><textual class="po-textual"> and sums G</textual><subscript class="po-atom e532 e532"><textual class="po-textual">i</textual></subscript><textual class="po-textual">+G </textual><subscript class="po-atom e533 e533"><textual class="po-textual">j</textual></subscript><textual class="po-textual">, products and sums of triples, and so on; finally values of symbolic grammar paths. In this process, maintain three tables storing respectively products, sums and resulting grammar paths.
</textual></para></listitem></itemizedlist><para class="po-block e534 e534"><textual class="po-textual">
In more details, the table Products[i] stores an abstract value of products G</textual><subscript class="po-atom e535 e535"><textual class="po-textual">i</textual><subscript class="po-atom e536 e536"><textual class="po-textual">1</textual></subscript></subscript><textual class="po-textual">*...*G</textual><subscript class="po-atom e537 e537"><textual class="po-textual">i</textual><subscript class="po-atom e538 e538"><textual class="po-textual">j</textual></subscript></subscript><textual class="po-textual"> where 1&lt;=i</textual><subscript class="po-atom e539 e539"><textual class="po-textual">1</textual></subscript><textual class="po-textual">&lt;=...&lt;=i</textual><subscript class="po-atom e540 e540"><textual class="po-textual">j</textual></subscript><textual class="po-textual">&lt;=n and 1&lt;=j&lt;=k.
Here, the index i is a decimal value of the binary word of size k in which bits at positions i</textual><subscript class="po-atom e541 e541"><textual class="po-textual">m</textual></subscript><textual class="po-textual"> are set to 1 and remaining bits are set to 0. For example, for k=4, Products[5] stores an abstract value represented by 0101, i.e. of the product G</textual><subscript class="po-atom e542 e542"><textual class="po-textual">2</textual></subscript><textual class="po-textual">*G</textual><subscript class="po-atom e543 e543"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> and Result[5] will store the value of G</textual><subscript class="po-atom e544 e544"><textual class="po-textual">2</textual></subscript><textual class="po-textual">*G</textual><subscript class="po-atom e545 e545"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> − (G</textual><subscript class="po-atom e546 e546"><textual class="po-textual">1</textual></subscript><textual class="po-textual">+G</textual><subscript class="po-atom e547 e547"><textual class="po-textual">3</textual></subscript><textual class="po-textual">). </textual></para><para class="po-block e548 e548"><textual class="po-textual">
Execution of step 2 involves: </textual></para><itemizedlist class="po-table e549 e549"><listitem class="po-container e550 e550"><para class="po-block e551 e551"><textual class="po-textual">compute (and store in arrays Products and Sums) abstract values of all G</textual><subscript class="po-atom e552 e552"><textual class="po-textual">i</textual></subscript><textual class="po-textual">, then products (and sums) of two G</textual><subscript class="po-atom e553 e553"><textual class="po-textual">i</textual></subscript><textual class="po-textual">. If any product is empty then store in Products the value 0 (Empty) for any i-tuple that uses this product. Also, store in Results 0 for symbolic grammar paths that use such products. For example, if G</textual><subscript class="po-atom e554 e554"><textual class="po-textual">2</textual></subscript><textual class="po-textual">*G</textual><subscript class="po-atom e555 e555"><textual class="po-textual">4</textual></subscript><textual class="po-textual"> is empty, store 0 in Products at positions 5, and 7 and in Results at the same positions. Note that before any products are computed, we check if the value 0 has already been stored for this product</textual></para></listitem><listitem class="po-container e556 e556"><para class="po-block e557 e557"><textual class="po-textual"> repeat the above step for triples, etc. In computing unions, use previously computed values; for example to compute G</textual><subscript class="po-atom e558 e558"><textual class="po-textual">1</textual></subscript><textual class="po-textual">+G</textual><subscript class="po-atom e559 e559"><textual class="po-textual">2</textual></subscript><textual class="po-textual">+G</textual><subscript class="po-atom e560 e560"><textual class="po-textual">4</textual></subscript><textual class="po-textual">, we use the value of G</textual><subscript class="po-atom e561 e561"><textual class="po-textual">1</textual></subscript><textual class="po-textual">+G</textual><subscript class="po-atom e562 e562"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> which has already been computed.
</textual></para></listitem></itemizedlist><para class="po-block e563 e563" xml:id="Ex4.2" xreflabel="Example 4.2"><textual class="po-textual">
</textual><emphasis class="po-inline e564 e564" role="bold"><textual class="po-textual">Example 4.2. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e565 e565"><textual class="po-textual">
In our running example, we have four conditions: </textual></para><para class="po-block e566 e566"><textual class="po-textual">
C1: (@Id&lt;"0"), C2: (@Id&gt;"100"), C3: (@perm="true") and C4: (@name="Smith") </textual></para><para class="po-block e567 e567"><textual class="po-textual">
and there are 16 configurations; starting with configuration 0, for which all conditions are false, and ending with configuration 15, for which all conditions are true. Now, consider configuration (1100) with the index value equal to 12. However, C1 and C2 cannot be true at the same time, and so any configuration of the form 11xx is excluded. Therefore, the list of non-excluded configurations consists of integers from 0 to 11, and an abstract value of the grammar path N is (Id, basic/text(), (9,10,11)). </textual></para><para class="po-block e568 e568"><textual class="po-textual">
Abstract values of all symbolic grammar paths are shown below (starting with abstract values of four paths), using the following abbreviations: </textual></para><itemizedlist class="po-table e569 e569"><listitem class="po-container e570 e570"><para class="po-block e571 e571"><textual class="po-textual"> I : {1,3,5,9,11}</textual></para></listitem><listitem class="po-container e572 e572"><para class="po-block e573 e573"><textual class="po-textual"> B : basic/text()</textual></para></listitem><listitem class="po-container e574 e574"><para class="po-block e575 e575"><textual class="po-textual"> C : confidential/text()</textual></para></listitem><listitem class="po-container e576 e576"><para class="po-block e577 e577"><textual class="po-textual"> V : veryConfidential/text()</textual></para></listitem></itemizedlist><programlisting class="po-block e578 e578" xml:space="preserve"><textual class="po-textual">
	{N} = &lt;Id, (B,8,9,10,11)&gt;
	{P} = &lt;name,Id,B,C,V&gt;
	{R} = &lt;Id, C, (V,6,7)&gt;
	{S} = &lt;(B,I), (V,I), (C,I), (Perm,I)&gt;

	Results[1] = S-(P+R+N) = (perm,I)
	Results[2] = R-(N+P+S) = 0
	Results[3] = R*S-(P+N) = 0
	Results[4] = P-(N+R+S) = &lt;name,(B,0,2,4,6),(V,0,2,4,8,10)&gt;
	Results[5] = P*S-(N+R) = &lt;(B,1,3,5,7),(V,I)&gt;
	Results[6] = P*R-(N+S) = &lt;(C,0,2,4,6,8,10),(V,6)&gt;
	Results[7] = P*R*S-N = &lt;(C,I), (V,7)&gt;
	Results[8] = N-(P+R+S) = 0
	Results[9] = N*S-(P+R) = 0
	Results[10] = N*R-(P+S) = 0
	Results[11] = N*P*R-S = 0
	Results[12] = N*P-(R+S) = &lt;B,8,10&gt;
	Results[13] = N*P*S-R = &lt;B,9,11&gt;
	Results[14] = N*P*R-S= &lt;Id&gt;
	Results[15] = N*P*R*S = 0
</textual></programlisting></section><section class="po-hcontainer e579 e579"><title class="po-block e580 e580"><textual class="po-textual"> Schema-based Keyrings and Role-accessible Keyrings </textual></title><para class="po-block e581 e581"><textual class="po-textual">
For a schema S and a schema-level access control policy π</textual><subscript class="po-atom e582 e582"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e583 e583"><textual class="po-textual">S</textual></subscript><textual class="po-textual">, we use Algorithm 4.1, and for each non-empty value from the table Results, we generate one key. The keyring K</textual><subscript class="po-atom e584 e584"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> consists of all keys generated this way. Note that in our running example, out of 16 symbolic grammar paths, only 8 are non-empty. Therefore, where a brute-force approach would generate 16 keys for four roles for our running example, our optimized algorithm will instead generate only 8 keys. Now, we show how for each role R∈Ψ the keyring K</textual><subscript class="po-atom e585 e585"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> defines the set K</textual><subscript class="po-atom e586 e586"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R) of R-accessible keys. A user in role R will be provided with the R-accessible keys so that for any document D valid for S, she can decrypt the view π</textual><subscript class="po-atom e587 e587"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(R), where π</textual><subscript class="po-atom e588 e588"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual"> is the schema-induced document policy. </textual></para><para class="po-block e589 e589"><textual class="po-textual">
</textual><emphasis class="po-inline e590 e590" role="bold"><textual class="po-textual">Algorithm 4.3. </textual></emphasis><textual class="po-textual"> </textual></para><para class="po-block e591 e591"><textual class="po-textual">
Input: A schema S, a schema-level access control policy π</textual><subscript class="po-atom e592 e592"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e593 e593"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> and a role R∈Ψ.
</textual></para><para class="po-block e594 e594"><textual class="po-textual">
Output: Role R-accessible keyring K</textual><subscript class="po-atom e595 e595"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R). </textual></para><para class="po-block e596 e596"><textual class="po-textual">
Method: K</textual><subscript class="po-atom e597 e597"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R) = {k∈K</textual><subscript class="po-atom e598 e598"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> for some symbolic grammar path G, the abstract value of {G} is a subset of the abstract value of the grammar path π</textual><subscript class="po-atom e599 e599"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R)} □ </textual></para><para class="po-block e600 e600" xml:id="Ex4.3" xreflabel="Example 4.3"><textual class="po-textual">
</textual><emphasis class="po-inline e601 e601" role="bold"><textual class="po-textual">Example 4.3. </textual></emphasis></para><para class="po-block e602 e602"><textual class="po-textual">
For our running example, let us denote by ri a key corresponding to the value of Results[i] which is not empty. Therefore, K</textual><subscript class="po-atom e603 e603"><textual class="po-textual">S</textual></subscript><textual class="po-textual">= {r1, r4, r5, r6, r7, r12, r13, r14}. Two examples of role-accessible keyrings are K</textual><subscript class="po-atom e604 e604"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(Nurse) ={r12, r13, r14}, and K</textual><subscript class="po-atom e605 e605"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(Physician) ={r4, r5, r6, r7, r12, r13, r14}.□ </textual></para><para class="po-block e606 e606"><textual class="po-textual">
One can show that given a schema-level access control policy π</textual><subscript class="po-atom e607 e607"><textual class="po-textual">S</textual></subscript><textual class="po-textual">:Ψ→Π</textual><subscript class="po-atom e608 e608"><textual class="po-textual">S</textual></subscript><textual class="po-textual"> and XML document D valid in S, if the user U in role R is provided only with R-accessible keys created by Algorithm 4.3 then the protection requirement is satisfied; in particular U can access precisely the view V = π</textual><subscript class="po-atom e609 e609"><textual class="po-textual">S,D</textual></subscript><textual class="po-textual">(R). □
</textual></para></section><section class="po-hcontainer e610 e610"><title class="po-block e611 e611"><textual class="po-textual"> Schema Graph Annotations </textual></title><para class="po-block e612 e612"><textual class="po-textual">
Based on the information stored in the table Results, we now annotate the syntax graph with a list of pairs
(key, list of integers representing configuration index values).
We use ♦ to denote a key for the default role; one of • or ♥.
If the list consists of </textual><emphasis class="po-inline e613 e613" role="ital"><textual class="po-textual">all</textual></emphasis><textual class="po-textual"> permissible index values, then it is omitted.
The annotated schema graph will be used to guide the process of multi-encrypting an XML document D during its
SAX-based parsing. To annotate the schema graph, we traverse the table Results, and collect information about
 all keys. Next, we traverse the schema graph again, and if the annotation is missing at any node we add the
 annotation of the form (♦). For nodes that have already been annotated, we check if these annotations
contain all permissible index values, if any such values are missing they are added with the default key ♦.
</textual></para><para class="po-block e614 e614" xml:id="Ex4.4" xreflabel="Example 4.4"><textual class="po-textual">
</textual><emphasis class="po-inline e615 e615" role="bold"><textual class="po-textual">Example 4.4. </textual></emphasis></para><para class="po-block e616 e616"><textual class="po-textual">
Consider our running example. To annotate the node "veryConfidential" in the schema graph, we look in Results[] for the value V, and so its annotation is &lt;(r4,0,2,4,8,10), (r5,I), (r6,6), (r7,7)&gt;.  For the complete annotated schema graph see </textual><xref class="po-milestone e617 e617" linkend="fig5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><figure class="po-container e618 e618" floatstyle="1" xml:id="fig5" xreflabel="Figure 8"><mediaobject class="po-container e619 e619"><imageobject class="po-container e620 e620"><imagedata class="po-meta e621 e621" fileref="../../../vol1/graphics/Muldner01/Muldner01-008.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e622 e622"><para class="po-block e623 e623"><textual class="po-textual"> Annotated syntax graph for schema S </textual></para></caption></mediaobject></figure></section><section class="po-hcontainer e624 e624"><title class="po-block e625 e625"><textual class="po-textual"> Multi-encryption of Documents </textual></title><para class="po-block e626 e626"><textual class="po-textual">
The encryption of the document D valid in the Schema S results in single well-defined XML m-document MD, which always has a root element &lt;encrypteddocument&gt;. Each part of the document D that is encrypted with a key "k" will be represented as a child of the &lt;encrypteddocument&gt; node using this format: &lt;edata key = "k"&gt; </textual><emphasis class="po-inline e627 e627" role="ital"><textual class="po-textual">encrypted_data</textual></emphasis><textual class="po-textual"> &lt;/edata&gt;. Note that the structure of the document D is hidden inside of the </textual><emphasis class="po-inline e628 e628" role="ital"><textual class="po-textual">encrypted_data</textual></emphasis><textual class="po-textual"> part and is therefore not visible to users who are not authorized to decrypt the document (the &lt;edata&gt; tags are not nested inside of other &lt;edata&gt; tags). The encryption is performed by efficient, single-pass SAX parsing of D (performed in parallel with the traversal of the previously annotated schema graph GS). For each node d of D, the corresponding node s in GS is located, and its annotation is examined to determine which key should be used to encrypt this node (note that at that time we can determine values of all conditions and so we know which configuration should be used; unless nested conditions are used, which require additional treatment). Recall that the same key always encrypts the attribute and its value. </textual></para><para class="po-block e629 e629" xml:id="Ex4.5" xreflabel="Example 4.5"><textual class="po-textual">
</textual><emphasis class="po-inline e630 e630" role="bold"><textual class="po-textual">Example 4.5. </textual></emphasis></para><para class="po-block e631 e631"><textual class="po-textual">
Consider the document D from [</textual><xref class="po-milestone e632 e632" linkend="Ex3.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], (see </textual><xref class="po-milestone e633 e633" linkend="fig6"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">), in which dotted boxes attached to elements and attributes show the key that is used to encrypt this element. To explain the choice of keys, note that there are three patients; when the attributes of the first patient are processed, we know that that the name is not "Smith", Id is negative, and perm is true, and so the configuration 10 is used. Similarly, configuration 9 is used for the second patient, and configuration 6 for the third one. This information is used to retrieve the key to be used for encryption from the annotated schema graph. </textual></para><figure class="po-container e634 e634" floatstyle="1" xml:id="fig6" xreflabel="Figure 9"><mediaobject class="po-container e635 e635"><imageobject class="po-container e636 e636"><imagedata class="po-meta e637 e637" fileref="../../../vol1/graphics/Muldner01/Muldner01-009.png" format="png" width="100%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject><caption class="po-container e638 e638"><para class="po-block e639 e639"><textual class="po-textual"> Document D and keys used to encrypt this document.</textual></para></caption></mediaobject></figure><para class="po-block e640 e640"><textual class="po-textual">
The m-document M</textual><subscript class="po-atom e641 e641"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> looks like this (assuming that by default ♦ indicates that the node is not available to any user, so the corresponding &lt;edata&gt; nodes are omitted; below, we show details of the leftmost "patient" subtree and leave out other subtrees; encrypted data are also omitted): </textual></para><programlisting class="po-block e642 e642" xml:space="preserve"><textual class="po-textual">
&lt;encrypteddocument&gt;
	&lt;edata key="r4"&gt;...&lt;/edata&gt;
	&lt;edata key="r14"&gt;...&lt;/edata&gt;
	&lt;edata key="r6"&gt;...&lt;/edata&gt;
	&lt;edata key="r2"&gt;...&lt;/edata&gt;
	&lt;edata key="r4"&gt;...&lt;/edata&gt;
&lt;/encrypteddocument&gt;
</textual></programlisting></section><section class="po-hcontainer e643 e643"><title class="po-block e644 e644"><textual class="po-textual"> Decryption of Multi-Encrypted Documents </textual></title><para class="po-block e645 e645"><textual class="po-textual">
When the user U can prove that is entitled to play role R, she will first obtain the R-accessible keyring K</textual><subscript class="po-atom e646 e646"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R) via a secure channel, and then proceed to decrypt an m-document M</textual><subscript class="po-atom e647 e647"><textual class="po-textual">D</textual></subscript><textual class="po-textual">, to produce a document M</textual><subscript class="po-atom e648 e648"><textual class="po-textual">D,R</textual></subscript><textual class="po-textual">. The software system available for U will first identify a sub-keyring K1 of K</textual><subscript class="po-atom e649 e649"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R) consisting of keys needed to decrypt M, and then apply keys available in K1 to perform decryption. The output from the decryption is a single XML document. Given this document, U may use the system to create a sanitized schema (showing only accessible parts of schemas), which would allow them to efficiently apply XML tools, such as XQuery for XML databases. One can show that given a schema-level access control policy and XML document D valid in S, if the user U in role R is provided only with R-accessible keys K</textual><subscript class="po-atom e650 e650"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(R), then the protection requirement is satisfied. □
</textual></para><para class="po-block e651 e651" xml:id="Ex4.6" xreflabel="Example 4.6"><textual class="po-textual">
</textual><emphasis class="po-inline e652 e652" role="bold"><textual class="po-textual">Example 4.6. </textual></emphasis></para><para class="po-block e653 e653"><textual class="po-textual">
 Consider the m-document from [</textual><xref class="po-milestone e654 e654" linkend="Ex4.5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], using the schema-based ACP policy from [</textual><xref class="po-milestone e655 e655" linkend="Ex3.8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].
Recall from [</textual><xref class="po-milestone e656 e656" linkend="Ex4.3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] that K</textual><subscript class="po-atom e657 e657"><textual class="po-textual">S</textual></subscript><textual class="po-textual">(Physician) ={r4, r5, r6, r7, r12, r13, r14}.
Assuming that the user plays the role Physician, the decrypted file will look as follows (note that in this example, tags are encrypted and so their respective values have been concatenated): </textual></para><programlisting class="po-block e658 e658" xml:space="preserve"><textual class="po-textual">
	&lt;encryptedtag name="Kay" Id="-1"&gt;B1C1V1&lt;/encryptedtag&gt;
</textual></programlisting><para class="po-block e659 e659"><textual class="po-textual">□</textual></para></section><section class="po-hcontainer e660 e660"><title class="po-block e661 e661"><textual class="po-textual"> Implementation </textual></title><para class="po-block e662 e662"><textual class="po-textual">
Our implementation uses the C++ language, with external libraries to support XML usage and cryptographic functions; specifically the Xerces-C++ XML toolkit from Apache [</textual><xref class="po-milestone e663 e663" linkend="mul115"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and Crypto++ [</textual><xref class="po-milestone e664 e664" linkend="mul116"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. First, the schema file is parsed and loaded into memory represented as a tree like structure (a schema graph). Once the tree is constructed, the access control policy file will be parsed and can be validated for semantic correctness against the schema in memory (although this is not currently completed). Lastly, all of the information that the encryption process requires will be saved into a file that can be loaded at a later point in time. Currently, this file is a simple xml file that contains the generated keys, schema graph and annotations, as well as the set of conditions specific in the access control policy. </textual></para><para class="po-block e665 e665"><textual class="po-textual">
The encryption process works by firstly re-loading (if necessary) the data saved to the xml file back into memory, and next the document to be encrypted is parsed with a SAX parser. Each node in the document will be encrypted in the order they appear in the document, with nodes being queued if there is not enough information available to encrypt them at the time they are first encountered (this can happen when the access control policy specified a condition for this node which cannot be calculated until a node later in the document is parsed). The encryption process is implemented in such a way that the algorithm used to perform the encryption can be changed very easily, so either a symmetric or asymmetric algorithm can be used based on user preference. It is also possible to extend the implementation to provide a run time facility for selecting an encryption algorithm.
</textual></para><para class="po-block e666 e666"><textual class="po-textual">
Nested paths to arbitrary nodes in conditions are supported through a combination of data caching and a queue. During encryption, each node to be encrypted is added to the end of the </textual><emphasis class="po-inline e667 e667" role="ital"><textual class="po-textual">encryption queue</textual></emphasis><textual class="po-textual">. Additionally, if the node is an attribute or text node that is referenced by conditions, the value of this node is cached in the </textual><emphasis class="po-inline e668 e668" role="ital"><textual class="po-textual">global value table</textual></emphasis><textual class="po-textual">. The encryption queue is then flushed, by trying to encrypt as many nodes from the front of the queue as possible. A node can only be encrypted and removed from the queue if all of its dependencies are met. A node with no condition has no dependencies, and can be always encrypted. A node with a condition has dependencies, and the global value table is searched to ensure that all dependent attribute and text nodes have values within this table. If any dependent node is missing a value, this node cannot be encrypted, and no further nodes flushed from the queue. Otherwise, the condition can be evaluated (determining the key to use for encryption) and then the node is encrypted.
</textual></para></section></section><section class="po-hcontainer e669 e669"><title class="po-block e670 e670"><textual class="po-textual"> Results of Testing </textual></title><para class="po-block e671 e671"><textual class="po-textual">
We performed testing of our implementation, comparing the time required to multi-encrypt (and decrypt) against the time spent when super-encryption was used. The detailed description of steps performed in testing is provided below: </textual></para><itemizedlist class="po-table e672 e672"><listitem class="po-container e673 e673"><para class="po-block e674 e674"><textual class="po-textual"> For the schema S from [</textual><xref class="po-milestone e675 e675" linkend="Ex3.4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], we considered the SRBAC policy S from [</textual><xref class="po-milestone e676 e676" linkend="Ex3.8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]
, and determined the number of keys generated by our implementation.</textual></para></listitem><listitem class="po-container e677 e677"><para class="po-block e678 e678"><textual class="po-textual"> For the same schema S, we considered two documents valid in this schema; document D from [</textual><xref class="po-milestone e679 e679" linkend="Ex3.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and document D2, which is similar to D (except it had much longer text values and different values of attributes). For both of these document, we also considred the induced DRBAC policies for these documents.
.</textual></para></listitem><listitem class="po-container e680 e680"><para class="po-block e681 e681"><textual class="po-textual"> For each of the two documents D and D2, we multi-encrypted them four times using our approach, measured the time needed to encrypt, and recorded the average multi-encryption time</textual></para></listitem><listitem class="po-container e682 e682"><para class="po-block e683 e683"><textual class="po-textual"> For each of the two multi-encrypted documents M</textual><subscript class="po-atom e684 e684"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> and M</textual><subscript class="po-atom e685 e685"><textual class="po-textual">D2</textual></subscript><textual class="po-textual">, we decrypted themfour times for all four roles, measured the time needed to decrypt, and recorded the average decryption time</textual></para></listitem><listitem class="po-container e686 e686"><para class="po-block e687 e687"><textual class="po-textual"> For each of the two documents, we generated keys and super-encrypted these documents by performing the SAX traversal of the document, using the following approach: </textual></para><para class="po-block e688 e688"><textual class="po-textual">
a) for every node x in the intersection of document paths there is a keyring consisting of m keys (one for each path); and the node x is super-encrypted with all these keys. The user in any role R associated with the path P from the intersection will receive the entire keyring. </textual></para><para class="po-block e689 e689"><textual class="po-textual">
b) to satisfy the protection requirement, keys are reused based on the following principle. Suppose that in performing the SAX traversal of a document, we have encountered the node x as described above (and generated multiple keys), and then we have encountered the node y in the intersection of the same document paths. Then, the same keyring is used (i.e. no new keys are generated), and the node y is super-encrypted with keys from this keyring. </textual></para></listitem><listitem class="po-container e690 e690"><para class="po-block e691 e691"><textual class="po-textual"> For each of the two documents D1 and D2, we super-encrypted them using the approach described above, and measured the time needed to encrypt </textual></para></listitem><listitem class="po-container e692 e692"><para class="po-block e693 e693"><textual class="po-textual"> For each of the two super-encrypted documents M</textual><subscript class="po-atom e694 e694"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> and M</textual><subscript class="po-atom e695 e695"><textual class="po-textual">D2</textual></subscript><textual class="po-textual">, we decrypted them four times for all four roles, measured the time needed to decrypt, and recorded the average decryption time </textual></para></listitem></itemizedlist><para class="po-block e696 e696"><textual class="po-textual">
</textual><emphasis class="po-inline e697 e697" role="bold"><textual class="po-textual">Results. </textual></emphasis></para><para class="po-block e698 e698"><textual class="po-textual">
The total number of keys generated at the schema level was 8, while the number of keys generated at the document level (for super-encryption) was 17 for both documents. The time needed to generate keys at the schema level was 0.0279024. The average time needed respectively for multi-encryption and super-encryption of the document D was 0.0007776830 and 0.0019404000. For the document D2, the average time was 0.0022022350 and 0.0042952375.  The average time needed respectively for decryption for the role Physician for the multi-encrypted and super-encrypted document M</textual><subscript class="po-atom e699 e699"><textual class="po-textual">D</textual></subscript><textual class="po-textual"> was 0.00125512 and 0.00368630. For the document M</textual><subscript class="po-atom e700 e700"><textual class="po-textual">D2</textual></subscript><textual class="po-textual">, the average time was respectively 0.00633886 and 0.00972875.</textual></para><para class="po-block e701 e701"><textual class="po-textual">
</textual><emphasis class="po-inline e702 e702" role="bold"><textual class="po-textual">Conclusions. </textual></emphasis><textual class="po-textual"> Our testing proved the expected superiority of multi-encryption over super-encryption. Approximately half the keys were generated (although at the schema levels we generate keys for all valid documents). While multi-encryption incurs the initial cost of time spending on key generation, our tests show that on average for multi-encryption, the encryption time and the decryption times were between 30 and 50 percent shorter.
 </textual></para></section><section class="po-hcontainer e703 e703"><title class="po-block e704 e704"><textual class="po-textual"> Conclusions and Future Work </textual></title><para class="po-block e705 e705"><textual class="po-textual">
In this paper, we provided a description of role-based ACPs for defining permissions for fragments of XML documents, both at the document and the schema level. Using our approach, keys can be generated at the schema level and then only required keys may be assigned to specific documents valid for the schema. A complete system was designed and implemented. </textual></para><para class="po-block e706 e706"><textual class="po-textual">
Our future work includes full optimization of the algorithm which generates keys at the schema level, removing some restrictions on XML documents, such as IDREF attributes, and designing and implementing re-usability of keyrings when a document or ACP is modified. Also, we will start using our approach to develop secure publishing solutions in areas such as social networks. </textual></para></section><section class="po-hcontainer e707 e707"><title class="po-block e708 e708"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e709 e709"><textual class="po-textual"> The algorithm to find excluded configurations was suggested by Raimond Seidel,
Saarbruecken University. Greg Leighton, a PhD student from the University of Alberta provided many useful comments. Finally, the first author would like to acknowledge help of Tommie Usdin in resolving various issues when converting the document in thw Word format to XML.
</textual></para></section><bibliography class="po-hcontainer e710 e710"><title class="po-block e711 e711"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e712 e712" xml:id="mul93" xreflabel="Baldano2002"><textual class="po-textual">Baldonado, M., Bertino, E. and Ferrari, E. Secure and Selective Dissemination of XML Documents. ACM Transactions on Information and System Security (TISSEC), 5(3):290–331, (2002). doi:</textual><biblioid class="po-atom e713 doi e713"><textual class="po-textual">10.1145/545186.545190</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e714 e714" xml:id="mul94" xreflabel="Bertino2004"><textual class="po-textual">Bertino, E., Carminati, B., Ferrari, E., Thuraisingham B. and A. Gupta. Selective and Authentic Third-Party Distribution of XML Documents. IEEE Transactions on Knowledge and Data Engineering (TKDE), 16(10), 2004, pp. 1263–1278. doi:</textual><biblioid class="po-atom e715 doi e715"><textual class="po-textual">10.1109/TKDE.2004.63</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e716 e716" xml:id="mul95" xreflabel="Bertino2001"><textual class="po-textual">Bertino, E., Carminati, B. and Ferrari, E. A temporal key management scheme for secure broadcasting of XML documents. Conference on Computer and Comm. Security. Proc. of the 9th ACM conference on Computer and communications security (2002): 31–40. doi:</textual><biblioid class="po-atom e717 doi e717"><textual class="po-textual">10.1145/586110.586116</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e718 e718" xml:id="mul96" xreflabel="Bertino2002"><textual class="po-textual">Bertino, E., Carminati, B. and Ferrari, E. Securing XML Documents with Author-X. IEEE Internet Computing Volume 5, Issue 3 (2001): 21 – 31. doi:</textual><biblioid class="po-atom e719 doi e719"><textual class="po-textual">10.1109/4236.935172</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e720 e720" xml:id="mul97" xreflabel="Cramption2004"><textual class="po-textual">Crampton, J. Applying hierarchical and role-based access control to XML documents. Proc. of the 2004 workshop on Secure web service (2004): 37 – 46. doi:</textual><biblioid class="po-atom e721 doi e721"><textual class="po-textual">10.1145/1111348.1111353</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e722 e722" xml:id="mul98" xreflabel="Damiani2005"><textual class="po-textual">Damiani, E. De Capitani di Vimercati, S.D.C. and Samarati, P. New paradigms for access control in open environments. Signal Processing and Information Technology, Proc. of the Fifth IEEE International Symposium (2005): 540–545. doi:</textual><biblioid class="po-atom e723 doi e723"><textual class="po-textual">10.1109/ISSPIT.2005.1577155</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e724 e724" xml:id="mul99" xreflabel="Damiani2002"><textual class="po-textual">Damiani, E., De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  A Fine-grained Access Control System for XML Documents.  ACM Transactions on Information and System Security,5(2): 169–202,(2002). doi:</textual><biblioid class="po-atom e725 doi e725"><textual class="po-textual">10.1145/505586.505590</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e726 e726" xml:id="mul100" xreflabel="De Capitani2003"><textual class="po-textual">De Capitani di Vimercati, S., Paraboschi, S. and Samarati, P.  Access control: principles and solutions. Software Practice and Experience, Vol, 33, Issue 5 (April 2003): 397–421. John Wiley and Sons, Inc. doi:</textual><biblioid class="po-atom e727 doi e727"><textual class="po-textual">10.1002/spe.513</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e728 e728" xml:id="mul101" xreflabel="Devanbu2001"><textual class="po-textual">Devanbu, P., Gertz, M., Kwong, A., Martel, C., Nuckolls, G. and S.G. Stubblebine. Flexible Authentication of XML documents. In Proc. of the 8th ACM Conference on Computer and Communications Security, ACM Press, (2001). doi:</textual><biblioid class="po-atom e729 doi e729"><textual class="po-textual">10.1145/501983.502003</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e730 e730" xml:id="mul102" xreflabel="Ferraiolo2001"><textual class="po-textual">Ferraiolo, D.F., Sandhu, R., Gavrila, S., Kuhn, D.S. and Chandramouli, R. Proposed NIST Standard for Role-Based Access Control. ACM Trans. on Information and System Security, 4 (3), (2001), 224–274. doi:</textual><biblioid class="po-atom e731 doi e731"><textual class="po-textual">10.1145/501978.501980</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e732 e732" xml:id="mul103" xreflabel="Fundulaki2004"><textual class="po-textual">Fundulaki, I. and Marx, M. Specifying access control policies for XML documents. Proceedings of the ninth ACM symposium on Access control models and technologies (2004) 61 – 69. doi:</textual><biblioid class="po-atom e733 doi e733"><textual class="po-textual">10.1145/990036.990046</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e734 e734" xml:id="mul104" xreflabel="Goel2003"><textual class="po-textual">Goel, S K., Clinton, C. and Rosenthal, A. Derived access control specification for XML. Proc. of the 2003 ACM workshop on XML security (2003): 1 – 14. doi:</textual><biblioid class="po-atom e735 doi e735"><textual class="po-textual">10.1145/968559.968561</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e736 e736" xml:id="mul105" xreflabel="Kudo2000"><textual class="po-textual">Kudo, M. and Hada S. XML document security based on provisional authorization. Proc. of the 7th ACM conference on Computer and communications security (2000): 87 –96. doi:</textual><biblioid class="po-atom e737 doi e737"><textual class="po-textual">10.1145/352600.352613</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e738 e738" xml:id="mul106" xreflabel="Kuper2005"><textual class="po-textual">Kuper, G., Massaci, F. and Rassadko, N. Generalized XML security views. Proc. of the tenth ACM symposium on Access control models and technologies. (2005):77–84. doi:</textual><biblioid class="po-atom e739 doi e739"><textual class="po-textual">10.1145/1063979.1063994</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e740 e740" xml:id="mul107" xreflabel="Miklau2003"><textual class="po-textual">Miklau, G. and Suciu, D. Controlling Access to Published Data Using Cryptography, In Proc. of the 29th VLDB Conference, Berlin, Germany, (2003).</textual></bibliomixed><bibliomixed class="po-block e741 e741" xml:id="mul108" xreflabel="Müldner2006"><textual class="po-textual"> Müldner, T., Leighton, G. and Miziolek, J.K. Using Multi-Encryption to Provide Secure and Controlled Access to XML Documents. Extreme Markup Languages 2006, (2006), Montreal, Canada.</textual></bibliomixed><bibliomixed class="po-block e742 e742" xml:id="mul109" xreflabel="Müldner2008"><textual class="po-textual"> Müldner, T., Leighton, G. and Miziolek, J.K. Succinct Access Control Policies for Published XML Datasets. 10th International Conference on Enterprise Information Systems. 12 –16, June 2008, Barcelona, Spain.</textual></bibliomixed><bibliomixed class="po-block e743 e743" xml:id="mul110" xreflabel="Ramaswamy2003"><textual class="po-textual">Ramaswamy C. A Policy Validation Framework for Enterprise Authorization Specification. 19th Annual Computer Security Applications Conference ACSAC, (2003): 319–329. doi:</textual><biblioid class="po-atom e744 doi e744"><textual class="po-textual">10.1109/CSAC.2003.1254336</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e745 e745" xml:id="mul111" xreflabel="XML2008"><textual class="po-textual">Extensible Markup Language (XML) 1.0 (Fourth Edition) </textual><link class="po-inline e746 e746" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/REC-xml/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e747 e747" xml:id="mul112" xreflabel="XPath2008"><textual class="po-textual">XML Path Language. </textual><link class="po-inline e748 e748" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e749 e749" xml:id="mul113" xreflabel="XML-Schema2008"><textual class="po-textual">XML Schema </textual><link class="po-inline e750 e750" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-0/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e751 e751" xml:id="mul114" xreflabel="Zhang2003"><textual class="po-textual">Zhang, X., Park, J. and Sandhu, R. Schema based XML Security: RBAC Approach, 17th IFIP 11.3. Working Conference on Data and Application Security, 2003. doi:</textual><biblioid class="po-atom e752 doi e752"><textual class="po-textual">10.1007/1-4020-8070-0_24</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e753 e753" xml:id="mul115" xreflabel="Xerces2008"><link class="po-inline e754 e754" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xerces.apache.org/xerces-c/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e755 e755" xml:id="mul116" xreflabel="Crypto++2008"><link class="po-inline e756 e756" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.cryptopp.com/</textual></link><textual class="po-textual">.</textual></bibliomixed></bibliography></article></classedDocument>