<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">Optimized Cartesian product: A hybrid approach to derivation-chain checking in XSD 1.1</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2008</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 12 - 15, 2008</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">As XPath predicates are involved, XSD 1.1 conditional declarations make difficult the problem of statically verifying whether a type is a legal restriction of its base. The XSD 1.1 current draft adopts a full dynamic approach to the problem. In this paper we propose a hybrid solution (neither completely static, nor completely dynamic) to the same problem.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Maurizio</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Casimirri</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Maurizio Casimirri is a graduate student in Computer Science, at the University of Bologna.</textual></para></personblurb><email class="po-field e14 e14"><textual class="po-textual">mcasimir@cs.unibo.it</textual></email><affiliation class="po-record e15 e15"><jobtitle class="po-field e16 e16"><textual class="po-textual">Graduate student</textual></jobtitle><orgname class="po-block e17 e17"><textual class="po-textual">Department of Computer Science, University of Bologna</textual></orgname></affiliation></author><author class="po-record e18 e18"><personname class="po-record e19 e19"><firstname class="po-field e20 e20"><textual class="po-textual">Paolo</textual></firstname><surname class="po-field e21 e21"><textual class="po-textual">Marinelli</textual></surname></personname><personblurb class="po-container e22 e22"><para class="po-block e23 e23"><textual class="po-textual">Paolo Marinelli holds a Master Degree in Computer Science from the University of Bologna. He is a temporary research associate at the Department of Computer Science of the University of Bologna.</textual></para></personblurb><affiliation class="po-record e24 e24"><jobtitle class="po-field e25 e25"><textual class="po-textual">Temporary research associate</textual></jobtitle><orgname class="po-block e26 e26"><textual class="po-textual">Department of Computer Science, University of Bologna</textual></orgname></affiliation><email class="po-field e27 e27"><textual class="po-textual">pmarinel@cs.unibo.it</textual></email></author><author class="po-record e28 e28"><personname class="po-record e29 e29"><firstname class="po-field e30 e30"><textual class="po-textual">Fabio</textual></firstname><surname class="po-field e31 e31"><textual class="po-textual">Vitali</textual></surname></personname><personblurb class="po-container e32 e32"><para class="po-block e33 e33"><textual class="po-textual">Fabio Vitali is an associate professor at the Department of Computer Science at the University of Bologna. He holds a Laurea degree in Mathematics and a Ph.D. in Computer and Law, both from the University of Bologna. His research interests include markup languages; distributed, coordinated systems; and the World Wide Web. He is the author of several papers on hypertext functionalities, the World Wide Web, and XML.</textual></para></personblurb><affiliation class="po-record e34 e34"><jobtitle class="po-field e35 e35"><textual class="po-textual">Associate professor</textual></jobtitle><orgname class="po-block e36 e36"><textual class="po-textual">Department of Computer Science, University of Bologna</textual></orgname></affiliation><email class="po-field e37 e37"><textual class="po-textual">fabio@cs.unibo.it</textual></email></author><legalnotice class="po-container e38 e38"><para class="po-block e39 e39"><textual class="po-textual">Copyright Â© 2008 by the authors. Reproduced with permission.</textual></para></legalnotice></info><section class="po-hcontainer e40 e40" xml:id="sectIntroduction" xreflabel="Introduction"><title class="po-block e41 e41"><textual class="po-textual">Introduction</textual></title><para class="po-block e42 e42"><textual class="po-textual">In this paper we propose an </textual><emphasis class="po-inline e43 e43"><textual class="po-textual">hybrid</textual></emphasis><textual class="po-textual"> solution to the problem of verifying whether a type is a legal restriction of its base in XSD 1.1.</textual></para><para class="po-block e44 e44"><textual class="po-textual">Version 1.1 of XML Schema (XSD) in now in Working Draft [</textual><xref class="po-milestone e45 e45" linkend="entryXSD1.1-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e46 e46" linkend="entryXSD1.1-datatypes"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. One of the most important features introduced by XSD 1.1 is Conditional Type Assignment, i.e., the possibility for element declarations to assign a type based on XPath predicates. CTA is meant to address one of the most evident limitations of XSD 1.0: the </textual><emphasis class="po-inline e47 e47"><textual class="po-textual">co-constraint</textual></emphasis><textual class="po-textual"> definition support.</textual></para><para class="po-block e48 e48"><textual class="po-textual">The CTA introduction in XSD arises an issue concerning the derivation by restriction between types containing conditional declarations. Indeed, the type actually assigned by a conditional declaration can be known at run-time only and it may vary from element to element. Thus the problem of </textual><emphasis class="po-inline e49 e49"><textual class="po-textual">statically</textual></emphasis><textual class="po-textual"> verifying whether a type is a legal restriction of its base when conditional declarations are involved is difficult. It is possible to identify three alternative approaches to the problem:</textual></para><orderedlist class="po-table e50 e50"><listitem class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">Limiting the CTA usage in type restrictions.</textual></para></listitem><listitem class="po-container e53 e53"><para class="po-block e54 e54"><textual class="po-textual">Dynamic verification: at schema compile time no check is performed, but if at run-time we have a document proving that a type is not a legal restriction of its base, an error is thrown.</textual></para></listitem><listitem class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">Hybrid approach: similar to the previous approach, with the exception that at schema compile time some analysis is performed providing the dynamic phase information that might decrease the operations to be performed.</textual></para></listitem></orderedlist><para class="po-block e57 e57"><emphasis class="po-inline e58 e58"><textual class="po-textual">Co-occurrence constraints</textual></emphasis><textual class="po-textual"> (also known as </textual><emphasis class="po-inline e59 e59"><textual class="po-textual">co-constraints</textual></emphasis><textual class="po-textual"> ) are rules relating the presence and values of elements and attributes that may occur in distinct fragments of an XML document. E.g., we have a co-constraint when an attribute value governs the content of an element, or when two attributes are in some logic/arithmetic relation, and so on. Co-constraints are present in several XML-based languages, among which also languages recommended by W3C.</textual></para><para class="po-block e60 e60"><textual class="po-textual">One of the widely recognized limitations of XSD 1.0 [</textual><xref class="po-milestone e61 e61" linkend="entryXSD1.0-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e62 e62" linkend="entryXSD1.0-datatypes"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] is the inability to define co-constraints. This is a serious shortcoming for a schema language, and especially for XSD, given its widespread use. Indeed, when a schema is not able to capture every validity constraints of a class of XML documents, in order to reach a complete validation process specific modules are required to verify those constraints not covered by the schema. In such cases, not only the validation process becomes more complex, but also the interoperability between applications decreases.</textual></para><para class="po-block e63 e63"><textual class="po-textual">Version 1.1 of XSD introduces two mechanisms for the co-constraint definition: </textual><emphasis class="po-inline e64 e64"><textual class="po-textual">assertions</textual></emphasis><textual class="po-textual"> and  </textual><emphasis class="po-inline e65 e65"><textual class="po-textual">Conditional Type Assignment</textual></emphasis><textual class="po-textual"> (CTA). The former is inspired by Schematron [</textual><xref class="po-milestone e66 e66" linkend="entrySchematronISOspecification"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. It permits to augment type definitions with XPath predicates (called assertions), each specifying a further validity condition besides those enforced by the content model. Assertions are particularly useful to require some elements and attributes to be in logic or arithmetic relations.</textual></para><para class="po-block e67 e67"><textual class="po-textual">CTA, inspired by SchemaPath [</textual><xref class="po-milestone e68 e68" linkend="entrySchemaPathWWW"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], allows an element declaration to conditionally assign a type based on XPath predicates. Here we refer to declaration of such a typology as </textual><emphasis class="po-inline e69 e69"><textual class="po-textual">conditional declarations</textual></emphasis><textual class="po-textual">. CTA is particularly suitable for those situations where an attribute value governs the content of an element. For instance, in order to subject the content of a </textual><code class="po-atom e70 e70"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> element (representing a bibliographic entry) to the value of the </textual><code class="po-atom e71 e71"><textual class="po-textual">kind</textual></code><textual class="po-textual"> attribute, the following conditional declaration might be used</textual></para><programlisting class="po-block e72 e72" xml:space="preserve"><textual class="po-textual">
&lt;xs:element name="entry" type="Entry"&gt;
	&lt;xs:alternative test="@kind = 'proceedings'" type="ProceedingsEntry" /&gt;
	&lt;xs:alternative test="@kind = 'journal'"     type="JournalEntry" /&gt;
	&lt;xs:alternative test="@kind = 'book'"        type="BookEntry" /&gt;
&lt;/xs:element&gt;
</textual></programlisting><para class="po-block e73 e73"><textual class="po-textual">The above declaration reads as "if </textual><code class="po-atom e74 e74"><textual class="po-textual">@kind</textual></code><textual class="po-textual"> is </textual><code class="po-atom e75 e75"><textual class="po-textual">proceedings</textual></code><textual class="po-textual"> then </textual><code class="po-atom e76 e76"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> is of type </textual><emphasis class="po-inline e77 e77"><textual class="po-textual">ProceedingsEntry</textual></emphasis><textual class="po-textual">, otherwise if </textual><code class="po-atom e78 e78"><textual class="po-textual">@kind</textual></code><textual class="po-textual"> is </textual><code class="po-atom e79 e79"><textual class="po-textual">journal</textual></code><textual class="po-textual"> then </textual><code class="po-atom e80 e80"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> is of type </textual><emphasis class="po-inline e81 e81"><textual class="po-textual">JournalEntry</textual></emphasis><textual class="po-textual">, otherwise if </textual><code class="po-atom e82 e82"><textual class="po-textual">@kind</textual></code><textual class="po-textual"> is </textual><code class="po-atom e83 e83"><textual class="po-textual">book</textual></code><textual class="po-textual"> then </textual><code class="po-atom e84 e84"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> is of type </textual><emphasis class="po-inline e85 e85"><textual class="po-textual">BookEntry</textual></emphasis><textual class="po-textual">, otherwise (none of the above conditions hold) </textual><code class="po-atom e86 e86"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> is of type </textual><emphasis class="po-inline e87 e87"><textual class="po-textual">Entry</textual></emphasis><textual class="po-textual"> (which is a type for generic bibliographic entries). Each </textual><code class="po-atom e88 e88"><textual class="po-textual">&lt;xs:alternative&gt;</textual></code><textual class="po-textual"> element is named </textual><emphasis class="po-inline e89 e89"><textual class="po-textual">type alternative</textual></emphasis><textual class="po-textual"> in XSD 1.1.</textual></para><para class="po-block e90 e90"><textual class="po-textual">Conditional declarations arise an issue in the derivation by restriction. XSD (both 1.0 and 1.1) allows to define new types deriving existing ones. A derivation method is by restriction. The general principle behind the derivation by restriction is that the derived type accepts a subset of what the base type accepts. Thus, given an element </textual><emphasis class="po-inline e91 e91"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, it is required that the type assigned to </textual><emphasis class="po-inline e92 e92"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of the derived type, be a restriction of the type assigned to </textual><emphasis class="po-inline e93 e93"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of the base type. The presence of conditional declarations heavily complicates the static verification of such principle, as it require to analyze logic relations among XPath predicates. However, there are at least three alternative approaches to the problem of verifying whether a type is a legal restriction of its base:</textual></para><variablelist class="po-table e94 e94"><varlistentry class="po-record e95 e95"><term class="po-block e96 e96"><textual class="po-textual">CTA limitation</textual></term><listitem class="po-container e97 e97"><para class="po-block e98 e98"><textual class="po-textual">Ad hoc limitations are imposed on the CTA usage to ensure a simple static verification of the restriction. For instance, a radical limitation is that when a type contains a conditional declaration it is implicitly final w.r.t. the derivation by restriction.</textual></para></listitem></varlistentry><varlistentry class="po-record e99 e99"><term class="po-block e100 e100"><textual class="po-textual">Full dynamic approach</textual></term><listitem class="po-container e101 e101"><para class="po-block e102 e102"><textual class="po-textual">At schema compile type, it is never checked whether a type is a legal restriction of its base. However, at validation time, it is checked whether the instance document is an evidence of the fact that a type is not a legal restriction of its base.</textual></para></listitem></varlistentry><varlistentry class="po-record e103 e103"><term class="po-block e104 e104"><textual class="po-textual">Hybrid approach</textual></term><listitem class="po-container e105 e105"><para class="po-block e106 e106"><textual class="po-textual">Very similar to the full dynamic approach, but at schema compile time conditional declarations are processed in order to precompute those cases in which the derivation by restriction is violated. Such precomputed information is then available (in some form) at run-time, and it can be used by the validator to decrease the number of operations required to conclude whether the current document is an evidence of the fact that a type is not a legal restriction of its base.</textual></para></listitem></varlistentry></variablelist><para class="po-block e107 e107"><textual class="po-textual">The XSD current draft adopts the full dynamic approach. Indeed, at schema compile time the derivation by restriction is checked simply ignoring type alternatives. Given an element </textual><emphasis class="po-inline e108 e108"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, at run-time it is checked that the type conditionally assigned to </textual><emphasis class="po-inline e109 e109"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of a derived type is a restriction of the type which would be assigned to </textual><emphasis class="po-inline e110 e110"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of the base type. Such a condition is then recursively checked also for </textual><emphasis class="po-inline e111 e111"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and the base type, until the type hierarchy root is reached. I.e., the condition is checked on the entire derivation chain of the initial derived type. We call such a solution </textual><emphasis class="po-inline e112 e112"><textual class="po-textual">Run-Time Check</textual></emphasis><textual class="po-textual"> (RTC). The XSD Working Group publicly </textual><quote class="po-inline e113 e113"><textual class="po-textual">solicit input from implementors and users of this specification as to whether the current run-time rule should be retained</textual></quote><textual class="po-textual"> [</textual><xref class="po-milestone e114 e114" linkend="entryXSD1.1-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e115 e115"><emphasis class="po-inline e116 e116"><textual class="po-textual">Cartesian Product</textual></emphasis><textual class="po-textual"> (CP) is another solution but adopts a hybrid approach. At schema compile time it analyzes </textual><emphasis class="po-inline e117 e117"><textual class="po-textual">all</textual></emphasis><textual class="po-textual"> possible cases that may occur at run-time. As the number of such cases is very high, it has serious shortcomings concerning the computational cost of the static phase.</textual></para><para class="po-block e118 e118"><textual class="po-textual">In this paper we propose a hybrid solution to the problem of the verification of the derivation by restriction in presence of conditional declarations. We call our solution </textual><emphasis class="po-inline e119 e119"><textual class="po-textual">Optimized Cartesian Product</textual></emphasis><textual class="po-textual"> (OCP). OCP, CP, and RTC have the same extensional behavior. OCP can be seen as an optimization to RTC. Indeed, at run-time the number of XPath predicates evaluated by OCP is less than or equal to the number of XPath predicates evaluated by RTC. Moreover, the OCP static phase requires an acceptable computational cost. So OCP is also an optimization to CP (and hence its name). Our paper contribute is two-fold:</textual></para><orderedlist class="po-table e120 e120"><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">it proposes an optimization to the solution adopted by the XSD current draft;</textual></para></listitem><listitem class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">it answers the feedback request about RTC, discussing various possible approaches to the derivation problem, and thoroughly describing three solutions: RTC, CP and OCP;</textual></para></listitem></orderedlist><para class="po-block e125 e125"><textual class="po-textual">Our paper is organized as follows. The next section describes XSD 1.1 in relation to the problem of the co-constraint definition. In particular it describes CTA and assertions. Then we introduce some XSD 1.1 specific terminology in Section â</textual><xref class="po-milestone e126 e126" linkend="sectXSDTerminology"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. In Section â</textual><xref class="po-milestone e127 e127" linkend="sectRestrictionXSD1.1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â we describe the problem of the derivation by restriction in presence of conditional declarations. There we describe some possible approaches and solutions. In particular, we provide a detailed Run-Time Check description, including a computational cost analysis. We also discuss about Cartesian Product. Then in Section â</textual><xref class="po-milestone e128 e128" linkend="sectOurProposal"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â we describe our proposal, providing a computational cost analysis for both the static phase and the dynamic phase. Then in Section â</textual><xref class="po-milestone e129 e129" linkend="sectComparison"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â we compare RTC, CP and OCP, mainly focusing on the number of XPath predicates evaluated at validation time by the three techniques. Then we describe a prototype implementation for OCP, which demonstrates the feasibility of our proposal. Before concluding, in Section â</textual><xref class="po-milestone e130 e130" linkend="sectRelatedWorks"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â we discuss about some related works.</textual></para></section><section class="po-hcontainer e131 e131" xml:id="sectXSD1.1CoConstraints" xreflabel="XSD 1.1 and Co-Constraints"><title class="po-block e132 e132"><textual class="po-textual">XSD 1.1 and Co-Constraints</textual></title><para class="po-block e133 e133"><textual class="po-textual">XSD (</textual><emphasis class="po-inline e134 e134"><textual class="po-textual">XML Schema Definition Language</textual></emphasis><textual class="po-textual">) is the schema language proposed by W3C. Its current version is 1.0, and it is described by two W3C recommendations [</textual><xref class="po-milestone e135 e135" linkend="entryXSD1.0-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e136 e136" linkend="entryXSD1.0-datatypes"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Although there are many other schema languages (such as RELAX NG [</textual><xref class="po-milestone e137 e137" linkend="entryRELAXNGISOspecification"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and  Schematron [</textual><xref class="po-milestone e138 e138" linkend="entrySchematronISOspecification"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]), XSD probably is the most known and supported. XSD 1.0 provides support for the definition of a number of constraint kinds. For instance, by means of content models, it is possible to define the legal content of elements. XSD provides a rich set of built-in types for the definition of legal data values. It also provides derivation mechanisms, permitting to construct new types from existing ones. Moreover, XSD allows to define uniqueness and reference constraints on elements and attributes (cumulatively called identity-constraints).</textual></para><para class="po-block e139 e139"><textual class="po-textual">However, XSD 1.0 is widely recognized as unable to express a particular kind of constraints: </textual><emphasis class="po-inline e140 e140"><textual class="po-textual">co-occurrence constraints</textual></emphasis><textual class="po-textual"> (commonly referred to as </textual><emphasis class="po-inline e141 e141"><textual class="po-textual">co-constraints</textual></emphasis><textual class="po-textual">). According to the definition given by the ESW Wiki, co-constraints are </textual><quote class="po-inline e142 e142"><textual class="po-textual">rules which govern what kinds of markup (elements, attributes) can occur together (co-occur) in an XML document.</textual></quote><textual class="po-textual"> [</textual><xref class="po-milestone e143 e143" linkend="entryCoOccurrenceConstraintsESWWiki"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. In other words, a co-constraint relates the existence or values of an element (or attribute) to the existence or values of other elements (or attributes).</textual></para><para class="po-block e144 e144"><textual class="po-textual">Some categorizations for co-constraints do exist. Within the ESW Wiki about 30 use-cases are listed, ranging from the mutual exclusion of attributes, to the requirement that two elements values must be in some arithmetic relation. In 2001, Norman Walsh and John Cowan identified seven kinds of co-constraints [</textual><xref class="po-milestone e145 e145" linkend="entryWalshCowan2001"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e146 e146"><textual class="po-textual">XSD 1.0 is unable to express co-constraints. Such an inability is heavily felt for in many user communities. For instance, validation of incoming data is critical for e-business infrastructures, that require also the adoption of co-constraints. Adopting XSD 1.0 as validation language requires them to implement application-specific modules, in order to provide a complete validation process.</textual></para><para class="po-block e147 e147"><textual class="po-textual">W3C is releasing a new version of XSD: XSD 1.1. At the time of writing, it is in Last Call Working Draft [</textual><xref class="po-milestone e148 e148" linkend="entryXSD1.1-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, </textual><xref class="po-milestone e149 e149" linkend="entryXSD1.1-datatypes"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. One of the major improvements over 1.0, is the support for co-constraints definition. For this purpose, XSD 1.1</textual><footnote class="po-popup e150 e150"><para class="po-block e151 e151"><textual class="po-textual">From here on, we refer to XSD 1.1 just as XSD.</textual></para></footnote><textual class="po-textual"> introduces two mechanisms: </textual><emphasis class="po-inline e152 e152"><textual class="po-textual">assertions</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e153 e153"><textual class="po-textual">Conditional Type Assignment</textual></emphasis><textual class="po-textual">. Both mechanisms will be described in the next two sections.</textual></para><section class="po-hcontainer e154 e154" xml:id="sectAssertions" xreflabel="Assertions"><title class="po-block e155 e155"><textual class="po-textual">Assertions</textual></title><para class="po-block e156 e156"><textual class="po-textual">In XSD 1.1, a complex type may define a sequence of assertions. Each assertion basically is an XPath 2.0 predicate. In order to be considered valid, each element assigned to a type must satisfy all the assertions defined by that type. Syntactically, an assertion is represented by an </textual><code class="po-atom e157 e157"><textual class="po-textual">&lt;assert&gt;</textual></code><textual class="po-textual"> element, whose </textual><code class="po-atom e158 e158"><textual class="po-textual">test</textual></code><textual class="po-textual"> attribute specifies the XPath predicate.</textual></para><figure class="po-container e159 e159" floatstyle="1" xml:id="figAssertionsExample" xreflabel="Assertion Example"><title class="po-block e160 e160"><textual class="po-textual">Assertion Example</textual></title><programlisting class="po-block e161 e161" xml:space="preserve"><textual class="po-textual">
&lt;xs:element name="pages" type="PagesType" /&gt;
&lt;xs:complexType name="PagesType"&gt;
  &lt;xs:attribute name="from" type="xs:positiveInteger" /&gt;
  &lt;xs:attribute name="to" type="xs:positiveInteger" /&gt;
  </textual><emphasis class="po-inline e162 e162"><textual class="po-textual">&lt;xs:assert test="@from le @to" /&gt;</textual></emphasis><textual class="po-textual">
&lt;/xs:complexType&gt;
</textual></programlisting><caption class="po-container e163 e163"><para class="po-block e164 e164"><textual class="po-textual">An example of XSD assertions. This assertion enforces the </textual><code class="po-atom e165 e165"><textual class="po-textual">from</textual></code><textual class="po-textual"> attribute being less than the </textual><code class="po-atom e166 e166"><textual class="po-textual">to</textual></code><textual class="po-textual"> attribute.</textual></para></caption></figure><para class="po-block e167 e167"><textual class="po-textual">For instance, suppose we want to define an XML language to represent bibliography entries. In order to specify the conference proceedings pages in which a paper appears, we might define a </textual><code class="po-atom e168 e168"><textual class="po-textual">&lt;pages&gt;</textual></code><textual class="po-textual"> element with two attributes </textual><code class="po-atom e169 e169"><textual class="po-textual">from</textual></code><textual class="po-textual"> and </textual><code class="po-atom e170 e170"><textual class="po-textual">to</textual></code><textual class="po-textual">. In order to enforce </textual><code class="po-atom e171 e171"><textual class="po-textual">from</textual></code><textual class="po-textual"> being greater than </textual><code class="po-atom e172 e172"><textual class="po-textual">to</textual></code><textual class="po-textual">, the type definition shown in Figure â</textual><xref class="po-milestone e173 e173" linkend="figAssertionsExample"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â might be used.</textual></para><para class="po-block e174 e174"><textual class="po-textual">Assertions are clearly inspired by Schematron. However, there are some points of distinction. XSD associates assertions to type definitions. On the other hand, Schematron is not a typed language, and thus it associates assertions to elements, or, more precisely, to a set of elements identified by an expression. Moreover, Schematron allows to define assertions involving elements and attributes placed anywhere in the document. On the other hand, in XSD an assertion is allowed to involve only elements and attributes of the subtree rooted by the element the assertion is checked on: nodes outside that subtree are not visible.</textual><footnote class="po-popup e175 e175"><para class="po-block e176 e176"><textual class="po-textual">This limitation is not enforced by a syntactic limitation on the XPath expression, but rather by the way the XPath Data Model is constructed.</textual></para></footnote></para></section><section class="po-hcontainer e177 e177" xml:id="sectCTA" xreflabel="Conditional Type Assignment"><title class="po-block e178 e178"><textual class="po-textual">Conditional Type Assignment</textual></title><para class="po-block e179 e179"><textual class="po-textual">XSD supports co-constraint definitions by means of another mechanism known as </textual><emphasis class="po-inline e180 e180"><textual class="po-textual">Conditional Type Assignment</textual></emphasis><textual class="po-textual"> (CTA). An element declaration may specify a sequence of alternative types, each associated with an XPath predicate. Within this paper we refer to such declarations as </textual><emphasis class="po-inline e181 e181"><textual class="po-textual">conditional</textual></emphasis><textual class="po-textual">. When an element of the instance document is validated against a conditional declaration, the XPath predicates are evaluated using the element as context node. The type assigned to the element is the one corresponding to the satisfied predicate. If the element satisfies more than one predicate, the one occurring first within the schema takes precedence. A conditional declaration always specifies a default type, which is assigned when no predicates are satisfied. Each alternative type derives from the declared type.</textual></para><figure class="po-container e182 e182" floatstyle="1" xml:id="figCTAExample" xreflabel="CTA Example"><title class="po-block e183 e183"><textual class="po-textual">CTA Example</textual></title><programlisting class="po-block e184 e184" xml:space="preserve"><textual class="po-textual">
&lt;xs:complexType name="Entry"&gt;
  &lt;xs:sequence&gt;
    </textual><emphasis class="po-inline e185 e185"><textual class="po-textual">content model for a generic entry</textual></emphasis><textual class="po-textual">
  &lt;/xs:sequence&gt;
  &lt;xs:attribute name="kind" type="EntryKindType" /&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="ProceedingsEntry"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="Entry"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="conference" type="Conference" /&gt;
        &lt;xs:element name="pages" type="Pages" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="entry" type="Entry"&gt;
  </textual><emphasis class="po-inline e186 e186"><textual class="po-textual">&lt;xs:alternative test="@kind = 'proceedings'" type="ProceedingsEntry" /&gt;</textual></emphasis><textual class="po-textual">
&lt;/xs:element&gt;
</textual></programlisting><caption class="po-container e187 e187"><para class="po-block e188 e188"><textual class="po-textual">An example of CTA usage. The conditional declaration assigns type </textual><emphasis class="po-inline e189 e189"><textual class="po-textual">Proceedings</textual></emphasis><textual class="po-textual"> if the entry is of kind </textual><emphasis class="po-inline e190 e190"><textual class="po-textual">proceedings</textual></emphasis><textual class="po-textual">, otherwise it assigns type </textual><emphasis class="po-inline e191 e191"><textual class="po-textual">Entry</textual></emphasis><textual class="po-textual">.</textual></para></caption></figure><para class="po-block e192 e192"><textual class="po-textual">In order to show the usefulness of CTA within the co-constraint definition, we consider again our language for bibliographic entries. Suppose we want to represent an entry through an </textual><code class="po-atom e193 e193"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> element, whose </textual><code class="po-atom e194 e194"><textual class="po-textual">kind</textual></code><textual class="po-textual"> attribute specifies the entry kind (i.e., conference proceedings, technical report, and so on). Suppose that we want to enforce the following co-constraint: if the entry is of kind proceedings, than the </textual><code class="po-atom e195 e195"><textual class="po-textual">&lt;conference&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e196 e196"><textual class="po-textual">&lt;pages&gt;</textual></code><textual class="po-textual"> elements must be present. Then we might define:</textual></para><itemizedlist class="po-table e197 e197"><listitem class="po-container e198 e198"><para class="po-block e199 e199"><textual class="po-textual">an </textual><emphasis class="po-inline e200 e200"><textual class="po-textual">Entry</textual></emphasis><textual class="po-textual"> type, constraining the content of a generic entry</textual></para></listitem><listitem class="po-container e201 e201"><para class="po-block e202 e202"><textual class="po-textual">a </textual><emphasis class="po-inline e203 e203"><textual class="po-textual">ProceedingsEntry</textual></emphasis><textual class="po-textual"> type, derived by </textual><emphasis class="po-inline e204 e204"><textual class="po-textual">Entry</textual></emphasis><textual class="po-textual"> and requiring the presence of both </textual><code class="po-atom e205 e205"><textual class="po-textual">&lt;conference&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e206 e206"><textual class="po-textual">&lt;pages&gt;</textual></code><textual class="po-textual">.</textual></para></listitem><listitem class="po-container e207 e207"><para class="po-block e208 e208"><textual class="po-textual">a conditional declaration for </textual><code class="po-atom e209 e209"><textual class="po-textual">&lt;entry&gt;</textual></code><textual class="po-textual"> assigning type </textual><emphasis class="po-inline e210 e210"><textual class="po-textual">ProceedingsEntry</textual></emphasis><textual class="po-textual"> if the </textual><code class="po-atom e211 e211"><textual class="po-textual">kind</textual></code><textual class="po-textual"> attribute has value </textual><code class="po-atom e212 e212"><textual class="po-textual">"proceedings"</textual></code><textual class="po-textual">, and type </textual><emphasis class="po-inline e213 e213"><textual class="po-textual">Entry</textual></emphasis><textual class="po-textual"> otherwise.</textual></para></listitem></itemizedlist><para class="po-block e214 e214"><textual class="po-textual">That solution is shown in Figure â</textual><xref class="po-milestone e215 e215" linkend="figCTAExample"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â.</textual></para><para class="po-block e216 e216"><textual class="po-textual">Note that, by default if an element does not satisfy any alternative, then it is assigned the type specified through the </textual><code class="po-atom e217 e217"><textual class="po-textual">type</textual></code><textual class="po-textual"> attribute (known as the </textual><emphasis class="po-inline e218 e218"><textual class="po-textual">declared type</textual></emphasis><textual class="po-textual">). In order to specify a default type other than the declared type, it is possible to explicitly define a </textual><emphasis class="po-inline e219 e219"><textual class="po-textual">default type alternative</textual></emphasis><textual class="po-textual">, i.e., a type alternative occurring in last position and without any XPath predicate.</textual></para><para class="po-block e220 e220"><textual class="po-textual">XSD 1.1 introduces a new built-in simple type named </textual><emphasis class="po-inline e221 e221"><textual class="po-textual">error</textual></emphasis><textual class="po-textual">. No element or attribute is valid against such a type. </textual><emphasis class="po-inline e222 e222"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> is typically used in default type alternatives to states that it is an error if no type alternative is selected.</textual></para><para class="po-block e223 e223"><textual class="po-textual">The CTA mechanism is inspired by SchemaPath, an extension to XSD 1.0 introducing the concept of conditional type assignment [</textual><xref class="po-milestone e224 e224" linkend="entrySchemaPathWWW"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. However, there are some remarkable points of distinction (besides some syntactic aspects). In SchemaPath, a conditional declaration does not have the declared type. Moreover, while SchemaPath does not put any restriction on XPath predicates, XSD allows predicates to access attribute nodes only. Thus, it is not possible to put conditions on neither preceding, ancestor, nor descending nodes.</textual></para></section></section><section class="po-hcontainer e225 e225" xml:id="sectXSDTerminology" xreflabel="XSD Terminology"><title class="po-block e226 e226"><textual class="po-textual">XSD Terminology</textual></title><para class="po-block e227 e227"><textual class="po-textual">For the reader unfamiliar with XSD, this section introduces some CTA-related definitions taken from the XSD current draft [</textual><xref class="po-milestone e228 e228" linkend="entryXSD1.1-structures"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><variablelist class="po-table e229 e229"><varlistentry class="po-record e230 e230"><term class="po-block e231 e231"><emphasis class="po-inline e232 e232" role="bold"><textual class="po-textual">Declared type</textual></emphasis></term><listitem class="po-container e233 e233"><para class="po-block e234 e234"><textual class="po-textual">Given an element declaration </textual><emphasis class="po-inline e235 e235"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> the declared type of </textual><emphasis class="po-inline e236 e236"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> is either the type referred to by the attribute </textual><code class="po-atom e237 e237"><textual class="po-textual">type</textual></code><textual class="po-textual">, or the anonymous type definition within </textual><emphasis class="po-inline e238 e238"><textual class="po-textual">D</textual></emphasis></para></listitem></varlistentry><varlistentry class="po-record e239 e239"><term class="po-block e240 e240"><emphasis class="po-inline e241 e241" role="bold"><textual class="po-textual">Context-determined type</textual></emphasis></term><listitem class="po-container e242 e242"><para class="po-block e243 e243"><textual class="po-textual">Given an element </textual><emphasis class="po-inline e244 e244"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a type </textual><emphasis class="po-inline e245 e245"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, the context-determined type of </textual><emphasis class="po-inline e246 e246"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e247 e247"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> is the declared type of the declaration </textual><emphasis class="po-inline e248 e248"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> assigned to </textual><emphasis class="po-inline e249 e249"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> by the </textual><emphasis class="po-inline e250 e250"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> content model.</textual></para></listitem></varlistentry><varlistentry class="po-record e251 e251"><term class="po-block e252 e252"><emphasis class="po-inline e253 e253" role="bold"><textual class="po-textual">Type Table</textual></emphasis></term><listitem class="po-container e254 e254"><para class="po-block e255 e255"><textual class="po-textual">A Type Table is a property of conditional declarations, and it is a sequence of type alternatives (or simply, alternatives). Each alternative corresponds to a </textual><code class="po-atom e256 e256"><textual class="po-textual">xs:alternative</textual></code><textual class="po-textual"> element, and it mainly consits of an XPath predicate and a type.</textual></para></listitem></varlistentry><varlistentry class="po-record e257 e257"><term class="po-block e258 e258"><emphasis class="po-inline e259 e259" role="bold"><textual class="po-textual">Selected type</textual></emphasis></term><listitem class="po-container e260 e260"><para class="po-block e261 e261"><textual class="po-textual">Given an element </textual><emphasis class="po-inline e262 e262"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a Type Table </textual><emphasis class="po-inline e263 e263"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual">, the selected type of </textual><emphasis class="po-inline e264 e264"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is the type associated to the </textual><emphasis class="po-inline e265 e265"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> alternative satisfied by </textual><emphasis class="po-inline e266 e266"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">.</textual></para></listitem></varlistentry><varlistentry class="po-record e267 e267"><term class="po-block e268 e268"><emphasis class="po-inline e269 e269" role="bold"><textual class="po-textual">Context-determined Type Table</textual></emphasis></term><listitem class="po-container e270 e270"><para class="po-block e271 e271"><textual class="po-textual">Given an element </textual><emphasis class="po-inline e272 e272"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a type </textual><emphasis class="po-inline e273 e273"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, the context-determined Type Table of </textual><emphasis class="po-inline e274 e274"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e275 e275"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> is the Type Table of the declaration </textual><emphasis class="po-inline e276 e276"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> assigned to </textual><emphasis class="po-inline e277 e277"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> by the </textual><emphasis class="po-inline e278 e278"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> content model. If </textual><emphasis class="po-inline e279 e279"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> is non-conditional, the context-determined Type Table has the default alternative only, which assigns the declared type.</textual></para></listitem></varlistentry></variablelist></section><section class="po-hcontainer e280 e280" xml:id="sectRestrictionXSD1.1" xreflabel="Derivation by Restriction in XSD 1.1"><title class="po-block e281 e281"><textual class="po-textual">Derivation by Restriction in XSD 1.1</textual></title><para class="po-block e282 e282"><textual class="po-textual">XSD allows to define new types from existing ones through two derivation mechanisms, </textual><emphasis class="po-inline e283 e283"><textual class="po-textual">extension</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e284 e284"><textual class="po-textual">restriction</textual></emphasis><textual class="po-textual">. The latter is meant to define a type whose content model accepts a subset of what the base type content model accepts.</textual></para><figure class="po-container e285 e285" floatstyle="1" xml:id="figCTARestrictionExample" xreflabel="CTA Restriction Example"><title class="po-block e286 e286"><textual class="po-textual">CTA Restriction Example</textual></title><programlisting class="po-block e287 e287" xml:space="preserve"><textual class="po-textual">
&lt;xs:complexType name="B"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="e" type="xs:anyType"&gt;
      &lt;xs:alternative test="@a &gt;  @b" type="T1" /&gt;
      &lt;xs:alternative test="@a &lt;= @b" type="T2" /&gt;
    &lt;/xs:element&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="R"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="B"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="e" type="xs:anyType"&gt;
          &lt;xs:alternative test="@a &gt;  @b" type="T2" /&gt;
          &lt;xs:alternative test="@a &lt;= @b" type="T1" /&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="T1"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="t1" /&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attributeGroup ref="ab" /&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="T2"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="t2" /&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attributeGroup ref="ab" /&gt;
&lt;/xs:complexType&gt;

</textual></programlisting><caption class="po-container e288 e288"><para class="po-block e289 e289"><textual class="po-textual">An example of derivation by restriction involving conditional declarations.</textual></para></caption></figure><para class="po-block e290 e290"><textual class="po-textual">The presence of conditional declarations within content models immediately arises a question concerning the derivation by restriction. In order to explain the issue, let us consider the schema snippet shown in Figure â</textual><xref class="po-milestone e291 e291" linkend="figCTARestrictionExample"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. We can observe that neither </textual><emphasis class="po-inline e292 e292"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual"> derives from </textual><emphasis class="po-inline e293 e293"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">, nor the converse. Also it is easy to observe that whenever the conditional declaration within </textual><emphasis class="po-inline e294 e294"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> assigns </textual><emphasis class="po-inline e295 e295"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">, the conditional declaration within </textual><emphasis class="po-inline e296 e296"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> assigns </textual><emphasis class="po-inline e297 e297"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">, and vice versa.</textual></para><para class="po-block e298 e298"><textual class="po-textual">Now let us consider the following XML fragment:</textual></para><programlisting class="po-block e299 e299" xml:space="preserve"><textual class="po-textual">
&lt;p xsi:type="R"&gt;
 &lt;e a="5" b="2"&gt; </textual><emphasis class="po-inline e300 e300"><textual class="po-textual">&lt;!-- @a &gt; @b --&gt;</textual></emphasis><textual class="po-textual">
   &lt;t2 /&gt;
 &lt;/e&gt;
&lt;/p&gt;
</textual></programlisting><para class="po-block e301 e301"><textual class="po-textual">As </textual><code class="po-atom e302 e302"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual"> is assigned type </textual><emphasis class="po-inline e303 e303"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">, its child </textual><code class="po-atom e304 e304"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> is assigned type </textual><emphasis class="po-inline e305 e305"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">. According to the schema, </textual><code class="po-atom e306 e306"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> is valid against </textual><emphasis class="po-inline e307 e307"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">. For what previously observed, the type that would be assigned to </textual><code class="po-atom e308 e308"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> if </textual><code class="po-atom e309 e309"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual"> was of type </textual><emphasis class="po-inline e310 e310"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e311 e311"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">. Clearly, </textual><code class="po-atom e312 e312"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> is not valid against </textual><emphasis class="po-inline e313 e313"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">. Thus we have that </textual><emphasis class="po-inline e314 e314"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> rejects something </textual><emphasis class="po-inline e315 e315"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> accepts. We can reasonably argue that this is a violation of the principle behind the derivation by restriction. And actually, the XSD current draft imposes constraints meant to detect as illegal situations like the one above.</textual></para><para class="po-block e316 e316"><textual class="po-textual">Before discussing in details how the XSD current draft faces the derivation by restriction in presence of conditional declarations, we examine some general approaches to the problem.</textual></para><section class="po-hcontainer e317 e317" xml:id="sectFullStaticApproach" xreflabel="Full Static Approach"><title class="po-block e318 e318"><textual class="po-textual">Full Static Approach</textual></title><para class="po-block e319 e319"><textual class="po-textual">We can think about approaches </textual><emphasis class="po-inline e320 e320"><textual class="po-textual">statically</textual></emphasis><textual class="po-textual"> (i.e., at schema compile time) deciding whether a conditional declaration within a restricted type is compatible with a conditional declaration within the base type. I.e., such an approach should decide the following problem. Given two conditional declarations </textual><emphasis class="po-inline e321 e321"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e322 e322"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, is there any XML document containing an element </textual><emphasis class="po-inline e323 e323"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> such that if </textual><emphasis class="po-inline e324 e324"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is validated against </textual><emphasis class="po-inline e325 e325"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> then it is assigned a type which is not a valid restriction of the type that would be assigned if </textual><emphasis class="po-inline e326 e326"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> was validated against </textual><emphasis class="po-inline e327 e327"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">?</textual></para><para class="po-block e328 e328"><textual class="po-textual">This is not a simple problem, as it is necessary to verify logic relationships among XPath predicates. For instance consider again the conditional declarations shown in Figure â</textual><xref class="po-milestone e329 e329" linkend="figCTARestrictionExample"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. Clearly, the answer to the above question is </textual><emphasis class="po-inline e330 e330"><textual class="po-textual">yes</textual></emphasis><textual class="po-textual">, as if the conditional declaration within the restricted type assigns </textual><emphasis class="po-inline e331 e331"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">, then the conditional declaration within the base type assigns </textual><emphasis class="po-inline e332 e332"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">. Thus, we can assert that the derived type is not a legal restriction of its base. In order to prove it, we should consider the semantics of the relational operators </textual><code class="po-atom e333 e333"><textual class="po-textual">&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e334 e334"><textual class="po-textual">&lt;=</textual></code><textual class="po-textual">. Probably, it is not a so difficult task, as the XPath predicates involved in the example are quite simple. But if we move to the general case, the problem becomes much more difficult, as we have to consider also the other XPath functions and operators.</textual></para></section><section class="po-hcontainer e335 e335" xml:id="sectExpressivityLimitationApproach" xreflabel="Expressivity Limitation Approach"><title class="po-block e336 e336"><textual class="po-textual">Expressivity Limitation Approach</textual></title><para class="po-block e337 e337"><textual class="po-textual">It is possible to identify a class of approaches facing the problem by narrowing the CTA usage, in order to avoid the XPath predicates analysis. For instance a simple and radical solution to the problem consists in implicitly setting as </textual><emphasis class="po-inline e338 e338"><textual class="po-textual">final</textual></emphasis><footnote class="po-popup e339 e339"><para class="po-block e340 e340"><textual class="po-textual">In XSD, if a type is set as final, it cannot be derived.</textual></para></footnote><textual class="po-textual"> every complex types containing a conditional declaration. This is the solution adopted by SchemaPath. Obviously, this solution might be felt as overly restrictive.</textual></para><para class="po-block e341 e341"><textual class="po-textual">Less restrictive solutions may be found. The XSD Working Group discussed a number of them. One of such solutions, known as </textual><emphasis class="po-inline e342 e342"><textual class="po-textual">Prefix</textual></emphasis><textual class="po-textual">, forces the conditional declaration within the derived type to repeat all the alternatives of the conditional declaration within the base type, and allows to append new alternatives. Requiring new alternative types to be a restriction of the default type of the base declaration, ensures that every type assigned in the context of the derived type is a restriction of the type that would be assigned in the context of the base type.</textual></para><figure class="po-container e343 e343" floatstyle="1" xml:id="figCTARestrictionUseCase" xreflabel="CTA Restriction Use Case"><title class="po-block e344 e344"><textual class="po-textual">CTA Restriction Use Case</textual></title><programlisting class="po-block e345 e345" xml:space="preserve"><textual class="po-textual">
&lt;xs:complexType name="B"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="message" type="messageType"&gt;
      &lt;xs:alternative test="@kind='string'" type="messageTypeString"/&gt;
      &lt;xs:alternative test="@kind='base64'" type="messageTypeBase64"/&gt;
      &lt;xs:alternative test="@kind='binary'" type="messageTypeBase64"/&gt;
      &lt;xs:alternative test="@kind='xml'"    type="messageTypeXML"/&gt;
      &lt;xs:alternative test="@kind='XML'"    type="messageTypeXML"/&gt;
    &lt;/xs:element&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="R"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="B"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="message" type="messageType"&gt;
          &lt;xs:alternative test="@kind='string'" type="messageTypeString"/&gt;
          &lt;xs:alternative                       type="xs:error"/&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</textual></programlisting><caption class="po-container e346 e346"><para class="po-block e347 e347"><textual class="po-textual">An example of restriction in presence of CTA. The restricted type definition is meant to accept a subset of what the base type definition accepts.</textual></para></caption></figure><para class="po-block e348 e348"><textual class="po-textual">Let us consider the schema shown in Figure â</textual><xref class="po-milestone e349 e349" linkend="figCTARestrictionUseCase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, which is inspired by the example of CTA usage described in the XSD current draft. Within type </textual><emphasis class="po-inline e350 e350"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, the conditional declaration for </textual><code class="po-atom e351 e351"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> elements assigns a specific message type based on the </textual><code class="po-atom e352 e352"><textual class="po-textual">kind</textual></code><textual class="po-textual"> attribute value. Type </textual><emphasis class="po-inline e353 e353"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is meant to accept string messages only. In this respect, we might argue that </textual><emphasis class="po-inline e354 e354"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is a legal restriction of </textual><emphasis class="po-inline e355 e355"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">. However, Prefix rejects the above schema, as the alternative sequence of the base type are not listed in the alternative sequence of the restricted type.</textual></para></section><section class="po-hcontainer e356 e356" xml:id="sectFullDynamicApproach" xreflabel="Full Dynamic Approach"><title class="po-block e357 e357"><textual class="po-textual">Full Dynamic Approach</textual></title><para class="po-block e358 e358"><textual class="po-textual">Another approach to the problem is the following: do not perform any check at compile time and let schema authors to write conditional declarations as they like, but if at run time (i.e., at validation time) there is an evidence of the fact that a type is not a legal restriction of its base type, then report the error. W.r.t. the approach described in the previous section, this one reaches the maximum expressivity degree in writing conditional declarations. Clearly, the drawback is that the same schema error might become evident only for certain instance documents, and not for others.</textual></para><para class="po-block e359 e359"><textual class="po-textual">This is the approach adopted by the XSD current draft, and will be described in details in Section â</textual><xref class="po-milestone e360 e360" linkend="sectRuntTimeCheck"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â.</textual></para></section><section class="po-hcontainer e361 e361" xml:id="sectRuntTimeCheck" xreflabel="Run-Time Check"><title class="po-block e362 e362"><textual class="po-textual">Run-time Check</textual></title><para class="po-block e363 e363"><textual class="po-textual">As already mentioned in the previous sections, the XSD current draft adopts a dynamic approach to the verification of the derivation by restriction in presence of conditional declarations. Indeed, the general problem of verifying whether a type </textual><emphasis class="po-inline e364 e364"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is legal restriction of a type </textual><emphasis class="po-inline e365 e365"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> is divided in two phases. The first one is meant to be performed at schema compile time, and it considers the declared type of element declarations only, thus simply ignoring the presence of Type Tables. For the implementation of such a phase, the XSD draft refers to the algorithms described in [</textual><xref class="po-milestone e366 e366" linkend="entryFSAThompson"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e367 e367" linkend="entryFuchs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and [</textual><xref class="po-milestone e368 e368" linkend="entryBrzozowski"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e369 e369"><textual class="po-textual">The second phase (which we call </textual><emphasis class="po-inline e370 e370"><textual class="po-textual">Run-Time Check</textual></emphasis><textual class="po-textual"> or simply RTC) is meant to be performed at run-time, and it takes into considerations Type Tables. The XSD specs describe it as a rule to decide the validity of an element w.r.t. a type. In order to be valid against a type </textual><emphasis class="po-inline e371 e371"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, an element must satisfy a number of constraints. One of such constraints states that each child </textual><emphasis class="po-inline e372 e372"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> together with </textual><emphasis class="po-inline e373 e373"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> must satisfy the </textual><emphasis class="po-inline e374 e374"><textual class="po-textual">Conditional Type Substitutable in Restriction</textual></emphasis><textual class="po-textual"> constraint (CTSR).</textual></para><para class="po-block e375 e375"><textual class="po-textual">Informally, given an element </textual><emphasis class="po-inline e376 e376"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a type </textual><emphasis class="po-inline e377 e377"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e378 e378"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e379 e379"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> satisfy CTSR if the type assigned to </textual><emphasis class="po-inline e380 e380"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of </textual><emphasis class="po-inline e381 e381"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, is a valid restriction of the type assigned to </textual><emphasis class="po-inline e382 e382"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in the context of </textual><emphasis class="po-inline e383 e383"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base type. Moreover, </textual><emphasis class="po-inline e384 e384"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e385 e385"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base type must recursively satisfy CTSR.</textual></para><para class="po-block e386 e386"><textual class="po-textual">For instance, consider again the schema in Figure â</textual><xref class="po-milestone e387 e387" linkend="figCTARestrictionExample"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, and the following XML document fragment:</textual></para><programlisting class="po-block e388 e388" xml:space="preserve"><textual class="po-textual">
&lt;p xsi:type="R"&gt;
 &lt;e a="5" b="2"&gt;
   &lt;t2 /&gt;
 &lt;/e&gt;
&lt;/p&gt;
</textual></programlisting><para class="po-block e389 e389"><textual class="po-textual">The first phase checks whether type </textual><emphasis class="po-inline e390 e390"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is a legal restriction of </textual><emphasis class="po-inline e391 e391"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, taking into consideration declared types only. In particular, it is checked whether the declared type of the element declaration within </textual><emphasis class="po-inline e392 e392"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> (i.e., </textual><emphasis class="po-inline e393 e393"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual">) is a valid restriction of the declared type of the element declaration within </textual><emphasis class="po-inline e394 e394"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> (i.e., </textual><emphasis class="po-inline e395 e395"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual">). As </textual><emphasis class="po-inline e396 e396"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual"> is a valid restriction of itself, the first phase succeeds.</textual></para><para class="po-block e397 e397"><textual class="po-textual">The second phase checks whether or not the input document is an evidence of the fact that </textual><emphasis class="po-inline e398 e398"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e399 e399"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> a legal restriction of </textual><emphasis class="po-inline e400 e400"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">. In particular, RTC checks whether </textual><code class="po-atom e401 e401"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> and </textual><emphasis class="po-inline e402 e402"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> satisfy CTSR. Thus, the Type Table determined by </textual><emphasis class="po-inline e403 e403"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> is evaluated, obtaining the selected type </textual><emphasis class="po-inline e404 e404"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual">. Then, also the Type Table determined by </textual><emphasis class="po-inline e405 e405"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> is evaluated, obtaining the selected type </textual><emphasis class="po-inline e406 e406"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">. As </textual><emphasis class="po-inline e407 e407"><textual class="po-textual">T2</textual></emphasis><textual class="po-textual"> is not a valid restriction of </textual><emphasis class="po-inline e408 e408"><textual class="po-textual">T1</textual></emphasis><textual class="po-textual">, </textual><code class="po-atom e409 e409"><textual class="po-textual">&lt;e&gt;</textual></code><textual class="po-textual"> and </textual><emphasis class="po-inline e410 e410"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> does not satisfy CTSR. As a consequence, </textual><code class="po-atom e411 e411"><textual class="po-textual">&lt;p&gt;</textual></code><textual class="po-textual"> is not valid against </textual><emphasis class="po-inline e412 e412"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">.</textual></para><section class="po-hcontainer e413 e413" xml:id="sectRTCAlgorithm" xreflabel="An Algorithm for Run-Time Check"><title class="po-block e414 e414"><textual class="po-textual">An Algorithm for Run-Time Check</textual></title><figure class="po-container e415 e415" floatstyle="1" xml:id="figRTCAlgorithm" xreflabel="RTC Algorithm"><title class="po-block e416 e416"><textual class="po-textual">RTC Algorithm</textual></title><programlisting class="po-block e417 e417" xml:space="preserve"><textual class="po-textual">
void process-element(Element e) {

  </textual><emphasis class="po-inline e418 e418"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">

  Type T = get-current-type(); </textual><emphasis class="po-inline e419 e419"><textual class="po-textual">// e's parent type</textual></emphasis><textual class="po-textual">

  TypeTable TT</textual><subscript class="po-atom e420 e420"><textual class="po-textual">T</textual></subscript><textual class="po-textual"> = get-context-determined-type-table(e, T);
  int i = evaluate-type-table(e, TT</textual><subscript class="po-atom e421 e421"><textual class="po-textual">T</textual></subscript><textual class="po-textual">);
  Type S</textual><subscript class="po-atom e422 e422"><textual class="po-textual">T</textual></subscript><textual class="po-textual"> = TT</textual><subscript class="po-atom e423 e423"><textual class="po-textual">T</textual></subscript><textual class="po-textual">.get-alternative(i).getType();

  boolean error = false;

  </textual><emphasis class="po-inline e424 e424"><textual class="po-textual">// walk on the derivation chain</textual></emphasis><textual class="po-textual">
  while (T is not xs:anyType and !error) do {

    Type B = T.base;
    TypeTable TT</textual><subscript class="po-atom e425 e425"><textual class="po-textual">B</textual></subscript><textual class="po-textual"> = get-context-determined-type-table(e, B);
    int j = evaluate-type-table(e, TT</textual><subscript class="po-atom e426 e426"><textual class="po-textual">B</textual></subscript><textual class="po-textual">);
    Type S</textual><subscript class="po-atom e427 e427"><textual class="po-textual">B</textual></subscript><textual class="po-textual"> = TT</textual><subscript class="po-atom e428 e428"><textual class="po-textual">B</textual></subscript><textual class="po-textual">.getAlternative(j).getType();

    if (validly-substitutable-as-restriction(S</textual><subscript class="po-atom e429 e429"><textual class="po-textual">T</textual></subscript><textual class="po-textual">, S</textual><subscript class="po-atom e430 e430"><textual class="po-textual">B</textual></subscript><textual class="po-textual">)) {
      T = B;
      S</textual><subscript class="po-atom e431 e431"><textual class="po-textual">T</textual></subscript><textual class="po-textual"> = S</textual><subscript class="po-atom e432 e432"><textual class="po-textual">B</textual></subscript><textual class="po-textual">;
    } else {
      </textual><emphasis class="po-inline e433 e433"><textual class="po-textual">// CTSR violation</textual></emphasis><textual class="po-textual">
      error = true;
      report-schema-error("vr-cta-substitutable");
    }
  }

  </textual><emphasis class="po-inline e434 e434"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">

}

</textual></programlisting><caption class="po-container e435 e435"><para class="po-block e436 e436"><textual class="po-textual">An algorithm implementing RTC.</textual></para></caption></figure><para class="po-block e437 e437"><textual class="po-textual">In Figure â</textual><xref class="po-milestone e438 e438" linkend="figRTCAlgorithm"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â we present an algorithm implementing RTC, in Java-like pseudo-code. The </textual><emphasis class="po-inline e439 e439"><textual class="po-textual">process-element</textual></emphasis><textual class="po-textual"> function is meant to be invoked for each element of the instance document. The function body is a simple iterative version of the CTSR constraint definition given in the XSD draft. It iterates over the derivation chain for </textual><emphasis class="po-inline e440 e440"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, and it stops when either a violation of CTSR occurs or the type hierarchy root (i.e., </textual><emphasis class="po-inline e441 e441"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual">) is reached.</textual></para></section><section class="po-hcontainer e442 e442" xml:id="sectRTCAlgorithmCostAnalysis" xreflabel="RTC Algorithm Cost Analysis"><title class="po-block e443 e443"><textual class="po-textual">RTC Algorithm Cost Analysis</textual></title><para class="po-block e444 e444"><textual class="po-textual">In presenting our cost analysis for the algorithm shown in the previous section, we need to introduce some notations. A Type Table </textual><emphasis class="po-inline e445 e445"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> is an ordered sequence of </textual><emphasis class="po-inline e446 e446"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> pairs &lt;</textual><emphasis class="po-inline e447 e447"><textual class="po-textual">c</textual></emphasis><subscript class="po-atom e448 e448"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, </textual><emphasis class="po-inline e449 e449"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e450 e450"><textual class="po-textual">1</textual></subscript><textual class="po-textual">&gt;, ..., &lt;</textual><emphasis class="po-inline e451 e451"><textual class="po-textual">c</textual><subscript class="po-atom e452 e452"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e453 e453"><textual class="po-textual">T</textual><subscript class="po-atom e454 e454"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">&gt;, where </textual><emphasis class="po-inline e455 e455"><textual class="po-textual">c</textual><subscript class="po-atom e456 e456"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual"> is the always true condition. We also say that </textual><emphasis class="po-inline e457 e457"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> has size </textual><emphasis class="po-inline e458 e458"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e459 e459"><textual class="po-textual">Now, let </textual><emphasis class="po-inline e460 e460"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e461 e461"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> be an element and a type definition respectively. Consider the derivation chain for </textual><emphasis class="po-inline e462 e462"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">. We indicate it with </textual><emphasis class="po-inline e463 e463"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e464 e464"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e465 e465"><textual class="po-textual">T</textual><subscript class="po-atom e466 e466"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e467 e467"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e468 e468"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> is </textual><emphasis class="po-inline e469 e469"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e470 e470"><textual class="po-textual">T</textual><subscript class="po-atom e471 e471"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e472 e472"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, and for each </textual><emphasis class="po-inline e473 e473"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> &lt; </textual><emphasis class="po-inline e474 e474"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e475 e475"><textual class="po-textual">T</textual><subscript class="po-atom e476 e476"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e477 e477"><textual class="po-textual">T</textual><subscript class="po-atom e478 e478"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e479 e479"><textual class="po-textual">+1</textual></subscript><textual class="po-textual">'s base type. For each </textual><emphasis class="po-inline e480 e480"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> between 1 and </textual><emphasis class="po-inline e481 e481"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, we denote the context-determined Type Table for </textual><emphasis class="po-inline e482 e482"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e483 e483"><textual class="po-textual">T</textual><subscript class="po-atom e484 e484"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> by </textual><emphasis class="po-inline e485 e485"><textual class="po-textual">TT</textual><subscript class="po-atom e486 e486"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">. Moreover we denote the </textual><emphasis class="po-inline e487 e487"><textual class="po-textual">TT</textual><subscript class="po-atom e488 e488"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> size by </textual><emphasis class="po-inline e489 e489"><textual class="po-textual">d</textual><subscript class="po-atom e490 e490"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e491 e491"><textual class="po-textual">Now, we can start the RTC algorithm cost analysis. If there is no CTSR violation, the RTC algorithm iterates over the entire derivation chain for </textual><emphasis class="po-inline e492 e492"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">. For each </textual><emphasis class="po-inline e493 e493"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> between 1 and </textual><emphasis class="po-inline e494 e494"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, the following operations are performed:</textual></para><orderedlist class="po-table e495 e495"><listitem class="po-container e496 e496"><para class="po-block e497 e497"><textual class="po-textual">get the context-determined Type Table for </textual><emphasis class="po-inline e498 e498"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e499 e499"><textual class="po-textual">T</textual><subscript class="po-atom e500 e500"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, i.e., </textual><emphasis class="po-inline e501 e501"><textual class="po-textual">TT</textual><subscript class="po-atom e502 e502"><textual class="po-textual">i</textual></subscript></emphasis></para></listitem><listitem class="po-container e503 e503"><para class="po-block e504 e504"><textual class="po-textual">calculate the selected type for </textual><emphasis class="po-inline e505 e505"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> according to </textual><emphasis class="po-inline e506 e506"><textual class="po-textual">TT</textual><subscript class="po-atom e507 e507"><textual class="po-textual">i</textual></subscript></emphasis></para></listitem><listitem class="po-container e508 e508"><para class="po-block e509 e509"><textual class="po-textual">check whether the selected type is validly substitutable as restriction for the selected type calculated at step </textual><emphasis class="po-inline e510 e510"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> - 1.</textual></para></listitem></orderedlist><para class="po-block e511 e511"><textual class="po-textual">We assume the first operation has a negligible cost. Indeed, given an element </textual><emphasis class="po-inline e512 e512"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a type </textual><emphasis class="po-inline e513 e513"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, the </textual><emphasis class="po-inline e514 e514"><textual class="po-textual">Element Declarations Consistent</textual></emphasis><textual class="po-textual"> (EDC) constraint ensures that the context-determined type table for </textual><emphasis class="po-inline e515 e515"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e516 e516"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> depends on the </textual><emphasis class="po-inline e517 e517"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> name only. Thus it suffices to scan the </textual><emphasis class="po-inline e518 e518"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> content model, looking for an element declaration named as </textual><emphasis class="po-inline e519 e519"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">. As we are not interested in the content model size here, we assume </textual><emphasis class="po-inline e520 e520"><textual class="po-textual">TT</textual><subscript class="po-atom e521 e521"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> can be found through a single memory access.</textual></para><para class="po-block e522 e522"><textual class="po-textual">We assume the third operation has a negligible cost too. Indeed, we assume for each pair of types &lt;</textual><emphasis class="po-inline e523 e523"><textual class="po-textual">A</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e524 e524"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">&gt;, the schema compile phase already decided whether </textual><emphasis class="po-inline e525 e525"><textual class="po-textual">A</textual></emphasis><textual class="po-textual"> is validly substitutable as restriction for </textual><emphasis class="po-inline e526 e526"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, and that the result is available at run-time and can be read through a single memory access.</textual></para><para class="po-block e527 e527"><textual class="po-textual">In our analysis, we do not neglect the second operation cost. Given an element </textual><emphasis class="po-inline e528 e528"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and a Type Table </textual><emphasis class="po-inline e529 e529"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual">, in order to decide the selected type for </textual><emphasis class="po-inline e530 e530"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e531 e531"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual">, it might be necessary to evaluate all the XPath conditions in </textual><emphasis class="po-inline e532 e532"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual">.</textual><footnote class="po-popup e533 e533"><para class="po-block e534 e534"><textual class="po-textual">To be more precise, as the last predicate of a Type Table is the always true condition, it suffices to evaluate </textual><emphasis class="po-inline e535 e535"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">-1 predicates, where </textual><emphasis class="po-inline e536 e536"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> is the Type Table size.</textual></para></footnote><textual class="po-textual"> Indeed if </textual><emphasis class="po-inline e537 e537"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> has the following alternatives &lt;</textual><emphasis class="po-inline e538 e538"><textual class="po-textual">c</textual></emphasis><subscript class="po-atom e539 e539"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, </textual><emphasis class="po-inline e540 e540"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e541 e541"><textual class="po-textual">1</textual></subscript><textual class="po-textual">&gt;, ..., &lt;</textual><emphasis class="po-inline e542 e542"><textual class="po-textual">c</textual><subscript class="po-atom e543 e543"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e544 e544"><textual class="po-textual">T</textual><subscript class="po-atom e545 e545"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">&gt;, then </textual><emphasis class="po-inline e546 e546"><textual class="po-textual">T</textual><subscript class="po-atom e547 e547"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is chosen if and only if none of the conditions </textual><emphasis class="po-inline e548 e548"><textual class="po-textual">c</textual></emphasis><subscript class="po-atom e549 e549"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e550 e550"><textual class="po-textual">c</textual><subscript class="po-atom e551 e551"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e552 e552"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> hold, and </textual><emphasis class="po-inline e553 e553"><textual class="po-textual">c</textual><subscript class="po-atom e554 e554"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> holds. Thus a correct algorithm for a Type Table evaluation is that evaluating each alternative in order, and stopping as soon as a condition is satisfied. Clearly, such an algorithm is linear in the Type Table size.</textual></para><para class="po-block e555 e555"><textual class="po-textual">Coming back to our cost analysis, as </textual><emphasis class="po-inline e556 e556"><textual class="po-textual">TT</textual><subscript class="po-atom e557 e557"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> has size </textual><emphasis class="po-inline e558 e558"><textual class="po-textual">d</textual><subscript class="po-atom e559 e559"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, the second operation requires the evaluation of at most </textual><emphasis class="po-inline e560 e560"><textual class="po-textual">d</textual><subscript class="po-atom e561 e561"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> XPath conditions.</textual></para><para class="po-block e562 e562"><textual class="po-textual">Thus in our analysis, the RTC algorithm cost is given by the number of XPath predicates evaluated. By the observations above, we have that such a cost is upper-bounded by the equation shown in Equation â</textual><xref class="po-milestone e563 e563" linkend="equationRTCAlgoUpperBound"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â.</textual></para><equation class="po-container e564 e564" xml:id="equationRTCAlgoUpperBound" xreflabel="RTC algorithm upper-bound"><mathphrase class="po-block e565 e565"><emphasis class="po-inline e566 e566"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e567 e567"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> + ... + </textual><emphasis class="po-inline e568 e568"><textual class="po-textual">d</textual><subscript class="po-atom e569 e569"><textual class="po-textual">k</textual></subscript></emphasis></mathphrase></equation></section></section><section class="po-hcontainer e570 e570" xml:id="sectHybridApproachCartesianProduct" xreflabel="Hybrid Approach: Cartesian Product"><title class="po-block e571 e571"><textual class="po-textual">Hybrid Approach: Cartesian Product</textual></title><para class="po-block e572 e572"><textual class="po-textual">There also exist an </textual><emphasis class="po-inline e573 e573"><textual class="po-textual">hybrid</textual></emphasis><textual class="po-textual"> approach to the problem, i.e., an approach neither fully dynamic, nor fully static. A solution taking such an approach is named </textual><emphasis class="po-inline e574 e574"><textual class="po-textual">Cartesian Product</textual></emphasis><textual class="po-textual"> (CP), and the XSD Working Group considered it for a period. As RTC, CP does not impose any limitation on the CTA usage.</textual></para><para class="po-block e575 e575"><textual class="po-textual">Adopting a hybrid approach, CP consists of two phases. The former is performed at schema compile time, the latter at validation time. During the static phase, the Type Tables of the input schema are rewritten. In particular, given a Type Table </textual><emphasis class="po-inline e576 e576"><textual class="po-textual">TT</textual><subscript class="po-atom e577 e577"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> within a type </textual><emphasis class="po-inline e578 e578"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> and the corresponding Type Table </textual><emphasis class="po-inline e579 e579"><textual class="po-textual">TT</textual><subscript class="po-atom e580 e580"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> within </textual><emphasis class="po-inline e581 e581"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">'s base type, the static phase substitutes </textual><emphasis class="po-inline e582 e582"><textual class="po-textual">TT</textual><subscript class="po-atom e583 e583"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> with the Type Table resulting from the </textual><emphasis class="po-inline e584 e584"><textual class="po-textual">Cartesian product</textual></emphasis><textual class="po-textual"> between </textual><emphasis class="po-inline e585 e585"><textual class="po-textual">TT</textual><subscript class="po-atom e586 e586"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e587 e587"><textual class="po-textual">TT</textual><subscript class="po-atom e588 e588"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e589 e589"><textual class="po-textual">The Cartesian product between </textual><emphasis class="po-inline e590 e590"><textual class="po-textual">TT</textual><subscript class="po-atom e591 e591"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e592 e592"><textual class="po-textual">TT</textual><subscript class="po-atom e593 e593"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> is a Type Table denoted by </textual><emphasis class="po-inline e594 e594"><textual class="po-textual">TT</textual><subscript class="po-atom e595 e595"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> Ã </textual><emphasis class="po-inline e596 e596"><textual class="po-textual">TT</textual><subscript class="po-atom e597 e597"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> whose size is the product of the sizes of </textual><emphasis class="po-inline e598 e598"><textual class="po-textual">TT</textual><subscript class="po-atom e599 e599"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e600 e600"><textual class="po-textual">TT</textual><subscript class="po-atom e601 e601"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">. For each pair of alternatives &lt;&lt;</textual><emphasis class="po-inline e602 e602"><textual class="po-textual">r</textual><subscript class="po-atom e603 e603"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e604 e604"><textual class="po-textual">R</textual><subscript class="po-atom e605 e605"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">&gt;, &lt;</textual><emphasis class="po-inline e606 e606"><textual class="po-textual">b</textual><subscript class="po-atom e607 e607"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e608 e608"><textual class="po-textual">B</textual><subscript class="po-atom e609 e609"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">&gt;&gt; (where the first item is the </textual><emphasis class="po-inline e610 e610"><textual class="po-textual">i</textual></emphasis><textual class="po-textual">-th alternative of </textual><emphasis class="po-inline e611 e611"><textual class="po-textual">TT</textual><subscript class="po-atom e612 e612"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual">, and the second item is the </textual><emphasis class="po-inline e613 e613"><textual class="po-textual">j</textual></emphasis><textual class="po-textual">-th alternative of </textual><emphasis class="po-inline e614 e614"><textual class="po-textual">TT</textual><subscript class="po-atom e615 e615"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">), </textual><emphasis class="po-inline e616 e616"><textual class="po-textual">TT</textual><subscript class="po-atom e617 e617"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> Ã </textual><emphasis class="po-inline e618 e618"><textual class="po-textual">TT</textual><subscript class="po-atom e619 e619"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> has an alternative whose condition is the conjunction of </textual><emphasis class="po-inline e620 e620"><textual class="po-textual">r</textual><subscript class="po-atom e621 e621"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e622 e622"><textual class="po-textual">b</textual><subscript class="po-atom e623 e623"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">, and whose type is:</textual></para><itemizedlist class="po-table e624 e624"><listitem class="po-container e625 e625"><para class="po-block e626 e626"><emphasis class="po-inline e627 e627"><textual class="po-textual">R</textual><subscript class="po-atom e628 e628"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, if </textual><emphasis class="po-inline e629 e629"><textual class="po-textual">R</textual><subscript class="po-atom e630 e630"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is a valid restriction of </textual><emphasis class="po-inline e631 e631"><textual class="po-textual">B</textual><subscript class="po-atom e632 e632"><textual class="po-textual">j</textual></subscript></emphasis></para></listitem><listitem class="po-container e633 e633"><para class="po-block e634 e634"><emphasis class="po-inline e635 e635"><textual class="po-textual">error</textual></emphasis><textual class="po-textual">, otherwise.</textual></para></listitem></itemizedlist><para class="po-block e636 e636"><textual class="po-textual">At run-time, given a type </textual><emphasis class="po-inline e637 e637"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> and an element </textual><emphasis class="po-inline e638 e638"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, in order to know whether </textual><emphasis class="po-inline e639 e639"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e640 e640"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> satisfy CTSR, it suffices to evaluate the (rewritten) context-determined Type Table of </textual><emphasis class="po-inline e641 e641"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e642 e642"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">. And thus there is no need to walk on the derivation chain.</textual></para><para class="po-block e643 e643"><textual class="po-textual">However, given a derivation chain </textual><emphasis class="po-inline e644 e644"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e645 e645"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e646 e646"><textual class="po-textual">T</textual><subscript class="po-atom e647 e647"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, and an element </textual><emphasis class="po-inline e648 e648"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, let </textual><emphasis class="po-inline e649 e649"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e650 e650"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e651 e651"><textual class="po-textual">TT</textual><subscript class="po-atom e652 e652"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> be the sequence of context-determined Type Tables before the static phase rewrite them. The static phase rewrites those Type Tables in </textual><emphasis class="po-inline e653 e653"><textual class="po-textual">TT'</textual></emphasis><subscript class="po-atom e654 e654"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e655 e655"><textual class="po-textual">TT'</textual><subscript class="po-atom e656 e656"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, where:</textual></para><itemizedlist class="po-table e657 e657"><listitem class="po-container e658 e658"><para class="po-block e659 e659"><emphasis class="po-inline e660 e660"><textual class="po-textual">TT'</textual></emphasis><subscript class="po-atom e661 e661"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> is </textual><emphasis class="po-inline e662 e662"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e663 e663"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, and</textual></para></listitem><listitem class="po-container e664 e664"><para class="po-block e665 e665"><emphasis class="po-inline e666 e666"><textual class="po-textual">TT'</textual><subscript class="po-atom e667 e667"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e668 e668"><textual class="po-textual">TT</textual><subscript class="po-atom e669 e669"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> Ã </textual><emphasis class="po-inline e670 e670"><textual class="po-textual">TT'</textual><subscript class="po-atom e671 e671"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e672 e672"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">, for every 1 &lt; </textual><emphasis class="po-inline e673 e673"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> &lt;= </textual><emphasis class="po-inline e674 e674"><textual class="po-textual">k</textual></emphasis></para></listitem></itemizedlist><para class="po-block e675 e675"><textual class="po-textual">The condition of each alternative of </textual><emphasis class="po-inline e676 e676"><textual class="po-textual">TT'</textual><subscript class="po-atom e677 e677"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> is the conjunction of </textual><emphasis class="po-inline e678 e678"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> XPath predicates. Moreover, the </textual><emphasis class="po-inline e679 e679"><textual class="po-textual">TT'</textual><subscript class="po-atom e680 e680"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> size is </textual><emphasis class="po-inline e681 e681"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e682 e682"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> â ... â </textual><emphasis class="po-inline e683 e683"><textual class="po-textual">d</textual><subscript class="po-atom e684 e684"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e685 e685"><textual class="po-textual">d</textual><subscript class="po-atom e686 e686"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is the </textual><emphasis class="po-inline e687 e687"><textual class="po-textual">TT</textual><subscript class="po-atom e688 e688"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> size. Fixing each </textual><emphasis class="po-inline e689 e689"><textual class="po-textual">d</textual><subscript class="po-atom e690 e690"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> to a constant </textual><emphasis class="po-inline e691 e691"><textual class="po-textual">d</textual></emphasis><textual class="po-textual">, that product is </textual><emphasis class="po-inline e692 e692"><textual class="po-textual">d</textual><superscript class="po-atom e693 e693"><textual class="po-textual">k</textual></superscript></emphasis><textual class="po-textual">. Such an observation makes clear that the CP static phase might be too expensive.</textual></para></section></section><section class="po-hcontainer e694 e694" xml:id="sectOurProposal" xreflabel="Optimized Cartesian Product"><title class="po-block e695 e695"><textual class="po-textual">Optimized Cartesian Product</textual></title><para class="po-block e696 e696"><textual class="po-textual">In this section we present our solution to the problem of the derivation by restriction in presence of conditional declarations. We call it </textual><emphasis class="po-inline e697 e697"><textual class="po-textual">Optimized Cartesian Product</textual></emphasis><textual class="po-textual"> (OCP). From the expressivity point of view, our proposal is meant to be fully equivalent to Runt-Time Check and Cartesian Product. While being inspired by CP (and hence its name), it can also be seen as an RTC optimization.</textual></para><section class="po-hcontainer e698 e698" xml:id="sectGeneralIdea" xreflabel="General Idea"><title class="po-block e699 e699"><textual class="po-textual">General idea</textual></title><para class="po-block e700 e700"><textual class="po-textual">Our idea is to perform a static analysis on Type Tables, anticipating at compile time those cases in which a CTSR violation occurs. Such an analysis is meant to avoid at run-time the evaluation of those XPath predicates which do not affect the CTSR checking result.</textual></para><para class="po-block e701 e701"><textual class="po-textual">For instance, consider the schema shown in Figure â</textual><xref class="po-milestone e702 e702" linkend="figCTARestrictionUseCase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. As </textual><emphasis class="po-inline e703 e703"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> is not a valid restriction of any type, it is clear that whenever at run-time a </textual><code class="po-atom e704 e704"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> element does not satisfy the </textual><code class="po-atom e705 e705"><textual class="po-textual">@kind='string'</textual></code><textual class="po-textual"> predicate within the </textual><emphasis class="po-inline e706 e706"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> context (and hence is assigned type </textual><emphasis class="po-inline e707 e707"><textual class="po-textual">error</textual></emphasis><textual class="po-textual">), a CTSR violation occurs </textual><emphasis class="po-inline e708 e708"><textual class="po-textual">regardless</textual></emphasis><textual class="po-textual"> of the actual type that would be assigned within the </textual><emphasis class="po-inline e709 e709"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> context.</textual></para><para class="po-block e710 e710"><textual class="po-textual">So our approach is to perform a static analysis in order to tell the run-time phase something like: if within the context of type </textual><emphasis class="po-inline e711 e711"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> the predicate </textual><emphasis class="po-inline e712 e712"><textual class="po-textual">a</textual></emphasis><textual class="po-textual"> is satisfied, do not evaluate any of the predicates </textual><emphasis class="po-inline e713 e713"><textual class="po-textual">b</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e714 e714"><textual class="po-textual">c</textual></emphasis><textual class="po-textual">, or </textual><emphasis class="po-inline e715 e715"><textual class="po-textual">d</textual></emphasis><textual class="po-textual"> within </textual><emphasis class="po-inline e716 e716"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">'s base type, because such an evaluation will not affect the CTSR checking result.</textual></para><para class="po-block e717 e717"><textual class="po-textual">Note that our approach does not consider the actual XPath predicate semantics during the static analysis. As we already observed, it would be too difficult. Moreover, note that, as seen for Cartesian Product, our approach is neither completely static, nor completely dynamic, i.e., it is a </textual><emphasis class="po-inline e718 e718"><textual class="po-textual">hybrid</textual></emphasis><textual class="po-textual"> approach.</textual></para><para class="po-block e719 e719"><textual class="po-textual">Before discussing in details our technique, it is worth considering some major problems our hybrid approach has to face</textual></para><variablelist class="po-table e720 e720"><varlistentry class="po-record e721 e721"><term class="po-block e722 e722"><emphasis class="po-inline e723 e723"><textual class="po-textual">The corresponding Type Table problem</textual></emphasis></term><listitem class="po-container e724 e724"><para class="po-block e725 e725"><textual class="po-textual">Given a type </textual><emphasis class="po-inline e726 e726"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> and an element declaration </textual><emphasis class="po-inline e727 e727"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">, our general idea is to perform a static analysis of the cases in which </textual><emphasis class="po-inline e728 e728"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> and a generic element matching </textual><emphasis class="po-inline e729 e729"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> violate CTSR. Thus, the context-determined Type Table of that generic element in the base type of </textual><emphasis class="po-inline e730 e730"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> have to be statically decided. Put in a bit more formal way, let </textual><emphasis class="po-inline e731 e731"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> be </textual><emphasis class="po-inline e732 e732"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base type. The static analysis has to answer the following question: which is the Type Table </textual><emphasis class="po-inline e733 e733"><textual class="po-textual">TT'</textual></emphasis><textual class="po-textual"> determined by </textual><emphasis class="po-inline e734 e734"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> for an element matching </textual><emphasis class="po-inline e735 e735"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">?</textual></para></listitem></varlistentry><varlistentry class="po-record e736 e736"><term class="po-block e737 e737"><emphasis class="po-inline e738 e738"><textual class="po-textual">The potential case enumeration problem</textual></emphasis></term><listitem class="po-container e739 e739"><para class="po-block e740 e740"><textual class="po-textual">Assume for the moment the previous problem can be solved. Thus consider a derivation chain </textual><emphasis class="po-inline e741 e741"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e742 e742"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e743 e743"><textual class="po-textual">T</textual></emphasis><emphasis class="po-inline e744 e744"><subscript class="po-atom e745 e745"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, and the sequence of Type Tables </textual><emphasis class="po-inline e746 e746"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e747 e747"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e748 e748"><textual class="po-textual">TT</textual><subscript class="po-atom e749 e749"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> such that each </textual><emphasis class="po-inline e750 e750"><textual class="po-textual">TT</textual><subscript class="po-atom e751 e751"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is the Type Table determined by </textual><emphasis class="po-inline e752 e752"><textual class="po-textual">T</textual><subscript class="po-atom e753 e753"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> for a given element. If each </textual><emphasis class="po-inline e754 e754"><textual class="po-textual">TT</textual><subscript class="po-atom e755 e755"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> has size </textual><emphasis class="po-inline e756 e756"><textual class="po-textual">d</textual><subscript class="po-atom e757 e757"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, the number of cases that might potentially be verified at run-time is given by </textual><emphasis class="po-inline e758 e758"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e759 e759"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> â ... â </textual><emphasis class="po-inline e760 e760"><textual class="po-textual">d</textual><subscript class="po-atom e761 e761"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">. If the Type Tables average size is </textual><emphasis class="po-inline e762 e762"><textual class="po-textual">d</textual></emphasis><textual class="po-textual">, that product is similar to </textual><emphasis class="po-inline e763 e763"><textual class="po-textual">d</textual><superscript class="po-atom e764 e764"><textual class="po-textual">k</textual></superscript></emphasis><textual class="po-textual">. Enumerating all such potential cases, might lead to an unacceptable static analysis cost. It precisely is the problem of the Cartesian Product technique.</textual></para></listitem></varlistentry></variablelist><para class="po-block e765 e765"><textual class="po-textual">For what concerns the first problem, both the </textual><emphasis class="po-inline e766 e766"><textual class="po-textual">Element Declarations Consistent</textual></emphasis><textual class="po-textual"> (EDC) constraint and the context-determined Type Table definition provided by the XSD current draft help us. Indeed, by EDC it is possible to define for each type </textual><emphasis class="po-inline e767 e767"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> a partial function </textual><emphasis class="po-inline e768 e768"><textual class="po-textual">tt-map</textual><superscript class="po-atom e769 e769"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> : QName  â Type Table, such that for each element name </textual><emphasis class="po-inline e770 e770"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e771 e771"><textual class="po-textual">tt-map</textual><superscript class="po-atom e772 e772"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e773 e773"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">) returns, if any, the Type Table of an element declaration named </textual><emphasis class="po-inline e774 e774"><textual class="po-textual">e</textual></emphasis><textual class="po-textual"> within </textual><emphasis class="po-inline e775 e775"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e776 e776"><textual class="po-textual">Given: </textual></para><orderedlist class="po-table e777 e777"><listitem class="po-container e778 e778"><para class="po-block e779 e779"><emphasis class="po-inline e780 e780"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, a type;</textual></para></listitem><listitem class="po-container e781 e781"><para class="po-block e782 e782"><emphasis class="po-inline e783 e783"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, the base type of </textual><emphasis class="po-inline e784 e784"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e785 e785"><para class="po-block e786 e786"><emphasis class="po-inline e787 e787"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">, an element declaration within </textual><emphasis class="po-inline e788 e788"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e789 e789"><para class="po-block e790 e790"><emphasis class="po-inline e791 e791"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">, the name of </textual><emphasis class="po-inline e792 e792"><textual class="po-textual">D</textual></emphasis></para></listitem></orderedlist><para class="po-block e793 e793"><textual class="po-textual">the context-determined Type Table within </textual><emphasis class="po-inline e794 e794"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> for any element matching </textual><emphasis class="po-inline e795 e795"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">, cannot be directly calculated as </textual><emphasis class="po-inline e796 e796"><textual class="po-textual">tt-map</textual><superscript class="po-atom e797 e797"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e798 e798"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">), as we have to deal with wildcards (and some other minor details). However, wildcards do not pose any particular problem, as EDC states that if a type contains both an element declaration </textual><emphasis class="po-inline e799 e799"><textual class="po-textual">D</textual></emphasis><textual class="po-textual"> and a wildcard </textual><emphasis class="po-inline e800 e800"><textual class="po-textual">W</textual></emphasis><textual class="po-textual">, then </textual><emphasis class="po-inline e801 e801"><textual class="po-textual">D</textual></emphasis><textual class="po-textual">'s Type Table and the Type Table of any top-level declaration matching </textual><emphasis class="po-inline e802 e802"><textual class="po-textual">W</textual></emphasis><textual class="po-textual"> must be the same. Moreover, the context-determined Type Table definition states that if, within a type </textual><emphasis class="po-inline e803 e803"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, an element </textual><emphasis class="po-inline e804 e804"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> does not match any declaration, but matches a wildcard </textual><emphasis class="po-inline e805 e805"><textual class="po-textual">W</textual></emphasis><textual class="po-textual">, then the context-determined Type Table within </textual><emphasis class="po-inline e806 e806"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> for </textual><emphasis class="po-inline e807 e807"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is the Type Table of the top-level declaration matching </textual><emphasis class="po-inline e808 e808"><textual class="po-textual">W</textual></emphasis><textual class="po-textual">, if any. Here, the </textual><emphasis class="po-inline e809 e809"><textual class="po-textual">match</textual></emphasis><textual class="po-textual"> predicate is always defined in terms of string matching, and never in terms of schema component semantics.</textual></para><para class="po-block e810 e810"><textual class="po-textual">Thus, it is easy to extend our </textual><emphasis class="po-inline e811 e811"><textual class="po-textual">tt-map</textual><superscript class="po-atom e812 e812"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> function definition so that for any name </textual><emphasis class="po-inline e813 e813"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e814 e814"><textual class="po-textual">tt-map</textual><superscript class="po-atom e815 e815"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e816 e816"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">) returns the  context-determined Type Table within </textual><emphasis class="po-inline e817 e817"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> for any element </textual><emphasis class="po-inline e818 e818"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> named </textual><emphasis class="po-inline e819 e819"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">, exactly as defined by the XSD current draft.</textual></para><para class="po-block e820 e820"><textual class="po-textual">Note also that although the set of qualified names is infinite, </textual><emphasis class="po-inline e821 e821"><textual class="po-textual">tt-map</textual><superscript class="po-atom e822 e822"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> is defined only for those qualified names matching some element declaration of the schema. As the number of element declarations within a schema is finite, also the </textual><emphasis class="po-inline e823 e823"><textual class="po-textual">tt-map</textual><superscript class="po-atom e824 e824"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> domain is finite. The possibility to statically define the function </textual><emphasis class="po-inline e825 e825"><textual class="po-textual">tt-map</textual><superscript class="po-atom e826 e826"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> solves the </textual><emphasis class="po-inline e827 e827"><textual class="po-textual">corresponding Type Table problem</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e828 e828"><textual class="po-textual">For what concerns the </textual><emphasis class="po-inline e829 e829"><textual class="po-textual">potential case enumeration problem</textual></emphasis><textual class="po-textual">, our idea is the following. Given a sequence of Type Tables </textual><emphasis class="po-inline e830 e830"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e831 e831"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e832 e832"><textual class="po-textual">TT</textual><subscript class="po-atom e833 e833"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> as previously described in the problem definition, we do not consider all the </textual><emphasis class="po-inline e834 e834"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> Type Tables together, but rather we analyze each pair of Type Tables </textual><emphasis class="po-inline e835 e835"><textual class="po-textual">TT</textual><subscript class="po-atom e836 e836"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e837 e837"><textual class="po-textual">TT</textual><subscript class="po-atom e838 e838"><textual class="po-textual">i-1</textual></subscript></emphasis><textual class="po-textual"> separately. In particular, for each such pair of Type Tables, we identify the cases that would cause a CTSR violation for that single derivation step. The results of such analysis are made available at run-time as annotations on </textual><emphasis class="po-inline e839 e839"><textual class="po-textual">TT</textual><subscript class="po-atom e840 e840"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">. As we will see, this guarantees an acceptable cost for the static phase. Obviously, for any element </textual><emphasis class="po-inline e841 e841"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> whose context-determined Type Table is </textual><emphasis class="po-inline e842 e842"><textual class="po-textual">TT</textual><subscript class="po-atom e843 e843"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, we have information about CTSR for a single derivation step only, and not for the whole derivation chain. If that information is not sufficient to decide whether CTSR is satisfied or not, it is necessary to walk on the derivation chain in order the access the annotations for </textual><emphasis class="po-inline e844 e844"><textual class="po-textual">TT</textual><subscript class="po-atom e845 e845"><textual class="po-textual">i-1</textual></subscript><textual class="po-textual">.</textual></emphasis></para></section><section class="po-hcontainer e846 e846" xml:id="sectOCPStaticPhase" xreflabel="OCP Static Phase"><title class="po-block e847 e847"><textual class="po-textual">OCP Static Phase</textual></title><para class="po-block e848 e848"><textual class="po-textual">The static phase consists of two steps. The first step just builds for any type </textual><emphasis class="po-inline e849 e849"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> of the schema type hierarchy the </textual><emphasis class="po-inline e850 e850"><textual class="po-textual">tt-map</textual><superscript class="po-atom e851 e851"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> mapping. For any </textual><emphasis class="po-inline e852 e852"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> of the schema type hierarchy, the second step annotates the Type Tables within the </textual><emphasis class="po-inline e853 e853"><textual class="po-textual">tt-map</textual><superscript class="po-atom e854 e854"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> codomain with </textual><emphasis class="po-inline e855 e855"><textual class="po-textual">error conditions</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e856 e856"><textual class="po-textual">In particular, for each type </textual><emphasis class="po-inline e857 e857"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> and for each name </textual><emphasis class="po-inline e858 e858"><textual class="po-textual">e</textual></emphasis><textual class="po-textual"> within the </textual><emphasis class="po-inline e859 e859"><textual class="po-textual">tt-map</textual><superscript class="po-atom e860 e860"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual"> domain, the alternatives of the Type Table </textual><emphasis class="po-inline e861 e861"><textual class="po-textual">tt-map</textual><superscript class="po-atom e862 e862"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual">(</textual><emphasis class="po-inline e863 e863"><textual class="po-textual">e</textual></emphasis><textual class="po-textual">) are annotated with an error condition. Such a condition specifies the cases in which CTSR is broken w.r.t. the context-determined Type Table within </textual><emphasis class="po-inline e864 e864"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base.</textual><footnote class="po-popup e865 e865"><para class="po-block e866 e866"><textual class="po-textual">From here on, given a type </textual><emphasis class="po-inline e867 e867"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, an element </textual><emphasis class="po-inline e868 e868"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and the context-determined Type Table </textual><emphasis class="po-inline e869 e869"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> of </textual><emphasis class="po-inline e870 e870"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e871 e871"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, by â</textual><emphasis class="po-inline e872 e872"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual">'s base Type Tableâ we mean the context-determined Type Table of </textual><emphasis class="po-inline e873 e873"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e874 e874"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base.</textual></para></footnote><textual class="po-textual"> Each error condition simply is a boolean expression built on the base Type Table predicates.</textual></para><figure class="po-container e875 e875" floatstyle="1" xml:id="figStaticPhaseAlgo" xreflabel="OCP Static Phase Algorithm"><title class="po-block e876 e876"><textual class="po-textual">OCP Static Phase Algorithm</textual></title><programlisting class="po-block e877 e877" xml:space="preserve"><textual class="po-textual">
</textual><emphasis class="po-inline e878 e878"><textual class="po-textual">// visits a type of the schema type hierarchy</textual></emphasis><textual class="po-textual">
void visit-type(Type T) {

  </textual><emphasis class="po-inline e879 e879"><textual class="po-textual">// annotate each context-determined Type Table within the current type</textual></emphasis><textual class="po-textual">
  for each QName name in tt-map</textual><superscript class="po-atom e880 e880"><textual class="po-textual">T</textual></superscript><textual class="po-textual">.domain {
    annotate-type-table(tt-map</textual><superscript class="po-atom e881 e881"><textual class="po-textual">T</textual></superscript><textual class="po-textual">(name));
  }

  </textual><emphasis class="po-inline e882 e882"><textual class="po-textual">// recursive call</textual></emphasis><textual class="po-textual">
  for each Type D derived from T do {
    visit-type(D);
  }
}

</textual><emphasis class="po-inline e883 e883"><textual class="po-textual">// annotates a context-determined Type Table</textual></emphasis><textual class="po-textual">
void annotate-type-table(TypeTable ttr) {
  for each int i s.t. 1 &lt;= i &lt;= ttr.size {
    </textual><emphasis class="po-inline e884 e884"><textual class="po-textual">// build the error condition for the current alternative</textual></emphasis><textual class="po-textual">
    Expression expr = build-error-condition(ttr, i);
    </textual><emphasis class="po-inline e885 e885"><textual class="po-textual">// simplify the error condition</textual></emphasis><textual class="po-textual">
    expr = simplify(expr);
    </textual><emphasis class="po-inline e886 e886"><textual class="po-textual">// annotate the current alternative with the simplified condition</textual></emphasis><textual class="po-textual">
    ttr.get-alternative(i).error-condition = expr;
  }
}

</textual><emphasis class="po-inline e887 e887"><textual class="po-textual">// builds an error condition for a Type Table alternative</textual></emphasis><textual class="po-textual">
Expression build-error-condition(TypeTable ttr, int i) {

  </textual><emphasis class="po-inline e888 e888"><textual class="po-textual">// get the base Type Table</textual></emphasis><textual class="po-textual">
  TypeTable ttb = ttr.base;
  if (ttb is absent) {
    return Expression.FALSE; </textual><emphasis class="po-inline e889 e889"><textual class="po-textual">// In such a case no CTSR violation may occur</textual></emphasis><textual class="po-textual">
  } else {
    return build-error-condition_aux(ttr, ttb, i, Expression.FALSE, 1, STATE_OR);
  }
}

Expression build-error-condition_aux(TypeTable ttr, TypeTable ttb, int i, Expression left, int j, short state) {
  if (j &gt; ttb.size) {
    return left;
  } else {

    Expression a;
    if (j == ttb.size) {
      a = Expression.TRUE;
    } else {
      a = ttb.get-alternative(j).getTest();
    }

    Expression right;

    Type r = ttr.get-alternative(i).getType();
    Type b = ttb.get-alternative(j).getType();

    if (r validly restricts b) {
      NotExpression negatedLiteral = new NotExpression(a);
      right = build-error-condition_aux(ttr, ttb, i, negatedLiteral, j + 1, STATE_AND);
    } else {
      right = build-error-condition_aux(ttr, ttb, i, a, j + 1, STATE_OR);
    }

    if (state == STATE_OR) {
      return new OrExpression(left, right);
    } else { </textual><emphasis class="po-inline e890 e890"><textual class="po-textual">state == STATE_AND</textual></emphasis><textual class="po-textual">
      return new AndExpression(left, right);
    }
  }
}
</textual></programlisting><caption class="po-container e891 e891"><para class="po-block e892 e892"><textual class="po-textual">Pseudo-code for the static analysis of OCP.</textual></para></caption></figure><para class="po-block e893 e893"><textual class="po-textual">The procedure described above is shown in Java-like pseudo-code in Figure â</textual><xref class="po-milestone e894 e894" linkend="figStaticPhaseAlgo"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. The </textual><code class="po-atom e895 e895"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> function is not shown: its purpose is to rewrite the error condition in a simpler form. In particular, if by </textual><emphasis class="po-inline e896 e896"><textual class="po-textual">atom</textual></emphasis><textual class="po-textual"> we mean a Type Table XPath predicate, the </textual><code class="po-atom e897 e897"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> purpose is to minimize the number of atoms within the input expression. </textual><code class="po-atom e898 e898"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> can be implemented visiting the structure of the expression produced by </textual><code class="po-atom e899 e899"><textual class="po-textual">build-error-condition</textual></code><textual class="po-textual">, and applying the lazy boolean evaluation rules shown in the following table:</textual><footnote class="po-popup e900 e900"><para class="po-block e901 e901"><textual class="po-textual">Symmetric rules for binary operators are not shown.</textual></para></footnote></para><informaltable class="po-container e902 e902" xml:id="tabRewritingRules" xreflabel="Rewriting Rules"><thead class="po-container e903 e903"><tr class="po-table e904 e904"><th class="po-field e905 e905"><textual class="po-textual">Input expression</textual></th><th class="po-field e906 e906"><textual class="po-textual">Rewritten expression</textual></th></tr></thead><tr class="po-table e907 e907"><th class="po-field e908 e908" colspan="2"><textual class="po-textual">or-rules</textual></th></tr><tr class="po-table e909 e909"><td class="po-block e910 e910"><code class="po-atom e911 e911"><textual class="po-textual">FALSE</textual></code><textual class="po-textual"> or </textual><emphasis class="po-inline e912 e912"><textual class="po-textual">expr</textual></emphasis></td><td class="po-block e913 e913"><emphasis class="po-inline e914 e914"><textual class="po-textual">expr</textual></emphasis></td></tr><tr class="po-table e915 e915"><td class="po-block e916 e916"><code class="po-atom e917 e917"><textual class="po-textual">TRUE</textual></code><textual class="po-textual"> or </textual><emphasis class="po-inline e918 e918"><textual class="po-textual">expr</textual></emphasis></td><td class="po-block e919 e919"><code class="po-atom e920 e920"><textual class="po-textual">TRUE</textual></code></td></tr><tr class="po-table e921 e921"><th class="po-field e922 e922" colspan="2"><textual class="po-textual">and-rules</textual></th></tr><tr class="po-table e923 e923"><td class="po-block e924 e924"><code class="po-atom e925 e925"><textual class="po-textual">FALSE</textual></code><textual class="po-textual"> and </textual><emphasis class="po-inline e926 e926"><textual class="po-textual">expr</textual></emphasis></td><td class="po-block e927 e927"><code class="po-atom e928 e928"><textual class="po-textual">FALSE</textual></code></td></tr><tr class="po-table e929 e929"><td class="po-block e930 e930"><code class="po-atom e931 e931"><textual class="po-textual">TRUE</textual></code><textual class="po-textual"> and </textual><emphasis class="po-inline e932 e932"><textual class="po-textual">expr</textual></emphasis></td><td class="po-block e933 e933"><emphasis class="po-inline e934 e934"><textual class="po-textual">expr</textual></emphasis></td></tr><tr class="po-table e935 e935"><th class="po-field e936 e936" colspan="2"><textual class="po-textual">not-rules</textual></th></tr><tr class="po-table e937 e937"><td class="po-block e938 e938"><textual class="po-textual">not(</textual><code class="po-atom e939 e939"><textual class="po-textual">TRUE</textual></code><textual class="po-textual">)</textual></td><td class="po-block e940 e940"><code class="po-atom e941 e941"><textual class="po-textual">FALSE</textual></code></td></tr><tr class="po-table e942 e942"><td class="po-block e943 e943"><textual class="po-textual">not(</textual><code class="po-atom e944 e944"><textual class="po-textual">FALSE</textual></code><textual class="po-textual">)</textual></td><td class="po-block e945 e945"><code class="po-atom e946 e946"><textual class="po-textual">TRUE</textual></code></td></tr></informaltable><para class="po-block e947 e947"><textual class="po-textual">The evaluation of the algorithm of Figure â</textual><xref class="po-milestone e948 e948" linkend="figStaticPhaseAlgo"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â on the schema shown in Figure â</textual><xref class="po-milestone e949 e949" linkend="figCTARestrictionUseCase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, annotates the alternatives of the Type Table within </textual><emphasis class="po-inline e950 e950"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> with the following error conditions:</textual></para><itemizedlist class="po-table e951 e951"><listitem class="po-container e952 e952"><para class="po-block e953 e953"><code class="po-atom e954 e954"><textual class="po-textual">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or @kind='XML')))</textual></code></para></listitem><listitem class="po-container e955 e955"><para class="po-block e956 e956"><code class="po-atom e957 e957"><textual class="po-textual">TRUE</textual></code></para></listitem></itemizedlist><para class="po-block e958 e958"><textual class="po-textual">The error condition associated to the first alternative states that an element </textual><emphasis class="po-inline e959 e959"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> of the instance document and </textual><emphasis class="po-inline e960 e960"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> violates CTSR whenever </textual><emphasis class="po-inline e961 e961"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> is assigned one of the types </textual><emphasis class="po-inline e962 e962"><textual class="po-textual">messageTypeBase64</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e963 e963"><textual class="po-textual">messageTypeXML</textual></emphasis><textual class="po-textual"> in the context of </textual><emphasis class="po-inline e964 e964"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> (we are in the hypothesis that </textual><emphasis class="po-inline e965 e965"><textual class="po-textual">messageTypeString</textual></emphasis><textual class="po-textual"> is not a valid restriction of any of those two types). The error condition associated to the second alternative states that regardless of the type assigned in the context of </textual><emphasis class="po-inline e966 e966"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">, a CTSR violation occurs. This is because </textual><emphasis class="po-inline e967 e967"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> is not a valid restriction of any of the types of the Type Table within </textual><emphasis class="po-inline e968 e968"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e969 e969"><textual class="po-textual">On the other hand, the algorithm annotates each alternative of the Type Table within </textual><emphasis class="po-inline e970 e970"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> with the error condition </textual><code class="po-atom e971 e971"><textual class="po-textual">FALSE</textual></code><textual class="po-textual">. It means that for any element </textual><emphasis class="po-inline e972 e972"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e973 e973"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e974 e974"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> do not violate CTSR. This is because </textual><emphasis class="po-inline e975 e975"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">'s base is </textual><emphasis class="po-inline e976 e976"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual"> and obviously the types within the Type Table within </textual><emphasis class="po-inline e977 e977"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> are valid restrictions of </textual><emphasis class="po-inline e978 e978"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e979 e979" xml:id="sectOCPRunTimPhase" xreflabel="OCP Run-Time Phase"><title class="po-block e980 e980"><textual class="po-textual">OCP Run-Time Phase</textual></title><para class="po-block e981 e981"><textual class="po-textual">At validation time, the annotations on context-determined Type Tables are read in order to check CTSR. In particular, let </textual><emphasis class="po-inline e982 e982"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> be an element of the instance document, </textual><emphasis class="po-inline e983 e983"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> be the type of </textual><emphasis class="po-inline e984 e984"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">'s  parent, and </textual><emphasis class="po-inline e985 e985"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> be the context-determined Type Table of </textual><emphasis class="po-inline e986 e986"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> in </textual><emphasis class="po-inline e987 e987"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">. Firstly, </textual><emphasis class="po-inline e988 e988"><textual class="po-textual">TT</textual></emphasis><textual class="po-textual"> has to be evaluated. Then, the error condition associated to the satisfied alternative is also evaluated. If the error condition evaluates to true, then it is possible to conclude that CTSR is not satisfied. Otherwise, the same procedure has to be recursively executed using </textual><emphasis class="po-inline e989 e989"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">'s base type. The recursive process stops either when a CTSR violation occurs, or </textual><emphasis class="po-inline e990 e990"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual"> is reached.</textual></para><figure class="po-container e991 e991" floatstyle="1" xml:id="figRunTimePhaseAlgo" xreflabel="OCP Run-time Phase Algorithm"><title class="po-block e992 e992"><textual class="po-textual">OCP Run-time Phase Algorithm</textual></title><programlisting class="po-block e993 e993" xml:space="preserve"><textual class="po-textual">

void process-element(Element e) {

  </textual><emphasis class="po-inline e994 e994"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">

  </textual><emphasis class="po-inline e995 e995"><textual class="po-textual">// e's parent type</textual></emphasis><textual class="po-textual">
  Type T = current-type();

  </textual><emphasis class="po-inline e996 e996"><textual class="po-textual">// get the context determined Type Table for e</textual></emphasis><textual class="po-textual">
  TypeTable tt = tt-map</textual><superscript class="po-atom e997 e997"><textual class="po-textual">T</textual></superscript><textual class="po-textual">(e);

  </textual><emphasis class="po-inline e998 e998"><textual class="po-textual">// evaluate the type table </textual></emphasis><textual class="po-textual">
  int i = evaluate-type-table(e, tt);

  if (!check-CTSR(e, tt, i)) {
    report-schema-error("vr-cta-substitutable");
  }

  </textual><emphasis class="po-inline e999 e999"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">

}

boolean check-CTSR(Element e, TypeTable ttr, int i) {

  Alternative alt = ttr.get-alternative(i);
  Expression err-epxr = alt.error-condition;

  if (evaluate-error-condition(e, err-expr)) {
    return false;
  } else {
    TypeTable ttb = ttr.base;
    if (ttb is absent) {
      return true; // implicitly handles the xs:anyType case
    } else {
      int j = evaluate-type-table(e, ttb);

      </textual><emphasis class="po-inline e1000 e1000"><textual class="po-textual">// recursive call</textual></emphasis><textual class="po-textual">
      return check-CTSR(e, ttb, j);
    }
  }
}
</textual></programlisting><caption class="po-container e1001 e1001"><para class="po-block e1002 e1002"><textual class="po-textual">Algorithm for the run-time phase of OCP.</textual></para></caption></figure><para class="po-block e1003 e1003"><textual class="po-textual">The procedure described above is shown in Java-like pseudo-code in Figure â</textual><xref class="po-milestone e1004 e1004" linkend="figRunTimePhaseAlgo"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. In order to show how it works, let us consider following document:</textual></para><programlisting class="po-block e1005 e1005" xml:space="preserve"><textual class="po-textual">
&lt;messages xsi:type="R"&gt;
  &lt;message kind="string"&gt;
    </textual><emphasis class="po-inline e1006 e1006"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">
  &lt;/message&gt;
  &lt;message kind="binary"&gt;
    </textual><emphasis class="po-inline e1007 e1007"><textual class="po-textual">...</textual></emphasis><textual class="po-textual">
  &lt;/message&gt;
&lt;/messages&gt;
</textual></programlisting><para class="po-block e1008 e1008"><textual class="po-textual">and suppose we have to validate it against the schema depicted in Figure â</textual><xref class="po-milestone e1009 e1009" linkend="figCTARestrictionUseCase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â (the error conditions built during the static phase are described in Section â</textual><xref class="po-milestone e1010 e1010" linkend="sectOCPStaticPhase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â). When the first </textual><code class="po-atom e1011 e1011"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> element is processed, its context-determined Type Table is evaluated. It is then checked that it satisfies the first condition </textual><code class="po-atom e1012 e1012"><textual class="po-textual">@kind='string'</textual></code><textual class="po-textual">. As a consequence, it is assigned the first alternative. So the error condition associated with that alternative is evaluated. Such a condition is </textual><code class="po-atom e1013 e1013"><textual class="po-textual">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or @kind='XML')))</textual></code><textual class="po-textual">. Clearly, the error condition is not satisfied (</textual><code class="po-atom e1014 e1014"><textual class="po-textual">not(@kind='string')</textual></code><textual class="po-textual"> evaluates to false). Consequently, the Type Table within </textual><emphasis class="po-inline e1015 e1015"><textual class="po-textual">B</textual></emphasis><textual class="po-textual"> has to be evaluated. Again, the first alternative is chosen, and thus its error condition is evaluated. But such a condition is </textual><code class="po-atom e1016 e1016"><textual class="po-textual">FALSE</textual></code><textual class="po-textual">. And so it is possible conclude that the first </textual><code class="po-atom e1017 e1017"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> element and </textual><emphasis class="po-inline e1018 e1018"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> satisfy CTSR.</textual></para><para class="po-block e1019 e1019"><textual class="po-textual">For what concerns the second </textual><code class="po-atom e1020 e1020"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> element, we have that it does not satisfy the first alternative predicate, and so it is assigned the default alternative. The error condition associated to such alternative is </textual><code class="po-atom e1021 e1021"><textual class="po-textual">TRUE</textual></code><textual class="po-textual">. So we have that the second </textual><code class="po-atom e1022 e1022"><textual class="po-textual">&lt;message&gt;</textual></code><textual class="po-textual"> element and </textual><emphasis class="po-inline e1023 e1023"><textual class="po-textual">R</textual></emphasis><textual class="po-textual"> do not satisfy CTSR.</textual></para></section><section class="po-hcontainer e1024 e1024" xml:id="sectOCPCostAnalysis" xreflabel="OCP Cost Analysis"><title class="po-block e1025 e1025"><textual class="po-textual">OCP Cost Analysis</textual></title><para class="po-block e1026 e1026"><textual class="po-textual">In this subsection we provide a cost analysis for the static phase and a cost analysis for the run-time phase of OCP.</textual></para><section class="po-hcontainer e1027 e1027" xml:id="sectOCPStaticPhaseAnalysis" xreflabel="OCP Static Phase Analysis"><title class="po-block e1028 e1028"><textual class="po-textual">OCP Static Phase Analysis</textual></title><para class="po-block e1029 e1029"><textual class="po-textual">Here we are not interested in analyzing the cost of the static phase applied to the entire schema type hierarchy. Rather, we fix an element name and we consider a single path from the root to a generic leaf of the type hierarchy.</textual></para><para class="po-block e1030 e1030"><textual class="po-textual">Thus, let </textual><emphasis class="po-inline e1031 e1031"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e1032 e1032"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1033 e1033"><textual class="po-textual">T</textual><subscript class="po-atom e1034 e1034"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual"> be a derivation chain, and </textual><emphasis class="po-inline e1035 e1035"><textual class="po-textual">e</textual></emphasis><textual class="po-textual"> be our element name. We can now consider the sequence of Type Tables </textual><emphasis class="po-inline e1036 e1036"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e1037 e1037"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1038 e1038"><textual class="po-textual">TT</textual><subscript class="po-atom e1039 e1039"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e1040 e1040"><textual class="po-textual">TT</textual><subscript class="po-atom e1041 e1041"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is the context-determined Type Table for an element named </textual><emphasis class="po-inline e1042 e1042"><textual class="po-textual">e</textual></emphasis><textual class="po-textual"> within </textual><emphasis class="po-inline e1043 e1043"><textual class="po-textual">T</textual><subscript class="po-atom e1044 e1044"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">. The size of each </textual><emphasis class="po-inline e1045 e1045"><textual class="po-textual">TT</textual><subscript class="po-atom e1046 e1046"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is denoted by </textual><emphasis class="po-inline e1047 e1047"><textual class="po-textual">d</textual><subscript class="po-atom e1048 e1048"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1049 e1049"><textual class="po-textual">Given a 1 &lt; </textual><emphasis class="po-inline e1050 e1050"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> &lt;= </textual><emphasis class="po-inline e1051 e1051"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">, now we analyze the time needed to annotate </textual><emphasis class="po-inline e1052 e1052"><textual class="po-textual">TT</textual><subscript class="po-atom e1053 e1053"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1054 e1054"><textual class="po-textual">The function </textual><code class="po-atom e1055 e1055"><textual class="po-textual">build-error-condition</textual></code><textual class="po-textual"> iterates over the whole alternative sequence of </textual><emphasis class="po-inline e1056 e1056"><textual class="po-textual">TT</textual><subscript class="po-atom e1057 e1057"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1058 e1058"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">, and for each alterantive it computes a number of operations whose cost is constant. Thus the function cost is linear in the </textual><emphasis class="po-inline e1059 e1059"><textual class="po-textual">TT</textual><subscript class="po-atom e1060 e1060"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1061 e1061"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> size, i.e., </textual><emphasis class="po-inline e1062 e1062"><textual class="po-textual">d</textual><subscript class="po-atom e1063 e1063"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1064 e1064"><textual class="po-textual">-1</textual></subscript></para><para class="po-block e1065 e1065"><textual class="po-textual">The function </textual><code class="po-atom e1066 e1066"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> can be implemented visiting the structure of the expression returned by </textual><code class="po-atom e1067 e1067"><textual class="po-textual">build-error-condition</textual></code><textual class="po-textual">. The number of nodes of such an expression is linear in </textual><emphasis class="po-inline e1068 e1068"><textual class="po-textual">d</textual><subscript class="po-atom e1069 e1069"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1070 e1070"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. Thus, the </textual><code class="po-atom e1071 e1071"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> computational cost is linear in </textual><emphasis class="po-inline e1072 e1072"><textual class="po-textual">d</textual><subscript class="po-atom e1073 e1073"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1074 e1074"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> too.</textual></para><para class="po-block e1075 e1075"><textual class="po-textual">As both </textual><code class="po-atom e1076 e1076"><textual class="po-textual">simplify</textual></code><textual class="po-textual"> and </textual><code class="po-atom e1077 e1077"><textual class="po-textual">build-error-condition</textual></code><textual class="po-textual"> are called for each alternative of </textual><emphasis class="po-inline e1078 e1078"><textual class="po-textual">TT</textual><subscript class="po-atom e1079 e1079"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, the asymptotic computational cost for the function </textual><code class="po-atom e1080 e1080"><textual class="po-textual">annotate-type-table</textual></code><textual class="po-textual"> is </textual><emphasis class="po-inline e1081 e1081"><textual class="po-textual">d</textual><subscript class="po-atom e1082 e1082"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1083 e1083"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">â</textual><emphasis class="po-inline e1084 e1084"><textual class="po-textual">d</textual><subscript class="po-atom e1085 e1085"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1086 e1086"><textual class="po-textual">Thus, the asymptotic cost for building and simplifying the error conditions of the whole sequence of Type Tables, is given by:</textual></para><para class="po-block e1087 e1087"><emphasis class="po-inline e1088 e1088"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e1089 e1089"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> + </textual><emphasis class="po-inline e1090 e1090"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e1091 e1091"><textual class="po-textual">1</textual></subscript><textual class="po-textual">â</textual><emphasis class="po-inline e1092 e1092"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e1093 e1093"><textual class="po-textual">2</textual></subscript><textual class="po-textual"> + ... + </textual><emphasis class="po-inline e1094 e1094"><textual class="po-textual">d</textual><subscript class="po-atom e1095 e1095"><textual class="po-textual">n</textual></subscript></emphasis><subscript class="po-atom e1096 e1096"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">â</textual><emphasis class="po-inline e1097 e1097"><textual class="po-textual">d</textual><subscript class="po-atom e1098 e1098"><textual class="po-textual">n</textual></subscript></emphasis></para><para class="po-block e1099 e1099"><textual class="po-textual">We believe such a cost is perfectly acceptable at schema compile time.</textual></para></section><section class="po-hcontainer e1100 e1100" xml:id="sectOCPRunTimePhaseAnalysis" xreflabel="OCP Run-Time Phase Analysis"><title class="po-block e1101 e1101"><textual class="po-textual">OCP Run-Time Phase Analysis</textual></title><para class="po-block e1102 e1102"><textual class="po-textual">Here we provide a computational cost analysis of the run-time phase of OCP. As similarly done for RTC, we are interested in determining the number of XPath predicates that have to be evaluated for a generic element of the instance document.</textual></para><para class="po-block e1103 e1103"><textual class="po-textual">Let </textual><emphasis class="po-inline e1104 e1104"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> be an element of the instance document, and </textual><emphasis class="po-inline e1105 e1105"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> be the type assigned to </textual><emphasis class="po-inline e1106 e1106"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">'s parent. Consider the derivation chain </textual><emphasis class="po-inline e1107 e1107"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e1108 e1108"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1109 e1109"><textual class="po-textual">T</textual><subscript class="po-atom e1110 e1110"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e1111 e1111"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e1112 e1112"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> is </textual><emphasis class="po-inline e1113 e1113"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1114 e1114"><textual class="po-textual">T</textual><subscript class="po-atom e1115 e1115"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e1116 e1116"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">. Also consider the usual Type Table sequence </textual><emphasis class="po-inline e1117 e1117"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e1118 e1118"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1119 e1119"><textual class="po-textual">TT</textual><subscript class="po-atom e1120 e1120"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e1121 e1121"><textual class="po-textual">TT</textual><subscript class="po-atom e1122 e1122"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is the context-determined Type Table for </textual><emphasis class="po-inline e1123 e1123"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> within </textual><emphasis class="po-inline e1124 e1124"><textual class="po-textual">T</textual><subscript class="po-atom e1125 e1125"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1126 e1126"><textual class="po-textual">If </textual><emphasis class="po-inline e1127 e1127"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1128 e1128"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> satisfy CTSR, the entire Type Table sequence is processed. For any  1 &lt; </textual><emphasis class="po-inline e1129 e1129"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> &lt;= </textual><emphasis class="po-inline e1130 e1130"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1131 e1131"><textual class="po-textual">TT</textual><subscript class="po-atom e1132 e1132"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is evaluated to obtain the assigned alternative. The cost of such an operation is linear in </textual><emphasis class="po-inline e1133 e1133"><textual class="po-textual">d</textual><subscript class="po-atom e1134 e1134"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">. Once the assigned alternative has been determined, the algorithm evaluates the corresponding error condition. As already discussed, such a condition is a boolean expression over the XPath predicates of </textual><emphasis class="po-inline e1135 e1135"><textual class="po-textual">TT</textual><subscript class="po-atom e1136 e1136"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1137 e1137"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. In our analysis, the cost of evaluating an error condition with </textual><emphasis class="po-inline e1138 e1138"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> predicates is linear in </textual><emphasis class="po-inline e1139 e1139"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">. As by construction none XPath predicate appear more than once within the same error condition, we have that the error condition associated to the assigned alternative contains at most </textual><emphasis class="po-inline e1140 e1140"><textual class="po-textual">d</textual><subscript class="po-atom e1141 e1141"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1142 e1142"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> predicates of </textual><emphasis class="po-inline e1143 e1143"><textual class="po-textual">TT</textual><subscript class="po-atom e1144 e1144"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1145 e1145"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. So its evaluation cost is linear in </textual><emphasis class="po-inline e1146 e1146"><textual class="po-textual">d</textual><subscript class="po-atom e1147 e1147"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1148 e1148"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. Thus, the number of predicates evaluated for </textual><emphasis class="po-inline e1149 e1149"><textual class="po-textual">TT</textual><subscript class="po-atom e1150 e1150"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is upper-bounded by </textual><emphasis class="po-inline e1151 e1151"><textual class="po-textual">d</textual><subscript class="po-atom e1152 e1152"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> + </textual><emphasis class="po-inline e1153 e1153"><textual class="po-textual">d</textual><subscript class="po-atom e1154 e1154"><textual class="po-textual">i</textual></subscript></emphasis><subscript class="po-atom e1155 e1155"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">.</textual></para><para class="po-block e1156 e1156"><textual class="po-textual">Considering the whole Type Table sequence, the number of evaluated XPath predicates is given by the formula shown in Equation â</textual><xref class="po-milestone e1157 e1157" linkend="equationOCPRunTimePhaseUpperBound"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â.</textual></para><equation class="po-container e1158 e1158" xml:id="equationOCPRunTimePhaseUpperBound" xreflabel="OCP run-time phase upper-bound"><mathphrase class="po-block e1159 e1159"><textual class="po-textual">2â</textual><emphasis class="po-inline e1160 e1160"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e1161 e1161"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> + ... + 2â</textual><emphasis class="po-inline e1162 e1162"><textual class="po-textual">d</textual><subscript class="po-atom e1163 e1163"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1164 e1164"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> + </textual><emphasis class="po-inline e1165 e1165"><textual class="po-textual">d</textual><subscript class="po-atom e1166 e1166"><textual class="po-textual">k</textual></subscript></emphasis></mathphrase></equation></section></section></section><section class="po-hcontainer e1167 e1167" xml:id="sectComparison" xreflabel="Comparing CP, OCP, and RTC"><title class="po-block e1168 e1168"><textual class="po-textual">Comparing CP, OCP, and RTC</textual></title><para class="po-block e1169 e1169"><textual class="po-textual">In this section we provide a comparison among the main techniques discussed so far: Optimized Cartesian Product, Run-Time Check, and Cartesian Product. The comparison focuses on the number of XPath predicates evaluated at run-time. Before starting, let us first fix some notations. Let:</textual></para><itemizedlist class="po-table e1170 e1170"><listitem class="po-container e1171 e1171"><para class="po-block e1172 e1172"><emphasis class="po-inline e1173 e1173"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> be an element of the instance document;</textual></para></listitem><listitem class="po-container e1174 e1174"><para class="po-block e1175 e1175"><emphasis class="po-inline e1176 e1176"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> be the type assigned to </textual><emphasis class="po-inline e1177 e1177"><textual class="po-textual">E</textual></emphasis><textual class="po-textual">'s parent;</textual></para></listitem><listitem class="po-container e1178 e1178"><para class="po-block e1179 e1179"><emphasis class="po-inline e1180 e1180"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e1181 e1181"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1182 e1182"><textual class="po-textual">T</textual><subscript class="po-atom e1183 e1183"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> be the derivation chain for </textual><emphasis class="po-inline e1184 e1184"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">, where </textual><emphasis class="po-inline e1185 e1185"><textual class="po-textual">T</textual></emphasis><subscript class="po-atom e1186 e1186"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> is </textual><emphasis class="po-inline e1187 e1187"><textual class="po-textual">anyType</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1188 e1188"><textual class="po-textual">T</textual><subscript class="po-atom e1189 e1189"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> is </textual><emphasis class="po-inline e1190 e1190"><textual class="po-textual">T</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1191 e1191"><para class="po-block e1192 e1192"><emphasis class="po-inline e1193 e1193"><textual class="po-textual">TT</textual></emphasis><subscript class="po-atom e1194 e1194"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1195 e1195"><textual class="po-textual">TT</textual><subscript class="po-atom e1196 e1196"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> be the sequence of context-determined Type Tables of </textual><emphasis class="po-inline e1197 e1197"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> along the derivation chain;</textual></para></listitem><listitem class="po-container e1198 e1198"><para class="po-block e1199 e1199"><emphasis class="po-inline e1200 e1200"><textual class="po-textual">d</textual><subscript class="po-atom e1201 e1201"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> be the </textual><emphasis class="po-inline e1202 e1202"><textual class="po-textual">TT</textual><subscript class="po-atom e1203 e1203"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> size, for every </textual><emphasis class="po-inline e1204 e1204"><textual class="po-textual">i</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1205 e1205"><para class="po-block e1206 e1206"><emphasis class="po-inline e1207 e1207"><textual class="po-textual">TT'</textual></emphasis><subscript class="po-atom e1208 e1208"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1209 e1209"><textual class="po-textual">TT'</textual><subscript class="po-atom e1210 e1210"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> be the Type Tables generated by the Cartesian Product static phase.</textual></para></listitem></itemizedlist><para class="po-block e1211 e1211"><textual class="po-textual">Both OCP and RTC evaluate </textual><emphasis class="po-inline e1212 e1212"><textual class="po-textual">TT</textual><subscript class="po-atom e1213 e1213"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> in order to decide which type alternative </textual><emphasis class="po-inline e1214 e1214"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> has to be assigned. Clearly, both techniques evaluate the same XPath predicates of </textual><emphasis class="po-inline e1215 e1215"><textual class="po-textual">TT</textual><subscript class="po-atom e1216 e1216"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">. The number of evaluated XPath predicates ranges from 1 to </textual><emphasis class="po-inline e1217 e1217"><textual class="po-textual">d</textual><subscript class="po-atom e1218 e1218"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1219 e1219"><textual class="po-textual">On the other hand, CP evaluates </textual><emphasis class="po-inline e1220 e1220"><textual class="po-textual">TT'</textual><subscript class="po-atom e1221 e1221"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">. If, for any </textual><emphasis class="po-inline e1222 e1222"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> between 1 and </textual><emphasis class="po-inline e1223 e1223"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1224 e1224"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> satisfies the first alternative of </textual><emphasis class="po-inline e1225 e1225"><textual class="po-textual">TT</textual><subscript class="po-atom e1226 e1226"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, CP is assigned the first alternative of </textual><emphasis class="po-inline e1227 e1227"><textual class="po-textual">TT</textual><subscript class="po-atom e1228 e1228"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, and thus the condition of that alternative only is evaluated. However, that condition is the conjunction of </textual><emphasis class="po-inline e1229 e1229"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> XPath predicates. So in the best case, CP evaluates </textual><emphasis class="po-inline e1230 e1230"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> XPath predicates. But if for every </textual><emphasis class="po-inline e1231 e1231"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> between 1 and </textual><emphasis class="po-inline e1232 e1232"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> </textual><emphasis class="po-inline e1233 e1233"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> satisfies the last alternative of </textual><emphasis class="po-inline e1234 e1234"><textual class="po-textual">TT</textual><subscript class="po-atom e1235 e1235"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, than CP has to process every alternative of </textual><emphasis class="po-inline e1236 e1236"><textual class="po-textual">TT'</textual><subscript class="po-atom e1237 e1237"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">. It means that it has to evaluate </textual><emphasis class="po-inline e1238 e1238"><textual class="po-textual">d</textual></emphasis><subscript class="po-atom e1239 e1239"><textual class="po-textual">1</textual></subscript><textual class="po-textual"> â ... â </textual><emphasis class="po-inline e1240 e1240"><textual class="po-textual">d</textual><subscript class="po-atom e1241 e1241"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> conditions, where each condition is the conjunction of </textual><emphasis class="po-inline e1242 e1242"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> XPath predicates.</textual></para><para class="po-block e1243 e1243"><textual class="po-textual">After the </textual><emphasis class="po-inline e1244 e1244"><textual class="po-textual">TT'</textual><subscript class="po-atom e1245 e1245"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> evaluation, CP already knows whether </textual><emphasis class="po-inline e1246 e1246"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e1247 e1247"><textual class="po-textual">T</textual></emphasis><textual class="po-textual"> satisfy CTSR without the need to walk on the derivation chain: if </textual><emphasis class="po-inline e1248 e1248"><textual class="po-textual">TT'</textual><subscript class="po-atom e1249 e1249"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> selected type </textual><emphasis class="po-inline e1250 e1250"><textual class="po-textual">error</textual></emphasis><textual class="po-textual"> then CTSR is violated, otherwise CTSR is satisfied. The problem is that the evaluation of </textual><emphasis class="po-inline e1251 e1251"><textual class="po-textual">TT'</textual><subscript class="po-atom e1252 e1252"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> might be very expensive.</textual></para><para class="po-block e1253 e1253"><textual class="po-textual">On the other hand, after the </textual><emphasis class="po-inline e1254 e1254"><textual class="po-textual">TT</textual><subscript class="po-atom e1255 e1255"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> evaluation, both OCP and RTC execute further operations. OCP evaluates the error condition linked to the alternative returned by </textual><emphasis class="po-inline e1256 e1256"><textual class="po-textual">TT</textual><subscript class="po-atom e1257 e1257"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, while RTC evaluates </textual><emphasis class="po-inline e1258 e1258"><textual class="po-textual">TT</textual><subscript class="po-atom e1259 e1259"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1260 e1260"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. Thus, for the purposes of our comparison, it is important to understand whether evaluating the error condition is more or less expensive than evaluating </textual><emphasis class="po-inline e1261 e1261"><textual class="po-textual">TT</textual><subscript class="po-atom e1262 e1262"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1263 e1263"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. In order deal with a clearer notation, we temporarily rename some variables:</textual></para><itemizedlist class="po-table e1264 e1264"><listitem class="po-container e1265 e1265"><para class="po-block e1266 e1266"><emphasis class="po-inline e1267 e1267"><textual class="po-textual">T</textual><subscript class="po-atom e1268 e1268"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1269 e1269"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1270 e1270"><para class="po-block e1271 e1271"><emphasis class="po-inline e1272 e1272"><textual class="po-textual">T</textual><subscript class="po-atom e1273 e1273"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1274 e1274"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1275 e1275"><textual class="po-textual">B</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1276 e1276"><para class="po-block e1277 e1277"><emphasis class="po-inline e1278 e1278"><textual class="po-textual">TT</textual><subscript class="po-atom e1279 e1279"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1280 e1280"><textual class="po-textual">TT</textual><subscript class="po-atom e1281 e1281"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1282 e1282"><para class="po-block e1283 e1283"><emphasis class="po-inline e1284 e1284"><textual class="po-textual">TT</textual><subscript class="po-atom e1285 e1285"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1286 e1286"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1287 e1287"><textual class="po-textual">TT</textual><subscript class="po-atom e1288 e1288"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1289 e1289"><para class="po-block e1290 e1290"><emphasis class="po-inline e1291 e1291"><textual class="po-textual">d</textual><subscript class="po-atom e1292 e1292"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1293 e1293"><textual class="po-textual">n</textual></emphasis><textual class="po-textual">;</textual></para></listitem><listitem class="po-container e1294 e1294"><para class="po-block e1295 e1295"><emphasis class="po-inline e1296 e1296"><textual class="po-textual">d</textual><subscript class="po-atom e1297 e1297"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1298 e1298"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> becomes </textual><emphasis class="po-inline e1299 e1299"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">;</textual></para></listitem></itemizedlist><para class="po-block e1300 e1300"><textual class="po-textual">We denote the </textual><emphasis class="po-inline e1301 e1301"><textual class="po-textual">TT</textual><subscript class="po-atom e1302 e1302"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual"> alternatives by &lt;</textual><emphasis class="po-inline e1303 e1303"><textual class="po-textual">r</textual></emphasis><subscript class="po-atom e1304 e1304"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, </textual><emphasis class="po-inline e1305 e1305"><textual class="po-textual">R</textual></emphasis><subscript class="po-atom e1306 e1306"><textual class="po-textual">1</textual></subscript><textual class="po-textual">&gt;, ..., &lt;</textual><emphasis class="po-inline e1307 e1307"><textual class="po-textual">r</textual><subscript class="po-atom e1308 e1308"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1309 e1309"><textual class="po-textual">R</textual><subscript class="po-atom e1310 e1310"><textual class="po-textual">n</textual></subscript></emphasis><textual class="po-textual">&gt;; and the </textual><emphasis class="po-inline e1311 e1311"><textual class="po-textual">TT</textual><subscript class="po-atom e1312 e1312"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> alternatives by &lt;</textual><emphasis class="po-inline e1313 e1313"><textual class="po-textual">b</textual></emphasis><subscript class="po-atom e1314 e1314"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, </textual><emphasis class="po-inline e1315 e1315"><textual class="po-textual">B</textual></emphasis><subscript class="po-atom e1316 e1316"><textual class="po-textual">1</textual></subscript><textual class="po-textual">&gt;, ..., &lt;</textual><emphasis class="po-inline e1317 e1317"><textual class="po-textual">b</textual><subscript class="po-atom e1318 e1318"><textual class="po-textual">m</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1319 e1319"><textual class="po-textual">B</textual><subscript class="po-atom e1320 e1320"><textual class="po-textual">m</textual></subscript></emphasis><textual class="po-textual">&gt;. Moreover, let </textual><emphasis class="po-inline e1321 e1321"><textual class="po-textual">i</textual></emphasis><textual class="po-textual"> be the (index of the) alternative selected by </textual><emphasis class="po-inline e1322 e1322"><textual class="po-textual">TT</textual><subscript class="po-atom e1323 e1323"><textual class="po-textual">R</textual></subscript></emphasis><textual class="po-textual">. We denote the error condition associated to that alternative by </textual><emphasis class="po-inline e1324 e1324"><textual class="po-textual">err</textual><subscript class="po-atom e1325 e1325"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1326 e1326"><textual class="po-textual">As already observed in Section â</textual><xref class="po-milestone e1327 e1327" linkend="sectOCPStaticPhase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, </textual><emphasis class="po-inline e1328 e1328"><textual class="po-textual">err</textual><subscript class="po-atom e1329 e1329"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is a boolean expression over the XPath predicates (here called </textual><emphasis class="po-inline e1330 e1330"><textual class="po-textual">atoms</textual></emphasis><textual class="po-textual">) of </textual><emphasis class="po-inline e1331 e1331"><textual class="po-textual">TT</textual><subscript class="po-atom e1332 e1332"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">. Assuming the simplification process did </textual><emphasis class="po-inline e1333 e1333"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> rewrite it, </textual><emphasis class="po-inline e1334 e1334"><textual class="po-textual">err</textual><subscript class="po-atom e1335 e1335"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> contains each of the </textual><emphasis class="po-inline e1336 e1336"><textual class="po-textual">m</textual></emphasis><textual class="po-textual"> atoms of </textual><emphasis class="po-inline e1337 e1337"><textual class="po-textual">TT</textual><subscript class="po-atom e1338 e1338"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">.</textual></para><figure class="po-container e1339 e1339" floatstyle="1" xml:id="figErrorConditionStructure" xreflabel="OCP Error Condition Example"><title class="po-block e1340 e1340"><textual class="po-textual">OCP Error Condition Example</textual></title><mediaobject class="po-container e1341 e1341"><imageobject class="po-container e1342 e1342"><imagedata class="po-meta e1343 e1343" fileref="../../../vol1/graphics/Marinelli01/Marinelli01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e1344 e1344"><para class="po-block e1345 e1345"><textual class="po-textual">Structure for the error condition </textual><code class="po-atom e1346 e1346"><textual class="po-textual">not(@kind='string') and (@kind='base64' or (@kind='binary' or (@kind='xml' or (@kind='XML' or FALSE))))</textual></code><textual class="po-textual">. XPath predicates have been abbreviated for conciseness reasons.</textual></para></caption></figure><para class="po-block e1347 e1347"><textual class="po-textual">At this point it is important to study the structure of a generic error expression </textual><emphasis class="po-inline e1348 e1348"><textual class="po-textual">err</textual><subscript class="po-atom e1349 e1349"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">. As also shown in Figure â</textual><xref class="po-milestone e1350 e1350" linkend="figErrorConditionStructure"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, an error condition has a fixed structure: for each </textual><code class="po-atom e1351 e1351"><textual class="po-textual">or</textual></code><textual class="po-textual"> (</textual><code class="po-atom e1352 e1352"><textual class="po-textual">and</textual></code><textual class="po-textual">) operator, its left operand is always a (negated) atom, while its right operand is either another binary operator, or </textual><code class="po-atom e1353 e1353"><textual class="po-textual">FALSE</textual></code><textual class="po-textual"> (</textual><code class="po-atom e1354 e1354"><textual class="po-textual">TRUE</textual></code><textual class="po-textual">). Moreover, we can observe that the atoms appear in the same order they appear in </textual><emphasis class="po-inline e1355 e1355"><textual class="po-textual">TT</textual><subscript class="po-atom e1356 e1356"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1357 e1357"><textual class="po-textual">It is easy to implement an error condition evaluator as a </textual><emphasis class="po-inline e1358 e1358"><textual class="po-textual">lazy boolean evaluator</textual></emphasis><textual class="po-textual">: for any input binary operator it always evaluates the left operand first, and it evaluates the right operand only if necessary. The atoms of </textual><emphasis class="po-inline e1359 e1359"><textual class="po-textual">err</textual><subscript class="po-atom e1360 e1360"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> actually evaluated by such a boolean evaluator are exactly the same as those evaluated by RTC to decide the </textual><emphasis class="po-inline e1361 e1361"><textual class="po-textual">TT</textual><subscript class="po-atom e1362 e1362"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual"> selected type.</textual></para><para class="po-block e1363 e1363"><textual class="po-textual">For instance, suppose that for a given </textual><emphasis class="po-inline e1364 e1364"><textual class="po-textual">j</textual></emphasis><textual class="po-textual"> our </textual><emphasis class="po-inline e1365 e1365"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> element does not satisfy none of </textual><emphasis class="po-inline e1366 e1366"><textual class="po-textual">b</textual></emphasis><subscript class="po-atom e1367 e1367"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1368 e1368"><textual class="po-textual">b</textual><subscript class="po-atom e1369 e1369"><textual class="po-textual">j</textual></subscript></emphasis><subscript class="po-atom e1370 e1370"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">, and it does satisfy </textual><emphasis class="po-inline e1371 e1371"><textual class="po-textual">b</textual><subscript class="po-atom e1372 e1372"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">. RTC evaluates </textual><emphasis class="po-inline e1373 e1373"><textual class="po-textual">b</textual></emphasis><subscript class="po-atom e1374 e1374"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ...,</textual><emphasis class="po-inline e1375 e1375"><textual class="po-textual">b</textual><subscript class="po-atom e1376 e1376"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">. Also our technique evaluates those predicates, and it does not evaluate further ones. Indeed within </textual><emphasis class="po-inline e1377 e1377"><textual class="po-textual">err</textual><subscript class="po-atom e1378 e1378"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1379 e1379"><textual class="po-textual">b</textual><subscript class="po-atom e1380 e1380"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual"> appears either in negated form as left operand of an </textual><code class="po-atom e1381 e1381"><textual class="po-textual">and</textual></code><textual class="po-textual"> operator, or directly as left operand of an </textual><code class="po-atom e1382 e1382"><textual class="po-textual">or</textual></code><textual class="po-textual"> operator (it depends on whether or not </textual><emphasis class="po-inline e1383 e1383"><textual class="po-textual">R</textual><subscript class="po-atom e1384 e1384"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is validly substitutable as restriction for </textual><emphasis class="po-inline e1385 e1385"><textual class="po-textual">B</textual><subscript class="po-atom e1386 e1386"><textual class="po-textual">j</textual></subscript></emphasis><textual class="po-textual">). In either case, the </textual><emphasis class="po-inline e1387 e1387"><textual class="po-textual">err</textual><subscript class="po-atom e1388 e1388"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> evaluation stops before processing the right operand.</textual></para><para class="po-block e1389 e1389"><textual class="po-textual">Thus we can conclude that even if it is not possible to simplify </textual><emphasis class="po-inline e1390 e1390"><textual class="po-textual">err</textual><subscript class="po-atom e1391 e1391"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual">, OCP and RTC are equivalent in terms of evaluated atoms. But there are cases in which </textual><emphasis class="po-inline e1392 e1392"><textual class="po-textual">err</textual><subscript class="po-atom e1393 e1393"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is simplified by the rewriting rules described in Section â</textual><xref class="po-milestone e1394 e1394" linkend="sectOCPStaticPhase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. Indeed, if there exists a </textual><emphasis class="po-inline e1395 e1395"><textual class="po-textual">j</textual></emphasis><textual class="po-textual"> such that either</textual></para><itemizedlist class="po-table e1396 e1396"><listitem class="po-container e1397 e1397"><para class="po-block e1398 e1398"><textual class="po-textual">for each  </textual><emphasis class="po-inline e1399 e1399"><textual class="po-textual">j</textual></emphasis><textual class="po-textual"> &lt; </textual><emphasis class="po-inline e1400 e1400"><textual class="po-textual">j'</textual></emphasis><textual class="po-textual"> &lt;= </textual><emphasis class="po-inline e1401 e1401"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1402 e1402"><textual class="po-textual">R</textual><subscript class="po-atom e1403 e1403"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is not validly substitutable as restriction for </textual><emphasis class="po-inline e1404 e1404"><textual class="po-textual">B</textual><subscript class="po-atom e1405 e1405"><textual class="po-textual">j'</textual></subscript></emphasis></para></listitem></itemizedlist><para class="po-block e1406 e1406"><textual class="po-textual">or</textual></para><itemizedlist class="po-table e1407 e1407"><listitem class="po-container e1408 e1408"><para class="po-block e1409 e1409"><textual class="po-textual">for each  </textual><emphasis class="po-inline e1410 e1410"><textual class="po-textual">j</textual></emphasis><textual class="po-textual"> &lt; </textual><emphasis class="po-inline e1411 e1411"><textual class="po-textual">j'</textual></emphasis><textual class="po-textual"> &lt;= </textual><emphasis class="po-inline e1412 e1412"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">, </textual><emphasis class="po-inline e1413 e1413"><textual class="po-textual">R</textual><subscript class="po-atom e1414 e1414"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> is validly substitutable as restriction for </textual><emphasis class="po-inline e1415 e1415"><textual class="po-textual">B</textual><subscript class="po-atom e1416 e1416"><textual class="po-textual">j'</textual></subscript></emphasis><textual class="po-textual">,</textual></para></listitem></itemizedlist><para class="po-block e1417 e1417"><textual class="po-textual">then the simplification process removes from </textual><emphasis class="po-inline e1418 e1418"><textual class="po-textual">err</textual><subscript class="po-atom e1419 e1419"><textual class="po-textual">i</textual></subscript></emphasis><textual class="po-textual"> the atmos </textual><emphasis class="po-inline e1420 e1420"><textual class="po-textual">b</textual><subscript class="po-atom e1421 e1421"><textual class="po-textual">j</textual></subscript></emphasis><subscript class="po-atom e1422 e1422"><textual class="po-textual">+1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1423 e1423"><textual class="po-textual">b</textual><subscript class="po-atom e1424 e1424"><textual class="po-textual">m</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1425 e1425"><textual class="po-textual">In such cases, if </textual><emphasis class="po-inline e1426 e1426"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> does not satisfy any of the predicates </textual><emphasis class="po-inline e1427 e1427"><textual class="po-textual">b</textual></emphasis><subscript class="po-atom e1428 e1428"><textual class="po-textual">1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1429 e1429"><textual class="po-textual">b</textual><subscript class="po-atom e1430 e1430"><textual class="po-textual">j</textual></subscript></emphasis><subscript class="po-atom e1431 e1431"><textual class="po-textual">+</textual></subscript><emphasis class="po-inline e1432 e1432"><subscript class="po-atom e1433 e1433"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, for some </textual><emphasis class="po-inline e1434 e1434"><textual class="po-textual">k</textual></emphasis><textual class="po-textual">, then OCP does not need to evaluate the </textual><emphasis class="po-inline e1435 e1435"><textual class="po-textual">k</textual></emphasis><textual class="po-textual"> atoms </textual><emphasis class="po-inline e1436 e1436"><textual class="po-textual">b</textual><subscript class="po-atom e1437 e1437"><textual class="po-textual">j</textual></subscript></emphasis><subscript class="po-atom e1438 e1438"><textual class="po-textual">+1</textual></subscript><textual class="po-textual">, ..., </textual><emphasis class="po-inline e1439 e1439"><textual class="po-textual">b</textual><subscript class="po-atom e1440 e1440"><textual class="po-textual">j</textual></subscript></emphasis><subscript class="po-atom e1441 e1441"><textual class="po-textual">+</textual></subscript><emphasis class="po-inline e1442 e1442"><subscript class="po-atom e1443 e1443"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual"> in order to decide whether CTSR is satisfied or not. On the other hand, RTC does evaluate those atoms, because it has to find the type actually selected by </textual><emphasis class="po-inline e1444 e1444"><textual class="po-textual">TT</textual><subscript class="po-atom e1445 e1445"><textual class="po-textual">B</textual></subscript></emphasis><textual class="po-textual">.</textual></para><para class="po-block e1446 e1446"><textual class="po-textual">Thus, we can conclude that on a single step of a derivation chain, OCP evaluates a number of predicates less than or equal to the number of predicates evaluated by RTC.</textual></para><para class="po-block e1447 e1447"><textual class="po-textual">However, as can be noted from the formulas shown in Equations â</textual><xref class="po-milestone e1448 e1448" linkend="equationRTCAlgoUpperBound"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â and â</textual><xref class="po-milestone e1449 e1449" linkend="equationOCPRunTimePhaseUpperBound"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, OCP might evaluate twice the same atoms. Coming back to the notation introduced early in this section, if </textual><emphasis class="po-inline e1450 e1450"><textual class="po-textual">E</textual></emphasis><textual class="po-textual"> does not satisfy the error condition of the alternative selected by </textual><emphasis class="po-inline e1451 e1451"><textual class="po-textual">TT</textual><subscript class="po-atom e1452 e1452"><textual class="po-textual">k</textual></subscript></emphasis><textual class="po-textual">, then OCP has to evaluate </textual><emphasis class="po-inline e1453 e1453"><textual class="po-textual">TT</textual><subscript class="po-atom e1454 e1454"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1455 e1455"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">. But as the error condition previously processed was built on the atoms of </textual><emphasis class="po-inline e1456 e1456"><textual class="po-textual">TT</textual><subscript class="po-atom e1457 e1457"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1458 e1458"><textual class="po-textual">-1</textual></subscript><textual class="po-textual">, it is clear that some predicates of </textual><emphasis class="po-inline e1459 e1459"><textual class="po-textual">TT</textual><subscript class="po-atom e1460 e1460"><textual class="po-textual">k</textual></subscript></emphasis><subscript class="po-atom e1461 e1461"><textual class="po-textual">-1</textual></subscript><textual class="po-textual"> might be processed twice.</textual></para><para class="po-block e1462 e1462"><textual class="po-textual">However, it is possible to ease such an additional cost if during the processing of an error condition, the result of each atom evaluation is stored in some data structure. In this way, an XPath predicate is actually evaluated only if it has not been evaluated yet.</textual></para><para class="po-block e1463 e1463"><textual class="po-textual">So we conclude that for a given derivation chain, OCP evaluates a number of XPath predicates less than or equal to the number of XPath predicates RTC evaluates.</textual></para></section><section class="po-hcontainer e1464 e1464" xml:id="sectImplementation" xreflabel="Implementation"><title class="po-block e1465 e1465"><textual class="po-textual">Implementation</textual></title><para class="po-block e1466 e1466"><textual class="po-textual">We realized a prototype implementation of Optimized Cartesian Product, thus demonstrating its feasibility. We implemented it in Java within Xerces [</textual><xref class="po-milestone e1467 e1467" linkend="entryXerces"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Our prototype patches Xerces under three aspects:</textual></para><orderedlist class="po-table e1468 e1468"><listitem class="po-container e1469 e1469"><para class="po-block e1470 e1470"><textual class="po-textual">support for XSD 1.1 related components;</textual></para></listitem><listitem class="po-container e1471 e1471"><para class="po-block e1472 e1472"><textual class="po-textual">implementation of the OCP static phase;</textual></para></listitem><listitem class="po-container e1473 e1473"><para class="po-block e1474 e1474"><textual class="po-textual">implementation of the OCP run-time phase within the existing validation code.</textual></para></listitem></orderedlist><para class="po-block e1475 e1475"><textual class="po-textual">As Xerces is an XML parser for XSD 1.0, it does not handle 1.1-specific constructs. Our prototype modifies the Xerces modules delegated to the construction of schema components (package </textual><code class="po-atom e1476 e1476"><textual class="po-textual">org.apache.xerces.impl.xs.traversers</textual></code><textual class="po-textual">). It also modifies the Xerces implementation of the XML Schema API [</textual><xref class="po-milestone e1477 e1477" linkend="entryXMLSchemaAPI"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], in order to represent type alternative components, and to give element declarations awareness of their Type Tables (packages </textual><code class="po-atom e1478 e1478"><textual class="po-textual">org.apache.xerces.xs</textual></code><textual class="po-textual"> and </textual><code class="po-atom e1479 e1479"><textual class="po-textual">org.apache.xerces.impl.xs</textual></code><textual class="po-textual">).</textual></para><para class="po-block e1480 e1480"><textual class="po-textual">The OCP static phase is implemented within a separated package </textual><code class="po-atom e1481 e1481"><textual class="po-textual">it.unibo.cs.cta</textual></code><textual class="po-textual">. The code for the error condition construction is within the class </textual><code class="po-atom e1482 e1482"><textual class="po-textual">it.unibo.cs.cta.preprocessor.impl.ErrorConditionBuilder</textual></code><textual class="po-textual">. Such a class processes an input XSD schema, associating each type with a map. That map is our implementation of </textual><emphasis class="po-inline e1483 e1483"><textual class="po-textual">tt-map</textual><superscript class="po-atom e1484 e1484"><textual class="po-textual">T</textual></superscript></emphasis><textual class="po-textual">. Indeed, it associates element names to context-determined Type Tables. </textual><code class="po-atom e1485 e1485"><textual class="po-textual">ErrorConditionBuilder</textual></code><textual class="po-textual"> also annotates each context-determined Type Table with its error conditions. Error conditions are built directly using the algorithm described in Section â</textual><xref class="po-milestone e1486 e1486" linkend="sectOCPStaticPhase"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â. The classes handling error conditions are within the package </textual><code class="po-atom e1487 e1487"><textual class="po-textual">it.unibo.cs.cta.errorexpr</textual></code><textual class="po-textual">. In particular, the simplification of error conditions is implemented by </textual><code class="po-atom e1488 e1488"><textual class="po-textual">ErrorExpressionSimplifier</textual></code><textual class="po-textual">, while their evaluation is implemented by </textual><code class="po-atom e1489 e1489"><textual class="po-textual">ErrorExpressionEvaluator</textual></code><textual class="po-textual">.</textual></para><para class="po-block e1490 e1490"><textual class="po-textual">The static phase is delegated to a pre-processor invoked when a schema document is loaded. In order to invoke it, the simple and compact code below is used:</textual></para><programlisting class="po-block e1491 e1491" xml:space="preserve"><textual class="po-textual">
</textual><emphasis class="po-inline e1492 e1492"><textual class="po-textual">// instantiation </textual></emphasis><textual class="po-textual">
PreprocessorFactory pf = PreprocessorFactory.getInstance();
fPreprocessor = pf.createPreprocessorSequence(
    new String[]{"ErrorConditionBuilder"}
    );
</textual><emphasis class="po-inline e1493 e1493"><textual class="po-textual">// invocation on an XS Model</textual></emphasis><textual class="po-textual">
fPreprocessor.processModel(model);
</textual></programlisting><para class="po-block e1494 e1494"><textual class="po-textual">The static phase result (i.e., association between types and maps) is read calling the pre-processor method </textual><code class="po-atom e1495 e1495"><textual class="po-textual">getStateByName("type-table-map")</textual></code><textual class="po-textual">.</textual></para><para class="po-block e1496 e1496"><textual class="po-textual">The OCP run-time phase is implemented within the class </textual><code class="po-atom e1497 e1497"><textual class="po-textual">org.apache.xerces.impl.xs.OptimizedCTAXMLSchemaValidator</textual></code><textual class="po-textual">, a patched version of the original XSD validator provided by Xerces. In particular, the code for the CTSR verification is within the method </textual><code class="po-atom e1498 e1498"><textual class="po-textual">handleStartElement</textual></code><textual class="po-textual">. XPath predicates are evaluated using the interfaces in </textual><code class="po-atom e1499 e1499"><textual class="po-textual">javax.xml.xpath</textual></code><textual class="po-textual">. Currently, our prototype does not check whether an XPath predicate has already been evaluated. Thus, as observed in Section â</textual><xref class="po-milestone e1500 e1500" linkend="sectComparison"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">â, an XPath predicate might be evaluated twice for the same element.</textual></para><para class="po-block e1501 e1501"><textual class="po-textual">Our prototype is meant to prove the OCP feasibility, and as such it is not aimed to be XSD 1.1 conformant. In particular it has some limitations, the most important of which are:</textual></para><orderedlist class="po-table e1502 e1502"><listitem class="po-container e1503 e1503"><para class="po-block e1504 e1504"><textual class="po-textual">XPath 1.0 expressions only are accepted;</textual></para></listitem><listitem class="po-container e1505 e1505"><para class="po-block e1506 e1506"><textual class="po-textual">all non CTA related syntax is ignored. E.g., </textual><code class="po-atom e1507 e1507"><textual class="po-textual">&lt;assert&gt;</textual></code><textual class="po-textual"> elements are not considered legal within a schema;</textual></para></listitem><listitem class="po-container e1508 e1508"><para class="po-block e1509 e1509"><textual class="po-textual">derivations by restriction are checked using the original Xerces code, i.e., XSD 1.0 rules are applied.</textual><footnote class="po-popup e1510 e1510"><para class="po-block e1511 e1511"><textual class="po-textual">XSD 1.0 defines the derivation by restriction in terms of ad hoc rules provided by the recommendation itself. XSD 1.1 allows processors to choose the algorithm they like to check whether a content model includes another content model.</textual></para></footnote></para></listitem></orderedlist><para class="po-block e1512 e1512"><textual class="po-textual">We also developed a small test suite for OCP. It can be run through a simple graphic interface. Source code and jars are available from </textual><link class="po-inline e1513 e1513" xlink:actuate="onRequest" xlink:href="http://tesi.fabio.web.cs.unibo.it/Tesi/OptimizedCartesianProduct" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://tesi.fabio.web.cs.unibo.it/Tesi/OptimizedCartesianProduct</textual></link><textual class="po-textual">.</textual></para></section><section class="po-hcontainer e1514 e1514" xml:id="sectRelatedWorks" xreflabel="Related Works"><title class="po-block e1515 e1515"><textual class="po-textual">Related Works</textual></title><para class="po-block e1516 e1516"><textual class="po-textual">Among the most known validation languages (DTD [</textual><xref class="po-milestone e1517 e1517" linkend="entryXML11"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], RELAX NG [</textual><xref class="po-milestone e1518 e1518" linkend="entryRELAXNGISOspecification"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], Schematron [</textual><xref class="po-milestone e1519 e1519" linkend="entrySchematronISOspecification"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], DSD [</textual><xref class="po-milestone e1520 e1520" linkend="entryDSD20"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], etc), the problem of verifying the subtype relation in presence of conditional declarations is very specific to XSD 1.1. Indeed, although there exist at least one language, DSD, permitting the definition of conditional content models, that language is not type-based, and consequently nor it has any concept of type derivation. We do not know works about restriction checking in presence of conditional declarations.</textual></para><para class="po-block e1521 e1521"><textual class="po-textual">However, there exist works on the problem of verifying whether an XSD 1.0 type is a legal restriction of another type [</textual><xref class="po-milestone e1522 e1522" linkend="entryFSAThompson"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e1523 e1523" linkend="entryFuchs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], [</textual><xref class="po-milestone e1524 e1524" linkend="entryBrzozowski"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Those works propose techniques to statically verify whether a type accepts a subset of what the base type accepts. On the same line, Neven et al present theoretical results about some basic decision problems concerning schemas, among which the problem of testing for inclusion of schemas [</textual><xref class="po-milestone e1525 e1525" linkend="entryNeven1PassPreorder"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para></section><section class="po-hcontainer e1526 e1526" xml:id="sectConclusions" xreflabel="Conclusions"><title class="po-block e1527 e1527"><textual class="po-textual">Conclusions</textual></title><para class="po-block e1528 e1528"><textual class="po-textual">In XSD 1.1, the presence of conditional declarations increases the difficulty in verifying whether a type is a legal restriction of its base. We discussed about three main approaches to the problem: CTA usage limitation, run-time verification, and hybrid verification. Solutions of the first kind ensure it is possible to </textual><emphasis class="po-inline e1529 e1529"><textual class="po-textual">statically</textual></emphasis><textual class="po-textual"> verify whether a type is a legal restriction of its base, but at the cost of limiting the CTA expressivity. Solutions of both second and third kinds allow the highest degree of expressivity, but they may recognize as legal restriction also a type accepting something its base rejects. They throw an error only for those instance documents actually proving that a type is not a legal restriction of its base. Hybrid solutions are meant to precompute during the static phase some information that might decrease the work to be done at run-time.</textual></para><para class="po-block e1530 e1530"><textual class="po-textual">In particular, we described the solution adopted by the XSD current draft, which follows a run-time approach described within the specs by the Conditional Type Substitutable in Restriction (CTSR) constraint. We discussed about an algorithm verifying CTSR, and we called it Run-Time Check (RTC). Then we proposed an alternative solution to RTC, named Optimized Cartesian Product (OCP). OCP is a hybrid solution. Its idea is to analyze conditional declarations in order to statically decide which XPath predicates can be ignored at run-time. We showed as, contrary to Cartesian Product (CP) - another hybrid solution OCP can be seen as an optimization of - the OCP static analysis cost is perfectly acceptable.</textual></para><para class="po-block e1531 e1531"><textual class="po-textual">We than compared the RTC, OCP and CP techniques, focusing on the number of XPath predicates evaluated at run-time. We showed as CP is the worst technique, as it inherits from the static phase a high volume of information that might heavily slow down the run-time phase. We also showed that although OCP might process the same alternatives twice, storing the XPath predicate evaluation results, we can assert that OCP evaluates a number of predicates less than or equal to the number of predicates RTC evaluates.</textual></para><para class="po-block e1532 e1532"><textual class="po-textual">An interesting future work is the experimental comparison among RTC, OCP and CP on a base of real schema documents. Moreover it is interesting to improve our error condition simplification process. For instance, our simplification rules are not able to rewrite expressions like </textual><code class="po-atom e1533 e1533"><textual class="po-textual">not(@a = 'v1') and (@a = 'v2')</textual></code><textual class="po-textual"> into </textual><code class="po-atom e1534 e1534"><textual class="po-textual">(@a = 'v2')</textual></code><textual class="po-textual">. There are also error conditions that are clearly unsatisfiable when associated to a particular alternative. For instance, if the alternative predicate is </textual><code class="po-atom e1535 e1535"><textual class="po-textual">(@a = 'v1')</textual></code><textual class="po-textual"> and the error condition is </textual><code class="po-atom e1536 e1536"><textual class="po-textual">(@a = 'v2')</textual></code><textual class="po-textual">, it is clear that the error condition will never be satisfied. Improving the simplification rule set should increase the number of situations in which OCP is preferable to RTC.</textual></para></section><section class="po-hcontainer e1537 e1537" xml:id="sectAcknowledgements" xreflabel="Acknowledgements"><title class="po-block e1538 e1538"><textual class="po-textual">Acknowledgements</textual></title><para class="po-block e1539 e1539"><textual class="po-textual">We would like to thank Stefano Zacchiroli for the technical discussions we had during the design of the Optimized Cartesian Product technique, the anonymous reviewers for their comments, and the XML Schema Working Group for the several and inspiring discussions on the topics covered by this paper.</textual></para></section><bibliography class="po-hcontainer e1540 e1540"><title class="po-block e1541 e1541"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e1542 e1542" xml:id="entryCoOccurrenceConstraintsESWWiki" xreflabel="Co-occurrence constraints ESW Wiki"><textual class="po-textual">Co-occurrence constraints ESW Wiki. </textual><link class="po-inline e1543 e1543" xlink:actuate="onRequest" xlink:href="http://esw.w3.org/topic/Co-occurrence_constraints" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://esw.w3.org/topic/Co-occurrence_constraints</textual></link></bibliomixed><bibliomixed class="po-block e1544 e1544" xml:id="entryDSD20" xreflabel="DSD 2.0"><textual class="po-textual">MÃ¸ller, A. 2002. Document Structure Description 2.0. BRICS, Department of Computer Science, University of Aarhus, Aarhus, Denmark. </textual><link class="po-inline e1545 e1545" xlink:actuate="onRequest" xlink:href="http://www.brics.dk/DSD/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.brics.dk/DSD/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1546 e1546" xml:id="entryFuchs" xreflabel="M. Fuchs, and A. Brown, 2003"><textual class="po-textual">M. Fuchs, and A. Brown. Supporting UPA and restriction on an extension of XML Schema. In </textual><emphasis class="po-inline e1547 e1547"><textual class="po-textual">Proceedings of Extreme Markup Languages</textual></emphasis><textual class="po-textual">. August, 2003. MontrÃ©al, QuÃ©bec. </textual><link class="po-inline e1548 e1548" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/extreme03/html/2003/Fuchs01/EML2003Fuchs01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.idealliance.org/papers/extreme03/html/2003/Fuchs01/EML2003Fuchs01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1549 e1549" xml:id="entrySchemaPathWWW" xreflabel="P. Marinelli, C. Sacerdoti Coen, and F. Vitali, 2004"><textual class="po-textual">P. Marinelli, C. Sacerdoti Coen, and F. Vitali. SchemaPath, a Minimal Extension to XML Schema for Conditional Constraints. In </textual><emphasis class="po-inline e1550 e1550"><textual class="po-textual">Proceedings of the Thirteenth International World Wide Web Conference</textual></emphasis><textual class="po-textual">. New York, NY, USA. May, 2004. Pages 164-174. ACM Press. doi:</textual><biblioid class="po-atom e1551 doi e1551"><textual class="po-textual">10.1145/988672.988695</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1552 e1552" xml:id="entryNeven1PassPreorder" xreflabel="W. Martens, F. Neven, and T. Schwentick, 2005"><textual class="po-textual">W. Martens, F. Neven, and T. Schwentick. Which XML Schemas Admit 1-Pass Preorder Typing? In </textual><emphasis class="po-inline e1553 e1553"><textual class="po-textual">Proceedings of the 10</textual><superscript class="po-atom e1554 e1554"><textual class="po-textual">th</textual></superscript><textual class="po-textual"> International Conference on Database Theory</textual></emphasis><textual class="po-textual">. Edinburgh, UK, January 5-7, 2005. LNCS. Volume 3363. Pages 68-82. doi:</textual><biblioid class="po-atom e1555 doi e1555"><textual class="po-textual">10.1007/978-3-540-30570-5_5</textual></biblioid><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1556 e1556" xml:id="entryRELAXNGISOspecification" xreflabel="RELAX NG ISO specification"><textual class="po-textual">Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar-based validation -- RELAX NG. ISO/IEC 19757-2:2003, JTC1/SC34 Committee. Publicly available at </textual><link class="po-inline e1557 e1557" xlink:actuate="onRequest" xlink:href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c037605_ISO_IEC_19757-2_2003(E).zip" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://standards.iso.org/ittf/PubliclyAvailableStandards/c037605_ISO_IEC_19757-2_2003(E).zip</textual></link></bibliomixed><bibliomixed class="po-block e1558 e1558" xml:id="entrySchematronISOspecification" xreflabel="Schematron ISO specification"><textual class="po-textual">Information technology -- Document Schema Definition Language (DSDL) -- Part 3: Rule-based validation -- Schematron. ISO/IEC 19757-3:2006, JTC1/SC34 Committee. Publicly available at </textual><link class="po-inline e1559 e1559" xlink:actuate="onRequest" xlink:href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1560 e1560" xml:id="entryBrzozowski" xreflabel="C. M. Sperberg-McQueen, 2005"><textual class="po-textual">C. M. Sperberg-McQueen. Applications of Brzozowski derivatives to XML Schema processing. In </textual><emphasis class="po-inline e1561 e1561"><textual class="po-textual">Proceedings of Extreme Markup Languages</textual></emphasis><textual class="po-textual">. August, 2005. MontrÃ©al, QuÃ©bec. </textual><link class="po-inline e1562 e1562" xlink:actuate="onRequest" xlink:href="http://www.mulberrytech.com/Extreme/Proceedings/html/2005/SperbergMcQueen01/EML2005SperbergMcQueen01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.mulberrytech.com/Extreme/Proceedings/html/2005/SperbergMcQueen01/EML2005SperbergMcQueen01.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1563 e1563" xml:id="entryFSAThompson" xreflabel="H. S. Thompson, and R. Tobin, 2003"><textual class="po-textual">H. S. Thompson, and R. Tobin. Using Finite State Automata to Implement W3C XML Schema Content Model Validation and Restriction Checking. In </textual><emphasis class="po-inline e1564 e1564"><textual class="po-textual">Proceedings of XML Europe</textual></emphasis><textual class="po-textual">. London, England. May, 2003. </textual><link class="po-inline e1565 e1565" xlink:actuate="onRequest" xlink:href="http://www.idealliance.org/papers/dx_xmle03/papers/02-02-05/02-02-05.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.idealliance.org/papers/dx_xmle03/papers/02-02-05/02-02-05.html</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1566 e1566" xml:id="entryWalshCowan2001" xreflabel="N. Walsh and J. Cowan, 2001"><textual class="po-textual">N. Walsh, and J. Cowan. Schema Language Comparison. December, 2001. </textual><link class="po-inline e1567 e1567" xlink:actuate="onRequest" xlink:href="http://nwalsh.com/xml2001/schematownhall/slides/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://nwalsh.com/xml2001/schematownhall/slides/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1568 e1568" xml:id="entryXerces" xreflabel="Xerces"><textual class="po-textual">The Apache Software Foundation. Apache Xerces. </textual><link class="po-inline e1569 e1569" xlink:actuate="onRequest" xlink:href="http://xml.apache.org" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://xml.apache.org</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1570 e1570" xml:id="entryXMLSchemaAPI" xreflabel="XML Schema API"><textual class="po-textual">Elena Litani. XML Schema API. W3C Member Submission. 22 January 2004. </textual><link class="po-inline e1571 e1571" xlink:actuate="onRequest" xlink:href="http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040122/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/Submission/2004/SUBM-xmlschema-api-20040122/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1572 e1572" xml:id="entryXML11" xreflabel="XML 1.1"><textual class="po-textual">Extensible Markup Language (XML) 1.1 (Second Edition). W3C Recommendation. 16 August 2006. </textual><link class="po-inline e1573 e1573" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xml11/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xml11/</textual></link><textual class="po-textual">.</textual></bibliomixed><bibliomixed class="po-block e1574 e1574" xml:id="entryXSD1.0-structures" xreflabel="XSD 1.0: Structures"><textual class="po-textual">XML Schema Part 1: Structures Second Edition. W3C Recommendation. 28 October 2004. </textual><link class="po-inline e1575 e1575" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-1/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-1/</textual></link><textual class="po-textual"> </textual></bibliomixed><bibliomixed class="po-block e1576 e1576" xml:id="entryXSD1.0-datatypes" xreflabel="XSD 1.0: Datatypes"><textual class="po-textual">XML Schema Part 2: Datatypes Second Edition. W3C Recommendation. 28 October 2004. </textual><link class="po-inline e1577 e1577" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xmlschema-2/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xmlschema-2/</textual></link></bibliomixed><bibliomixed class="po-block e1578 e1578" xml:id="entryXSD1.1-structures" xreflabel="XSD 1.1: Structures"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures. W3C Working Draft. 20 June 2008. </textual><link class="po-inline e1579 e1579" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2008/WD-xmlschema11-1-20080620/</textual></link></bibliomixed><bibliomixed class="po-block e1580 e1580" xml:id="entryXSD1.1-datatypes" xreflabel="XSD 1.1: Datatypes"><textual class="po-textual">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes. W3C Working Draft. 20 June 2008. </textual><link class="po-inline e1581 e1581" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/2008/WD-xmlschema11-2-20080620/</textual></link></bibliomixed></bibliography></article></classedDocument>