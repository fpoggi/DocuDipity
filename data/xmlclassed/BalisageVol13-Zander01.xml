<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">Extending XQuery with pattern matching over XML, HTML and JSON, and its usage for data mining </textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2014</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 5 - 8, 2014</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual"> Pattern matching in a broad sense is a common feature of modern functional programming languages, answering the question, if one complex structured object has a form that is the same as another complex structured object, for some definition of “the same”. In XQuery path expressions, switch, and typeswitch statements are often described as performing pattern matching, but these are merely impoverished flavors of matching when compared to the real thing. 
      We describe a syntax for general pattern matching based on regular expressions for XML/HTML/JSONiq trees, how these patterns are matched against input data, and how this pattern matching can be integrated into the syntax and semantics of the XQuery language.</textual><textual class="po-textual"> </textual><textual class="po-textual"> </textual><textual class="po-textual">
      At the end we summarize real-world experience using it for large-scale data mining of library webcatalogs.  </textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">Benito</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">van der Zander</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">Benito van der Zander is a graduate student at the University of Lübeck, working on the Ph.D. project "Algorithmics Of Causal Inference" investigating algorithms for Pearl's causality framework. Before his enrollment in that graduate school, he has developed the open-source XQuery engine </textual><link class="po-inline e14 e14" xlink:actuate="onRequest" xlink:href="http://xidel.sourceforge.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Xidel</textual></link><textual class="po-textual">. He received a computer science B.S. from the University of Düsseldorf, and a M.S. from the RWTH Aachen.  </textual></para></personblurb><affiliation class="po-record e15 e15"><orgname class="po-block e16 e16"><textual class="po-textual">Institute for Theoretical Computer Science </textual></orgname></affiliation><affiliation class="po-record e17 e17"><orgname class="po-block e18 e18"><textual class="po-textual">Graduate School for Computing in Medicine and Life Sciences, University of Lübeck</textual></orgname></affiliation><email class="po-field e19 e19"><textual class="po-textual">benito@benibela.de</textual></email></author><legalnotice class="po-container e20 e20"><para class="po-block e21 e21"><textual class="po-textual">Copyright © 2014 Benito van der Zander</textual></para></legalnotice><keywordset class="po-table e22 e22" role="author"><keyword class="po-field e23 e23"><textual class="po-textual">Pattern matching</textual></keyword><keyword class="po-field e24 e24"><textual class="po-textual">XQuery syntax extension</textual></keyword><keyword class="po-field e25 e25"><textual class="po-textual">JSONiq syntax extension</textual></keyword><keyword class="po-field e26 e26"><textual class="po-textual">Data mining</textual></keyword></keywordset></info><section class="po-hcontainer e27 e27"><title class="po-block e28 e28"><textual class="po-textual">Introduction</textual></title><para class="po-block e29 e29"><textual class="po-textual">Modern XQuery is becoming a more and more functional programming language. Nowadays it has, for example,  filter and map operators, inline functions, higher order functions and sequence heads/tails. However, it still does not support any kind of pattern matching, although pattern matching is often considered one of the most remarkable features of functional programming. Some of them, like Haskell, even base their entire syntax on it.  In such languages a pattern matching algorithm takes an input value and one or more patterns, and searches the pattern that has the same internal structure as the input value, possibly extracting some data from the value.  </textual></para><para class="po-block e30 e30"><textual class="po-textual">The most similar feature in XQuery is the </textual><code class="po-atom e31 e31"><textual class="po-textual">switch</textual></code><textual class="po-textual"> expression that can be used for atomic values, which branches to a case clause of equal value. But, since it is limited to atomic values, it cannot be used for the majority of data used in XQuery, the XML infosets. </textual></para><para class="po-block e32 e32"><textual class="po-textual">XML Schemas </textual><textual class="po-textual">could be used for matching these XML infosets in path or </textual><code class="po-atom e33 e33"><textual class="po-textual">typeswitch</textual></code><textual class="po-textual">-expressions. However, this matching cannot directly return data from the matched nodes and defining an XML Schema for schema-less input data (like HTML pages) can be cumbersome, since its definition requires an additional file and cannot occur within the XQuery itself. Also the definition of an XML Schema  is not implicit/intuitive like a pattern, but explicit by declaring every element and attribute by a special element, so it cannot really be considered pattern matching. </textual></para><para class="po-block e34 e34"><textual class="po-textual">Sometimes the standard path expressions are called "pattern matching", but this is not correct either, since a path expression is also a list of explicitly applied filtering expressions, not an implicitly defined pattern. </textual></para><para class="po-block e35 e35"><textual class="po-textual">In academics there are various different meanings  of the term "pattern matching", often it is used to denote any specific querying on XML trees, like in  [</textual><xref class="po-milestone e36 e36" linkend="rel2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] or [</textual><xref class="po-milestone e37 e37" linkend="rel3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. Or in another direction, [</textual><xref class="po-milestone e38 e38" linkend="rel1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] considers pattern matching as finding specially ordered subsequences in sequences, similarly to regular expressions on sequences of letters. None of this is pattern matching in our sense. We consider a pattern to be an exemplary part of an XML (HTML, JSON) document that is compared to an input document, detecting if the input document contains the pattern, and which parts of the input document were added. 
     </textual></para><para class="po-block e39 e39"><textual class="po-textual">
     More specifically, but also figuratively, a pattern can be considered a tree with holes, and during matching we must test if the tree of an input document contains the pattern tree as subtree, and which nodes of the document are matched to/fall into  the "holes".
     
</textual><textual class="po-textual"> </textual><textual class="po-textual"> </textual></para><para class="po-block e40 e40"><textual class="po-textual">
     To see examples of such patterns, we need to look outside of XQuery and the common XML research:</textual></para><para class="po-block e41 e41"><textual class="po-textual">One of the first query languages using true XML pattern matching was XML-QL [</textual><xref class="po-milestone e42 e42" linkend="xmlql"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">],   an early attempt to develop an XML query language which combines SQL with XML pattern matching. However it has never evolved beyond drafting state and appears to have been forgotten in favor of XQL the predecessor of XQuery. It is even unclear, if there has ever existed an implementation of XML-QL. Its pattern matching as such is more expressive than ours, but since it cannot use the matched values in a Turing-complete functional language, it is in total less powerful than our system. </textual></para><para class="po-block e43 e43"><textual class="po-textual">Another example is the language Scala [</textual><xref class="po-milestone e44 e44" linkend="scala"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], which tries to combine functional and object-oriented programming concepts. It can perform true pattern matching on all of its objects, and has XML literals as abbreviations for XML elements, so it can naturally  perform pattern matching on XML elements. However, it cannot do this on elements with attributes and is therefore of limited use. </textual></para><para class="po-block e45 e45"><textual class="po-textual">This paper brings these concepts to XQuery by describing a possible syntax for XML pattern matching, how these patterns can return selected data and how these patterns can be used in XQuery in a natural way. We conclude with our experiences of applying these patterns to HTML pages, and possible future work. We do not investigate theoretical implications or efficient ways to implement it, instead we want to develop an easy and powerful syntax that can be practically used.
         </textual></para><para class="po-block e46 e46"><textual class="po-textual">The pattern matching described here</textual><textual class="po-textual"> is an idealized variant of the actual pattern matching in our implementation</textual><footnote class="po-popup e47 e47"><para class="po-block e48 e48"><textual class="po-textual">Available as standalone version under the name "</textual><link class="po-inline e49 e49" xlink:actuate="onRequest" xlink:href="http://xidel.sourceforge.net" xlink:show="new" xlink:type="simple"><textual class="po-textual">Xidel</textual></link><textual class="po-textual">" as command line tool and </textual><link class="po-inline e50 e50" xlink:actuate="onRequest" xlink:href="http://videlibri.sourceforge.net/cgi-bin/xidelcgi" xlink:show="new" xlink:type="simple"><textual class="po-textual">webservice</textual></link><textual class="po-textual">, and under the name "</textual><link class="po-inline e51 e51" xlink:actuate="onRequest" xlink:href="https://github.com/benibela/internettools" xlink:show="new" xlink:type="simple"><textual class="po-textual">Internet Tools</textual></link><textual class="po-textual">" as  GPL library for FreePascal.</textual></para></footnote><textual class="po-textual">. On the one hand, some logical extensions explained here have not  yet been implemented, and on the other hand, our implementation has features we do not mention, because they are deprecated or would cause confusion.	</textual></para><para class="po-block e52 e52"><textual class="po-textual">We assume the reader is familiar with the XML  [</textual><xref class="po-milestone e53 e53" linkend="xml"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], XQuery  [</textual><xref class="po-milestone e54 e54" linkend="xquery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and JSONiq  [</textual><xref class="po-milestone e55 e55" linkend="jsoniq"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] standards, so terms and definitions given there will not be repeated.</textual></para></section><section class="po-hcontainer e56 e56"><title class="po-block e57 e57"><textual class="po-textual">The pattern syntax</textual></title><para class="po-block e58 e58"><textual class="po-textual">Our goal is to develop a pattern syntax that fulfills the following three properties:</textual></para><itemizedlist class="po-table e59 e59"><listitem class="po-container e60 e60"><para class="po-block e61 e61"><emphasis class="po-inline e62 e62"><textual class="po-textual">Intuitive</textual></emphasis><textual class="po-textual">:</textual></para><para class="po-block e63 e63"><textual class="po-textual"> It should be obvious which data a pattern could match, even if you have never seen a pattern before. We realize this, first, by requiring that  a (basic) pattern has to match itself, if the pattern is given as input. Therefore the pattern is an illustrative example for itself. </textual><textual class="po-textual"> And, second, by basing most of the syntax on regular expressions which should be familiar to any programmer.</textual></para></listitem><listitem class="po-container e64 e64"><para class="po-block e65 e65"><emphasis class="po-inline e66 e66"><textual class="po-textual">Validating</textual></emphasis><textual class="po-textual">:</textual></para><para class="po-block e67 e67"><textual class="po-textual">When matched against not-matching, unexpected input data the pattern should raise an error, instead returning something arbitrary. (unlike a simple path expression that returns an empty sequence on failure.  )</textual></para></listitem><listitem class="po-container e68 e68"><para class="po-block e69 e69"><emphasis class="po-inline e70 e70"><textual class="po-textual">Minimal</textual></emphasis><textual class="po-textual">:</textual></para><para class="po-block e71 e71"><textual class="po-textual"> There should be no pointless redundancy or data not relevant to the query within a pattern. This means that all additional data in the input should be ignored during matching, so we can exclude unimportant data from the pattern.</textual></para></listitem></itemizedlist><para class="po-block e72 e72"><textual class="po-textual">From the first and third property (and later given examples) it follows that it is also easy to create a pattern to match a given input, since the pattern can be created by copying the input data, completely removing all data that should not be queried for, replacing the remaining data with annotations and finally calling it a pattern. We hope that this is even easy for people who only have knowledge of XML/HTML and no real programming language, since they do not have to write anything new,  contrary to a path expression.</textual></para><para class="po-block e73 e73"><textual class="po-textual">There is, however, a conflict between the second and third property, which cannot be resolved in general. By ignoring additional data a pattern might match a completely different input document successfully, which was not intended to be accepted as a match, but contains matching data somewhere within it. So for any actual pattern, it must be carefully decided what to include and exclude from the pattern. Nevertheless the third property is important, because the (HTML) documents we are processing contain far too much noise to include it all in the pattern. </textual></para><section class="po-hcontainer e74 e74" xml:id="sec_basic"><title class="po-block e75 e75"><textual class="po-textual">Basic node matching</textual></title><para class="po-block e76 e76"><textual class="po-textual">Due to the intuitiveness goal the pattern itself has to be a well-formed XML document (resp. fragment). We can therefore define the basic "matching" as recursive relation between a node of the pattern and a node of the input as follows:</textual></para><itemizedlist class="po-table e77 e77"><listitem class="po-container e78 e78"><para class="po-block e79 e79"><textual class="po-textual">
      A </textual><emphasis class="po-inline e80 e80"><textual class="po-textual">text node</textual></emphasis><textual class="po-textual"> matches another text node, if they have matching string values.
      </textual></para></listitem><listitem class="po-container e81 e81"><para class="po-block e82 e82"><textual class="po-textual">
      An </textual><emphasis class="po-inline e83 e83"><textual class="po-textual">attribute</textual></emphasis><textual class="po-textual"> matches another attribute, if they have the same name and matching string values. 
      </textual></para></listitem><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">
</textual><textual class="po-textual">
      An  </textual><emphasis class="po-inline e86 e86"><textual class="po-textual">element</textual></emphasis><textual class="po-textual"> </textual><code class="po-atom e87 e87"><textual class="po-textual">E</textual></code><textual class="po-textual"> matches another element </textual><code class="po-atom e88 e88"><textual class="po-textual">F</textual></code><textual class="po-textual">, if they have the same name, every attribute of </textual><code class="po-atom e89 e89"><textual class="po-textual">E</textual></code><textual class="po-textual"> matches an attribute of </textual><code class="po-atom e90 e90"><textual class="po-textual">F</textual></code><textual class="po-textual"> and every child of </textual><code class="po-atom e91 e91"><textual class="po-textual">E</textual></code><textual class="po-textual"> matches a descendant of </textual><code class="po-atom e92 e92"><textual class="po-textual">F</textual></code><textual class="po-textual"> in order. </textual><textual class="po-textual"> </textual><textual class="po-textual">
      </textual></para></listitem></itemizedlist><para class="po-block e93 e93"><textual class="po-textual">An exact definition for "matching string values" is given below. The property "in order" of the last point means: if a child </textual><code class="po-atom e94 e94"><textual class="po-textual">C</textual></code><textual class="po-textual"> of </textual><code class="po-atom e95 e95"><textual class="po-textual">E</textual></code><textual class="po-textual"> matches a descendant </textual><code class="po-atom e96 e96"><textual class="po-textual">X</textual></code><textual class="po-textual"> of </textual><code class="po-atom e97 e97"><textual class="po-textual">F</textual></code><textual class="po-textual"> and another child </textual><code class="po-atom e98 e98"><textual class="po-textual">D</textual></code><textual class="po-textual"> of </textual><code class="po-atom e99 e99"><textual class="po-textual">E</textual></code><textual class="po-textual"> matches a descendant </textual><code class="po-atom e100 e100"><textual class="po-textual">Y</textual></code><textual class="po-textual"> of </textual><code class="po-atom e101 e101"><textual class="po-textual">F</textual></code><textual class="po-textual">, </textual><code class="po-atom e102 e102"><textual class="po-textual">C</textual></code><textual class="po-textual"> precedes </textual><code class="po-atom e103 e103"><textual class="po-textual">D</textual></code><textual class="po-textual"> in the pattern if and only if </textual><code class="po-atom e104 e104"><textual class="po-textual">X</textual></code><textual class="po-textual"> precedes </textual><code class="po-atom e105 e105"><textual class="po-textual">Y</textual></code><textual class="po-textual"> in the document. </textual></para><para class="po-block e106 e106"><textual class="po-textual">
      Trivial examples are the pattern </textual><code class="po-atom e107 e107"><textual class="po-textual">&lt;foo/&gt;</textual></code><textual class="po-textual"> matching an identical input document </textual><code class="po-atom e108 e108"><textual class="po-textual">&lt;foo/&gt;</textual></code><textual class="po-textual"> or a text node pattern </textual><code class="po-atom e109 e109"><textual class="po-textual">foo</textual></code><textual class="po-textual"> matching an identical text node </textual><code class="po-atom e110 e110"><textual class="po-textual">foo</textual></code><textual class="po-textual">.
      A more meaningful example is the pattern
      
      </textual><programlisting class="po-block e111 e111" xml:space="preserve"><textual class="po-textual">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</textual></programlisting><textual class="po-textual">
      
      that matches </textual><programlisting class="po-block e112 e112" xml:space="preserve"><textual class="po-textual">&lt;element foo="bar"&gt;cat&lt;meow/&gt;&lt;/element&gt;</textual></programlisting><textual class="po-textual"> or (ignoring additional data) </textual><programlisting class="po-block e113 e113" xml:space="preserve"><textual class="po-textual">&lt;element foo="bar" att="value"&gt;&lt;p&gt;cat&lt;call&gt;&lt;meow loudness="60 dB"/&gt;&lt;/call&gt;&lt;/p&gt;&lt;/element&gt;</textual></programlisting><textual class="po-textual"> but neither (missing attribute) </textual><programlisting class="po-block e114 e114" xml:space="preserve"><textual class="po-textual">&lt;element&gt;cat&lt;meow/&gt;&lt;/element&gt;</textual></programlisting><textual class="po-textual"> nor (wrong name) </textual><programlisting class="po-block e115 e115" xml:space="preserve"><textual class="po-textual">&lt;element foo="bar" xmlns="elsewhere"&gt;cat&lt;meow/&gt;&lt;/element&gt;</textual></programlisting><textual class="po-textual"> nor (wrong order of descendants) </textual><programlisting class="po-block e116 e116" xml:space="preserve"><textual class="po-textual">&lt;element foo="bar"&gt;&lt;meow/&gt;cat&lt;/element&gt;</textual></programlisting><textual class="po-textual">
</textual><textual class="po-textual">
      </textual></para><para class="po-block e117 e117"><textual class="po-textual">
      We have not considered a syntax to match comment or processing-instruction nodes, since such nodes rarely contain data that should be returned by a query and    cannot contain a selector expression (see </textual><link class="po-inline e118 e118" linkend="sec_selection" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">below</textual></link><textual class="po-textual">) as a child to select this data. Also the most natural way to match a comment node would be to include an </textual><code class="po-atom e119 e119"><textual class="po-textual">&lt;!-- .. --&gt;</textual></code><textual class="po-textual"> XML comment node in the pattern, which is problematic in our application, because we use standalone patterns outside of XQuery, where  we prefer to use XML comments as actual comments that are ignored by the matching process. There is also no syntax to match document nodes, since it is always possible to match the root node of the document instead. </textual></para><para class="po-block e120 e120"><textual class="po-textual">That a child in the pattern is allowed to match any descendant in the input, not only another child, follows the principle of ignoring additional data to keep the pattern minimal. </textual></para><para class="po-block e121 e121"><textual class="po-textual">Requiring that the descendants have to occur in the same order as the children, instead accepting any order, has a few benefits. First, it follows the idea of patterns as XML regular expressions, which also match their letters ordered. Second, XQuery itself is good at selecting unordered elements, but very difficult [</textual><xref class="po-milestone e122 e122" linkend="rel1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] to use to select ordered elements</textual><footnote class="po-popup e123 e123"><para class="po-block e124 e124"><textual class="po-textual">Many people do not even understand how to use the </textual><code class="po-atom e125 e125"><textual class="po-textual">following</textual></code><textual class="po-textual"> or </textual><code class="po-atom e126 e126"><textual class="po-textual">preceding</textual></code><textual class="po-textual"> axes, which becomes evident after watching   XPath questions on stackoverflow for a while.</textual></para></footnote><textual class="po-textual">, so the combination of XPath and patterns provides a simple and powerful solution for both cases. Third, the advanced pattern syntax contains natural, </textual><link class="po-inline e127 e127" linkend="para_unordered" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">unrelated features</textual></link><textual class="po-textual"> that can directly be used for unordered matching. It is doubtful that unordered matching could be used for ordered matching in such a way. </textual></para><para class="po-block e128 e128"><textual class="po-textual">The conditions for text node matching could be relaxed to accept any node that has a matching string value, not just other text nodes. This might be useful, if the input data could sometimes contain markups like </textual><code class="po-atom e129 e129"><textual class="po-textual">&lt;em&gt;</textual></code><textual class="po-textual"> within the text and sometimes not. However, we have not seen such a use case, and therefore have implemented the faster way to match text nodes only to text nodes.</textual></para><para class="po-block e130 e130"><textual class="po-textual">
      </textual><emphasis class="po-inline e131 e131"><textual class="po-textual">String values</textual></emphasis><textual class="po-textual"> can be matched using one of six different modes: </textual><code class="po-atom e132 e132"><textual class="po-textual">eq</textual></code><textual class="po-textual">, </textual><code class="po-atom e133 e133"><textual class="po-textual">matches</textual></code><textual class="po-textual">, </textual><code class="po-atom e134 e134"><textual class="po-textual">starts-with</textual></code><textual class="po-textual">, </textual><code class="po-atom e135 e135"><textual class="po-textual">ends-with</textual></code><textual class="po-textual">, </textual><code class="po-atom e136 e136"><textual class="po-textual">contains</textual></code><textual class="po-textual"> and </textual><code class="po-atom e137 e137"><textual class="po-textual">list-contains</textual></code><textual class="po-textual">. </textual><code class="po-atom e138 e138"><textual class="po-textual">eq</textual></code><textual class="po-textual"> checks for an exact match, like the </textual><code class="po-atom e139 e139"><textual class="po-textual">eq</textual></code><textual class="po-textual"> operator. </textual><code class="po-atom e140 e140"><textual class="po-textual">list-contains</textual></code><textual class="po-textual"> treats the string value as space separated list (e.g. like the class attribute of HTML elements) and matches, if the value of the pattern occurs in that list. The other modes match, if the call to the corresponding XQuery function, e.g. </textual><code class="po-atom e141 e141"><textual class="po-textual">fn:starts-with($value, $pattern)</textual></code><textual class="po-textual">, returns </textual><code class="po-atom e142 e142"><textual class="po-textual">true</textual></code><textual class="po-textual">.
      
      Additionally the matching can be case-sensitive or case-insensitive, in latter case, the values are first converted to lowercase resp. the </textual><code class="po-atom e143 e143"><textual class="po-textual">i</textual></code><textual class="po-textual"> flag is passed to </textual><code class="po-atom e144 e144"><textual class="po-textual">fn:matches</textual></code><textual class="po-textual">.
      </textual></para><para class="po-block e145 e145"><textual class="po-textual">
      Which  mode is chosen depends on the node whose string value is matched and the local settings. Due to legacy reasons, the default modes of our implementation are </textual><code class="po-atom e146 e146"><textual class="po-textual">starts-with</textual></code><textual class="po-textual"> for text nodes, </textual><code class="po-atom e147 e147"><textual class="po-textual">list-contains</textual></code><textual class="po-textual"> for </textual><code class="po-atom e148 e148"><textual class="po-textual">class</textual></code><textual class="po-textual">-attributes and </textual><code class="po-atom e149 e149"><textual class="po-textual">eq</textual></code><textual class="po-textual"> for all other attributes</textual><footnote class="po-popup e150 e150"><para class="po-block e151 e151"><textual class="po-textual">However, in a new, not HTML-focused implementation </textual><code class="po-atom e152 e152"><textual class="po-textual">matches</textual></code><textual class="po-textual"> as default for everything might be a more reasonable choice.</textual></para></footnote><textual class="po-textual">. These modes can be changed within a pattern, similarly to the options described </textual><link class="po-inline e153 e153" linkend="tmeta" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">below</textual></link><textual class="po-textual">.
      </textual></para><para class="po-block e154 e154"><textual class="po-textual">There is no difference between matching a pattern to an XML document and matching it against a HTML document, except that node names are compared case sensitive for XML and case insensitive for HTML. </textual></para></section><section class="po-hcontainer e155 e155" xml:id="sec_selection"><title class="po-block e156 e156"><textual class="po-textual">Selecting data</textual></title><para class="po-block e157 e157"><textual class="po-textual">So far we have only described how a pattern can be used to test if an input document has a certain structure. To become a real replacement for standard XPath selectors, we need a way to select specific data from the matches in the input document. In regular expressions such selecting can be done with capture groups, an idea  we need to transfer to the pattern syntax. </textual><textual class="po-textual"> </textual><textual class="po-textual">
       </textual><textual class="po-textual">
        </textual></para><para class="po-block e158 e158"><textual class="po-textual">For this we allow the  embedding of arbitrary XQuery expressions which will be evaluated in the context of partial matches and whose return values become the return values of the pattern matching. So in  case someone needs a query that does not just copy the matched data from the input document, but needs to perform certain calculations with the data, he can do it with all the power of XQuery. </textual></para><para class="po-block e159 e159"><textual class="po-textual">We have decided to allow the following ways to embed a query in the pattern:</textual></para><para class="po-block e160 e160"><textual class="po-textual">
      
      </textual><itemizedlist class="po-table e161 e161"><listitem class="po-container e162 e162"><para class="po-block e163 e163"><code class="po-atom e164 e164"><textual class="po-textual">{expression}</textual></code><textual class="po-textual">: A text node starting with </textual><code class="po-atom e165 e165"><textual class="po-textual">{</textual></code><textual class="po-textual"> and ending with </textual><code class="po-atom e166 e166"><textual class="po-textual">}</textual></code><textual class="po-textual"> is the shortest syntax to include an expression. The </textual><code class="po-atom e167 e167"><textual class="po-textual">{}</textual></code><textual class="po-textual"> parentheses are used, because they correspond to the expression in a standard XQuery element constructor, and, more important, because every string starting with </textual><code class="po-atom e168 e168"><textual class="po-textual">{</textual></code><textual class="po-textual"> is an invalid regular expression. So there is never a collision between a regular expression used to match text nodes and a selector expression.  </textual></para></listitem><listitem class="po-container e169 e169"><para class="po-block e170 e170"><code class="po-atom e171 e171"><textual class="po-textual">&lt;template:s&gt;expression&lt;/template:s&gt;</textual></code><textual class="po-textual">: A more standard syntax to include queries in an XML document. Although the </textual><code class="po-atom e172 e172"><textual class="po-textual">{...}</textual></code><textual class="po-textual"> syntax does not collide with regex text matching, it is sometimes problematic to use. For example, if you want to have a text node for matching and a selector expression in the same parent node. So we have added the </textual><code class="po-atom e173 e173"><textual class="po-textual">&lt;s&gt;</textual></code><textual class="po-textual">-element in the namespace </textual><code class="po-atom e174 e174"><textual class="po-textual">http://www.benibela.de/2011/templateparser</textual></code><textual class="po-textual"> (at default bound to the namespace prefixes </textual><code class="po-atom e175 e175"><textual class="po-textual">template</textual></code><footnote class="po-popup e176 e176"><para class="po-block e177 e177"><textual class="po-textual">We usually refer to the patterns as "templates" in our implementation. However, "pattern" is a more appropriate term. </textual></para></footnote><textual class="po-textual"> and </textual><code class="po-atom e178 e178"><textual class="po-textual">t</textual></code><textual class="po-textual">) that can also contain an expression.</textual></para></listitem><listitem class="po-container e179 e179"><para class="po-block e180 e180"><code class="po-atom e181 e181"><textual class="po-textual">&lt;t:s&gt;expression&lt;/t:s&gt;</textual></code><textual class="po-textual">:  This is actually identical to  </textual><code class="po-atom e182 e182"><textual class="po-textual">&lt;template:s&gt;expression&lt;/template:s&gt;</textual></code><textual class="po-textual"> due to binding the same namespace to prefixes </textual><code class="po-atom e183 e183"><textual class="po-textual">template</textual></code><textual class="po-textual"> and </textual><code class="po-atom e184 e184"><textual class="po-textual">t</textual></code><textual class="po-textual">, but faster to write being the shortest name a node  outside the default namespace can have. </textual></para></listitem><listitem class="po-container e185 e185"><para class="po-block e186 e186"><code class="po-atom e187 e187"><textual class="po-textual">attribute="{expression}"</textual></code><textual class="po-textual">: The </textual><code class="po-atom e188 e188"><textual class="po-textual">{}</textual></code><textual class="po-textual"> syntax can also be used in attributes. In that case the attribute is replaced by a </textual><code class="po-atom e189 e189"><textual class="po-textual">t:condition</textual></code><textual class="po-textual"> attribute (see </textual><link class="po-inline e190 e190" linkend="tcondition" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">below</textual></link><textual class="po-textual">) just checking the existence of the old attribute, and a </textual><code class="po-atom e191 e191"><textual class="po-textual">&lt;t:s&gt;@attribute / (expression) &lt;/t:s&gt;</textual></code><textual class="po-textual"> child node is inserted instead. E.g. </textual><code class="po-atom e192 e192"><textual class="po-textual">&lt;a href="{.}"/&gt;</textual></code><textual class="po-textual"> to query for the url of a link target. </textual></para></listitem></itemizedlist><textual class="po-textual">
            
      </textual></para><para class="po-block e193 e193"><textual class="po-textual">After the matching process each node of the pattern has been matched to a unique node of the input data. This node is then set as context item </textual><code class="po-atom e194 e194"><textual class="po-textual">.</textual></code><textual class="po-textual"> when evaluating the query contained in the children of the pattern node and the result of these queries is returned as result of the pattern. </textual></para><para class="po-block e195 e195"><textual class="po-textual">With this definition we can for example already write </textual><programlisting class="po-block e196 e196" xml:space="preserve"><textual class="po-textual">&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual"> as a  pattern query for the first  </textual><code class="po-atom e197 e197"><textual class="po-textual">b</textual></code><textual class="po-textual">-element contained in an </textual><code class="po-atom e198 e198"><textual class="po-textual">a</textual></code><textual class="po-textual">-element</textual><footnote class="po-popup e199 e199"><para class="po-block e200 e200"><textual class="po-textual">The content of the b-element, i.es. a sequence of all its children, might be more natural, but it cannot be assigned to the context item.</textual></para></footnote><textual class="po-textual">, e.g. it returns </textual><code class="po-atom e201 e201"><textual class="po-textual">&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;</textual></code><textual class="po-textual"> on input </textual><programlisting class="po-block e202 e202" xml:space="preserve"><textual class="po-textual">&lt;a&gt;&lt;b&gt;foo&lt;br/&gt;bar&lt;/b&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual">. Using the longer syntax, we get example patterns
      </textual><programlisting class="po-block e203 e203" xml:space="preserve"><textual class="po-textual">&lt;a&gt;&lt;b&gt;&lt;t:s&gt;.&lt;/t:s&gt;&lt;/b&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual"> and </textual><programlisting class="po-block e204 e204" xml:space="preserve"><textual class="po-textual">&lt;a&gt;&lt;b&gt;&lt;template:s&gt;.&lt;/template:s&gt;&lt;/b&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual"> that are matched in exactly the same way as the first example pattern.</textual></para><para class="po-block e205 e205"><textual class="po-textual">An example for the attribute variant is </textual><programlisting class="po-block e206 e206" xml:space="preserve"><textual class="po-textual">&lt;a href="{.}"/&gt;</textual></programlisting><textual class="po-textual"> which returns an attribute node </textual><code class="po-atom e207 e207"><textual class="po-textual">href="http://balisage.net/"</textual></code><textual class="po-textual"> when matched against </textual><programlisting class="po-block e208 e208" xml:space="preserve"><textual class="po-textual">&lt;html&gt;Some text&lt;p&gt;&lt;a href="http://balisage.net/"&gt;title&lt;/a&gt;&lt;/p&gt;&lt;/html&gt;</textual></programlisting><textual class="po-textual">.</textual></para><para class="po-block e209 e209"><textual class="po-textual">A combined example is the pattern </textual><programlisting class="po-block e210 e210" xml:space="preserve"><textual class="po-textual">&lt;a href="{.}"&gt;{concat("=&gt; ", .)}&lt;/a&gt;</textual></programlisting><textual class="po-textual"> which would return an attribute node </textual><code class="po-atom e211 e211"><textual class="po-textual">href="http://balisage.net/"</textual></code><textual class="po-textual"> as well as a string value </textual><code class="po-atom e212 e212"><textual class="po-textual">"=&gt; title"</textual></code><textual class="po-textual">.</textual></para><para class="po-block e213 e213"><textual class="po-textual">Someone who is familiar with  XQuery's handling of sequences might now wonder what happens when a pattern has multiple selector expressions that all return a sequence. Does the pattern return multiple sequences? Is that even possible? Does it return a single sequence of all sequences flattened together?</textual></para><para class="po-block e214 e214"><textual class="po-textual">We prefer former case, because it makes it possible to combine multiple patterns to a single one. However, multiple sequences cannot really be handled with standard XQuery data types, so we have decided to extend the XQuery syntax to create some kind of named return values. </textual></para><para class="po-block e215 e215"><textual class="po-textual">
      </textual><textual class="po-textual">
       Thus we have added variable assignments </textual><code class="po-atom e216 e216"><textual class="po-textual">$variable := expression</textual></code><textual class="po-textual"> which evaluate the expression on the right hand side and assign it to a global variable on the left hand side.  The priority of the </textual><code class="po-atom e217 e217"><textual class="po-textual">:=</textual></code><textual class="po-textual"> operator is set to be lower than the priority of every existing operator. More formally, we have introduced these extensions to the XQuery EBNF:
      
      </textual><programlisting class="po-block e218 e218" xml:space="preserve"><textual class="po-textual">ExprSingle         ::= FLWORExpr | QuantifiedExpr | SwitchExpr | TypeswitchExpr | IfExpr | TryCatchExpr | VarAssignmentExpr
VarAssignmentExpr  ::= (VarRef ":=" )* OrExpr
VarRef             ::= "$" VarName   </textual></programlisting><textual class="po-textual">
 
      Now we can return multiple sequences by assigning these sequences to variables, e.g. </textual><code class="po-atom e219 e219"><textual class="po-textual">{$var1 := (1,2,3), $var2 := (4,5,6)}</textual></code><textual class="po-textual">. </textual></para><para class="po-block e220 e220"><textual class="po-textual">This leaves the question, what happens, when there are multiple assignments to the same variable. We will later see that in </textual><link class="po-inline e221 e221" linkend="tloop" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">loops</textual></link><textual class="po-textual"> every selector expression is evaluated multiple times, so the most reasonable way is to return two different variables with the same name. Although in most of the </textual><link class="po-inline e222 e222" linkend="integration" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">XQuery syntax extension</textual></link><textual class="po-textual"> this is not possible, we prefer to do it, where possible. So e.g. </textual><code class="po-atom e223 e223"><textual class="po-textual">{$x := (1,2), $x := (3,4)}</textual></code><textual class="po-textual"> also returns two different sequences. This is easier to understand, when the variable assignments are not considered as creating actual variables, but as creating a name+value pair (like a  map with one element) and adding it to a sequence. Since the pairs are not sequences themselves, they are not flattened. </textual></para><para class="po-block e224 e224"><textual class="po-textual">
      However, always writing </textual><code class="po-atom e225 e225"><textual class="po-textual">{$var := expr}</textual></code><textual class="po-textual"> would be  cumbersome, especially after seeing the </textual><code class="po-atom e226 e226"><textual class="po-textual">{.}</textual></code><textual class="po-textual"> examples above. So we have added two abbreviations</textual><footnote class="po-popup e227 e227"><para class="po-block e228 e228"><textual class="po-textual">They also apply to </textual><code class="po-atom e229 e229"><textual class="po-textual">&lt;t:s&gt;</textual></code><textual class="po-textual">-expressions, but in the following we will restrict ourselves to </textual><code class="po-atom e230 e230"><textual class="po-textual">{..}</textual></code><textual class="po-textual"> for breverity</textual></para></footnote><textual class="po-textual">:
      
      </textual><itemizedlist class="po-table e231 e231"><listitem class="po-container e232 e232"><para class="po-block e233 e233"><code class="po-atom e234 e234"><textual class="po-textual">{expression}</textual></code><textual class="po-textual"> not containing </textual><code class="po-atom e235 e235"><textual class="po-textual">:=</textual></code><textual class="po-textual">: An expression without assignment is replaced by an assignment </textual><code class="po-atom e236 e236"><textual class="po-textual">{$result := expression}</textual></code><textual class="po-textual"> to a default variable </textual><code class="po-atom e237 e237"><textual class="po-textual">$result</textual></code><textual class="po-textual">. The name of the default variable is configurable, and later we will even extend it to assignments to the context item </textual><code class="po-atom e238 e238"><textual class="po-textual">.</textual></code><textual class="po-textual"> itself. </textual></para></listitem><listitem class="po-container e239 e239"><para class="po-block e240 e240"><code class="po-atom e241 e241"><textual class="po-textual">{$variable}</textual></code><textual class="po-textual">: A selector expression containing exactly one variable is replaced by </textual><code class="po-atom e242 e242"><textual class="po-textual">{$variable := .}</textual></code></para></listitem></itemizedlist><textual class="po-textual">
       
      With this definition, the meaning of </textual><code class="po-atom e243 e243"><textual class="po-textual">{.}</textual></code><textual class="po-textual"> is implied and does not need to be defined explicitly, and the above example pattern </textual><code class="po-atom e244 e244"><textual class="po-textual">&lt;a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/a&gt;</textual></code><textual class="po-textual"> returns the </textual><code class="po-atom e245 e245"><textual class="po-textual">b</textual></code><textual class="po-textual">-element in the default variable (if the matching does not fail). Like the XQuery expression </textual><code class="po-atom e246 e246"><textual class="po-textual">let $result := exactly-one(((//a)[1]//b)[1]) return ...</textual></code><textual class="po-textual"> (but we will omit the </textual><code class="po-atom e247 e247"><textual class="po-textual">let $result :=</textual></code><textual class="po-textual"> prefix in the remaining of the paper for brevity). 
      </textual></para><para class="po-block e248 e248"><textual class="po-textual">
      Another example is </textual><programlisting class="po-block e249 e249" xml:space="preserve"><textual class="po-textual">&lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;/root&gt;</textual></programlisting><textual class="po-textual"> returning the first </textual><code class="po-atom e250 e250"><textual class="po-textual">a</textual></code><textual class="po-textual">-element in </textual><code class="po-atom e251 e251"><textual class="po-textual">$a</textual></code><textual class="po-textual"> and a following </textual><code class="po-atom e252 e252"><textual class="po-textual">b</textual></code><textual class="po-textual">-element in </textual><code class="po-atom e253 e253"><textual class="po-textual">$b</textual></code><textual class="po-textual">. It is equivalent to the XQuery expression
      </textual><programlisting class="po-block e254 e254" xml:space="preserve"><textual class="po-textual">let $a := exactly-one(((//root)[1]//a)[1]),  
    $b := exactly-one(($a/following::b)[1] intersect (//root)[1]//b)
return ...</textual></programlisting><textual class="po-textual">
      This example also shows how awkward it is to simultaneously encode the order requirement (</textual><code class="po-atom e255 e255"><textual class="po-textual">b</textual></code><textual class="po-textual"> following </textual><code class="po-atom e256 e256"><textual class="po-textual">a</textual></code><textual class="po-textual">) as well as the descendant requirement (</textual><code class="po-atom e257 e257"><textual class="po-textual">a</textual></code><textual class="po-textual"> and </textual><code class="po-atom e258 e258"><textual class="po-textual">b</textual></code><textual class="po-textual"> being descendants of </textual><code class="po-atom e259 e259"><textual class="po-textual">root</textual></code><textual class="po-textual">) in standard XQuery</textual><footnote class="po-popup e260 e260"><para class="po-block e261 e261"><code class="po-atom e262 e262"><textual class="po-textual">following-sibling::</textual></code><textual class="po-textual"> cannot be used, since it encodes a sibling not a descendant relationship.</textual></para></footnote><textual class="po-textual">.
      </textual></para><para class="po-block e263 e263"><textual class="po-textual">So in the end the matching process either raises an matching error or returns a list of variable assignments </textual><programlisting class="po-block e264 e264" xml:space="preserve"><textual class="po-textual">$var1 := value1
$var2 := value2
... </textual></programlisting><textual class="po-textual">. We call this list "assignment stream", since it is similar to a  tuple stream of a flower expression except that it involves different variables.</textual></para></section><section class="po-hcontainer e265 e265" xml:id="sec_advanced"><title class="po-block e266 e266"><textual class="po-textual">Advanced patterns</textual></title><para class="po-block e267 e267"><textual class="po-textual">The previous sections have explained the basic matching of individual elements, in which each node of the pattern is matched to exactly one node in the input data. But in practical applications it is necessary to return data that does not have a 1-1 relationship with the query itself. For this the patterns have various syntaxes which are explained in this section:</textual></para><section class="po-hcontainer e268 e268"><title class="po-block e269 e269"><textual class="po-textual">Optional elements</textual></title><para class="po-block e270 e270"><textual class="po-textual">An optional element is optional, i.e. if a match for the element exists in the input, the element is matched as usual, otherwise it is ignored.</textual></para><para class="po-block e271 e271"><textual class="po-textual">
      There are two ways to mark an element as optional:
      
      </textual><itemizedlist class="po-table e272 e272"><listitem class="po-container e273 e273"><para class="po-block e274 e274"><code class="po-atom e275 e275"><textual class="po-textual">?</textual></code><textual class="po-textual">: The element is followed by a </textual><code class="po-atom e276 e276"><textual class="po-textual">?</textual></code><textual class="po-textual">, e.g.: </textual><code class="po-atom e277 e277"><textual class="po-textual">&lt;element/&gt;?</textual></code></para></listitem><listitem class="po-container e278 e278"><para class="po-block e279 e279"><code class="po-atom e280 e280"><textual class="po-textual">t:optional = "true"</textual></code><textual class="po-textual">: It has an </textual><code class="po-atom e281 e281"><textual class="po-textual">optional</textual></code><textual class="po-textual"> attribute, e.g.: </textual><code class="po-atom e282 e282"><textual class="po-textual">&lt;element t:optional="true"/&gt;</textual></code><textual class="po-textual"> or </textual><code class="po-atom e283 e283"><textual class="po-textual">&lt;element template:optional="true"/&gt;</textual></code></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e284 e284"><code class="po-atom e285 e285"><textual class="po-textual">?</textual></code><textual class="po-textual"> as marker does not conflict with text node matching, since regular expressions cannot start with a question mark.</textual></para><para class="po-block e286 e286"><textual class="po-textual">A naive implementation can match optional elements first as non-optional, and if that fails with a matching error, skip the element in the pattern and match it again. 
         </textual></para></section><section class="po-hcontainer e287 e287" xml:id="tloop"><title class="po-block e288 e288"><textual class="po-textual">Repeated elements</textual></title><para class="po-block e289 e289"><textual class="po-textual">With the patterns described so far, we can only apply a selector expression to a single element of the input document and therefore only return a single value with a simple selector like </textual><code class="po-atom e290 e290"><textual class="po-textual">{.}</textual></code><textual class="po-textual"> or </textual><code class="po-atom e291 e291"><textual class="po-textual">{$var}</textual></code><textual class="po-textual">, although the input usually contains many elements, which all should be examined by a query. In fact returning multiple elements is considered so important that it easier to select all elements than only the first element with standard path expressions. So the patterns need to be extended to be able to match multiple elements.</textual></para><para class="po-block e292 e292"><textual class="po-textual">
            For this we introduce a notation similar to regular expressions:
      
      </textual><itemizedlist class="po-table e293 e293"><listitem class="po-container e294 e294"><para class="po-block e295 e295"><code class="po-atom e296 e296"><textual class="po-textual">*</textual></code><textual class="po-textual">: The preceding element can be repeated arbitrary many times.  E.g.  </textual><code class="po-atom e297 e297"><textual class="po-textual">&lt;element/&gt;*</textual></code></para></listitem><listitem class="po-container e298 e298"><para class="po-block e299 e299"><code class="po-atom e300 e300"><textual class="po-textual">+</textual></code><textual class="po-textual">: The preceding element can be repeated once or more times. E.g.  </textual><code class="po-atom e301 e301"><textual class="po-textual">&lt;element/&gt;+</textual></code></para></listitem><listitem class="po-container e302 e302"><para class="po-block e303 e303"><code class="po-atom e304 e304"><textual class="po-textual">{min, max}</textual></code><textual class="po-textual">: The preceding element is repeated between min and max times. E.g. </textual><code class="po-atom e305 e305"><textual class="po-textual">&lt;element/&gt;{1,3}</textual></code></para></listitem><listitem class="po-container e306 e306"><para class="po-block e307 e307"><code class="po-atom e308 e308"><textual class="po-textual">{count}</textual></code><textual class="po-textual">: The preceding element is repeated exactly count times. E.g. </textual><code class="po-atom e309 e309"><textual class="po-textual">&lt;element/&gt;{3}</textual></code><textual class="po-textual"> is equivalent to </textual><code class="po-atom e310 e310"><textual class="po-textual">&lt;element/&gt;&lt;element/&gt;&lt;element/&gt;</textual></code></para></listitem><listitem class="po-container e311 e311"><para class="po-block e312 e312"><code class="po-atom e313 e313"><textual class="po-textual">&lt;t:loop [min=".."] [max=""]&gt; ... &lt;/t:loop&gt;</textual></code><textual class="po-textual">: The child elements are matched at least </textual><code class="po-atom e314 e314"><textual class="po-textual">@min</textual></code><textual class="po-textual"> and at most </textual><code class="po-atom e315 e315"><textual class="po-textual">@max</textual></code><textual class="po-textual"> times. A missing </textual><code class="po-atom e316 e316"><textual class="po-textual">min</textual></code><textual class="po-textual"> attribute is interpreted as 0, and a missing </textual><code class="po-atom e317 e317"><textual class="po-textual">max</textual></code><textual class="po-textual"> attribute as infinite. E.g. </textual><code class="po-atom e318 e318"><textual class="po-textual">&lt;t:loop min="1"&gt;&lt;tr/&gt;&lt;/t:loop&gt; </textual></code><textual class="po-textual"> </textual></para></listitem></itemizedlist></para><para class="po-block e319 e319"><textual class="po-textual">Using these symbols is unproblematic like </textual><code class="po-atom e320 e320"><textual class="po-textual">?</textual></code><textual class="po-textual"> for optionality and </textual><code class="po-atom e321 e321"><textual class="po-textual">{}</textual></code><textual class="po-textual"> for selector expressions, since no regular expression can start with </textual><code class="po-atom e322 e322"><textual class="po-textual">+</textual></code><textual class="po-textual"> or </textual><code class="po-atom e323 e323"><textual class="po-textual">*</textual></code><textual class="po-textual">.  </textual><code class="po-atom e324 e324"><textual class="po-textual">{count}</textual></code><textual class="po-textual"> could be confused with a selector expression returning </textual><code class="po-atom e325 e325"><textual class="po-textual">count</textual></code><textual class="po-textual">, however a selector returning a single number is pointless, so we can assume every single number is not meant to be a selector. A single text node can contain a repetition marker and a selector expression. </textual></para><para class="po-block e326 e326"><textual class="po-textual">The use of a minimal count can be demonstrated with the following example: each of the patterns </textual><code class="po-atom e327 e327"><textual class="po-textual">&lt;x&gt;{.}&lt;/x&gt;*</textual></code><textual class="po-textual"> and </textual><code class="po-atom e328 e328"><textual class="po-textual">&lt;x&gt;{.}&lt;/x&gt;+</textual></code><textual class="po-textual"> applied to  </textual><code class="po-atom e329 e329"><textual class="po-textual">&lt;root&gt;&lt;x&gt;1&lt;/x&gt;&lt;x&gt;2&lt;/x&gt;&lt;x&gt;3&lt;/x&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e330 e330"><textual class="po-textual">&lt;x&gt;1&lt;/x&gt;</textual></code><textual class="po-textual">, </textual><code class="po-atom e331 e331"><textual class="po-textual">&lt;x&gt;2&lt;/x&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e332 e332"><textual class="po-textual">&lt;x&gt;3&lt;/x&gt;</textual></code><textual class="po-textual">.  However, if applied to </textual><code class="po-atom e333 e333"><textual class="po-textual">&lt;root/&gt;</textual></code><textual class="po-textual">, former succeeds and returns nothing, while latter raises a matching error.</textual></para><para class="po-block e334 e334"><textual class="po-textual">Unlike the minimal count a maximal count does not raise matching errors, instead all elements after the first max elements are just ignored, following the principle of ignoring additional data. </textual></para><para class="po-block e335 e335"><textual class="po-textual">Although </textual><code class="po-atom e336 e336"><textual class="po-textual">&lt;x&gt;{.}&lt;/x&gt;*</textual></code><textual class="po-textual"> seems to be the same as </textual><code class="po-atom e337 e337"><textual class="po-textual">//x</textual></code><textual class="po-textual">, it is not. This becomes obvious, if we look at the expanded pattern </textual><code class="po-atom e338 e338"><textual class="po-textual">&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;&lt;x&gt;{.}&lt;/x&gt;...</textual></code><textual class="po-textual">. All the x-elements in the pattern are siblings and not descendants of each other, so the pattern will only match separated </textual><code class="po-atom e339 e339"><textual class="po-textual">x</textual></code><textual class="po-textual">-elements which do not contain each other. An equivalent XQuery would therefore be </textual><code class="po-atom e340 e340"><textual class="po-textual">let $temp := count(ancestor-or-self::x) return .//x[count(ancestor::x) eq $temp]</textual></code><textual class="po-textual"> or shorter </textual><code class="po-atom e341 e341"><textual class="po-textual">.//x except .//x//x </textual></code><textual class="po-textual"> </textual><textual class="po-textual">.</textual></para><para class="po-block e342 e342"><textual class="po-textual">Considering a loop to be a sequence of repeated elements also explains, how selectors are handled within the loop: Every selector is evaluated for every matched element and the result is returned as another assignment to the result variable. </textual></para><para class="po-block e343 e343"><textual class="po-textual">For example </textual><programlisting class="po-block e344 e344" xml:space="preserve"><textual class="po-textual">&lt;a&gt;{$var}&lt;b/&gt;&lt;/a&gt;+</textual></programlisting><textual class="po-textual"> applied to </textual><programlisting class="po-block e345 e345" xml:space="preserve"><textual class="po-textual">&lt;root&gt; &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt; &lt;a&gt;2&lt;/a&gt; &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;</textual></programlisting><textual class="po-textual"> returns an assigment stream
     </textual><programlisting class="po-block e346 e346" xml:space="preserve"><textual class="po-textual">$var := &lt;a&gt;&lt;b&gt;1&lt;/b&gt;&lt;/a&gt;
$var := &lt;a&gt;&lt;b&gt;3&lt;/b&gt;&lt;/a&gt;</textual></programlisting><textual class="po-textual">. The second </textual><code class="po-atom e347 e347"><textual class="po-textual">&lt;a/&gt;</textual></code><textual class="po-textual"> is skipped, because it does not a </textual><code class="po-atom e348 e348"><textual class="po-textual">&lt;b/&gt;</textual></code><textual class="po-textual"> child. </textual></para><para class="po-block e349 e349"><code class="po-atom e350 e350"><textual class="po-textual">&lt;t:loop&gt;</textual></code><textual class="po-textual"> is the most powerful variant of these five syntaxes, not only does it generalize the other notations</textual><footnote class="po-popup e351 e351"><para class="po-block e352 e352"><textual class="po-textual">In fact, our implementation converts everything to </textual><code class="po-atom e353 e353"><textual class="po-textual">&lt;t:loop&gt;</textual></code><textual class="po-textual"> before matching.</textual></para></footnote><textual class="po-textual">, it is the only one that can repeat multiple elements e.g. to separate odd and even rows: </textual><code class="po-atom e354 e354"><textual class="po-textual"> &lt;t:loop&gt;&lt;tr&gt;{$odd}&lt;/tr&gt; &lt;tr&gt;{$even}&lt;/tr&gt; &lt;/t:loop&gt; </textual></code></para><para class="po-block e355 e355"><textual class="po-textual">A possible way to implement repeated elements is to modify the matching process of the parent of the loop node to match all its children and children of </textual><code class="po-atom e356 e356"><textual class="po-textual">t:loop</textual></code><textual class="po-textual">-elements against all possible nodes in the input document. The last match of the non-loop children following the loop children is then a constraint for the maximum number of matching loop children, because only nodes preceding  that last match can be matched by children of the loop. </textual></para></section><section class="po-hcontainer e357 e357" xml:id="tcondition"><title class="po-block e358 e358"><textual class="po-textual">Conditionals</textual></title><para class="po-block e359 e359"><textual class="po-textual">In some cases it is necessary to check for arbitrary conditions that cannot be expressed directly by a pattern, e.g. for conditions that are not local like two values depending on each other. For this we use an attribute </textual><code class="po-atom e360 e360"><textual class="po-textual">t:condition</textual></code><textual class="po-textual">, which stores an XQuery expression that an input element has to satisfy in order to be accepted as valid match, similarly to the expression contained in a filter expression. The context item </textual><code class="po-atom e361 e361"><textual class="po-textual">.</textual></code><textual class="po-textual"> is set to the node currently checked for a match.  </textual></para><para class="po-block e362 e362"><textual class="po-textual">
      For example the pattern </textual><code class="po-atom e363 e363"><textual class="po-textual">&lt;e t:condition="exists(@a) and @b eq ."/&gt;</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e364 e364"><textual class="po-textual">&lt;e a="" b="1"&gt;1&lt;/e&gt;</textual></code><textual class="po-textual">, but neither </textual><code class="po-atom e365 e365"><textual class="po-textual">&lt;e  b="1"&gt;1&lt;/e&gt;</textual></code><textual class="po-textual"> nor </textual><code class="po-atom e366 e366"><textual class="po-textual">&lt;e a="" b="1"&gt;2&lt;/e&gt;</textual></code><textual class="po-textual">.
      </textual></para><para class="po-block e367 e367"><textual class="po-textual">Another use of conditionals is to skip parts of the pattern. E.g. if you have two data sources which are similar, but not identical, you might want to use the same pattern for both, ignoring the parts of the pattern which only apply to the other data source. 
      This can be accomplished with the </textual><code class="po-atom e368 e368"><textual class="po-textual">&lt;t:if&gt;</textual></code><textual class="po-textual"> element, whose children are only matched, if the XQuery expression given in the </textual><code class="po-atom e369 e369"><textual class="po-textual">test</textual></code><textual class="po-textual"> attribute of the </textual><code class="po-atom e370 e370"><textual class="po-textual">&lt;t:if&gt;</textual></code><textual class="po-textual"> element evaluates to true. The context item </textual><code class="po-atom e371 e371"><textual class="po-textual">.</textual></code><textual class="po-textual"> is the previously matched element.</textual></para><para class="po-block e372 e372"><textual class="po-textual"> For example </textual><code class="po-atom e373 e373"><textual class="po-textual">&lt;x&gt;&lt;y&gt;{$y}&lt;/y&gt;&lt;t:if test="$y eq 17"&gt;&lt;z&gt;{$z}&lt;/z&gt;&lt;/t:if&gt;&lt;/x&gt;</textual></code><textual class="po-textual"> matched against </textual><code class="po-atom e374 e374"><textual class="po-textual">&lt;x&gt;&lt;y&gt;1&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e375 e375"><textual class="po-textual">$x := &lt;y&gt;1&lt;/y&gt;</textual></code><textual class="po-textual"> and matched against </textual><code class="po-atom e376 e376"><textual class="po-textual">&lt;x&gt;&lt;y&gt;17&lt;/y&gt;&lt;z&gt;2&lt;/z&gt;&lt;/x&gt;</textual></code><textual class="po-textual">, it returns </textual><code class="po-atom e377 e377"><textual class="po-textual">$x := &lt;y&gt;17&lt;/y&gt;, $y := &lt;z&gt;2&lt;/z&gt;</textual></code><textual class="po-textual">.</textual></para><para class="po-block e378 e378"><textual class="po-textual">Most languages support an </textual><code class="po-atom e379 e379"><textual class="po-textual">else</textual></code><textual class="po-textual"> statement to be used  with their </textual><code class="po-atom e380 e380"><textual class="po-textual">if</textual></code><textual class="po-textual"> statement, so we added a similar </textual><code class="po-atom e381 e381"><textual class="po-textual">&lt;t:else/&gt;</textual></code><textual class="po-textual">-element to the pattern syntax. The children of a </textual><code class="po-atom e382 e382"><textual class="po-textual">&lt;t:else/&gt;</textual></code><textual class="po-textual"> element are only matched, if the children of the preceding </textual><code class="po-atom e383 e383"><textual class="po-textual">&lt;t:if/&gt;</textual></code><textual class="po-textual"> element were ignored. </textual><textual class="po-textual">
      For example </textual><code class="po-atom e384 e384"><textual class="po-textual">&lt;root&gt;&lt;t:if test="$check"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;/t:if&gt;&lt;t:else&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:else&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> matched against </textual><code class="po-atom e385 e385"><textual class="po-textual">&lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> returns </textual><code class="po-atom e386 e386"><textual class="po-textual">&lt;a&gt;1&lt;/a&gt;</textual></code><textual class="po-textual">, if </textual><code class="po-atom e387 e387"><textual class="po-textual">$check</textual></code><textual class="po-textual"> is true, and </textual><code class="po-atom e388 e388"><textual class="po-textual">&lt;b&gt;2&lt;/b&gt;</textual></code><textual class="po-textual"> otherwise. </textual></para><para class="po-block e389 e389"><textual class="po-textual">If the </textual><code class="po-atom e390 e390"><textual class="po-textual">&lt;t:if&gt;</textual></code><textual class="po-textual"> element is used to give a condition for a single element, it is quite cumbersome to surround just that element with </textual><code class="po-atom e391 e391"><textual class="po-textual">&lt;t:if&gt;..&lt;/t:if&gt;</textual></code><textual class="po-textual">. Therefore we allow the </textual><code class="po-atom e392 e392"><textual class="po-textual">t:test</textual></code><textual class="po-textual"> attribute being used directly on elements, as abbreviation for a surrounding </textual><code class="po-atom e393 e393"><textual class="po-textual">&lt;t:if&gt;</textual></code><textual class="po-textual">. E.g. </textual><code class="po-atom e394 e394"><textual class="po-textual">&lt;a t:test="$check"/&gt;</textual></code><textual class="po-textual"> is equivalent to </textual><code class="po-atom e395 e395"><textual class="po-textual">&lt;t:if t:test="$check"&gt;&lt;a/&gt;&lt;/t:if&gt;</textual></code><textual class="po-textual"> and  ignored if </textual><code class="po-atom e396 e396"><textual class="po-textual">$check</textual></code><textual class="po-textual"> is </textual><code class="po-atom e397 e397"><textual class="po-textual">false</textual></code><textual class="po-textual">. </textual></para><para class="po-block e398 e398"><textual class="po-textual"> </textual><code class="po-atom e399 e399"><textual class="po-textual">t:test</textual></code><textual class="po-textual"> might be confused with </textual><code class="po-atom e400 e400"><textual class="po-textual">t:condition</textual></code><textual class="po-textual"> by someone just seeing a pattern without having read this paper. but they are very different from each other. </textual><code class="po-atom e401 e401"><textual class="po-textual">t:test</textual></code><textual class="po-textual"> is a condition the element in the pattern (given the previous variables) has to satisfy, is checked (at most once, outside t:loop) before a match for this element is searched and only a positive return value can lead to a matching error. </textual><code class="po-atom e402 e402"><textual class="po-textual">t:condition</textual></code><textual class="po-textual"> is a condition the element in the input data has to satisfy, might be checked for every element in the input data, and only a negative return value can lead to a matching error. </textual></para></section><section class="po-hcontainer e403 e403" xml:id="para_unordered"><title class="po-block e404 e404"><textual class="po-textual">Alternative elements</textual></title><para class="po-block e405 e405"><textual class="po-textual">Sometimes different  elements may occur in the input data and should be accepted as matches, but it is not known a priori which one actually exists.
             It would be possible to handle this with optional elements and conditions, but that would be cumbersome. 
             Instead the patterns  support a </textual><code class="po-atom e406 e406"><textual class="po-textual">&lt;t:switch&gt;</textual></code><textual class="po-textual"> element, which contains different alternative patterns, i.e. it matches an element in the input successfully, if any of its children match that element successfully.
       </textual></para><para class="po-block e407 e407"><textual class="po-textual">For example </textual><code class="po-atom e408 e408"><textual class="po-textual">&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</textual></code><textual class="po-textual"> applied to either </textual><code class="po-atom e409 e409"><textual class="po-textual">&lt;a&gt;1&lt;/a&gt;</textual></code><textual class="po-textual"> or  </textual><code class="po-atom e410 e410"><textual class="po-textual">&lt;b&gt;1&lt;/b&gt;</textual></code><textual class="po-textual"> will return the input node (with value 1). </textual></para><para class="po-block e411 e411"><textual class="po-textual">There occurs a strange effect, if all the children exist as elements in the input data,  but in a different order, like </textual><code class="po-atom e412 e412"><textual class="po-textual">&lt;root&gt;&lt;x&gt;&lt;b&gt;B&lt;/b&gt;&lt;/x&gt;&lt;a&gt;A&lt;/a&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> for the previous example. The </textual><code class="po-atom e413 e413"><textual class="po-textual">&lt;t:switch/&gt;</textual></code><textual class="po-textual"> element as described so far would return the b-element, because </textual><code class="po-atom e414 e414"><textual class="po-textual">&lt;t:switch/&gt;</textual></code><textual class="po-textual"> is first matched against </textual><code class="po-atom e415 e415"><textual class="po-textual">&lt;root&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e416 e416"><textual class="po-textual">&lt;x&gt;</textual></code><textual class="po-textual">, which are not accepted by any of its children, and then against </textual><code class="po-atom e417 e417"><textual class="po-textual">&lt;b&gt;</textual></code><textual class="po-textual">, which is matched by the second child. So   </textual><code class="po-atom e418 e418"><textual class="po-textual">&lt;t:switch&gt;</textual></code><textual class="po-textual"> always chooses the first matching element in the input.</textual></para><para class="po-block e419 e419"><textual class="po-textual">However, it has turned out that we usually want the element matching the earliest child that has a match, when we combine multiple patterns into a single one. So we have added an attribute </textual><code class="po-atom e420 e420"><textual class="po-textual">prioritized</textual></code><textual class="po-textual">, which enables "prioritized" matching, i.e. performing the matching of the children in order and accepting the first match of the earliest child. E.g. </textual><code class="po-atom e421 e421"><textual class="po-textual">&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;</textual></code><textual class="po-textual"> would return the a-element when matched against the previous  example input document. </textual></para><para class="po-block e422 e422"><textual class="po-textual">Another interesting use of the </textual><code class="po-atom e423 e423"><textual class="po-textual">&lt;t:switch&gt;</textual></code><textual class="po-textual"> element is to perform unordered matching, when combined with a loop. For example </textual><code class="po-atom e424 e424"><textual class="po-textual">&lt;t:loop&gt;&lt;t:switch&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/t:switch&gt;&lt;/t:loop&gt;</textual></code><textual class="po-textual"> returns all  (not nested) </textual><code class="po-atom e425 e425"><textual class="po-textual">&lt;a/&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e426 e426"><textual class="po-textual">&lt;b/&gt;</textual></code><textual class="po-textual"> nodes of the input document. So applied to the example input above it returns </textual><code class="po-atom e427 e427"><textual class="po-textual">&lt;b&gt;B&lt;/b&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e428 e428"><textual class="po-textual">&lt;a&gt;A&lt;/a&gt;</textual></code><textual class="po-textual">. (without the loop and switch, it would raise a matching error due to the different order). This occurs automatically, without handling this case in an implementation, since the switch-element is matched against every element in the input.  </textual></para><para class="po-block e429 e429"><textual class="po-textual">A possible abbreviation for a </textual><code class="po-atom e430 e430"><textual class="po-textual">&lt;t:switch&gt;</textual></code><textual class="po-textual"> element could be the regex inspired </textual><code class="po-atom e431 e431"><textual class="po-textual">(&lt;a&gt;{.}&lt;/a&gt;|&lt;b&gt;{.}&lt;/b&gt;)</textual></code><textual class="po-textual">. We have, however, not implemented this, because a regex is allowed to start with a </textual><code class="po-atom e432 e432"><textual class="po-textual">|</textual></code><textual class="po-textual"> (matching an empty string), so it might not be clear, if a switch abbreviation or a regex for text node matching is meant.</textual></para></section><section class="po-hcontainer e433 e433" xml:id="tmeta"><title class="po-block e434 e434"><textual class="po-textual">Default options</textual></title><para class="po-block e435 e435"><textual class="po-textual">The way string values are matched can be changed with the </textual><code class="po-atom e436 e436"><textual class="po-textual">&lt;t:meta/&gt;</textual></code><textual class="po-textual">-element, which sets the comparison function and case-sensitiveness for text nodes and attributes:
      </textual><programlisting class="po-block e437 e437" xml:space="preserve"><textual class="po-textual">&lt;t:meta [text-matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [text-case-sensitive="true|false"] 
        [attribute-matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [attribute-case-sensitive="true|false"] /&gt;</textual></programlisting><textual class="po-textual">      
      </textual></para><para class="po-block e438 e438"><textual class="po-textual">
      For example </textual><code class="po-atom e439 e439"><textual class="po-textual">&lt;t:meta text-case-sensitive="false"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e440 e440"><textual class="po-textual">&lt;a&gt;foobar&lt;/a&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e441 e441"><textual class="po-textual">&lt;a&gt;FOOBAR&lt;/a&gt;</textual></code><textual class="po-textual">, while </textual><code class="po-atom e442 e442"><textual class="po-textual">&lt;t:meta text-case-sensitive="true"&gt;&lt;a&gt;foobar&lt;/a&gt;&lt;/t:meta&gt;</textual></code><textual class="po-textual"> matches only former input.
      </textual></para><para class="po-block e443 e443"><textual class="po-textual">For individual attributes the string value matching can be controlled with the </textual><code class="po-atom e444 e444"><textual class="po-textual">&lt;t:meta-attribute/&gt;</textual></code><textual class="po-textual">-element:
      </textual><programlisting class="po-block e445 e445" xml:space="preserve"><textual class="po-textual">&lt;t:meta-attribute 
        name="..."
        [matching="eq|matches|starts-with|ends-with|contains|list-contains"] 
        [case-sensitive="true|false"] /&gt;</textual></programlisting><textual class="po-textual">      
      </textual></para><para class="po-block e446 e446"><textual class="po-textual">
      For example </textual><code class="po-atom e447 e447"><textual class="po-textual">&lt;t:meta-attribute name="x" case-sensitive="false"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e448 e448"><textual class="po-textual">&lt;a x="y"/&gt;</textual></code><textual class="po-textual"> and </textual><code class="po-atom e449 e449"><textual class="po-textual">&lt;a x="Y"/&gt;</textual></code><textual class="po-textual">, while </textual><code class="po-atom e450 e450"><textual class="po-textual">&lt;t:meta-attribute name="x" case-sensitive="true"&gt;&lt;a x="y"/&gt;&lt;/t:meta-attribute&gt;</textual></code><textual class="po-textual"> matches only former input.
      </textual></para><para class="po-block e451 e451"><textual class="po-textual">A meta element changes the options for all its children, and, if it does not have children, for all following elements due to legacy reasons.</textual></para></section></section><section class="po-hcontainer e452 e452"><title class="po-block e453 e453"><textual class="po-textual">Matching JSONiq</textual></title><para class="po-block e454 e454"><textual class="po-textual">After having specified a pattern syntax for XML data, it appears reasonable to extend it to other data storage formats, like JSON. Recently a JSON-query language called JSONiq [</textual><xref class="po-milestone e455 e455" linkend="jsoniq"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] was announced as extension to XQuery, which we have implemented and plan to extend with pattern matching. </textual></para><para class="po-block e456 e456"><textual class="po-textual">To perform pattern matching on JSONiq types, we need to define the matching process for all new types added by JSONiq: </textual><code class="po-atom e457 e457"><textual class="po-textual">null</textual></code><textual class="po-textual">, objects and arrays</textual><footnote class="po-popup e458 e458"><para class="po-block e459 e459"><textual class="po-textual">This section is purely theoretical, we have never used JSONiq matching in any practical application.</textual></para></footnote><textual class="po-textual">. As well as for the standard atomic XQuery types derived from </textual><code class="po-atom e460 e460"><textual class="po-textual">xs:anyAtomicType</textual></code><textual class="po-textual">, because the previous sections only defined the matching for nodes.</textual></para><para class="po-block e461 e461"><textual class="po-textual">
      A small problem is that none of the JSONiq types support namespaces, so we cannot do advanced matching with a </textual><code class="po-atom e462 e462"><textual class="po-textual">t:</textual></code><textual class="po-textual"> prefix, like in the XML case, not even to include selector expressions. However, the important JSONiq types, arrays and objects, can contain XML nodes, so we can wrap the selector expressions in </textual><code class="po-atom e463 e463"><textual class="po-textual">&lt;t:s/&gt;</textual></code><textual class="po-textual">-elements and include them like that in the JSONiq item. 
      </textual></para><itemizedlist class="po-table e464 e464"><listitem class="po-container e465 e465"><para class="po-block e466 e466"><textual class="po-textual">
      Defining a natural matching for </textual><emphasis class="po-inline e467 e467"><textual class="po-textual">atomic types and </textual><code class="po-atom e468 e468"><textual class="po-textual">null</textual></code></emphasis><textual class="po-textual"> is easy: These values matches another value, if the </textual><code class="po-atom e469 e469"><textual class="po-textual">eq</textual></code><textual class="po-textual">-operator returns true. Due to the definition of the equality of </textual><code class="po-atom e470 e470"><textual class="po-textual">null</textual></code><textual class="po-textual"> in JSONiq, it follows </textual><code class="po-atom e471 e471"><textual class="po-textual">null</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e472 e472"><textual class="po-textual">null</textual></code><textual class="po-textual"> and nothing else.
      </textual></para></listitem><listitem class="po-container e473 e473"><para class="po-block e474 e474"><textual class="po-textual">
      An </textual><emphasis class="po-inline e475 e475"><textual class="po-textual">object</textual></emphasis><textual class="po-textual"> pattern matches a value, if that value is an object and the value of every property of the pattern matches the value of the corresponding property of the value. 
      </textual></para></listitem><listitem class="po-container e476 e476"><para class="po-block e477 e477"><textual class="po-textual">      
      
      
      For arrays there are three reasonable ways to define array matching: An array pattern </textual><code class="po-atom e478 e478"><textual class="po-textual">$a</textual></code><textual class="po-textual"> matches an  value </textual><code class="po-atom e479 e479"><textual class="po-textual">$b</textual></code><textual class="po-textual">, if 
      </textual><itemizedlist class="po-table e480 e480"><listitem class="po-container e481 e481"><para class="po-block e482 e482"><textual class="po-textual"> </textual><emphasis class="po-inline e483 e483"><textual class="po-textual">Exact matching</textual></emphasis><textual class="po-textual">: </textual><textual class="po-textual"> element </textual><code class="po-atom e484 e484"><textual class="po-textual">$a[$i]</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e485 e485"><textual class="po-textual">$b[$i]</textual></code><textual class="po-textual"> for all </textual><code class="po-atom e486 e486"><textual class="po-textual">$i in 1 to jn:size($a)</textual></code><textual class="po-textual">, and </textual><code class="po-atom e487 e487"><textual class="po-textual">$a</textual></code><textual class="po-textual"> and </textual><code class="po-atom e488 e488"><textual class="po-textual">$b</textual></code><textual class="po-textual"> have the same number of elements. </textual></para></listitem><listitem class="po-container e489 e489"><para class="po-block e490 e490"><emphasis class="po-inline e491 e491"><textual class="po-textual">Exact prefix matching</textual></emphasis><textual class="po-textual">: element </textual><code class="po-atom e492 e492"><textual class="po-textual">$a[$i]</textual></code><textual class="po-textual"> matches </textual><code class="po-atom e493 e493"><textual class="po-textual">$b[$i]</textual></code><textual class="po-textual"> for all </textual><code class="po-atom e494 e494"><textual class="po-textual">$i in 1 to jn:size($a)</textual></code><textual class="po-textual">. I.e. after the exactly matched beginning of the array </textual><code class="po-atom e495 e495"><textual class="po-textual">$b</textual></code><textual class="po-textual">  there might follow arbitrary other elements.</textual></para></listitem><listitem class="po-container e496 e496"><para class="po-block e497 e497"><emphasis class="po-inline e498 e498"><textual class="po-textual">Existence matching</textual></emphasis><textual class="po-textual">: element </textual><code class="po-atom e499 e499"><textual class="po-textual">$a[$i]</textual></code><textual class="po-textual"> matches an </textual><code class="po-atom e500 e500"><textual class="po-textual">$b[$j($i)]</textual></code><textual class="po-textual">, such that $j($i) &lt; $j($i+1),  for all </textual><code class="po-atom e501 e501"><textual class="po-textual">$i in 1 to jn:size($a)</textual></code><textual class="po-textual">. I.e. every element of $a can be matched, but there might be arbitrary many elements between each match.</textual></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e502 e502"><textual class="po-textual">Each way represents a different compromise between the goal 2 (validation) and goal 3 (minimality). We have decided to use the last way, giving priority to minimality</textual><footnote class="po-popup e503 e503"><para class="po-block e504 e504"><textual class="po-textual">Sequences could be handled similar to arrays, but we will not consider sequences here, since they do not occur as such in input data.</textual></para></footnote><textual class="po-textual">.</textual></para></listitem></itemizedlist><para class="po-block e505 e505"><textual class="po-textual">An example of a pattern according to above definitions is 
      </textual><programlisting class="po-block e506 e506" xml:space="preserve"><textual class="po-textual">{"a": [1,2,3], "b": null, "c": &lt;t:s&gt;{.}&lt;/t:s&gt;}</textual></programlisting><textual class="po-textual">
      which matches 
      </textual><programlisting class="po-block e507 e507" xml:space="preserve"><textual class="po-textual">{"a": [1,2,3], "b": null, "c": "foobar"}</textual></programlisting><textual class="po-textual">
      returning </textual><code class="po-atom e508 e508"><textual class="po-textual">foobar</textual></code><textual class="po-textual">
      or 
      </textual><programlisting class="po-block e509 e509" xml:space="preserve"><textual class="po-textual">{"a": [1,"u",2,"v",3], "b": null, "c": [7,8,9], "d": 17}</textual></programlisting><textual class="po-textual">
      returning </textual><code class="po-atom e510 e510"><textual class="po-textual">[7,8,9]</textual></code><textual class="po-textual">.
      </textual></para><para class="po-block e511 e511"><textual class="po-textual">
      But it matches neither 
      </textual><programlisting class="po-block e512 e512" xml:space="preserve"><textual class="po-textual">{"a": [1,2,3], "b": [4,5], "c": "xyz"}</textual></programlisting><textual class="po-textual">
      nor 
      </textual><programlisting class="po-block e513 e513" xml:space="preserve"><textual class="po-textual">{"a": [1,2,3], "c": "foobar"}</textual></programlisting><textual class="po-textual">
       </textual></para><para class="po-block e514 e514"><textual class="po-textual">Since writing </textual><code class="po-atom e515 e515"><textual class="po-textual">&lt;t:s/&gt;</textual></code><textual class="po-textual"> is extremely cumbersome in a JSONiq pattern, it might be beneficial to allow abbreviations like </textual><code class="po-atom e516 e516"><textual class="po-textual">{"c": .}</textual></code><textual class="po-textual">, </textual><code class="po-atom e517 e517"><textual class="po-textual">{"c": $result}</textual></code><textual class="po-textual"> or </textual><code class="po-atom e518 e518"><textual class="po-textual">{"c": $result := .}</textual></code><textual class="po-textual"> in an implementation, in which the </textual><code class="po-atom e519 e519"><textual class="po-textual">&lt;t:s&gt;</textual></code><textual class="po-textual"> is omitted. This syntax is mostly unambiguous, however it cannot be evaluated and stored as JSONiq type. Therefore, such an implementation must be able to partially evaluate JSONiq types, keeping it in AST form or serializing the XQuery-AST back to a reparsable query wrapped in </textual><code class="po-atom e520 e520"><textual class="po-textual">&lt;t:s&gt;</textual></code><textual class="po-textual">. Another alternative might be to use inline functions instead </textual><code class="po-atom e521 e521"><textual class="po-textual">&lt;t:s&gt;</textual></code><textual class="po-textual">, e.g </textual><code class="po-atom e522 e522"><textual class="po-textual">function(){$result := .}</textual></code><textual class="po-textual"> replacing </textual><code class="po-atom e523 e523"><textual class="po-textual">&lt;t:s&gt;$result := . &lt;/t:s&gt;</textual></code><textual class="po-textual">, in which case no serialization of XQuery expressions is needed. But we will not consider such  extensions in the remaining paper. </textual></para></section></section><section class="po-hcontainer e524 e524" xml:id="integration"><title class="po-block e525 e525"><textual class="po-textual">The integration in XQuery</textual></title><section class="po-hcontainer e526 e526"><title class="po-block e527 e527"><textual class="po-textual">As function, without syntax modification</textual></title><para class="po-block e528 e528"><textual class="po-textual">Since every pattern is a valid XML element (or JSONiq item), it </textual><textual class="po-textual"> can be represented by valid values in the XQuery type schema, and it is possible to write a matching function that takes a pattern and input data as arguments and performs the matching in standard XQuery (or JSONiq). Such a function is useful to perform pattern matching in existing XQuery implementations without having to write a new implementation.</textual></para><para class="po-block e529 e529"><textual class="po-textual"> To use the full power of selector expressions within a patten, the underlying implementation has to support some kind of </textual><code class="po-atom e530 e530"><textual class="po-textual">eval</textual></code><textual class="po-textual"> function to evaluate an XQuery given as string. And of course, only the right-hand-side of </textual><code class="po-atom e531 e531"><textual class="po-textual">:=</textual></code><textual class="po-textual"> assignment can be passed to the </textual><code class="po-atom e532 e532"><textual class="po-textual">eval</textual></code><textual class="po-textual">-function and the variable names have to be tracked separately. </textual></para><para class="po-block e533 e533"><textual class="po-textual">The type declaration of our matching function is:</textual><footnote class="po-popup e534 e534"><para class="po-block e535 e535"><textual class="po-textual">The prefix </textual><code class="po-atom e536 e536"><textual class="po-textual">pxp</textual></code><textual class="po-textual"> can be considered an abbreviation of "Pascal XQuery Project", another name of our XQuery implementation. Although the function </textual><code class="po-atom e537 e537"><textual class="po-textual">pxp:match</textual></code><textual class="po-textual"> exists in our implementation it is there not written in XQuery and depends on our own special features. </textual></para></footnote></para><programlisting class="po-block e538 e538" xml:space="preserve"><textual class="po-textual">pxp:match($pattern as item(), data as item()*) as item()*</textual></programlisting><para class="po-block e539 e539"><textual class="po-textual">The first argument is the pattern that is matched against every item in the </textual><code class="po-atom e540 e540"><textual class="po-textual">$data</textual></code><textual class="po-textual"> sequence, thereby creating multiple assignment streams which are concatenated. Since </textual><code class="po-atom e541 e541"><textual class="po-textual">$pattern</textual></code><textual class="po-textual"> is an ordinary value, the </textual><code class="po-atom e542 e542"><textual class="po-textual">{...}</textual></code><textual class="po-textual"> selector expressions have to be encoded as </textual><code class="po-atom e543 e543"><textual class="po-textual">{{...}}</textual></code><textual class="po-textual">, if the pattern is created within the query by an element constructor.  </textual></para><para class="po-block e544 e544"><textual class="po-textual">In theory, the function should return the final assignment stream, but an assignment stream is not a valid XDM instance. So we wrap the result in an XQuery map which maps variable names to a sequence of values and which can be read like a function call. For example the map </textual><code class="po-atom e545 e545"><textual class="po-textual">$map := {"foo": "bar", "x": ("y", "z")}</textual></code><textual class="po-textual"> contains two keys which can be accessed with </textual><code class="po-atom e546 e546"><textual class="po-textual">$map("foo") = "bar"</textual></code><textual class="po-textual"> and </textual><code class="po-atom e547 e547"><textual class="po-textual">$map("x") = ("y", "z")</textual></code><textual class="po-textual">. In modern XQuery such a map can be implemented as an anonymous function that returns a certain value if called with the corresponding key.  A theoretical alternative to a map is to wrap the data in an XML element, however, that would destroy information like the parents of the returned items</textual><footnote class="po-popup e548 e548"><para class="po-block e549 e549"><textual class="po-textual">For the same reason we are talking about a "map" instead of a JSONiq "object". A standard JSONiq object would contain copies of the XML elements and therefore  lose the parent relationships as well.</textual></para></footnote><textual class="po-textual">.   </textual><textual class="po-textual"> </textual></para><para class="po-block e550 e550"><textual class="po-textual">Since sequences cannot nest, assignments of sequences to variables are flattened in the returned sequence. e.g. the assignment stream </textual><code class="po-atom e551 e551"><textual class="po-textual">$a = (1, 2), $a = 3, $a = 4</textual></code><textual class="po-textual"> becomes a single sequence in the map </textual><code class="po-atom e552 e552"><textual class="po-textual">{"a": (1,2,3,4)}</textual></code><textual class="po-textual">. If the only assigment is to the default variable, we do not wrap it in a map and return the value directly. </textual></para><para class="po-block e553 e553"><textual class="po-textual">For example

      </textual><programlisting class="po-block e554 e554" xml:space="preserve"><textual class="po-textual">pxp:match(&lt;root&gt;&lt;foo&gt;{{.}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</textual></programlisting><textual class="po-textual">
      
      has internally the assigment stream
      
      </textual><programlisting class="po-block e555 e555" xml:space="preserve"><textual class="po-textual">. = &lt;foo&gt;1&lt;/foo&gt;
. = &lt;foo&gt;2&lt;/foo&gt;
</textual></programlisting><textual class="po-textual">

      and returns 
      
      </textual><programlisting class="po-block e556 e556" xml:space="preserve"><textual class="po-textual">(&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;)</textual></programlisting></para><para class="po-block e557 e557"><textual class="po-textual">Another example with variables is </textual><programlisting class="po-block e558 e558" xml:space="preserve"><textual class="po-textual">pxp:match(&lt;root attrib="{{$attrib}}"&gt;&lt;foo&gt;{{$var}}&lt;/foo&gt;+&lt;/root&gt;, &lt;root attrib="ABC"&gt;&lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt;&lt;/root&gt;)</textual></programlisting><textual class="po-textual">
      which has the assigment stream
      </textual><programlisting class="po-block e559 e559" xml:space="preserve"><textual class="po-textual">$attrib = "ABC"
$var = &lt;foo&gt;1&lt;/foo&gt;
$var = &lt;foo&gt;2&lt;/foo&gt;
</textual></programlisting><textual class="po-textual">
      and returns
      </textual><programlisting class="po-block e560 e560" xml:space="preserve"><textual class="po-textual">{"attrib": "ABC", "var": (&lt;foo&gt;1&lt;/foo&gt;, &lt;foo&gt;2&lt;/foo&gt;) }</textual></programlisting></para></section><section class="po-hcontainer e561 e561"><title class="po-block e562 e562"><textual class="po-textual">Extending Switch-Expressions</textual></title><para class="po-block e563 e563"><textual class="po-textual">The natural way to extend the </textual><code class="po-atom e564 e564"><textual class="po-textual">switch</textual></code><textual class="po-textual">-expression with pattern matching seems to allow patterns as operands of </textual><code class="po-atom e565 e565"><textual class="po-textual">case</textual></code><textual class="po-textual"> clauses, like </textual><code class="po-atom e566 e566"><textual class="po-textual">case &lt;element&gt; ...the pattern... &lt;/element&gt; return ... </textual></code><textual class="po-textual">. However, this is already a valid XQuery syntax, denoting the atomization of the case operand to the string value </textual><code class="po-atom e567 e567"><textual class="po-textual">...the pattern...</textual></code><textual class="po-textual"> and comparing that value to the input. So the </textual><code class="po-atom e568 e568"><textual class="po-textual">case</textual></code><textual class="po-textual">-clause cannot be used and we have to add a new keyword </textual><code class="po-atom e569 e569"><textual class="po-textual">match</textual></code><textual class="po-textual"> that has a pattern as operand. The formal grammar of this new </textual><code class="po-atom e570 e570"><textual class="po-textual">switch</textual></code><textual class="po-textual">-expression is then: </textual></para><programlisting class="po-block e571 e571" xml:space="preserve"><textual class="po-textual">SwitchCaseClause    ::=  ("case" SwitchCaseOperand | "match" SwitchMatchOperand)+ "return" ExprSingle
SwitchMatchOperand  ::=  PatternExpr</textual></programlisting><para class="po-block e572 e572"><textual class="po-textual">A pattern given to </textual><code class="po-atom e573 e573"><textual class="po-textual">match</textual></code><textual class="po-textual"> will not be evaluated, before the matching.  So writing </textual><code class="po-atom e574 e574"><textual class="po-textual">&lt;x&gt;{$y}&lt;/x&gt;</textual></code><textual class="po-textual"> is sufficient for a pattern that assigns  </textual><code class="po-atom e575 e575"><textual class="po-textual">&lt;x/&gt;</textual></code><textual class="po-textual"> to </textual><code class="po-atom e576 e576"><textual class="po-textual">$y</textual></code><textual class="po-textual"> and it does </textual><emphasis class="po-inline e577 e577"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> have to be encoded as </textual><code class="po-atom e578 e578"><textual class="po-textual">&lt;x&gt;{{$y}}&lt;/x&gt;</textual></code><textual class="po-textual">.  So the variables that could be created by the pattern are statically known, and can be added to the static context of the expression in the corresponding return clause. </textual></para><para class="po-block e579 e579"><textual class="po-textual">We define </textual><code class="po-atom e580 e580"><textual class="po-textual">PatternExpr</textual></code><textual class="po-textual"> to be either an XML pattern with optional loop marker (e.g. </textual><code class="po-atom e581 e581"><textual class="po-textual">+</textual></code><textual class="po-textual">) or a JSONiq constructor: </textual></para><programlisting class="po-block e582 e582" xml:space="preserve"><textual class="po-textual">LoopIndicator   := OccurrenceIndicator | "{" Digits "}" | "{" Digits "," Digits "}" 
PatternExpr     := DirectConstructor LoopIndicator? | ObjectConstructor | ArrayConstructor </textual></programlisting><para class="po-block e583 e583"><textual class="po-textual">This syntactical definition is broader than the semantically allowed values (e.g. function calls would not be allowed), so some expressions are rejected during evaluation. </textual></para><para class="po-block e584 e584"><textual class="po-textual">
      The switch expression is then evaluated as follows:</textual></para><para class="po-block e585 e585"><textual class="po-textual">
      All </textual><code class="po-atom e586 e586"><textual class="po-textual">case</textual></code><textual class="po-textual"> and </textual><code class="po-atom e587 e587"><textual class="po-textual">match</textual></code><textual class="po-textual"> clauses are processed in order.
      </textual><itemizedlist class="po-table e588 e588"><listitem class="po-container e589 e589"><para class="po-block e590 e590"><textual class="po-textual">If a </textual><code class="po-atom e591 e591"><textual class="po-textual">case</textual></code><textual class="po-textual"> clause is meet, it is "matched" like in standard XQuery.</textual></para></listitem><listitem class="po-container e592 e592"><para class="po-block e593 e593"><textual class="po-textual">If a </textual><code class="po-atom e594 e594"><textual class="po-textual">match</textual></code><textual class="po-textual"> clause is meet, its pattern is matched against the input as described in the previous sections.
          </textual><itemizedlist class="po-table e595 e595"><listitem class="po-container e596 e596"><para class="po-block e597 e597"><textual class="po-textual">If a matching error occurs, this clause is skipped (the error is not propagated upwards). </textual></para></listitem><listitem class="po-container e598 e598"><para class="po-block e599 e599"><textual class="po-textual">If the matching succeeds, the value of the switch expression is the value of the current return expression.
          All variables that were created by the pattern are available in the evaluation of the return expression and, if a value was assigned to the default variable, it replaces the context item. </textual></para></listitem></itemizedlist></para></listitem></itemizedlist><textual class="po-textual">
      </textual></para><para class="po-block e600 e600"><textual class="po-textual">So for example, either
      
      </textual><programlisting class="po-block e601 e601" xml:space="preserve"><textual class="po-textual">switch (&lt;y&gt;123&lt;/y&gt;) 
  match &lt;x&gt;{$data}&lt;/x&gt; return "The x-data is " || $data
  match &lt;y&gt;{$data}&lt;/y&gt; return "The y-data is " || $data
  default return "foo"</textual></programlisting><textual class="po-textual">
      
      or

      </textual><programlisting class="po-block e602 e602" xml:space="preserve"><textual class="po-textual">switch (&lt;y&gt;123&lt;/y&gt;) 
  match &lt;x&gt;{.}&lt;/x&gt; return "The x-data is " || .
  match &lt;y&gt;{.}&lt;/y&gt; return "The y-data is " || .
  default return "foo"</textual></programlisting><textual class="po-textual">      
      
      
      will return </textual><code class="po-atom e603 e603"><textual class="po-textual">The y-data is 123</textual></code><textual class="po-textual">.</textual></para><para class="po-block e604 e604"><textual class="po-textual"> 
      If multiple values have been added to a single variable by the pattern, like in </textual><code class="po-atom e605 e605"><textual class="po-textual">&lt;x&gt;{$var}&lt;/x&gt;+</textual></code><textual class="po-textual"> they are all flattened to a variable containing a sequence. However, if the assignment was to the context item, an exception is thrown, since </textual><code class="po-atom e606 e606"><textual class="po-textual">.</textual></code><textual class="po-textual"> cannot be a sequence.
      </textual></para><para class="po-block e607 e607"><textual class="po-textual">So we could use the following example to count all links on a webpage:
      </textual><programlisting class="po-block e608 e608" xml:space="preserve"><textual class="po-textual">switch ($inputdata) 
  match &lt;a&gt;{$a}&lt;/a&gt;+ return "There are " || count($a) || " links on the webpage"
  match &lt;html/&gt; return "There are no links on the webpage"
  default return "Invalid input"</textual></programlisting><textual class="po-textual">      </textual></para></section><section class="po-hcontainer e609 e609"><title class="po-block e610 e610"><textual class="po-textual">Extending Flowers</textual></title><para class="po-block e611 e611"><textual class="po-textual">
        Before we can extend the flower expressions, we need to extend the tuple stream, so it behaves more like an assignment stream.
        In XQuery implementations this stream assigns certain values to certain variables. Since our patterns also allow assignments to a default variable with </textual><code class="po-atom e612 e612"><textual class="po-textual">{.}</textual></code><textual class="po-textual"> which is then mapped to the context item </textual><code class="po-atom e613 e613"><textual class="po-textual">.</textual></code><textual class="po-textual">, the tuple stream has to be able to not only store normal variables, but also this default variable. We will write such assignments
        </textual><programlisting class="po-block e614 e614" xml:space="preserve"><textual class="po-textual">(. = 1)
(. = 2)</textual></programlisting><textual class="po-textual">
        in this paper.
        </textual></para><para class="po-block e615 e615"><textual class="po-textual">
        We then could write </textual><code class="po-atom e616 e616"><textual class="po-textual">for . in $sequence return expression ...</textual></code><textual class="po-textual"> meaning the same as </textual><code class="po-atom e617 e617"><textual class="po-textual">$sequence ! expression ...</textual></code><textual class="po-textual"> or </textual><code class="po-atom e618 e618"><textual class="po-textual">let . := $value return expression</textual></code><textual class="po-textual"> meaning the same as </textual><code class="po-atom e619 e619"><textual class="po-textual">exactly-one($value) ! expression ...</textual></code><textual class="po-textual"> in a query</textual><footnote class="po-popup e620 e620"><para class="po-block e621 e621"><textual class="po-textual">Actually our current parser rejects these expressions, but they would be natural extensions.</textual></para></footnote><textual class="po-textual">. 
        </textual></para><section class="po-hcontainer e622 e622"><title class="po-block e623 e623"><textual class="po-textual">Extending let</textual></title><para class="po-block e624 e624"><textual class="po-textual">We extend the </textual><code class="po-atom e625 e625"><textual class="po-textual">let</textual></code><textual class="po-textual">-expression by  allowing patterns to be used as binding variable, i.e. by adding a  </textual><code class="po-atom e626 e626"><textual class="po-textual">MatchLetClause</textual></code><textual class="po-textual"> to the </textual><code class="po-atom e627 e627"><textual class="po-textual">InitialClause</textual></code><textual class="po-textual">-EBNF defined as follows:
      </textual><programlisting class="po-block e628 e628" xml:space="preserve"><textual class="po-textual">MatchLetClause         ::=    	"let" PatternLetBinding ("," PatternLetBinding)*      
LetBinding             ::=    	PatternExpr ":=" ExprSingle</textual></programlisting></para><para class="po-block e629 e629"><textual class="po-textual">During evaluation this pattern is matched against the right-hand-side of </textual><code class="po-atom e630 e630"><textual class="po-textual">:=</textual></code><textual class="po-textual"> and the resulting variables are added to the tuple stream, so they can be used just like in the </textual><code class="po-atom e631 e631"><textual class="po-textual">return</textual></code><textual class="po-textual"> clause of an extended </textual><code class="po-atom e632 e632"><textual class="po-textual">switch</textual></code><textual class="po-textual">-expression.</textual></para><para class="po-block e633 e633"><textual class="po-textual">For example
      </textual><programlisting class="po-block e634 e634" xml:space="preserve"><textual class="po-textual">let &lt;a&gt;{.}&lt;/a&gt; := &lt;root&gt;&lt;a&gt;123&lt;/a&gt;&lt;/root&gt; return .</textual></programlisting><textual class="po-textual">
      will create a tuple stream
</textual><programlisting class="po-block e635 e635" xml:space="preserve"><textual class="po-textual">(. = &lt;a&gt;123&lt;/a&gt;)
</textual></programlisting><textual class="po-textual">
 and therefore return </textual><code class="po-atom e636 e636"><textual class="po-textual">&lt;a&gt;123&lt;/a&gt;.</textual></code></para><para class="po-block e637 e637"><textual class="po-textual">As mentioned when extending the </textual><code class="po-atom e638 e638"><textual class="po-textual">switch</textual></code><textual class="po-textual">-expression, multiple assignments will be flattened to a sequence. E.g. </textual><code class="po-atom e639 e639"><textual class="po-textual">let &lt;a&gt;{$a}&lt;/a&gt;* := &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> creates the tuple stream </textual><code class="po-atom e640 e640"><textual class="po-textual">($a = (&lt;a&gt;1&lt;/a&gt;, &lt;a&gt;2&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;))</textual></code><textual class="po-textual">.</textual></para><para class="po-block e641 e641"><textual class="po-textual">The practical usage of such an expression is to validate that (schema-less) data has a certain structure, without creating a new XML schema or using a lot of if-expressions. E.g. </textual><code class="po-atom e642 e642"><textual class="po-textual">let &lt;xml&gt;&lt;a&gt;{$a}/&lt;a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;c&gt;{$c}&lt;/c&gt;&lt;/xml&gt; := &lt;xml&gt;&lt;a&gt;{123}/&lt;a&gt;&lt;b&gt;{456}&lt;/b&gt;&lt;c&gt;{789}&lt;/c&gt;&lt;/xml&gt; return ($a, $b, $c)</textual></code><textual class="po-textual"> queries the three elements and throws an exception, if they do not occur or have a different order. </textual></para></section><section class="po-hcontainer e643 e643"><title class="po-block e644 e644"><textual class="po-textual">Extending for</textual></title><para class="po-block e645 e645"><textual class="po-textual">Similar to the let-expression we extend the for-expression by allowing a pattern as binding variable. Hence we add a new initial clause </textual><code class="po-atom e646 e646"><textual class="po-textual">MatchForClause</textual></code><textual class="po-textual">:
      </textual><programlisting class="po-block e647 e647" xml:space="preserve"><textual class="po-textual">MatchForClause         ::=    	"for" PatternForBinding ("," PatternForBinding)*
PatternForBinding      ::=    	PatternExpr "in" ExprSingle</textual></programlisting></para><para class="po-block e648 e648"><textual class="po-textual">During evaluation, this pattern is matched against the right-hand-side of </textual><code class="po-atom e649 e649"><textual class="po-textual">in</textual></code><textual class="po-textual"> similar to the evaluation of the extended </textual><code class="po-atom e650 e650"><textual class="po-textual">let</textual></code><textual class="po-textual">. However, this  time the resulting variables are not directly added to the tuple stream. Instead each assignment within the pattern creates a new row in the stream, in which only the currently assigned variable has a value. This also means that a sequence assigned to a variable is not flattened. </textual></para><para class="po-block e651 e651"><textual class="po-textual">
      For example
      </textual><programlisting class="po-block e652 e652" xml:space="preserve"><textual class="po-textual">for &lt;a&gt;{.}&lt;/a&gt;+ in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt; return .</textual></programlisting><textual class="po-textual">
      will create the tuple stream
      </textual><programlisting class="po-block e653 e653" xml:space="preserve"><textual class="po-textual">(. = &lt;a&gt;1&lt;/a&gt;)
(. = &lt;a&gt;2&lt;/a&gt;)
(. = &lt;a&gt;3&lt;/a&gt;)</textual></programlisting><textual class="po-textual">
      and return every a-element.</textual><textual class="po-textual">
      </textual></para><para class="po-block e654 e654"><textual class="po-textual">
      And
      </textual><programlisting class="po-block e655 e655" xml:space="preserve"><textual class="po-textual">for  &lt;html&gt;&lt;h2&gt;Title A&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Title B&lt;/h2&gt;&lt;/html&gt; in $input-data return .</textual></programlisting><textual class="po-textual">
      will return all paragraphs between </textual><code class="po-atom e656 e656"><textual class="po-textual">Title A</textual></code><textual class="po-textual"> and </textual><code class="po-atom e657 e657"><textual class="po-textual">Title B</textual></code><textual class="po-textual">, a natural appearing query that would be complicated to express with standard XPath.
      </textual></para><para class="po-block e658 e658"><textual class="po-textual">When multiple variables are used in the pattern, they all occur in the tuple stream, but only one is non-empty. For example:
      </textual><programlisting class="po-block e659 e659" xml:space="preserve"><textual class="po-textual">for &lt;root&gt;&lt;a&gt;{$a}&lt;/a&gt;&lt;b&gt;{$b}&lt;/b&gt;&lt;a&gt;{$a := (., .)}&lt;/a&gt;&lt;/root&gt; in &lt;root&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;a&gt;3&lt;/a&gt;&lt;/root&gt; return .</textual></programlisting><textual class="po-textual">
      results in the tuple stream
      </textual><programlisting class="po-block e660 e660" xml:space="preserve"><textual class="po-textual">($a = &lt;a&gt;1&lt;/a&gt;,             $b = ()),
($a = (),                   $b = &lt;b&gt;2&lt;/b&gt;)
($a = (&lt;a&gt;3&lt;/a&gt;, &lt;a&gt;3&lt;/a&gt;), $b = ())
</textual></programlisting><textual class="po-textual">
      
       </textual></para><para class="po-block e661 e661"><textual class="po-textual">Combinations of </textual><code class="po-atom e662 e662"><textual class="po-textual">let</textual></code><textual class="po-textual"> and </textual><code class="po-atom e663 e663"><textual class="po-textual">for</textual></code><textual class="po-textual"> as well as the intermediate clauses can be used as usually, since they change the tuple stream in a certain way, independent of the source of that tuple stream.</textual></para></section></section></section><section class="po-hcontainer e664 e664"><title class="po-block e665 e665"><textual class="po-textual">Using pattern matching for data mining</textual></title><para class="po-block e666 e666"><textual class="po-textual">In this section we summarize our experiences and observed issues when applying the pattern matching to perform data mining from various webpages, which is, in fact, the purpose the patterns were designed for.  </textual></para><para class="po-block e667 e667"><textual class="po-textual">The webpages in question are the 
    </textual><textual class="po-textual">  catalogs of over 175 different libraries which were using 14 different library systems with, in total, around 100 individual HTML pages. We have created a pattern for each of these 100 pages, ranging from querying  all the data on the page to querying a single link. With these patterns we mirror the entire functionality of the catalog, like searching for books, getting detailed bibliography data, ordering them for lending, showing the items lend by a patron, renewing loans...  A list of these libraries is available on the </textual><link class="po-inline e668 e668" xlink:actuate="onRequest" xlink:href="http://videlibri.sourceforge.net/#libraries" xlink:show="new" xlink:type="simple"><textual class="po-textual">German VideLibri webpage</textual></link><textual class="po-textual"> and the patterns itself can be found in its </textual><link class="po-inline e669 e669" xlink:actuate="onRequest" xlink:href="http://sourceforge.net/p/videlibri/code/ci/trunks/tree/programs/internet/VideLibri/data/libraries/templates/" xlink:show="new" xlink:type="simple"><textual class="po-textual">source repository</textual></link><textual class="po-textual">.</textual><textual class="po-textual">
    </textual></para><para class="po-block e670 e670"><textual class="po-textual">
	    We have observed the following positive aspects when applying the pattern matching:
	    </textual><itemizedlist class="po-table e671 e671"><listitem class="po-container e672 e672"><para class="po-block e673 e673"><textual class="po-textual">The patterns have vastly simplified the task of mining data from a new webpage. As mentioned above a pattern "can be created by copying the input data, completely removing all data that should not be queried for, replacing the remaining data with annotations and finally calling it a pattern", so we can add a new webpage in a few minutes</textual><footnote class="po-popup e674 e674"><para class="po-block e675 e675"><textual class="po-textual">Outside the scope of this paper, we have simplified this creation process even further by developing a script that can create a pattern for a HTML file, by just selecting the relevant data with the mouse in Firefox.</textual></para></footnote><textual class="po-textual"> and an entire new library system in an hour (up to corner cases/bugs that only appear after months of testing).</textual></para></listitem><listitem class="po-container e676 e676"><para class="po-block e677 e677"><textual class="po-textual">A more concise point is that the pattern is useful for "grounding" an XQuery expression. If we use path expressions to query data from the same element, we either have to prefix each expression with </textual><code class="po-atom e678 e678"><textual class="po-textual">//all/ancestors/of/that/element/</textual></code><textual class="po-textual"> (pointless redundancy) or create a new variable </textual><code class="po-atom e679 e679"><textual class="po-textual">$var := //all/ancestors/of/that/element/</textual></code><textual class="po-textual"> and prefix </textual><code class="po-atom e680 e680"><textual class="po-textual">$var</textual></code><textual class="po-textual">  instead (many variables to name and keep track of). With patterns we create just one element </textual><code class="po-atom e681 e681"><textual class="po-textual">&lt;all&gt;&lt;ancestors&gt;&lt;of&gt;&lt;that&gt;&lt;element&gt;{...}&lt;/element&gt;&lt;/that&gt;&lt;/of&gt;&lt;/ancestors&gt;&lt;/all&gt;</textual></code><textual class="po-textual"> (or copy it from the webpage) and all expressions inside that element are relative to it. This is especially helpful, if there are additional expressions with  partial identical ancestors like,  </textual><code class="po-atom e682 e682"><textual class="po-textual">//all/ancestors/of/that/element/foo/bar</textual></code><textual class="po-textual"> and </textual><code class="po-atom e683 e683"><textual class="po-textual">//all/ancestors/of/x/y/z</textual></code><textual class="po-textual">. The patterns make it obvious how they are related to each other and in which order they occur on the webpage, the path expression not so much. </textual></para></listitem><listitem class="po-container e684 e684"><para class="po-block e685 e685"><textual class="po-textual">It is very easy to query for elements surrounded by certain siblings like </textual><code class="po-atom e686 e686"><textual class="po-textual">&lt;root&gt;&lt;pre-sibling/&gt;&lt;elements/&gt;+&lt;post-sibling/&gt;&lt;/root&gt;</textual></code><textual class="po-textual"> or more specific </textual><code class="po-atom e687 e687"><textual class="po-textual">&lt;root&gt;&lt;h2&gt;Header 1&lt;/h2&gt;&lt;p&gt;{.}&lt;/p&gt;+&lt;h2&gt;Header 2&lt;/h2&gt;&lt;/root&gt;</textual></code><textual class="po-textual">, which often occurs on webpages and is not easy in pure XPath.</textual></para></listitem><listitem class="po-container e688 e688"><para class="po-block e689 e689"><textual class="po-textual">Many people prefer to CSS selectors instead XPath/XQuery expressions, because they are better suited to process HTML, e.g. when querying for classes and ids, although those selectors cannot process the selected data. Our patterns are as easy to use as CSS selectors (especially due to special handling of </textual><code class="po-atom e690 e690"><textual class="po-textual">class</textual></code><textual class="po-textual"> attributes) and provide a way to process the data with all the power of XQuery. </textual></para></listitem><listitem class="po-container e691 e691"><para class="po-block e692 e692"><textual class="po-textual">As expected the patterns are much shorter than queries in a non pattern based system. We do not know how many lines our implementation would have required without patterns, but we can compare it to another, independently developed, open-source project (using Java and CSS selectors) that attempts to mine data from some of these pages. </textual><textual class="po-textual"> For these pages, our pattern based implementation consists of 1641 lines (mostly copied from the original pages), while the other project had to use 3362 lines (assumed to be written manually).</textual></para></listitem><listitem class="po-container e693 e693"><para class="po-block e694 e694"><textual class="po-textual">The patterns are easy to unit test. For this we keep an archive of all ever mined webpages and match the corresponding pattern to each of them, testing if they still return the same assignment stream.  This would be difficult to do for a bunch of path expressions, since these expressions are embedded within a query and do not return an assignment stream, so for every tested pattern there would be several path expressions to test. </textual></para></listitem></itemizedlist><textual class="po-textual">
	    </textual></para><para class="po-block e695 e695"><textual class="po-textual"> We can conclude that the mining task would have been much more difficult and taken much more time without our patterns</textual><footnote class="po-popup e696 e696"><para class="po-block e697 e697"><textual class="po-textual">Although possibly not as much time, as we have spend developing a complete XQuery engine to integrate the patterns.</textual></para></footnote><textual class="po-textual">. </textual></para></section><section class="po-hcontainer e698 e698"><title class="po-block e699 e699"><textual class="po-textual">Futher work</textual></title><para class="po-block e700 e700"><textual class="po-textual">Nevertheless the practical application has shown that the pattern are still  neither as easy and intuitive to use nor as powerful as we hoped. </textual><textual class="po-textual"> The following list describes a few observed issues together with possible extensions that might solve them:</textual></para><itemizedlist class="po-table e701 e701"><listitem class="po-container e702 e702"><para class="po-block e703 e703"><textual class="po-textual">Within loops the validating-property works against its purpose, such that too strongly validating patterns in loops lead to skipped elements.
                For example, you can use the following pattern to read the 2nd column of all rows of a table that have an image in the first column: </textual><programlisting class="po-block e704 e704" xml:space="preserve"><textual class="po-textual">&lt;tr&gt;&lt;td&gt;&lt;img/&gt;&lt;/td&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+</textual></programlisting><textual class="po-textual"> 
                But if (unexpectedly) a row does not contain an image
                </textual><programlisting class="po-block e705 e705" xml:space="preserve"><textual class="po-textual">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;img unavailable&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;&lt;img&gt;&lt;/td&gt;          &lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</textual></programlisting><textual class="po-textual">
 it is skipped, because the row does not match, which can be surprising to someone expecting either a correct matching of all rows or a matching error. </textual></para><para class="po-block e706 e706"><textual class="po-textual">In this example the issue is easily solved by marking the image as optional, either with a following </textual><code class="po-atom e707 e707"><textual class="po-textual">?</textual></code><textual class="po-textual"> or the </textual><code class="po-atom e708 e708"><textual class="po-textual">t:optional</textual></code><textual class="po-textual"> attribute. However, someone creating the pattern has to remember to do that, and needs to know that there might be no image. But when patterns are created based on various samples from a webpage, we often do not know which elements are optional and not.</textual></para><para class="po-block e709 e709"><textual class="po-textual">We have considered two possible extensions to the pattern syntax, which could solve the issue of skipped rows by requiring that all rows participate in the matching: 
          </textual><itemizedlist class="po-table e710 e710"><listitem class="po-container e711 e711"><para class="po-block e712 e712"><textual class="po-textual">An option that all children of a certain element have to be matched, if one of them has been matched. (a </textual><code class="po-atom e713 e713"><textual class="po-textual">++</textual></code><textual class="po-textual"> qualifier might fit well) </textual></para></listitem><listitem class="po-container e714 e714"><para class="po-block e715 e715"><textual class="po-textual">An option that disables the recursive matching, when searching the next match for a loop child, and only tests the loop child itself  (and perhaps its n-th  descendants for a fixed n), if it would match an element (as if the loop child had no children itself). If this first test succeeds, the recursive matching is performed to evaluate the contained selector expressions as before, but if that recursive matching fails then, the entire matching is aborted with a matching error. E.g. with this option, a pattern like </textual><code class="po-atom e716 e716"><textual class="po-textual">&lt;tr&gt;...&lt;/tr&gt;+</textual></code><textual class="po-textual"> would first ignore the </textual><code class="po-atom e717 e717"><textual class="po-textual">...</textual></code><textual class="po-textual"> and just search the next </textual><code class="po-atom e718 e718"><textual class="po-textual">tr</textual></code><textual class="po-textual">-element. Afterward the </textual><code class="po-atom e719 e719"><textual class="po-textual">...</textual></code><textual class="po-textual"> would be matched against that element as usual, propagating exceptions. </textual></para></listitem></itemizedlist></para></listitem><listitem class="po-container e720 e720"><para class="po-block e721 e721"><textual class="po-textual">There is no syntax to match or loop over table </textual><emphasis class="po-inline e722 e722"><textual class="po-textual">columns</textual></emphasis><textual class="po-textual">, instead rows. Although you can read the i-th column by prepending </textual><code class="po-atom e723 e723"><textual class="po-textual">&lt;td/&gt;{i-1}</textual></code><textual class="po-textual"> to skip the previous </textual><code class="po-atom e724 e724"><textual class="po-textual">i-1</textual></code><textual class="po-textual"> columns, it is quite difficult to create a pattern that matches the i-th column on one page and the j-th column on another, or that handles different column orders on different pages</textual><footnote class="po-popup e725 e725"><para class="po-block e726 e726"><textual class="po-textual">Former case can be solved with optional columns, later only with both cases being included in the pattern as switchable subpatterns.</textual></para></footnote><textual class="po-textual">. This issue stems from the hierarchical structure of SGML and is problematic in every query language.</textual></para><para class="po-block e727 e727"><textual class="po-textual">To solve it, a pattern syntax not based on a tree structure is required. Maybe it is possible to add an option that connects the order of children of different elements in the pattern. Then the first row of the pattern could match the header, unordered, and the following rows were linked to the header row, such that the children are processed in the same order the header elements were assigned to their matches. </textual></para></listitem><listitem class="po-container e728 e728"><para class="po-block e729 e729"><textual class="po-textual">Some pages use a table layout with many nested tables. In these cases the table, tr, td-elements of a pattern that are supposed to match a single table might all match </textual><emphasis class="po-inline e730 e730"><textual class="po-textual">different</textual></emphasis><textual class="po-textual"> tables. For example </textual><programlisting class="po-block e731 e731" xml:space="preserve"><textual class="po-textual">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;{.}&lt;/td&gt;&lt;/tr&gt;+
&lt;/table&gt;</textual></programlisting><textual class="po-textual"> appears to be a good pattern to match all rows below a header row in a certain table. </textual><textual class="po-textual"> However, if table layouts are used like in 
      </textual><programlisting class="po-block e732 e732" xml:space="preserve"><textual class="po-textual">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;Header&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;bar&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</textual></programlisting><textual class="po-textual"> the table-element matches the outer table (because it still contains a descendant </textual><code class="po-atom e733 e733"><textual class="po-textual">Header</textual></code><textual class="po-textual"> text node), and the pattern selects all rows of that table, i.e. the last td-element containing </textual><code class="po-atom e734 e734"><textual class="po-textual">bar</textual></code><textual class="po-textual">. And </textual><emphasis class="po-inline e735 e735"><textual class="po-textual">not</textual></emphasis><textual class="po-textual"> the td-element containing </textual><code class="po-atom e736 e736"><textual class="po-textual">foo</textual></code><textual class="po-textual">.
      </textual></para><para class="po-block e737 e737"><textual class="po-textual">A solution would be to add an option to only match direct children of certain elements, instead all descendants. Perhaps even enable it at default for tables, although this will cause new issues with table rows never being children of the table, but of a tbody-element. </textual></para></listitem><listitem class="po-container e738 e738"><para class="po-block e739 e739"><textual class="po-textual">Despite our goal of minimality there is a lot of unnecessary redundancy in the pattern syntax. For example a frequently used pattern to read properties of a book is
      </textual><programlisting class="po-block e740 e740" xml:space="preserve"><textual class="po-textual">&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Author:&lt;/td&gt;   &lt;td&gt;{$book.author}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Title:&lt;/td&gt;    &lt;td&gt;{$book.title}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Publisher:&lt;/td&gt;&lt;td&gt;{$book.publisher}&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Year:&lt;/td&gt;     &lt;td&gt;{$book.year}&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</textual></programlisting><textual class="po-textual"> which contains many duplicated td and tr-elements. This is not a problem during the creation of the pattern, but if it needs to adapted to changes (e.g. to read divs instead tds or have the value in the third column) each tag has to updated, which is pointless work.</textual></para><para class="po-block e741 e741"><textual class="po-textual"> So perhaps some kind of "meta-pattern" needs be developed that can create a pattern programmatically within the pattern itself, like a macro in C++ or a function with access to the AST.   </textual></para></listitem><listitem class="po-container e742 e742"><para class="po-block e743 e743"><textual class="po-textual">The validation property was not as useful as expected to find errors. We assumed that an element throwing a matching error tells us, which element in the pattern was wrong/changed and should be adapted. But although this works in patterns like </textual><code class="po-atom e744 e744"><textual class="po-textual">&lt;a&gt;&lt;b&gt;&lt;c&gt;{.}&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</textual></code><textual class="po-textual">, where we can get a matching error for a, b or c and know which element is missing in the input, in patterns containing multiple alternatives like  </textual><code class="po-atom e745 e745"><textual class="po-textual">&lt;t:switch prioritized="true"&gt;&lt;a&gt;{.}&lt;/a&gt;&lt;b&gt;{.}/b&gt;</textual></code><textual class="po-textual"> we get a matching error for the t:switch expression and cannot distinguish if the input was supposed to match a or b.</textual></para><para class="po-block e746 e746"><textual class="po-textual">Therefore the error reporting </textual><textual class="po-textual">has to somehow consider all possible pattern branches and report the error for the most likely one.</textual></para></listitem><listitem class="po-container e747 e747"><para class="po-block e748 e748"><textual class="po-textual">
      Currently every pattern is represented by a valid XML file, which is useful for automatic parsing/processing and familiarity.
      However, the pattern syntax can be greatly simplified by allowing non-valid XML patterns.
      The first possible extension in this direction is to allow regular expressions as element and attribute names. A simple pattern like
      </textual><programlisting class="po-block e749 e749" xml:space="preserve"><textual class="po-textual">&lt;a|b|c foo|bar="123" x.z="17" /&gt;</textual></programlisting><textual class="po-textual">
      could then replace this more complex, but equivalent pattern:
      </textual><programlisting class="po-block e750 e750" xml:space="preserve"><textual class="po-textual">&lt;t:switch&gt;
&lt;a foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;a bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;b foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;b bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;c foo="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;c bar="123" t:condition="exists(@*[matches(name(.), '^x.z$') and . eq '17'])" /&gt;
&lt;/t:switch&gt;</textual></programlisting><textual class="po-textual">
      </textual></para><para class="po-block e751 e751"><textual class="po-textual">      
      The second extension is to allow other attribute value separators than the </textual><code class="po-atom e752 e752"><textual class="po-textual">=</textual></code><textual class="po-textual"> sign which would specify the matching mode used for the string value. 
      
      E.g. the symbols </textual><code class="po-atom e753 e753"><textual class="po-textual">==</textual></code><textual class="po-textual">, </textual><code class="po-atom e754 e754"><textual class="po-textual">~=</textual></code><textual class="po-textual">, </textual><code class="po-atom e755 e755"><textual class="po-textual">^=</textual></code><textual class="po-textual">, </textual><code class="po-atom e756 e756"><textual class="po-textual">$=</textual></code><textual class="po-textual">, </textual><code class="po-atom e757 e757"><textual class="po-textual">*=</textual></code><textual class="po-textual"> or </textual><code class="po-atom e758 e758"><textual class="po-textual">|=</textual></code><textual class="po-textual"> could be used to specify the resp. matching mode
      </textual><code class="po-atom e759 e759"><textual class="po-textual">eq</textual></code><textual class="po-textual">, </textual><code class="po-atom e760 e760"><textual class="po-textual">matches</textual></code><textual class="po-textual">, </textual><code class="po-atom e761 e761"><textual class="po-textual">starts-with</textual></code><textual class="po-textual">, </textual><code class="po-atom e762 e762"><textual class="po-textual">ends-with</textual></code><textual class="po-textual">, </textual><code class="po-atom e763 e763"><textual class="po-textual">contains</textual></code><textual class="po-textual"> or </textual><code class="po-atom e764 e764"><textual class="po-textual">list-contains</textual></code><textual class="po-textual">.
      
      For example </textual><code class="po-atom e765 e765"><textual class="po-textual">foo ^= "bar"</textual></code><textual class="po-textual"> would match a foo attribute starting with "bar".
      
      </textual></para><para class="po-block e766 e766"><textual class="po-textual">      
      The third is to allow omitted end tags. Currently half of the pattern consists of redunant end tags, which is not very useful. If we allow the old SGML syntax with closing short tags </textual><code class="po-atom e767 e767"><textual class="po-textual">&lt;/&gt;</textual></code><textual class="po-textual"> or null end tags </textual><code class="po-atom e768 e768"><textual class="po-textual">&lt;element/ ... /</textual></code><textual class="po-textual"> in the pattern, it could be much shorter. Since we already match the patterns  against HTML as well, there is no point in keeping a pure XML syntax.
      </textual></para></listitem><listitem class="po-container e769 e769"><para class="po-block e770 e770"><textual class="po-textual">
      The patterns as defined so far only match against the string values of the nodes. It might be useful to combine them with XML schemas to match on typed values, distinguishing e.g. </textual><code class="po-atom e771 e771"><textual class="po-textual">xs:integer(17)</textual></code><textual class="po-textual"> and </textual><code class="po-atom e772 e772"><textual class="po-textual">xs:string("17")</textual></code><textual class="po-textual">.
      </textual></para></listitem><listitem class="po-container e773 e773"><para class="po-block e774 e774"><textual class="po-textual">
      </textual><textual class="po-textual">Our current implementation performs naive backtracking, following exactly the recursive definition of the matching process, which is well suited for the fast testing of experimental syntaxes. It is, however, not very performant. It is therefore worthwhile to research more efficient ways to implement patterns. One faster way would be to use dynamic programming, using a </textual><code class="po-atom e775 e775"><textual class="po-textual">n*m</textual></code><textual class="po-textual"> table tracking which pattern element can be matched to which input element. Another way might be to model the matching as NFA like a regular expression.  A third way would be an automated conversion of a pattern to normal path expressions. Such an approach could benefit from the existing research on query optimization, but might miss specific optimizations applicable only to the patterns. Especially problematic from an optimization POV is that variables created in a selector expression could be later used in a condition affecting the matching. It might be a good idea to implement the special case where such usage does not occur separately. 
      </textual></para></listitem><listitem class="po-container e776 e776"><para class="po-block e777 e777"><textual class="po-textual">
      The basic node patterns do not have a syntax for back (like </textual><code class="po-atom e778 e778"><textual class="po-textual">parent::</textual></code><textual class="po-textual">) or forward (like </textual><code class="po-atom e779 e779"><textual class="po-textual">following::</textual></code><textual class="po-textual">) references. Therefore they seem to present a  natural way to write queries with streaming parsers that read one element at the time and do not store preceding or following nodes.   </textual><textual class="po-textual">
      It is worthwhile to investigate how well and efficient they can be combined with such a streaming XML parser. 
      </textual></para></listitem><listitem class="po-container e780 e780"><para class="po-block e781 e781"><textual class="po-textual">
      Once further extensions have been researched, it might be a good idea to convince the W3C to add patterns to the next XQuery standard.
      </textual></para></listitem></itemizedlist></section><section class="po-hcontainer e782 e782"><title class="po-block e783 e783"><textual class="po-textual">Conclusion</textual></title><para class="po-block e784 e784"><textual class="po-textual">We have presented a true pattern matching on XML and HTML nodes with a syntax based on regular expressions and XQuery, which provides an intuitive way to write  queries for XML and HTML data. It was then successfully extended to matching on arbitrary JSONiq data, albeit with a less intuitive syntax.  </textual></para><para class="po-block e785 e785"><textual class="po-textual">It was then shown that it can be integrated naturally in XQuery </textual><code class="po-atom e786 e786"><textual class="po-textual">switch</textual></code><textual class="po-textual">, </textual><code class="po-atom e787 e787"><textual class="po-textual">let</textual></code><textual class="po-textual"> and </textual><code class="po-atom e788 e788"><textual class="po-textual">for</textual></code><textual class="po-textual"> expressions, allowing one to use patterns in XQuery and XQuery expressions in patterns. </textual></para><para class="po-block e789 e789"><textual class="po-textual">We conclude with the experiences of many years of pattern matching usage that such a matching is very useful to run queries on schema-less data like HTML pages, although there are still open issues and possible further syntax extensions that need to be researched. </textual></para></section><section class="po-hcontainer e790 e790"><title class="po-block e791 e791"><textual class="po-textual">Acknowledgment</textual></title><para class="po-block e792 e792"><textual class="po-textual">This paper was supported by the Graduate School for Computing in Medicine and Life Sciences funded by Germany’s Excellence Initiative [DFG GSC 235/1].</textual></para></section><bibliography class="po-hcontainer e793 e793"><title class="po-block e794 e794"><textual class="po-textual">Bibliography</textual></title><bibliomixed class="po-block e795 e795" xml:id="xmlql" xreflabel="XMLQL"><textual class="po-textual">Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and Dan Suciu. </textual><emphasis class="po-inline e796 e796" role="ital"><textual class="po-textual"> XML-QL: A Query Language for XML</textual></emphasis><textual class="po-textual">. 1998. </textual><link class="po-inline e797 e797" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/1998/NOTE-xml-ql-19980819</textual></link></bibliomixed><bibliomixed class="po-block e798 e798" xml:id="xml" xreflabel="XML"><textual class="po-textual">W3C </textual><emphasis class="po-inline e799 e799" role="ital"><textual class="po-textual">Extensible Markup Language (XML) 1.0</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e800 e800" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual"> http://www.w3.org/TR/xml/</textual></link></bibliomixed><bibliomixed class="po-block e801 e801" xml:id="xquery" xreflabel="XQuery"><textual class="po-textual">W3C </textual><emphasis class="po-inline e802 e802" role="ital"><textual class="po-textual">XQuery 3.0: An XML Query Language</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e803 e803" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery-30/</textual></link></bibliomixed><bibliomixed class="po-block e804 e804" xml:id="jsoniq" xreflabel="JSONiq"><textual class="po-textual">Jonathan Robie, Ghislain Fourny, Matthias Brantner, Daniela Florescu, Till Westmann, and Markos Zaharioudakis. </textual><emphasis class="po-inline e805 e805" role="ital"><textual class="po-textual">The JSON Query Language</textual></emphasis><textual class="po-textual">. </textual><link class="po-inline e806 e806" xlink:actuate="onRequest" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.jsoniq.org/docs/JSONiqExtensionToXQuery/html-single/index.html</textual></link></bibliomixed><bibliomixed class="po-block e807 e807" xml:id="scala" xreflabel="Scala"><textual class="po-textual">Odersky, M., Altherr, P., Cremet, V., Emir, B., Maneth, S., Micheloud, S., ... &amp; Zenger, M. </textual><emphasis class="po-inline e808 e808" role="ital"><textual class="po-textual">An overview of the Scala programming language</textual></emphasis><textual class="po-textual">. 2004.</textual></bibliomixed><bibliomixed class="po-block e809 e809" xml:id="rel1" xreflabel="Fischer2010"><textual class="po-textual">Peter Fischer,  Aayush Garg and Kyumars Sheykh Esmaili.   </textual><emphasis class="po-inline e810 e810" role="ital"><textual class="po-textual">Extending XQuery with a Pattern Matching Facility</textual></emphasis><textual class="po-textual">, in Database and XML Technologies, Lecture Notes in Computer Science. 2003. </textual></bibliomixed><bibliomixed class="po-block e811 e811" xml:id="rel2" xreflabel="Hosoya2003"><textual class="po-textual">Haruo Hosoya, and Benjamin C. Pierce.  </textual><emphasis class="po-inline e812 e812" role="ital"><textual class="po-textual">Regular expression pattern matching for XML</textual></emphasis><textual class="po-textual">, in Journal of Functional Programming. 2003. </textual></bibliomixed><bibliomixed class="po-block e813 e813" xml:id="rel3" xreflabel="Yao2004"><textual class="po-textual">J. T. Yao, and Ming Zhang. </textual><emphasis class="po-inline e814 e814" role="ital"><textual class="po-textual">A fast tree pattern matching algorithm for XML query</textual></emphasis><textual class="po-textual">, IEEE. 2004. </textual></bibliomixed></bibliography></article></classedDocument>