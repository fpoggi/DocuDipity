<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.2"><title class="po-block e1 e1"><textual class="po-textual">Extension of the type/token distinction to document structure</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2010</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 3 - 6, 2010</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">
     The type/token distinction introduced by C. S. Peirce and taken
     up by many others is familiar when applied to individual symbols
     or characters in a writing system, and also when applied at a
     higher level to words (and word-like objects).  
    </textual></para><para class="po-block e8 e8"><textual class="po-textual">
     Some writers apply the distinction not only at some basic or
     foundational level but also as a description of higher levels of
     organization.  This paper follows their example by outlining a
     concrete extension of the type/token distinction to all levels of
     document organization, specifying that higher-level types may
     contain sequences of lower-level types, and similarly
     for higher- and lower-level tokens. We further extend the usual
     model of types and tokens by allowing higher-level types to
     contain not just sequences of (lower-level) types 
     but also sets, bags, conjunctions and disjunctions of types. 
     This allows the system to
     deal gracefully both with indeterminate documents (e.g., a
     manuscript in which it is not clear whether a given mark on the
     page represents a 'c' or a 't') and with intentionally polyvalent
     documents, in which some marks are to be read as tokens of more
     than one type, as in the </textual><quote class="po-inline e9 e9"><textual class="po-textual">ambigram</textual></quote><textual class="po-textual">, a sort of
     combination puzzle and calligraphic artwork in which the shapes
     on the page may be read in different ways, or the same way, in
     different directions.</textual></para><para class="po-block e10 e10"><textual class="po-textual">
     This account of document structure in terms of types and tokens
     is similar in many ways to that offered by SGML, XML, and other
     systems of descriptive markup.  On this view, SGML and XML
     elements are, strictly speaking, types (and tokens) in Peirce's
     sense of those words.  Some techniques developed in other areas
     to which the type/token distinction is relevant may be useful in
     work on markup languages (and vice versa).
    </textual></para></abstract><author class="po-record e11 e11"><personname class="po-record e12 e12"><firstname class="po-field e13 e13"><textual class="po-textual">Claus</textual></firstname><surname class="po-field e14 e14"><textual class="po-textual">Huitfeldt</textual></surname></personname><personblurb class="po-container e15 e15"><para class="po-block e16 e16"><textual class="po-textual">Mag.art. Claus Huitfeldt (born 1957) is Associate Professor (førsteamanuensis) at the Department of Philosophy of the University  of Bergen since 1994.
       </textual></para><para class="po-block e17 e17"><textual class="po-textual">
	He was founding Director (1990-2000) of the Wittgenstein Archives at the University of Bergen, for which he developed the text encoding system MECS as well as the editorial methods for the publication of </textual><emphasis class="po-inline e18 e18"><textual class="po-textual">Wittgenstein's Nachlass — The Bergen Electronic Edition</textual></emphasis><textual class="po-textual">
(Oxford University Press, 2000).</textual></para><para class="po-block e19 e19"><textual class="po-textual">
	He was Research Director (2000-2002) of Aksis (Section for Culture, Language and Information Technology at the Bergen University Research Foundation). In 2003 he returned to his position at the Department of Philosophy, where he teaches modern philosophy and philosophy of language, and also gives frequent courses in text technology at the The Department of Humanistic Informatics.
       </textual></para><para class="po-block e20 e20"><textual class="po-textual">
	He was active in the Text Encoding Initiative (TEI) since 1991, and was centrally involved in the foundation of the TEI Consortium in 2001. The consortium now counts more than 90 member institutions.
       </textual></para><para class="po-block e21 e21"><textual class="po-textual">
	Huitfeldt's research interests are within philosophy of language, philosophy of technology, text theory, editorial philology and markup theory. He is currently leader of the project Markup Languages for Complex Documents (MLCD).</textual></para></personblurb><affiliation class="po-record e22 e22"><jobtitle class="po-field e23 e23"><textual class="po-textual">Associate Professor (førsteamanuensis)</textual></jobtitle><orgname class="po-block e24 e24"><textual class="po-textual">Department of Philophy, University of Bergen</textual></orgname></affiliation></author><author class="po-record e25 e25"><personname class="po-record e26 e26"><firstname class="po-field e27 e27"><textual class="po-textual">Yves</textual></firstname><surname class="po-field e28 e28"><textual class="po-textual">Marcoux</textual></surname></personname><personblurb class="po-container e29 e29"><para class="po-block e30 e30"><textual class="po-textual">Yves Marcoux is a faculty member at EBSI, University of Montréal,
 since 1991. He is mainly involved in teaching and research activities in the
 field of document informatics. Prior to his appointment at EBSI, he has worked
 for 10 years in systems maintenance and development, in Canada, the U.S., and
 Europe. He obtained his Ph.D. in theoretical computer science from University
 of Montréal in 1991. His main research interests are document semantics,
 structured document implementation methodologies, and information retrieval in
 structured documents. Through GRDS, his research group at EBSI, he has been
 principal architect for the Governmental Framework for Integrated Document
 Management, a project funded by the National Archives of Québec and by the
 Québec Treasury Board.</textual></para></personblurb><affiliation class="po-record e31 e31"><jobtitle class="po-field e32 e32"><textual class="po-textual">Associate Professor</textual></jobtitle><orgname class="po-block e33 e33"><textual class="po-textual">Université de Montréal</textual></orgname></affiliation><email class="po-field e34 e34"><textual class="po-textual">yves.marcoux@umontreal.ca</textual></email></author><author class="po-record e35 e35"><personname class="po-record e36 e36"><firstname class="po-field e37 e37"><textual class="po-textual">C. M.</textual></firstname><surname class="po-field e38 e38"><textual class="po-textual">Sperberg-McQueen</textual></surname></personname><personblurb class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">C. M. Sperberg-McQueen is a consultant specializing
in preserving and providing access to cultural and scientific data.
He has served as co-editor of the XML 1.0
specification, the Guidelines of the Text Encoding Initiative, and the
XML Schema Definition Language (XSDL) 1.1 specification.  He holds a
doctorate in comparative literature.
</textual></para></personblurb><affiliation class="po-record e41 e41"><orgname class="po-block e42 e42"><textual class="po-textual">Black Mesa Technologies</textual></orgname></affiliation><email class="po-field e43 e43"><textual class="po-textual">cmsmcq@blackmesatech.com</textual></email></author><legalnotice class="po-container e44 e44"><para class="po-block e45 e45"><textual class="po-textual">Copyright © 2010 by the authors.</textual></para></legalnotice></info><section class="po-hcontainer e46 e46" xml:id="intro"><title class="po-block e47 e47"><textual class="po-textual">Introduction</textual></title><para class="po-block e48 e48"><textual class="po-textual">We propose to extend the familiar type/token distinction in two
     ways.  First, we apply it not only to words or to atomic
     characters but also to higher-level document structures; second,
     we introduce mechanisms for handling tokens whose type identity
     is ambiguous either because of uncertainty or because of
     intentional use of multiple meanings.  In the first point, we
     follow the example of a number of other authors who have
     distinguished at multiple levels what we here call tokens from
     what we here call types; we offer a more explicit and formal
     account than has been usual. Recasting the familiar type/instance
     distinction as a type/token distinction has the helpful
     consequence of providing a unified account of document structure
     at all levels, instead of treating the character and element
     levels as essentially different.
    </textual></para><para class="po-block e49 e49"><textual class="po-textual">The ideas presented here originally arose (as some of the
     examples will show) in the context of work on the logical
     structure of transcription, but they concern general questions of
     document structure.</textual></para><para class="po-block e50 e50"><textual class="po-textual">The next section (</textual><xref class="po-milestone e51 e51" linkend="giants"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">)
     presents a terse survey of the type/token distinction, as we
     believe it is conventionally accepted.  The following section 
     (</textual><xref class="po-milestone e52 e52" linkend="ttx"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) elaborates the conventional view
     and extends it in three ways. First, our account handles not only
     atomic but also compound types; our compound types and compound
     tokens include the structures conventionally recognized and
     marked up in descriptive markup.  Second, we propose a mechanism
     that handles not only the usual case in which a token has a
     single known type, but also less common and more difficult cases
     in which there is uncertainty about which type to assign to a
     token, or in which a token has been intentionally designed to
     belong to multiple types.  Third, we introduce the notions of
     type repertoire and type system to clarify the ways in which
     multi-level types and tokens obey the normal rule stipulating
     that any token instantiates just one type. The penultimate
     section (</textual><xref class="po-milestone e53 e53" linkend="ttmk"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) discusses some of the obvious parallels between
     markup languages like XML and the application of the type/token
     distinction to document structures at levels above the individual
     character or word. The final section (</textual><xref class="po-milestone e54 e54" linkend="conclusion"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) contains some concluding remarks and
     speculations.
      
    </textual></para></section><section class="po-hcontainer e55 e55" xml:id="giants"><title class="po-block e56 e56"><textual class="po-textual">The type/token distinction</textual></title><para class="po-block e57 e57"><textual class="po-textual">
     The distinction between strings as </textual><emphasis class="po-inline e58 e58"><textual class="po-textual">types</textual></emphasis><textual class="po-textual"> and strings
     as </textual><emphasis class="po-inline e59 e59"><textual class="po-textual">tokens</textual></emphasis><textual class="po-textual"> is a familiar one to almost any
      programmer, but what they have in mind is not quite
      the same as was described by Peirce when he introduced the distinction
     [</textual><xref class="po-milestone e60 e60" linkend="Peirce"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual></para><para class="po-block e61 e61"><textual class="po-textual">Consider a sequence of words on a page, for example the first
     sentence of the Algol 60 report [</textual><xref class="po-milestone e62 e62" linkend="Algol"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], 
     and the question </textual><quote class="po-inline e63 e63"><textual class="po-textual">How many
       words are  in this sentence?</textual></quote><textual class="po-textual">
     </textual><blockquote class="po-container e64 e64"><para class="po-block e65 e65"><textual class="po-textual">After the publication of a preliminary report
      on the algorithmic language ALGOL, as prepared at a conference
      in Zürich in 1958, much interest in the ALGOL language 
      developed.</textual></para></blockquote><textual class="po-textual">
     In one sense, there are 28 words; the sentence is a sequence of
     words, and the length of the sequence is 28.  In another sense,
     however, the sentence contains only 21 words (assuming that </textual><quote class="po-inline e66 e66"><textual class="po-textual">1958</textual></quote><textual class="po-textual">
     counts as a word), some of which
     (</textual><quote class="po-inline e67 e67"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e68 e68"><textual class="po-textual">a</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e69 e69"><textual class="po-textual">in</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e70 e70"><textual class="po-textual">language</textual></quote><textual class="po-textual">, and </textual><quote class="po-inline e71 e71"><textual class="po-textual">the</textual></quote><textual class="po-textual">)
     appear more than once.  In some contexts, it would be convenient to
     treat these repeated words as distinct, and in other contexts,
     to treat them as identical.
      
     
    </textual></para><para class="po-block e72 e72"><textual class="po-textual">Peirce provided a simple way to do this, by distinguishing the
     two senses of </textual><emphasis class="po-inline e73 e73"><textual class="po-textual">word</textual></emphasis><textual class="po-textual"> at issue here. He
      called words in the first sense </textual><emphasis class="po-inline e74 e74"><textual class="po-textual">tokens</textual></emphasis><textual class="po-textual"> and in the 
     second sense
     </textual><emphasis class="po-inline e75 e75"><textual class="po-textual">types</textual></emphasis><textual class="po-textual">.  A token, in Peirce's account, is a </textual><quote class="po-inline e76 e76"><textual class="po-textual">thing
      which is in some single place at any one instant of time</textual></quote><textual class="po-textual">
     — this example, the tokens are the physical marks of ink
     on the page (or the physical illumination of the pixels on the
     screen).  Types, meanwhile, are in the usual account the abstract
     objects we identify when we say that the second and ninth words
     (tokens) of the sentence </textual><quote class="po-inline e77 e77"><textual class="po-textual">are the same word</textual></quote><textual class="po-textual">.
    </textual></para><section class="po-hcontainer e78 e78" xml:id="tt_peirce"><title class="po-block e79 e79"><textual class="po-textual">Peirce's account</textual></title><para class="po-block e80 e80"><textual class="po-textual">Peirce's account of the distinction runs as follows
      [</textual><xref class="po-milestone e81 e81" linkend="Peirce"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] pp. 423-4:
     </textual><blockquote class="po-container e82 e82"><para class="po-block e83 e83"><textual class="po-textual">A common mode of estimating the amount of
      matter in a MS. or printed book is to count the number of words.
      There will ordinarily be about twenty
      </textual><emphasis class="po-inline e84 e84"><textual class="po-textual">the</textual></emphasis><textual class="po-textual">s on a page, and of course they count
      as twenty words. In another sense of the word </textual><quote class="po-inline e85 e85"><textual class="po-textual">word,</textual></quote><textual class="po-textual">
      however, there is but one word </textual><quote class="po-inline e86 e86"><textual class="po-textual">the</textual></quote><textual class="po-textual"> in the English
      language; and it is impossible that this word should lie visibly
      on a page or be heard in any voice, for the reason
      that it is not a Single thing or Single event. It does not
      exist; it only determines things that do exist.  Such a
      definitely significant Form, I propose to term a
      </textual><emphasis class="po-inline e87 e87"><textual class="po-textual">Type</textual></emphasis><textual class="po-textual">.  A Single event which happens once and whose
      identity is limited to that one happening or a Single object or
      thing which is in some single place at any one instant of time,
      such event or thing being significant only as occurring just
      when and where it does, such as this or that word on a single
      line of a single page of a single copy of a book, I will venture
      to call a </textual><emphasis class="po-inline e88 e88"><textual class="po-textual">Token</textual></emphasis><textual class="po-textual">. [...] In order that a Type may be
      used, it has to be embodied in a Token which shall be a sign of
      the Type, and thereby of the object the Type signifies. I
      propose to call such a Token of a Type an </textual><emphasis class="po-inline e89 e89"><textual class="po-textual">Instance</textual></emphasis><textual class="po-textual">
      of the Type.  Thus, there may be twenty Instances of the type
      </textual><quote class="po-inline e90 e90"><textual class="po-textual">the</textual></quote><textual class="po-textual"> on a page.</textual></para></blockquote><textual class="po-textual">
    </textual></para><para class="po-block e91 e91"><textual class="po-textual">As may be seen, Peirce's distinction stresses the opposition
      between the concrete physical existence of the token and the
      abstract nature (and, in Peirce's terminology, the
      non-existence!) of the type.  He also establishes the usage that
      tokens can be said to </textual><emphasis class="po-inline e92 e92"><textual class="po-textual">instantiate</textual></emphasis><textual class="po-textual"> 
      types.</textual><footnote class="po-popup e93 e93"><para class="po-block e94 e94"><textual class="po-textual">It may be worth noting that Peirce makes
       explicitly clear that blank spaces between words are also to be
       considered tokens of a specific type. The quoted paragraph
       continues as follows:
       </textual><quote class="po-inline e95 e95"><textual class="po-textual">The term (Existential)
	Graph will be taken in the sense of a Type; and the act of
	embodying it in a Graph-Instance will be termed scribing the
	Graph (not the Instance), whether the Instance be written,
	drawn, or incised. A mere blank place is a Graph-Instance, and
	the Blank per se is a Graph - but I shall ask you to assume
	that it has the peculiarity that it cannot be abolished from
	any Area on which it is scribed as long as that Area
	exists.</textual></quote><textual class="po-textual"> </textual></para></footnote><textual class="po-textual"> 
      To be a token, in fact, is  to instantiate
      a type (and vice versa); there are no tokens without associated
      types.</textual><footnote class="po-popup e96 e96"><para class="po-block e97 e97"><textual class="po-textual">We remain agnostic on the related
       question whether there can be types without associated
       tokens.</textual></para></footnote><textual class="po-textual">
     </textual></para></section><section class="po-hcontainer e98 e98" xml:id="nonpar"><title class="po-block e99 e99"><textual class="po-textual">Other usages of </textual><emphasis class="po-inline e100 e100"><textual class="po-textual">type</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e101 e101"><textual class="po-textual">token</textual></emphasis></title><para class="po-block e102 e102"><textual class="po-textual">There are a number of other usages of the terms </textual><emphasis class="po-inline e103 e103"><textual class="po-textual">type</textual></emphasis><textual class="po-textual">
      and </textual><emphasis class="po-inline e104 e104"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> which differ from Peirce's, and
      should not be confused with it.</textual></para><para class="po-block e105 e105"><textual class="po-textual">Peirce's types have nothing to do with Bertrand Russell's
      </textual><quote class="po-inline e106 e106"><textual class="po-textual">logical types</textual></quote><textual class="po-textual">, which are classes or orders
      of sets and belong to a completely different story.  The
      (data) types of programming languages and XML schema languages
      are similarly distinct concepts.
     </textual></para><para class="po-block e107 e107"><textual class="po-textual">
      Some common usages (not only in computing, but particularly
      visible there), employ an opposition between </textual><emphasis class="po-inline e108 e108"><textual class="po-textual">token</textual></emphasis><textual class="po-textual">
      and </textual><emphasis class="po-inline e109 e109"><textual class="po-textual">type</textual></emphasis><textual class="po-textual"> similar to Peirce's, but divorce it more
      or less completely from the opposition of concrete physical
      existence and abstraction; any instance of a particular string
      (more precisely, of a particular string type) is taken as a
      token of that type. In a related usage, </textual><emphasis class="po-inline e110 e110"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> is
      also taken simply as one item in the results produced by a
      tokenizer, whose task it is to divide a sequence of characters
      into units. 
      A more careful usage reserves the word
      </textual><emphasis class="po-inline e111 e111"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> for concrete physical phenomena and
      uses the term </textual><emphasis class="po-inline e112 e112"><textual class="po-textual">occurrence</textual></emphasis><textual class="po-textual"> for what common
      computing terminology calls tokens, reserving
      </textual><emphasis class="po-inline e113 e113"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> for particular physical
      realizations of the type.</textual><footnote class="po-popup e114 e114"><para class="po-block e115 e115"><textual class="po-textual">The concept of
       occurrences is not without its own complications and
       subtleties, but we will not detain the reader with a discussion
       of them.  A helpful discussion of the distinction between
       tokens and occurrences, and a useful summary of some of the
       related philosophical issues, may be found in [</textual><xref class="po-milestone e116 e116" linkend="Wetzel2008"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] and [</textual><xref class="po-milestone e117 e117" linkend="Wetzel2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and also our discussion further below in
       section </textual><xref class="po-milestone e118 e118" linkend="ttlevels"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para></footnote><textual class="po-textual"> 
    </textual></para><para class="po-block e119 e119"><textual class="po-textual">
     In this paper, we do distinguish between tokens, types, and occurrences of types. 
     The latter will be encountered mainly in what we will call 
     </textual><emphasis class="po-inline e120 e120"><textual class="po-textual">compound types</textual></emphasis><textual class="po-textual">, for example </textual><emphasis class="po-inline e121 e121"><textual class="po-textual">sets</textual></emphasis><textual class="po-textual"> 
     or </textual><emphasis class="po-inline e122 e122"><textual class="po-textual">sequences</textual></emphasis><textual class="po-textual"> of (other) types. In those cases, 
     the components of the compound type are implicitly understood to be 
     </textual><emphasis class="po-inline e123 e123"><textual class="po-textual">occurrences</textual></emphasis><textual class="po-textual"> of types, so we will not say, for example, 
     </textual><quote class="po-inline e124 e124"><textual class="po-textual">sequence of occurrences of types</textual></quote><textual class="po-textual"> (which would be somewhat 
     pleonastic), but simply </textual><quote class="po-inline e125 e125"><textual class="po-textual">sequence of types.</textual></quote></para></section><section class="po-hcontainer e126 e126" xml:id="tt_other"><title class="po-block e127 e127"><textual class="po-textual">Related distinctions</textual></title><para class="po-block e128 e128"><textual class="po-textual">The type/token distinction is sometimes met with under different
      names (and those who use those different ways of speaking about
      things may or may not agree with our claim that what they
      are speaking about is in fact the type/token distinction).  In
      this section we mention two of the more important, without
      being able to discuss them in the detail they deserve.
     </textual></para><para class="po-block e129 e129"><textual class="po-textual">Nelson Goodman describes the constituents of a
      </textual><emphasis class="po-inline e130 e130"><textual class="po-textual">notational system</textual></emphasis><textual class="po-textual"> thus 
      [</textual><xref class="po-milestone e131 e131" linkend="Goodman"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], p. 131: 
      </textual><blockquote class="po-container e132 e132"><para class="po-block e133 e133"><textual class="po-textual">Characters are certain classes of utterances or
       inscriptions or marks. (… 
       an
       inscription is any mark — visual, auditory, etc. —
       that belongs to a character.) 
        Now the essential feature of a
       character in a notation is that its members may be freely
       exchanged for one another without any syntactical effect; or
       more literally, since actual marks are seldom moved about and
       exchanged, that all inscriptions of a given character be
       syntactically equivalent.  In other words, being instances of
       one character in a notation must constitute a sufficient
       condition for marks being </textual><quote class="po-inline e134 e134"><textual class="po-textual">true copies</textual></quote><textual class="po-textual"> or
       replicas of each other, or being spelled the same way.</textual></para></blockquote><textual class="po-textual">       
      Goodman speaks here of characters being classes of inscriptions,
      but he makes clear elsewhere that this is merely a convenient
      way of expressing himself and is not intended to commit him to
      the existence of classes or sets: in a more careful formulation,
      presumably, Goodman would say that characters are the
      mereological sums of their inscriptions:  complex individuals
      (entities) made of the individual inscriptions of the
      character.</textual><footnote class="po-popup e135 e135"><para class="po-block e136 e136"><textual class="po-textual">The notion of such spatially and
       temporally disjoint objects forming a single whole may trouble
       some readers, but consideration of such noun phrases as </textual><quote class="po-inline e137 e137"><textual class="po-textual">the
	Aleutian islands</textual></quote><textual class="po-textual">, </textual><quote class="po-inline e138 e138"><textual class="po-textual">the Olympic Games</textual></quote><textual class="po-textual">, and
       </textual><quote class="po-inline e139 e139"><textual class="po-textual">Poland</textual></quote><textual class="po-textual"> may persuade such readers that some cases (at
       least) of temporal and physical disjointness seem to pass
       without comment.</textual></para></footnote><textual class="po-textual">
     </textual></para><para class="po-block e140 e140"><textual class="po-textual">We take Goodman's opposition between </textual><emphasis class="po-inline e141 e141"><textual class="po-textual">inscription</textual></emphasis><textual class="po-textual">
      and </textual><emphasis class="po-inline e142 e142"><textual class="po-textual">character</textual></emphasis><textual class="po-textual"> to be the same as, or very similar
      to, Peirce's opposition of token and type. The properties
      Goodman ascribes to characters and inscriptions are precisely
      those of types and tokens.  Goodman makes explicit some
      properties of types and tokens which are part of the usual
      view of the matter but are not explicit in the passage from 
      Peirce quoted above.  In particular:
      </textual><itemizedlist class="po-table e143 e143"><listitem class="po-container e144 e144"><para class="po-block e145 e145"><textual class="po-textual">No token is a token of more than one 
	type.</textual><footnote class="po-popup e146 e146"><para class="po-block e147 e147"><textual class="po-textual">In Goodman's terms, </textual><quote class="po-inline e148 e148"><textual class="po-textual">no mark may belong to
	  more than one character</textual></quote><textual class="po-textual"> [</textual><xref class="po-milestone e149 e149" linkend="Goodman"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] 
	 p. 133.</textual></para></footnote><textual class="po-textual"> In consequence, types are
	disjoint from each other.</textual></para></listitem><listitem class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">Any two types must be </textual><emphasis class="po-inline e152 e152"><textual class="po-textual">finitely differentiated</textual></emphasis><textual class="po-textual">
	from each other; it must always be possible, in principle, to
	distinguish tokens of one type from tokens of another.
	(This does not mean that it will always be easy or possible
	in practice, only that in any system of types it is not
	possible to have two which are not in principle 
	distinguishable from each other.)
       </textual></para></listitem></itemizedlist><textual class="po-textual">
      The full exploitation of Goodman's work for illumination of
      the type/token distinction remains a desideratum for the future.
     </textual></para><para class="po-block e153 e153"><textual class="po-textual">The type/token distinction also resembles the distinction made
      by most phonologists between specific individual sounds 
      or configurations of the vocal organs
      (</textual><emphasis class="po-inline e154 e154"><textual class="po-textual">phones</textual></emphasis><textual class="po-textual">) and the distinctive units of phonology
      (</textual><emphasis class="po-inline e155 e155"><textual class="po-textual">phonemes</textual></emphasis><textual class="po-textual">).</textual><footnote class="po-popup e156 e156"><para class="po-block e157 e157"><textual class="po-textual">One outstanding
       difference should probably be mentioned:  while Peirce
       explicitly contrasts the concrete token with the abstract
       type, the phones discussed by linguists and captured in
       phonetic transcriptions whether broad or narrow are not
       concrete sounds but abstract classes of sounds.  This does
       not, however, seem to us to make the concept of phoneme
       irrelevant to our topic:  like a type, a phoneme provides 
       a unit which serves to make identical many things which 
       would otherwise be distinct.  It does not matter for our
       purposes whether those things are abstract phones or
       concrete segments of utterances.</textual></para></footnote><textual class="po-textual"> 
      Goodman's remark about the equivalence
      (at least for syntactic purposes) of the different tokens of a
      type recalls the occasional supposition by phonologists that
      different realizations of the same phoneme may be interchanged
      freely without affecting the acceptability of the utterance.
      
     </textual></para><para class="po-block e158 e158"><textual class="po-textual">
      The phone/phoneme distinction allows linguists to treat sounds
      in different utterances (or at different locations in the same
      utterance) as identical for certain purposes, and distinct for
      others.  It thus serves a function analogous to the one we noted
      above for the type/token distinction.  Like types, phonemes
      are instantiated by physical phenomena which can vary widely in
      detail.  Like types, they are taken to be disjoint from each
      other (they serve, in a common description, as </textual><quote class="po-inline e159 e159"><textual class="po-textual">contrastive
      units</textual></quote><textual class="po-textual">, which we take to mean that one of their functions 
      is to be distinct from each other).
     </textual></para><para class="po-block e160 e160"><textual class="po-textual">Much of the machinery of phonology can usefully be applied to
      types and tokens. Just as phonemes can almost always be realized
      by a number of different phonetic variants (allophones), with
      the choice of allophone often determined by the phonetic
      environment, so also do the tokens of a type frequently fall
      into subclasses which may vary depending on environment or other
      factors.  Conventionally minimal pairs (pairs of words which
      differ only in a single sound) are taken as evidence for
      distinctions among phonemes; similarly minimal pairs can be used
      to distinguish different types from each other.  And just as
      phonologists have found it helpful to define phonemes in terms
      of sets of minimally distinctive features, so also it may
      prove helpful to define types in terms of distinctive
      features.  It is interesting to note that defining types
      in terms of finite sets of distinctive features guarantees
      that any type so defined will satisfy Goodman's requirement
      that it be finitely differentiated from other types.
     </textual></para></section><section class="po-hcontainer e161 e161" xml:id="ttlevels"><title class="po-block e162 e162"><textual class="po-textual">Types and tokens at different levels</textual></title><para class="po-block e163 e163"><textual class="po-textual">One further topic should be discussed at least briefly before
      we proceed with our elaboration of the type/token distinction.
      As the title of the paper indicates, its central idea is that
      the type/token distinction can be applied not just to words and
      characters, but also to higher-level document structures. Since
      document structures are generally understood to have internal
      structure and to nest within other document structures, we 
      must necessarily consider both types and tokens as capable
      of nesting and having internal structure.</textual></para><para class="po-block e164 e164"><textual class="po-textual">This appears not to be the most common view of the type/token
      distinction.  The distinction is sometimes applied at the
      character level, and sometimes at the type level, but not
      (usually) at both levels at the same time. In the passage quoted
      above, for example, Peirce identifies types and tokens only as
      ways of looking at words, without mentioning their relation to
      types or tokens at lower or higher levels of analysis.</textual></para><para class="po-block e165 e165"><textual class="po-textual">It is not unknown, however, to apply the type/token
      distinction at multiple levels.</textual></para><para class="po-block e166 e166"><textual class="po-textual">Goodman, for example, explicitly applies the term
      </textual><emphasis class="po-inline e167 e167"><textual class="po-textual">character</textual></emphasis><textual class="po-textual"> things which may contain other
      characters, and expects this to be the normal case:
      </textual><quote class="po-inline e168 e168"><textual class="po-textual">Any symbol scheme consists of characters,
      usually with modes of combining them to form others.</textual></quote><textual class="po-textual"> 
       
      So in Goodman's sense, the initial </textual><quote class="po-inline e169 e169"><textual class="po-textual">A</textual></quote><textual class="po-textual"> of </textual><quote class="po-inline e170 e170"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual"> is a
      character, and so is </textual><quote class="po-inline e171 e171"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual"> itself.  The first sentence of
      the Algol report can be regarded as a character in the same
      sense, as can the paragraph in which it occurs, and after a few
      more combinations at higher and higher levels, the Algol 60
      report itself as a whole.  (Or, in the terminology we prefer as
      less confusing to users of Unicode, the initial </textual><quote class="po-inline e172 e172"><textual class="po-textual">A</textual></quote><textual class="po-textual"> of
      </textual><quote class="po-inline e173 e173"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual">, the word </textual><quote class="po-inline e174 e174"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual"> itself, and so on, are all
      types at various levels, instantiated by tokens at similarly
      various levels.)
    </textual></para><para class="po-block e175 e175"><textual class="po-textual">The linguistic concept of phone and phoneme does not allow
      phonemes to nest.  But the idea of phonetic/phonemic contrasts
      has been widely applied in other areas of linguistics, perhaps
      most widely and visibly by the linguist Kenneth L. Pike.  Pike
      generalized the distinction between phonetic and phonemic
      phenomena, coining the terms </textual><emphasis class="po-inline e176 e176"><textual class="po-textual">emic</textual></emphasis><textual class="po-textual"> and
      </textual><emphasis class="po-inline e177 e177"><textual class="po-textual">etic</textual></emphasis><textual class="po-textual">, and applied the distinction not
      only to other areas of linguistic analysis but also to virtually
      all of human behavior [</textual><xref class="po-milestone e178 e178" linkend="Pike"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">]. The
      emic/etic distinction has apparently achieved wide currency in
      some schools of anthropology and sociology.  And when 
      both phonological and other linguistic levels are analysed
      in terms of emic and etic units, it is unavoidable that
      some of those units will have internal structure and nest
      in other emic and etic units.
     </textual></para><para class="po-block e179 e179"><textual class="po-textual">Finally, recent discussions of types and tokens by the
      philosopher Linda Wetzel have devoted significant attention to
      questions that arise when considering tokens, or types, at
      multiple levels.  If we consider any concrete realization of the
      sentence from the Algol report quoted above (i.e. any token of
      the sentence), then it is easy enough to see that the sentence
      token can be decomposed into word tokens, and the word tokens
      into character tokens.  But of what, asks Wetzel, is the
      sentence </textual><emphasis class="po-inline e180 e180"><textual class="po-textual">type</textual></emphasis><textual class="po-textual"> composed? It cannot be composed of
      word tokens, because as a type it is abstract.  It cannot be
      composed simply of word types, because the sentence is 28 words
      long, but there are only 21 word types available for the job.
      Wetzel concludes, after painstaking investigation of
      alternatives, arguments, and counter-arguments, that the
      sentence type consists of 28 occurrences 
      of word types.  She
      elucidates the concept of occurrence with the aid of an appeal
      to sequences, and then generalizes it to situations where the
      parts of a larger whole are not arranged in sequences.
     </textual></para><para class="po-block e181 e181"><textual class="po-textual">Another issue raised by Wetzel may be worth mentioning.
      In cases where the containing string is written out in full,
      each </textual><emphasis class="po-inline e182 e182"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> in the string will (as always)
      constitute a different occurrence of a type, and each occurrence
      of a type will be signaled by a different token. This has led
      some philosophers to doubt the utility of any distinction
      between occurrences and tokens.  How, they ask, can a type occur
      multiple times in a sequence (or other structure) unless it is
      instantiated by a different token for each occurrence? The
      question takes on a particular interest in the context of SGML
      and XML, where multiple references to an entity can in fact
      easily produce multiple occurrences of a type from a single
      token.  Macros as handled by the C pre-processor have the same
      effect.  Examples outside of mechanical systems appear to
      be less common, but they do exist.  In printed versions of
      ballads and other songs with refrains, it is not uncommon
      for only the first occurrence of the refrain to be printed
      in full, while others are indicated only by the word
      </textual><emphasis class="po-inline e183 e183"><textual class="po-textual">Refrain</textual></emphasis><textual class="po-textual">, which functions here as a sort
      of macro or entity reference.  And repeat-marks in music
      seem to make the note tokens so marked correspond to 
      multiple note-type occurrences in the music.
     </textual></para></section></section><section class="po-hcontainer e184 e184" xml:id="ttx"><title class="po-block e185 e185"><textual class="po-textual">Extensions to the conventional view of types and tokens</textual></title><para class="po-block e186 e186"><textual class="po-textual">In this section we elaborate and extend the conventional
     type/token distinction, and provide a formal model for it. The
     formal model is expressed using the syntax of Alloy, a modeling
     tool developed by Daniel Jackson and his research team 
     [</textual><xref class="po-milestone e187 e187" linkend="Jackson"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].</textual><footnote class="po-popup e188 e188"><para class="po-block e189 e189"><textual class="po-textual">Other
      notations could serve the purpose as well; we choose Alloy
      because it has a reasonably clear, easily learnable logical
      notation and convenient, useful tools for checking the model.
      We offer no systematic introduction to Alloy syntax here; the
      reader is directed to the Alloy web site at
      </textual><link class="po-inline e190 e190" xlink:actuate="onRequest" xlink:href="http://alloy.mit.edu/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://alloy.mit.edu/</textual></link><textual class="po-textual"> and to Jackson's book [</textual><xref class="po-milestone e191 e191" linkend="Jackson"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">].  The reader unfamiliar with
      Alloy notation should be able to follow the essentials of the
      discussion, since every salient property of the model is stated
      both in Alloy and in English prose.</textual></para></footnote><textual class="po-textual">  Readers uninterested
     in formalization may skip the Alloy extracts without loss of
     context.
    </textual></para><para class="po-block e192 e192"><textual class="po-textual">Our model goes beyond the most common version of the
     type/token distinction in three ways:</textual><orderedlist class="po-table e193 e193"><listitem class="po-container e194 e194"><para class="po-block e195 e195"><textual class="po-textual">We follow Goodman, Pike, Wetzel, and others in 
       assuming types and tokens on multiple levels.</textual></para></listitem><listitem class="po-container e196 e196"><para class="po-block e197 e197"><textual class="po-textual">We introduce disjunction of types to cover cases
       in which a reader is uncertain which type is instantiated
       by a given token, and conjunction of types to cover cases
       in which a token, contrary to the usual rule,
       instantiates multiple types.
      </textual></para></listitem><listitem class="po-container e198 e198"><para class="po-block e199 e199"><textual class="po-textual">We introduce explicit notions of type repertoires and type
       systems as a way of resolving the contradictions that otherwise
       arise from assuming both (a) that several
       </textual><quote class="po-inline e200 e200"><textual class="po-textual">levels</textual></quote><textual class="po-textual"> of type and token can coexist, and
       (b) that, as already noted, types are necessarily disjoint.
      </textual></para></listitem></orderedlist><textual class="po-textual">
    </textual></para><section class="po-hcontainer e201 e201" xml:id="ttx-basic"><title class="po-block e202 e202"><textual class="po-textual">Basic concepts</textual></title><para class="po-block e203 e203"><textual class="po-textual">The basic concepts of the model  
      we propose can be summarized
      as follows.
     </textual></para><para class="po-block e204 e204"><textual class="po-textual">The key concepts of the model are those of
      </textual><emphasis class="po-inline e205 e205"><textual class="po-textual">token</textual></emphasis><textual class="po-textual"> and of </textual><emphasis class="po-inline e206 e206"><textual class="po-textual">type</textual></emphasis><textual class="po-textual">, which are defined
      partly in opposition to each other.</textual></para><orderedlist class="po-table e207 e207"><listitem class="po-container e208 e208"><para class="po-block e209 e209"><emphasis class="po-inline e210 e210"><textual class="po-textual">Tokens</textual></emphasis><textual class="po-textual"> are concrete physical phenomena:
	marks on paper, magnetic pulses on disk or tape, etc.</textual></para></listitem></orderedlist><para class="po-block e211 e211"><textual class="po-textual">But not all physical marks are tokens:  a mark is recognized
      as a token if and only if it is recognized as being a token of
      some </textual><emphasis class="po-inline e212 e212"><textual class="po-textual">type</textual></emphasis><textual class="po-textual">.</textual><footnote class="po-popup e213 e213"><para class="po-block e214 e214"><textual class="po-textual">For purposes of this
       paper, the identity of the type is not part of the identity of
       the token. If a particular mark is either an
       </textual><emphasis class="po-inline e215 e215"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> or a </textual><emphasis class="po-inline e216 e216"><textual class="po-textual">u</textual></emphasis><textual class="po-textual">, then it
       is a token which is either of type </textual><emphasis class="po-inline e217 e217"><textual class="po-textual">n</textual></emphasis><textual class="po-textual"> or
       of type </textual><emphasis class="po-inline e218 e218"><textual class="po-textual">u</textual></emphasis><textual class="po-textual">; the two different readings
       are different readings of the same token, not readings positing
       different tokens in the document.  This allows two readers to
       disagree about which type is instantiated by a given token
       without requiring them also to disagree about the identity of
       the token in question.</textual></para></footnote><textual class="po-textual"> The recognition of
      tokens as instances of particular types requires a competent
      observer (e.g., a human reader, in the case of conventional
      writing), but we do not here address the perceptual and
      psychological processes by which humans recognize a token as
      being of a particular type.</textual></para><orderedlist class="po-table e219 e219"><listitem class="po-container e220 e220"><para class="po-block e221 e221"><emphasis class="po-inline e222 e222"><textual class="po-textual">Types</textual></emphasis><textual class="po-textual"> may be regarded as abstract
	objects represented or symbolized by tokens.</textual></para></listitem></orderedlist><para class="po-block e223 e223"><textual class="po-textual">Alternatively (in the spirit of Goodman's calculus of
      individuals) they may be regarded as collective individuals
      whose constituent parts are tokens.</textual><footnote class="po-popup e224 e224"><para class="po-block e225 e225"><textual class="po-textual">Note,
       however, that the arguments brought forward by Wetzel against
       the association of types with sets or classes may also
       apply with equal force to mereological sums 
       [</textual><xref class="po-milestone e226 e226" linkend="Wetzel2009"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] (chapter 4, section 5).
       
      </textual></para></footnote></para><para class="po-block e227 e227"><textual class="po-textual">In either case, we will say that tokens
      </textual><emphasis class="po-inline e228 e228"><textual class="po-textual">instantiate</textual></emphasis><textual class="po-textual"> types, and that types are normally
      conveyed or communicated by being instantiated by tokens.</textual></para><orderedlist class="po-table e229 e229"><listitem class="po-container e230 e230"><para class="po-block e231 e231"><textual class="po-textual">Each token instantiates exactly one type.</textual></para></listitem></orderedlist><para class="po-block e232 e232"><textual class="po-textual">It must instantiate at least one type, because a mark that
      does not instantiate a type is not a token.  And it cannot
      instantiate more than one type, because types are mutually
      disjoint and no token can be of multiple types.  (At least, this
      is the simplest way to start out.  But see further the discussion
      of type repertoires and type systems 
      </textual><link class="po-inline e233 e233" xlink:actuate="onRequest" xlink:href="#trts" xlink:show="new" xlink:type="simple"><textual class="po-textual">below</textual></link><textual class="po-textual">.)</textual></para><para class="po-block e234 e234"><textual class="po-textual">In more formal terms:  types have identity, but we specify
      no other properties for them.</textual></para><para class="po-block e235 e235"><programlisting class="po-block e236 e236" xml:space="preserve"><textual class="po-textual">abstract sig Type {}</textual></programlisting></para><para class="po-block e237 e237"><textual class="po-textual">Tokens map to types.  The only salient property of a token,
      and thus the only property we model, is the identity of 
      the type it instantiates.</textual><footnote class="po-popup e238 e238"><para class="po-block e239 e239"><textual class="po-textual">It is
       sometimes thought that the tokens of any given type necessarily
       resemble each other in some way (graphical or visual similarity
       in the case of written tokens, acoustic similarity in that of
       phonemes).  But it seems to us unlikely that any measure of 
       visual similarity could possibly be constructed that would group
       together all tokens of (for example) lower-case Latin 
       letter </textual><emphasis class="po-inline e240 e240"><textual class="po-textual">g</textual></emphasis><textual class="po-textual">, and exclude all other objects.
       As far as we can tell, the only property tokens of a given type
       are guaranteed to have in common is that they instantiate that
       type.  (One might indeed speculate that the concept of type was
       invented precisely to allow us to talk about these tokens as
       a group, since the instances of a type cannot by identified by
       appealing to any other property.)  Independently, Goodman
       and Wetzel have come to the same conclusion; Wetzel devotes much 
       of her chapter 3 to
       demolishing the view that tokens of a type must share some
       properties other than that of instantiating the type;
       see also [</textual><xref class="po-milestone e241 e241" linkend="Goodman"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], pp. 131 and 138.
       
      </textual></para></footnote></para><para class="po-block e242 e242"><programlisting class="po-block e243 e243" xml:space="preserve"><textual class="po-textual">abstract sig Token {
 type : Type
}
</textual></programlisting></para><para class="po-block e244 e244"><textual class="po-textual">The declaration </textual><code class="po-atom e245 e245"><textual class="po-textual">type : Type</textual></code><textual class="po-textual"> indicates that the 
      </textual><code class="po-atom e246 e246"><textual class="po-textual">type</textual></code><textual class="po-textual"> relation links each Token to exactly one
      Type.  It follows, then, that:
    </textual></para><itemizedlist class="po-table e247 e247"><listitem class="po-container e248 e248"><para class="po-block e249 e249"><textual class="po-textual">Each token instantiates exactly one type.</textual></para></listitem><listitem class="po-container e250 e250"><para class="po-block e251 e251"><textual class="po-textual">Any two types are instantiated by disjoint sets 
       of tokens.</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e252 e252" xml:id="ttx-levels"><title class="po-block e253 e253"><textual class="po-textual">Multiple levels of types and tokens</textual></title><para class="po-block e254 e254"><textual class="po-textual">As noted above, earlier authors have contemplated types and
      tokens which have internal structure and nest; here we take 
      up that principle and formalize it.
     </textual></para><orderedlist class="po-table e255 e255"><listitem class="po-container e256 e256"><para class="po-block e257 e257"><textual class="po-textual">Some tokens are basic, or atomic in the sense that no
       other tokens are part of them; the types instantiated by them
       are similarly basic.</textual></para></listitem></orderedlist><para class="po-block e258 e258"><textual class="po-textual">Simple examples are the characters of the Latin alphabet and
      punctuation marks.</textual></para><para class="po-block e259 e259"><textual class="po-textual">Formally: basic types are a kind of type, 
and basic tokens are a kind of token.
The types to which basic tokens map will normally be basic types,
but for reasons clarified below this is not required
by the model.
</textual><programlisting class="po-block e260 e260" xml:space="preserve"><textual class="po-textual">
sig Basic_Type extends Type {}
sig Basic_Token extends Token {}
</textual></programlisting></para><orderedlist class="po-table e261 e261"><listitem class="po-container e262 e262"><para class="po-block e263 e263"><textual class="po-textual">Other tokens are compound:  aggregations or
       collections of </textual><quote class="po-inline e264 e264"><textual class="po-textual">lower-level</textual></quote><textual class="po-textual"> tokens; so also
       with types.</textual></para></listitem></orderedlist><para class="po-block e265 e265"><textual class="po-textual">We refer to the lower-level types or tokens as the
      </textual><emphasis class="po-inline e266 e266"><textual class="po-textual">constituents</textual></emphasis><textual class="po-textual"> of the higher-level one of which they
      form a part.</textual></para><para class="po-block e267 e267"><textual class="po-textual">Because in written documents compound tokens typically
      occupy a discernible and possibly large region of the text
      carrier, we call them </textual><emphasis class="po-inline e268 e268"><textual class="po-textual">regions</textual></emphasis><textual class="po-textual">. Because compound
      types are, in the usual case, structural units of a kind
      familiar to any user of SGML or XML for document markup, we
      refer to them as </textual><emphasis class="po-inline e269 e269"><textual class="po-textual">S_Units</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e270 e270"><textual class="po-textual">Regions can be decomposed into subregions and S_Units
      have children.  It proves useful to postulate that S_Units
      also have a set of property-value pairs, and are labeled
      as to their type or (to avoid overloading the word
      </textual><emphasis class="po-inline e271 e271"><textual class="po-textual">type</textual></emphasis><textual class="po-textual"> yet again) their </textual><emphasis class="po-inline e272 e272"><textual class="po-textual">kind</textual></emphasis><textual class="po-textual">.
     </textual></para><para class="po-block e273 e273"><textual class="po-textual">Formally:  compound types and tokens are subsets, respectively, 
      of types and tokens generally.  They have subordinate types
      and tokens, referred to as their </textual><emphasis class="po-inline e274 e274"><textual class="po-textual">children</textual></emphasis><textual class="po-textual">
      and </textual><emphasis class="po-inline e275 e275"><textual class="po-textual">subregions</textual></emphasis><textual class="po-textual">, respectively.
</textual><programlisting class="po-block e276 e276" xml:space="preserve"><textual class="po-textual">
abstract sig Region extends Token {
  subregions : set Token
}{ 
  type in S_Unit
  type.children = subregions.@type
}
abstract sig S_Unit extends Type {
  kind : lone Kind,
  props : set AVPair,
  children : set Type
}
</textual></programlisting></para><orderedlist class="po-table e277 e277"><listitem class="po-container e278 e278"><para class="po-block e279 e279"><textual class="po-textual">The lower-level items in compounds are frequently arranged in a
	sequence, but this is not invariably so.  The constituents
	(subregions and children) may also form a set, or a bag.</textual></para></listitem></orderedlist><para class="po-block e280 e280"><textual class="po-textual">Simple examples of sequence include the aggregation of
      sequences of character tokens to form word tokens and similarly
      the aggregation of sequences of character types to form word
      types.  At higher levels, the aggregation of paragraphs to form
      a chapter, or of chapters to form a novel, provide further
      examples.  Sets and bags are less frequent in documentary
      applications, but not unknown; they occur whenever it is
      meaningless or misleading to ask about the order of the
      children, or when the children are represented in some sequence
      of tokens which is explicitly stated to carry no significance.
     </textual></para><para class="po-block e281 e281"><textual class="po-textual">Formally:
</textual><programlisting class="po-block e282 e282" xml:space="preserve"><textual class="po-textual">
sig Ordered_Region extends Region {
 sub_seq : seq Token
}{
  elems[sub_seq] = subregions
  type in Ordered_S_Unit
  type.ch_seq = sub_seq.@type
}
sig Ordered_S_Unit extends S_Unit {
  ch_seq : seq Type
}{
  elems[ch_seq] = children
}
</textual></programlisting></para><para class="po-block e283 e283"><textual class="po-textual">
      The declaration </textual><code class="po-atom e284 e284"><textual class="po-textual">sub_seq : seq Token</textual></code><textual class="po-textual"> says
      that each Ordered_Region is associated with a sequence of
      (sub)tokens; </textual><code class="po-atom e285 e285"><textual class="po-textual">ch_seq : seq Type</textual></code><textual class="po-textual"> says the analogous
      thing for Ordered_S_Unites.  The declarations
      </textual><code class="po-atom e286 e286"><textual class="po-textual">elems[sub_seq] = subregions</textual></code><textual class="po-textual"> and </textual><code class="po-atom e287 e287"><textual class="po-textual">elems[ch_seq]
       = children</textual></code><textual class="po-textual"> specify that the elements of those sequence
      are precisely the constituents of the compound object. The
      declaration </textual><code class="po-atom e288 e288"><textual class="po-textual">type in Ordered_S_Unit</textual></code><textual class="po-textual"> requires that
      any ordered region instantiate an ordered 
      type.</textual><footnote class="po-popup e289 e289"><para class="po-block e290 e290"><textual class="po-textual">The model thus disallows the convention mentioned
       above, in which tokens are ordered but the order is taken as
       insignificant.  It might be better to require only that ordered
       regions instantiate compound types.</textual></para></footnote><textual class="po-textual"> The declaration
      </textual><code class="po-atom e291 e291"><textual class="po-textual">type.ch_seq = sub_seq.@type</textual></code><textual class="po-textual"> specifies that for any
      ordered region </textual><emphasis class="po-inline e292 e292"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">, the children of
      </textual><emphasis class="po-inline e293 e293"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">'s type are the types of </textual><emphasis class="po-inline e294 e294"><textual class="po-textual">R</textual></emphasis><textual class="po-textual">'s
      subregions.
     </textual></para><para class="po-block e295 e295"><textual class="po-textual">Next, we turn to unordered types and tokens (bags and sets):
</textual><programlisting class="po-block e296 e296" xml:space="preserve"><textual class="po-textual">
abstract sig Unordered_Region extends Region {}{
  type in Unordered_S_Unit
}
abstract sig Unordered_S_Unit extends S_Unit {}
</textual></programlisting></para><para class="po-block e297 e297"><textual class="po-textual">Note that those definitions make </textual><code class="po-atom e298 e298"><textual class="po-textual">Ordered_S_Unit</textual></code><textual class="po-textual">
      and </textual><code class="po-atom e299 e299"><textual class="po-textual">Unordered_S_Unit</textual></code><textual class="po-textual"> disjoint from each other, as
      expected (an </textual><code class="po-atom e300 e300"><textual class="po-textual">S_Unit</textual></code><textual class="po-textual"> cannot be both ordered and
      unordered).</textual></para><para class="po-block e301 e301"><textual class="po-textual">
      Types and tokens whose constituents are unordered have
      either set structure or bag structure.  Set-structured
      tokens map to set-structured types (and ditto for 
      those with bag structure).  Bag-structured types and
      tokens keep track of the number of occurrences of each
      constituent (modeled here by the functions </textual><code class="po-atom e302 e302"><textual class="po-textual">sub_counts</textual></code><textual class="po-textual">
      and </textual><code class="po-atom e303 e303"><textual class="po-textual">ch_counts</textual></code><textual class="po-textual">, which map from constituents
      to natural numbers.</textual></para><para class="po-block e304 e304"><programlisting class="po-block e305 e305" xml:space="preserve"><textual class="po-textual">
abstract sig Set_Structured_Region extends Unordered_Region {}{
  type in Set_Structured_S_Unit
}
abstract sig Set_Structured_S_Unit extends Unordered_S_Unit {}

abstract sig Bag_Structured_Region extends Unordered_Region {
  sub_counts : subregions -&gt; Natural_number
}{
  type in Bag_Structured_S_Unit
}
abstract sig Bag_Structured_S_Unit extends Unordered_S_Unit {
  ch_counts : children -&gt; Natural_number
}
</textual></programlisting></para><para class="po-block e306 e306"><textual class="po-textual">Normally, basic tokens instantiate basic types; exceptions
      are the disjunctive and conjunctive types defined below.
      Only compound tokens can successfully instantiate most compound
      types, because of the rule </textual><code class="po-atom e307 e307"><textual class="po-textual">type.children = subregions.@type</textual></code><textual class="po-textual">
      in the declaration of regions.  Essentially, this requires a
      kind of compositionality:  if the type of a region has child
      types, then those child types must be instantiated by
      subregions of the region.  Since basic tokens have no 
      subregions, they cannot satisfy this constraint.</textual></para><para class="po-block e308 e308"><textual class="po-textual">Several observations can be made about compound types and tokens.</textual></para><para class="po-block e309 e309"><textual class="po-textual">The lowest level of compound, consisting of a sequence of
      basic tokens (or types), is frequently an object of special
      interest.  (For example, the </textual><emphasis class="po-inline e310 e310"><textual class="po-textual">text node</textual></emphasis><textual class="po-textual"> of the XPath
      data model is characterized precisely by being a sequence of
      Unicode characters [here taken as basic] uninterrupted by markup
      and without any further properties or structure.)</textual><footnote class="po-popup e311 e311"><para class="po-block e312 e312"><textual class="po-textual">It
	might be desirable to single these lowest-level compound types
	and tokens out with a signature of their own, for example:
</textual><programlisting class="po-block e313 e313" xml:space="preserve"><textual class="po-textual">
sig Text_Flow extends S_Unit {
  types : seq Basic_Type
}{
  kind = PCData
  no children 
}
sig Token_Sequence extends Region {
  tokens : seq Basic_Token
}{
  type in Text_Flow
  type.types = tokens.@type
  no subregions
}
one sig PCData extends Kind {}
</textual></programlisting><textual class="po-textual">
	The overall system seems simpler, however, without this elaboration.
       </textual></para></footnote><textual class="po-textual">
     </textual></para><para class="po-block e314 e314"><textual class="po-textual">Basic tokens consist of marks on a text-bearing writing
      medium; compound tokens consist of collections of other tokens
      (basic or compound); not infrequently, these are physically
      proximate and so compound tokens may be identified with
      </textual><emphasis class="po-inline e315 e315"><textual class="po-textual">regions</textual></emphasis><textual class="po-textual"> of the text carrier.</textual><footnote class="po-popup e316 e316"><para class="po-block e317 e317"><textual class="po-textual">It
       is tempting to suggest that the regions of a document partition
       the physical space of the text carrier [</textual><xref class="po-milestone e318 e318" linkend="Cayless"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">], and in some simple cases they do.  In the
       general case, however, the marks even of basic tokens may
       overlap with other marks constituting other tokens, and
       unwritten space in a document does not always constitute a
       token.</textual></para></footnote></para><para class="po-block e319 e319"><textual class="po-textual">The compound types instantiated by compound tokens are not
      infrequently structural units of the kind identified by elements
      and attributes in standard markup practice.</textual></para><para class="po-block e320 e320"><textual class="po-textual">Among the compound tokens, the </textual><emphasis class="po-inline e321 e321"><textual class="po-textual">document</textual></emphasis><textual class="po-textual"> itself is
      an important edge case, and similarly the </textual><emphasis class="po-inline e322 e322"><textual class="po-textual">text</textual></emphasis><textual class="po-textual">
      among compound types.</textual><footnote class="po-popup e323 e323"><para class="po-block e324 e324"><textual class="po-textual">We strive to use the
       term </textual><emphasis class="po-inline e325 e325"><textual class="po-textual">document</textual></emphasis><textual class="po-textual"> always and only for physical
       objects, and the term </textual><emphasis class="po-inline e326 e326"><textual class="po-textual">text</textual></emphasis><textual class="po-textual"> for the type
       instantiated by a document.  This usage is not universal among
       those who speak and write about texts and documents.</textual></para></footnote></para><para class="po-block e327 e327"><textual class="po-textual">Finally, some ancillary declarations are needed for the
      </textual><code class="po-atom e328 e328"><textual class="po-textual">Kind</textual></code><textual class="po-textual">, </textual><code class="po-atom e329 e329"><textual class="po-textual">AVPair</textual></code><textual class="po-textual">, and </textual><code class="po-atom e330 e330"><textual class="po-textual">Natural_number</textual></code><textual class="po-textual">
      objects appealed to in some of the earlier declarations.
     </textual></para><para class="po-block e331 e331"><textual class="po-textual">
      The signatures </textual><emphasis class="po-inline e332 e332"><textual class="po-textual">Kind</textual></emphasis><textual class="po-textual"> and </textual><emphasis class="po-inline e333 e333"><textual class="po-textual">AVPair</textual></emphasis><textual class="po-textual">
      serve purposes analogous to the generic identifiers and
      attribute-value pairs of SGML and related markup languages. We
      do not analyse them further.  </textual><emphasis class="po-inline e334 e334"><textual class="po-textual">Natural_number</textual></emphasis><textual class="po-textual">
      is just an integer greater than zero.
     </textual></para><para class="po-block e335 e335"><programlisting class="po-block e336 e336" xml:space="preserve"><textual class="po-textual">
abstract sig Kind {}

sig AVPair {
  att_name : Kind,
  att_value : Type
}

sig Natural_number {
  theNumber : Int
}{
  theNumber &gt; 0
}
</textual></programlisting></para></section><section class="po-hcontainer e337 e337" xml:id="ttx-disj-conj"><title class="po-block e338 e338"><textual class="po-textual">Ambiguity:  disjunction, and conjunction</textual></title><para class="po-block e339 e339"><textual class="po-textual">Our model of the type/token distinction goes beyond
      the conventional view in a second way:  we postulate
      disjunctive and conjunctive types, to address some
      cases which are otherwise difficult to handle.
     </textual></para><para class="po-block e340 e340"><textual class="po-textual">In some documents it may be difficult to say just what type
      is instantiated by some tokens (e.g., if the document is
      difficult to read).  For example, consider the following
      extract from a manuscript of Ludwig Wittgenstein:
      </textual><figure class="po-container e341 e341"><mediaobject class="po-container e342 e342"><imageobject class="po-container e343 e343"><imagedata class="po-meta e344 e344" fileref="../../../vol5/graphics/Huitfeldt01/Huitfeldt01-001.png" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><para class="po-block e345 e345"><textual class="po-textual">A word in Wittgenstein's </textual><quote class="po-inline e346 e346"><textual class="po-textual">Geheimschrift</textual></quote><textual class="po-textual">
	(Item 118, page 8v).</textual></para></figure><textual class="po-textual">
       
      Transcribers not yet aware that this word is written in Wittgenstein's 
      so-called </textual><quote class="po-inline e347 e347"><textual class="po-textual">secret writing</textual></quote><textual class="po-textual"> (in which A is
      substituted for Z, B for Y, etc., and vice versa) might have
      difficulty deciphering the token.  Transcriber A might
      render the word as </textual><quote class="po-inline e348 e348"><textual class="po-textual">munonyqi</textual></quote><textual class="po-textual">, transcriber B as
      </textual><quote class="po-inline e349 e349"><textual class="po-textual">wunouyqi</textual></quote><textual class="po-textual">.  Both might accept the other's transcription
      as just as likely as their own.  How, in this case, should 
      a neutral observer whose knowledge of the original is derived
      only from the transcription, or a transcriber uncertain how
      to read the philosopher's handwriting, characterize the first
      letter of this word?  Is it a </textual><emphasis class="po-inline e350 e350"><textual class="po-textual">w</textual></emphasis><textual class="po-textual"> or
      an </textual><emphasis class="po-inline e351 e351"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">?
     </textual></para><para class="po-block e352 e352"><textual class="po-textual">We could of course simply insist that each
      token be mapped to a unique type as a matter of principle, thus
      forcing a choice among the possibilities:  </textual><emphasis class="po-inline e353 e353"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">
      or </textual><emphasis class="po-inline e354 e354"><textual class="po-textual">w</textual></emphasis><textual class="po-textual">.  But it might provide a
      more accurate depiction of the state of affairs if we specified
      not that the first letter is an </textual><emphasis class="po-inline e355 e355"><textual class="po-textual">m</textual></emphasis><textual class="po-textual">, or
      that it is a </textual><emphasis class="po-inline e356 e356"><textual class="po-textual">w</textual></emphasis><textual class="po-textual">, but specified instead
      that it is </textual><emphasis class="po-inline e357 e357"><textual class="po-textual">either</textual></emphasis><textual class="po-textual">
      the one </textual><emphasis class="po-inline e358 e358"><textual class="po-textual">or</textual></emphasis><textual class="po-textual"> the other.</textual><footnote class="po-popup e359 e359"><para class="po-block e360 e360"><textual class="po-textual">As the
       example illustrates, this
       proposal for disjunctive types arose in the context of work on
       the logic of transcription, but we believe it to be more
       generally applicable:  it can be used to describe all cases of
       uncertainty, whether the document in question is being
       transcribed or not.
       The curious reader may wish to know that the correct
       literal transcription of the example is </textual><quote class="po-inline e361 e361"><textual class="po-textual">muuvnyzi</textual></quote><textual class="po-textual">,
       which is the secret-writing form of the German word
       </textual><quote class="po-inline e362 e362"><textual class="po-textual">offenbar</textual></quote><textual class="po-textual"> </textual><quote class="po-inline e363 e363"><textual class="po-textual">public, apparent, obvious</textual></quote><textual class="po-textual">.
      </textual></para></footnote></para><para class="po-block e364 e364"><textual class="po-textual">So we extend the model given above by adding the possibility of
      </textual><emphasis class="po-inline e365 e365"><textual class="po-textual">disjunctive types</textual></emphasis><textual class="po-textual">.</textual></para><orderedlist class="po-table e366 e366"><listitem class="po-container e367 e367"><para class="po-block e368 e368"><textual class="po-textual">Some compound types represent a disjunction among
       their constituents.</textual></para></listitem></orderedlist><para class="po-block e369 e369"><textual class="po-textual">In Alloy notation: 
</textual><programlisting class="po-block e370 e370" xml:space="preserve"><textual class="po-textual">sig Disjunctive_Type extends S_Unit {}{
  kind = Disjunction
  some children
}
one sig Disjunction extends Kind {}</textual></programlisting><textual class="po-textual">

      Here again, note that
      </textual><code class="po-atom e371 e371"><textual class="po-textual">Disjunctive_Type</textual></code><textual class="po-textual">  is disjoint from both
      </textual><code class="po-atom e372 e372"><textual class="po-textual">Ordered_S_Unit</textual></code><textual class="po-textual"> and </textual><code class="po-atom e373 e373"><textual class="po-textual">Unordered_S_Unit</textual></code><textual class="po-textual">.
     </textual></para><para class="po-block e374 e374"><textual class="po-textual">
      Note that the mapping from token to type remains a function:
      each token continues to map to a single type, but in cases of
      uncertainty, that single type simply happens to be a
      disjunction. Formally, this state of affairs could be handled
      instead by making the token/type mapping a relation, through
      which any given token would map to one or more types; we choose
      to reify the notion of disjunction for reasons which should
      become clear shortly.
     </textual></para><para class="po-block e375 e375"><textual class="po-textual">Uncertainty is not the only reason one might wish to map a
      given token to more than one type.  Just as ambiguity in
      utterance may be either unintentional or intentional, so also
      polyvalence in the token/type mapping may reflect either the
      uncertainty of the reader or the purposeful choice of the
      creator.  Some of the most entertaining instances of this
      phenomenon are the mixtures of calligraphy and puzzle creation
      known as </textual><quote class="po-inline e376 e376"><textual class="po-textual">ambigrams</textual></quote><textual class="po-textual"> or
      </textual><quote class="po-inline e377 e377"><textual class="po-textual">inversions</textual></quote><textual class="po-textual">, in which the marks of a
      document are carefully constructed to instantiate not single
      types but two or even more.  In the following example, 
      
      the marks can be read either clockwise or counter-clockwise
      as tokens of the word </textual><emphasis class="po-inline e378 e378"><textual class="po-textual">infinity</textual></emphasis><textual class="po-textual">.</textual><footnote class="po-popup e379 e379"><para class="po-block e380 e380"><textual class="po-textual">Strictly speaking, in this case even the 
       individuation of particular marks as constituting tokens
       differs in the two readings:  the marks constituting a single token
       of the type </textual><emphasis class="po-inline e381 e381"><textual class="po-textual">y</textual></emphasis><textual class="po-textual"> in one reading are,
       in the other reading, two tokens of </textual><emphasis class="po-inline e382 e382"><textual class="po-textual">f</textual></emphasis><textual class="po-textual">
       and </textual><emphasis class="po-inline e383 e383"><textual class="po-textual">i</textual></emphasis><textual class="po-textual">.  The word tokens have different
       boundaries in the two directions.  And so on.  For now, our
       model ignores these complications; to address them directly 
       it would seem to be necessary to model explicitly the marks which
       constitute tokens, and to indicate how different sets of 
       marks are individuated now as one token and now as another.
       But it does not seem possible, in the general case, to treat
       marks as sets of individuals independent of particular readings
       of the marks:  it is frequently only through being identified as a
       token of a particular type that marks can successfully be
       individuated and distinguished from each other.  A similar
       (albeit aesthetically less interesting)
       example can be found in
       [</textual><xref class="po-milestone e384 e384" linkend="Goodman"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">] pp. 138-139.
       Goodman's example has the property that there is no ambiguity
       about the organization of marks into tokens, and that the 
       same token is intentionally written so
       that it can be assigned to several types.
       </textual></para></footnote><textual class="po-textual">      
      </textual><figure class="po-container e385 e385"><mediaobject class="po-container e386 e386"><imageobject class="po-container e387 e387"><imagedata class="po-meta e388 e388" fileref="../../../vol5/graphics/Huitfeldt01/Huitfeldt01-002.gif" format="png"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><para class="po-block e389 e389"><textual class="po-textual">An </textual><quote class="po-inline e390 e390"><textual class="po-textual">inversion</textual></quote><textual class="po-textual">. © Scott Kim, 
	</textual><link class="po-inline e391 e391" xlink:actuate="onRequest" xlink:href="http://scottkim.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">scottkim.com</textual></link><textual class="po-textual">.  
	Reproduced by permission.
      </textual></para></figure><textual class="po-textual">
       
     </textual></para><para class="po-block e392 e392"><textual class="po-textual">We extend the model, therefore, to include
      </textual><emphasis class="po-inline e393 e393"><textual class="po-textual">conjunctive</textual></emphasis><textual class="po-textual"> types.</textual></para><orderedlist class="po-table e394 e394"><listitem class="po-container e395 e395"><para class="po-block e396 e396"><textual class="po-textual">Some compound types represent the conjunction of
       their constituents:  tokens instantiating such types
       instantiate, at the same time, each constituent of the
       type.</textual></para></listitem></orderedlist><para class="po-block e397 e397"><textual class="po-textual">In Alloy:
</textual><programlisting class="po-block e398 e398" xml:space="preserve"><textual class="po-textual">
sig Conjunctive_Type extends S_Unit {}{
  kind = Conjunction
  some children
}
one sig Conjunction extends Kind {}
</textual></programlisting></para><para class="po-block e399 e399"><textual class="po-textual">
      As with disjunctive types, no additional fields or machinery are
      needed:  it suffices to classify a type as disjunctive or
      conjunctive to make clear how the constituent types relate to
      each other and to the tokens of the type.</textual><footnote class="po-popup e400 e400"><para class="po-block e401 e401"><textual class="po-textual">This is not strictly true:  the formulation
	above includes constraints that
	enforce the parallel compositionality of tokens and types
	by requiring the types of a region's subregions to be the
	children of the region's type.  These need to be reformulated
	to account for the presence of disjunctive and conjunctive
	types.  In this paper, we simply
       ignore this complication.</textual></para></footnote><textual class="po-textual"> 
     </textual></para><para class="po-block e402 e402"><textual class="po-textual">
      Other cases of willed polyvalence include acrostics (in which
      individual basic tokens form parts of two compound tokens, not
      just one) and some simple forms of coded communication (e.g.,
      documents where the intended recipient must read every other
      word, or every other line, to glean the secret message).  These
      deviate from the normal case in which each token (except
      the top-most, namely the document) is a constituent of just 
      one higher-level token (and similarly, with appropriate 
      adjustments, for types).  In the normal case, that is, both
      tokens and the types they instantiate can typically be arranged
      in a simple hierarchy.  Violations of this hierarchical 
      assumption do not require a special kind
      of type like a disjunction or a conjunction; it suffices 
      to avoid requiring that no two tokens, and not two types,
      share any constituents.</textual></para><para class="po-block e403 e403"><textual class="po-textual">It is not hard to imagine (though it is beyond our ability to
      provide plausible examples of) cases in which the marks of a
      document are clearly intended to be polyvalent and thus appear
      to require a mapping to some conjunctive type, but in which it
      is not clear which conjunctive type is called for.  In such
      situations, the tokens in question may be regarded as
      instantiating a disjunctive type whose constituents are
      conjunctive types. One might also imagine an inversion in which
      the identity of one conjoined type is certain but the other is
      not: that may be described by mapping the token in question to a
      conjunctive type whose constituents are a
      </textual><quote class="po-inline e404 e404"><textual class="po-textual">normal</textual></quote><textual class="po-textual"> type (compound or basic) and a
      disjunctive type.</textual></para></section></section><section class="po-hcontainer e405 e405" xml:id="trts"><title class="po-block e406 e406"><textual class="po-textual">Type repertoires and type systems</textual></title><para class="po-block e407 e407"><textual class="po-textual">It is a fundamental property of types as commonly defined, that
     types are mutually exclusive:  each token instantiates a single
     type.  With the exception of special cases involving accidental
     or willed ambiguity, a given mark is always an
     </textual><emphasis class="po-inline e408 e408"><textual class="po-textual">a</textual></emphasis><textual class="po-textual">, or a </textual><emphasis class="po-inline e409 e409"><textual class="po-textual">b</textual></emphasis><textual class="po-textual">, or a
     </textual><emphasis class="po-inline e410 e410"><textual class="po-textual">c</textual></emphasis><textual class="po-textual">, etc., and never more than one.
     Essentially, types and tokens form a </textual><emphasis class="po-inline e411 e411"><textual class="po-textual">digital</textual></emphasis><textual class="po-textual"> rather
     than an </textual><emphasis class="po-inline e412 e412"><textual class="po-textual">analog</textual></emphasis><textual class="po-textual"> system.
    </textual></para><para class="po-block e413 e413"><textual class="po-textual">But if types can nest within other types, it is easy to
     find cases where the same token must instantiate multiple
     types, at different levels.  A token </textual><quote class="po-inline e414 e414"><textual class="po-textual">I</textual></quote><textual class="po-textual"> might at one
     and the same time instantiate several different types:
     </textual><itemizedlist class="po-table e415 e415"><listitem class="po-container e416 e416"><para class="po-block e417 e417"><textual class="po-textual">a character (upper-case Latin letter I)</textual></para></listitem><listitem class="po-container e418 e418"><para class="po-block e419 e419"><textual class="po-textual">a letter (as opposed to a punctuation character or
      other non-letter character)</textual></para></listitem><listitem class="po-container e420 e420"><para class="po-block e421 e421"><textual class="po-textual">a word</textual></para></listitem><listitem class="po-container e422 e422"><para class="po-block e423 e423"><textual class="po-textual">a pronoun</textual></para></listitem><listitem class="po-container e424 e424"><para class="po-block e425 e425"><textual class="po-textual">a noun phrase</textual></para></listitem><listitem class="po-container e426 e426"><para class="po-block e427 e427"><textual class="po-textual">a sentence</textual></para></listitem><listitem class="po-container e428 e428"><para class="po-block e429 e429"><textual class="po-textual">an utterance</textual></para></listitem></itemizedlist><textual class="po-textual">
    </textual></para><para class="po-block e430 e430"><textual class="po-textual">This is not a problem for uses of the type/token distinction
     which work with a single level at a time; it is a more serious
     difficulty for a model like ours, in which multiple levels are
     normally present.  In such a multi-level system, it is no longer
     true that </textual><emphasis class="po-inline e431 e431"><textual class="po-textual">all</textual></emphasis><textual class="po-textual"> types are disjoint or that each token
     instanatiates only a single type.  On the other
     hand, the phenomenon arises only because multiple levels of type
     are present at the same time, in the same view of things. Within
     a given level (for some suitable definition of that construct)
     the conventional rule applies:  all types are pairwise disjoint.
    </textual></para><para class="po-block e432 e432"><textual class="po-textual">We postulate that types can be grouped together in </textual><emphasis class="po-inline e433 e433"><textual class="po-textual">type
      repertoires</textual></emphasis><textual class="po-textual"> in such a way that the disjointness rule
     holds true not absolutely, but for all types in a repertoire.
     The token </textual><quote class="po-inline e434 e434"><textual class="po-textual">I</textual></quote><textual class="po-textual"> can be both a character and a word, because
     the character </textual><emphasis class="po-inline e435 e435"><textual class="po-textual">I</textual></emphasis><textual class="po-textual"> is a member of one 
     type repertoire, and the word </textual><emphasis class="po-inline e436 e436"><textual class="po-textual">I</textual></emphasis><textual class="po-textual"> is
     a member of a different type repertoire.
    </textual></para><para class="po-block e437 e437"><textual class="po-textual">In practice, normal readers reading conventional written
     documents (or listening to normal spoken utterances) apply
     several type repertoires in parallel, with complex interactions
     among them.</textual></para><para class="po-block e438 e438"><textual class="po-textual">
     A non-empty finite collection of type repertoires we call a 
     </textual><emphasis class="po-inline e439 e439"><textual class="po-textual">type system</textual></emphasis><textual class="po-textual">.</textual></para><para class="po-block e440 e440"><textual class="po-textual">Any particular reading of a document will involve a type
     system.  Different readings of a document may diverge not because
     of irreconcilable substantive differences, but only because they
     are applying different type systems.  For example, a transcriber
     of eighteenth-century documents who preserves the distinction
     between long s and short s, and a transcriber who levels the
     distinction (perhaps on the grounds that the two forms are in
     complementary distribution and are thus clearly allographs) do
     not in fact disagree on what their common exemplar actually says;
     if they disagree, it is only about the appropriate type system to
     bring to bear on transcriptions of such material.     
    </textual></para><para class="po-block e441 e441"><textual class="po-textual">In some cases (as in the case of long and short s), the
     relation between type repertoires is a straightforward
     refinement/abstraction relation:  one repertoire makes finer
     distinctions than the other and contains more information.
     In other cases, the relation will be more complex.
    </textual></para></section><section class="po-hcontainer e442 e442" xml:id="ttmk"><title class="po-block e443 e443"><textual class="po-textual">Types, tokens, and markup languages</textual></title><para class="po-block e444 e444"><textual class="po-textual">There are noticeable parallels between the structured types
     and tokens we have described and the analysis of documents
     underlying many colloquial SGML and XML vocabularies.
     In both cases, we identify structured units which may
     occur as parts of larger structured units.  In both
     cases, the same abstract units may be instantiated by
     different concrete realizations.
    </textual></para><para class="po-block e445 e445"><textual class="po-textual">The model we have presented has been kept rather abstract
     and general; we have not attempted to enforce in it any
     of the structural regularities of SGML and XML, such as
     strict nesting and hierarchical structure.  In fact, as far
     as we can tell, the abstract model of types and tokens we
     have sketched provides a model not only for SGML and XML,
     but for all the other kinds of document markup with which 
     we are familiar:  MECS and Cocoa and TexMecs and 
     various batch-formatting languages (TeX, Script, troff, ..),
     as well as word-processor formats.  That is, we believe
     the model outlined here provides a sort of greatest common
     denominator for markup systems.
    </textual></para><para class="po-block e446 e446"><textual class="po-textual">The first implication of our work for markup languages,
     then, appears to be:  element types are types, in the sense
     of the type/token distinction.  Element instances are tokens,
     in the sense of type type/token distinction.  This holds
     at least for the most common cases in colloquial markup
     vocabularies.     
    </textual></para><para class="po-block e447 e447"><textual class="po-textual">Since by default, all children are ordered in XML documents,
     XML itself provides no mechanism for signaling that children are
     in fact unordered.  Since such a signal is sometimes necessary,
     it is to be expected that some vocabularies will define such a
     signal — as in fact some (e.g., the TEI) do.
    </textual></para><para class="po-block e448 e448"><textual class="po-textual">The second implication of our work is that higher-level
     textual objects like paragraphs, sections, chapters, and
     books, are not different in kind from the characters 
     appearing in character data in the document.  The fundamental
     distinction in SGML and XML between </textual><emphasis class="po-inline e449 e449"><textual class="po-textual">markup</textual></emphasis><textual class="po-textual">
     and </textual><emphasis class="po-inline e450 e450"><textual class="po-textual">content</textual></emphasis><textual class="po-textual"> appears, on this account, to be
     a technological artifact which masks the underlying
     reality that characters, paragraphs, sections, and so on
     are all objects of the same fundamental kind.</textual></para><para class="po-block e451 e451"><textual class="po-textual">
     It is true that historical writing systems are most complete,
     consistent, and explicit for the character level, while the
     realization of higher-level structures like paragraphs, chapters,
     etc. tends to be more haphazard and inconsistent.  But historical
     writing systems are virtually always incomplete:  they do not
     capture all the relevant linguistic facts, only enough of them to
     make it possible to convey information.  When an existing writing
     system is applied in new contexts, it may become necessary (and
     historically this has often been so) to elaborate the writing
     system so as to make it more explicit.  (The development
     of vowel pointing in Hebrew and Arabic scripts is a case in
     point.)
    </textual></para><para class="po-block e452 e452"><textual class="po-textual">This leads us to the third implication of our work:  
     markup languages form nothing other than the extension of
     conventional writing systems in order to make them more explicit.
     That is, the paragraph and chapter types which may be
     marked up by typical vocabularies for descriptive markup
     are neither more nor less part of the text than the
     character data which makes up their content.  It is
     sometimes convenient to regard all markup as a kind of
     annotation, different in nature from the recording of
     </textual><quote class="po-inline e453 e453"><textual class="po-textual">the text itself</textual></quote><textual class="po-textual">.  But if our model
     of types and tokens is correct, then there is no difference
     in essential nature between the </textual><quote class="po-inline e454 e454"><textual class="po-textual">A</textual></quote><textual class="po-textual"> of the word
     </textual><quote class="po-inline e455 e455"><textual class="po-textual">ALGOL</textual></quote><textual class="po-textual">, and the paragraph within which it appears.
     Both are realized in a document by physical phenomena
     which are tokens of corresponding types.</textual></para><para class="po-block e456 e456"><textual class="po-textual">
     For a long time, one of the authors of this paper introduced new
     users to SGML and XML by saying that markup languages are a way
     to make explicit (part of) our understanding of a text.  To the
     extent that this suggests a separation between the text and our
     understanding of it and thus encourages the view that markup is a
     kind of annotation separate from and additional to the text
     proper, this formulation now seems misleading.
     Markup languages are a way to make explicit some aspects of the
     text, as we understand it.
    </textual></para></section><section class="po-hcontainer e457 e457" xml:id="conclusion"><title class="po-block e458 e458"><textual class="po-textual">Conclusion</textual></title><para class="po-block e459 e459"><textual class="po-textual">The assertion that all levels of document structure may be
regarded as exhibiting a form of the type/token distinction 
may have a number of implications, some of which appear to require
further elaboration and exploration.</textual></para><para class="po-block e460 e460"><textual class="po-textual">If basic and compound tokens and types form a logical
continuum rather than entirely separate levels of representation
with entirely different rules, then conceptual models which
treat documents as consisting of one or more sequences of
characters and a set of character ranges would seem to be
imposing a radical distinction in methods of representation
between the two levels
which has no analogue in the phenomena being modeled.
</textual></para><para class="po-block e461 e461"><textual class="po-textual">
This view may shed a new light on the practice of some XML
vocabularies of using empty elements to represent character types not
present in (the current version of) the Unicode /ISO 10646 universal
character set.  Instead of being an ad hoc solution, 
practically necessary but conceptually awkward, this 
approach becomes (on the view outlined here) a natural
application of the fundamental fact that UCS characters
and XML elements are essentially similar:  concrete
tokens instantiating types of some writing system.</textual></para><para class="po-block e462 e462"><textual class="po-textual">
Just as the phonemic units of a language's sound system
can be defined in terms of distinctive features, 
and specific phones are regarded as instantiating particular
phonemes whenever they exhibit the requisite pattern of
distinctive features, so also it is possible to define
the basic types (graphemes) of a writing system in terms
of distinctive features.  It would be illuminating to 
extend the analogy further and define distinctive features
for the elements and attributes of markup vocabularies.</textual></para><para class="po-block e463 e463"><textual class="po-textual">
The realization of phonemes as phones is subject to variation
of many kinds:  different regional accents may systematically 
affect the realization of many phonemes in the system,
different speakers have different qualities of voice tone,
and individual utterances by the same speaker may vary in 
many ways either systematically or (as far as analysis
can tell) randomly.  The realization of graphemes is similarly
various:  different fonts (in printed books and electronic
display), different handwriting styles, different hands,
different letter formation at different places.  And
of course the possibility of systematic changes in realization
was historically one of the motive forces impelling
the development of descriptive markup in the first place.
The parallels and possible differences among these phenomena
merit consideration at greater length than is possible here.
</textual></para></section><bibliography class="po-hcontainer e464 e464"><title class="po-block e465 e465"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e466 e466" xml:id="Cayless" xreflabel="Cayless 2009"><textual class="po-textual">
Cayless, Hugh.
2009.
</textual><quote class="po-inline e467 e467"><textual class="po-textual">Image as markup:  Adding semantics to manuscript images</textual></quote><textual class="po-textual">.
Paper given at Digital Humanities 2009, College Park, Maryland, June 2009.</textual></bibliomixed><bibliomixed class="po-block e468 e468" xml:id="Goodman" xreflabel="Goodman 1976"><textual class="po-textual">
Goodman, Nelson. 1976.
</textual><emphasis class="po-inline e469 e469"><textual class="po-textual">Languages of art:
An approach to the theory of symbols</textual></emphasis><textual class="po-textual">.
Indianapolis, Cambridge:  Hackett, 1976.
</textual></bibliomixed><bibliomixed class="po-block e470 e470" xml:id="Jackson" xreflabel="Jackson 2006"><textual class="po-textual">
Jackson, Daniel.  
</textual><emphasis class="po-inline e471 e471"><textual class="po-textual">Software abstractions: Logic, language, and
analysis</textual></emphasis><textual class="po-textual">.  Cambridge: MIT Press, 2006.
</textual></bibliomixed><bibliomixed class="po-block e472 e472" xml:id="Algol" xreflabel="Naur et al. 1960"><textual class="po-textual">
Naur, Peter, ed., et al.
</textual><quote class="po-inline e473 e473"><textual class="po-textual">Report on the Algorithmic Language ALGOL 60</textual></quote><textual class="po-textual">.
</textual><emphasis class="po-inline e474 e474"><textual class="po-textual">Numerische Mathematik</textual></emphasis><textual class="po-textual">
2 (1960): 106-136.
Also 
</textual><emphasis class="po-inline e475 e475"><textual class="po-textual">Communications of the ACM</textual></emphasis><textual class="po-textual">
3.5 (1960): 299-314. doi: </textual><biblioid class="po-atom e476 doi e476"><textual class="po-textual">10.1145/367236.367262</textual></biblioid><textual class="po-textual">.
</textual></bibliomixed><bibliomixed class="po-block e477 e477" xml:id="Peirce" xreflabel="Peirce 1906"><textual class="po-textual">
Peirce, Charles Santiago Sanders.  
</textual><quote class="po-inline e478 e478"><textual class="po-textual">Prolegomena to an apology for pragmaticism</textual></quote><textual class="po-textual">.  
</textual><emphasis class="po-inline e479 e479"><textual class="po-textual">The Monist</textual></emphasis><textual class="po-textual">
16 (1906): 492-546.
Reprinted vol. 4 of C. S. Peirce,
</textual><emphasis class="po-inline e480 e480"><textual class="po-textual">Collected papers</textual></emphasis><textual class="po-textual">, 
ed. Charles Hartshorne and Paul Weiss
(Cambridge, MA: Harvard University Press, 1931-58).
</textual></bibliomixed><bibliomixed class="po-block e481 e481" xml:id="Pike" xreflabel="Pike 1967"><textual class="po-textual">
Pike, Kenneth L.
</textual><emphasis class="po-inline e482 e482"><textual class="po-textual">Language in relation to a unified theory of the structure of human behavior</textual></emphasis><textual class="po-textual">.
The Hague, Paris: Mouton, 1967.
</textual></bibliomixed><bibliomixed class="po-block e483 e483" xml:id="Wetzel2008" xreflabel="Wetzel 2008"><textual class="po-textual">
Wetzel, Linda.
2008.
</textual><quote class="po-inline e484 e484"><textual class="po-textual">Types and Tokens</textual></quote><textual class="po-textual">, 
in
</textual><emphasis class="po-inline e485 e485"><textual class="po-textual">The Stanford Encyclopedia of Philosophy</textual></emphasis><textual class="po-textual"> 
(Winter 2008 Edition), 
ed. Edward N. Zalta.
Available on the Web at 
</textual><link class="po-inline e486 e486" xlink:actuate="onRequest" xlink:href="http://plato.stanford.edu/archives/win2008/entries/types-tokens/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://plato.stanford.edu/archives/win2008/entries/types-tokens/</textual></link><textual class="po-textual">.
</textual></bibliomixed><bibliomixed class="po-block e487 e487" xml:id="Wetzel2009" xreflabel="Wetzel 2009"><textual class="po-textual">
Wetzel, Linda.
2009.
</textual><emphasis class="po-inline e488 e488"><textual class="po-textual">Types and tokens:  On abstract objects</textual></emphasis><textual class="po-textual">. 
Cambridge, Mass., London:  MIT Press, 2009.
</textual></bibliomixed></bibliography></article></classedDocument>