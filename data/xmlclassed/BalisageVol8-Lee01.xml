<?xml version="1.0" encoding="UTF-8" standalone="no"?><classedDocument><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="po-hcontainer e0 e0" version="5.0-subset Balisage-1.3"><title class="po-block e1 e1"><textual class="po-textual">CodeUp: Marking up Programming Languages and the winding road to an XML Syntax.</textual></title><info class="po-record e2 e2"><confgroup class="po-record e3 e3"><conftitle class="po-field e4 e4"><textual class="po-textual">Balisage: The Markup Conference 2012</textual></conftitle><confdates class="po-field e5 e5"><textual class="po-textual">August 7 - 10, 2012</textual></confdates></confgroup><abstract class="po-container e6 e6"><para class="po-block e7 e7"><textual class="po-textual">Text markup has a rich history and mature tools and techniques. Programming
                languages however are rarely marked up except to provide embedded documentation. In
                this paper I compare the properties of Text and Programming Languages and suggest
                ways of applying the lessons and tool-chains from the Text Markup tradition to
                Programming Languages, evaluating the value verses the cost and suggest alternative
                approaches to achieving some of the value gained using Text Markup in a Programming
                Language context.</textual></para></abstract><author class="po-record e8 e8"><personname class="po-record e9 e9"><firstname class="po-field e10 e10"><textual class="po-textual">David</textual></firstname><surname class="po-field e11 e11"><textual class="po-textual">Lee</textual></surname></personname><personblurb class="po-container e12 e12"><para class="po-block e13 e13"><textual class="po-textual">David Lee has over 30 years experience in the software industry responsible for many major
                    projects in small and large companies including Sun Microsystems, IBM, Centura
                    Software (formerly Gupta.), Premenos, Epiphany (formerly RightPoint), WebGain,
                    Nexstra, Epocrates, MarkLogic. As Lead Engineer at MarkLogic, Inc., Mr Lee is
                    responsible for maintaining and enhancing the core XML Database server.</textual></para><para class="po-block e14 e14"><textual class="po-textual">Key career contributions include Real-time AIX OS extensions for optimizing transmission
					of real-time streaming video (IBM), secure encrypted EDI over internet email
					(Premenos), porting the Centura Team Desktop system to Solaris (Gupta, Centura),
					optimizations of large Enterprise CRM systems (Epiphany), author of xmlsh (</textual><link class="po-inline e15 e15" xlink:actuate="onRequest" xlink:href="http://www.xmlsh.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.xmlsh.org</textual></link><textual class="po-textual"> ) an open
					source scripting language for XML.</textual></para></personblurb><affiliation class="po-record e16 e16"><jobtitle class="po-field e17 e17"><textual class="po-textual">Lead Engineer</textual></jobtitle><orgname class="po-block e18 e18"><textual class="po-textual">MarkLogic, Inc.</textual></orgname></affiliation><email class="po-field e19 e19"><textual class="po-textual">dlee@marklogic.com</textual></email></author><legalnotice class="po-container e20 e20"><para class="po-block e21 e21"><textual class="po-textual">Copyright Â© 2012 David A. Lee</textual></para></legalnotice></info><section class="po-hcontainer e22 e22"><title class="po-block e23 e23"><textual class="po-textual">Why is text marked up?</textual></title><para class="po-block e24 e24"><textual class="po-textual">In any field the experts can get so good at what they do that the original purpose can get
            lost, or they assume everyone has the same understanding. It can be useful to step back
            and ask 'What are we doing?', 'Why are we doing it?', "Who is the audience for our
            work?", "Are our tools and techniques accomplishing our goals?". </textual></para><para class="po-block e25 e25"><textual class="po-textual">I started this navel pondering last year and asked first myself, then informally the
            professional groups "Why is text marked up?" "Why not just add to the original text?".
            Immediately these simple questions exposed some assumptions that need clarification
            before answers could be given. </textual></para><section class="po-hcontainer e26 e26"><title class="po-block e27 e27"><textual class="po-textual">What is 'Text'</textual></title><para class="po-block e28 e28"><textual class="po-textual">For the purposes of this discussion I will define 'Text' as the 'Written representation of
                natural languages'. This is a narrow definition, but it is what we tend to mean when
                talking about 'Marking up Text'. Furthermore I am jumping forward a few centuries
                and narrow the meaning further to mean 'The machine readable digital encoding of
                written representation of natural human languages' aka Bytes, Characters, Codepoints, Words,
                Sentences, Paragraphs in a computer representation.</textual></para><para class="po-block e29 e29"><textual class="po-textual">So now that we know what 'Text' is ... what does that imply ? Humans don't natively encode
                their thoughts and language directly (aka telepathically) into computers. They speak
                or write or type onto some media which is then encoded or transcribed into a
                computer. That very process changes the original and loses information. In speech,
                intonation and body expressions are lost when transcribed. In writing the media and
                physical representations (style, color, size, and emphasis) is lost when encoded to
                computer media. Typing via a keyboard generally limits the representation to uniform
                characters. Even before computers this was so natural to humans that the expression
                of language can affect it's meaning that different language is used when speaking
                and writing. Written (and printed) language contains information with the intent of
                adding back things missing from the spoken word in the form of style, font, size,
                spacing, as well usually a clearer and more precise use of language. </textual></para><para class="po-block e30 e30"><textual class="po-textual">Unlike interactive communication, the nature of Text (and recorded speech) extracts itself
                from time and space. Text is read, it is usually at a different moment in time and a
                different place in space from when it was authored. Since language requires a shared
                understanding, much is inherently lost in text. The reader has indirect access at
                best to the environment or context of the original event. Some of this context is
                recreated in the text itself through dialog, prose, notes and contextual references,
                but requires the author to imagine what context may be lost and provide a
                substitute. This is one reason why ancient texts are more difficult to interpret
                than modern texts; the author was unable to predict and accommodate for the greater
                difference in context of the modern reader.</textual></para></section><section class="po-hcontainer e31 e31"><title class="po-block e32 e32"><textual class="po-textual">What is the purpose of Text ?</textual></title><para class="po-block e33 e33"><textual class="po-textual">The purpose of Text, as a representation of natural language, is to express and ideally
                communicate thought. Expressing thought implies an Author. Communicating thought
                implies an Audience. We were taught to "Consider the audience" when writing, but
                that is a difficult and often impossible goal. At best we may consider the Intended
                Audience, but who is to say who may want to read our text in the future and where or
                when that might be? Since we can't embed our entire context in every writing there
                is always an assumption as to the shared understanding of the intended
                audience.</textual></para></section><section class="po-hcontainer e34 e34"><title class="po-block e35 e35"><textual class="po-textual">Why mark up text?</textual></title><para class="po-block e36 e36"><textual class="po-textual">Why do we mark up text? Especially digital text and when the markup itself is text, why not
                just add to the text? Marking up text is essentially just adding more text. But it's
                a different sort, it is 'out of band'. It represents a different dimension or layer
                from the text itself. Why do we do this ?</textual></para><para class="po-block e37 e37"><textual class="po-textual">I asked this question to several groups in the hopes of getting opinions I had not
                previously considered, or at least to clarify my preconceptions. As expected the
                answers varied in detail greatly by the person. Obviously (in hindsight) people mark
                up text for different specific purposes and express these in different degrees of
                abstraction.</textual></para><para class="po-block e38 e38"><textual class="po-textual">Some example responses indicating a range of  reasoning, edited and out of context for
                brevity:</textual></para><blockquote class="po-container e39 e39"><para class="po-block e40 e40"><textual class="po-textual">... [so] that you could have a single document (with markup) and derive
						from it a variety of secondary views that were very different. </textual></para><attribution class="po-block e41 e41"><textual class="po-textual">Dave Patterson on LinkedIn Groups XML and Related Technologies Network </textual><xref class="po-milestone e42 e42" linkend="type-ref-1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e43 e43"><para class="po-block e44 e44"><textual class="po-textual">Because it doesn't tell the whole story. There may be important contextual
					information that could completely change the meaning of the narrative. </textual></para><attribution class="po-block e45 e45"><textual class="po-textual">Paul Monk on LinkedIn Groups XML and Related Technologies Network </textual><xref class="po-milestone e46 e46" linkend="type-ref-2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e47 e47"><para class="po-block e48 e48"><textual class="po-textual">... it separates the "meta" information that was human readable in the style
					into a format that is machine readable ...as a visual encoding format that is
					human readable. </textual></para><attribution class="po-block e49 e49"><textual class="po-textual">Sean Rushing on LinkedIn Groups XML and Related Technologies Network </textual><xref class="po-milestone e50 e50" linkend="type-ref-3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e51 e51"><para class="po-block e52 e52"><textual class="po-textual">... Annotate things, ...add meta-data to a document. And presentation
				    ...</textual></para><attribution class="po-block e53 e53"><textual class="po-textual">Oscar Vives on xml-dev@lists.xml.org </textual><xref class="po-milestone e54 e54" linkend="type-ref-4"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e55 e55"><para class="po-block e56 e56"><textual class="po-textual">... for the purpose of extending meaning, suggesting presentation or
				    communicating actions </textual></para><attribution class="po-block e57 e57"><textual class="po-textual">Philip Fennell on xml-dev@lists.xml.org </textual><xref class="po-milestone e58 e58" linkend="type-ref-5"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e59 e59"><para class="po-block e60 e60"><textual class="po-textual">Mark-up in retail increases the selling price.  Mark-up in texts increases the value. </textual></para><attribution class="po-block e61 e61"><textual class="po-textual">Liam Quin  on xml-dev@lists.xml.org</textual><xref class="po-milestone e62 e62" linkend="type-ref-6"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e63 e63"><para class="po-block e64 e64"><textual class="po-textual">To make explicit for mechanical processing what is implicit-but-evident in the original. </textual></para><attribution class="po-block e65 e65"><textual class="po-textual">Henry S. Thompson on xml-dev@lists.xml.org</textual><xref class="po-milestone e66 e66" linkend="type-ref-7"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><blockquote class="po-container e67 e67"><para class="po-block e68 e68"><textual class="po-textual">... there was an Original Text that was
				Divinely Inspired by the Goddesses, and that could not be improved upon
				by mortals; the task of the humans was to understand these sacred texts,
				so that a commentary had to distinguish clearly the original and the
				expansion.</textual></para><attribution class="po-block e69 e69"><textual class="po-textual">Liam Quin on xml-dev@lists.xml.org </textual><xref class="po-milestone e70 e70" linkend="type-ref-8"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></attribution></blockquote><para class="po-block e71 e71"><textual class="po-textual">Distilling these responses with my own reasoning I propose the following concepts for why
                we mark up text. The reasons vary by author, context, and purpose. Some reasons are
                complementary and some are contradictory. Yet still we find markup useful.</textual></para><para class="po-block e72 e72"><textual class="po-textual">
				</textual><itemizedlist class="po-table e73 e73"><listitem class="po-container e74 e74"><para class="po-block e75 e75"><textual class="po-textual">Preserve the original text while adding additional information </textual></para></listitem><listitem class="po-container e76 e76"><para class="po-block e77 e77"><textual class="po-textual">Annotate for purposes of presentation </textual></para></listitem><listitem class="po-container e78 e78"><para class="po-block e79 e79"><textual class="po-textual">Annotate for purposes of action</textual></para></listitem><listitem class="po-container e80 e80"><para class="po-block e81 e81"><textual class="po-textual">Annotate to provide 'layers' of information</textual></para></listitem><listitem class="po-container e82 e82"><para class="po-block e83 e83"><textual class="po-textual">Provide for machine readable processing</textual></para></listitem><listitem class="po-container e84 e84"><para class="po-block e85 e85"><textual class="po-textual">Allow for production of multiple products from the same source (for
							different media, form factor or audience)</textual></para></listitem><listitem class="po-container e86 e86"><para class="po-block e87 e87"><textual class="po-textual">To add information (context) implicit in the original form</textual></para></listitem><listitem class="po-container e88 e88"><para class="po-block e89 e89"><textual class="po-textual">To encode text so that it may be semantically analyzed</textual></para></listitem></itemizedlist><textual class="po-textual">
			</textual></para><para class="po-block e90 e90"><textual class="po-textual">It is relevant to note that many of these reasons only require markup because software to
                date is not smart enough to actually parse and understand natural languages well
                enough. With human consumers, the semantics of text representing "Title",
                "Paragraph", "sentence" "emphasis" are usually quite obvious to the human reader. So
                are generally the more linguistic attributes such as verb, noun, and phonetics. Even
                the context is often known implicitly by the reader, say when reading a book by
                Charles Dickens one may have a reasonably accurate internal model of the Victorian
                period by which to frame the experience.</textual></para><para class="po-block e91 e91"><textual class="po-textual">Thus much of the value of markup is to encode these things which the primary consumer
                (humans) already knows to make it easier for computer processing.</textual></para></section></section><section class="po-hcontainer e92 e92"><title class="po-block e93 e93"><textual class="po-textual">Why markup Programming Languages?</textual></title><para class="po-block e94 e94"><textual class="po-textual">As with Text, consider Programming Languages. Why would we want to markup programming
            languages? If there is missing information why not just add more to the program? Isn't a
            Programming language already marked up? Similar to Text, these simple questions pose
            some implications and assumptions.</textual></para><section class="po-hcontainer e95 e95"><title class="po-block e96 e96"><textual class="po-textual">What is a Programming Language? </textual></title><para class="po-block e97 e97"><textual class="po-textual">At first glance, Programming Languages seem an altogether different beast than natural
                Languages. The language is artificial and designed for a single purpose - to
                instruct a computer on how to accomplish a task. All the information necessary for
                this task is already encoded in the language - so what need is there for
                markup?</textual></para><para class="po-block e98 e98"><textual class="po-textual">The hidden assumption in these questions is that Programming Languages (or rather it's
                textual representation - "The Source Code") have a single target audience - the
                compiler. But this is blatantly untrue. The truth is that Programming Languages not
                only have multiple audiences for multiple purposes but also usually multiple
                authors. So what really is a Programming Language?</textual></para><para class="po-block e99 e99"><textual class="po-textual">An instance of Programming Language is expressed as one or more text documents which
                comprise "The Source Code". These documents are encoded typically in 'plain text'
                with a limited range of characters available. The syntax of the programming language
                is intended to be humanly readable and writable as well as readable by a computer. </textual></para></section><section class="po-hcontainer e100 e100"><title class="po-block e101 e101"><textual class="po-textual">What is the purpose of a Programming Language?</textual></title><para class="po-block e102 e102"><textual class="po-textual">A programming language serves multiple purposes. The obvious purpose is to instruct a
                computer to perform a task. But there are other purposes. A programming language is
                intended to be written and understood by humans. Similar to a text document, there
                is an implicit context in which the language resides which may not be necessary for
                the compiler, but is necessary for humans in authoring, editing, reading and
                understanding the program. </textual></para><para class="po-block e103 e103"><textual class="po-textual">Different languages recognize and support these purposes to different extents by allowing
                types of markup as part of the language itself. Comments are the main form, but also
                common is markup which may be recognized by the compiler or ancillary programs such
                as pragmas, annotations, and micro-markup within comments such as JavaDoc </textual><xref class="po-milestone e104 e104" linkend="JavaDoc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, HTML </textual><xref class="po-milestone e105 e105" linkend="HTML"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> etc. The syntax of comments and
                micro-markup is specific to each language and generally not interoperable. To make
                things more difficult, languages are often embedded within other languages within
                the same document. For example a Java </textual><xref class="po-milestone e106 e106" linkend="Java"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> program which includes
                HTML that has JavaScript </textual><xref class="po-milestone e107 e107" linkend="JavaScript"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> , or C </textual><xref class="po-milestone e108 e108" linkend="C"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">
                Program with embedded SQL </textual><xref class="po-milestone e109 e109" linkend="SQL"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> . The syntax rules for what
                constitutes a comment and where it can be placed can get extremely confusing.
                Furthermore, most markup defined in programming languages is a point, not a
                container; e.g. a comment occurs at some point in the text stream but does not
                explicitly identify it's target (if any) that is to what does the comment refer. It
                is up to humans and convention to decipher the target, scope, and intent.</textual></para></section><section class="po-hcontainer e110 e110"><title class="po-block e111 e111"><textual class="po-textual">Why markup programming languages?</textual></title><para class="po-block e112 e112"><textual class="po-textual">Programming languages need to be marked up for generally the same reason as Text. Source
                code is a human readable text document that has many of the same characteristics and
                needs as text for human languages. Reasons for marking up Programming Languages
                include: </textual></para><para class="po-block e113 e113"><textual class="po-textual">
				</textual><itemizedlist class="po-table e114 e114"><listitem class="po-container e115 e115"><para class="po-block e116 e116"><textual class="po-textual">Preserve the original machine readable program while adding additional
							information for human readers.</textual></para></listitem><listitem class="po-container e117 e117"><para class="po-block e118 e118"><textual class="po-textual">Annotate for purposes of presentation ("pretty printing")</textual></para></listitem><listitem class="po-container e119 e119"><para class="po-block e120 e120"><textual class="po-textual">Annotate for purposes of action ("TODO, FIXME ...")</textual></para></listitem><listitem class="po-container e121 e121"><para class="po-block e122 e122"><textual class="po-textual">Annotate to provide 'layers' of information (Change history,
							rationale, alternative implementations)</textual></para></listitem><listitem class="po-container e123 e123"><para class="po-block e124 e124"><textual class="po-textual">Provide for machine readable processing besides compilation (document generation,
                            reassembly of sections, flow analysis, code databases and
                            searching)</textual></para></listitem><listitem class="po-container e125 e125"><para class="po-block e126 e126"><textual class="po-textual">Allow for production of multiple products from the same source
							(documentation, program listings, graphs, overviews ...)</textual></para></listitem><listitem class="po-container e127 e127"><para class="po-block e128 e128"><textual class="po-textual">To add information (context) implicit in the original form (explanation of algorithms,
                            attributions, clarifications)</textual></para></listitem></itemizedlist><textual class="po-textual">
			</textual></para><para class="po-block e129 e129"><textual class="po-textual">Programming languages have some pre-existing mechanisms for markup which may suffice for
                some of these needs. Are these sufficient? Is there benefit in learning from the
                concepts, tools, and techniques of Text markup?</textual></para><para class="po-block e130 e130"><textual class="po-textual">A very significant difference between computer languages and Text is that computer
                processes can already (and must) explicitly extract the semantic meaning of most
                language constructs. The main exception being comments which suffer from the same
                problems as Text, they are not currently readily parsable by computers.</textual></para><para class="po-block e131 e131"><textual class="po-textual">The problem however, is that even though "The Computer" can parse the semantics of
                a programming language, it greedily hides this information in the bowels of it's
                internal data structure giving no heed to the concept that maybe there might be
                additional consumers who could value from this information. Thus much of this
                information for which Text Markup is required is only needed because Programming
                Language consumers (parsers, compilers etc.) are not designed for any other
                purpose.</textual></para><section class="po-hcontainer e132 e132"><title class="po-block e133 e133"><textual class="po-textual">Practical uses for Programming Language Markup</textual></title><para class="po-block e134 e134"><textual class="po-textual">In the previous section we discussed some fairly abstract reasons for marking up
                    software. In practical terms what might this buy us? What kinds of tools and
                    value might we expect if the full semantics of programming languages was
                    available to existing markup processing tool-sets?</textual></para><para class="po-block e135 e135"><textual class="po-textual">Some concrete examples might include:</textual></para><itemizedlist class="po-table e136 e136"><listitem class="po-container e137 e137"><para class="po-block e138 e138"><textual class="po-textual">Automated reorganization of source files by reliable detection of boundary
                            markers in compilation units</textual></para></listitem><listitem class="po-container e139 e139"><para class="po-block e140 e140"><textual class="po-textual">Call-flow and dependency analysis</textual></para></listitem><listitem class="po-container e141 e141"><para class="po-block e142 e142"><textual class="po-textual">Data Mining and document management of a large code base to determine
                            possibilities for reuse, rework or discovering difficult to find
                            code</textual></para></listitem><listitem class="po-container e143 e143"><para class="po-block e144 e144"><textual class="po-textual">Source level code optimization </textual><xref class="po-milestone e145 e145" linkend="XsltOpt"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></para></listitem><listitem class="po-container e146 e146"><para class="po-block e147 e147"><textual class="po-textual">Algorithmic analysis of software to help find and fix insecure or inefficient code</textual></para></listitem><listitem class="po-container e148 e148"><para class="po-block e149 e149"><textual class="po-textual">Publication of parts or all of codebases in different combinations and media.</textual></para></listitem><listitem class="po-container e150 e150"><para class="po-block e151 e151"><textual class="po-textual">License management and auditing.</textual></para></listitem><listitem class="po-container e152 e152"><para class="po-block e153 e153"><textual class="po-textual">Detecting potential patentable algorithms.</textual></para></listitem><listitem class="po-container e154 e154"><para class="po-block e155 e155"><textual class="po-textual">Validation of the accuracy of documentation and comments with respect to the
                            actual code.</textual></para></listitem><listitem class="po-container e156 e156"><para class="po-block e157 e157"><textual class="po-textual">Language independent IDE's that can be used across languages and
                            roles.</textual></para></listitem></itemizedlist></section><section class="po-hcontainer e158 e158"><title class="po-block e159 e159"><textual class="po-textual">The problem with Programming Language AS a Markup Language</textual></title><para class="po-block e160 e160"><textual class="po-textual">A common sentiment regarding marking up programming languages is that it is
                    unnecessary because programming languages are themselves a markup language, or
                    at least provide a strict syntax which is computer parsable. There are several
                    problems with this reasoning. A big problem is that the syntax and semantics of
                    programming languages is primarily aimed at one consumer - the compiler. This
                    syntax can be extremely tedious to use for other purposes. In general it
                    requires a complete specific language aware parser to extract the program
                    structure from the syntax. Even extracting comments requires a language aware
                    parser.</textual></para><para class="po-block e161 e161"><textual class="po-textual">For example, consider this Java snippet:</textual></para><figure class="po-container e162 e162"><programlisting class="po-block e163 e163" xml:space="preserve"><textual class="po-textual">
System.out.println("This is /* A comment */ or // is this " + /* A comment */ " or // is this ") ; // 
"A comment"</textual></programlisting></figure><para class="po-block e164 e164"><textual class="po-textual">Or this XQuery statement</textual></para><figure class="po-container e165 e165"><programlisting class="po-block e166 e166" xml:space="preserve"><textual class="po-textual">           

return &lt;element&gt;
    (: Is this a comment :) { () (: or is this a comment :) } &lt;!-- What about this --&gt;
&lt;/element&gt;

            </textual></programlisting></figure><para class="po-block e167 e167"><textual class="po-textual">Reliably extracting out the comments from the code is a very tedious task.
                    Furthermore, it is language specific. Every programming language has it's own
                    rules and quirks. Of the same can be said of all languages including XML,
                    however programming languages tend to have non regular structures that are
                    particularly difficult to parse.</textual></para><para class="po-block e168 e168"><textual class="po-textual">But suppose we could easily parse and extract comments, and identify where they were
                in the code text - what do they mean? By their very nature comments have no explicit
                semantics.  They are just plain text.  The traditional way of handling this is to
                add a kind of micro-format or embedded markup within comments used by particular
                tools.  For example JavaDoc uses a set of special tags as well as HTML to mark up
                portions of the text within comments.   This becomes a very complex 'Russian Doll'
                layering of different markup languages embedded within each other.</textual><footnote class="po-popup e169 e169"><para class="po-block e170 e170"><textual class="po-textual">It can be argued that this markup is actually all part of JavaDoc and not an actual nesting of
                            markup, however the issues involve with parsing the markup
                            remain.</textual></para></footnote><textual class="po-textual">   Even then, the
                target audience of JavaDoc is limited.  It can be parsed by very few tools and the
                output is limited to few uses.  To target other uses we need different markup - and
                special tools to parse that.  </textual></para><figure class="po-container e171 e171" xml:id="JavaDoc11"><title class="po-block e172 e172"><textual class="po-textual">JavaDoc Example</textual></title><mediaobject class="po-container e173 e173"><imageobject class="po-container e174 e174"><imagedata class="po-meta e175 e175" fileref="../../../vol8/graphics/Lee01/Lee01-001.jpg" format="jpg" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject><caption class="po-container e176 e176"><para class="po-block e177 e177"><textual class="po-textual">Nested markup in JavaDoc</textual></para><para class="po-block e178 e178"><textual class="po-textual">From Saxon 9.4 source.</textual></para></caption></figure><para class="po-block e179 e179"><textual class="po-textual">Imagine we decided on a good markup for embedding in comments, there is
                a fundamental limitation imposed by the syntax - they are missing a target. Comments
                appear at a single point in the text stream. There is nothing explicit that
                indicates to what they refer. There are conventions that are generally humanly
                understandable, such as placing a comment preceding a function means it applies to
                that function, but the conventions are easily broken.  </textual></para><para class="po-block e180 e180"><textual class="po-textual"> Consider this simple Java snippet</textual></para><figure class="po-container e181 e181"><programlisting class="po-block e182 e182" xml:space="preserve"><textual class="po-textual">	            
/*
 * This file implements the PixieDust portion of Magic Products.
 */
 class PixieDust {
 
 // The pixie function
 private int magic = 0;     // Magic 
 public int pixie( int dust )
 { 
       /*
       * Be careful that magic is not set somewhere else
       */
      return ((magic &lt; 10) ? 0 : magic)   + dust ;  // Conditionally add dust
 } 
} 
</textual></programlisting></figure><para class="po-block e183 e183"><textual class="po-textual">To a human it is fairly clear which comment applies to what. One generally follows
                    the convention that block comments precede their target and inline comments
                    follow their target. But from a parsers perspective it's entirely unclear what
                    comment is associated with which language construct, if any. Note, for example,
                    the comment "The pixie function" immediately precedes the variable declaration
                    for "magic" yet is obvious to human readers that it refers to the function
                    declaration instead. The comment "Be careful that magic is not set somewhere
                    else" doesn't target the following expression exactly, it's a more out of bands
                    annotation concerning the algorithm. We could of course start adding markup in
                    the comments to clarify to what they refer.</textual></para><programlisting class="po-block e184 e184" xml:space="preserve"><textual class="po-textual">              
/*
 *  &lt;file name="pixiedust.java"&gt;This file implements the PixieDust portion of Magic Products.&lt;/file&gt;
 */
 class PixieDust {
 
 
  // &lt;function name="pixie"&gt;The pixie function&lt;/function&gt;

  private int magic = 0;     // &lt;description variable="magic"&gt;Magic &lt;/description&gt;
  int pixie( int dust )
  { 
       /* &lt;annotation&gt;
       * Be careful that magic is not set somewhere else
         &lt;/annotation&gt;
       */
      return ((magic &lt; 10) ? 0 : x)   + dust ;  // Add magic to dust if &gt;= 10 ;  // 
      &lt;explanation reference="((magic &lt; 10) ? 0 : magic)"&gt;Conditionally add dust&lt;/explanation&gt;
      
  }
}
	        </textual></programlisting><para class="po-block e185 e185"><textual class="po-textual">This is starting to look pretty crazy. Unfortunately this is the essence of what
                implementations of embedded markup in programming languages end up doing.
                Furthermore this is still an extremely fragile binding. Without a full language
                parser available, the comment markup processor has no way of identifying and
                validating the targets. For example, if I wanted to query "Give me the code for
                function 'pixie'" the above markup would not be able to answer that. </textual></para><para class="po-block e186 e186"><textual class="po-textual">We could go further and try to express the more of the structure in comment markup
                    using containment instead of positioning and named references.</textual></para><figure class="po-container e187 e187"><programlisting class="po-block e188 e188" xml:space="preserve"><textual class="po-textual"> 
	        
/*
 *  &lt;file name="pixiedust.java"&gt;
 *  &lt;description&gt;This file implements the PixieDust portion of Magic Products.&lt;description&gt;
 */
 class PixieDust {
 // &lt;variable name="magic"&gt;
  int magic = 0;     // &lt;description&gt;Magic&lt;/description&gt;
 // &lt;/variable&gt;  
 // &lt;function name="pixie"&gt;
 // &lt;description&gt;The pixie function&lt;/description&gt;

 int pixie( int dust )
 { 
       /* &lt;annotation&gt;
       * Be careful that magic is not set somewhere else
         &lt;/annotation&gt;
       */
        // &lt;explanation&gt;
        
       return ((magic &lt; 10) ? 0 : magic)   + dust ; //  &lt;description&gt;Conditionally add dust&lt;/description&gt;
      // &lt;/explanation&gt;
 }
 //&lt; /function&gt;
 //&lt;/file&gt;

</textual></programlisting></figure><para class="po-block e189 e189"><textual class="po-textual">Now we approach a markup, embedded in comments, that has more semantics. it's also
                    redundant and extremely difficult to read, edit, maintain and validate. it's
                    likely that for these reasons markup in programming languages is general limited
                    to embedding documentation. When simply using markup for documentation (as
                    opposed to the above structure) the markup is "close to" the code but it really
                    doesn't markup the code. This is very useful as documentation that is close to
                    the code is generally more likely to be updated and kept in sync but it's really
                    just a way of managing documentation and adds little if any value to the code
                    itself</textual></para><section class="po-hcontainer e190 e190"><title class="po-block e191 e191"><textual class="po-textual">Pragmas and Annotations</textual></title><para class="po-block e192 e192"><textual class="po-textual">Another form of programming language markup is Pragmas and Annotations. These
                        are designed to be part of the language itself and thus have semantics as
                        opposed to comments. Java is a good example with a quite expressive
                        annotation capability. The problem with annotations and pragmas however lies
                        specifically with their coupling to the language. Not only are they language
                        specific but have predefined or proprietary semantics and are part of the
                        language itself, rather than meta-data about the language. Thus by adding
                        pragmas or annotations you are changing the program itself; this violates
                        many of the goals of markup in that it changes the underlying
                        semantics.</textual></para><para class="po-block e193 e193"><textual class="po-textual">It is possible that programming languages could be extended to allow for more
                        structured documentation or markup such as annotations that does not affect
                        the semantics of the program in any way. However this would still require a
                        full language parser and would inherently be language  dependent.</textual></para></section></section><section class="po-hcontainer e194 e194"><title class="po-block e195 e195"><textual class="po-textual">Making Markup a First Class Citizen</textual></title><para class="po-block e196 e196"><textual class="po-textual">Much of the problem is imposed on us by trying to work within the existing syntax
                    of the language. Either by using comments which have no semantics and complex
                    nested syntax to support markup, or by annotations which have language defined
                    semantics and so affect the underlying code directly. Instead perhaps we can
                    learn from the lessons Text Markup tradition. </textual></para><para class="po-block e197 e197"><textual class="po-textual">With Text Markup there is fundamentally the same problem. The original text is
                    preserved while adding additional data or meta-data. The solution used by markup
                    such as XML is to discard the concept that serialized format of the document
                    itself must be the original text. Rather the text is contained within markup
                    instead of putting markup within the text. The markup processor can parse the
                    document, and if desired reproduce the original text exactly. Just as with human
                    languages, this technique allows a single syntax to be used to markup any number
                    of languages and a common tool-chain to process them. This inversion of
                    representation is not without precedent in programming languages. Preprocessors
                    such as cpp and m4 are a similar concept, and language tool-chains typically
                    have the ability to integrate transformation of source documents prior to
                    compilation. Many modern IDE's have the ability to install plug-ins for working
                    with additional document formats while utilizing the full features of the
                    IDE.</textual></para></section></section><section class="po-hcontainer e198 e198"><title class="po-block e199 e199"><textual class="po-textual">A journey through Literate Programming</textual></title><para class="po-block e200 e200"><textual class="po-textual">A discussion about marking up programming languages is not complete without consideration of Literate Programming </textual><xref class="po-milestone e201 e201" linkend="LitP"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">.</textual></para><para class="po-block e202 e202"><textual class="po-textual">Literate Programming, as introduced by Donald Knuth, is a very interesting concept. The
                idea is that commentary (prose) is 'interwoven' with code and that a post processing
                phase separates the two into either documentation or source code. This has some
                overlap with the concept of marking up programming language but I feel it is a quite
                different path.</textual></para><para class="po-block e203 e203"><textual class="po-textual">The perspective I propose is that source code be treated more like Historic or Primary
                documents. That is that the source code is the primary information and that markup
                is annotation or meta-data applied to document.</textual></para><para class="po-block e204 e204"><textual class="po-textual">This philosophical distinction has practical implications. With Literate Programming the
                source code is "tangled". That is snippets of source code are interspersed
                throughout the prose and not necessarily even in the same order as the final
                resulting program. This has the advantages of providing an emphasis on providing the
                prose as the primary source so let's the reader understand the exposition in a more
                customary way, leaving the actual implementation (the code) as almost a side
                thought.</textual></para><para class="po-block e205 e205"><textual class="po-textual">This is useful for describing the thought processes of design but I argue that it is
                problematic for the actual engineering of software. The fact is that software source
                code (or rather, compilers) is very particular about the exact representation. It
                takes significant effort to produce source code that is parsed and works exactly as
                intended. Much of this difficulty is in fact the sort of things literate programming
                attempts to hide such as ordering and placement of statements, code blocks, and
                compilation units. I suggest that one reason Literate Programming has not achieved
                wide adoption is that it makes the everyday programmers task more difficult.
                Curiously, similar statements have been made about C++ for example. </textual><quote class="po-inline e206 e206"><textual class="po-textual">C++ is an
                    excellent language for hiding the trivial and mundane details of a program...
                    like where the bugs are.</textual></quote><citation class="po-atom e207 e207"><textual class="po-textual">unknown</textual></citation><textual class="po-textual"> I belie tangling
                already difficult to understand code within prose makes the job of both authoring
                and debugging the software harder, not easier.</textual></para><para class="po-block e208 e208"><textual class="po-textual">With these thoughts in mind I suggest diverging from the Literate Programming perspective
                and instead look to the source code as the primary information, not something to be
                hidden within prose, but rather annotated.</textual></para></section></section><section class="po-hcontainer e209 e209"><title class="po-block e210 e210"><textual class="po-textual">CodeUp - Marking up Programming Languages with XML</textual></title><para class="po-block e211 e211"><textual class="po-textual">Considering that it is not a huge technical hurdle to integrate marked up programming
            language documents into the life-cycle of development tools, let's consider what
            possible benefits could be gained and effort and costs would be to apply text markup
            concepts to programming languages.</textual></para><para class="po-block e212 e212"><textual class="po-textual">"CodeUp" is an experimental family of XML schemas designed to experiment with the
            application of Text Markup techniques to programming language source code. The premise
            is that marking up source code can add value and that programming languages can be
            considered similar text in terms of purpose and techniques. To start we take the initial
            huge leap and decide that like XML based text markup, source code should be contained
            within an XML document structure, as opposed to putting XML markup within the
            programming language syntax. This implies that the marked up document is not directly
            usable by a consumer which assumes the document is syntactically represented as it's
            programming language. Rather, like with text markup, a transformation must be applied to
            the marked up document in order to retrieve the 'original' source document. </textual></para><para class="po-block e213 e213"><textual class="po-textual">By starting with a minimal markup then proceeding to more complexity we can experiment
            with the value vs costs trade-off implicit with adding markup. Markup involves a cost.
            There is the cost of applying the markup, but in addition there are costs associated
            with maintenance, readability and transformation. The more complex the markup the higher
            the cost. Presumably there comes with higher cost, higher value; but like with text
            markup value is more difficult to measure than cost. One way of describing value is like
            potential energy. The value added by markup is potential, but may not be realized
            depending on the actual use of the content. Thus there is a trade-off between how much
            we are willing to invest in markup compared to the value we hope to extract. The first
            foothold in marking up a source code document in XML is to simply wrap the source in a
            root element. This then gives us a scaffolding by which we can incrementally build more
            complex markup. This is very simple to do but it also immediately exposes us to indirect
            costs. Once we wrap a source code document in even the most simple root element it is no
            longer directly usable by the primary consumer - a compiler! Getting over this first
            step adds significant cost with very little if any value.</textual></para><section class="po-hcontainer e214 e214"><title class="po-block e215 e215"><textual class="po-textual">Transparent Markup</textual></title><para class="po-block e216 e216"><textual class="po-textual">A critical requirement for source code markup is that the "original" text needs to be
                preserved. Similar to Text Documents, "original" may be a temporal quality (i.e.
                there existed prior in time an "original" document which is later marked up). But a
                similar case is to consider "original" to mean "what would the text be if there was
                no markup", regardless of which was authored first or authored at the same time. In
                both cases the requirements are the same: the "original" must be unchanged by markup
                and be able to be extracted from a marked up document. The simplest case of this is
                the use of "transparent markup". This is a premise in many text oriented schemas,
                that is the concept that if you remove all markup what is left is the
                "original".</textual></para><para class="po-block e217 e217"><textual class="po-textual">
                Applying that to CodeUp we can start with the first step, a root element.</textual></para><figure class="po-container e218 e218"><programlisting class="po-block e219 e219" xml:space="preserve"><textual class="po-textual">	            
&lt;program xmlns="http://xml.calldei.com/codeup"&gt;
/*
* This file implements the Pixie portion of PixieDust Products.
*/

// The pixie function
int x = 0;     // Magic 
int pixie( int dust )
{ 
/*
* Be careful that x is not set somewhere else
*/
return ((x &amp;lt; 10) ? 0 : x)   + dust;  // Conditionally Add dust

}
&lt;/program&gt;
 </textual></programlisting></figure><para class="po-block e220 e220"><textual class="po-textual">This simple step is easy to apply, and in fact could be programmatically applied
                to a set of source code. There is a complication that the text of the code itself
                may overlap with XML markup; it needs to be escaped with entity escapes or CDATA
                sections, but that is fairly easy to accomplish. CDATA markers can easily be added
                by hand to the beginning and end of the file. A simple text parser or an XML enabled
                GUI tool can accomplish entity encoding easily and risk free. The direct cost of
                adding this markup is practically zero. However it exposes the indirect costs: the
                entire development and compilation ecosystem is now broken. In addition if simple
                hand entering or editing of the source code is done care must be taken to escape
                what was source code but in the context of a marked up document would be
                misinterpreted as markup. More complex escaping may need to be done if the code
                contained XML-like markup to begin with such as JavaDoc with embedded HTML,
                especially if the contained markup itself has CDATA sections or entity encoding. </textual></para><section class="po-hcontainer e221 e221"><title class="po-block e222 e222"><textual class="po-textual">Compilers</textual></title><para class="po-block e223 e223"><textual class="po-textual">The most obvious problem is that now any consumer of the source code, such as compilers, which previously expected it to be syntactically identical to the original document is broken.</textual></para><para class="po-block e224 e224"><textual class="po-textual">That is likely why this approach is rarely taken in practice. However the
                    solution for automated processing (compilers, parsers etc.) is actually quite
                    easy. Most development tool-sets accommodate preprocessing quite easily as a
                    normal and expected procedure. For example in a Makefile or ANT script it is
                    quite easy to add a step which would consume the CodeUp document and produce the
                    original source. A Very simple XSLT </textual><xref class="po-milestone e225 e225" linkend="XSLT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, XQuery </textual><xref class="po-milestone e226 e226" linkend="XQuery"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> or other XML processor could be used.</textual></para><para class="po-block e227 e227"><textual class="po-textual">The following XSLT is sufficient extracting the data from this example. In fact
                    this is sufficient for any markup which follows the constraints of transparent -
                    that is it removes all markup and leaves the underlying text unchanged.
                    Equivalent to this is using any XML parser and outputting only text
                    nodes.</textual></para><figure class="po-container e228 e228" xml:id="XSLT1"><title class="po-block e229 e229"><textual class="po-textual">Simple XSLT for transparent markup</textual></title><programlisting class="po-block e230 e230" xml:space="preserve"><textual class="po-textual">	            
&lt;?XML version="1.0" encoding="UTF-8"?&gt;
&lt;XSL:stylesheet xmlns:XSL="http://www.w3.org/1999/XSL/Transform" version="2.0"&gt;
&lt;XSL:output method="text"/&gt;
&lt;XSL:template match="*"&gt;
    &lt;XSL:value-of select="."/&gt;
&lt;/XSL:template&gt;
&lt;/XSL:stylesheet&gt;
</textual></programlisting></figure><para class="po-block e231 e231"><textual class="po-textual">Applying this transformation as part of the compilation process is quite
                    simple in most programming environments. A somewhat more complex transformation
                    if source line numbers and filenames are to be preserved, but again the
                    techniques are well known and commonly used in other situations.</textual></para></section><section class="po-hcontainer e232 e232"><title class="po-block e233 e233"><textual class="po-textual">Editors and IDE's</textual></title><para class="po-block e234 e234"><textual class="po-textual">Authoring and Editing marked up code is another challenge. Once the code no longer
                    parses as the original source language syntax, any editors or IDE's which are
                    designed for the specific language will no longer work as expected. Simple
                    things like syntax highlighting will be broken. More complex features such as
                    refactoring, class browsing, outlining etc. will not work. This can be a major
                    hurdle to embracing code markup.</textual></para><para class="po-block e235 e235"><textual class="po-textual">Fortunately the IDE's with the more complex features tend to also have more
                    customization abilities. Eclipse </textual><xref class="po-milestone e236 e236" linkend="Eclipse"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> is a prime example
                    which is designed to be extended to multiple languages and syntaxes. Another be
                    possibility is that once code is in XML form, then XML editors can be used as
                    intelligent code editors. In fact the more mark-up applied to source code the
                    more XML editors can be leveraged as software editors. However it is difficult
                    to imagine how a pure XML editor could match the features of a language specific
                    IDE even if every token was marked up. Modern IDE's use incremental compilation
                    and language awareness to do things like method name completion which would be
                    impossible to achieve with static schemas alone. An XML editor using a language
                    schema may be able to know that a </textual><emphasis class="po-inline e237 e237"><textual class="po-textual">for loop</textual></emphasis><textual class="po-textual"> needs a body but
                    unless they can reflect on the full parse tree of the whole compilation unit
                    they couldn't for example know what methods a particular instance of an object
                    are public or even what variables are in scope.</textual></para><para class="po-block e238 e238"><textual class="po-textual">For authors that use less specific editors the opposite is the problem. XML markup
                    itself poses no problems in a text editor, but it also provides no benefit. Much
                    like the authors of Text markup, editing marked up code with non-XML aware
                    editors poses challenges to many authors. For those comfortable authoring with
                    markup syntax the experience may be easy, but for those who are not, the use of
                    a specialized editor or macros in customizable editors (like Emacs </textual><xref class="po-milestone e239 e239" linkend="Emacs"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) may be more
                    productive. </textual></para></section></section><section class="po-hcontainer e240 e240"><title class="po-block e241 e241"><textual class="po-textual">The rocky road from A Text Syntax to an XML Syntax</textual></title><para class="po-block e242 e242"><textual class="po-textual">Once we've accomplished the initial step of converting a programing language to an XML Document, and all that entails including editors, IDE's, tool-chains and work-flows we can start to explore the benefits and costs of enriching the markup.</textual></para><para class="po-block e243 e243"><textual class="po-textual">Continuing under the premise of "Transparent Markup" what can be improved while maintaining the original text as source code?  Much of this can be done as language neutral markup because it is entirely optional.  Strip out the markup and you get the source code.  Markup need only be informative or helpful but need not be semantically perfect.</textual></para><para class="po-block e244 e244"><textual class="po-textual">Imagine the following 'improvements' to the original sample.</textual><figure class="po-container e245 e245"><programlisting class="po-block e246 e246" xml:space="preserve"><textual class="po-textual">	            
&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
    &lt;comment scope="file"&gt;
    /*
    * This file implements the PixieDust portion of Magic Products.
    */
    &lt;/comment&gt;
    &lt;class&gt;  
    class PixieDust {
    
    &lt;comment inline="true"&gt;// The pixie function&lt;/comment&gt;
    private int magic = 0;     // Magic 
    &lt;method&gt; 
    public int pixie( int dust )
    { 
      &lt;comment&gt;
      /*
      * Be careful that magic is not set somewhere else
      */
      &lt;/comment&gt;
      return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;// Conditionally 
      add dust&lt;/comment&gt;
    
    } 
    &lt;/method&gt;
    &lt;/class&gt;
}
&lt;/program&gt;

</textual></programlisting></figure></para><para class="po-block e247 e247"><textual class="po-textual">This begins to add the sort of semantics common in text markup while still being transparent.  The simple XSLT still produces the original source code by stripping all markup, and using an XML IDE starts to provide value in terms of authoring </textual></para><para class="po-block e248 e248"><textual class="po-textual">For example the following is the Author view in Oxygen </textual><xref class="po-milestone e249 e249" linkend="Oxygen"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> </textual><footnote class="po-popup e250 e250"><para class="po-block e251 e251"><textual class="po-textual">For the purpose of this paper, experiments and samples were implemented
                using Oxygen Author.  This tool provides for fairly simple customization
                using CSS Stylesheets </textual><xref class="po-milestone e252 e252" linkend="CSS"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> and supports a "WYSIWYG" style of authoring XML marked
                up documents in addition to a text view.  This is not to propose this tool as
                the solution to the problem of editing, but rather as an example of how
                existing tools XML editors can be leveraged for the purposes of authoring
                and editing software.   This focuses on the language neutrality enabled by a
                consistent markup vocabulary regardless of the underlying programming
                language.  Ideally, if these concepts were embraced a more specialized
                software development  IDE (such as Eclipse) should be able to  provide a more
                enhanced experience.  </textual></para></footnote><textual class="po-textual">with a very simple CSS applied to the schema</textual></para><figure class="po-container e253 e253" xml:id="Sample2"><title class="po-block e254 e254"><textual class="po-textual">Oxygen Author mode view of the above source.</textual></title><mediaobject class="po-container e255 e255"><imageobject class="po-container e256 e256"><imagedata class="po-meta e257 e257" fileref="../../../vol8/graphics/Lee01/Lee01-002.jpg" format="jpg" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure><section class="po-hcontainer e258 e258"><title class="po-block e259 e259"><textual class="po-textual">The Dead End of Transparent Markup</textual></title><para class="po-block e260 e260"><textual class="po-textual">The previous attempt has some valuable markup but still lacks significant semantic
                    value. For example the question "what is the method called 'pixie'" or "To which
                    language element is a comment referring" cannot be answered with only this XML
                    markup. Suppose we go further and embed more of the language semantics within
                    the markup, while still staying with the goal of Transparent markup. Something
                    like this is an obvious next step.</textual><figure class="po-container e261 e261"><programlisting class="po-block e262 e262" xml:space="preserve"><textual class="po-textual">	            
&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
    &lt;comment scope="file"&gt;
    /*
    * This file implements the PixieDust portion of Magic Products.
    */
    &lt;/comment&gt;
    &lt;class name="PixieDust"&gt;    
    class PixieDust {
    
   &lt;comment inline="true"&gt;// The pixie function&lt;/comment&gt;
   
   &lt;variable scope="private" name="magic" type="int" initializer="0"&gt;
    private int magic = 0;     // Magic 
   &lt;/variable&gt;
   
    &lt;method name="pixie" scope="public" return="int"&gt;
    &lt;parameter name="dust" type="int"/&gt;
    public int pixie( int dust )
    { 

    &lt;comment&gt;
    /*
    * Be careful that magic is not set somewhere else
    */
    &lt;/comment&gt;
        &lt;statement type="return" expression="((magic &amp;lt; 10 ) ? 0 : magic)   + dust"&gt;
        return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;// Conditionally 
        add dust&lt;/comment&gt;
    &lt;/statement&gt;
    } 

    &lt;/method&gt;&lt;/class&gt;
    }
&lt;/program&gt;

</textual></programlisting></figure><textual class="po-textual">
                </textual></para><para class="po-block e263 e263"><textual class="po-textual">With a little CSS magic Oxygen Author mode displays the additional semantics
                including outlining and collapsing. Using the  XSLT in </textual><xref class="po-milestone e264 e264" linkend="XSLT1"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">  the result is the original
                    text.</textual><figure class="po-container e265 e265" xml:id="Sample3"><title class="po-block e266 e266"><textual class="po-textual">Oxygen Author mode view of the above source.</textual></title><mediaobject class="po-container e267 e267"><imageobject class="po-container e268 e268"><imagedata class="po-meta e269 e269" fileref="../../../vol8/graphics/Lee01/Lee01-003.jpg" format="jpg" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></para><para class="po-block e270 e270"><textual class="po-textual">At this point we have captured a significant amount of the language semantics
                    entirely in XML Markup and can indeed perform some semantic queries such as
                    "What is the body of the pixie function" or "What are the method names,
                    parameters and return values in the pixiedust.java file". We could use this
                    information to achieve many of the goals of Markup such as production of
                    different representations, limited semantic queries, publication, aggregation
                    even code refactoring - all using XML tools only.</textual></para><para class="po-block e271 e271"><textual class="po-textual">Unfortunately to achieve this we have suffered some of the main problems of
                    embedded markup: that of duplication of information, fragility and difficulty
                    authoring, editing and viewing. Also the markup does not embed the full
                    semantics of the language. For example call graphs or object dependencies cannot
                    be generated because the semantics of expressions is not modeled. It seems we
                    have reached a dead-end as it's unlikely software authors are willing to put the
                    effort into this level of markup considering that it's really duplicating the
                    code in two different ways serving the author little gain and adding great
                    effort. Furthermore the chances of the markup being valid over the life-cycle of
                    the program are slim. It would take a very dedicated author to make sure that
                    the entire markup is updated as code is updated and there is no automatic way of
                    validating it without comparing the results of a full language parser against
                    the markup. So in reality the value is negative and the cost is high.</textual></para></section><section class="po-hcontainer e272 e272"><title class="po-block e273 e273"><textual class="po-textual">Semi-transparent Markup</textual></title><para class="po-block e274 e274"><textual class="po-textual">Considering the dead end attempting pure transparent markup, let's back up and
                    reconsider the original goals. When we wanted to maintain the integrity of the
                    "original text" of the programming language, perhaps the goal can be achieved by
                    relaxing the concept of "original". Instead, considering we have already added a
                    process of transformation to extract the "original", perhaps it's sufficient
                    that the transformation itself can produce some of the text as a side effect of
                    markup instead of requiring that all output be literal text. As long as the
                    results are identical to the </textual><emphasis class="po-inline e275 e275"><textual class="po-textual">intended</textual></emphasis><textual class="po-textual"> original we can
                    consider it semantically equivalent. </textual></para><para class="po-block e276 e276"><textual class="po-textual">For purposes of this discussion I will call this markup style "Semi Transparent".  That is, a combination of markup and plain text, when transformed with a known transformation is able to produce what would be the "original" text if we did not use markup.</textual></para><para class="po-block e277 e277"><textual class="po-textual">Consider this simple fragment </textual><programlisting class="po-block e278 e278" xml:space="preserve"><textual class="po-textual">
class PixieDust { body } 
 </textual></programlisting><textual class="po-textual"> One could represent this using markup but without duplication by something
                    like </textual><programlisting class="po-block e279 e279" xml:space="preserve"><textual class="po-textual">

&lt;class name="PixieDust"&gt;
body
&lt;/class&gt;
</textual></programlisting></para><para class="po-block e280 e280"><textual class="po-textual">These two are semantically equivalent.  Using a simple transformation the </textual><emphasis class="po-inline e281 e281"><textual class="po-textual">Intended Text</textual></emphasis><textual class="po-textual"> could easily be produced but without duplication of data.</textual></para><para class="po-block e282 e282"><textual class="po-textual">Expanding on this let's see what the full sample might look like using a
                    semi-transparent markup.</textual></para><para class="po-block e283 e283"><figure class="po-container e284 e284"><programlisting class="po-block e285 e285" xml:space="preserve"><textual class="po-textual">

&lt;program xmlns="http://xml.calldei.com/codeup" language="Java" file="pixiedust.java"&gt;
   &lt;comment scope="file"&gt;
   * This file implements the PixieDust portion of Magic Products.
   &lt;/comment&gt;
   &lt;class name="PixieDust"&gt;    
   &lt;comment inline="true"&gt;The pixie function&lt;/comment&gt;
        
   &lt;variable scope="private" name="magic" type="int" initializer="0"/&gt;
   &lt;method name="pixie" scope="public" return="int"&gt;
    &lt;parameter name="dust" type="int"/&gt;
    &lt;comment&gt;
    * Be careful that magic is not set somewhere else
    &lt;/comment&gt;
        &lt;statement&gt;
            return ((magic &amp;lt; 10 ) ? 0 : magic)   + dust ;  &lt;comment inline="true"&gt;Conditionally 
            add dust&lt;/comment&gt;
        &lt;/statement&gt;
   &lt;/method&gt;&lt;/class&gt;
&lt;/program&gt;
 
  </textual></programlisting></figure><textual class="po-textual">               
       
             </textual></para><para class="po-block e286 e286"><textual class="po-textual">With some more CSS magic Oxygen Author mode displays the additional semantics.  
                </textual><figure class="po-container e287 e287" xml:id="Sample4"><title class="po-block e288 e288"><textual class="po-textual">Oxygen Author mode view of the above source.</textual></title><mediaobject class="po-container e289 e289"><imageobject class="po-container e290 e290"><imagedata class="po-meta e291 e291" fileref="../../../vol8/graphics/Lee01/Lee01-004.jpg" format="jpg" width="75%"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></imagedata></imageobject></mediaobject></figure></para><para class="po-block e292 e292"><textual class="po-textual">A slightly more complex XSLT is required to produce the </textual><emphasis class="po-inline e293 e293"><textual class="po-textual">Intended Text</textual></emphasis><textual class="po-textual">
                </textual><figure class="po-container e294 e294"><programlisting class="po-block e295 e295" xml:space="preserve"><textual class="po-textual">

&lt;?XML version="1.0" encoding="UTF-8"?&gt;
&lt;XSL:stylesheet xmlns:codeup="http://xml.calldei.com/codeup" 
                xmlns:XSL="http://www.w3.org/1999/XSL/Transform" 
                version="2.0"&gt;
    &lt;XSL:output method="text"/&gt;

    &lt;XSL:template match="codeup:comment"&gt;
        &lt;XSL:if test="@inline"&gt;&lt;XSL:text&gt;// &lt;/XSL:text&gt;&lt;/XSL:if&gt;
        &lt;XSL:if test="not(@inline)"&gt;&lt;XSL:text&gt;/*&lt;/XSL:text&gt;&lt;/XSL:if&gt;
        &lt;XSL:value-of select="text()"/&gt; 
        &lt;XSL:if test="not(@inline)"&gt;&lt;XSL:text&gt;*/&lt;/XSL:text&gt;&lt;/XSL:if&gt;
    &lt;/XSL:template&gt;
    
    &lt;XSL:template match="codeup:variable"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt;  &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;  &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@type"/&gt;
        &lt;XSL:text&gt;  = &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@initializer"/&gt;
         &lt;XSL:text&gt; ;&lt;/XSL:text&gt; 
     &lt;/XSL:template&gt;
    
    &lt;XSL:template match="codeup:class"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt; class &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;{&lt;/XSL:text&gt; 
        &lt;XSL:apply-templates select="node() "/&gt;
        &lt;XSL:text&gt;}&lt;/XSL:text&gt; 
    &lt;/XSL:template&gt;
        
    &lt;XSL:template match="codeup:method"&gt;
        &lt;XSL:value-of select="@scope"/&gt;
        &lt;XSL:text&gt; &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@return"/&gt; 
        &lt;XSL:text&gt; &lt;/XSL:text&gt;
        &lt;XSL:value-of select="@name"/&gt;
        &lt;XSL:text&gt;(&lt;/XSL:text&gt;
        &lt;XSL:apply-templates select="parameters"/&gt;
        &lt;XSL:text&gt;){&lt;/XSL:text&gt;
        &lt;XSL:apply-templates select="node() except element(parameters)"/&gt;
        &lt;XSL:text&gt;}&amp;#10;&lt;/XSL:text&gt;
    &lt;/XSL:template&gt;

&lt;/XSL:stylesheet&gt;
 
  </textual></programlisting></figure><textual class="po-textual"> </textual></para></section></section></section><section class="po-hcontainer e296 e296"><title class="po-block e297 e297"><textual class="po-textual">Towards a fully XML syntax</textual></title><para class="po-block e298 e298"><textual class="po-textual">As we can see from Semi-Transparent markup there is an obvious path towards a fully
            XML Syntax. If you can mark up classes, function, variable declarations, statements,
            comments, why stop there? One could envision a markup fully detailing the semantics of
            every aspect of the programming language. A next step might be encoding control flow
            (if/while/switch), and expressions. Is there an obvious end to this path? At what point
            do we achieve a fully XML syntax, and is it even desirable?</textual></para><para class="po-block e299 e299"><textual class="po-textual">A look to what is considered XML Syntax languages can show the possible results. XSLT,
            for example, is considered an XML Syntax language. But XSLT is not fully marked up!
            Consider this snippet in XSLT 3.0. </textual><figure class="po-container e300 e300" xml:id="XPath"><title class="po-block e301 e301"><textual class="po-textual">XPath embedded in XSLT </textual><xref class="po-milestone e302 e302" linkend="XPathXSLT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></title><programlisting class="po-block e303 e303" xml:space="preserve"><textual class="po-textual">
 
 
&lt;?XML version='1.0'?&gt;
&lt;XSL:stylesheet 
    version="3.0" 
    xmlns:XSL="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;XSL:template match="/"&gt;
        &lt;XSL:variable name="f1" select="
            function($x as xs:integer) as (function(xs:integer) as xs:integer){
                    function ($y as xs:integer) as xs:integer{
                        $x*$x + $y * $y
                    }
            }
        "/&gt;
        &lt;XSL:value-of select="$f1(2)(3)"/&gt; 
&lt;/XSL:template&gt;
&lt;/XSL:stylesheet&gt;
                      
            
        </textual></programlisting></figure><textual class="po-textual"> Here we have a non-XML syntax child language (XPath 3.0 </textual><xref class="po-milestone e304 e304" linkend="XPath3"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">) embedded in a XML syntax language (XSLT). </textual></para><para class="po-block e305 e305"><textual class="po-textual">XQueryX</textual><xref class="po-milestone e306 e306" linkend="XQueryX"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> represents a more "pure" XSLT syntax in that even
            XPath expressions within XQueryX are fully decomposed and marked up as XML. However
            XQueryX is generally considered unreadable and unwritable by humans except in very small
            doses. At some point, adding markup or expressing every semantic detail as markup
            becomes untenable - at-least for humans.</textual></para><para class="po-block e307 e307"><textual class="po-textual">As an example just the select expression in the above XSLT translated to XQueryX is shown
        </textual><figure class="po-container e308 e308" xml:id="XQueryXXSLT"><programlisting class="po-block e309 e309" xml:space="preserve"><textual class="po-textual">

&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:inlineFunctionItemExpr&gt;
        &lt;xqx:paramList&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;x&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
        &lt;/xqx:paramList&gt;
        &lt;xqx:typeDeclaration&gt;
          &lt;xqx:parenthesizedItemType&gt;
            &lt;xqx:typedFunctionTest&gt;
              &lt;xqx:paramTypeList&gt;
                &lt;xqx:sequenceType&gt;
                  &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
                &lt;/xqx:sequenceType&gt;
              &lt;/xqx:paramTypeList&gt;
              &lt;xqx:sequenceType&gt;
                &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
              &lt;/xqx:sequenceType&gt;
            &lt;/xqx:typedFunctionTest&gt;
          &lt;/xqx:parenthesizedItemType&gt;
        &lt;/xqx:typeDeclaration&gt;
        &lt;xqx:functionBody&gt;
          &lt;xqx:inlineFunctionItemExpr&gt;
            &lt;xqx:paramList&gt;
              &lt;xqx:param&gt;
                &lt;xqx:varName&gt;y&lt;/xqx:varName&gt;
                &lt;xqx:typeDeclaration&gt;
                  &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
                &lt;/xqx:typeDeclaration&gt;
              &lt;/xqx:param&gt;
            &lt;/xqx:paramList&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:atomicType xqx:prefix="xs"&gt;integer&lt;/xqx:atomicType&gt;
            &lt;/xqx:typeDeclaration&gt;
            &lt;xqx:functionBody&gt;
              &lt;xqx:addOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:multiplyOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;x&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;x&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:multiplyOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:multiplyOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;y&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;y&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:multiplyOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:addOp&gt;
            &lt;/xqx:functionBody&gt;
          &lt;/xqx:inlineFunctionItemExpr&gt;
        &lt;/xqx:functionBody&gt;
      &lt;/xqx:inlineFunctionItemExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;

                
                
                
            </textual></programlisting><caption class="po-container e310 e310"><para class="po-block e311 e311"><textual class="po-textual">Translation from XQuery 3.0 to XQueryX </textual><xref class="po-milestone e312 e312" linkend="XQueryX2"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref></para></caption></figure><textual class="po-textual">
            
        </textual></para><section class="po-hcontainer e313 e313"><title class="po-block e314 e314"><textual class="po-textual">Further down the path of an XML Syntax</textual></title><para class="po-block e315 e315"><textual class="po-textual">There is much further we can take this exploration. For examples the comments are
                still unreferenced; they appear inline with code but no clear semantic reference to
                which they refer. That could be solved with cross reference tags. Statements and
                expressions are yet to be fully decomposed. The full syntax of statements and
                expressions could be marked up. If we keep on this path we will end up where XSLT
                and ultimately XQueryX have. A fully semantic markup that in this author's  opinion
                is impractical for human authoring and consumption.</textual></para><para class="po-block e316 e316"><textual class="po-textual">There is a reason that programming languages are largely expressed using more
                unstructured human readable syntax. That is that humans are ultimately the main
                creators and consumers of the language. Even though a computer has to interpret the
                language, so it must be quite explicit and unambiguous, humans have to write, read,
                maintain, and debug it.</textual></para><para class="po-block e317 e317"><textual class="po-textual">That doesn't mean there isn't room for improvement. As we have seen with markup
                such as JavaDoc there is still a strong desire to add layers of semantics to
                programming languages. A universal markup for programming languages may well be a
                practical and useful tool.  And possibly some compromise between no markup and fully
                semantically marked up might be a 'sweet spot' for some programming
                languages.</textual></para></section><section class="po-hcontainer e318 e318"><title class="po-block e319 e319"><textual class="po-textual">The Golden Road (to Unlimited Devotion)</textual></title><para class="po-block e320 e320"><textual class="po-textual"> Like the song of the same name </textual><xref class="po-milestone e321 e321" linkend="GoldenRoad"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual">, applying markup to
                Programming languages to it's full conclusion may require unlimited devotion. Even
                if every single statement, expression and symbol was marked up the resulting
                information would not include all the information that a compiler understands by
                parsing the plain text due to the compiler understanding the semantics of the entire
                corpus. This means even if we follow the Golden Road to it's end we wont end up with
                the information a language specific parser does. So in a way this seems like a dead
                end road. What can markup gain us? </textual></para><para class="po-block e322 e322"><textual class="po-textual">
               With Text markup, the data added by markup supplies us with generally not available with the original text.  With Programming Languages, the information contained in the program statements themselves
              is ultimately available, even if deeply hidden in the bowls of the compiler.  Perhaps it is best if that in information be pulled from the compiler's grasp instead of duplicated by markup.
              But what of information the compiler discards, is unaware, or is unimportant to the compiler but useful to humans ?  That may be a realm ripe for markup.
           </textual></para><para class="po-block e323 e323"><textual class="po-textual">So what information in software and it's incarnation in programming language text
                not available or not of interest to the compiler? Clearly comments and documentation
                come to mind. But there is more</textual></para><para class="po-block e324 e324"><textual class="po-textual">The very tedium of engineering required to construct a good program, and which the
                compiler assumes but generally not part of the compilers undemanding, or discarded
                as part of the compilation may be ripe for markup: information such as the structure
                of a complex system. What pieces need to go together and what is irrelevant (and may
                be changed). What is the rationale behind seemingly arbitrary choices such as naming
                conventions, compilation units and program source structure. For example in version
                of troff </textual><xref class="po-milestone e325 e325" linkend="Troff"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> which I was fortunate enough to port in the mid
                80's from Unix to VMS, the C Source was written (originally ported from PDP11
                assembly) assuming that global variables were aligned in memory in the order
                declared. This was implicit but required by the program and broke in exiting ways on
                VMS where the C compiler ordered variables alphabetically not by declaration order.
                Perhaps Markup may have indicated this requirement?</textual></para><para class="po-block e326 e326"><textual class="po-textual">Sometimes certain functions, variables and comments should belong together.
                Markup could indicate this where a compiler does not. Functions describing a public
                and private interface could be indicated in languages where the compiler does not
                provide such a facility. There are many areas where the compiler is ignorant but the
                programmer has important knowledge. Markup could be effectively used for these
                situations.</textual></para></section></section><section class="po-hcontainer e327 e327"><title class="po-block e328 e328"><textual class="po-textual">Conclusion: To Mark up or Not to mark up</textual></title><para class="po-block e329 e329"><textual class="po-textual">The path to marking up programming languages is neither straight nor objective. There
            are branches along the path that depending on the techniques and goals may or may not be
            easy or valuable. There is certainly pain (cost) to be had by adding markup, but there
            is also potential value. Much of the rationale behind Text markup also applies to
            programming languages and we have shown that similar techniques and tools can be used
            for both. But as with Text, it is a continuum not an absolute. Depending on your effort,
            willingness, perspective and desire for additional value, varying types and amounts of
            markup may be appropriate. Traditional embedded markup can be easily simplified by this
            approach. I have shown that one can approach the problem incrementally - even some
            markup can be valuable yet easy to introduce. The hardest part is accepting and
            implementing the inversion of programming language </textual><emphasis class="po-inline e330 e330"><textual class="po-textual">within</textual></emphasis><textual class="po-textual"> markup as
            opposed to markup within the programming language syntax. By placing the language within
            the markup we are able to use standard markup processing tools largely programming
            language agnostic as well as keeping the source relatively clean compared to embedding
            markup within language constructs. Another issue is when markup overlaps the information
            inherent in the programming language itself. It is unlikely that programmers will be
            willing to duplicate information the compiler will understand without the markup.
            Furthermore it is generally a bad engineering practice to duplicate information as the
            multiple versions lead to maintenance issues (two watches rarely show the same
            time).</textual></para><para class="po-block e331 e331"><textual class="po-textual">On the other hand, existing programing language and markup tools are readily available to accomplish many
            tasks with little effort. XML-centric editors could be used for programming IDE's, with some limits.
            Common programming IDE's can be enhanced with understanding of markup. The compilation
            tool-chain has for decades been easily extendible to transformation of source documents.
            By taking the initial step and effort of tooling up for marked up source there is a wide
            spectrum of value that can be achieved with incremental cost.   But and at what value
            and at what cost ?</textual></para><section class="po-hcontainer e332 e332"><title class="po-block e333 e333"><textual class="po-textual">Markup for high value and low cost</textual></title><para class="po-block e334 e334"><textual class="po-textual">Examining what types of markup are required to encode what semantic information
                leads one wondering "is it worth it?". There are some goals with moderate value that
                can be achieved at low cost, but much which can be achieved only with very high cost
                if at all, and the value is debatable.</textual></para><para class="po-block e335 e335"><textual class="po-textual">Presuming you consider the retooling necessary for wrapping programming languages within markup (inversion) a fixed sunk cost, what goals can be achieved with minimal additional work?</textual></para><section class="po-hcontainer e336 e336"><title class="po-block e337 e337"><textual class="po-textual">Source Structural Decomposition</textual></title><para class="po-block e338 e338"><textual class="po-textual">With fairly minor markup, mainly wrapping all classes, methods and their
                    corresponding dependent variable declarations and comments in a kind of
                    structural markup, structural decomposition can be achieved.</textual></para><para class="po-block e339 e339"><textual class="po-textual">By this I mean you can automatically recognize and reorganize your codebase. This
                    might be useful for bulk refactoring or for presenting a database of searchable
                    code snippets. But how useful and reliable will this actually be? Without full
                    knowledge of dependencies (data, call and usage graphs) and subtle details of
                    the language, reorganizing based on simple source file structural boundaries is
                    fragile. It has some value but also high risk.</textual></para><para class="po-block e340 e340"><textual class="po-textual">Another use for structural markup is providing an IDE with the ability to do
                    outlining, expansion, collapsing, indexing etc. This is definitely a useful
                    feature. However language specific IDE's commonly provide this feature already.
                    The main advantage of achieving this through markup would be to be able to use a
                    language agnostic editor, such as shown through the examples using Oxygen. But
                    since there exists language specific IDE's that do this as good or better than
                    could be done with simple structural markup alone, it's unlikely a developer
                    would move from a more functional IDE to a less functional one especially
                    considering the cost of adding the markup.</textual></para></section><section class="po-hcontainer e341 e341"><title class="po-block e342 e342"><textual class="po-textual">Associating comments with language elements</textual></title><para class="po-block e343 e343"><textual class="po-textual">As discussed previously, it is not at all obvious to a computer parser what
                    comments are associated with which language elements. Even the simple case of
                    "block comments precede the element" and "inline comments are after the element"
                    is frequently incorrect. A human usually has no problems detecting the
                    association but without additional hints (markup) a computer often cannot get
                    this right.</textual></para><para class="po-block e344 e344"><textual class="po-textual">A little markup (low cost) could provide this association easily by containment.
                    However what value is this? To human readers it's little value because they can
                    already usually associate the comment by context. To commuters it might
                    ultimately be of some, but it's not immediately obvious. Since the compiler
                    cannot readily interpret the comment, other uses need to be found where this
                    association is valuable.</textual></para></section><section class="po-hcontainer e345 e345"><title class="po-block e346 e346"><textual class="po-textual">Adding additional structure</textual></title><para class="po-block e347 e347"><textual class="po-textual">Not all necessary structure of a program is available as explicit notation in every
                    programming language. A simple example is the separation of variable declaration
                    and use. Variables generally need to be declared before use but it is up to the
                    engineer to arrange the source such that the compiler sees the declaration
                    first. Markup may aid in making explicit the implicit dependencies of pieces of
                    software in order to create structure beyond that which the language allows.
                    Such a markup structure could facilitate refactoring, dependency analysis and
                    reuse.</textual></para></section></section></section><section class="po-hcontainer e348 e348"><title class="po-block e349 e349"><textual class="po-textual">Markup with high cost</textual></title><section class="po-hcontainer e350 e350"><title class="po-block e351 e351"><textual class="po-textual">Semantic Analysis</textual></title><para class="po-block e352 e352"><textual class="po-textual">The really high value possibilities lie in the area of semantic analysis. For
                    example call graphs, dependency checkers, flow control graphs, algorithmic
                    analysis etc. These are areas that could be of extremely high value.
                    Unfortunately they have high cost in terms of both markup and execution. To do something as simple as a call graph,
                    all expressions and identifiers would need to be marked up. In addition full
                    language semantics would need to be understood in order to resolve overloads,
                    virtual functions, namespaces, indirect calls etc. It is not sufficient to
                    simply mark up every bit of the program; a semantic analysis requires full
                    understanding of the language itself.</textual></para><para class="po-block e353 e353"><textual class="po-textual">Essentially the entire semantics of the program would need to be marked up and
                available to analysis. To achieve this would require markup as verbose complex as
                XQueryX </textual><xref class="po-milestone e354 e354" linkend="XQueryXXSLT"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> as well as a knowledge engine that understands
                the meaning of the language constructs.  </textual></para><para class="po-block e355 e355"><textual class="po-textual">Experience has shown that people do not want to author in this level of markup.
                    The history of mathematics and programming languages has generally been towards
                    concise and humanly readable syntax. In fact many of the 'pure XML' syntax
                    languages like XSLT and XProc</textual><xref class="po-milestone e356 e356" linkend="XProc"><textual class="po-textual">Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao Pippo! Ciao</textual></xref><textual class="po-textual"> have active groups
                    attempting to reduce the markup in the language providing for an alternate
                    syntax which does not require the verbosity of XML markup. Furthermore
                    describing the information inferred by a compilation of programming languages is
                    extremely difficult in pure XML vocabularies. So even if the syntax was
                    available to XML tools as fully marked up software, the semantics the
                    representation is difficult.</textual></para></section></section><section class="po-hcontainer e357 e357"><title class="po-block e358 e358"><textual class="po-textual">Extracting semantics</textual></title><para class="po-block e359 e359"><textual class="po-textual">As discussed there are a few areas which adding markup may be of little effort and
                add value that is not already explicit in the language. In particular are in areas
                of documentation, comments and higher level structures. However the highest value, as well as the highest
                cost is in the semantics of the underlying language structure which is surfaced by
                the actual language syntax.</textual></para><para class="po-block e360 e360"><textual class="po-textual">Unlike text however this semantics is entirely computable. Unfortunately it is
                largely inaccessible as it lies in the black hole of the interior of the compiler or
                language specific parser and generally unavailable for other purposes.</textual></para><para class="po-block e361 e361"><textual class="po-textual">Suppose that were not true.  Suppose that the semantics represented by a program were exposed in a unified syntax such as XML and in a open public schema.  Then most of the high value hoped for by making up programming languages could be achieved instead by extracting the semantic model from the compiler.</textual></para><para class="po-block e362 e362"><textual class="po-textual">This could lead to a very powerful ecosystem of software analysis not bounded by
                the constraint and narrow vision of the compiler. Such a data model should not be
                difficult to generate by enhancements to existing tools as all the knowledge is
                already available to the compiler. It could be supplemented by additional markup
                within the source and then combined to produce a comprehensive data-model that can
                be stored, queried, analyzed and processed using existing markup tool-chains.</textual></para><para class="po-block e363 e363"><textual class="po-textual">I propose that the difficult work is in designing such a schema and encoding the
                semantics of the language. Can there be a reasonable schema representing a
                programing language model which is language neutral? Or do different languages need
                their own schemas. Perhaps a tree of schemas with some common representation of
                generic programming language constructs with branches for particular languages. In
                addition, to do semantic analysis requires understanding the semantics of the model
                not just the structure.</textual></para><para class="po-block e364 e364"><textual class="po-textual">Again we can look to the Text Markup work for design patterns on how to do accomplish this.  The road is still open for inquiring minds and brave souls.</textual></para></section><section class="po-hcontainer e365 e365"><title class="po-block e366 e366"><textual class="po-textual">Conclusion: Proposals</textual></title><para class="po-block e367 e367"><textual class="po-textual">I suggest that there is value and small cost in marking up programming languages for
            the purposes of comments, documentation, and most importantly, to make explicit the
            higher level structure of the program which the programming language itself does not
            have the capability to describe. However for annotation which duplicates the information
            inferable from the programming language itself the cost is high and the value is likely
            negative due to inherent problems with information duplication. The method with least
            impact on existing tools is embedded markup within comments. However I suggest that
            since there is high value and fairly low cost, if implemented widely, that the concept
            of Transparent Markup be considered and implemented as an option by tools makers
            (particularly in IDE's).</textual></para><para class="po-block e368 e368"><textual class="po-textual">However the information contained within the programming language itself is of high
                value outside simply compilation. I propose that it is worthwhile to expose this
                information sourced in the text but only currently available in the compiler as
                explicitly generated data. Compilers should be enhanced to optionally generate
                standardized meta information as a byproduct of compilation.</textual></para><para class="po-block e369 e369"><textual class="po-textual">The combination of high level source markup, and compiler generated information
                could then be utilized by analysis processes. This presents some key areas for
                future research and consideration.</textual></para><section class="po-hcontainer e370 e370"><title class="po-block e371 e371"><textual class="po-textual">Standardized Transparent Markup</textual></title><para class="po-block e372 e372"><textual class="po-textual">A standardized schema or family of schemas for transparent markup should be
                considered. If a standard or convention is developed this may encourage tools makers
                to adopt the concept into IDE's and other components of the software lifecycle. It
                should be a fairly easy task to accept a form of transparent markup - even if only
                to completely ignore it. Simply allowing software to be marked up without
                interfering with the toolchain opens it to more diverse purposes. If built into
                IDE's then problems with escaping special markup characters could be minimized. The
                IDE itself may be able to add some markup based on out of band information such as
                project structure. Rich text editing support could be added for sections which allow
                it such as currently supported in JavaDoc. The co-existence of transparent markup
                with the entire toolchain of software development should be a fairly low cost and
                high value proposal.</textual></para></section><section class="po-hcontainer e373 e373"><title class="po-block e374 e374"><textual class="po-textual">Standardized In-Comment markup</textual></title><para class="po-block e375 e375"><textual class="po-textual">If transparent markup is too high a cost, then consider standardiazing in-comment markup similar to JavaDoc.  I feel that in todays cross language environments that a language neutral method of marking up languages is valuable.
              While it is difficult to get perfect parsing/extraction of comments from programming languages, it is not that difficult to get "usually works" extraction of comments.
              For example any line that starts with only punction characters then includes say "@@" could indicate a markup tag.
                  </textual><figure class="po-container e376 e376" xml:id="InlineMarkup"><programlisting class="po-block e377 e377" xml:space="preserve"><textual class="po-textual">
   // @@Tag  A C or C++ or Java inline comment tag
   /*
    * @@Tag A C or C++ or Java block comment tag
    */
   (: @@Tag An XQuery comment Tag :)
   # A Shell or Perl comment tag
   &lt;!-- @@Tag An XML comment tag --&gt;
 
    </textual></programlisting></figure><textual class="po-textual">
              
              </textual></para><para class="po-block e378 e378"><textual class="po-textual">The choice of @@ is largely arbitrary. Any similar token that is reasonably
                parsable within language comments could be used, including plain XML or perhaps a
                infrequently used PI like &lt;?CODEUP?&gt; . While this is not as technically desirable
                as pure transparent markup - because of the chance of mis-parsing actual code as
                markup, the cost is significantly lower as it would not impact existing software
                lifecycle (compilers, editors etc.) so may be a pragmatic compromise. </textual></para></section><section class="po-hcontainer e379 e379"><title class="po-block e380 e380"><textual class="po-textual">Standardized compiler data structure outputs</textual></title><para class="po-block e381 e381"><textual class="po-textual">Compilers should not be black holes for information. A standard or convention
                for representing the information consumed and produced by compilers should be
                considered. If there was a common data structure defined for representing the
                semantic information derived as a side effect of compilation then compilers could
                output this as part of the compilation process and expose this rich source of data
                for other uses. Designing a structure or schema which can be easily produced by a
                variety of compilers as well as usefully consumed by other processes may be a
                challenging task, but I suggest it is an avenue that could lead to great rewards. </textual></para></section><section class="po-hcontainer e382 e382"><title class="po-block e383 e383"><textual class="po-textual">Put it all together</textual></title><para class="po-block e384 e384"><textual class="po-textual">In conclusion I propose that a mixture of additional annotation or markup on
                programming languages, in combination with more visibility to the byproducts of
                compilation together could expose great previously untapped value. More work is
                necessary to investigate and implement real world uses for this hidden knowledge but
                the potential is large. Lets get to work !</textual></para></section></section><bibliography class="po-hcontainer e385 e385"><title class="po-block e386 e386"><textual class="po-textual">References</textual></title><bibliomixed class="po-block e387 e387" xml:id="XSLT" xreflabel="XSLT"><textual class="po-textual">XSL Transformations (XSLT) </textual><link class="po-inline e388 e388" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xslt" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xslt</textual></link></bibliomixed><bibliomixed class="po-block e389 e389" xml:id="XQuery" xreflabel="XQuery"><textual class="po-textual">XQuery 1.0: An XML Query Language </textual><link class="po-inline e390 e390" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xquery/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xquery/</textual></link></bibliomixed><bibliomixed class="po-block e391 e391" xml:id="JavaScript" xreflabel="JavaScript"><textual class="po-textual">JavaScript aka ECMA-262 </textual><link class="po-inline e392 e392" xlink:actuate="onRequest" xlink:href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</textual></link></bibliomixed><bibliomixed class="po-block e393 e393" xml:id="C" xreflabel="C"><textual class="po-textual">The C programming language aka ISO/IEC 9899 </textual><link class="po-inline e394 e394" xlink:actuate="onRequest" xlink:href="http://www.open-std.org/JTC1/SC22/WG14/www/standards.html#9899" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.open-std.org/JTC1/SC22/WG14/www/standards.html#9899</textual></link></bibliomixed><bibliomixed class="po-block e395 e395" xml:id="Java" xreflabel="Java"><textual class="po-textual">The Java programming </textual><link class="po-inline e396 e396" xlink:actuate="onRequest" xlink:href="http://www.java.com" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.java.com</textual></link></bibliomixed><bibliomixed class="po-block e397 e397" xml:id="SQL" xreflabel="SQL"><textual class="po-textual">Structured Query Language (SQL) </textual><link class="po-inline e398 e398" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/SQL" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/SQL</textual></link></bibliomixed><bibliomixed class="po-block e399 e399" xml:id="Oxygen" xreflabel="Oxygen"><textual class="po-textual">Oxygen XML Editor </textual><link class="po-inline e400 e400" xlink:actuate="onRequest" xlink:href="http://www.oxygenxml.com/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oxygenxml.com</textual></link></bibliomixed><bibliomixed class="po-block e401 e401" xml:id="Eclipse" xreflabel="Eclipse"><textual class="po-textual">The Eclipse Foundation </textual><link class="po-inline e402 e402" xlink:actuate="onRequest" xlink:href="http://www.eclipse.org/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.eclipse.org/</textual></link></bibliomixed><bibliomixed class="po-block e403 e403" xml:id="Emacs" xreflabel="Emacs"><textual class="po-textual">GNU Emacs </textual><link class="po-inline e404 e404" xlink:actuate="onRequest" xlink:href="http://www.gnu.org/software/emacs/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.gnu.org/software/emacs/</textual></link></bibliomixed><bibliomixed class="po-block e405 e405" xml:id="CSS" xreflabel="CSS"><textual class="po-textual">Cascading Style Sheets </textual><link class="po-inline e406 e406" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Cascading_Style_Sheets" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Cascading_Style_Sheets</textual></link></bibliomixed><bibliomixed class="po-block e407 e407" xml:id="XPath3" xreflabel="XPath"><textual class="po-textual">XML Path Language (XPath) 3.0 </textual><link class="po-inline e408 e408" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xpath-30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xpath-30/</textual></link></bibliomixed><bibliomixed class="po-block e409 e409" xml:id="XProc" xreflabel="XProc"><textual class="po-textual">XProc: An XML Pipeline Language </textual><link class="po-inline e410 e410" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xproc/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xproc/</textual></link></bibliomixed><bibliomixed class="po-block e411 e411" xml:id="type-ref-1" xreflabel="XMLLinkedIn1"><textual class="po-textual">Dave Patterson on LinkedIn Groups XML and Related Technologies Network, Jan 2012		</textual></bibliomixed><bibliomixed class="po-block e412 e412" xml:id="type-ref-2" xreflabel="XMLLinkedIn2"><textual class="po-textual">Paul Monk on LinkedIn Groups XML and Related Technologies Network, Jan 2012	    </textual></bibliomixed><bibliomixed class="po-block e413 e413" xml:id="type-ref-3" xreflabel="XMLLinkedIn3"><textual class="po-textual">Sean Rushing on LinkedIn Groups XML and Related Technologies Network, Jan 2012	    </textual></bibliomixed><bibliomixed class="po-block e414 e414" xml:id="type-ref-4" xreflabel="XMLDev1"><textual class="po-textual">Oscar Vives on xml-dev@lists.xml.org, 2012-01-19</textual></bibliomixed><bibliomixed class="po-block e415 e415" xml:id="type-ref-5" xreflabel="XMLDev2"><textual class="po-textual">Philip Fennell on xml-dev@lists.xml.org, 2012-01-19</textual></bibliomixed><bibliomixed class="po-block e416 e416" xml:id="type-ref-6" xreflabel="XMLDev3"><textual class="po-textual">Liam Quin on xml-dev@lists.xml.org, 2012-01-19</textual></bibliomixed><bibliomixed class="po-block e417 e417" xml:id="type-ref-7" xreflabel="XMLDev4"><textual class="po-textual">Henry S. Thompson on xml-dev@lists.xml.org, 2012-01-19</textual></bibliomixed><bibliomixed class="po-block e418 e418" xml:id="type-ref-8" xreflabel="XMLDev5"><textual class="po-textual">Liam Quin on xml-dev@lists.xml.org, 2012-01-19</textual></bibliomixed><bibliomixed class="po-block e419 e419" xml:id="JavaDoc" xreflabel="JavaDoc"><textual class="po-textual">JavaDoc </textual><link class="po-inline e420 e420" xlink:actuate="onRequest" xlink:href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html</textual></link></bibliomixed><bibliomixed class="po-block e421 e421" xml:id="HTML" xreflabel="HTML"><textual class="po-textual">HyperText Markup Language - HTML 4.01 Specification </textual><link class="po-inline e422 e422" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/html4/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/html4/</textual></link></bibliomixed><bibliomixed class="po-block e423 e423" xml:id="XPathXSLT" xreflabel="XPathXSLT"><textual class="po-textual">XPath in XSLT </textual><link class="po-inline e424 e424" xlink:actuate="onRequest" xlink:href="http://www.stylusstudio.com/tutorials/intro-xslt-3.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.stylusstudio.com/tutorials/intro-xslt-3.html</textual></link></bibliomixed><bibliomixed class="po-block e425 e425" xml:id="XQueryX" xreflabel="XQueryX"><textual class="po-textual">XML Syntax for XQuery 1.0 (XQueryX) </textual><link class="po-inline e426 e426" xlink:actuate="onRequest" xlink:href="http://www.w3.org/TR/xqueryx/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/TR/xqueryx/</textual></link></bibliomixed><bibliomixed class="po-block e427 e427" xml:id="XQueryX2" xreflabel="XQueryXApplet"><textual class="po-textual">From the Grammar Test page for XQuery 3.0 </textual><link class="po-inline e428 e428" xlink:actuate="onRequest" xlink:href="http://www.w3.org/2011/08/qt-applets/xquery30/" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.w3.org/2011/08/qt-applets/xquery30/</textual></link></bibliomixed><bibliomixed class="po-block e429 e429" xml:id="LitP" xreflabel="LiterateProg"><textual class="po-textual">Knuth, Donald E. (1992). </textual><emphasis class="po-inline e430 e430"><textual class="po-textual">Literate Programming.</textual></emphasis><textual class="po-textual"> ISBN: 978-0-937073-80-3</textual></bibliomixed><bibliomixed class="po-block e431 e431" xml:id="GoldenRoad" xreflabel="GoldenRoad"><textual class="po-textual">The Golden Road (To Unlimited Devotion)
                </textual><link class="po-inline e432 e432" xlink:actuate="onRequest" xlink:href="http://artsites.ucsc.edu/GDead/agdl/goldroad.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://artsites.ucsc.edu/GDead/agdl/goldroad.html</textual></link></bibliomixed><bibliomixed class="po-block e433 e433" xml:id="Troff" xreflabel="Troff"><textual class="po-textual">troff - a text formatting language </textual><link class="po-inline e434 e434" xlink:actuate="onRequest" xlink:href="http://en.wikipedia.org/wiki/Troff" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://en.wikipedia.org/wiki/Troff</textual></link></bibliomixed><bibliomixed class="po-block e435 e435" xml:id="XsltOpt" xreflabel="XsltOpt"><textual class="po-textual">Writing an XSLT Optimizer in XSLT </textual><link class="po-inline e436 e436" xlink:actuate="onRequest" xlink:href="http://www.saxonica.com/papers/Extreme2007/EML2007Kay01.html" xlink:show="new" xlink:type="simple"><textual class="po-textual">http://www.saxonica.com/papers/Extreme2007/EML2007Kay01.html</textual></link></bibliomixed></bibliography></article></classedDocument>